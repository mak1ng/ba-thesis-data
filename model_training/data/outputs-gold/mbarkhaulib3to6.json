[EOL] import builtins [EOL] def hello ( who ) : [EOL] print ( f" [string] { who }" ) [EOL]	0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] import setuptools [EOL] [EOL] [EOL] def project_path ( * sub_paths ) : [EOL] project_dirpath = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] return os . path . join ( project_dirpath , * sub_paths ) [EOL] [EOL] [EOL] def read ( * sub_paths ) : [EOL] with open ( project_path ( * sub_paths ) , mode = [string] ) as fobj : [EOL] return fobj . read ( ) . decode ( [string] ) [EOL] [EOL] [EOL] install_requires = [ line . strip ( ) for line in read ( [string] , [string] ) . splitlines ( ) if line . strip ( ) and not line . startswith ( [string] ) ] [EOL] [EOL] [EOL] packages = setuptools . find_packages ( project_path ( [string] ) ) [EOL] package_dir = { [string] : [string] } [EOL] [EOL] [EOL] if any ( arg . startswith ( [string] ) for arg in sys . argv ) : [EOL] try : [EOL] import lib3to6 [EOL] package_dir = lib3to6 . fix ( package_dir , install_requires = install_requires ) [EOL] except ImportError as ex : [EOL] if [string] in str ( ex ) : [EOL] print ( [string] ) [EOL] else : [EOL] raise [EOL] [EOL] [EOL] long_description = ( read ( [string] ) + [string] + read ( [string] ) ) [EOL] [EOL] [EOL] setuptools . setup ( name = [string] , license = [string] , author = [string] , author_email = [string] , url = [string] , version = [string] , keywords = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , packages = packages , package_dir = package_dir , install_requires = install_requires , entry_points = [string] , python_requires = [string] , zip_safe = True , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from . utils import parsedump_ast [EOL] from . utils import parsedump_source [EOL] from . packaging import fix [EOL] from . transpile import transpile_module [EOL] [EOL] __version__ = [string] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Tuple , Dict , List , Any , Optional , Type [EOL] import ast [EOL] import typing [EOL] import builtins [EOL] import _ast [EOL] import src [EOL] import ast [EOL] import typing as typ [EOL] import builtins [EOL] [EOL] PackageName = str [EOL] PackageDirectory = str [EOL] PackageDir = typ . Dict [ PackageName , PackageDirectory ] [EOL] [EOL] InstallRequires = typ . Optional [ typ . Set [ str ] ] [EOL] [EOL] [EOL] ConstantNodeTypes = ( ast . Constant , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if hasattr ( ast , [string] ) : [EOL] ConstantNodeTypes += ( ast . Num , ast . Str , ast . Bytes , ast . NameConstant , ast . Ellipsis ) [EOL] [EOL] [EOL] LeafNodeTypes = ConstantNodeTypes + ( ast . Name , ast . cmpop , ast . boolop , ast . operator , ast . unaryop , ast . expr_context , ) [EOL] [EOL] [EOL] ContainerNodes = ( ast . List , ast . Set , ast . Tuple ) [EOL] [EOL] [EOL] class BuildConfig ( typ . NamedTuple ) : [EOL] [EOL] target_version = ... [comment] [EOL] cache_enabled = ... [EOL] default_mode = ... [EOL] fixers = ... [EOL] checkers = ... [EOL] install_requires = ... [EOL] [EOL] [EOL] class BuildContext ( typ . NamedTuple ) : [EOL] [EOL] cfg = ... [EOL] filepath = ... [EOL] [EOL] [EOL] def init_build_context ( target_version = [string] , cache_enabled = True , default_mode = [string] , fixers = [string] , checkers = [string] , install_requires = None , filepath = [string] , ) : [EOL] cfg = BuildConfig ( target_version = target_version , cache_enabled = cache_enabled , default_mode = default_mode , fixers = fixers , checkers = checkers , install_requires = install_requires , ) [EOL] return BuildContext ( cfg = cfg , filepath = filepath ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class InvalidPackage ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def get_node_lineno ( node = None , parent = None ) : [EOL] if isinstance ( node , ( ast . stmt , ast . expr ) ) : [EOL] return node . lineno [EOL] if isinstance ( parent , ( ast . stmt , ast . expr ) ) : [EOL] return parent . lineno [EOL] return - [number] [EOL] [EOL] [EOL] class CheckError ( Exception ) : [EOL] [EOL] lineno = ... [EOL] [EOL] def __init__ ( self , msg , node = None , parent = None ) : [EOL] self . lineno = get_node_lineno ( node , parent ) [EOL] super ( ) . __init__ ( msg ) [EOL] [EOL] [EOL] class FixerError ( Exception ) : [EOL] [EOL] msg = ... [EOL] node = ... [EOL] module = ... [EOL] [EOL] def __init__ ( self , msg , node , module = None ) : [EOL] self . msg = msg [EOL] self . node = node [EOL] self . module = module [EOL] super ( ) . __init__ ( msg ) [EOL] [EOL] [EOL] class VersionInfo : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] apply_since = ... [EOL] apply_until = ... [EOL] works_since = ... [EOL] works_until = ... [EOL] [EOL] def __init__ ( self , apply_since = [string] , apply_until = None , works_since = None , works_until = None , ) : [EOL] [EOL] self . apply_since = [ int ( part ) for part in apply_since . split ( [string] ) ] [EOL] if apply_until is None : [EOL] self . apply_until = None [EOL] else : [EOL] self . apply_until = [ int ( part ) for part in apply_until . split ( [string] ) ] [EOL] [EOL] if works_since is None : [EOL] [comment] [EOL] [comment] [EOL] self . works_since = self . apply_since [EOL] else : [EOL] self . works_since = [ int ( part ) for part in works_since . split ( [string] ) ] [EOL] [EOL] if works_until is None : [EOL] self . works_until = None [EOL] else : [EOL] self . works_until = [ int ( part ) for part in works_until . split ( [string] ) ] [EOL] [EOL] def is_required_for ( self , version ) : [EOL] version_num = [ int ( part ) for part in version . split ( [string] ) ] [EOL] apply_until = self . apply_until [EOL] if apply_until and apply_until < version_num : [EOL] return False [EOL] return self . apply_since <= version_num [EOL] [EOL] def is_compatible_with ( self , version ) : [EOL] version_num = [ int ( part ) for part in version . split ( [string] ) ] [EOL] works_since = self . works_since [EOL] works_until = self . works_until [EOL] if works_since and version_num < works_since : [EOL] return False [EOL] if works_until and works_until < version_num : [EOL] return False [EOL] return True [EOL] [EOL] def is_applicable_to ( self , source_version , target_version ) : [EOL] return self . is_required_for ( target_version ) and self . is_compatible_with ( source_version ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class ImportDecl ( typ . NamedTuple ) : [EOL] module_name = ... [EOL] import_name = ... [EOL] py2_module_name = ... [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] BUILTIN_NAMES = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] [comment] [EOL] [EOL] BUILTIN_NAMES . update ( [ name for name in dir ( builtins ) if not name . startswith ( [string] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[ast.Constant],...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[ast.Constant],...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 $typing.Tuple[typing.Type[ast.Constant],...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[_ast.List],typing.Type[_ast.Set],typing.Type[_ast.Tuple]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $InstallRequires$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BuildConfig$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $BuildContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $ast.AST$ 0 0 0 $ast.AST$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $ast.AST$ 0 $ast.AST$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $ast.AST$ 0 0 0 $typing.Optional[ast.Module]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $_ast.AST$ 0 $typing.Optional[_ast.Module]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $_ast.AST$ 0 $_ast.AST$ 0 0 0 $typing.Optional[_ast.Module]$ 0 $typing.Optional[_ast.Module]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 $typing.Optional[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 $typing.Optional[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import ast [EOL] import common [EOL] import ast [EOL] [EOL] from . import common [EOL] [EOL] [EOL] class CheckerBase : [EOL] [EOL] [comment] [EOL] version_info = common . VersionInfo ( ) [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $common.VersionInfo$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Tuple [EOL] import common [EOL] import ast [EOL] import typing [EOL] import builtins [EOL] import _ast [EOL] import src [EOL] import ast [EOL] import typing as typ [EOL] [EOL] import astor [EOL] [EOL] from . import common [EOL] from . import transpile [EOL] [EOL] [comment] [EOL] [comment] [EOL] NodeOrNodelist = typ . Union [ ast . AST , typ . List [ typ . Any ] ] [EOL] [EOL] [EOL] [comment] [EOL] def dump_ast ( node , annotate_fields = True , include_attributes = False , indent = [string] , ) : [EOL] [docstring] [EOL] [EOL] def _format ( node , level = [number] ) : [EOL] [comment] [EOL] if isinstance ( node , ast . AST ) : [EOL] fields = [ ( a , _format ( b , level + [number] ) ) for a , b in ast . iter_fields ( node ) ] [EOL] if include_attributes and node . _attributes : [EOL] fields . extend ( [ ( a , _format ( getattr ( node , a ) , level + [number] ) ) for a in node . _attributes ] ) [EOL] [EOL] if annotate_fields : [EOL] field_parts = [ [string] % field for field in fields ] [EOL] else : [EOL] field_parts = [ b for a , b in fields ] [EOL] [EOL] node_name = node . __class__ . __name__ [EOL] is_short_node = len ( field_parts ) <= [number] or isinstance ( node , ( ast . Name , ast . Num , ast . Str , ast . Bytes , ast . alias ) ) [EOL] [EOL] if is_short_node : [EOL] return node_name + [string] + [string] . join ( field_parts ) + [string] [EOL] [EOL] lines = [ node_name + [string] ] [EOL] for part in field_parts : [EOL] lines . append ( ( indent * level ) + part + [string] ) [EOL] lines . append ( ( indent * ( level - [number] ) ) + [string] ) [EOL] return [string] . join ( lines ) [EOL] elif isinstance ( node , list ) : [EOL] subnodes = node [EOL] if len ( subnodes ) == [number] : [EOL] return [string] [EOL] [EOL] if len ( subnodes ) == [number] : [EOL] return [string] + _format ( subnodes [ [number] ] , level ) + [string] [EOL] [EOL] lines = [ indent * level + _format ( subnode , level + [number] ) + [string] for subnode in subnodes ] [EOL] return [string] + [string] . join ( lines ) + [string] + indent * ( level - [number] ) + [string] [EOL] return repr ( node ) [EOL] [EOL] if isinstance ( node , ( ast . AST , list ) ) : [EOL] return _format ( node ) [EOL] else : [EOL] raise TypeError ( [string] % node . __class__ . __name__ ) [EOL] [EOL] [EOL] def clean_whitespace ( fixture_str ) : [EOL] if fixture_str . strip ( ) . count ( [string] ) == [number] : [EOL] return fixture_str . strip ( ) [EOL] [EOL] fixture_lines = [ line for line in fixture_str . splitlines ( ) if line . strip ( ) ] [EOL] line_indents = [ len ( line ) - len ( line . lstrip ( ) ) for line in fixture_lines ] [EOL] if not any ( line_indents ) or min ( line_indents ) == [number] : [EOL] return fixture_str [EOL] [EOL] indent = min ( line_indents ) [EOL] dedented_lines = [ line [ indent : ] for line in fixture_lines ] [EOL] return [string] . join ( dedented_lines ) . strip ( ) + [string] [EOL] [EOL] [EOL] def parse_stmt ( code ) : [EOL] module = ast . parse ( code ) [EOL] assert len ( module . body ) == [number] [EOL] return module . body [ [number] ] [EOL] [EOL] [EOL] def parsedump_ast ( code , mode = [string] , ** kwargs ) : [EOL] [docstring] [EOL] node = ast . parse ( clean_whitespace ( code ) , mode = mode ) [EOL] return dump_ast ( node , ** kwargs ) [EOL] [EOL] [EOL] def parsedump_source ( code , mode = [string] ) : [EOL] node = ast . parse ( clean_whitespace ( code ) , mode = mode ) [EOL] return astor . to_source ( node ) [EOL] [EOL] [EOL] def transpile_and_dump ( ctx , module_str ) : [EOL] module_str = clean_whitespace ( module_str ) [EOL] header = transpile . parse_module_header ( module_str , ctx . cfg . target_version ) [EOL] result_str = transpile . transpile_module ( ctx , module_str ) [EOL] return header . coding , header . text , result_str [EOL] [EOL] [EOL] def has_base_class ( cls_node , module_name = None , base_class_name = None ) : [EOL] if not ( module_name or base_class_name ) : [EOL] return False [EOL] [EOL] for base in cls_node . bases : [EOL] if isinstance ( base , ast . Attribute ) : [EOL] val = base . value [EOL] if isinstance ( val , ast . Name ) and val . id == module_name and base . attr == base_class_name : [EOL] return True [EOL] [EOL] if isinstance ( base , ast . Name ) and base . id == base_class_name : [EOL] return True [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.stmt$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import ast [EOL] import _ast [EOL] import src [EOL] import ast [EOL] [EOL] from . import common [EOL] from . import fixer_base as fb [EOL] [EOL] [EOL] def _try_fallback ( node , fallback_node ) : [EOL] return ast . Try ( body = [ node ] , handlers = [ ast . ExceptHandler ( type = ast . Name ( id = [string] , ctx = ast . Load ( ) ) , name = None , body = [ fallback_node ] ) ] , orelse = [ ] , finalbody = [ ] , ) [EOL] [EOL] [EOL] class ModuleImportFallbackFixerBase ( fb . TransformerFixerBase ) : [EOL] [EOL] new_name = ... [EOL] old_name = ... [EOL] [EOL] def visit_Import ( self , node ) : [EOL] if len ( node . names ) != [number] : [EOL] return node [EOL] [EOL] alias = node . names [ [number] ] [EOL] if alias . name != self . new_name : [EOL] return node [EOL] [EOL] if alias . asname : [EOL] asname = alias . asname [EOL] elif [string] in self . new_name : [EOL] asname = self . new_name . replace ( [string] , [string] ) [EOL] msg = ( f" [string] { self . new_name } [string] " f" [string] { self . new_name } [string] { asname } [string] " ) [EOL] raise common . CheckError ( msg , node ) [EOL] else : [EOL] asname = self . new_name [EOL] [EOL] return _try_fallback ( node , ast . Import ( names = [ ast . alias ( name = self . old_name , asname = asname ) ] ) ) [EOL] [EOL] def visit_ImportFrom ( self , node ) : [EOL] if node . module != self . new_name : [EOL] return node [EOL] [EOL] return _try_fallback ( node , ast . ImportFrom ( module = self . old_name , names = node . names , level = node . level ) ) [EOL] [EOL] [EOL] class ConfigParserImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class SocketServerImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class BuiltinsImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class QueueImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class CopyRegImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class WinRegImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class ReprLibImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class ThreadImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class DummyThreadImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class HttpCookiejarImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class UrllibParseImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class UrllibRequestImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class UrllibErrorImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class UrllibRobotParserImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class XMLRPCClientImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class XmlrpcServerImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class HtmlParserImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class HttpClientImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class HttpCookiesImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class PickleImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class DbmGnuImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class EmailMimeBaseImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class EmailMimeImageImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class EmailMimeMultipartImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class EmailMimeNonmultipartImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class EmailMimeTextImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterDialogImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterScrolledTextImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterTixImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterTtkImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterConstantsImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterDndImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterColorchooserImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterCommonDialogImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterFontImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class TkinterMessageboxImportFallbackFixer ( ModuleImportFallbackFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.Try$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $ast.stmt$ 0 0 0 $ast.Import$ 0 0 0 0 0 0 $ast.Import$ 0 0 0 0 0 0 0 0 $ast.Import$ 0 0 $_ast.alias$ 0 $ast.Import$ 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 0 0 $ast.Import$ 0 0 0 $_ast.alias$ 0 $builtins.str$ 0 0 $builtins.str$ 0 $_ast.alias$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $ast.Import$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $ast.Import$ 0 0 0 0 0 0 0 0 0 0 $_ast.alias$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $ast.stmt$ 0 0 0 $ast.ImportFrom$ 0 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Tuple , Iterable , Set , Dict , Union , Any , List , Optional , Type [EOL] import sys [EOL] import fixer_base [EOL] import common [EOL] import checker_base [EOL] import ast [EOL] import typing [EOL] import builtins [EOL] import _ast [EOL] import src [EOL] import re [EOL] import ast [EOL] import sys [EOL] import typing as typ [EOL] [EOL] import astor [EOL] [EOL] from . import utils [EOL] from . import common [EOL] from . import fixers [EOL] from . import checkers [EOL] from . import fixer_base as fb [EOL] from . import checker_base as cb [EOL] [EOL] DEFAULT_SOURCE_ENCODING_DECLARATION = [string] [EOL] [EOL] DEFAULT_SOURCE_ENCODING = [string] [EOL] [EOL] DEFAULT_TARGET_VERSION = [string] [EOL] [EOL] [comment] [EOL] SOURCE_ENCODING_PATTERN = [string] [EOL] [EOL] SOURCE_ENCODING_RE = re . compile ( SOURCE_ENCODING_PATTERN , re . VERBOSE ) [EOL] [EOL] [EOL] MODE_MARKER_PATTERN = [string] [EOL] [EOL] MODE_MARKER_RE = re . compile ( MODE_MARKER_PATTERN , flags = re . MULTILINE ) [EOL] [EOL] [EOL] class ModuleHeader ( typ . NamedTuple ) : [EOL] [EOL] coding = ... [EOL] text = ... [EOL] [EOL] [EOL] def _parse_header_line ( line_data , coding ) : [EOL] if isinstance ( line_data , bytes ) : [EOL] return line_data . decode ( coding ) [EOL] if isinstance ( line_data , str ) : [EOL] return line_data [EOL] [EOL] [comment] [EOL] bad_type = type ( line_data ) [EOL] errmsg = f" [string] { bad_type } [string] " [EOL] raise TypeError ( errmsg ) [EOL] [EOL] [EOL] def parse_module_header ( module_source , target_version ) : [EOL] shebang = False [EOL] coding = None [EOL] line = ... [EOL] [EOL] header_lines = [ ] [EOL] [EOL] for i , line_data in enumerate ( module_source . splitlines ( ) ) : [EOL] assert isinstance ( line_data , ( bytes , str ) ) [EOL] line = _parse_header_line ( line_data , coding or DEFAULT_SOURCE_ENCODING ) [EOL] [EOL] if i < [number] : [EOL] if i == [number] and line . startswith ( [string] ) and [string] in line : [EOL] shebang = True [EOL] else : [EOL] match = SOURCE_ENCODING_RE . match ( line ) [EOL] if match : [EOL] coding = match . group ( [string] ) . strip ( ) [EOL] [EOL] if line . rstrip ( ) and not line . rstrip ( ) . startswith ( [string] ) : [EOL] break [EOL] [EOL] header_lines . append ( line ) [EOL] [EOL] if coding is None : [EOL] coding = DEFAULT_SOURCE_ENCODING [EOL] if target_version < [string] : [EOL] coding_decl = DEFAULT_SOURCE_ENCODING_DECLARATION . format ( coding ) [EOL] if shebang : [EOL] header_lines . insert ( [number] , coding_decl ) [EOL] else : [EOL] header_lines . insert ( [number] , coding_decl ) [EOL] [EOL] header_text = [string] . join ( header_lines ) + [string] [EOL] return ModuleHeader ( coding , header_text ) [EOL] [EOL] [EOL] CheckerType = typ . Type [ cb . CheckerBase ] [EOL] [EOL] FixerType = typ . Type [ fb . FixerBase ] [EOL] [EOL] CheckerOrFixer = typ . Union [ CheckerType , FixerType ] [EOL] [EOL] [EOL] def normalize_name ( name ) : [EOL] name = name . strip ( ) . lower ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] if name . endswith ( [string] ) : [EOL] name = name [ : - len ( [string] ) ] [EOL] if name . endswith ( [string] ) : [EOL] name = name [ : - len ( [string] ) ] [EOL] return name [EOL] [EOL] [EOL] def get_available_classes ( module , clazz ) : [EOL] [EOL] assert isinstance ( clazz , type ) [EOL] clazz_name = clazz . __name__ [EOL] assert clazz_name . endswith ( [string] ) [EOL] [EOL] maybe_classes = { name : getattr ( module , name ) for name in dir ( module ) if not name . endswith ( clazz_name ) } [EOL] [EOL] return { normalize_name ( attr_name ) : attr for attr_name , attr in maybe_classes . items ( ) if isinstance ( attr , type ) and issubclass ( attr , clazz ) } [EOL] [EOL] [EOL] FuzzyNames = typ . Union [ str , typ . List [ str ] ] [EOL] [EOL] [EOL] def get_selected_names ( names , available_names ) : [EOL] if isinstance ( names , str ) : [EOL] names_list = names . split ( [string] ) [EOL] else : [EOL] names_list = names [EOL] [EOL] selected_names = [ normalize_name ( name ) for name in names_list if name . strip ( ) ] [EOL] [EOL] if selected_names : [EOL] for name in selected_names : [EOL] assert name in available_names [EOL] else : [EOL] [comment] [EOL] selected_names = sorted ( available_names ) [EOL] [EOL] assert len ( selected_names ) > [number] [EOL] [EOL] return selected_names [EOL] [EOL] [EOL] def iter_fuzzy_selected_checkers ( names ) : [EOL] available_classes = get_available_classes ( checkers , cb . CheckerBase ) [EOL] selected_names = get_selected_names ( names , set ( available_classes ) ) [EOL] for name in selected_names : [EOL] checker_type = typ . cast ( CheckerType , available_classes [ name ] ) [EOL] yield checker_type ( ) [EOL] [EOL] [EOL] def iter_fuzzy_selected_fixers ( names ) : [EOL] available_classes = get_available_classes ( fixers , fb . FixerBase ) [EOL] selected_names = get_selected_names ( names , set ( available_classes ) ) [EOL] for name in selected_names : [EOL] fixer_type = typ . cast ( FixerType , available_classes [ name ] ) [EOL] yield fixer_type ( ) [EOL] [EOL] [EOL] def find_import_decls ( node ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not isinstance ( node , ( ast . Try , ast . Import , ast . ImportFrom ) ) : [EOL] return [EOL] [EOL] if isinstance ( node , ast . Try ) : [EOL] if not ( len ( node . body ) == [number] and len ( node . handlers ) == [number] ) : [EOL] return [EOL] [EOL] except_handler = node . handlers [ [number] ] [EOL] [EOL] is_import_error_handler = ( isinstance ( except_handler . type , ast . Name ) [EOL] and except_handler . type . id == [string] [EOL] and len ( except_handler . body ) == [number] ) [EOL] if not is_import_error_handler : [EOL] return [EOL] [EOL] maybe_import = node . body [ [number] ] [EOL] if not isinstance ( maybe_import , ast . Import ) : [EOL] return [EOL] [EOL] default_import = maybe_import [EOL] [EOL] maybe_fallback_import = except_handler . body [ [number] ] [EOL] if not isinstance ( maybe_fallback_import , ast . Import ) : [EOL] return [EOL] [EOL] fallback_import = maybe_fallback_import [EOL] [EOL] if len ( default_import . names ) == [number] and len ( fallback_import . names ) == [number] : [EOL] default_import_alias = default_import . names [ [number] ] [EOL] fallback_import_alias = fallback_import . names [ [number] ] [EOL] yield common . ImportDecl ( default_import_alias . name , default_import_alias . asname , fallback_import_alias . name ) [EOL] [EOL] elif isinstance ( node , ast . Import ) : [EOL] if len ( node . names ) != [number] and any ( alias . asname for alias in node . names ) : [EOL] [comment] [EOL] return [EOL] [EOL] alias = node . names [ [number] ] [EOL] yield common . ImportDecl ( alias . name , None , None ) [EOL] elif isinstance ( node , ast . ImportFrom ) : [EOL] if any ( alias . asname for alias in node . names ) : [EOL] [comment] [EOL] return [EOL] [EOL] module_name = node . module [EOL] if not module_name : [EOL] return [EOL] [EOL] for alias in node . names : [EOL] yield common . ImportDecl ( module_name , alias . name , None ) [EOL] [EOL] [EOL] def parse_imports ( tree ) : [EOL] future_imports_offset = [number] [EOL] imports_end_offset = [number] [EOL] [EOL] import_decls = set ( ) [EOL] [EOL] for body_offset , node in enumerate ( tree . body ) : [EOL] is_docstring = ( body_offset == [number] and isinstance ( node , ast . Expr ) and isinstance ( node . value , ast . Str ) ) [EOL] if is_docstring : [EOL] future_imports_offset = body_offset + [number] [EOL] imports_end_offset = body_offset + [number] [EOL] continue [EOL] [EOL] node_import_decls = list ( find_import_decls ( node ) ) [EOL] if not node_import_decls : [EOL] [comment] [EOL] [comment] [EOL] break [EOL] [EOL] for import_decl in node_import_decls : [EOL] if import_decl . module_name == [string] : [EOL] future_imports_offset = body_offset [EOL] imports_end_offset = body_offset [EOL] import_decls . add ( import_decl ) [EOL] [EOL] return ( future_imports_offset , imports_end_offset , import_decls ) [EOL] [EOL] [EOL] def add_required_imports ( tree , required_imports ) : [EOL] [docstring] [EOL] ( future_imports_offset , imports_end_offset , found_imports ) = parse_imports ( tree ) [EOL] [EOL] missing_imports = sorted ( required_imports - found_imports ) [EOL] [EOL] import_node = ... [EOL] for import_decl in missing_imports : [EOL] if import_decl . import_name is None : [EOL] import_node = ast . Import ( names = [ ast . alias ( name = import_decl . module_name , asname = None ) ] ) [EOL] else : [EOL] import_node = ast . ImportFrom ( module = import_decl . module_name , level = [number] , names = [ ast . alias ( name = import_decl . import_name , asname = None ) ] , ) [EOL] [EOL] if import_decl . py2_module_name : [EOL] asname = import_decl . import_name or import_decl . module_name [EOL] fallback_import = ast . Import ( names = [ ast . alias ( name = import_decl . py2_module_name , asname = asname ) ] ) [EOL] import_node = ast . Try ( body = [ import_node ] , handlers = [ ast . ExceptHandler ( type = ast . Name ( id = [string] , ctx = ast . Load ( ) ) , name = None , body = [ fallback_import ] , ) ] , orelse = [ ] , finalbody = [ ] , ) [EOL] [EOL] if import_decl . module_name == [string] : [EOL] tree . body . insert ( future_imports_offset , import_node ) [EOL] future_imports_offset += [number] [EOL] imports_end_offset += [number] [EOL] else : [EOL] tree . body . insert ( imports_end_offset , import_node ) [EOL] imports_end_offset += [number] [EOL] [EOL] [EOL] def add_module_declarations ( tree , module_declarations ) : [EOL] [docstring] [EOL] _ , imports_end_offset , _ = parse_imports ( tree ) [EOL] [EOL] for decl_str in sorted ( module_declarations ) : [EOL] decl_node = utils . parse_stmt ( decl_str ) [EOL] tree . body . insert ( imports_end_offset + [number] , decl_node ) [EOL] imports_end_offset += [number] [EOL] [EOL] [EOL] def transpile_module ( ctx , module_source ) : [EOL] _module_header = module_source . split ( [string] , [number] ) [ [number] ] [EOL] _module_header = _module_header . split ( [string] , [number] ) [ [number] ] [EOL] _module_header = _module_header . split ( [string] , [number] ) [ [number] ] [EOL] [EOL] lib3to6_mode_marker = MODE_MARKER_RE . search ( _module_header ) [EOL] if lib3to6_mode_marker : [EOL] mode = lib3to6_mode_marker . group ( [string] ) [EOL] else : [EOL] mode = ctx . cfg . default_mode [EOL] [EOL] if mode == [string] : [EOL] return module_source [EOL] [EOL] checker_names = ctx . cfg . checkers [EOL] fixer_names = ctx . cfg . fixers [EOL] module_tree = ast . parse ( module_source ) [EOL] required_imports = set ( ) [EOL] module_declarations = set ( ) [EOL] [EOL] ver = sys . version_info [EOL] source_version = f"{ ver . major } [string] { ver . minor }" [EOL] target_version = ctx . cfg . target_version [EOL] [EOL] for checker in iter_fuzzy_selected_checkers ( checker_names ) : [EOL] if checker . version_info . is_applicable_to ( source_version , target_version ) : [EOL] checker ( ctx , module_tree ) [EOL] [EOL] for fixer in iter_fuzzy_selected_fixers ( fixer_names ) : [EOL] if fixer . version_info . is_applicable_to ( source_version , target_version ) : [EOL] maybe_fixed_module = fixer ( ctx , module_tree ) [EOL] if maybe_fixed_module is None : [EOL] raise Exception ( f" [string] { type ( fixer ) . __name__ }" ) [EOL] required_imports . update ( fixer . required_imports ) [EOL] module_declarations . update ( fixer . module_declarations ) [EOL] module_tree = maybe_fixed_module [EOL] [EOL] if any ( required_imports ) : [EOL] add_required_imports ( module_tree , required_imports ) [EOL] if any ( module_declarations ) : [EOL] add_module_declarations ( module_tree , module_declarations ) [EOL] header = parse_module_header ( module_source , target_version ) [EOL] return header . text + [string] . join ( astor . to_source ( module_tree ) ) [EOL] [EOL] [EOL] def transpile_module_data ( ctx , module_source_data ) : [EOL] target_version = ctx . cfg . target_version [EOL] header = parse_module_header ( module_source_data , target_version ) [EOL] module_source = module_source_data . decode ( header . coding ) [EOL] fixed_module_source = transpile_module ( ctx , module_source ) [EOL] return fixed_module_source . encode ( header . coding ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ModuleHeader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,CheckerOrFixer]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[checker_base.CheckerBase]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[fixer_base.FixerBase]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[common.ImportDecl]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,typing.Set[common.ImportDecl]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Set , Union , Any , Iterator , List , Optional , Type [EOL] import builtins [EOL] import ast [EOL] import typing [EOL] import common [EOL] import _ast [EOL] import src [EOL] import ast [EOL] import sys [EOL] import typing as typ [EOL] [EOL] from . import utils [EOL] from . import common [EOL] from . import fixer_base as fb [EOL] from . fixers_future import DivisionFutureFixer [EOL] from . fixers_future import GeneratorsFutureFixer [EOL] from . fixers_future import AnnotationsFutureFixer [EOL] from . fixers_future import NestedScopesFutureFixer [EOL] from . fixers_future import GeneratorStopFutureFixer [EOL] from . fixers_future import PrintFunctionFutureFixer [EOL] from . fixers_future import WithStatementFutureFixer [EOL] from . fixers_future import AbsoluteImportFutureFixer [EOL] from . fixers_future import UnicodeLiteralsFutureFixer [EOL] from . fixers_future import RemoveUnsupportedFuturesFixer [EOL] from . fixers_builtin_rename import UnichrToChrFixer [EOL] from . fixers_builtin_rename import UnicodeToStrFixer [EOL] from . fixers_builtin_rename import XrangeToRangeFixer [EOL] from . fixers_builtin_rename import RawInputToInputFixer [EOL] from . fixers_import_fallback import QueueImportFallbackFixer [EOL] from . fixers_import_fallback import DbmGnuImportFallbackFixer [EOL] from . fixers_import_fallback import PickleImportFallbackFixer [EOL] from . fixers_import_fallback import ThreadImportFallbackFixer [EOL] from . fixers_import_fallback import WinRegImportFallbackFixer [EOL] from . fixers_import_fallback import CopyRegImportFallbackFixer [EOL] from . fixers_import_fallback import ReprLibImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterImportFallbackFixer [EOL] from . fixers_import_fallback import BuiltinsImportFallbackFixer [EOL] from . fixers_import_fallback import HtmlParserImportFallbackFixer [EOL] from . fixers_import_fallback import HttpClientImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterDndImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterTixImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterTtkImportFallbackFixer [EOL] from . fixers_import_fallback import DummyThreadImportFallbackFixer [EOL] from . fixers_import_fallback import HttpCookiesImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterFontImportFallbackFixer [EOL] from . fixers_import_fallback import UrllibErrorImportFallbackFixer [EOL] from . fixers_import_fallback import UrllibParseImportFallbackFixer [EOL] from . fixers_import_fallback import ConfigParserImportFallbackFixer [EOL] from . fixers_import_fallback import SocketServerImportFallbackFixer [EOL] from . fixers_import_fallback import XMLRPCClientImportFallbackFixer [EOL] from . fixers_import_fallback import XmlrpcServerImportFallbackFixer [EOL] from . fixers_import_fallback import EmailMimeBaseImportFallbackFixer [EOL] from . fixers_import_fallback import EmailMimeTextImportFallbackFixer [EOL] from . fixers_import_fallback import HttpCookiejarImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterDialogImportFallbackFixer [EOL] from . fixers_import_fallback import UrllibRequestImportFallbackFixer [EOL] from . fixers_import_fallback import EmailMimeImageImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterConstantsImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterMessageboxImportFallbackFixer [EOL] from . fixers_import_fallback import UrllibRobotParserImportFallbackFixer [EOL] from . fixers_import_fallback import EmailMimeMultipartImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterColorchooserImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterCommonDialogImportFallbackFixer [EOL] from . fixers_import_fallback import TkinterScrolledTextImportFallbackFixer [EOL] from . fixers_import_fallback import EmailMimeNonmultipartImportFallbackFixer [EOL] from . fixers_unpacking_generalization import UnpackingGeneralizationsFixer [EOL] [EOL] AstStr = getattr ( ast , [string] , ast . Constant ) [EOL] [EOL] [EOL] def is_const_node ( node ) : [EOL] return node is None or any ( isinstance ( node , cntype ) for cntype in common . ConstantNodeTypes ) [EOL] [EOL] [EOL] Elt = typ . Union [ ast . Name , ast . Constant , ast . Subscript ] [EOL] Elts = typ . List [ Elt ] [EOL] [EOL] [EOL] AnnoNode = typ . Union [ ast . arg , ast . AnnAssign , ast . FunctionDef ] [EOL] [EOL] [EOL] class _FRAFContext : [EOL] [EOL] local_classes = ... [EOL] known_classes = ... [EOL] [EOL] def __init__ ( self , local_classes ) : [EOL] self . local_classes = local_classes [EOL] self . known_classes = set ( ) [EOL] [EOL] def is_forward_ref ( self , name ) : [EOL] return name in self . local_classes and name not in self . known_classes [EOL] [EOL] def update_index_elts ( self , elts ) : [EOL] [comment] [EOL] [comment] [EOL] for i in range ( len ( elts ) ) : [EOL] elt = elts [ i ] [EOL] if is_const_node ( elt ) or isinstance ( elt , ast . Attribute ) : [EOL] continue [EOL] [EOL] if isinstance ( elt , ast . Name ) : [EOL] if self . is_forward_ref ( elt . id ) : [EOL] elts [ i ] = ast . Constant ( elt . id ) [EOL] elif isinstance ( elt , ast . Subscript ) : [EOL] idx = elt . slice [EOL] assert isinstance ( idx , ast . Index ) [EOL] self . update_index ( idx ) [EOL] else : [EOL] msg = f" [string] { type ( elt ) }" [EOL] raise NotImplementedError ( msg ) [EOL] [EOL] def update_index ( self , idx ) : [EOL] val = idx . value [EOL] if is_const_node ( val ) or isinstance ( val , ast . Attribute ) : [EOL] return [EOL] [EOL] if isinstance ( val , ast . Name ) : [EOL] if self . is_forward_ref ( val . id ) : [EOL] idx . value = AstStr ( val . id ) [EOL] elif isinstance ( val , ast . Subscript ) : [EOL] sub_idx = val . slice [EOL] assert isinstance ( sub_idx , ast . Index ) [EOL] self . update_index ( sub_idx ) [EOL] elif isinstance ( val , ast . Tuple ) : [EOL] elts = typ . cast ( Elts , val . elts ) [EOL] self . update_index_elts ( elts ) [EOL] else : [EOL] msg = f" [string] { type ( val ) }" [EOL] raise NotImplementedError ( msg ) [EOL] [EOL] def update_annotation_refs ( self , node , attrname ) : [EOL] anno = getattr ( node , attrname ) [EOL] if is_const_node ( anno ) or isinstance ( anno , ast . Attribute ) : [EOL] return [EOL] [EOL] if isinstance ( anno , ast . Name ) : [EOL] if self . is_forward_ref ( anno . id ) : [EOL] setattr ( node , attrname , AstStr ( anno . id ) ) [EOL] elif isinstance ( anno , ast . Subscript ) : [EOL] idx = anno . slice [EOL] assert isinstance ( idx , ast . Index ) [EOL] self . update_index ( idx ) [EOL] else : [EOL] msg = f" [string] { type ( anno ) }" [EOL] raise NotImplementedError ( msg ) [EOL] [EOL] def remove_forward_references ( self , node ) : [EOL] for sub_node in ast . iter_child_nodes ( node ) : [EOL] if isinstance ( sub_node , ast . FunctionDef ) : [EOL] self . update_annotation_refs ( sub_node , [string] ) [EOL] [EOL] for arg in sub_node . args . args : [EOL] self . update_annotation_refs ( arg , [string] ) [EOL] for arg in sub_node . args . kwonlyargs : [EOL] self . update_annotation_refs ( arg , [string] ) [EOL] [EOL] kwarg = sub_node . args . kwarg [EOL] if kwarg : [EOL] self . update_annotation_refs ( kwarg , [string] ) [EOL] vararg = sub_node . args . vararg [EOL] if vararg : [EOL] self . update_annotation_refs ( vararg , [string] ) [EOL] elif isinstance ( sub_node , ast . AnnAssign ) : [EOL] self . update_annotation_refs ( sub_node , [string] ) [EOL] [EOL] if hasattr ( sub_node , [string] ) : [EOL] self . remove_forward_references ( sub_node ) [EOL] [EOL] if isinstance ( sub_node , ast . ClassDef ) : [EOL] self . known_classes . add ( sub_node . name ) [EOL] [EOL] [EOL] class ForwardReferenceAnnotationsFixer ( fb . FixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] local_classes = set ( ) [EOL] for node in ast . walk ( tree ) : [EOL] if isinstance ( node , ast . ClassDef ) : [EOL] local_classes . add ( node . name ) [EOL] [EOL] _FRAFContext ( local_classes ) . remove_forward_references ( tree ) [EOL] return tree [EOL] [EOL] [EOL] class RemoveFunctionDefAnnotationsFixer ( fb . FixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] for node in ast . walk ( tree ) : [EOL] if isinstance ( node , ast . FunctionDef ) : [EOL] node . returns = None [EOL] for arg in node . args . args : [EOL] arg . annotation = None [EOL] for arg in node . args . kwonlyargs : [EOL] arg . annotation = None [EOL] [EOL] if node . args . kwarg : [EOL] node . args . kwarg . annotation = None [EOL] if node . args . vararg : [EOL] node . args . vararg . annotation = None [EOL] [EOL] return tree [EOL] [EOL] [EOL] class RemoveAnnAssignFixer ( fb . TransformerFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] [EOL] @ staticmethod def visit_AnnAssign ( node ) : [EOL] tgt_node = node . target [EOL] if not isinstance ( tgt_node , ( ast . Name , ast . Attribute ) ) : [EOL] raise common . FixerError ( [string] , tgt_node ) [EOL] [EOL] value = ... [EOL] if node . value is None : [EOL] value = ast . NameConstant ( value = None ) [EOL] else : [EOL] value = node . value [EOL] return ast . Assign ( targets = [ tgt_node ] , value = value ) [EOL] [EOL] [EOL] class ShortToLongFormSuperFixer ( fb . TransformerFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] [EOL] @ staticmethod def visit_ClassDef ( node ) : [EOL] for maybe_method in ast . walk ( node ) : [EOL] if not isinstance ( maybe_method , ast . FunctionDef ) : [EOL] continue [EOL] [EOL] method = maybe_method [EOL] method_args = method . args [EOL] if len ( method_args . args ) == [number] : [EOL] continue [EOL] [EOL] self_arg = method_args . args [ [number] ] [EOL] [EOL] for maybe_super_call in ast . walk ( method ) : [EOL] if not isinstance ( maybe_super_call , ast . Call ) : [EOL] continue [EOL] [EOL] func_node = maybe_super_call . func [EOL] if not ( isinstance ( func_node , ast . Name ) and func_node . id == [string] ) : [EOL] continue [EOL] [EOL] super_call = maybe_super_call [EOL] if len ( super_call . args ) > [number] : [EOL] continue [EOL] [EOL] super_call . args = [ ast . Name ( id = node . name , ctx = ast . Load ( ) ) , ast . Name ( id = self_arg . arg , ctx = ast . Load ( ) ) , ] [EOL] return node [EOL] [EOL] [EOL] class InlineKWOnlyArgsFixer ( fb . TransformerFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] [EOL] @ staticmethod def visit_FunctionDef ( node ) : [EOL] if not node . args . kwonlyargs : [EOL] return node [EOL] [EOL] if node . args . kwarg : [EOL] kw_name = node . args . kwarg . arg [EOL] else : [EOL] kw_name = [string] [EOL] node . args . kwarg = ast . arg ( arg = kw_name , annotation = None ) [EOL] [EOL] kwonlyargs = reversed ( node . args . kwonlyargs ) [EOL] kw_defaults = reversed ( node . args . kw_defaults ) [EOL] for arg , default in zip ( kwonlyargs , kw_defaults ) : [EOL] arg_name = arg . arg [EOL] node_value = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if default is None : [EOL] node_value = ast . Subscript ( value = ast . Name ( id = kw_name , ctx = ast . Load ( ) ) , slice = ast . Index ( value = AstStr ( s = arg_name ) ) , ctx = ast . Load ( ) , ) [EOL] elif not isinstance ( default , common . ConstantNodeTypes ) : [EOL] msg = ( f" [string] " f" [string] { default } [string] { arg_name }" ) [EOL] raise common . FixerError ( msg , node ) [EOL] else : [EOL] node_value = ast . Call ( func = ast . Attribute ( value = ast . Name ( id = kw_name , ctx = ast . Load ( ) ) , attr = [string] , ctx = ast . Load ( ) ) , args = [ AstStr ( s = arg_name ) , default ] , keywords = [ ] , ) [EOL] [EOL] new_node = ast . Assign ( targets = [ ast . Name ( id = arg_name , ctx = ast . Store ( ) ) ] , value = node_value ) [EOL] [EOL] node . body . insert ( [number] , new_node ) [EOL] [EOL] node . args . kwonlyargs = [ ] [EOL] [EOL] return node [EOL] [EOL] [EOL] class NewStyleClassesFixer ( fb . TransformerFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] [EOL] def visit_ClassDef ( self , node ) : [EOL] self . generic_visit ( node ) [EOL] if len ( node . bases ) == [number] : [EOL] node . bases . append ( ast . Name ( id = [string] , ctx = ast . Load ( ) ) ) [EOL] return node [EOL] [EOL] [EOL] class ItertoolsBuiltinsFixer ( fb . TransformerFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] , works_until = [string] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] new_tree = self . visit ( tree ) [EOL] return typ . cast ( ast . Module , new_tree ) [EOL] [EOL] def visit_Name ( self , node ) : [EOL] if isinstance ( node . ctx , ast . Load ) and node . id in ( [string] , [string] , [string] ) : [EOL] self . required_imports . add ( common . ImportDecl ( [string] , None , None ) ) [EOL] global_decl = f"{ node . id } [string] { node . id } [string] { node . id } [string] " [EOL] self . module_declarations . add ( global_decl ) [EOL] [EOL] return node [EOL] [EOL] [EOL] class NamedTupleClassToAssignFixer ( fb . TransformerFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] [EOL] _typing_module_name = ... [EOL] _namedtuple_class_name = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . _typing_module_name = None [EOL] self . _namedtuple_class_name = None [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def visit_ImportFrom ( self , node ) : [EOL] if node . module == [string] : [EOL] for alias in node . names : [EOL] if alias . name == [string] : [EOL] if alias . asname is None : [EOL] self . _namedtuple_class_name = alias . name [EOL] else : [EOL] self . _namedtuple_class_name = alias . asname [EOL] [EOL] return node [EOL] [EOL] def visit_Import ( self , node ) : [EOL] for alias in node . names : [EOL] if alias . name == [string] : [EOL] if alias . asname is None : [EOL] self . _typing_module_name = alias . name [EOL] else : [EOL] self . _typing_module_name = alias . asname [EOL] return node [EOL] [EOL] def visit_ClassDef ( self , node ) : [EOL] self . generic_visit ( node ) [EOL] if len ( node . bases ) == [number] : [EOL] return node [EOL] [EOL] if not ( self . _typing_module_name or self . _namedtuple_class_name ) : [EOL] [comment] [EOL] return node [EOL] [EOL] has_namedtuple_base = utils . has_base_class ( node , self . _typing_module_name , self . _namedtuple_class_name or [string] ) [EOL] if not has_namedtuple_base : [EOL] return node [EOL] [EOL] func = ... [EOL] [EOL] if self . _typing_module_name : [EOL] func = ast . Attribute ( value = ast . Name ( id = self . _typing_module_name , ctx = ast . Load ( ) ) , attr = [string] , ctx = ast . Load ( ) , ) [EOL] elif self . _namedtuple_class_name : [EOL] func = ast . Name ( id = self . _namedtuple_class_name , ctx = ast . Load ( ) ) [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] elts = [ ] [EOL] [EOL] for assign in node . body : [EOL] if not isinstance ( assign , ast . AnnAssign ) : [EOL] continue [EOL] tgt = assign . target [EOL] if not isinstance ( tgt , ast . Name ) : [EOL] continue [EOL] [EOL] elts . append ( ast . Tuple ( elts = [ AstStr ( s = tgt . id ) , assign . annotation ] , ctx = ast . Load ( ) ) ) [EOL] [EOL] return ast . Assign ( targets = [ ast . Name ( id = node . name , ctx = ast . Store ( ) ) ] , value = ast . Call ( func = func , args = [ AstStr ( s = node . name ) , ast . List ( elts = elts , ctx = ast . Load ( ) ) ] , keywords = [ ] , ) , ) [EOL] [EOL] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] from . fixers_fstring import FStringToStrFormatFixer [EOL] else : [EOL] FStringToStrFormatFixer = None [EOL] [EOL] [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] from . fixers_namedexpr import NamedExprFixer [EOL] else : [EOL] NamedExprFixer = None [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.FunctionDef$ 0 $ast.FunctionDef$ 0 0 0 0 0 $ast.FunctionDef$ 0 0 0 $typing.Iterator[_ast.arg]$ 0 0 0 $ast.FunctionDef$ 0 0 0 $ast.FunctionDef$ 0 0 0 0 0 0 $builtins.str$ 0 $ast.FunctionDef$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $ast.FunctionDef$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Iterator[_ast.arg]$ 0 0 0 $ast.FunctionDef$ 0 0 0 $typing.Iterator[_ast.arg]$ 0 0 $typing.Iterator[typing.Optional[_ast.expr]]$ 0 0 0 $ast.FunctionDef$ 0 0 0 $typing.Iterator[typing.Optional[_ast.expr]]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[_ast.arg]$ 0 $typing.Iterator[typing.Optional[_ast.expr]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $ast.FunctionDef$ 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Assign$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 $ast.FunctionDef$ 0 0 0 0 0 0 0 $_ast.Assign$ 0 0 0 $ast.FunctionDef$ 0 0 0 $typing.Iterator[_ast.arg]$ 0 0 0 0 0 0 $ast.FunctionDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 $typing.Any$ 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Union[ast.Name,ast.Attribute]$ 0 0 0 $ast.Name$ 0 0 0 0 0 0 $ast.Name$ 0 0 0 0 0 0 0 0 $ast.Name$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $ast.Name$ 0 0 0 0 0 $ast.Name$ 0 0 0 0 0 $ast.Name$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $ast.Name$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 $ast.ImportFrom$ 0 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $ast.ImportFrom$ 0 0 0 $ast.Import$ 0 0 0 $ast.Import$ 0 0 0 0 0 0 $ast.Import$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $ast.Import$ 0 0 0 $typing.Union[ast.ClassDef,ast.Assign]$ 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 $builtins.bool$ 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $ast.ClassDef$ 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ast.Tuple]$ 0 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 0 $typing.List[ast.Tuple]$ 0 0 0 0 0 0 0 $typing.List[ast.Tuple]$ 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 $typing.Union[_ast.Attribute,_ast.Name]$ 0 0 0 0 0 0 0 0 $ast.ClassDef$ 0 0 0 0 0 0 0 0 $typing.List[ast.Tuple]$ 0 $typing.List[ast.Tuple]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , List , Any , Iterator , Optional , Sequence [EOL] import logging [EOL] import io [EOL] import src [EOL] import typing [EOL] import builtins [EOL] import difflib [EOL] import io [EOL] import re [EOL] import sys [EOL] import typing as typ [EOL] import difflib [EOL] import logging [EOL] [EOL] import click [EOL] [EOL] from . import common [EOL] from . import packaging [EOL] from . import transpile [EOL] [EOL] try : [EOL] import pretty_traceback [EOL] [EOL] pretty_traceback . install ( envvar = [string] ) [EOL] except ImportError : [EOL] pass [comment] [EOL] [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] def _configure_logging ( verbose = [number] ) : [EOL] if verbose >= [number] : [EOL] log_format = [string] [EOL] log_level = logging . DEBUG [EOL] elif verbose == [number] : [EOL] log_format = [string] [EOL] log_level = logging . INFO [EOL] else : [EOL] log_format = [string] [EOL] log_level = logging . INFO [EOL] [EOL] logging . basicConfig ( level = log_level , format = log_format , datefmt = [string] ) [EOL] logger . debug ( [string] ) [EOL] [EOL] [EOL] click . disable_unicode_literals_warning = True [EOL] [EOL] [EOL] def _print_diff ( source_text , fixed_source_text ) : [EOL] differ = difflib . Differ ( ) [EOL] [EOL] source_lines = source_text . splitlines ( ) [EOL] fixed_source_lines = fixed_source_text . splitlines ( ) [EOL] diff_lines = differ . compare ( source_lines , fixed_source_lines ) [EOL] if not sys . stdout . isatty ( ) : [EOL] click . echo ( [string] . join ( diff_lines ) ) [EOL] return [EOL] [EOL] for line in diff_lines : [EOL] if line . startswith ( [string] ) : [EOL] click . echo ( [string] + line + [string] ) [EOL] elif line . startswith ( [string] ) : [EOL] click . echo ( [string] + line + [string] ) [EOL] elif line . startswith ( [string] ) : [EOL] click . echo ( [string] + line + [string] ) [EOL] else : [EOL] click . echo ( line ) [EOL] print ( ) [EOL] [EOL] [EOL] __INSTALL_REQUIRES_HELP = [string] [EOL] [EOL] __DEFAULT_MODE_HELP = [string] [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , count = True , help = [string] , ) @ click . option ( [string] , default = [string] , metavar = [string] , help = [string] , ) @ click . option ( [string] , default = False , is_flag = True , help = [string] , ) @ click . option ( [string] , default = False , is_flag = True , help = [string] , ) @ click . option ( [string] , default = None , metavar = [string] , help = __INSTALL_REQUIRES_HELP . strip ( ) , ) @ click . option ( [string] , default = [string] , metavar = [string] , help = __DEFAULT_MODE_HELP . strip ( ) , ) @ click . argument ( [string] , metavar = [string] , nargs = - [number] , type = click . File ( mode = [string] ) , ) def main ( target_version , diff , in_place , install_requires , source_files , default_mode = [string] , verbose = [number] , ) : [EOL] _configure_logging ( verbose ) [EOL] [EOL] has_opt_error = False [EOL] [EOL] if target_version and not re . match ( [string] , target_version ) : [EOL] print ( f" [string] { target_version }" ) [EOL] has_opt_error = True [EOL] [EOL] if default_mode not in ( [string] , [string] ) : [EOL] print ( f" [string] { default_mode }" ) [EOL] print ( [string] ) [EOL] has_opt_error = True [EOL] [EOL] if not any ( source_files ) : [EOL] print ( [string] ) [EOL] has_opt_error = True [EOL] [EOL] if has_opt_error : [EOL] sys . exit ( [number] ) [EOL] [EOL] cfg = packaging . eval_build_config ( target_version = target_version , install_requires = install_requires , default_mode = default_mode , ) [EOL] for src_file in source_files : [EOL] ctx = common . BuildContext ( cfg , src_file . name ) [EOL] source_text = src_file . read ( ) [EOL] try : [EOL] fixed_source_text = transpile . transpile_module ( ctx , source_text ) [EOL] except common . CheckError as err : [EOL] loc = src_file . name [EOL] if err . lineno >= [number] : [EOL] loc += [string] + str ( err . lineno ) [EOL] [EOL] err . args = ( loc + [string] + err . args [ [number] ] , ) + err . args [ [number] : ] [EOL] raise [EOL] [EOL] if diff : [EOL] _print_diff ( source_text , fixed_source_text ) [EOL] elif in_place : [EOL] with io . open ( src_file . name , mode = [string] ) as fobj : [EOL] fobj . write ( fixed_source_text ) [EOL] else : [EOL] print ( fixed_source_text ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] [comment] [EOL] main ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import ast [EOL] import common [EOL] import src [EOL] import ast [EOL] [EOL] from . import common [EOL] from . import fixer_base as fb [EOL] [EOL] [EOL] class BuiltinsRenameFixerBase ( fb . FixerBase ) : [EOL] [EOL] new_name = ... [EOL] old_name = ... [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] for node in ast . walk ( tree ) : [EOL] is_access_to_builtin = ( isinstance ( node , ast . Name ) [EOL] and isinstance ( node . ctx , ast . Load ) [EOL] and node . id == self . new_name ) [EOL] [EOL] if is_access_to_builtin : [EOL] self . required_imports . add ( common . ImportDecl ( [string] , None , [string] ) ) [EOL] builtin_renmae_decl_str = f""" [string] { self . new_name } [string] { self . old_name } [string] { self . new_name } [string] """ [EOL] self . module_declarations . add ( builtin_renmae_decl_str . strip ( ) ) [EOL] [EOL] return tree [EOL] [EOL] [EOL] class XrangeToRangeFixer ( BuiltinsRenameFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_until = [string] ) [EOL] [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class UnicodeToStrFixer ( BuiltinsRenameFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_until = [string] ) [EOL] [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class UnichrToChrFixer ( BuiltinsRenameFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_until = [string] ) [EOL] [EOL] new_name = [string] [EOL] old_name = [string] [EOL] [EOL] [EOL] class RawInputToInputFixer ( BuiltinsRenameFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_until = [string] ) [EOL] [EOL] new_name = [string] [EOL] old_name = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $ast.Module$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $common.BuildContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Optional [EOL] import ast [EOL] import typing [EOL] import builtins [EOL] import _ast [EOL] import src [EOL] import ast [EOL] import typing as typ [EOL] [EOL] from . import common [EOL] from . import fixer_base as fb [EOL] [EOL] [EOL] class FStringToStrFormatFixer ( fb . TransformerFixerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_since = [string] , apply_until = [string] ) [EOL] [EOL] def _formatted_value_str ( self , fmt_val_node , arg_nodes ) : [EOL] arg_index = len ( arg_nodes ) [EOL] arg_nodes . append ( fmt_val_node . value ) [EOL] [EOL] format_spec_node = fmt_val_node . format_spec [EOL] if format_spec_node is None : [EOL] format_spec = [string] [EOL] elif not isinstance ( format_spec_node , ast . JoinedStr ) : [EOL] raise common . FixerError ( [string] , format_spec_node ) [EOL] else : [EOL] format_spec = [string] + self . _joined_str_str ( format_spec_node , arg_nodes ) [EOL] [EOL] return [string] + str ( arg_index ) + format_spec + [string] [EOL] [EOL] def _joined_str_str ( self , joined_str_node , arg_nodes ) : [EOL] fmt_str = [string] [EOL] for val in joined_str_node . values : [EOL] if isinstance ( val , ast . Str ) : [EOL] fmt_str += val . s [EOL] elif isinstance ( val , ast . FormattedValue ) : [EOL] fmt_str += self . _formatted_value_str ( val , arg_nodes ) [EOL] else : [EOL] raise common . FixerError ( [string] , val ) [EOL] return fmt_str [EOL] [EOL] def visit_JoinedStr ( self , node ) : [EOL] arg_nodes = [ ] [EOL] [EOL] fmt_str = self . _joined_str_str ( node , arg_nodes ) [EOL] format_attr_node = ast . Attribute ( value = ast . Str ( s = fmt_str ) , attr = [string] , ctx = ast . Load ( ) ) [EOL] return ast . Call ( func = format_attr_node , args = arg_nodes , keywords = [ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $ast.FormattedValue$ 0 $typing.List[ast.expr]$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[ast.expr]$ 0 0 $typing.List[ast.expr]$ 0 0 0 $ast.FormattedValue$ 0 0 0 0 0 $typing.Optional[_ast.expr]$ 0 $ast.FormattedValue$ 0 $builtins.str$ 0 0 $typing.Optional[_ast.expr]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[_ast.expr]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[_ast.expr]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[_ast.expr]$ 0 $typing.List[ast.expr]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $ast.JoinedStr$ 0 $typing.List[ast.expr]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $ast.JoinedStr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[ast.expr]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $ast.Call$ 0 0 0 $ast.JoinedStr$ 0 0 0 $typing.List[ast.expr]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $ast.JoinedStr$ 0 $typing.List[ast.expr]$ 0 0 $_ast.Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.Attribute$ 0 0 0 $typing.List[ast.expr]$ 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Set , Iterable , Union , List , Optional , Type [EOL] import builtins [EOL] import ast [EOL] import typing [EOL] import common [EOL] import _ast [EOL] import src [EOL] import ast [EOL] import typing as typ [EOL] [EOL] from . import utils [EOL] from . import common [EOL] from . import checker_base as cb [EOL] from . checkers_backports import NoUnusableImportsChecker [EOL] [EOL] [EOL] class NoStarImports ( cb . CheckerBase ) : [EOL] def __call__ ( self , ctx , tree ) : [EOL] for node in ast . walk ( tree ) : [EOL] if not isinstance ( node , ast . ImportFrom ) : [EOL] continue [EOL] [EOL] for alias in node . names : [EOL] if alias . name == [string] : [EOL] raise common . CheckError ( f" [string] { node . module } [string] " , node ) [EOL] [EOL] [EOL] def _iter_scope_names ( tree ) : [EOL] for node in ast . walk ( tree ) : [EOL] if isinstance ( node , ( ast . FunctionDef , ast . ClassDef ) ) : [EOL] yield node . name , node [EOL] elif isinstance ( node , ast . Name ) and isinstance ( node . ctx , ast . Store ) : [EOL] yield node . id , node [EOL] elif isinstance ( node , ( ast . ImportFrom , ast . Import ) ) : [EOL] for alias in node . names : [EOL] name = alias . name if alias . asname is None else alias . asname [EOL] yield name , node [EOL] elif isinstance ( node , ast . arg ) : [EOL] yield node . arg , node [EOL] [EOL] [EOL] class NoOverriddenFixerImportsChecker ( cb . CheckerBase ) : [EOL] [docstring] [EOL] [EOL] prohibited_import_overrides = { [string] , [string] , [string] } [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] for name_in_scope , node in _iter_scope_names ( tree ) : [EOL] is_fixer_import = ( isinstance ( node , ast . Import ) [EOL] and len ( node . names ) == [number] [EOL] and node . names [ [number] ] . asname is None [EOL] and node . names [ [number] ] . name == name_in_scope ) [EOL] if is_fixer_import : [EOL] continue [EOL] [EOL] if name_in_scope in self . prohibited_import_overrides : [EOL] msg = f" [string] { name_in_scope } [string] " [EOL] raise common . CheckError ( msg , node ) [EOL] [EOL] [EOL] class NoOverriddenBuiltinsChecker ( cb . CheckerBase ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] for name_in_scope , node in _iter_scope_names ( tree ) : [EOL] if name_in_scope in common . BUILTIN_NAMES : [EOL] msg = f" [string] { name_in_scope } [string] " [EOL] raise common . CheckError ( msg , node ) [EOL] [EOL] [EOL] PROHIBITED_OPEN_ARGUMENTS = { [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] [EOL] class NoOpenWithEncodingChecker ( cb . CheckerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_until = [string] ) [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] for node in ast . walk ( tree ) : [EOL] if not isinstance ( node , ast . Call ) : [EOL] continue [EOL] [EOL] func_node = node . func [EOL] if not isinstance ( func_node , ast . Name ) : [EOL] continue [EOL] if func_node . id != [string] or not isinstance ( func_node . ctx , ast . Load ) : [EOL] continue [EOL] [EOL] mode = [string] [EOL] if len ( node . args ) >= [number] : [EOL] mode_node = node . args [ [number] ] [EOL] if not isinstance ( mode_node , ast . Str ) : [EOL] msg = ( [string] + f" [string] { mode_node }" ) [EOL] raise common . CheckError ( msg , node ) [EOL] [EOL] mode = mode_node . s [EOL] [EOL] if len ( node . args ) > [number] : [EOL] raise common . CheckError ( [string] , node ) [EOL] [EOL] for keyword in node . keywords : [EOL] if keyword . arg in PROHIBITED_OPEN_ARGUMENTS : [EOL] msg = f" [string] { keyword . arg } [string] " [EOL] raise common . CheckError ( msg , node ) [EOL] if keyword . arg != [string] : [EOL] continue [EOL] [EOL] mode_node = keyword . value [EOL] if not isinstance ( mode_node , ast . Str ) : [EOL] msg = ( [string] + f" [string] { mode_node }" ) [EOL] raise common . CheckError ( msg , node ) [EOL] [EOL] mode = mode_node . s [EOL] [EOL] if [string] not in mode : [EOL] msg = ( f" [string] { mode } [string] " + [string] ) [EOL] raise common . CheckError ( msg , node ) [EOL] [EOL] [EOL] class NoAsyncAwait ( cb . CheckerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_until = [string] , works_since = [string] ) [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] async_await_node_types = ( ast . AsyncFor , ast . AsyncWith , ast . AsyncFunctionDef , ast . Await ) [EOL] for node in ast . walk ( tree ) : [EOL] if not isinstance ( node , async_await_node_types ) : [EOL] continue [EOL] [EOL] if isinstance ( node , ast . AsyncFor ) : [EOL] keywords = [string] [EOL] elif isinstance ( node , ast . AsyncWith ) : [EOL] keywords = [string] [EOL] elif isinstance ( node , ast . AsyncFunctionDef ) : [EOL] keywords = [string] [EOL] elif isinstance ( node , ast . Await ) : [EOL] keywords = [string] [EOL] else : [EOL] [comment] [EOL] keywords = [string] [EOL] [EOL] msg = ( f" [string] { keywords } [string] " f" [string] { ctx . cfg . target_version } [string] " ) [EOL] raise common . CheckError ( msg , node ) [EOL] [EOL] [EOL] class NoYieldFromChecker ( cb . CheckerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_until = [string] , works_since = [string] ) [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] [EOL] for node in ast . walk ( tree ) : [EOL] if isinstance ( node , ast . YieldFrom ) : [EOL] msg = ( [string] f" [string] { ctx . cfg . target_version }" ) [EOL] raise common . CheckError ( msg , node ) [EOL] [EOL] [EOL] class NoMatMultOpChecker ( cb . CheckerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_until = [string] , works_since = [string] ) [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] if not hasattr ( ast , [string] ) : [EOL] return [EOL] [EOL] for node in ast . walk ( tree ) : [EOL] if not isinstance ( node , ast . BinOp ) : [EOL] continue [EOL] [EOL] if not isinstance ( node . op , ast . MatMult ) : [EOL] continue [EOL] [EOL] msg = [string] [EOL] raise common . CheckError ( msg , node ) [EOL] [EOL] [EOL] def _raise_if_complex_named_tuple ( node ) : [EOL] for subnode in node . body : [EOL] if isinstance ( subnode , ast . Expr ) and isinstance ( subnode . value , ast . Str ) : [EOL] [comment] [EOL] continue [EOL] [EOL] if isinstance ( subnode , ast . AnnAssign ) : [EOL] if subnode . value : [EOL] tgt = subnode . target [EOL] assert isinstance ( tgt , ast . Name ) [EOL] msg = ( [string] + f" [string] { tgt . id } [string] { node . name } [string] " ) [EOL] raise common . CheckError ( msg , subnode , node ) [EOL] elif isinstance ( subnode , ast . FunctionDef ) : [EOL] msg = [string] + f" [string] { subnode . name } [string] { node . name } [string] " [EOL] raise common . CheckError ( msg , subnode , node ) [EOL] else : [EOL] msg = f" [string] { node . name } [string] { subnode }" [EOL] raise common . CheckError ( msg , subnode , node ) [EOL] [EOL] [EOL] class NoComplexNamedTuple ( cb . CheckerBase ) : [EOL] [EOL] version_info = common . VersionInfo ( apply_until = [string] , works_since = [string] ) [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] _typing_module_name = None [EOL] _namedtuple_class_name = [string] [EOL] [EOL] for node in ast . walk ( tree ) : [EOL] if isinstance ( node , ast . Import ) : [EOL] for alias in node . names : [EOL] if alias . name == [string] : [EOL] _typing_module_name = alias . name if alias . asname is None else alias . asname [EOL] continue [EOL] [EOL] if isinstance ( node , ast . ImportFrom ) and node . module == [string] : [EOL] for alias in node . names : [EOL] if alias . name == [string] : [EOL] _namedtuple_class_name = ( alias . name if alias . asname is None else alias . asname ) [EOL] continue [EOL] [EOL] is_namedtuple_class = ( isinstance ( node , ast . ClassDef ) [EOL] and ( _typing_module_name or _namedtuple_class_name ) [EOL] and utils . has_base_class ( node , _typing_module_name , _namedtuple_class_name ) ) [EOL] if is_namedtuple_class : [EOL] assert isinstance ( node , ast . ClassDef ) , [string] [EOL] _raise_if_complex_named_tuple ( node ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,ast.AST]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 $_ast.expr$ 0 $common.BuildContext$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $_ast.expr$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $_ast.expr$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 $typing.Tuple[typing.Type[_ast.AsyncFor],typing.Type[_ast.AsyncWith],typing.Type[_ast.AsyncFunctionDef],typing.Type[_ast.Await]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[_ast.AsyncFor],typing.Type[_ast.AsyncWith],typing.Type[_ast.AsyncFunctionDef],typing.Type[_ast.Await]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $common.BuildContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $common.BuildContext$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.lib3to6.common.VersionInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.bool,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 0 $typing.Union[builtins.bool,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Set , Tuple , Iterable , Dict , Optional [EOL] import builtins [EOL] import typing [EOL] import ast [EOL] import logging [EOL] import common [EOL] import src [EOL] import ast [EOL] import typing as typ [EOL] import logging [EOL] [EOL] from . import common [EOL] from . import checker_base as cb [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ModuleVersionInfo ( typ . NamedTuple ) : [EOL] [EOL] available_since = ... [EOL] backport_module = ... [EOL] backport_package = ... [EOL] [EOL] [EOL] MAYBE_UNUSABLE_MODULES = { [string] : ModuleVersionInfo ( [string] , None , None ) , [string] : ModuleVersionInfo ( [string] , None , None ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , [string] : ModuleVersionInfo ( [string] , [string] , [string] ) , } [EOL] [EOL] [EOL] def _iter_module_names ( node ) : [EOL] if isinstance ( node , ast . Import ) : [EOL] for alias in node . names : [EOL] yield alias . name [EOL] elif isinstance ( node , ast . ImportFrom ) : [EOL] mname = node . module [EOL] if mname : [EOL] yield mname [EOL] [EOL] [EOL] def _iter_maybe_unusable_modules ( node ) : [EOL] for mname in _iter_module_names ( node ) : [EOL] vnfo = MAYBE_UNUSABLE_MODULES . get ( mname ) [EOL] if vnfo : [EOL] yield ( mname , vnfo ) [EOL] [EOL] [EOL] class NoUnusableImportsChecker ( cb . CheckerBase ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __call__ ( self , ctx , tree ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] install_requires = ctx . cfg . install_requires [EOL] [EOL] target_version = ctx . cfg . target_version [EOL] for node in ast . iter_child_nodes ( tree ) : [EOL] for mname , vnfo in _iter_maybe_unusable_modules ( node ) : [EOL] if target_version >= vnfo . available_since : [EOL] [comment] [EOL] continue [EOL] [EOL] bppkg = vnfo . backport_package [EOL] [EOL] [comment] [EOL] [comment] [EOL] is_backport_name_same = mname == vnfo . backport_module [EOL] [EOL] is_whitelisted = ( is_backport_name_same [EOL] and install_requires is not None [EOL] and bppkg in install_requires ) [EOL] if is_whitelisted : [EOL] continue [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] is_backported = vnfo . backport_package is not None [EOL] is_strict_mode = install_requires is not None [EOL] is_hard_error = not is_backported or is_strict_mode or not is_backport_name_same [EOL] [EOL] vnfo_msg = ( f" [string] { vnfo . available_since } [string] " f" [string] { target_version } [string] " ) [EOL] [EOL] if is_hard_error : [EOL] errmsg = f" [string] { mname } [string] { vnfo_msg }" [EOL] if bppkg : [EOL] errmsg += f" [string] { bppkg } [string] " [EOL] else : [EOL] errmsg += [string] [EOL] [EOL] raise common . CheckError ( errmsg , node ) [EOL] else : [EOL] lineno = common . get_node_lineno ( node ) [EOL] loc = f"{ ctx . filepath } [string] { lineno }" [EOL] logger . warning ( f"{ loc } [string] { mname } [string] { vnfo_msg }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,src.lib3to6.checkers_backports.ModuleVersionInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,ModuleVersionInfo]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,src.lib3to6.checkers_backports.ModuleVersionInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $common.BuildContext$ 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Set[builtins.str]]$ 0 $common.BuildContext$ 0 0 0 $typing.Optional[typing.Set[builtins.str]]$ 0 0 $builtins.str$ 0 $common.BuildContext$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $ast.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $typing.Optional[typing.Set[builtins.str]]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[typing.Set[builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Optional[typing.Set[builtins.str]]$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $common.BuildContext$ 0 0 0 0 0 $builtins.int$ 0 0 $logging.Logger$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] import sys [EOL] [EOL] data = open ( sys . argv [ [number] ] ) . read ( [number] ) [EOL] has_data = len ( data ) > [number] [EOL] [EOL] sys . exit ( has_data ) [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0
from typing import Sequence , Tuple , Optional [EOL] import typing [EOL] import builtins [EOL] import m [EOL] [docstring] [EOL] from __future__ import annotations [EOL] [EOL] import typing [EOL] [comment] [EOL] [EOL] [EOL] def bar ( foos ) : [EOL] pass [EOL] [EOL] [EOL] def baz ( x ) : [EOL] pass [EOL] [EOL] [EOL] def before_foo ( foo ) : [EOL] ... [EOL] [EOL] [EOL] class Foo : [EOL] [EOL] foo = ... [EOL] foos = ... [EOL] foo_item = ... [EOL] [EOL] @ staticmethod def doer ( foo , * foos , ** kwfoos ) : [EOL] def nested_doer ( foo ) : [EOL] return ... [EOL] return ... [EOL] [EOL] [EOL] def after_foo ( foo ) : [EOL] ... [EOL] [EOL] [EOL] class Bar : [EOL] pass [EOL] [EOL] [EOL] def bar ( b , s ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Foo$ 0 0 0 $typing.List[Foo]$ 0 0 0 $typing.Tuple[Foo,typing.Tuple[typing.Tuple[Foo,Bar],'Foo']]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Type [EOL] import typing [EOL] import test [EOL] import sys [EOL] from collections import namedtuple [EOL] [EOL] import pytest [EOL] [EOL] from lib3to6 import utils [EOL] from lib3to6 import common [EOL] [EOL] CheckFixture = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def make_fixture ( names , test_source , expected_error_msg ) : [EOL] test_source = utils . clean_whitespace ( test_source ) [EOL] return CheckFixture ( names , test_source , expected_error_msg ) [EOL] [EOL] [EOL] FIXTURES = [ make_fixture ( [string] , [string] , None , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , None , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , None , ) , make_fixture ( [string] , [string] , None , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [ [string] , [string] , ] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [ [string] , [string] , ] , ) , make_fixture ( [string] , [string] , [ [string] , [string] ] , ) , make_fixture ( [string] , [string] , [string] , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FIXTURES ) def test_checkers ( fixture ) : [EOL] if [string] in sys . argv : [EOL] print ( ) [EOL] [EOL] if isinstance ( fixture . expected_error_msg , list ) : [EOL] expected_error_messages = fixture . expected_error_msg [EOL] else : [EOL] expected_error_messages = [ fixture . expected_error_msg ] [EOL] [EOL] ctx = common . init_build_context ( checkers = fixture . names , install_requires = set ( ) ) [EOL] try : [EOL] utils . transpile_and_dump ( ctx , fixture . test_source ) [EOL] assert fixture . expected_error_msg is None , f" [string] { fixture . names } [string] " [EOL] except common . CheckError as result_error : [EOL] assert fixture . expected_error_msg is not None [EOL] [EOL] for expected_error_msg in expected_error_messages : [EOL] assert expected_error_msg in str ( result_error ) [EOL] [EOL] [EOL] def _test_unusable_imports ( source , ver = [string] , req = None ) : [EOL] ctx = common . init_build_context ( checkers = [string] , target_version = ver , install_requires = set ( req . split ( [string] ) ) if req else None , ) [EOL] utils . transpile_and_dump ( ctx , source ) [EOL] [EOL] [EOL] def test_backport_checker_warning ( caplog ) : [EOL] assert len ( caplog . records ) == [number] [EOL] _test_unusable_imports ( [string] , [string] ) [EOL] assert len ( caplog . records ) == [number] [EOL] for record in caplog . records : [EOL] assert record . levelname == [string] [EOL] assert [string] in record . message [EOL] [EOL] [EOL] def test_backport_checker_nowarning ( caplog ) : [EOL] assert len ( caplog . records ) == [number] [EOL] _test_unusable_imports ( [string] , [string] , req = [string] ) [EOL] assert len ( caplog . records ) == [number] [EOL] [EOL] [EOL] def test_backport_checker_errors ( ) : [EOL] [comment] [EOL] _test_unusable_imports ( [string] , [string] ) [EOL] [EOL] try : [EOL] _test_unusable_imports ( [string] , [string] ) [EOL] assert False , [string] [EOL] except common . CheckError as err : [EOL] assert [string] in str ( err ) [EOL] [EOL] [comment] [EOL] _test_unusable_imports ( [string] , [string] ) [EOL] [comment] [EOL] _test_unusable_imports ( [string] , [string] , req = [string] ) [EOL] [EOL] try : [EOL] _test_unusable_imports ( [string] , [string] ) [EOL] assert False , [string] [EOL] except common . CheckError as err : [EOL] assert [string] in str ( err ) [EOL] [EOL] try : [EOL] _test_unusable_imports ( [string] , [string] , req = [string] ) [EOL] assert False , [string] [EOL] except common . CheckError as err : [EOL] [comment] [EOL] assert [string] in str ( err ) [EOL] [EOL] try : [EOL] _test_unusable_imports ( [string] , [string] , req = [string] ) [EOL] assert False , [string] [EOL] except common . CheckError as err : [EOL] [comment] [EOL] assert [string] in str ( err ) [EOL] [EOL] [comment] [EOL] _test_unusable_imports ( [string] , [string] ) [EOL] [comment] [EOL] _test_unusable_imports ( [string] , [string] , req = [string] ) [EOL] [EOL] try : [EOL] _test_unusable_imports ( [string] , [string] , req = [string] ) [EOL] assert False , [string] [EOL] except common . CheckError as err : [EOL] [comment] [EOL] assert [string] in str ( err ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.test_checkers.CheckFixture]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.test_checkers.CheckFixture]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from lib3to6 import transpile [EOL] from lib3to6 . utils import clean_whitespace [EOL] [EOL] [EOL] def test_parse_header_simple ( ) : [EOL] source = clean_whitespace ( [string] ) [EOL] header = transpile . parse_module_header ( source , [string] ) [EOL] assert header . coding == [string] [EOL] assert header . text == [string] [EOL] [EOL] [EOL] def test_parse_header_coding ( ) : [EOL] source = clean_whitespace ( [string] ) [EOL] header = transpile . parse_module_header ( source , [string] ) [EOL] assert header . coding == [string] [EOL] assert header . text == [string] [EOL] [EOL] source_data = source . encode ( [string] ) [EOL] header = transpile . parse_module_header ( source_data , [string] ) [EOL] assert header . coding == [string] [EOL] assert header . text == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Type [EOL] import typing [EOL] import test [EOL] import sys [EOL] import collections [EOL] [EOL] import pytest [EOL] [EOL] from lib3to6 import utils [EOL] from lib3to6 import common [EOL] from lib3to6 import transpile [EOL] [EOL] FixerFixture = collections . namedtuple ( [string] , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def make_fixture ( names , target_version , test_source , expected_source ) : [EOL] test_source = utils . clean_whitespace ( test_source ) [EOL] expected_source = utils . clean_whitespace ( expected_source ) [EOL] return FixerFixture ( names , target_version , test_source , expected_source ) [EOL] [EOL] [EOL] def test_numeric_literals_with_underscore ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] a_ast = utils . parsedump_ast ( [string] ) [EOL] b_ast = utils . parsedump_ast ( [string] ) [EOL] assert a_ast == b_ast [EOL] [EOL] [EOL] def test_header_preserved ( ) : [EOL] test_source = [string] [EOL] expected_source = [string] [EOL] test_source = utils . clean_whitespace ( test_source ) [EOL] expected_source = utils . clean_whitespace ( expected_source ) [EOL] [EOL] ctx = common . init_build_context ( filepath = [string] ) [EOL] result_header_coding , result_header_text , result_source = utils . transpile_and_dump ( ctx , test_source ) [EOL] assert result_header_coding == [string] [EOL] assert expected_source == result_source [EOL] [EOL] expected_ast = utils . parsedump_ast ( expected_source ) [EOL] result_ast = utils . parsedump_ast ( result_source ) [EOL] assert expected_ast == result_ast [EOL] [EOL] [EOL] FIXTURES = [ make_fixture ( [ [string] , [string] , [string] , [string] , ] , [string] , [string] , [string] , ) , make_fixture ( [ [string] , [string] , [string] , [string] , ] , [string] , [string] , [string] , ) , make_fixture ( [ [string] , [string] , [string] , [string] , [string] , ] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [string] , [string] , [string] , [string] , ) , make_fixture ( [ [string] , [string] ] , [string] , [string] , [string] , ) , make_fixture ( [ [string] ] , [string] , [string] , [string] , ) , ] [EOL] [EOL] [EOL] def _normalized_source ( in_source ) : [EOL] [docstring] [EOL] in_source = utils . clean_whitespace ( in_source ) [EOL] out_source = utils . parsedump_source ( in_source ) [EOL] assert utils . parsedump_ast ( out_source ) == utils . parsedump_ast ( in_source ) [EOL] return out_source [EOL] [EOL] [EOL] DEBUG_VERBOSITY = [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FIXTURES ) def test_fixers ( fixture ) : [EOL] if [string] in sys . argv : [EOL] print ( ) [EOL] [EOL] expected_source = utils . clean_whitespace ( fixture . expected_source ) [EOL] expected_ast = utils . parsedump_ast ( expected_source ) [EOL] expected_header = transpile . parse_module_header ( expected_source , fixture . target_version ) [EOL] [EOL] test_source = utils . clean_whitespace ( fixture . test_source ) [EOL] [EOL] if DEBUG_VERBOSITY > [number] : [EOL] print ( [string] * [number] ) [EOL] if DEBUG_VERBOSITY > [number] : [EOL] test_ast = utils . parsedump_ast ( test_source ) [EOL] print ( test_ast ) [EOL] print ( [string] * [number] ) [EOL] if DEBUG_VERBOSITY > [number] : [EOL] print ( repr ( test_source ) ) [EOL] print ( test_source ) [EOL] [EOL] if DEBUG_VERBOSITY > [number] : [EOL] print ( [string] * [number] ) [EOL] if DEBUG_VERBOSITY > [number] : [EOL] print ( expected_ast ) [EOL] print ( [string] * [number] ) [EOL] if DEBUG_VERBOSITY > [number] : [EOL] print ( repr ( expected_source ) ) [EOL] print ( expected_source ) [EOL] [EOL] ctx = common . init_build_context ( target_version = fixture . target_version , fixers = fixture . names , filepath = [string] ) [EOL] result_header_coding , result_header_text , result_source = utils . transpile_and_dump ( ctx , test_source ) [EOL] result_ast = utils . parsedump_ast ( result_source ) [EOL] [EOL] if DEBUG_VERBOSITY > [number] : [EOL] print ( [string] * [number] ) [EOL] if DEBUG_VERBOSITY > [number] : [EOL] print ( result_ast ) [EOL] print ( [string] * [number] ) [EOL] if DEBUG_VERBOSITY > [number] : [EOL] print ( repr ( result_source ) ) [EOL] print ( result_source ) [EOL] [EOL] assert result_header_coding == expected_header . coding [EOL] assert result_header_text == expected_header . text [EOL] [EOL] assert result_ast == expected_ast [EOL] assert _normalized_source ( result_source ) == _normalized_source ( expected_source ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.test_fixers.FixerFixture]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.test_fixers.FixerFixture]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List [EOL] import typing [EOL] import sys [EOL] import setuptools [EOL] import pkg_resources [EOL] [EOL] [EOL] packages = [ [string] ] [EOL] package_dir = { [string] : [string] } [EOL] [EOL] install_requires = [ [string] ] [EOL] [EOL] if any ( arg . startswith ( [string] ) for arg in sys . argv ) : [EOL] import lib3to6 [EOL] package_dir = lib3to6 . fix ( package_dir , target_version = [string] , install_requires = install_requires , ) [EOL] [EOL] __version__ = [string] [EOL] __normalized_python_version__ = str ( pkg_resources . parse_version ( __version__ ) ) [EOL] [EOL] setuptools . setup ( name = [string] , version = __normalized_python_version__ , description = [string] , author = [string] , author_email = [string] , packages = packages , package_dir = package_dir , install_requires = install_requires , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Type [EOL] import typing [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import unicode_literals [EOL] [EOL] import sys [EOL] [EOL] try : [EOL] import builtins [EOL] [comment] [EOL] [comment] [EOL] assert getattr ( builtins , [string] , None ) is None [EOL] except ( ImportError , AssertionError ) : [EOL] import __builtin__ as builtins [EOL] [EOL] [EOL] PY3 = sys . version_info [ [number] ] == [number] [EOL] [EOL] if PY3 : [EOL] str_types = ( builtins . bytes , builtins . str ) [EOL] str = builtins . str [EOL] integer_types = int , [EOL] else : [EOL] integer_types = ( int , long ) [EOL] str_types = ( builtins . str , builtins . unicode ) [EOL] str = builtins . unicode [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Tuple[unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[builtins.int]]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[builtins.int]]$ 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import sys [EOL] import setuptools [EOL] [EOL] packages = [ [string] ] [EOL] package_dir = { [string] : [string] } [EOL] [EOL] if any ( arg . startswith ( [string] ) for arg in sys . argv ) : [EOL] import lib3to6 [EOL] package_dir = lib3to6 . fix ( package_dir ) [EOL] [EOL] setuptools . setup ( name = [string] , version = [string] , packages = packages , package_dir = package_dir , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0
import builtins [EOL] import sys [EOL] [EOL] [EOL] def hello ( who ) : [EOL] print ( f" [string] { who } [string] { sys . version . split ( ) [ [number] ] } [string] " ) [EOL] [EOL] [EOL] print ( __file__ ) [EOL] hello ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0