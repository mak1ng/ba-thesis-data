from typing import List , Type , Any , Dict [EOL] import tests [EOL] import typing [EOL] from collections import namedtuple [EOL] import os [EOL] import random [EOL] [EOL] from cryptopals . block import ( aes_ecb_decrypt , aes_ecb_encrypt , aes_cbc_decrypt , aes_cbc_encrypt , aes_ctr_decrypt , aes_ctr_encrypt , detect_ecb_use , ecb_encrypt_append , ecb_encrypt_prepend_and_append , cbc_encrypt_prepend_and_append , encryption_ecb_cbc_detection_oracle , gen_random_block , construct_ecb_attack_dict , ) [EOL] from cryptopals . frequency import top_n_english_words [EOL] from cryptopals . utils import base64_to_bytes , hex_to_bytes , xor [EOL] [EOL] [EOL] BLOCK_SIZE = [number] [EOL] [EOL] [EOL] def test_aes_ecb_decrypt ( ) : [EOL] [comment] [EOL] [EOL] path_to_data = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] ) [EOL] [EOL] with open ( path_to_data , [string] ) as f : [EOL] base64_ciphertext = f . read ( ) [EOL] [EOL] ciphertext = base64_to_bytes ( base64_ciphertext ) [EOL] [EOL] key = [string] . encode ( [string] ) [EOL] [EOL] plaintext = aes_ecb_decrypt ( key , ciphertext ) [EOL] assert [string] in plaintext . decode ( [string] ) [EOL] [EOL] [EOL] def test_aes_ecb_encrypt ( ) : [EOL] key = [string] . encode ( [string] ) [EOL] plaintext = [string] . encode ( [string] ) [EOL] [EOL] ciphertext = aes_ecb_encrypt ( key , plaintext ) [EOL] [EOL] computed_plaintext = aes_ecb_decrypt ( key , ciphertext ) [EOL] [EOL] assert plaintext == computed_plaintext [EOL] [EOL] [EOL] def test_aes_cbc_encrypt ( ) : [EOL] key = [string] . encode ( [string] ) [EOL] plaintext = [string] . encode ( [string] ) [EOL] iv = bytes ( [ [number] ] ) * BLOCK_SIZE [EOL] [EOL] ciphertext = aes_cbc_encrypt ( key , plaintext , iv , BLOCK_SIZE ) [EOL] [EOL] computed_plaintext = aes_cbc_decrypt ( key , ciphertext , iv , BLOCK_SIZE ) [EOL] [EOL] assert plaintext == computed_plaintext [EOL] [EOL] [EOL] def test_aes_cbc_decrypt ( ) : [EOL] [comment] [EOL] [EOL] path_to_data = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] ) [EOL] [EOL] with open ( path_to_data , [string] ) as f : [EOL] base64_ciphertext = f . read ( ) [EOL] [EOL] ciphertext = base64_to_bytes ( base64_ciphertext ) [EOL] [EOL] key = [string] . encode ( [string] ) [EOL] [EOL] iv = bytes ( [ [number] ] ) * BLOCK_SIZE [EOL] [EOL] plaintext = aes_cbc_decrypt ( key , ciphertext , iv , remove_padding = False ) [EOL] [EOL] assert [string] in plaintext . decode ( [string] ) [EOL] assert [string] in plaintext . decode ( [string] ) [EOL] [EOL] [EOL] def test_aes_ecb_detection ( ) : [EOL] [comment] [EOL] [EOL] path_to_data = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] ) [EOL] [EOL] with open ( path_to_data , [string] ) as f : [EOL] hex_ciphertexts = f . read ( ) . split ( [string] ) [EOL] [EOL] texts_with_repeated_blocks = [ ] [EOL] for ciphertext in hex_ciphertexts : [EOL] [comment] [EOL] bytes_ciphertext = hex_to_bytes ( ciphertext ) [EOL] [EOL] if detect_ecb_use ( bytes_ciphertext ) : [EOL] texts_with_repeated_blocks . append ( bytes_ciphertext ) [EOL] [EOL] assert len ( texts_with_repeated_blocks ) == [number] [EOL] [EOL] [EOL] def test_ecb_cbc_detection_oracle ( ) : [EOL] [comment] [EOL] [EOL] num_ecbs = [number] [EOL] num_cbcs = [number] [EOL] num_total_iterations = [number] [EOL] [EOL] plaintext = [string] . encode ( [string] ) [EOL] [EOL] for _ in range ( num_total_iterations ) : [EOL] key = gen_random_block ( ) [EOL] ciphertext = encryption_ecb_cbc_detection_oracle ( key , plaintext ) [EOL] [EOL] if detect_ecb_use ( ciphertext ) : [EOL] num_ecbs += [number] [EOL] else : [EOL] num_cbcs += [number] [EOL] [EOL] cbc_rate = num_cbcs / num_total_iterations [EOL] ecb_rate = num_ecbs / num_total_iterations [EOL] [EOL] [comment] [EOL] assert cbc_rate > [number] and cbc_rate < [number] [EOL] assert ecb_rate > [number] and ecb_rate < [number] [EOL] [EOL] [EOL] def test_byte_at_a_time_ecb_decryption ( ) : [EOL] [comment] [EOL] [EOL] path_to_test_data = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] ) [EOL] [EOL] with open ( path_to_test_data , [string] ) as f : [EOL] append_text_str = f . read ( ) [EOL] [EOL] append_bytes = base64_to_bytes ( append_text_str ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] key = gen_random_block ( ) [EOL] [EOL] [comment] [EOL] previous_ciphertext_len = None [EOL] test_input = [string] [EOL] for blocksize in range ( [number] ) : [EOL] test_input = [string] + test_input [EOL] test_ciphertext = ecb_encrypt_append ( key , test_input . encode ( [string] ) , append_bytes ) [EOL] [EOL] if ( previous_ciphertext_len [EOL] and len ( test_ciphertext ) - previous_ciphertext_len != [number] ) : [EOL] blocksize = len ( test_ciphertext ) - previous_ciphertext_len [EOL] break [EOL] [EOL] previous_ciphertext_len = len ( test_ciphertext ) [EOL] [EOL] assert blocksize == BLOCK_SIZE [comment] [EOL] [EOL] ciphertext = ecb_encrypt_append ( key , [string] , append_bytes ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] reconstructed_str = [string] [EOL] [EOL] for index_of_target_block in range ( [number] , len ( ciphertext ) // blocksize ) : [EOL] [EOL] bytes_so_far_this_block = [string] [EOL] for test_byte in range ( blocksize ) : [EOL] [EOL] if index_of_target_block == [number] : [EOL] [comment] [EOL] attacker_controlled_bytes = [string] * ( blocksize - test_byte - [number] ) [EOL] [EOL] [comment] [EOL] prefix = ( attacker_controlled_bytes . encode ( [string] ) + bytes_so_far_this_block ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] previous_block_bytes = reconstructed_str [ - [number] * ( blocksize - [number] ) : ] [EOL] [EOL] [comment] [EOL] prefix = previous_block_bytes . encode ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] attacker_controlled_bytes = [string] * ( blocksize - test_byte - [number] ) [EOL] [EOL] ciphertext = ecb_encrypt_append ( key , attacker_controlled_bytes . encode ( [string] ) , append_bytes ) [EOL] [EOL] cipher_dict = construct_ecb_attack_dict ( key , prefix ) [EOL] [EOL] target_block_ciphertext = ciphertext [ ( index_of_target_block - [number] ) * blocksize : index_of_target_block * blocksize ] [EOL] [EOL] last_char = cipher_dict [ target_block_ciphertext ] [EOL] [EOL] reconstructed_str = reconstructed_str + last_char [EOL] bytes_so_far_this_block = bytes_so_far_this_block + last_char . encode ( [string] ) [EOL] [EOL] assert [string] in reconstructed_str [EOL] [EOL] [EOL] def test_random_prefix_byte_at_a_time_ecb_decryption ( ) : [EOL] [comment] [EOL] [EOL] path_to_test_data = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] ) [EOL] [EOL] with open ( path_to_test_data , [string] ) as f : [EOL] append_text_str = f . read ( ) [EOL] [EOL] append_bytes = base64_to_bytes ( append_text_str ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] key = gen_random_block ( ) [EOL] [EOL] [comment] [EOL] random_number_of_bytes = random . randint ( [number] , [number] ) [EOL] prepend_bytes = os . urandom ( random_number_of_bytes ) [EOL] [EOL] blocksize = [number] [EOL] [EOL] ciphertext = ecb_encrypt_prepend_and_append ( key , [string] , append_bytes , prepend_bytes ) [EOL] [EOL] test_str = [string] * blocksize [EOL] ciphertext_of_all_As = aes_ecb_encrypt ( key , test_str . encode ( [string] ) ) [ [number] : blocksize ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] block_to_begin_at = None [EOL] number_of_characters_in_test_string = None [EOL] for num_of_test_characters in range ( blocksize * [number] - [number] , [number] , - [number] ) : [EOL] test_str = [string] * num_of_test_characters [EOL] [EOL] ciphertext = ecb_encrypt_prepend_and_append ( key , test_str . encode ( [string] ) , append_bytes , prepend_bytes ) [EOL] [EOL] for block_num in range ( [number] , len ( ciphertext ) // blocksize ) : [EOL] [EOL] if ( ciphertext_of_all_As == ciphertext [ ( block_num - [number] ) * blocksize : block_num * blocksize ] ) : [EOL] block_to_begin_at = block_num [EOL] number_of_characters_in_test_string = num_of_test_characters [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] reconstructed_str = [string] [EOL] [EOL] for index_of_target_block in range ( block_to_begin_at , len ( ciphertext ) // blocksize ) : [EOL] [EOL] bytes_so_far_this_block = [string] [EOL] for test_byte in range ( blocksize ) : [EOL] [EOL] if index_of_target_block == block_to_begin_at : [EOL] [comment] [EOL] attacker_controlled_bytes = [string] * ( blocksize - test_byte - [number] ) [EOL] [EOL] [comment] [EOL] prefix = ( attacker_controlled_bytes . encode ( [string] ) + bytes_so_far_this_block ) [EOL] [EOL] [comment] [EOL] attacker_controlled_bytes = ( [string] * number_of_characters_in_test_string + attacker_controlled_bytes ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] previous_block_bytes = reconstructed_str [ - [number] * ( blocksize - [number] ) : ] [EOL] [EOL] [comment] [EOL] prefix = previous_block_bytes . encode ( [string] ) [EOL] [EOL] [comment] [EOL] attacker_controlled_bytes = ( [string] * number_of_characters_in_test_string + [string] * ( blocksize - test_byte - [number] ) ) [EOL] [EOL] ciphertext = ecb_encrypt_prepend_and_append ( key , attacker_controlled_bytes . encode ( [string] ) , append_bytes , prepend_bytes , ) [EOL] [EOL] cipher_dict = construct_ecb_attack_dict ( key , prefix ) [EOL] [EOL] target_block_ciphertext = ciphertext [ ( index_of_target_block - [number] ) * blocksize : index_of_target_block * blocksize ] [EOL] [EOL] last_char = cipher_dict [ target_block_ciphertext ] [EOL] [EOL] reconstructed_str = reconstructed_str + last_char [EOL] bytes_so_far_this_block = bytes_so_far_this_block + last_char . encode ( [string] ) [EOL] [EOL] assert [string] in reconstructed_str [EOL] [EOL] [EOL] def test_cbc_bitflip_attack ( ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] block_size = BLOCK_SIZE [EOL] key = gen_random_block ( ) [EOL] iv = gen_random_block ( ) [EOL] [EOL] prepend = [string] [EOL] append = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] plaintext = [string] . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] full_plaintext = prepend + plaintext + append [EOL] ciphertext = cbc_encrypt_prepend_and_append ( key , iv , plaintext . encode ( [string] ) , append . encode ( [string] ) , prepend . encode ( [string] ) , ) [EOL] [EOL] modified_ciphertext = [string] [EOL] target_text = [string] [EOL] edit_start_position = [number] [EOL] edit_stop_position = len ( target_text ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for ind , by in enumerate ( ciphertext ) : [EOL] if ind in range ( edit_start_position , edit_stop_position ) : [EOL] new_value = bytes ( [ int . from_bytes ( target_text [ edit_start_position + ind ] . encode ( [string] ) , [string] ) ^ ciphertext [ ind ] ^ int . from_bytes ( full_plaintext [ ind + block_size ] . encode ( [string] ) , [string] ) ] ) [EOL] [EOL] modified_ciphertext = modified_ciphertext + new_value [EOL] else : [EOL] modified_ciphertext = modified_ciphertext + bytes ( [ by ] ) [EOL] [EOL] decrypted_plaintext = aes_cbc_decrypt ( key , modified_ciphertext , iv ) [EOL] [EOL] assert target_text . encode ( [string] ) in decrypted_plaintext [EOL] [EOL] [EOL] def test_aes_ctr_decrypt ( ) : [EOL] [comment] [EOL] [EOL] ciphertext = base64_to_bytes ( [string] ) [EOL] key = [string] . encode ( [string] ) [EOL] nonce = [number] [EOL] [EOL] result = aes_ctr_decrypt ( key , ciphertext , nonce , BLOCK_SIZE ) [EOL] [EOL] assert result == [string] [EOL] [EOL] [EOL] def test_aes_ctr_consistency ( ) : [EOL] test_text = [string] [EOL] key = [string] . encode ( [string] ) [EOL] nonce = [number] [EOL] [EOL] ciphertext = aes_ctr_encrypt ( key , test_text , nonce , BLOCK_SIZE ) [EOL] decrypted_plaintext = aes_ctr_decrypt ( key , ciphertext , nonce , BLOCK_SIZE ) [EOL] [EOL] assert test_text == decrypted_plaintext [EOL] [EOL] [EOL] def test_break_fixed_nonce_ctf ( ) : [EOL] [comment] [EOL] [EOL] path_to_test_data = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] ) [EOL] [EOL] with open ( path_to_test_data , [string] ) as f : [EOL] plaintexts_b64 = f . readlines ( ) [EOL] [EOL] plaintexts = [ base64_to_bytes ( x ) for x in plaintexts_b64 ] [EOL] key = os . urandom ( BLOCK_SIZE ) [EOL] nonce = [number] [comment] [EOL] [EOL] ciphertexts = [ aes_ctr_encrypt ( key , x , nonce , BLOCK_SIZE ) for x in plaintexts ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] C1_xor_C2 = namedtuple ( [string] , [string] ) [EOL] xored = [ ] [EOL] for ind_x , ciphertext_x in enumerate ( ciphertexts ) : [EOL] for ind_y , ciphertext_y in enumerate ( ciphertexts ) : [EOL] if ind_x != ind_y : [EOL] result = [ bytes ( [ x ^ y ] ) for x , y in zip ( ciphertext_x , ciphertext_y ) ] [EOL] result_bytes = [string] . join ( result ) [EOL] result_tuple = C1_xor_C2 ( ind_x , ind_y , result_bytes ) [EOL] xored . append ( result_tuple ) [EOL] [EOL] xored = list ( set ( xored ) ) [EOL] [EOL] reconstructed_keystream = [string] * [number] [EOL] keystream_byte_guesses = { } [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] common_ngrams = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [comment] [EOL] top_words_with_space = [ ( x + [string] ) . encode ( [string] ) for x in top_n_english_words ( [number] ) ] [EOL] english_guesses = list ( set ( common_ngrams + top_words_with_space ) ) [EOL] [EOL] for pair in xored : [EOL] for test_ngram in english_guesses : [EOL] result = xor ( pair . value , test_ngram ) [EOL] for found_ngram in english_guesses : [EOL] if found_ngram != test_ngram and found_ngram in result : [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] starting_index = result . find ( found_ngram ) [EOL] len_ngram = len ( found_ngram ) [EOL] for index in range ( len_ngram ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ct_index = starting_index + index [EOL] c1 = ciphertexts [ pair . c1_index ] [EOL] c2 = ciphertexts [ pair . c2_index ] [EOL] keystream_byte_guess_c1 = bytes ( [ found_ngram [ index ] ^ c1 [ ct_index ] ] ) [EOL] keystream_byte_guess_c2 = bytes ( [ found_ngram [ index ] ^ c2 [ ct_index ] ] ) [EOL] [EOL] try : [EOL] keystream_byte_guesses [ ct_index ] . append ( keystream_byte_guess_c1 ) [EOL] keystream_byte_guesses [ ct_index ] . append ( keystream_byte_guess_c2 ) [EOL] except KeyError : [EOL] keystream_byte_guesses [ ct_index ] = [ keystream_byte_guess_c1 , keystream_byte_guess_c2 , ] [EOL] [EOL] for ct_index in keystream_byte_guesses . keys ( ) : [EOL] guesses = keystream_byte_guesses [ ct_index ] [EOL] winning_guess = max ( set ( guesses ) , key = guesses . count ) [EOL] reconstructed_keystream = ( reconstructed_keystream [ : ct_index ] + winning_guess + reconstructed_keystream [ ct_index + [number] : ] ) [EOL] [EOL] expected_keystream = aes_ctr_encrypt ( key , [string] * [number] , nonce , BLOCK_SIZE ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] percent_correct = ( [ x == y for x , y in zip ( expected_keystream , reconstructed_keystream ) ] . count ( True ) / len ( reconstructed_keystream ) * [number] ) [EOL] assert percent_correct > [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import pytest [EOL] [EOL] from cryptopals . exceptions import BadPaddingValidation [EOL] from cryptopals . padding import pkcs_7 , remove_pkcs_7 [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] , [string] ) , ( [string] , [number] , [string] ) , ] , ) def test_pkcs_7 ( test_input , block_size , expected ) : [EOL] assert pkcs_7 ( test_input . encode ( [string] ) , block_size ) == expected . encode ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ] , ) def test_removal_of_pkcs_7 ( test_input , expected ) : [EOL] assert remove_pkcs_7 ( test_input . encode ( [string] ) ) == expected . encode ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] ) , ( [string] ) , ( [string] ) , ( [string] ) , ] , ) def test_removal_of_pkcs_7_raises_exception_invalid_padding ( test_input ) : [EOL] with pytest . raises ( BadPaddingValidation ) : [EOL] remove_pkcs_7 ( test_input . encode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import pytest [EOL] [EOL] from cryptopals . block import aes_ecb_decrypt , aes_ecb_encrypt , gen_random_block [EOL] from cryptopals . cookie import parse_structured_cookie , generate_profile_for [EOL] [EOL] [EOL] def test_cookie_parsed_correctly ( ) : [EOL] test_value = [string] [EOL] [EOL] profile_dict = parse_structured_cookie ( test_value ) [EOL] [EOL] assert profile_dict [ [string] ] == [string] [EOL] assert profile_dict [ [string] ] == [string] [EOL] assert profile_dict [ [string] ] == [string] [EOL] [EOL] [EOL] def test_profile_for_success ( ) : [EOL] cookie = generate_profile_for ( [string] , [number] , [string] ) [EOL] [EOL] assert cookie == [string] [EOL] [EOL] [EOL] def test_profile_for_failure ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] generate_profile_for ( [string] , [number] , [string] ) [EOL] [EOL] [EOL] def test_ecb_cut_and_paste_cookie ( ) : [EOL] [comment] [EOL] [EOL] block_size = [number] [EOL] key = gen_random_block ( block_size ) [EOL] [EOL] original_cookie = generate_profile_for ( [string] ) [EOL] aes_ecb_encrypt ( key , original_cookie . encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] oracle_cookie = generate_profile_for ( [string] ) [EOL] encrypted_oracle_cookie = aes_ecb_encrypt ( key , oracle_cookie . encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] cut_and_pasted_cookie = generate_profile_for ( [string] ) [EOL] encrypted_cut_and_pasted_cookie = aes_ecb_encrypt ( key , cut_and_pasted_cookie . encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] padding_cookie = generate_profile_for ( [string] ) [EOL] encrypted_padding_cookie = aes_ecb_encrypt ( key , padding_cookie . encode ( [string] ) ) [EOL] [EOL] block_to_paste = encrypted_oracle_cookie [ block_size : [number] * block_size ] [EOL] block_to_cut = encrypted_cut_and_pasted_cookie [ [number] : - [number] * block_size ] [EOL] block_to_pad = encrypted_padding_cookie [ - [number] * block_size : ] [EOL] encrypted_admin_profile = block_to_cut + block_to_paste + block_to_pad [EOL] [EOL] decrypted_admin_profile = aes_ecb_decrypt ( key , encrypted_admin_profile ) [EOL] admin_profile = parse_structured_cookie ( decrypted_admin_profile . decode ( [string] ) ) [EOL] [EOL] assert admin_profile [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import cryptopals [EOL] import typing [EOL] import random [EOL] import time [EOL] from cryptopals . prng import MersenneTwister , mersenne_untemper [EOL] [EOL] [EOL] def test_mersenne_twister_cpp ( ) : [EOL] [docstring] [EOL] seed = [number] [EOL] mt_prng = MersenneTwister ( seed ) [EOL] [EOL] [comment] [EOL] output_10000 = [number] [EOL] n_outputs = [number] [EOL] [EOL] for rand in range ( n_outputs ) : [EOL] random_number = mt_prng . extract_number ( ) [EOL] [EOL] assert random_number == output_10000 [EOL] [EOL] [EOL] def test_crack_mt_seed ( ) : [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] lower_num_seconds = [number] [EOL] [comment] [EOL] upper_num_seconds = [number] [EOL] [EOL] random_seconds_to_wait = random . randrange ( lower_num_seconds , upper_num_seconds ) [EOL] time . sleep ( random_seconds_to_wait ) [EOL] [EOL] current_unix_timestamp = int ( time . time ( ) ) [EOL] [EOL] random_seconds_to_wait = random . randrange ( lower_num_seconds , upper_num_seconds ) [EOL] time . sleep ( random_seconds_to_wait ) [EOL] [EOL] mt_prng = MersenneTwister ( current_unix_timestamp ) [EOL] first_output = mt_prng . extract_number ( ) [EOL] [EOL] upper_seed_to_crack = int ( time . time ( ) ) [EOL] lower_seed_to_crack = upper_seed_to_crack - upper_num_seconds * [number] [EOL] for possible_seed in range ( lower_seed_to_crack , upper_seed_to_crack ) : [EOL] mt_prng = MersenneTwister ( possible_seed ) [EOL] test_output = mt_prng . extract_number ( ) [EOL] if test_output == first_output : [EOL] break [EOL] [EOL] assert current_unix_timestamp == possible_seed [EOL] [EOL] [EOL] def test_mersenne_twister_reconstruct_single_state_test ( ) : [EOL] seed = [number] [EOL] mt_prng = MersenneTwister ( seed ) [EOL] [EOL] output = mt_prng . extract_number ( ) [EOL] state_to_reconstruct = mt_prng . mt [ [number] ] [EOL] [EOL] reconstructed_state = mersenne_untemper ( output ) [EOL] [EOL] assert state_to_reconstruct == reconstructed_state [EOL] [EOL] [EOL] def test_clone_mersenne_twister_from_output ( ) : [EOL] [comment] [EOL] [EOL] seed = [number] [EOL] mt_prng = MersenneTwister ( seed ) [EOL] [EOL] N = [number] [EOL] observed_values = [ ] [EOL] reconstructed_states = [ ] [EOL] for _ in range ( N ) : [EOL] output = mt_prng . extract_number ( ) [EOL] reconstructed_state = mersenne_untemper ( output ) [EOL] observed_values . append ( output ) [EOL] reconstructed_states . append ( reconstructed_state ) [EOL] [EOL] [comment] [EOL] mt_prng = MersenneTwister ( [number] ) [comment] [EOL] mt_prng . mt = reconstructed_states [EOL] mt_prng . index = [number] [EOL] [EOL] [comment] [EOL] for i in range ( N ) : [EOL] assert observed_values [ i ] == mt_prng . extract_number ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from cryptopals . exceptions import BadPaddingValidation [EOL] [EOL] [EOL] def pkcs_7 ( plaintext , block_len ) : [EOL] num_bytes_in_last_block = len ( plaintext ) % block_len [EOL] [EOL] num_bytes_of_padding = block_len - num_bytes_in_last_block [EOL] [EOL] [comment] [EOL] [comment] [EOL] if num_bytes_of_padding == [number] : [EOL] num_bytes_of_padding = block_len [EOL] [EOL] return plaintext + bytes ( [ num_bytes_of_padding ] * num_bytes_of_padding ) [EOL] [EOL] [EOL] def remove_pkcs_7 ( plaintext ) : [EOL] num_bytes_of_padding = int . from_bytes ( plaintext [ - [number] : ] , byteorder = [string] ) [EOL] if num_bytes_of_padding == [number] : [EOL] raise BadPaddingValidation [EOL] [EOL] unpadded_plaintext = plaintext [EOL] for _ in range ( num_bytes_of_padding ) : [EOL] if plaintext [ - [number] : ] != unpadded_plaintext [ - [number] : ] : [EOL] raise BadPaddingValidation [EOL] unpadded_plaintext = unpadded_plaintext [ : - [number] ] [EOL] [EOL] return unpadded_plaintext [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class BadPaddingValidation ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] W = [number] [comment] [EOL] N = [number] [comment] [EOL] M = [number] [comment] [EOL] R = [number] [comment] [EOL] A = [number] [comment] [EOL] U = [number] [comment] [EOL] D = [number] [comment] [EOL] S = [number] [comment] [EOL] B = [number] [comment] [EOL] T = [number] [comment] [EOL] C = [number] [comment] [EOL] L = [number] [comment] [EOL] F = [number] [EOL] [EOL] BITMASK_32_BIT = [number] [EOL] [EOL] [EOL] class MersenneTwister ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , seed ) : [EOL] self . mt = [ [number] ] * N [comment] [EOL] self . index = N + [number] [EOL] [EOL] [comment] [EOL] self . lower_mask = ( [number] << R ) - [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . upper_mask = ( self . lower_mask ^ BITMASK_32_BIT ) & BITMASK_32_BIT [comment] [EOL] [EOL] self . seed_mt ( seed ) [EOL] [EOL] def seed_mt ( self , seed ) : [EOL] [docstring] [EOL] self . index = N [EOL] self . mt [ [number] ] = seed [EOL] for i in range ( [number] , N ) : [EOL] self . mt [ i ] = ( F * ( self . mt [ i - [number] ] ^ ( self . mt [ i - [number] ] >> ( W - [number] ) ) ) + i ) & BITMASK_32_BIT [comment] [EOL] [EOL] def extract_number ( self ) : [EOL] [docstring] [EOL] if self . index >= N : [EOL] if self . index > N : [EOL] raise Exception ( [string] ) [EOL] self . twist ( ) [EOL] [EOL] y = self . mt [ self . index ] [EOL] y = y ^ ( ( y >> U ) & D ) [EOL] y = y ^ ( ( y << S ) & B ) [EOL] y = y ^ ( ( y << T ) & C ) [EOL] y = y ^ ( y >> L ) [EOL] [EOL] self . index = self . index + [number] [EOL] return y & BITMASK_32_BIT [comment] [EOL] [EOL] def twist ( self ) : [EOL] [docstring] [EOL] for i in range ( [number] , N ) : [EOL] x = ( self . mt [ i ] & self . upper_mask ) + ( self . mt [ ( i + [number] ) % N ] & self . lower_mask ) [EOL] xA = x >> [number] [EOL] if ( x % [number] ) != [number] : [EOL] xA = xA ^ A [EOL] self . mt [ i ] = self . mt [ ( i + M ) % N ] ^ xA [EOL] self . index = [number] [EOL] [EOL] [EOL] def mersenne_untemper ( y ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] y = y ^ ( y >> L ) [EOL] [EOL] [comment] [EOL] y = y ^ ( ( y << T ) & C ) [EOL] [EOL] [comment] [EOL] y = reverse_op_3 ( y ) [EOL] [EOL] [comment] [EOL] y = reverse_op_4 ( y ) [EOL] [EOL] return y [EOL] [EOL] [EOL] def reverse_op_3 ( y ) : [EOL] x = y [EOL] for _ in range ( W ) : [comment] [EOL] x = x << S [EOL] x = y ^ ( x & B ) [EOL] return x [EOL] [EOL] [EOL] def reverse_op_4 ( y ) : [EOL] x = y [EOL] for _ in range ( W ) : [comment] [EOL] x = x >> U [EOL] x = y ^ ( x & D ) [EOL] return x [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0
from typing import Set , List , Any , Dict [EOL] import typing [EOL] import builtins [EOL] import cryptopals [EOL] import cryptography [EOL] import math [EOL] import os [EOL] import random [EOL] import string [EOL] from typing import Dict [EOL] [EOL] from cryptography . hazmat . backends import default_backend [EOL] from cryptography . hazmat . primitives . ciphers import algorithms , Cipher , modes [EOL] [EOL] from cryptopals . exceptions import BadPaddingValidation [EOL] from cryptopals . frequency import TEST_CHARACTERS [EOL] from cryptopals . padding import pkcs_7 , remove_pkcs_7 [EOL] from cryptopals . utils import xor [EOL] [EOL] [EOL] def aes_ecb_decrypt ( key , ciphertext , remove_padding = True ) : [EOL] decryptor = Cipher ( algorithms . AES ( key ) , modes . ECB ( ) , backend = default_backend ( ) ) . decryptor ( ) [EOL] [EOL] plaintext = decryptor . update ( ciphertext ) + decryptor . finalize ( ) [EOL] if remove_padding : [EOL] plaintext = remove_pkcs_7 ( plaintext ) [EOL] return plaintext [EOL] [EOL] [EOL] def aes_ecb_encrypt ( key , plaintext , block_size = [number] , padding = True ) : [EOL] if padding : [EOL] plaintext = pkcs_7 ( plaintext , block_size ) [EOL] [EOL] encryptor = Cipher ( algorithms . AES ( key ) , modes . ECB ( ) , backend = default_backend ( ) ) . encryptor ( ) [EOL] return encryptor . update ( plaintext ) + encryptor . finalize ( ) [EOL] [EOL] [EOL] def aes_cbc_decrypt ( key , ciphertext , iv , block_size = [number] , remove_padding = True , ) : [EOL] [EOL] if len ( ciphertext ) % block_size != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] num_blocks = len ( ciphertext ) // block_size [EOL] blocks = [ ciphertext [ x * block_size : ( x + [number] ) * block_size ] for x in range ( num_blocks ) ] [EOL] [EOL] plaintext = [string] [EOL] [EOL] for ind , block in enumerate ( reversed ( blocks ) ) : [EOL] block_num = num_blocks - ind [EOL] [EOL] if block_num == [number] : [EOL] block_to_xor = iv [EOL] else : [EOL] block_to_xor = blocks [ block_num - [number] ] [comment] [EOL] [EOL] aes_output = aes_ecb_decrypt ( key , block , remove_padding = False ) [EOL] this_block = xor ( aes_output , block_to_xor ) [EOL] [EOL] plaintext = this_block + plaintext [EOL] [EOL] if remove_padding : [EOL] plaintext = remove_pkcs_7 ( plaintext ) [EOL] [EOL] return plaintext [EOL] [EOL] [EOL] def aes_cbc_encrypt ( key , plaintext , iv , block_size = [number] ) : [EOL] [EOL] plaintext = pkcs_7 ( plaintext , block_size ) [EOL] [EOL] num_blocks = len ( plaintext ) // block_size [EOL] blocks = [ plaintext [ x * block_size : ( x + [number] ) * block_size ] for x in range ( num_blocks ) ] [EOL] [EOL] ciphertext = [string] [EOL] aes_output = [string] [EOL] for ind , block in enumerate ( blocks ) : [EOL] if ind == [number] : [EOL] block_to_xor = iv [EOL] else : [EOL] block_to_xor = aes_output [comment] [EOL] [EOL] this_block = xor ( block , block_to_xor ) [EOL] aes_output = aes_ecb_encrypt ( key , this_block , padding = False ) [EOL] [EOL] ciphertext = ciphertext + aes_output [EOL] [EOL] return ciphertext [EOL] [EOL] [EOL] def detect_ecb_use ( ciphertext , block_size = [number] ) : [EOL] num_blocks = math . ceil ( len ( ciphertext ) / block_size ) [EOL] [EOL] blocks = [ ] [EOL] for i in range ( num_blocks ) : [EOL] blocks . append ( ciphertext [ i * block_size : ( i + [number] ) * block_size ] ) [EOL] [EOL] unique_blocks = set ( blocks ) [EOL] if len ( unique_blocks ) != len ( blocks ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def gen_random_block ( block_size = [number] ) : [EOL] return os . urandom ( block_size ) [EOL] [EOL] [EOL] def encryption_ecb_cbc_detection_oracle ( key , plaintext ) : [EOL] [comment] [EOL] num_bytes_to_append = random . randrange ( [number] , [number] ) [EOL] pick_ecb_or_cbc = random . randrange ( [number] , [number] ) [EOL] [EOL] for _ in range ( num_bytes_to_append ) : [EOL] [comment] [EOL] plaintext = random . choice ( string . printable ) . encode ( [string] ) + plaintext [EOL] [comment] [EOL] plaintext = plaintext + random . choice ( string . printable ) . encode ( [string] ) [EOL] [EOL] if pick_ecb_or_cbc == [number] : [comment] [EOL] ciphertext = aes_ecb_encrypt ( key , plaintext ) [EOL] elif pick_ecb_or_cbc == [number] : [comment] [EOL] iv = gen_random_block ( ) [EOL] ciphertext = aes_cbc_encrypt ( key , plaintext , iv ) [EOL] [EOL] return ciphertext [EOL] [EOL] [EOL] def ecb_encrypt_append ( key , plaintext , append ) : [EOL] [comment] [EOL] plaintext = plaintext + append [EOL] [EOL] return aes_ecb_encrypt ( key , plaintext ) [EOL] [EOL] [EOL] def ecb_encrypt_prepend_and_append ( key , plaintext , append , prepend ) : [EOL] plaintext = prepend + plaintext + append [EOL] [EOL] return aes_ecb_encrypt ( key , plaintext ) [EOL] [EOL] [EOL] def cbc_encrypt_prepend_and_append ( key , iv , plaintext , append , prepend ) : [EOL] plaintext = prepend + plaintext + append [EOL] [EOL] return aes_cbc_encrypt ( key , plaintext , iv ) [EOL] [EOL] [EOL] def construct_ecb_attack_dict ( key , prefix , blocksize = [number] ) : [EOL] dict_to_construct = { } [EOL] for char in TEST_CHARACTERS : [EOL] plaintext = prefix + char . encode ( [string] ) [EOL] ciphertext = aes_ecb_encrypt ( key , plaintext ) [ [number] : blocksize ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] dict_to_construct [ ciphertext ] = char [EOL] [EOL] return dict_to_construct [EOL] [EOL] [EOL] def cbc_padding_oracle ( key , ciphertext , iv ) : [EOL] try : [EOL] aes_cbc_decrypt ( key , ciphertext , iv , remove_padding = True ) [EOL] return True [EOL] except BadPaddingValidation : [EOL] return False [EOL] [EOL] [EOL] class CounterMode ( object ) : [EOL] def __init__ ( self , key , nonce , block_size ) : [EOL] self . key = key [EOL] self . nonce = bytes ( [ nonce ] ) [EOL] self . counter = [number] [EOL] self . block_size = block_size [EOL] self . cipher = [string] [EOL] [EOL] def _generate_keystream_block ( self ) : [EOL] num_bytes_for_nonce = [number] [comment] [EOL] counter = bytes ( [ self . counter ] ) . rjust ( self . block_size - num_bytes_for_nonce , [string] ) + self . nonce . ljust ( num_bytes_for_nonce , [string] ) [EOL] keystream = aes_ecb_encrypt ( self . key , counter , self . block_size , False ) [EOL] self . counter += [number] [EOL] return keystream [EOL] [EOL] def _xor_with_keystream ( self , text ) : [EOL] result = [ ] [EOL] keystream = [string] [EOL] for text_byte in text : [EOL] if len ( keystream ) == [number] : [EOL] keystream = self . _generate_keystream_block ( ) [EOL] result_byte = keystream [ [number] ] ^ text_byte [EOL] result . append ( bytes ( [ result_byte ] ) ) [EOL] keystream = keystream [ [number] : ] [EOL] return [string] . join ( result ) [EOL] [EOL] def decrypt ( self , ciphertext ) : [EOL] return self . _xor_with_keystream ( ciphertext ) [EOL] [EOL] def encrypt ( self , plaintext ) : [EOL] return self . _xor_with_keystream ( plaintext ) [EOL] [EOL] [EOL] def aes_ctr_decrypt ( key , ciphertext , nonce , block_size = [number] ) : [EOL] [EOL] count = CounterMode ( key , nonce , block_size ) [EOL] return count . decrypt ( ciphertext ) [EOL] [EOL] [EOL] def aes_ctr_encrypt ( key , plaintext , nonce , block_size = [number] ) : [EOL] [EOL] count = CounterMode ( key , nonce , block_size ) [EOL] return count . encrypt ( plaintext ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.int$ 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import itertools [EOL] import builtins [EOL] import typing [EOL] import base64 [EOL] import itertools [EOL] [EOL] [EOL] def hex_to_base64 ( hex_str ) : [EOL] hex_bytes = hex_to_bytes ( hex_str ) [EOL] base64_str = bytes_to_base64 ( hex_bytes ) [EOL] return base64_str [EOL] [EOL] [EOL] def hex_to_bytes ( hex_str ) : [EOL] return bytes . fromhex ( hex_str ) [EOL] [EOL] [EOL] def bytes_to_hex ( bytes_input ) : [EOL] return bytes_input . hex ( ) [EOL] [EOL] [EOL] def base64_to_bytes ( str_input ) : [EOL] return base64 . b64decode ( str_input ) [EOL] [EOL] [EOL] def bytes_to_base64 ( bytes_input ) : [EOL] return base64 . b64encode ( bytes_input ) . decode ( [string] ) [EOL] [EOL] [EOL] def xor_hex_strings ( input_a , input_b ) : [EOL] bytes_result = xor ( hex_to_bytes ( input_a ) , hex_to_bytes ( input_b ) ) [EOL] return bytes_to_hex ( bytes_result ) [EOL] [EOL] [EOL] def hex_to_ascii ( hex_str ) : [EOL] return bytes . fromhex ( hex_str ) . decode ( [string] ) [EOL] [EOL] [EOL] def xor ( input_a , input_b ) : [EOL] input_b_generator = itertools . cycle ( input_b ) [EOL] result = [ a ^ b for a , b in zip ( input_a , input_b_generator ) ] [EOL] return bytes ( result ) [EOL] [EOL] [EOL] def edit_distance ( input_a , input_b ) : [EOL] differing_bits = [ x ^ y for x , y in zip ( input_a , input_b ) ] [EOL] return [string] . join ( [ bin ( x ) for x in differing_bits ] ) . count ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import builtins [EOL] import typing [EOL] from typing import Dict [EOL] [EOL] [EOL] def parse_structured_cookie ( cookie ) : [EOL] unpacked_cookie = { } [EOL] fields = cookie . split ( [string] ) [EOL] for field in fields : [EOL] key = field . split ( [string] ) [ [number] ] . strip ( ) [EOL] value = field . split ( [string] ) [ [number] ] . strip ( ) [EOL] unpacked_cookie [ key ] = value [EOL] [EOL] return unpacked_cookie [EOL] [EOL] [EOL] def generate_profile_for ( email , uid = [number] , role = [string] ) : [EOL] if [string] in email or [string] in email : [EOL] raise ValueError ( [string] ) [EOL] [EOL] return [string] . format ( email , uid , role ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import builtins [EOL] import typing [EOL] import math [EOL] from typing import Tuple [EOL] [EOL] from cryptopals . frequency import score_english_text , TEST_CHARACTERS [EOL] from cryptopals . utils import xor , edit_distance [EOL] [EOL] [EOL] def break_single_char_xor ( ciphertext ) : [EOL] potential_keys = [ x . encode ( [string] ) for x in list ( TEST_CHARACTERS ) ] [EOL] [EOL] best_key = [string] [EOL] best_metric = [number] [EOL] for key in potential_keys : [EOL] result = xor ( ciphertext , key ) [EOL] try : [EOL] metric = score_english_text ( result . decode ( [string] ) ) [EOL] except UnicodeDecodeError : [comment] [EOL] metric = [number] [EOL] [EOL] if metric < best_metric : [EOL] best_metric = metric [EOL] best_key = key [EOL] [EOL] return best_key , best_metric [EOL] [EOL] [EOL] def break_repeating_key_xor ( ciphertext , max_keysize = [number] ) : [EOL] keysizes = range ( [number] , max_keysize + [number] ) [EOL] [EOL] best_edit_distance = [number] [comment] [EOL] best_keysize = [number] [comment] [EOL] for keysize in keysizes : [EOL] num_fragments = math . floor ( len ( ciphertext ) / keysize ) [EOL] total_edit_distance = [number] [EOL] [EOL] for fragment_index in range ( [number] , num_fragments ) : [EOL] [EOL] first_keysize_worth_of_bytes = ciphertext [ ( fragment_index - [number] ) * keysize : fragment_index * keysize ] [EOL] second_keysize_worth_of_bytes = ciphertext [ fragment_index * keysize : ( fragment_index + [number] ) * keysize ] [EOL] [EOL] fragment_edit_distance = edit_distance ( first_keysize_worth_of_bytes , second_keysize_worth_of_bytes ) [EOL] [EOL] total_edit_distance += fragment_edit_distance [EOL] [EOL] average_edit_distance = total_edit_distance / num_fragments [EOL] normalized_edit_distance = average_edit_distance / float ( keysize ) [EOL] [EOL] if normalized_edit_distance < best_edit_distance : [EOL] best_edit_distance = normalized_edit_distance [EOL] best_keysize = keysize [EOL] [EOL] [comment] [EOL] [comment] [EOL] num_fragments = math . floor ( len ( ciphertext ) / best_keysize ) [EOL] key = [string] [EOL] [EOL] for key_index in range ( best_keysize ) : [EOL] ciphertext_for_this_problem = [string] [EOL] [EOL] [comment] [EOL] [EOL] for fragment_index in range ( [number] , num_fragments ) : [EOL] starting_index = ( fragment_index - [number] ) * best_keysize [EOL] ending_index = fragment_index * best_keysize [EOL] fragment = ciphertext [ starting_index : ending_index ] [EOL] ciphertext_for_this_problem += chr ( fragment [ key_index ] ) [EOL] [EOL] key_this_problem , _ = break_single_char_xor ( ciphertext_for_this_problem . encode ( [string] ) ) [EOL] key += key_this_problem [EOL] [EOL] return key [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Counter , Tuple , Dict , List , Any [EOL] import builtins [EOL] import collections [EOL] import typing [EOL] from collections import Counter [EOL] import string [EOL] import os [EOL] [EOL] from typing import Dict , List [EOL] [EOL] [EOL] RELATIVE_PATH_TO_ENGLISH_TEXT = [string] [EOL] TEST_CHARACTERS = string . printable [EOL] [EOL] [EOL] def compute_english_frequencies ( ) : [EOL] path_to_english_text = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , RELATIVE_PATH_TO_ENGLISH_TEXT ) [EOL] [EOL] with open ( path_to_english_text , [string] ) as f : [EOL] text = f . read ( ) . decode ( [string] ) [EOL] [EOL] english_frequencies = { } [EOL] for char in TEST_CHARACTERS : [EOL] english_frequencies [ char ] = text . count ( char ) / len ( text ) [EOL] [EOL] return english_frequencies [EOL] [EOL] [EOL] def top_n_english_words ( n ) : [EOL] path_to_english_text = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , RELATIVE_PATH_TO_ENGLISH_TEXT ) [EOL] [EOL] with open ( path_to_english_text , [string] ) as f : [EOL] text = f . read ( ) . decode ( [string] ) . split ( ) [EOL] [EOL] counter = Counter ( text ) [EOL] words_and_frequencies = counter . most_common ( n ) [EOL] words = [ x for ( x , y ) in words_and_frequencies ] [EOL] return words [EOL] [EOL] [EOL] def score_english_text ( text ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] metric = [number] [EOL] english_frequencies = compute_english_frequencies ( ) [EOL] [EOL] text = text . lower ( ) [EOL] for letter in TEST_CHARACTERS : [EOL] observed = text . count ( letter ) / len ( text ) [comment] [EOL] expected = english_frequencies [ letter ] [EOL] metric += abs ( observed - expected ) [EOL] [EOL] return metric [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0