[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] ADDR_SERVICE_ROOT_DIR = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] ADDRESS_BOOK_SCHEMA_FILE = os . path . abspath ( os . path . join ( ADDR_SERVICE_ROOT_DIR , [string] ) ) [EOL] [EOL] with open ( ADDRESS_BOOK_SCHEMA_FILE , mode = [string] , encoding = [string] ) as f : [EOL] ADDRESS_BOOK_SCHEMA = json . load ( f ) [EOL] [EOL] LOGGER_NAME = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [EOL] from typing import Mapping , Sequence , List , Any , Dict , Union , Optional [EOL] import builtins [EOL] import typing [EOL] import addrservice [EOL] from enum import Enum , unique [EOL] from typing import ( Any , Mapping , Optional , Sequence , Union ) [EOL] [EOL] [EOL] VALUE_ERR_MSG = [string] [EOL] [EOL] [EOL] @ unique class AddressType ( Enum ) : [EOL] home = [number] , [EOL] work = [number] [EOL] [EOL] [EOL] class Address : [EOL] def __init__ ( self , kind , street_name , pincode , country , building_name = None , unit_number = None , street_number = None , locality = None , city = None , province = None , ) : [EOL] if kind is None : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , kind ) ) [EOL] if not street_name : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , street_name ) ) [EOL] if not pincode : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , pincode ) ) [EOL] if not country : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , country ) ) [EOL] [EOL] self . _kind = kind [EOL] self . _building_name = building_name [EOL] self . _unit_number = unit_number [EOL] self . _street_number = street_number [EOL] self . _street_name = street_name [EOL] self . _locality = locality [EOL] self . _city = city [EOL] self . _province = province [EOL] self . _pincode = pincode [EOL] self . _country = country [EOL] [EOL] @ classmethod def from_api_dm ( cls , vars ) : [EOL] return Address ( kind = AddressType [ vars [ [string] ] ] , street_name = vars [ [string] ] , pincode = vars [ [string] ] , country = vars [ [string] ] , building_name = vars . get ( [string] ) , unit_number = vars . get ( [string] ) , street_number = vars . get ( [string] ) , locality = vars . get ( [string] ) , city = vars . get ( [string] ) , province = vars . get ( [string] ) , ) [EOL] [EOL] @ property def kind ( self ) : [EOL] return self . _kind [EOL] [EOL] @ kind . setter def kind ( self , value ) : [EOL] if value is None : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _kind = value [EOL] [EOL] @ property def building_name ( self ) : [EOL] return self . _building_name [EOL] [EOL] @ building_name . setter def building_name ( self , value ) : [EOL] self . _building_name = value [EOL] [EOL] @ property def unit_number ( self ) : [EOL] return self . _unit_number [EOL] [EOL] @ unit_number . setter def unit_number ( self , value ) : [EOL] self . _unit_number = value [EOL] [EOL] @ property def street_number ( self ) : [EOL] return self . _street_number [EOL] [EOL] @ street_number . setter def street_number ( self , value ) : [EOL] self . _street_number = value [EOL] [EOL] @ property def street_name ( self ) : [EOL] return self . _street_name [EOL] [EOL] @ street_name . setter def street_name ( self , value ) : [EOL] if not value : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _street_name = value [EOL] [EOL] @ property def locality ( self ) : [EOL] return self . _locality [EOL] [EOL] @ locality . setter def locality ( self , value ) : [EOL] self . _locality = value [EOL] [EOL] @ property def city ( self ) : [EOL] return self . _city [EOL] [EOL] @ city . setter def city ( self , value ) : [EOL] self . _ = value [EOL] [EOL] @ property def province ( self ) : [EOL] return self . _province [EOL] [EOL] @ province . setter def province ( self , value ) : [EOL] self . _province = value [EOL] [EOL] @ property def pincode ( self ) : [EOL] return self . _pincode [EOL] [EOL] @ pincode . setter def pincode ( self , value ) : [EOL] if not value : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _pincode = value [EOL] [EOL] @ property def country ( self ) : [EOL] return self . _country [EOL] [EOL] @ country . setter def country ( self , value ) : [EOL] if not value : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _country = value [EOL] [EOL] def to_api_dm ( self ) : [EOL] d = { [string] : self . kind . name , [string] : self . building_name , [string] : self . unit_number , [string] : self . street_number , [string] : self . street_name , [string] : self . locality , [string] : self . city , [string] : self . province , [string] : self . pincode , [string] : self . country , } [EOL] [EOL] return { k : v for k , v in d . items ( ) if v is not None } [EOL] [EOL] [EOL] class Phone : [EOL] def __init__ ( self , kind , country_code , local_number , area_code = None , ) : [EOL] if kind is None : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , kind ) ) [EOL] if not country_code : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , country_code ) ) [EOL] if not local_number : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , local_number ) ) [EOL] [EOL] self . _kind = kind [EOL] self . _country_code = country_code [EOL] self . _area_code = area_code [EOL] self . _local_number = local_number [EOL] [EOL] @ classmethod def from_api_dm ( cls , vars ) : [EOL] return Phone ( kind = AddressType [ vars [ [string] ] ] , country_code = vars [ [string] ] , local_number = vars [ [string] ] , area_code = vars . get ( [string] ) , ) [EOL] [EOL] @ property def kind ( self ) : [EOL] return self . _kind [EOL] [EOL] @ kind . setter def kind ( self , value ) : [EOL] if value is None : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _kind = value [EOL] [EOL] @ property def country_code ( self ) : [EOL] return self . _country_code [EOL] [EOL] @ country_code . setter def country_code ( self , value ) : [EOL] if not value : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _country_code = value [EOL] [EOL] @ property def area_code ( self ) : [EOL] return self . _area_code [EOL] [EOL] @ area_code . setter def area_code ( self , value ) : [EOL] self . _ = value [EOL] [EOL] @ property def local_number ( self ) : [EOL] return self . _local_number [EOL] [EOL] @ local_number . setter def local_number ( self , value ) : [EOL] if not value : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _local_number = value [EOL] [EOL] def to_api_dm ( self ) : [EOL] d = { [string] : self . kind . name , [string] : self . country_code , [string] : self . area_code , [string] : self . local_number , } [EOL] [EOL] return { k : v for k , v in d . items ( ) if v is not None } [EOL] [EOL] [EOL] class Email : [EOL] def __init__ ( self , kind , email , ) : [EOL] if kind is None : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , kind ) ) [EOL] if not email : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , email ) ) [EOL] [EOL] self . _kind = kind [EOL] self . _email = email [EOL] [EOL] @ classmethod def from_api_dm ( cls , vars ) : [EOL] return Email ( kind = AddressType [ vars [ [string] ] ] , email = vars [ [string] ] , ) [EOL] [EOL] @ property def kind ( self ) : [EOL] return self . _kind [EOL] [EOL] @ kind . setter def kind ( self , value ) : [EOL] if value is None : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _kind = value [EOL] [EOL] @ property def email ( self ) : [EOL] return self . _email [EOL] [EOL] @ email . setter def email ( self , value ) : [EOL] if not value : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _email = value [EOL] [EOL] def to_api_dm ( self ) : [EOL] d = { [string] : self . kind . name , [string] : self . email , } [EOL] [EOL] return { k : v for k , v in d . items ( ) if v is not None } [EOL] [EOL] [EOL] class AddressEntry : [EOL] def __init__ ( self , full_name , addresses = [ ] , phone_numbers = [ ] , fax_numbers = [ ] , emails = [ ] , ) : [EOL] if not full_name : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , full_name ) ) [EOL] [EOL] self . _full_name = full_name [EOL] self . _addresses = list ( addresses ) [EOL] self . _phone_numbers = list ( phone_numbers ) [EOL] self . _fax_numbers = list ( fax_numbers ) [EOL] self . _emails = list ( emails ) [EOL] [EOL] @ classmethod def from_api_dm ( cls , vars ) : [EOL] return AddressEntry ( full_name = vars [ [string] ] , addresses = [ Address . from_api_dm ( x ) for x in vars . get ( [string] , [ ] ) ] , phone_numbers = [ Phone . from_api_dm ( x ) for x in vars . get ( [string] , [ ] ) ] , fax_numbers = [ Phone . from_api_dm ( x ) for x in vars . get ( [string] , [ ] ) ] , emails = [ Email . from_api_dm ( x ) for x in vars . get ( [string] , [ ] ) ] , ) [EOL] [EOL] @ property def full_name ( self ) : [EOL] return self . _full_name [EOL] [EOL] @ full_name . setter def full_name ( self , value ) : [EOL] if not value : [EOL] raise ValueError ( VALUE_ERR_MSG . format ( [string] , value ) ) [EOL] [EOL] self . _full_name = value [EOL] [EOL] @ property def addresses ( self ) : [EOL] return self . _addresses [EOL] [EOL] @ addresses . setter def addresses ( self , value ) : [EOL] self . _addresses = list ( value ) [EOL] [EOL] @ property def phone_numbers ( self ) : [EOL] return self . _phone_numbers [EOL] [EOL] @ phone_numbers . setter def phone_numbers ( self , value ) : [EOL] self . _phone_numbers = list ( value ) [EOL] [EOL] @ property def fax_numbers ( self ) : [EOL] return self . _fax_numbers [EOL] [EOL] @ fax_numbers . setter def fax_numbers ( self , value ) : [EOL] self . _fax_numbers = list ( value ) [EOL] [EOL] @ property def emails ( self ) : [EOL] return self . _emails [EOL] [EOL] @ emails . setter def emails ( self , value ) : [EOL] self . _emails = list ( value ) [EOL] [EOL] def to_api_dm ( self ) : [EOL] d = { [string] : self . full_name , [string] : [ x . to_api_dm ( ) for x in self . addresses ] , [string] : [ x . to_api_dm ( ) for x in self . phone_numbers ] , [string] : [ x . to_api_dm ( ) for x in self . fax_numbers ] , [string] : [ x . to_api_dm ( ) for x in self . emails ] , } [EOL] [EOL] return { k : v for k , v in d . items ( ) if v is not None } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.AddressType$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $'Phone'$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $AddressType$ 0 0 0 0 $AddressType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $AddressType$ 0 0 0 0 0 0 0 0 $AddressType$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AddressType$ 0 $builtins.str$ 0 0 0 0 0 $AddressType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $AddressType$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $addrservice.datamodel.AddressType$ 0 $AddressType$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $'Email'$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $AddressType$ 0 0 0 0 $AddressType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $AddressType$ 0 0 0 0 0 0 0 0 $AddressType$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Sequence[Address]$ 0 0 0 0 $typing.Sequence[Phone]$ 0 0 0 0 $typing.Sequence[Phone]$ 0 0 0 0 $typing.Sequence[Email]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Sequence[Address]$ 0 0 0 0 0 0 0 0 $typing.Sequence[Phone]$ 0 0 0 0 0 0 0 0 $typing.Sequence[Phone]$ 0 0 0 0 0 0 0 0 $typing.Sequence[Email]$ 0 0 0 0 0 0 $'AddressEntry'$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[Address]$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[Address]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[Phone]$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[Phone]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[Phone]$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[Phone]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[Email]$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[Email]$ 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Mapping[builtins.str,typing.Any]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Mapping[builtins.str,typing.Any]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Tuple , AsyncIterator , Mapping [EOL] import builtins [EOL] import typing [EOL] import addrservice [EOL] import logging [EOL] import jsonschema [comment] [EOL] import logging [EOL] from typing import AsyncIterator , Mapping , Tuple [EOL] [EOL] from addrservice import ADDRESS_BOOK_SCHEMA [EOL] from addrservice . database . db_engines import create_addressbook_db [EOL] from addrservice . datamodel import AddressEntry [EOL] [EOL] [EOL] class AddressBookService : [EOL] def __init__ ( self , config , logger ) : [EOL] self . addr_db = create_addressbook_db ( config [ [string] ] ) [EOL] self . logger = logger [EOL] [EOL] def start ( self ) : [EOL] self . addr_db . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] self . addr_db . stop ( ) [EOL] [EOL] def validate_address ( self , addr ) : [EOL] try : [EOL] jsonschema . validate ( addr , ADDRESS_BOOK_SCHEMA ) [EOL] except jsonschema . exceptions . ValidationError : [EOL] raise ValueError ( [string] ) [EOL] [EOL] async def create_address ( self , value ) : [EOL] self . validate_address ( value ) [EOL] addr = AddressEntry . from_api_dm ( value ) [EOL] key = await self . addr_db . create_address ( addr ) [EOL] return key [EOL] [EOL] async def get_address ( self , key ) : [EOL] addr = await self . addr_db . read_address ( key ) [EOL] return addr . to_api_dm ( ) [EOL] [EOL] async def update_address ( self , key , value ) : [EOL] self . validate_address ( value ) [EOL] addr = AddressEntry . from_api_dm ( value ) [EOL] await self . addr_db . update_address ( key , addr ) [EOL] [EOL] async def delete_address ( self , key ) : [EOL] await self . addr_db . delete_address ( key ) [EOL] [EOL] async def get_all_addresses ( self ) : [EOL] async for nickname , addr in self . addr_db . read_all_addresses ( ) : [EOL] yield nickname , addr . to_api_dm ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping$ 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 $logging.Logger$ 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 $addrservice.datamodel.AddressEntry$ 0 0 0 0 0 $typing.Mapping$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $addrservice.datamodel.AddressEntry$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Mapping$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Mapping$ 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 $addrservice.datamodel.AddressEntry$ 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $addrservice.datamodel.AddressEntry$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.AsyncIterator[typing.Tuple[builtins.str,typing.Mapping]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import addrservice [EOL] from typing import Dict [EOL] [EOL] from addrservice . database . addressbook_db import ( AbstractAddressBookDB , InMemoryAddressBookDB , FilesystemAddressBookDB ) [EOL] [EOL] [EOL] def create_addressbook_db ( addr_db_config ) : [EOL] db_type = list ( addr_db_config . keys ( ) ) [ [number] ] [EOL] db_config = addr_db_config [ db_type ] [EOL] [EOL] return { [string] : lambda cfg : InMemoryAddressBookDB ( ) , [string] : lambda cfg : FilesystemAddressBookDB ( cfg ) , } [ db_type ] ( db_config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.database.addressbook_db.AbstractAddressBookDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
[comment] [EOL] [EOL] from typing import Any , Dict [EOL] import asyncio [EOL] import builtins [EOL] import tornado [EOL] import addrservice [EOL] import logging [EOL] import typing [EOL] import argparse [EOL] import aiotask_context as context [comment] [EOL] import argparse [EOL] import asyncio [EOL] import logging [EOL] import logging . config [EOL] from typing import Dict [EOL] import yaml [EOL] [EOL] import tornado . web [EOL] [EOL] from addrservice import LOGGER_NAME [EOL] from addrservice . service import AddressBookService [EOL] from addrservice . tornado . app import make_addrservice_app [EOL] import addrservice . utils . logutils as logutils [EOL] [EOL] [EOL] def parse_args ( args = None ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = int , default = [number] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , required = True , type = argparse . FileType ( [string] ) , help = [string] ) [EOL] [EOL] args = parser . parse_args ( args ) [EOL] return args [EOL] [EOL] [EOL] def run_server ( app , service , config , port , debug , logger ) : [EOL] name = config [ [string] ] [ [string] ] [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . set_task_factory ( context . task_factory ) [EOL] [EOL] [comment] [EOL] service . start ( ) [EOL] [EOL] [comment] [EOL] http_server_args = { [string] : True } [EOL] http_server = app . listen ( port , [string] , ** http_server_args ) [EOL] logutils . log ( logger , logging . INFO , message = [string] , service_name = name , port = port ) [EOL] [EOL] try : [EOL] [comment] [EOL] loop . run_forever ( ) [EOL] except KeyboardInterrupt : [EOL] [comment] [EOL] pass [EOL] finally : [EOL] loop . stop ( ) [EOL] logutils . log ( logger , logging . INFO , message = [string] , service_name = name ) [EOL] http_server . stop ( ) [EOL] [comment] [EOL] loop . run_until_complete ( loop . shutdown_asyncgens ( ) ) [EOL] service . stop ( ) [EOL] loop . close ( ) [EOL] logutils . log ( logger , logging . INFO , message = [string] , service_name = name ) [EOL] [EOL] [EOL] def main ( args = parse_args ( ) ) : [EOL] [docstring] [EOL] [EOL] config = yaml . load ( args . config . read ( ) , Loader = yaml . SafeLoader ) [EOL] [EOL] [comment] [EOL] logging . config . dictConfig ( config [ [string] ] ) [EOL] logger = logging . getLogger ( LOGGER_NAME ) [EOL] [EOL] addr_service , addr_app = make_addrservice_app ( config , args . debug , logger ) [EOL] [EOL] run_server ( app = addr_app , service = addr_service , config = config , port = args . port , debug = args . debug , logger = logger ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Dict [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import aiotask_context as context [comment] [EOL] import logfmt [comment] [EOL] import logging [EOL] import re [EOL] import traceback [EOL] from typing import Dict [EOL] [EOL] LOG_CONTEXT = [string] [EOL] [EOL] [EOL] def get_log_context ( ) : [EOL] log_context = context . get ( LOG_CONTEXT ) [EOL] if log_context is None : [EOL] log_context = { } [EOL] context . set ( LOG_CONTEXT , log_context ) [EOL] [EOL] return log_context [EOL] [EOL] [EOL] def set_log_context ( ** kwargs ) : [EOL] log_context = get_log_context ( ) [EOL] log_context . update ( kwargs ) [EOL] [EOL] [EOL] def clear_log_context ( ) : [EOL] log_context = get_log_context ( ) [EOL] log_context . clear ( ) [EOL] [EOL] [EOL] def log ( logger , lvl , include_context = False , ** kwargs ) : [EOL] [comment] [EOL] [EOL] all_info = { ** get_log_context ( ) , ** kwargs } if include_context else kwargs [EOL] [EOL] info = { k : v for k , v in all_info . items ( ) if k not in [ [string] , [string] , [string] ] } [EOL] [EOL] exc_info = all_info . get ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] if exc_info : [comment] [EOL] trace = [string] . join ( traceback . format_exception ( * exc_info ) ) [EOL] info [ [string] ] = re . sub ( [string] , [string] , trace ) [EOL] [EOL] msg = next ( logfmt . format ( info ) ) [EOL] logger . log ( lvl , msg , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [EOL] from typing import Dict , Any , Sequence , List [EOL] import builtins [EOL] import typing [EOL] import glob [EOL] import json [EOL] import os [EOL] from typing import Dict , Sequence [EOL] [EOL] ADDR_SERVICE_TEST_DATA_DIR = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] ADDRESS_DATA_DIR = os . path . abspath ( os . path . join ( ADDR_SERVICE_TEST_DATA_DIR , [string] ) ) [EOL] [EOL] ADDRESS_FILES = glob . glob ( ADDRESS_DATA_DIR + [string] ) [EOL] [EOL] [EOL] def address_data_suite ( json_files = ADDRESS_FILES ) : [EOL] addr_data_suite = { } [EOL] [EOL] for fname in json_files : [EOL] nickname = os . path . splitext ( os . path . basename ( fname ) ) [ [number] ] [EOL] with open ( fname , mode = [string] , encoding = [string] ) as f : [EOL] addr_json = json . load ( f ) [EOL] addr_data_suite [ nickname ] = addr_json [EOL] [EOL] return addr_data_suite [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] [EOL] import tornado . testing [EOL] [EOL] from addrservice . tornado . app import ( ADDRESSBOOK_ENTRY_URI_FORMAT_STR ) [EOL] [EOL] from tests . unit . tornado_app_handlers_test import ( AddressServiceTornadoAppTestSetup ) [EOL] [EOL] [EOL] class TestAddressServiceApp ( AddressServiceTornadoAppTestSetup ) : [EOL] def test_address_book_endpoints ( self ) : [EOL] [comment] [EOL] r = self . fetch ( ADDRESSBOOK_ENTRY_URI_FORMAT_STR . format ( id = [string] ) , method = [string] , headers = None , ) [EOL] all_addrs = json . loads ( r . body . decode ( [string] ) ) [EOL] self . assertEqual ( r . code , [number] , all_addrs ) [EOL] self . assertEqual ( len ( all_addrs ) , [number] , all_addrs ) [EOL] [EOL] [comment] [EOL] r = self . fetch ( ADDRESSBOOK_ENTRY_URI_FORMAT_STR . format ( id = [string] ) , method = [string] , headers = self . headers , body = json . dumps ( self . addr0 ) , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] addr_uri = r . headers [ [string] ] [EOL] [EOL] [comment] [EOL] r = self . fetch ( ADDRESSBOOK_ENTRY_URI_FORMAT_STR . format ( id = [string] ) , method = [string] , headers = None , ) [EOL] all_addrs = json . loads ( r . body . decode ( [string] ) ) [EOL] self . assertEqual ( r . code , [number] , all_addrs ) [EOL] self . assertEqual ( len ( all_addrs ) , [number] , all_addrs ) [EOL] [EOL] [comment] [EOL] r = self . fetch ( ADDRESSBOOK_ENTRY_URI_FORMAT_STR . format ( id = [string] ) , method = [string] , headers = self . headers , body = [string] , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] self . assertEqual ( r . reason , [string] ) [EOL] r = self . fetch ( ADDRESSBOOK_ENTRY_URI_FORMAT_STR . format ( id = [string] ) , method = [string] , headers = self . headers , body = json . dumps ( { } ) , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] self . assertEqual ( r . reason , [string] ) [EOL] [EOL] [comment] [EOL] r = self . fetch ( addr_uri , method = [string] , headers = None , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] self . assertEqual ( self . addr0 , json . loads ( r . body . decode ( [string] ) ) ) [EOL] [EOL] [comment] [EOL] r = self . fetch ( ADDRESSBOOK_ENTRY_URI_FORMAT_STR . format ( id = [string] ) , method = [string] , headers = None , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] [EOL] [comment] [EOL] r = self . fetch ( addr_uri , method = [string] , headers = self . headers , body = json . dumps ( self . addr1 ) , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] r = self . fetch ( addr_uri , method = [string] , headers = None , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] self . assertEqual ( self . addr1 , json . loads ( r . body . decode ( [string] ) ) ) [EOL] [EOL] [comment] [EOL] r = self . fetch ( addr_uri , method = [string] , headers = self . headers , body = [string] , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] self . assertEqual ( r . reason , [string] ) [EOL] r = self . fetch ( ADDRESSBOOK_ENTRY_URI_FORMAT_STR . format ( id = [string] ) , method = [string] , headers = self . headers , body = json . dumps ( self . addr1 ) , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] r = self . fetch ( addr_uri , method = [string] , headers = self . headers , body = json . dumps ( { } ) , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] self . assertEqual ( r . reason , [string] ) [EOL] [EOL] [comment] [EOL] r = self . fetch ( addr_uri , method = [string] , headers = None , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] r = self . fetch ( addr_uri , method = [string] , headers = None , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] [EOL] [comment] [EOL] r = self . fetch ( addr_uri , method = [string] , headers = None , ) [EOL] self . assertEqual ( r . code , [number] ) [EOL] [EOL] [comment] [EOL] r = self . fetch ( ADDRESSBOOK_ENTRY_URI_FORMAT_STR . format ( id = [string] ) , method = [string] , headers = None , ) [EOL] all_addrs = json . loads ( r . body . decode ( [string] ) ) [EOL] self . assertEqual ( r . code , [number] , all_addrs ) [EOL] self . assertEqual ( len ( all_addrs ) , [number] , all_addrs ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] tornado . testing . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import addrservice [EOL] import logging [EOL] import asynctest [comment] [EOL] from io import StringIO [EOL] import logging [EOL] import logging . config [EOL] import unittest [EOL] import yaml [EOL] [EOL] from addrservice import LOGGER_NAME [EOL] from addrservice . datamodel import AddressEntry [EOL] from addrservice . service import AddressBookService [EOL] from data import address_data_suite [EOL] [EOL] IN_MEMORY_CFG_TXT = [string] [EOL] [EOL] with StringIO ( IN_MEMORY_CFG_TXT ) as f : [EOL] TEST_CONFIG = yaml . load ( f . read ( ) , Loader = yaml . SafeLoader ) [EOL] [EOL] [EOL] class AddressBookServiceWithInMemoryDBTest ( asynctest . TestCase ) : [EOL] async def setUp ( self ) : [EOL] logging . config . dictConfig ( TEST_CONFIG [ [string] ] ) [EOL] logger = logging . getLogger ( LOGGER_NAME ) [EOL] [EOL] self . service = AddressBookService ( config = TEST_CONFIG , logger = logger ) [EOL] self . service . start ( ) [EOL] [EOL] self . address_data = address_data_suite ( ) [EOL] for nickname , val in self . address_data . items ( ) : [EOL] addr = AddressEntry . from_api_dm ( val ) [EOL] await self . service . addr_db . create_address ( addr , nickname ) [EOL] [EOL] async def tearDown ( self ) : [EOL] self . service . stop ( ) [EOL] [EOL] @ asynctest . fail_on ( active_handles = True ) async def test_get_address ( self ) : [EOL] for nickname , addr in self . address_data . items ( ) : [EOL] value = await self . service . get_address ( nickname ) [EOL] self . assertEqual ( addr , value ) [EOL] [EOL] @ asynctest . fail_on ( active_handles = True ) async def test_get_all_addresses ( self ) : [EOL] all_addr = { } [EOL] async for nickname , addr in self . service . get_all_addresses ( ) : [EOL] all_addr [ nickname ] = addr [EOL] self . assertEqual ( len ( all_addr ) , [number] ) [EOL] [EOL] @ asynctest . fail_on ( active_handles = True ) async def test_crud_address ( self ) : [EOL] nicknames = list ( self . address_data . keys ( ) ) [EOL] self . assertGreaterEqual ( len ( nicknames ) , [number] ) [EOL] [EOL] addr0 = self . address_data [ nicknames [ [number] ] ] [EOL] key = await self . service . create_address ( addr0 ) [EOL] val = await self . service . get_address ( key ) [EOL] self . assertEqual ( addr0 , val ) [EOL] [EOL] addr1 = self . address_data [ nicknames [ [number] ] ] [EOL] await self . service . update_address ( key , addr1 ) [EOL] val = await self . service . get_address ( key ) [EOL] self . assertEqual ( addr1 , val ) [EOL] [EOL] await self . service . delete_address ( key ) [EOL] [EOL] with self . assertRaises ( KeyError ) : [EOL] await self . service . get_address ( key ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $logging.Logger$ 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.AddressEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.AddressEntry$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [EOL] from typing import Any , Mapping [EOL] import typing [EOL] import addrservice [EOL] import jsonschema [comment] [EOL] import unittest [EOL] [EOL] from addrservice import ADDRESS_BOOK_SCHEMA [EOL] from data import address_data_suite [EOL] import addrservice . datamodel as datamodel [EOL] [EOL] [EOL] class AddressDataTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . address_data = address_data_suite ( ) [EOL] [EOL] def test_json_schema ( self ) : [EOL] [comment] [EOL] jsonschema . Draft7Validator . check_schema ( ADDRESS_BOOK_SCHEMA ) [EOL] [EOL] def test_address_data_json ( self ) : [EOL] [comment] [EOL] for nickname , addr in self . address_data . items ( ) : [EOL] [comment] [EOL] jsonschema . validate ( addr , ADDRESS_BOOK_SCHEMA ) [EOL] [EOL] [comment] [EOL] addr_obj = datamodel . AddressEntry . from_api_dm ( addr ) [EOL] addr_dict = addr_obj . to_api_dm ( ) [EOL] self . assertEqual ( addr , addr_dict ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.AddressEntry$ 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 $addrservice.datamodel.AddressEntry$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Sequence , Union , Mapping [EOL] import typing [EOL] import addrservice [EOL] import unittest [EOL] [EOL] from addrservice . datamodel import ( AddressType , Address , Phone , Email , AddressEntry ) [EOL] [EOL] [EOL] class DataModelTest ( unittest . TestCase ) : [EOL] def test_data_model ( self ) : [EOL] address = Address ( kind = AddressType . work , building_name = [string] , unit_number = [number] , street_number = [number] , street_name = [string] , locality = [string] , city = [string] , province = [string] , pincode = [number] , country = [string] ) [EOL] self . assertEqual ( address . kind , AddressType . work ) [EOL] self . assertEqual ( address . building_name , [string] ) [EOL] self . assertEqual ( address . unit_number , [number] ) [EOL] self . assertEqual ( address . street_number , [number] ) [EOL] self . assertEqual ( address . street_name , [string] ) [EOL] self . assertEqual ( address . locality , [string] ) [EOL] self . assertEqual ( address . city , [string] ) [EOL] self . assertEqual ( address . province , [string] ) [EOL] self . assertEqual ( address . pincode , [number] ) [EOL] self . assertEqual ( address . country , [string] ) [EOL] [EOL] phone = Phone ( kind = AddressType . home , country_code = [number] , local_number = [number] ) [EOL] self . assertEqual ( phone . kind , AddressType . home ) [EOL] self . assertEqual ( phone . country_code , [number] ) [EOL] self . assertEqual ( phone . area_code , None ) [EOL] self . assertEqual ( phone . local_number , [number] ) [EOL] [EOL] fax = Phone ( kind = AddressType . work , country_code = [number] , area_code = [number] , local_number = [number] ) [EOL] self . assertEqual ( fax . kind , AddressType . work ) [EOL] self . assertEqual ( fax . country_code , [number] ) [EOL] self . assertEqual ( fax . area_code , [number] ) [EOL] self . assertEqual ( fax . local_number , [number] ) [EOL] [EOL] email = Email ( kind = AddressType . work , email = [string] ) [EOL] [EOL] address_entry = AddressEntry ( full_name = [string] , addresses = [ address ] , phone_numbers = [ phone ] , fax_numbers = [ fax ] , emails = [ email ] ) [EOL] self . assertEqual ( address_entry . full_name , [string] ) [EOL] self . assertEqual ( len ( address_entry . addresses ) , [number] ) [EOL] self . assertEqual ( address_entry . addresses [ [number] ] , address ) [EOL] self . assertEqual ( len ( address_entry . phone_numbers ) , [number] ) [EOL] self . assertEqual ( address_entry . phone_numbers [ [number] ] , phone ) [EOL] self . assertEqual ( len ( address_entry . fax_numbers ) , [number] ) [EOL] self . assertEqual ( address_entry . fax_numbers [ [number] ] , fax ) [EOL] self . assertEqual ( len ( address_entry . emails ) , [number] ) [EOL] self . assertEqual ( address_entry . emails [ [number] ] , email ) [EOL] [EOL] address_dict_1 = address_entry . to_api_dm ( ) [EOL] address_dict_2 = AddressEntry . from_api_dm ( address_dict_1 ) . to_api_dm ( ) [EOL] self . assertEqual ( address_dict_1 , address_dict_2 ) [EOL] [EOL] [comment] [EOL] [EOL] address . kind = AddressType . home [EOL] address . building_name = [string] [EOL] address . unit_number = [number] [EOL] address . street_number = [number] [EOL] address . street_name = [string] [EOL] address . locality = [string] [EOL] address . city = [string] [EOL] address . province = [string] [EOL] address . pincode = [string] [EOL] address . country = [string] [EOL] [EOL] phone . kind = AddressType . work [EOL] phone . country_code = [number] [EOL] phone . area_code = [number] [EOL] phone . local_number = [number] [EOL] [EOL] email . kind = AddressType . home [EOL] email . email = [string] [EOL] [EOL] address_entry . full_name = [string] [EOL] address_entry . addresses = [ ] [EOL] address_entry . phone_numbers = [ ] [EOL] address_entry . fax_numbers = [ ] [EOL] address_entry . emails = [ ] [EOL] [EOL] [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] Address ( kind = None , street_name = [string] , pincode = [number] , country = [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] Address ( kind = AddressType . work , street_name = None , pincode = [number] , country = [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] Address ( kind = AddressType . work , street_name = [string] , pincode = None , country = [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] Address ( kind = AddressType . work , street_name = [string] , pincode = [number] , country = None ) [EOL] [EOL] addr = Address ( kind = AddressType . work , street_name = [string] , pincode = [number] , country = [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] addr . kind = None [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] addr . street_name = None [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] addr . pincode = None [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] addr . country = None [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] Phone ( kind = None , country_code = [number] , area_code = [number] , local_number = [number] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] Phone ( kind = AddressType . work , country_code = None , area_code = [number] , local_number = [number] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] Phone ( kind = AddressType . work , country_code = [number] , area_code = [number] , local_number = None ) [EOL] [EOL] p = Phone ( kind = AddressType . work , country_code = [number] , area_code = [number] , local_number = [number] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] p . kind = None [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] p . country_code = None [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] p . local_number = None [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] Email ( kind = None , email = [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] Email ( kind = AddressType . work , email = None ) [EOL] [EOL] e = Email ( kind = AddressType . work , email = [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] e . kind = None [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] e . email = None [comment] [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] AddressEntry ( full_name = None ) [comment] [EOL] [EOL] a = AddressEntry ( full_name = [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] a . full_name = None [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Phone$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Phone$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Phone$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Phone$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Email$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Email$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.Email$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.AddressEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.datamodel.AddressEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import tornado [EOL] import typing [EOL] import logging [EOL] import aiotask_context as context [comment] [EOL] import atexit [EOL] from io import StringIO [EOL] import json [EOL] import logging [EOL] import logging . config [EOL] import yaml [EOL] [EOL] from tornado . ioloop import IOLoop [EOL] import tornado . testing [EOL] [EOL] from addrservice import LOGGER_NAME [EOL] from addrservice . tornado . app import make_addrservice_app [EOL] [EOL] from data import address_data_suite [EOL] [EOL] [EOL] IN_MEMORY_CFG_TXT = [string] [EOL] [EOL] with StringIO ( IN_MEMORY_CFG_TXT ) as f : [EOL] TEST_CONFIG = yaml . load ( f . read ( ) , Loader = yaml . SafeLoader ) [EOL] [EOL] [EOL] class AddressServiceTornadoAppTestSetup ( tornado . testing . AsyncHTTPTestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . headers = { [string] : [string] } [EOL] address_data = address_data_suite ( ) [EOL] keys = list ( address_data . keys ( ) ) [EOL] self . assertGreaterEqual ( len ( keys ) , [number] ) [EOL] self . addr0 = address_data [ keys [ [number] ] ] [EOL] self . addr1 = address_data [ keys [ [number] ] ] [EOL] [EOL] def get_app ( self ) : [EOL] logging . config . dictConfig ( TEST_CONFIG [ [string] ] ) [EOL] logger = logging . getLogger ( LOGGER_NAME ) [EOL] [EOL] addr_service , app = make_addrservice_app ( config = TEST_CONFIG , debug = True , logger = logger ) [EOL] [EOL] addr_service . start ( ) [EOL] atexit . register ( lambda : addr_service . stop ( ) ) [EOL] [EOL] return app [EOL] [EOL] def get_new_ioloop ( self ) : [EOL] instance = IOLoop . current ( ) [EOL] instance . asyncio_loop . set_task_factory ( context . task_factory ) [EOL] return instance [EOL] [EOL] [EOL] class AddressServiceTornadoAppUnitTests ( AddressServiceTornadoAppTestSetup ) : [EOL] def test_default_handler ( self ) : [EOL] r = self . fetch ( [string] , method = [string] , headers = None , ) [EOL] info = json . loads ( r . body . decode ( [string] ) ) [EOL] [EOL] self . assertEqual ( r . code , [number] , info ) [EOL] self . assertEqual ( info [ [string] ] , [number] ) [EOL] self . assertEqual ( info [ [string] ] , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] tornado . testing . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [EOL] from typing import Any , Dict [EOL] import builtins [EOL] import typing [EOL] import addrservice [EOL] from abc import ABCMeta , abstractmethod [EOL] import asynctest [comment] [EOL] from io import StringIO [EOL] import os [EOL] import tempfile [EOL] from typing import Dict [EOL] import unittest [EOL] import yaml [EOL] [EOL] from addrservice . database . addressbook_db import ( AbstractAddressBookDB , InMemoryAddressBookDB , FilesystemAddressBookDB ) [EOL] from addrservice . database . db_engines import create_addressbook_db [EOL] from addrservice . datamodel import AddressEntry [EOL] [EOL] from data import address_data_suite [EOL] [EOL] [EOL] class AbstractAddressBookDBTest ( unittest . TestCase ) : [EOL] def read_config ( self , txt ) : [EOL] with StringIO ( txt ) as f : [EOL] cfg = yaml . load ( f . read ( ) , Loader = yaml . SafeLoader ) [EOL] return cfg [EOL] [EOL] def test_in_memory_db_config ( self ) : [EOL] cfg = self . read_config ( [string] ) [EOL] [EOL] self . assertIn ( [string] , cfg [ [string] ] ) [EOL] db = create_addressbook_db ( cfg [ [string] ] ) [EOL] self . assertEqual ( type ( db ) , InMemoryAddressBookDB ) [EOL] [EOL] def test_file_system_db_config ( self ) : [EOL] cfg = self . read_config ( [string] ) [EOL] [EOL] self . assertIn ( [string] , cfg [ [string] ] ) [EOL] db = create_addressbook_db ( cfg [ [string] ] ) [EOL] self . assertEqual ( type ( db ) , FilesystemAddressBookDB ) [EOL] self . assertEqual ( db . store , [string] ) [EOL] [EOL] [EOL] class AbstractAddressBookDBTestCase ( metaclass = ABCMeta ) : [EOL] def setUp ( self ) : [EOL] self . address_data = { k : AddressEntry . from_api_dm ( v ) for k , v in address_data_suite ( ) . items ( ) } [EOL] self . addr_db = self . make_addr_db ( ) [EOL] [EOL] @ abstractmethod def make_addr_db ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ abstractmethod def addr_count ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ asynctest . fail_on ( active_handles = True ) async def test_crud_lifecycle ( self ) : [EOL] [comment] [EOL] for nickname in self . address_data : [EOL] with self . assertRaises ( KeyError ) : [comment] [EOL] await self . addr_db . read_address ( nickname ) [EOL] [EOL] [comment] [EOL] for nickname , addr in self . address_data . items ( ) : [EOL] await self . addr_db . create_address ( addr , nickname ) [EOL] await self . addr_db . read_address ( nickname ) [EOL] with self . assertRaises ( KeyError ) : [comment] [EOL] await self . addr_db . create_address ( addr , nickname ) [EOL] [EOL] self . assertEqual ( self . addr_count ( ) , [number] ) [comment] [EOL] [EOL] [comment] [EOL] first_nickname = list ( self . address_data . keys ( ) ) [ [number] ] [EOL] first_addr = self . address_data [ first_nickname ] [EOL] [EOL] [comment] [EOL] await self . addr_db . update_address ( first_nickname , first_addr ) [EOL] with self . assertRaises ( KeyError ) : [comment] [EOL] await self . addr_db . update_address ( [string] , first_addr ) [EOL] [EOL] [comment] [EOL] new_nickname = await self . addr_db . create_address ( addr ) [EOL] self . assertIsNotNone ( new_nickname ) [comment] [EOL] self . assertEqual ( self . addr_count ( ) , [number] ) [comment] [EOL] [EOL] [comment] [EOL] addresses = { } [EOL] async for nickname , addr in self . addr_db . read_all_addresses ( ) : [EOL] addresses [ nickname ] = addr [EOL] [EOL] self . assertEqual ( len ( addresses ) , [number] ) [comment] [EOL] [EOL] [comment] [EOL] for nickname in self . address_data : [EOL] await self . addr_db . delete_address ( nickname ) [EOL] with self . assertRaises ( KeyError ) : [comment] [EOL] await self . addr_db . read_address ( nickname ) [EOL] with self . assertRaises ( KeyError ) : [comment] [EOL] await self . addr_db . delete_address ( nickname ) [EOL] [EOL] self . assertEqual ( self . addr_count ( ) , [number] ) [comment] [EOL] [EOL] await self . addr_db . delete_address ( new_nickname ) [EOL] self . assertEqual ( self . addr_count ( ) , [number] ) [comment] [EOL] [EOL] [EOL] class InMemoryAddressBookDBTest ( AbstractAddressBookDBTestCase , asynctest . TestCase ) : [EOL] def make_addr_db ( self ) : [EOL] self . mem_db = InMemoryAddressBookDB ( ) [EOL] return self . mem_db [EOL] [EOL] def addr_count ( self ) : [EOL] return len ( self . mem_db . db ) [EOL] [EOL] [EOL] class FilesystemAddressBookDBTest ( AbstractAddressBookDBTestCase , asynctest . TestCase ) : [EOL] def make_addr_db ( self ) : [EOL] self . tmp_dir = tempfile . TemporaryDirectory ( prefix = [string] ) [EOL] self . store_dir = self . tmp_dir . name [EOL] self . fs_db = FilesystemAddressBookDB ( self . store_dir ) [EOL] return self . fs_db [EOL] [EOL] def addr_count ( self ) : [EOL] return len ( [ name for name in os . listdir ( self . store_dir ) if os . path . isfile ( os . path . join ( self . store_dir , name ) ) ] ) [EOL] return len ( self . addr_db . db ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . tmp_dir . cleanup ( ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] async def test_db_creation ( self ) : [EOL] with tempfile . TemporaryDirectory ( prefix = [string] ) as tempdir : [EOL] store_dir = os . path . join ( tempdir , [string] ) [EOL] FilesystemAddressBookDB ( store_dir ) [EOL] tmpfilename = os . path . join ( tempdir , [string] ) [EOL] with open ( tmpfilename , [string] ) as f : [EOL] f . write ( [string] ) [EOL] with self . assertRaises ( ValueError ) : [EOL] FilesystemAddressBookDB ( tmpfilename ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $addrservice.database.addressbook_db.AbstractAddressBookDB$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $addrservice.database.addressbook_db.AbstractAddressBookDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $addrservice.database.addressbook_db.AbstractAddressBookDB$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $addrservice.database.addressbook_db.AbstractAddressBookDB$ 0 0 0 0 0 0 0 0 0 $addrservice.database.addressbook_db.AbstractAddressBookDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.database.addressbook_db.AbstractAddressBookDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.database.addressbook_db.AbstractAddressBookDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $addrservice.database.addressbook_db.AbstractAddressBookDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0