	0
from typing import Any , Iterator [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import os [EOL] import os . path [EOL] [EOL] import faker [EOL] [EOL] fake = faker . Faker ( ) [EOL] epoch = datetime . datetime . utcfromtimestamp ( [number] ) [EOL] [EOL] AVRO_SCHEMAS_DIR = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) [EOL] [EOL] [EOL] def unix_time_millis ( dt ) : [EOL] return ( dt - epoch ) . total_seconds ( ) * [number] [EOL] [EOL] [EOL] def get_schema_path ( fname ) : [EOL] return os . path . join ( AVRO_SCHEMAS_DIR , fname ) [EOL] [EOL] [EOL] def load_schema_file ( fname ) : [EOL] fname = get_schema_path ( fname ) [EOL] with open ( fname ) as f : [EOL] return f . read ( ) [EOL] [EOL] [EOL] def create_basic_item ( i ) : [EOL] return { [string] : fake . first_name ( ) , [string] : fake . pyint ( max_value = [number] ) } [EOL] [EOL] [EOL] def create_adv_item ( i ) : [EOL] friends = map ( create_basic_item , range ( [number] , [number] ) ) [EOL] family = map ( create_basic_item , range ( [number] , [number] ) ) [EOL] basic = create_basic_item ( i ) [EOL] basic [ [string] ] = dict ( map ( lambda bi : ( bi [ [string] ] , bi ) , family ) ) [EOL] basic [ [string] ] = dict ( map ( lambda bi : ( bi [ [string] ] , bi ) , friends ) ) [EOL] [EOL] return basic [EOL] [EOL] [EOL] def create_logical_item ( ) : [EOL] return { [string] : { [string] : fake . past_datetime ( ) , [string] : fake . pydecimal ( left_digits = [number] , right_digits = [number] ) } } [EOL] [EOL] [EOL] def create_nested_schema ( ) : [EOL] return { [string] : fake . first_name ( ) , [string] : fake . pyint ( min_value = [number] , max_value = [number] , step = [number] ) , [string] : { [string] : fake . pyint ( min_value = [number] , max_value = [number] , step = [number] ) } , } [EOL] [EOL] [EOL] BASIC_SCHEMA = load_schema_file ( os . path . join ( AVRO_SCHEMAS_DIR , [string] ) ) [EOL] ADVANCED_SCHEMA = load_schema_file ( os . path . join ( AVRO_SCHEMAS_DIR , [string] ) ) [EOL] BASIC_ITEMS = map ( create_basic_item , range ( [number] , [number] ) ) [EOL] USER_V1 = load_schema_file ( os . path . join ( AVRO_SCHEMAS_DIR , [string] ) ) [EOL] USER_V2 = load_schema_file ( os . path . join ( AVRO_SCHEMAS_DIR , [string] ) ) [EOL] LOGICAL_TYPES_SCHEMA = load_schema_file ( os . path . join ( AVRO_SCHEMAS_DIR , [string] ) ) [EOL] ADVANCED_ITEMS = map ( create_adv_item , range ( [number] , [number] ) ) [EOL] NESTED_SCHENA = load_schema_file ( os . path . join ( AVRO_SCHEMAS_DIR , [string] ) ) [EOL] ORDER_SCHENA = load_schema_file ( os . path . join ( AVRO_SCHEMAS_DIR , [string] ) ) [EOL] [EOL] [EOL] def cleanup ( files ) : [EOL] for f in files : [EOL] try : [EOL] os . remove ( f ) [EOL] except OSError : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List [EOL] import schema_registry [EOL] import typing [EOL] import pytest [EOL] [EOL] from schema_registry . client import schema [EOL] from tests import data_gen [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_delete_subject ( async_client , user_schema_v3 ) : [EOL] subject = [string] [EOL] versions = [ schema . AvroSchema ( data_gen . USER_V1 ) , schema . AvroSchema ( data_gen . USER_V2 ) ] [EOL] [EOL] for version in versions : [EOL] await async_client . register ( subject , version ) [EOL] [EOL] assert len ( await async_client . delete_subject ( subject ) ) == len ( versions ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_delete_subject_does_not_exist ( async_client ) : [EOL] assert not await async_client . delete_subject ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import schema_registry [EOL] import typing [EOL] import pytest [EOL] [EOL] from schema_registry . client import schema [EOL] from tests import data_gen [EOL] [EOL] [EOL] def assertLatest ( self , meta_tuple , sid , schema , version ) : [EOL] self . assertNotEqual ( sid , - [number] ) [EOL] self . assertNotEqual ( version , - [number] ) [EOL] self . assertEqual ( meta_tuple [ [number] ] , sid ) [EOL] self . assertEqual ( meta_tuple [ [number] ] , schema ) [EOL] self . assertEqual ( meta_tuple [ [number] ] , version ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_register ( async_client ) : [EOL] parsed = schema . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] schema_id = await async_client . register ( [string] , parsed ) [EOL] [EOL] assert schema_id > [number] [EOL] assert len ( async_client . id_to_schema ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_register_json_data ( async_client , deployment_schema ) : [EOL] schema_id = await async_client . register ( [string] , deployment_schema ) [EOL] assert schema_id > [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_register_with_custom_headers ( async_client , country_schema ) : [EOL] headers = { [string] : [string] } [EOL] schema_id = await async_client . register ( [string] , country_schema , headers = headers ) [EOL] assert schema_id > [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_register_with_logical_types ( async_client ) : [EOL] parsed = schema . AvroSchema ( data_gen . LOGICAL_TYPES_SCHEMA ) [EOL] schema_id = await async_client . register ( [string] , parsed ) [EOL] [EOL] assert schema_id > [number] [EOL] assert len ( async_client . id_to_schema ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_multi_subject_register ( async_client ) : [EOL] parsed = schema . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] schema_id = await async_client . register ( [string] , parsed ) [EOL] assert schema_id > [number] [EOL] [EOL] [comment] [EOL] dupe_id = await async_client . register ( [string] , parsed ) [EOL] assert schema_id == dupe_id [EOL] assert len ( async_client . id_to_schema ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_dupe_register ( async_client ) : [EOL] parsed = schema . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] subject = [string] [EOL] schema_id = await async_client . register ( subject , parsed ) [EOL] [EOL] assert schema_id > [number] [EOL] latest = await async_client . get_schema ( subject ) [EOL] [EOL] [comment] [EOL] dupe_id = await async_client . register ( subject , parsed ) [EOL] assert schema_id == dupe_id [EOL] [EOL] dupe_latest = await async_client . get_schema ( subject ) [EOL] assert latest == dupe_latest [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_multi_register ( async_client ) : [EOL] [docstring] [EOL] version_1 = schema . AvroSchema ( data_gen . USER_V1 ) [EOL] version_2 = schema . AvroSchema ( data_gen . USER_V2 ) [EOL] subject = [string] [EOL] [EOL] id1 = await async_client . register ( subject , version_1 ) [EOL] latest_schema_1 = await async_client . get_schema ( subject ) [EOL] await async_client . check_version ( subject , version_1 ) [EOL] [EOL] id2 = await async_client . register ( subject , version_2 ) [EOL] latest_schema_2 = await async_client . get_schema ( subject ) [EOL] await async_client . check_version ( subject , version_2 ) [EOL] [EOL] assert id1 != id2 [EOL] assert latest_schema_1 != latest_schema_2 [EOL] [comment] [EOL] assert latest_schema_1 . version < latest_schema_2 . version [EOL] [EOL] await async_client . register ( subject , version_1 ) [EOL] latest_schema_3 = await async_client . get_schema ( subject ) [EOL] [EOL] assert latest_schema_2 == latest_schema_3 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import schema_registry [EOL] import typing [EOL] import httpx [EOL] import pytest [EOL] [EOL] from schema_registry . client import errors , schema [EOL] from tests import data_gen [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_compatibility ( async_client , user_schema_v3 ) : [EOL] [docstring] [EOL] subject = [string] [EOL] version_2 = schema . AvroSchema ( data_gen . USER_V2 ) [EOL] await async_client . register ( subject , version_2 ) [EOL] [EOL] compatibility = await async_client . test_compatibility ( subject , user_schema_v3 ) [EOL] assert compatibility [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_update_compatibility_for_subject ( async_client ) : [EOL] [docstring] [EOL] assert await async_client . update_compatibility ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_update_global_compatibility ( async_client ) : [EOL] [docstring] [EOL] assert await async_client . update_compatibility ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_update_compatibility_fail ( async_client , response_klass , async_mock ) : [EOL] http_code = [number] [EOL] mock = async_mock ( httpx . AsyncClient , [string] , returned_value = response_klass ( http_code ) ) [EOL] [EOL] with mock : [EOL] with pytest . raises ( errors . ClientError ) as excinfo : [EOL] await async_client . update_compatibility ( [string] , [string] ) [EOL] [EOL] assert excinfo . http_code == http_code [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_compatibility_for_subject ( async_client ) : [EOL] [docstring] [EOL] assert await async_client . get_compatibility ( [string] ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_global_compatibility ( async_client ) : [EOL] [docstring] [EOL] assert await async_client . get_compatibility ( ) is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import schema_registry [EOL] import typing [EOL] import pytest [EOL] [EOL] from schema_registry . client import schema as schema_loader [EOL] from tests import data_gen [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_getters ( async_client ) : [EOL] subject = [string] [EOL] parsed_basic = schema_loader . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] await async_client . register ( subject , parsed_basic ) [EOL] schema = await async_client . get_by_id ( [number] ) [EOL] assert schema is not None [EOL] [EOL] subject = [string] [EOL] latest = await async_client . get_schema ( subject ) [EOL] assert latest is None [EOL] [EOL] schema_id = await async_client . register ( subject , parsed_basic ) [EOL] latest = await async_client . get_schema ( subject ) [EOL] fetched = await async_client . get_by_id ( schema_id ) [EOL] [EOL] assert fetched == parsed_basic [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_subjects ( async_client , user_schema_v3 , country_schema ) : [EOL] subject_user = [string] [EOL] subject_country = [string] [EOL] [EOL] await async_client . register ( [string] , user_schema_v3 ) [EOL] await async_client . register ( [string] , country_schema ) [EOL] [EOL] subjects = await async_client . get_subjects ( ) [EOL] [EOL] assert subject_user in subjects [EOL] assert subject_country in subjects [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import schema_registry [EOL] import typing [EOL] import os [EOL] from base64 import b64encode [EOL] [EOL] import httpx [EOL] import pytest [EOL] [EOL] from schema_registry . client import AsyncSchemaRegistryClient , utils [EOL] [EOL] [EOL] def test_invalid_cert ( ) : [EOL] with pytest . raises ( FileNotFoundError ) : [EOL] AsyncSchemaRegistryClient ( url = [string] , cert_location = [string] ) [EOL] [EOL] [EOL] def test_cert_with_key ( certificates ) : [EOL] client = AsyncSchemaRegistryClient ( url = [string] , cert_location = certificates [ [string] ] , key_location = certificates [ [string] ] , key_password = certificates [ [string] ] , ) [EOL] [EOL] assert client . conf [ utils . SSL_CERTIFICATE_LOCATION ] == certificates [ [string] ] [EOL] assert client . conf [ utils . SSL_KEY_LOCATION ] == certificates [ [string] ] [EOL] assert client . conf [ utils . SSL_KEY_PASSWORD ] == certificates [ [string] ] [EOL] [EOL] [EOL] def test_custom_headers ( ) : [EOL] extra_headers = { [string] : utils . HEADER_AVRO_JSON } [EOL] [EOL] client = AsyncSchemaRegistryClient ( url = [string] , extra_headers = extra_headers ) [EOL] assert extra_headers == client . extra_headers [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_override_headers ( deployment_schema , response_klass , async_mock ) : [EOL] extra_headers = { [string] : utils . HEADER_AVRO_JSON } [EOL] async_client = AsyncSchemaRegistryClient ( url = os . getenv ( [string] ) , extra_headers = extra_headers ) [EOL] [EOL] assert async_client . session . headers . get ( [string] ) == utils . HEADER_AVRO_JSON [EOL] [EOL] subject = [string] [EOL] override_header = { [string] : utils . HEADER_AVRO } [EOL] [EOL] mock = async_mock ( httpx . AsyncClient , [string] , returned_value = response_klass ( [number] , content = { [string] : [number] } ) ) [EOL] [EOL] with mock : [EOL] await async_client . register ( subject , deployment_schema , headers = override_header ) [EOL] [EOL] prepare_headers = async_client . prepare_headers ( body = [string] ) [EOL] prepare_headers [ [string] ] = utils . HEADER_AVRO [EOL] [EOL] mock . assert_called_with ( headers = prepare_headers ) [EOL] [EOL] [EOL] def test_cert_path ( ) : [EOL] client = AsyncSchemaRegistryClient ( url = [string] , ca_location = True ) [EOL] [EOL] assert client . conf [ utils . SSL_CA_LOCATION ] [EOL] [EOL] [EOL] def test_init_with_dict ( certificates ) : [EOL] client = AsyncSchemaRegistryClient ( { [string] : [string] , [string] : certificates [ [string] ] , [string] : certificates [ [string] ] , [string] : [string] , } ) [EOL] assert [string] == client . url_manager . url [EOL] [EOL] [EOL] def test_empty_url ( ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] AsyncSchemaRegistryClient ( { [string] : [string] } ) [EOL] [EOL] [EOL] def test_invalid_type_url ( ) : [EOL] with pytest . raises ( AttributeError ) : [EOL] AsyncSchemaRegistryClient ( url = [number] ) [EOL] [EOL] [EOL] def test_invalid_type_url_dict ( ) : [EOL] with pytest . raises ( AttributeError ) : [EOL] AsyncSchemaRegistryClient ( { [string] : [number] } ) [EOL] [EOL] [EOL] def test_basic_auth_url ( ) : [EOL] username = [string] [EOL] password = [string] [EOL] client = AsyncSchemaRegistryClient ( { [string] : f" [string] { username } [string] { password } [string] " } ) [EOL] userpass = [string] . join ( ( httpx . _utils . to_bytes ( username ) , httpx . _utils . to_bytes ( password ) ) ) [EOL] token = b64encode ( userpass ) . decode ( ) [EOL] [EOL] assert client . session . auth . _auth_header == f" [string] { token }" [EOL] [EOL] [EOL] def test_basic_auth_user_info ( ) : [EOL] username = [string] [EOL] password = [string] [EOL] client = AsyncSchemaRegistryClient ( { [string] : [string] , [string] : [string] , [string] : f"{ username } [string] { password }" , } ) [EOL] [EOL] userpass = [string] . join ( ( httpx . _utils . to_bytes ( username ) , httpx . _utils . to_bytes ( password ) ) ) [EOL] token = b64encode ( userpass ) . decode ( ) [EOL] [EOL] assert client . session . auth . _auth_header == f" [string] { token }" [EOL] [EOL] [EOL] def test_basic_auth_sasl_inherit ( ) : [EOL] username = [string] [EOL] password = [string] [EOL] client = AsyncSchemaRegistryClient ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : username , [string] : password , } ) [EOL] [EOL] userpass = [string] . join ( ( httpx . _utils . to_bytes ( username ) , httpx . _utils . to_bytes ( password ) ) ) [EOL] token = b64encode ( userpass ) . decode ( ) [EOL] [EOL] assert client . session . auth . _auth_header == f" [string] { token }" [EOL] [EOL] [EOL] def test_basic_auth_invalid ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] AsyncSchemaRegistryClient ( { [string] : [string] , [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_version_does_not_exists ( async_client , country_schema ) : [EOL] assert await async_client . check_version ( [string] , country_schema ) is None [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_versions ( async_client , country_schema ) : [EOL] subject = [string] [EOL] await async_client . register ( subject , country_schema ) [EOL] versions = await async_client . get_versions ( subject ) [EOL] [EOL] assert versions [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_versions_does_not_exist ( async_client ) : [EOL] assert not await async_client . get_versions ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_check_version ( async_client , country_schema ) : [EOL] subject = [string] [EOL] schema_id = await async_client . register ( subject , country_schema ) [EOL] result = await async_client . check_version ( subject , country_schema ) [EOL] [EOL] assert subject == result . subject [EOL] assert schema_id == result . schema_id [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_delete_version ( async_client , country_schema ) : [EOL] subject = [string] [EOL] await async_client . register ( subject , country_schema ) [EOL] versions = await async_client . get_versions ( subject ) [EOL] latest_version = versions [ - [number] ] [EOL] [EOL] assert latest_version == await async_client . delete_version ( subject , latest_version ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_delete_version_does_not_exist ( async_client , country_schema ) : [EOL] subject = [string] [EOL] await async_client . register ( subject , country_schema ) [EOL] [EOL] assert not await async_client . delete_version ( [string] ) [EOL] assert not await async_client . delete_version ( subject , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import schema_registry [EOL] import typing [EOL] import httpx [EOL] import pytest [EOL] [EOL] from schema_registry . client import errors , schema [EOL] from tests import data_gen [EOL] [EOL] [EOL] def test_compatibility ( client , user_schema_v3 ) : [EOL] [docstring] [EOL] subject = [string] [EOL] version_2 = schema . AvroSchema ( data_gen . USER_V2 ) [EOL] client . register ( subject , version_2 ) [EOL] [EOL] compatibility = client . test_compatibility ( subject , user_schema_v3 ) [EOL] assert compatibility [EOL] [EOL] [EOL] def test_update_compatibility_for_subject ( client ) : [EOL] [docstring] [EOL] assert client . update_compatibility ( [string] , [string] ) [EOL] [EOL] [EOL] def test_update_global_compatibility ( client ) : [EOL] [docstring] [EOL] assert client . update_compatibility ( [string] ) [EOL] [EOL] [EOL] def test_update_compatibility_fail ( client , response_klass , mocker ) : [EOL] http_code = [number] [EOL] mocker . patch . object ( httpx . Client , [string] , return_value = response_klass ( http_code ) ) [EOL] [EOL] with pytest . raises ( errors . ClientError ) as excinfo : [EOL] client . update_compatibility ( [string] , [string] ) [EOL] [EOL] assert excinfo . http_code == http_code [EOL] [EOL] [EOL] def test_get_compatibility_for_subject ( client ) : [EOL] [docstring] [EOL] assert client . get_compatibility ( [string] ) == [string] [EOL] [EOL] [EOL] def test_get_global_compatibility ( client ) : [EOL] [docstring] [EOL] assert client . get_compatibility ( ) is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import schema_registry [EOL] import typing [EOL] from schema_registry . client import schema [EOL] from tests import data_gen [EOL] [EOL] [EOL] def test_delete_subject ( client , user_schema_v3 ) : [EOL] subject = [string] [EOL] versions = [ schema . AvroSchema ( data_gen . USER_V1 ) , schema . AvroSchema ( data_gen . USER_V2 ) ] [EOL] [EOL] for version in versions : [EOL] client . register ( subject , version ) [EOL] [EOL] assert len ( client . delete_subject ( subject ) ) == len ( versions ) [EOL] [EOL] [EOL] def test_delete_subject_does_not_exist ( client ) : [EOL] assert not client . delete_subject ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import schema_registry [EOL] import typing [EOL] import pickle [EOL] from base64 import b64encode [EOL] [EOL] import httpx [EOL] import pytest [EOL] from httpx . _client import UNSET [EOL] [EOL] from schema_registry . client import SchemaRegistryClient , schema , utils [EOL] from tests import data_gen [EOL] [EOL] [EOL] def test_invalid_cert ( ) : [EOL] with pytest . raises ( FileNotFoundError ) : [EOL] SchemaRegistryClient ( url = [string] , cert_location = [string] ) [EOL] [EOL] [EOL] def test_cert_with_key ( certificates ) : [EOL] client = SchemaRegistryClient ( url = [string] , cert_location = certificates [ [string] ] , key_location = certificates [ [string] ] , key_password = certificates [ [string] ] , ) [EOL] [EOL] assert client . conf [ utils . SSL_CERTIFICATE_LOCATION ] == certificates [ [string] ] [EOL] assert client . conf [ utils . SSL_KEY_LOCATION ] == certificates [ [string] ] [EOL] assert client . conf [ utils . SSL_KEY_PASSWORD ] == certificates [ [string] ] [EOL] [EOL] [EOL] def test_pickelable ( client ) : [EOL] unpickled_client = pickle . loads ( pickle . dumps ( client ) ) [EOL] [EOL] assert client == unpickled_client [EOL] [EOL] [comment] [EOL] subject = [string] [EOL] parsed = schema . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] unpickled_client . get_subjects ( ) [EOL] schema_id = unpickled_client . register ( subject , parsed ) [EOL] [EOL] assert schema_id > [number] [EOL] assert unpickled_client . delete_subject ( subject ) [EOL] [EOL] [EOL] def test_custom_headers ( ) : [EOL] extra_headers = { [string] : utils . HEADER_AVRO_JSON } [EOL] [EOL] client = SchemaRegistryClient ( url = [string] , extra_headers = extra_headers ) [EOL] assert extra_headers == client . extra_headers [EOL] [EOL] [EOL] def test_custom_httpx_config ( ) : [EOL] [docstring] [EOL] timeout = httpx . Timeout ( [number] , connect = [number] ) [EOL] pool_limits = httpx . Limits ( max_keepalive = [number] , max_connections = [number] ) [EOL] [EOL] client = SchemaRegistryClient ( url = [string] , timeout = timeout , pool_limits = pool_limits , ) [EOL] [EOL] assert client . timeout == timeout [EOL] assert client . pool_limits == pool_limits [EOL] [EOL] [EOL] def test_override_headers ( client , deployment_schema , mocker , response_klass ) : [EOL] extra_headers = { [string] : utils . HEADER_AVRO_JSON } [EOL] client = SchemaRegistryClient ( [string] , extra_headers = extra_headers ) [EOL] [EOL] assert client . session . headers . get ( [string] ) == utils . HEADER_AVRO_JSON [EOL] [EOL] subject = [string] [EOL] override_header = { [string] : utils . HEADER_AVRO } [EOL] [EOL] request_patch = mocker . patch . object ( httpx . Client , [string] , return_value = response_klass ( [number] , content = { [string] : [number] } ) ) [EOL] client . register ( subject , deployment_schema , headers = override_header ) [EOL] [EOL] prepare_headers = client . prepare_headers ( body = [string] ) [EOL] prepare_headers [ [string] ] = utils . HEADER_AVRO [EOL] [EOL] request_patch . assert_called_once_with ( [string] , mocker . ANY , headers = prepare_headers , json = mocker . ANY , timeout = UNSET ) [EOL] [EOL] [EOL] def test_cert_path ( ) : [EOL] client = SchemaRegistryClient ( url = [string] , ca_location = True ) [EOL] [EOL] assert client . conf [ utils . SSL_CA_LOCATION ] [EOL] [EOL] [EOL] def test_init_with_dict ( certificates ) : [EOL] client = SchemaRegistryClient ( { [string] : [string] , [string] : certificates [ [string] ] , [string] : certificates [ [string] ] , [string] : certificates [ [string] ] , } ) [EOL] assert [string] == client . url_manager . url [EOL] [EOL] [EOL] def test_empty_url ( ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] SchemaRegistryClient ( { [string] : [string] } ) [EOL] [EOL] [EOL] def test_invalid_type_url ( ) : [EOL] with pytest . raises ( AttributeError ) : [EOL] SchemaRegistryClient ( url = [number] ) [EOL] [EOL] [EOL] def test_invalid_type_url_dict ( ) : [EOL] with pytest . raises ( AttributeError ) : [EOL] SchemaRegistryClient ( { [string] : [number] } ) [EOL] [EOL] [EOL] def test_invalid_url ( ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] SchemaRegistryClient ( { [string] : [string] } ) [EOL] [EOL] [EOL] def test_basic_auth_url ( ) : [EOL] username = [string] [EOL] password = [string] [EOL] client = SchemaRegistryClient ( { [string] : f" [string] { username } [string] { password } [string] " } ) [EOL] userpass = [string] . join ( ( httpx . _utils . to_bytes ( username ) , httpx . _utils . to_bytes ( password ) ) ) [EOL] token = b64encode ( userpass ) . decode ( ) [EOL] [EOL] assert client . session . auth . _auth_header == f" [string] { token }" [EOL] [EOL] [EOL] def test_basic_auth_user_info ( ) : [EOL] username = [string] [EOL] password = [string] [EOL] client = SchemaRegistryClient ( { [string] : [string] , [string] : [string] , [string] : f"{ username } [string] { password }" , } ) [EOL] [EOL] userpass = [string] . join ( ( httpx . _utils . to_bytes ( username ) , httpx . _utils . to_bytes ( password ) ) ) [EOL] token = b64encode ( userpass ) . decode ( ) [EOL] [EOL] assert client . session . auth . _auth_header == f" [string] { token }" [EOL] [EOL] [EOL] def test_basic_auth_sasl_inherit ( ) : [EOL] username = [string] [EOL] password = [string] [EOL] client = SchemaRegistryClient ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : username , [string] : password , } ) [EOL] [EOL] userpass = [string] . join ( ( httpx . _utils . to_bytes ( username ) , httpx . _utils . to_bytes ( password ) ) ) [EOL] token = b64encode ( userpass ) . decode ( ) [EOL] [EOL] assert client . session . auth . _auth_header == f" [string] { token }" [EOL] [EOL] [EOL] def test_basic_auth_invalid ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] SchemaRegistryClient ( { [string] : [string] , [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import schema_registry [EOL] import typing [EOL] from schema_registry . client import schema as schema_loader [EOL] from tests import data_gen [EOL] [EOL] [EOL] def test_getters ( client ) : [EOL] subject = [string] [EOL] parsed_basic = schema_loader . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] client . register ( subject , parsed_basic ) [EOL] schema = client . get_by_id ( [number] ) [EOL] assert schema is not None [EOL] [EOL] subject = [string] [EOL] latest = client . get_schema ( subject ) [EOL] assert latest is None [EOL] [EOL] schema_id = client . register ( subject , parsed_basic ) [EOL] latest = client . get_schema ( subject ) [EOL] fetched = client . get_by_id ( schema_id ) [EOL] [EOL] assert fetched == parsed_basic [EOL] [EOL] [EOL] def test_get_subjects ( client , user_schema_v3 , country_schema ) : [EOL] subject_user = [string] [EOL] subject_country = [string] [EOL] [EOL] client . register ( [string] , user_schema_v3 ) [EOL] client . register ( [string] , country_schema ) [EOL] [EOL] subjects = client . get_subjects ( ) [EOL] [EOL] assert subject_user in subjects [EOL] assert subject_country in subjects [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def test_version_does_not_exists ( client , country_schema ) : [EOL] assert client . check_version ( [string] , country_schema ) is None [EOL] [EOL] [EOL] def test_get_versions ( client , country_schema ) : [EOL] subject = [string] [EOL] client . register ( subject , country_schema ) [EOL] versions = client . get_versions ( subject ) [EOL] [EOL] assert versions [EOL] [EOL] [EOL] def test_get_versions_does_not_exist ( client ) : [EOL] assert not client . get_versions ( [string] ) [EOL] [EOL] [EOL] def test_check_version ( client , country_schema ) : [EOL] subject = [string] [EOL] schema_id = client . register ( subject , country_schema ) [EOL] result = client . check_version ( subject , country_schema ) [EOL] [EOL] assert subject == result . subject [EOL] assert schema_id == result . schema_id [EOL] [EOL] [EOL] def test_delete_version ( client , country_schema ) : [EOL] subject = [string] [EOL] client . register ( subject , country_schema ) [EOL] versions = client . get_versions ( subject ) [EOL] latest_version = versions [ - [number] ] [EOL] [EOL] assert latest_version == client . delete_version ( subject , latest_version ) [EOL] [EOL] [EOL] def test_delete_version_does_not_exist ( client , country_schema ) : [EOL] subject = [string] [EOL] client . register ( subject , country_schema ) [EOL] [EOL] assert not client . delete_version ( [string] ) [EOL] assert not client . delete_version ( subject , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , List , Dict [EOL] import schema_registry [EOL] import typing [EOL] import fastavro [EOL] import pytest [EOL] [EOL] from schema_registry . client import schema [EOL] from tests import data_gen [EOL] [EOL] [EOL] def test_schema_from_string ( ) : [EOL] parsed = schema . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] [EOL] assert isinstance ( parsed , schema . AvroSchema ) [EOL] [EOL] [EOL] def test_schema_from_file ( ) : [EOL] parsed = schema . load ( data_gen . get_schema_path ( [string] ) ) [EOL] assert isinstance ( parsed , schema . AvroSchema ) [EOL] [EOL] [EOL] def test_schema_load_parse_error ( ) : [EOL] with pytest . raises ( fastavro . schema . UnknownType ) : [EOL] schema . load ( data_gen . get_schema_path ( [string] ) ) [EOL] [EOL] [EOL] def test_expended_schema ( client ) : [EOL] advance_schema = schema . AvroSchema ( data_gen . ADVANCED_SCHEMA ) [EOL] expanded = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] } , { [string] : [string] , [string] : [string] , [string] : [ [string] ] } , { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] } , { [string] : [string] , [string] : [string] , [string] : [ [string] ] } , ] , } , } , } , { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] } , { [string] : [string] , [string] : [string] , [string] : [ [string] ] } , ] , } , } , } , ] , } [EOL] [EOL] assert advance_schema . expanded_schema == expanded [EOL] [EOL] [EOL] def test_flat_schema ( client ) : [EOL] advance_schema = schema . AvroSchema ( data_gen . ADVANCED_SCHEMA ) [EOL] subject = [string] [EOL] client . register ( subject , advance_schema ) [EOL] [EOL] schema_version = client . get_schema ( subject ) [EOL] parsed_schema = schema_version . schema [EOL] parsed_schema . schema . pop ( [string] ) [EOL] parsed_schema . schema . pop ( [string] ) [EOL] [EOL] assert schema_version . schema . flat_schema == parsed_schema . schema [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import schema_registry [EOL] import typing [EOL] from schema_registry . client import schema [EOL] from tests import data_gen [EOL] [EOL] [EOL] def assertLatest ( self , meta_tuple , sid , schema , version ) : [EOL] self . assertNotEqual ( sid , - [number] ) [EOL] self . assertNotEqual ( version , - [number] ) [EOL] self . assertEqual ( meta_tuple [ [number] ] , sid ) [EOL] self . assertEqual ( meta_tuple [ [number] ] , schema ) [EOL] self . assertEqual ( meta_tuple [ [number] ] , version ) [EOL] [EOL] [EOL] def test_register ( client ) : [EOL] parsed = schema . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] schema_id = client . register ( [string] , parsed ) [EOL] [EOL] assert schema_id > [number] [EOL] assert len ( client . id_to_schema ) == [number] [EOL] [EOL] [EOL] def test_register_json_data ( client , deployment_schema ) : [EOL] schema_id = client . register ( [string] , deployment_schema ) [EOL] assert schema_id > [number] [EOL] [EOL] [EOL] def test_register_with_custom_headers ( client , country_schema ) : [EOL] headers = { [string] : [string] } [EOL] schema_id = client . register ( [string] , country_schema , headers = headers ) [EOL] assert schema_id > [number] [EOL] [EOL] [EOL] def test_register_with_logical_types ( client ) : [EOL] parsed = schema . AvroSchema ( data_gen . LOGICAL_TYPES_SCHEMA ) [EOL] schema_id = client . register ( [string] , parsed ) [EOL] [EOL] assert schema_id > [number] [EOL] assert len ( client . id_to_schema ) == [number] [EOL] [EOL] [EOL] def test_multi_subject_register ( client ) : [EOL] parsed = schema . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] schema_id = client . register ( [string] , parsed ) [EOL] assert schema_id > [number] [EOL] [EOL] [comment] [EOL] dupe_id = client . register ( [string] , parsed ) [EOL] assert schema_id == dupe_id [EOL] assert len ( client . id_to_schema ) == [number] [EOL] [EOL] [EOL] def test_dupe_register ( client ) : [EOL] parsed = schema . AvroSchema ( data_gen . BASIC_SCHEMA ) [EOL] subject = [string] [EOL] schema_id = client . register ( subject , parsed ) [EOL] [EOL] assert schema_id > [number] [EOL] latest = client . get_schema ( subject ) [EOL] [EOL] [comment] [EOL] dupe_id = client . register ( subject , parsed ) [EOL] assert schema_id == dupe_id [EOL] [EOL] dupe_latest = client . get_schema ( subject ) [EOL] assert latest == dupe_latest [EOL] [EOL] [EOL] def test_multi_register ( client ) : [EOL] [docstring] [EOL] version_1 = schema . AvroSchema ( data_gen . USER_V1 ) [EOL] version_2 = schema . AvroSchema ( data_gen . USER_V2 ) [EOL] subject = [string] [EOL] [EOL] id1 = client . register ( subject , version_1 ) [EOL] latest_schema_1 = client . get_schema ( subject ) [EOL] client . check_version ( subject , version_1 ) [EOL] [EOL] id2 = client . register ( subject , version_2 ) [EOL] latest_schema_2 = client . get_schema ( subject ) [EOL] client . check_version ( subject , version_2 ) [EOL] [EOL] assert id1 != id2 [EOL] assert latest_schema_1 != latest_schema_2 [EOL] [comment] [EOL] assert latest_schema_1 . version < latest_schema_2 . version [EOL] [EOL] client . register ( subject , version_1 ) [EOL] latest_schema_3 = client . get_schema ( subject ) [EOL] [EOL] assert latest_schema_2 == latest_schema_3 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import urllib [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] import urllib [EOL] from collections import defaultdict [EOL] [EOL] [EOL] class UrlManager : [EOL] def __init__ ( self , base_url , paths ) : [EOL] parsed_url = urllib . parse . urlparse ( base_url ) [EOL] [EOL] assert parsed_url . scheme , f" [string] { base_url }" [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not base_url . endswith ( [string] ) : [EOL] base_url += [string] [EOL] [EOL] self . base_url = base_url [EOL] [EOL] self . paths = { path . name : path for path in map ( lambda path : Path ( path ) , paths ) } [EOL] [EOL] @ property def url ( self ) : [EOL] return self . base_url [EOL] [EOL] def url_for ( self , func , ** kwargs ) : [EOL] [docstring] [EOL] path = self . paths [ func ] [EOL] url = path . generate_url ( ** kwargs ) [EOL] [EOL] return urllib . parse . urljoin ( self . base_url , url ) , path . method [EOL] [EOL] [EOL] class Path : [EOL] def __init__ ( self , path ) : [EOL] self . func = path [ [number] ] [EOL] self . url = path [ [number] ] [EOL] self . method = path [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] return self . func [EOL] [EOL] def generate_url ( self , ** kwargs ) : [EOL] parameters = { key : value for key , value in kwargs . items ( ) if value } [EOL] [EOL] return self . url . format_map ( defaultdict ( str , ** parameters ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0
from typing import List [EOL] import typing [EOL] from schema_registry . client import errors , schema [comment] [EOL] from schema_registry . client . client import AsyncSchemaRegistryClient , SchemaRegistryClient [comment] [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
import builtins [EOL] from typing import Tuple , Type , Literal [EOL] import schema_registry [EOL] import typing [EOL] import typing_extensions [EOL] from collections import namedtuple [EOL] [EOL] SchemaVersion = namedtuple ( [string] , [string] ) [EOL] [EOL] BACKWARD = [string] [EOL] BACKWARD_TRANSITIVE = [string] [EOL] FORWARD = [string] [EOL] FORWARD_TRANSITIVE = [string] [EOL] FULL = [string] [EOL] FULL_TRANSITIVE = [string] [EOL] NONE = [string] [EOL] [EOL] VALID_LEVELS = ( BACKWARD , BACKWARD_TRANSITIVE , FORWARD , FORWARD_TRANSITIVE , FULL , FULL_TRANSITIVE , NONE ) [EOL] VALID_METHODS = ( [string] , [string] , [string] , [string] ) [EOL] VALID_AUTH_PROVIDERS = ( [string] , [string] , [string] ) [EOL] [EOL] HEADER_AVRO_JSON = [string] [EOL] HEADER_AVRO = [string] [EOL] HEADER_APPLICATION_JSON = [string] [EOL] HEADERS = [string] [EOL] ACCEPT_HEADERS = [string] [EOL] [EOL] URL = [string] [EOL] SSL_CA_LOCATION = [string] [EOL] SSL_CERTIFICATE_LOCATION = [string] [EOL] SSL_KEY_LOCATION = [string] [EOL] SSL_KEY_PASSWORD = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Optional [EOL] import builtins [EOL] import typing [EOL] import json [EOL] import typing [EOL] [EOL] import aiofiles [EOL] import fastavro [EOL] [EOL] [EOL] class AvroSchema : [EOL] def __init__ ( self , schema ) : [EOL] if isinstance ( schema , str ) : [EOL] schema = json . loads ( schema ) [EOL] self . raw_schema = schema [EOL] self . schema = fastavro . parse_schema ( schema , _force = True ) [EOL] self . generate_hash ( ) [EOL] [EOL] self . _flat_schema = None [EOL] self . _expanded_schema = None [EOL] [EOL] def generate_hash ( self ) : [EOL] self . _hash = hash ( json . dumps ( self . schema ) ) [EOL] [EOL] @ property def name ( self ) : [EOL] return self . schema . get ( [string] ) [EOL] [EOL] @ property def expanded_schema ( self ) : [EOL] [docstring] [EOL] if self . _expanded_schema is None : [EOL] self . _expanded_schema = fastavro . schema . expand_schema ( self . raw_schema ) [EOL] return self . _expanded_schema [EOL] [EOL] @ property def flat_schema ( self ) : [EOL] [docstring] [EOL] if self . _flat_schema is None : [EOL] self . _flat_schema = fastavro . parse_schema ( self . raw_schema , _write_hint = False , _force = True ) [EOL] [EOL] return self . _flat_schema [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . _hash [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . schema ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , AvroSchema ) : [EOL] return NotImplemented [EOL] return self . __hash__ ( ) == other . __hash__ ( ) [EOL] [EOL] [EOL] def load ( fp ) : [EOL] [docstring] [EOL] with open ( fp , mode = [string] ) as f : [EOL] content = f . read ( ) [EOL] return AvroSchema ( content ) [EOL] [EOL] [EOL] async def async_load ( fp ) : [EOL] [docstring] [EOL] async with aiofiles . open ( fp , mode = [string] ) as f : [EOL] content = await f . read ( ) [EOL] return AvroSchema ( content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $AvroSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AvroSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0