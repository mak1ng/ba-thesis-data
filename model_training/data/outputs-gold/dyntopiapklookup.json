[comment] [EOL] [EOL] from typing import Iterator , Optional , Match [EOL] import typing [EOL] import builtins [EOL] import re [EOL] import sys [EOL] from typing import Iterator [EOL] [EOL] from setuptools import setup [EOL] [EOL] import pklookup [EOL] [EOL] [EOL] def get_requirements ( filename ) : [EOL] with open ( filename , [string] ) as f : [EOL] for line in f . readlines ( ) : [EOL] line = line . strip ( ) [EOL] if line and not line . startswith ( [string] ) : [EOL] m = re . match ( [string] , line ) [EOL] if not m : [EOL] sys . exit ( [string] ) [EOL] yield [string] . format ( * m . groups ( ) ) [EOL] [EOL] [EOL] setup ( name = [string] , version = pklookup . __version__ , author = [string] , author_email = [string] , license = [string] , python_requires = [string] , install_requires = list ( get_requirements ( [string] ) ) , packages = [ [string] ] , entry_points = { [string] : [ [string] ] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] import builtins [EOL] from typing import Any , Optional [EOL] [EOL] [EOL] class ContextManagerMock : [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , * args , ** kwargs ) : [EOL] return [EOL] [EOL] [EOL] class URLOpenMock ( ContextManagerMock ) : [EOL] def __init__ ( self , data = [string] , exception = None , ) : [EOL] self . _data = data [EOL] self . _exception = exception [EOL] [EOL] def read ( self , amt = None ) : [EOL] if self . _exception : [EOL] raise self . _exception [EOL] return self . _data [ : amt or len ( self . _data ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ContextManagerMock"$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $typing.Optional[builtins.Exception]$ 0 $typing.Optional[builtins.Exception]$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0
	0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import List , Literal , Dict , Any , Union [EOL] import typing_extensions [EOL] import configparser [EOL] import os [EOL] import typing [EOL] import click [EOL] import builtins [EOL] import configparser [EOL] import getpass [EOL] import os [EOL] import shutil [EOL] import sys [EOL] from typing import Dict , List [EOL] [EOL] import click [EOL] import texttable [EOL] [EOL] from . www import WWW , WWWError [EOL] [EOL] ROLES = [ [string] , [string] ] [EOL] [EOL] [EOL] @ click . group ( ) @ click . option ( [string] , [string] , default = [string] ) @ click . pass_context def cli ( ctx , config_file ) : [EOL] config = configparser . ConfigParser ( ) [EOL] config . read ( os . path . expanduser ( config_file ) ) [EOL] [EOL] url = config . get ( [string] , [string] , fallback = [string] ) . rstrip ( [string] ) [EOL] if not url : [EOL] sys . stderr . write ( [string] . format ( config_file ) ) [EOL] sys . exit ( [number] ) [EOL] url = [string] . format ( url ) [EOL] [EOL] admin_token = config . get ( [string] , [string] , fallback = [string] ) [EOL] if not admin_token : [EOL] admin_token = getpass . getpass ( [string] ) [EOL] [EOL] cafile = config . get ( [string] , [string] , fallback = [string] ) or None [EOL] [EOL] known_hosts = os . path . expanduser ( config . get ( [string] , [string] , fallback = [string] ) ) [EOL] [EOL] ctx . obj = { [string] : known_hosts , [string] : WWW ( url , token = admin_token , cafile = cafile ) } [EOL] [EOL] [EOL] @ cli . group ( ) def token ( ) : [EOL] pass [EOL] [EOL] [EOL] @ token . command ( [string] ) @ click . option ( [string] , [string] ) @ click . option ( [string] , [string] , required = True , type = click . Choice ( ROLES ) ) @ click . pass_obj def token_add ( options , role , description ) : [EOL] try : [EOL] res = options [ [string] ] . post ( [string] , role = role , description = description ) [EOL] print ( [string] . format ( role , ** res ) ) [EOL] except WWWError as e : [EOL] sys . stderr . write ( [string] . format ( e ) ) [EOL] sys . exit ( [number] ) [EOL] except ( KeyError , TypeError ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] @ token . command ( [string] ) @ click . option ( [string] , [string] , type = int , required = True ) @ click . pass_obj def token_delete ( options , token_id ) : [EOL] try : [EOL] res = options [ [string] ] . delete ( [string] , id = token_id ) [EOL] print ( [string] . format ( ** res ) ) [EOL] except WWWError as e : [EOL] sys . stderr . write ( [string] . format ( e ) ) [EOL] sys . exit ( [number] ) [EOL] except ( KeyError , TypeError ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] @ token . command ( [string] ) @ click . pass_obj def token_list ( options ) : [EOL] try : [EOL] res = options [ [string] ] . get ( [string] ) [EOL] tabulate ( [ [string] , [string] , [string] , [string] ] , res [ [string] ] ) [EOL] except WWWError as e : [EOL] sys . stderr . write ( [string] . format ( e ) ) [EOL] sys . exit ( [number] ) [EOL] except ( KeyError , TypeError ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] @ cli . group ( ) def server ( ) : [EOL] pass [EOL] [EOL] [EOL] @ server . command ( [string] ) @ click . option ( [string] , required = True ) @ click . pass_obj def server_add ( options , public_key ) : [EOL] if public_key . startswith ( [string] ) : [EOL] try : [EOL] with open ( public_key [ [number] : ] , [string] ) as f : [EOL] public_key = f . readline ( ) . strip ( ) [EOL] except IOError as e : [EOL] sys . stderr . write ( [string] . format ( e ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] try : [EOL] res = options [ [string] ] . post ( [string] , public_key = public_key ) [EOL] print ( [string] . format ( ** res ) ) [EOL] except WWWError as e : [EOL] sys . stderr . write ( [string] . format ( e ) ) [EOL] sys . exit ( [number] ) [EOL] except ( KeyError , TypeError ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] @ server . command ( [string] ) @ click . option ( [string] , [string] , type = int , required = True ) @ click . pass_obj def server_delete ( options , server_id ) : [EOL] try : [EOL] res = options [ [string] ] . delete ( [string] , id = server_id ) [EOL] print ( [string] . format ( ** res ) ) [EOL] except WWWError as e : [EOL] sys . stderr . write ( [string] . format ( e ) ) [EOL] sys . exit ( [number] ) [EOL] except ( KeyError , TypeError ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] @ server . command ( [string] ) @ click . pass_obj def server_list ( options ) : [EOL] try : [EOL] res = options [ [string] ] . get ( [string] ) [EOL] headers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] tabulate ( headers , res [ [string] ] ) [EOL] except WWWError as e : [EOL] sys . stderr . write ( [string] . format ( e ) ) [EOL] sys . exit ( [number] ) [EOL] except ( KeyError , TypeError ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] @ server . command ( [string] ) @ click . option ( [string] , [string] , type = int , required = True ) @ click . pass_obj def server_save_key ( options , server_id ) : [EOL] try : [EOL] res = options [ [string] ] . get ( [string] , id = server_id ) [EOL] entry = [string] . format ( ** res [ [string] ] [ [number] ] ) [EOL] except WWWError as e : [EOL] sys . stderr . write ( [string] . format ( e ) ) [EOL] sys . exit ( [number] ) [EOL] except IndexError : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] except ( KeyError , TypeError ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] print ( [string] . format ( entry , ** options ) ) [EOL] with open ( options [ [string] ] , [string] ) as f : [EOL] f . write ( [string] . format ( entry ) ) [EOL] [EOL] [EOL] def tabulate ( header , rows ) : [EOL] [docstring] [EOL] size = shutil . get_terminal_size ( ) [EOL] table = texttable . Texttable ( max_width = size . columns ) [EOL] table . header ( header ) [EOL] for row in rows : [EOL] table . add_row ( [ row [ key ] for key in header ] ) [EOL] print ( table . draw ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . cli import cli [EOL] [EOL] if __name__ == [string] : [EOL] cli ( None , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , BinaryIO , Union , Optional [EOL] import typing [EOL] import http [EOL] import urllib [EOL] import builtins [EOL] import http . client [EOL] import json [EOL] import ssl [EOL] import urllib . error [EOL] import urllib . request [EOL] from typing import Any , BinaryIO , Dict , Optional , Union [EOL] [EOL] [EOL] class WWWError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class WWW : [EOL] def __init__ ( self , url , token = None , cafile = None , ) : [EOL] self . _url = url [EOL] self . _token = token [EOL] self . _cafile = cafile [EOL] [EOL] def get ( self , path = [string] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _send ( path , [string] , ** kwargs ) [EOL] [EOL] def delete ( self , path = [string] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _send ( path , [string] , ** kwargs ) [EOL] [EOL] def post ( self , path = [string] , ** kwargs ) : [EOL] [docstring] [EOL] return self . _send ( path , [string] , ** kwargs ) [EOL] [EOL] def _send ( self , path , method , ** kwargs ) : [EOL] [docstring] [EOL] data = None [EOL] headers = { } [EOL] [EOL] if self . _token : [EOL] headers [ [string] ] = [string] . format ( self . _token ) [EOL] [EOL] if kwargs : [EOL] data = json . dumps ( kwargs ) . encode ( [string] ) [EOL] headers [ [string] ] = [string] [EOL] [EOL] req = urllib . request . Request ( [string] . format ( self . _url , path ) , data = data , headers = headers , method = method , ) [EOL] try : [EOL] with urllib . request . urlopen ( req , cafile = self . _cafile ) as res : [EOL] return self . _json_decode ( res ) [EOL] except urllib . error . HTTPError as e : [EOL] raise WWWError ( self . _json_decode ( e ) [ [string] ] ) [EOL] except ( ssl . CertificateError , urllib . error . URLError ) as e : [EOL] raise WWWError ( e ) [EOL] [EOL] @ staticmethod def _json_decode ( res ) : [EOL] [docstring] [EOL] data = res . read ( ) . decode ( [string] ) [EOL] try : [EOL] return json . loads ( data ) [comment] [EOL] except json . JSONDecodeError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return { [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Dict$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $urllib.request.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.request.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $typing.Union[http.client.HTTPResponse,typing.BinaryIO]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Union[http.client.HTTPResponse,typing.BinaryIO]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0