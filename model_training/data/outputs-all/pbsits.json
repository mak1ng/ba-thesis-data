	0
from typing import Any [EOL] import typing [EOL] from flask import request [EOL] [EOL] from . errors import ITSInvalidImageFileError [EOL] from . settings import MIME_TYPES , NAMESPACES [EOL] [EOL] [EOL] def get_redirect_location ( namespace , query , filename ) : [EOL] config = NAMESPACES [ namespace ] [EOL] redirect_url = [string] . format ( url = config [ [string] ] , query_param = config [ [string] ] , scheme = request . scheme , host = request . host , namespace = namespace , path = filename , ) [EOL] ext = query . pop ( [string] , None ) [EOL] for key , val in query . items ( ) : [EOL] redirect_url = redirect_url + [string] . format ( key = key , val = val ) [EOL] [EOL] if ext : [EOL] redirect_url = redirect_url + [string] + ext [EOL] [EOL] return redirect_url [EOL] [EOL] [EOL] def validate_image_type ( image ) : [EOL] if image . format . upper ( ) not in MIME_TYPES : [EOL] raise ITSInvalidImageFileError ( [string] ) [EOL] [EOL] return image [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict , Any , List [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] [comment] [EOL] DEBUG = os . environ . get ( [string] , [string] ) . lower ( ) == [string] [EOL] [EOL] [comment] [EOL] ENFORCE_TYPE_CHECKS = ( os . environ . get ( [string] , [string] ) . lower ( ) == [string] ) [EOL] [EOL] MIME_TYPES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] PNGQUANT_PATH = os . environ . get ( [string] , [string] ) [EOL] [EOL] DEFAULT_JPEG_QUALITY = int ( os . environ . get ( [string] , [string] ) ) [EOL] [EOL] DEFAULT_NAMESPACES = json . dumps ( { [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] , [string] ] , } , [string] : { [string] : True , [string] : [string] , [string] : [string] , } , } ) [EOL] [EOL] NAMESPACES = json . JSONDecoder ( ) . decode ( s = os . environ . get ( [string] , DEFAULT_NAMESPACES ) ) [EOL] [EOL] [EOL] DEFAULT_OVERLAYS = json . dumps ( { [string] : [string] } ) [EOL] [EOL] OVERLAYS = json . JSONDecoder ( ) . decode ( s = os . environ . get ( [string] , DEFAULT_OVERLAYS ) ) [EOL] [EOL] [comment] [EOL] FOCUS_KEYWORD = os . environ . get ( [string] , [string] ) [EOL] [EOL] DELIMITERS_RE = os . environ . get ( [string] , [string] ) [EOL] [EOL] SENTRY_DSN = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] CORS_ORIGINS = os . environ . get ( [string] , [string] ) . split ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import PIL [EOL] import io [EOL] import io [EOL] [EOL] from PIL import Image , ImageCms [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class NormalizationError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def normalize ( image ) : [EOL] output_mode = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] fmt = image . format [EOL] if image . mode in ( [string] , [string] ) : [EOL] output_mode = [string] [EOL] image = image . convert ( [string] ) [EOL] if [string] in image . info : [EOL] input_icc_profile = io . BytesIO ( image . info [ [string] ] ) [EOL] output_icc_profile = ImageCms . createProfile ( [string] ) [EOL] try : [EOL] image = ImageCms . profileToProfile ( image , input_icc_profile , output_icc_profile , outputMode = output_mode ) [EOL] except ImageCms . PyCMSError : [EOL] raise NormalizationError ( [string] ) [EOL] image . format = fmt [EOL] return image [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PIL.Image$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Dict , Any , Set [EOL] import typing [EOL] import its [EOL] import werkzeug [EOL] import builtins [EOL] import logging [EOL] import flask [EOL] import io [EOL] import logging [EOL] from io import BytesIO [EOL] from typing import Dict , Optional [EOL] [EOL] import sentry_sdk [EOL] from flask import Flask , abort , redirect , request [EOL] from flask_cors import CORS [EOL] from PIL import ImageFile , JpegImagePlugin [EOL] from sentry_sdk . integrations . flask import FlaskIntegration [EOL] from werkzeug import Response [EOL] [EOL] from its . errors import ITSClientError , NotFoundError [EOL] from its . loader import loader [EOL] from its . normalize import NormalizationError , normalize [EOL] from its . optimize import optimize [EOL] from its . pipeline import process_transforms [EOL] from its . settings import MIME_TYPES [EOL] [EOL] from . settings import CORS_ORIGINS , NAMESPACES , SENTRY_DSN [EOL] from . util import get_redirect_location [EOL] [EOL] [comment] [EOL] ImageFile . LOAD_TRUNCATED_IMAGES = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] JpegImagePlugin . _getmp = lambda x : None [comment] [EOL] [EOL] APP = Flask ( __name__ ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] CORS ( APP , origins = CORS_ORIGINS ) [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def before_send ( event , hint ) : [EOL] if [string] in hint : [EOL] log_record = hint [ [string] ] [EOL] [comment] [EOL] try : [EOL] if [string] in log_record . getMessage ( ) : [EOL] return None [EOL] except AttributeError : [EOL] return event [EOL] return event [EOL] [EOL] [EOL] if SENTRY_DSN : [EOL] sentry_sdk . init ( SENTRY_DSN , before_send = before_send , integrations = [ FlaskIntegration ( ) ] ) [EOL] [EOL] [EOL] def _normalize_query ( query ) : [EOL] fit_synonyms = { [string] , [string] } [EOL] if len ( ( fit_synonyms | { [string] } ) & set ( query . keys ( ) ) ) > [number] : [EOL] raise ITSClientError ( [string] ) [EOL] [EOL] for fit_snynonym in fit_synonyms : [EOL] if fit_snynonym in query : [EOL] query [ [string] ] = query [ fit_snynonym ] [EOL] del query [ fit_snynonym ] [EOL] [EOL] return query [EOL] [EOL] [EOL] def process_request ( namespace , query , filename ) : [EOL] query = _normalize_query ( query ) [EOL] [EOL] if namespace not in NAMESPACES : [EOL] abort ( [number] , [string] . format ( namespace = namespace ) ) [EOL] [EOL] namespace_config = NAMESPACES [ namespace ] [EOL] if namespace_config . get ( [string] ) : [EOL] location = get_redirect_location ( namespace , query , filename ) [EOL] return redirect ( location = location , code = [number] ) [EOL] [EOL] try : [EOL] image = loader ( namespace , filename ) [EOL] except NotFoundError : [EOL] abort ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( image , BytesIO ) : [EOL] output = image [EOL] mime_type = MIME_TYPES [ [string] ] [EOL] else : [EOL] try : [EOL] image = normalize ( image ) [EOL] except NormalizationError as err : [EOL] LOGGER . warning ( [string] , namespace , filename , err ) [EOL] image . info [ [string] ] = filename [EOL] result = process_transforms ( image , query ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] result = optimize ( result , query ) [EOL] [EOL] if result . format is None : [EOL] result . format = image . format [EOL] [EOL] mime_type = MIME_TYPES [ result . format . upper ( ) ] [EOL] [EOL] output = BytesIO ( ) [EOL] [EOL] if result . format . upper ( ) in ( [string] , [string] ) : [EOL] result . save ( output , format = result . format . upper ( ) , progressive = True , optimize = True ) [EOL] else : [EOL] result . save ( output , format = result . format . upper ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] resp_headers = { [string] : [string] } [EOL] [EOL] return Response ( response = output . getvalue ( ) , headers = resp_headers , mimetype = mime_type ) [EOL] [EOL] [EOL] def process_old_request ( transform , width = None , height = None , ext = None , x_coordinate = None , y_coordinate = None , ) : [EOL] [EOL] query = { } [EOL] query [ transform ] = [string] [EOL] [EOL] if width is not None : [EOL] query [ transform ] = str ( width ) + query [ transform ] [EOL] [EOL] if height is not None : [EOL] query [ transform ] = query [ transform ] + str ( height ) [EOL] [EOL] if ext is not None : [EOL] query [ [string] ] = ext [EOL] [EOL] if x_coordinate is not None : [EOL] query [ transform ] = query [ transform ] + [string] + str ( x_coordinate ) [EOL] [EOL] if y_coordinate is not None : [EOL] query [ transform ] = query [ transform ] + [string] + str ( y_coordinate ) [EOL] [EOL] return query [EOL] [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) def transform_image ( namespace , filename ) : [EOL] [docstring] [EOL] query = request . args . to_dict ( ) [EOL] result = process_request ( namespace , query , filename ) [EOL] return result [EOL] [EOL] [EOL] [comment] [EOL] @ APP . route ( [string] ) def crop ( namespace , filename , width , height , ext ) : [EOL] query = process_old_request ( [string] , width , height , ext ) [EOL] result = process_request ( namespace , query , filename ) [EOL] return result [EOL] [EOL] [EOL] @ APP . route ( [string] + [string] ) def focalcrop ( namespace , filename , width , height , x_coordinate , y_coordinate , ext , ) : [EOL] query = process_old_request ( [string] , width , height , ext , x_coordinate , y_coordinate ) [EOL] result = process_request ( namespace , query , filename ) [EOL] return result [EOL] [EOL] [EOL] @ APP . route ( [string] ) def fit ( namespace , filename , width , height , ext ) : [EOL] query = process_old_request ( [string] , width , height , ext ) [EOL] result = process_request ( namespace , query , filename ) [EOL] return result [EOL] [EOL] [EOL] [comment] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ APP . route ( [string] ) def resize ( namespace , filename , ext , width = None , height = None , ) : [EOL] query = process_old_request ( [string] , width , height , ext ) [EOL] result = process_request ( namespace , query , filename ) [EOL] return result [EOL] [EOL] [EOL] [comment] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ APP . route ( [string] ) def resize_passport ( namespace , filename , width , height , ext ) : [EOL] query = process_old_request ( [string] , width , height , ext ) [EOL] query [ [string] ] = [string] [EOL] result = process_request ( namespace , query , filename ) [EOL] return result [EOL] [EOL] [EOL] [comment] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ APP . route ( [string] ) def fit_passport ( namespace , filename , width , height , ext ) : [EOL] query = process_old_request ( [string] , width , height , ext ) [EOL] query [ [string] ] = [string] [EOL] result = process_request ( namespace , query , filename ) [EOL] return result [EOL] [EOL] [EOL] @ APP . errorhandler ( ITSClientError ) def handle_transform_error ( error ) : [EOL] return Response ( error . message , status = error . status_code ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] APP . run ( debug = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $werkzeug.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $werkzeug.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $werkzeug.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $werkzeug.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $werkzeug.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $werkzeug.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $werkzeug.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0
from its . application import APP as application [comment] [EOL] [EOL] if __name__ == [string] : [EOL] application . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , List , Sequence , Union [EOL] import typing [EOL] import PIL [EOL] import its [EOL] import builtins [EOL] import io [EOL] [docstring] [EOL] import re [EOL] from io import BytesIO [EOL] from typing import Dict , Union [EOL] [EOL] from PIL . JpegImagePlugin import JpegImageFile [EOL] from PIL . PngImagePlugin import PngImageFile [EOL] [EOL] from . transformations import ( BlurTransform , FitTransform , OverlayTransform , ResizeTransform , ) [EOL] [EOL] [EOL] def process_transforms ( img , query ) : [EOL] [docstring] [EOL] if not query : [comment] [EOL] return img [EOL] [EOL] if isinstance ( img , BytesIO ) : [comment] [EOL] return img [EOL] [EOL] if query . get ( [string] ) : [EOL] query [ [string] ] = query . pop ( [string] ) [EOL] [EOL] img_info = img . info [EOL] transform_order = [ BlurTransform , ResizeTransform , FitTransform , OverlayTransform ] [EOL] [EOL] [comment] [EOL] for transform in transform_order : [EOL] slug = transform . slug [EOL] if slug in query : [EOL] parameters = transform . derive_parameters ( query [ slug ] ) [EOL] img = transform ( ) . apply_transform ( img , parameters ) [EOL] [EOL] if img . format is None and [string] in img_info . keys ( ) : [EOL] [comment] [EOL] file_type = re . sub ( [string] , [string] , img_info [ [string] ] , flags = re . IGNORECASE ) [EOL] if file_type . lower ( ) == [string] or file_type . lower ( ) == [string] : [EOL] img . format = [string] [EOL] else : [EOL] img . format = file_type . upper ( ) [EOL] [EOL] return img [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[PIL.JpegImagePlugin.JpegImageFile,PIL.PngImagePlugin.PngImageFile,io.BytesIO]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict , Any [EOL] import builtins [EOL] import typing [EOL] from typing import Any , Dict , Optional [EOL] [EOL] from enforce import runtime_validation [EOL] [EOL] from . settings import ENFORCE_TYPE_CHECKS [EOL] [EOL] [EOL] @ runtime_validation ( enabled = ENFORCE_TYPE_CHECKS ) class ITSError ( Exception ) : [EOL] [docstring] [EOL] [EOL] status_code = [number] [EOL] message = [string] [EOL] payload = dict ( ) [EOL] [EOL] def __init__ ( self , error , * args , status_code = None , payload = None ) : [EOL] super ( ) . __init__ ( error ) [EOL] [EOL] self . message = self . message + error [EOL] [EOL] if payload : [EOL] self . payload = payload [EOL] [EOL] if status_code : [EOL] self . status_code = status_code [EOL] [EOL] if args : [EOL] self . args = args [EOL] [EOL] [EOL] class ConfigError ( ITSError ) : [EOL] [docstring] [EOL] [EOL] status_code = [number] [EOL] message = [string] [EOL] [EOL] [EOL] class ITSLoaderError ( ITSError ) : [EOL] [docstring] [EOL] [EOL] status_code = [number] [EOL] message = [string] [EOL] [EOL] [EOL] class ITSInvalidImageFileError ( ITSLoaderError ) : [EOL] pass [EOL] [EOL] [EOL] class ITSTransformError ( ITSError ) : [EOL] [docstring] [EOL] [EOL] status_code = [number] [EOL] message = [string] [EOL] [EOL] [EOL] class NotFoundError ( ITSError ) : [EOL] [docstring] [EOL] [EOL] status_code = [number] [EOL] message = [string] [EOL] [EOL] [EOL] class ITSClientError ( ITSError ) : [EOL] status_code = [number] [EOL] message = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0
from typing import Type , Any , List [EOL] import its [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] from flask import request [EOL] from PIL . Image import DecompressionBombError [EOL] [EOL] from . errors import ( ConfigError , ITSClientError , ITSInvalidImageFileError , ITSLoaderError , ) [EOL] from . loaders import BaseLoader [EOL] from . settings import NAMESPACES [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def loader ( namespace , filename ) : [EOL] [EOL] [docstring] [EOL] loader_classes = BaseLoader . __subclasses__ ( ) [EOL] [EOL] if namespace not in NAMESPACES : [EOL] raise ConfigError ( [string] % namespace ) [EOL] [EOL] loader_parameters = NAMESPACES [ namespace ] [EOL] loader_slug = loader_parameters [ [string] ] [EOL] [EOL] matching_loaders = [ loader for loader in loader_classes if loader . slug == loader_slug ] [EOL] [EOL] if not matching_loaders : [EOL] raise ITSLoaderError ( [string] % loader_slug ) [EOL] [EOL] if len ( matching_loaders ) > [number] : [EOL] raise ConfigError ( [string] % loader_slug ) [EOL] [EOL] image_loader = matching_loaders [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] path_segments = filename . split ( [string] ) [EOL] if image_loader . slug == [string] and path_segments [ [number] ] == request . host : [EOL] namespace = path_segments [ [number] ] [EOL] filename = [string] . join ( path_segments [ [number] : ] ) [EOL] return loader ( namespace , filename ) [EOL] [EOL] if filename . endswith ( [string] ) : [EOL] return image_loader . get_fileobj ( namespace , filename ) [EOL] [EOL] try : [EOL] image = image_loader . load_image ( namespace , filename ) [EOL] except OSError as error : [EOL] LOGGER . error ( error ) [EOL] raise ITSClientError ( [string] . format ( ns = namespace , fn = filename ) ) [EOL] except ITSInvalidImageFileError : [EOL] raise ITSClientError ( [string] . format ( ns = namespace , fn = filename ) ) [EOL] except DecompressionBombError : [EOL] raise ITSClientError ( [string] . format ( ns = namespace , fn = filename ) ) [EOL] [EOL] return image [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] from io import BytesIO [EOL] from unittest import TestCase [EOL] [EOL] from PIL import Image [EOL] [EOL] from its . application import APP [EOL] [EOL] from . test_pipeline import compare_pixels [EOL] [EOL] [EOL] class TestOverlay ( TestCase ) : [EOL] @ classmethod def setUpClass ( self ) : [EOL] APP . config [ [string] ] = True [EOL] self . client = APP . test_client ( ) [EOL] [EOL] def test_simple_overlay ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_overlay_with_leading_slash ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_simple_overlay_with_underscores ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_empty_overlay ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] body = response . data . decode ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert [string] in body [EOL] [EOL] def test_legacy_passport_resize_overlay ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_legacy_passport_fit_overlay ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_overlay_image_resize_100_bytes ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] expected_image_path = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] , ) [EOL] [EOL] comparison = compare_pixels ( Image . open ( expected_image_path ) , Image . open ( BytesIO ( response . data ) ) ) [EOL] [EOL] self . assertGreaterEqual ( comparison , [number] ) [EOL] [EOL] def test_overlay_image_resize_500_bytes ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] expected_image_path = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] , ) [EOL] [EOL] comparison = compare_pixels ( Image . open ( expected_image_path ) , Image . open ( BytesIO ( response . data ) ) ) [EOL] [EOL] self . assertGreaterEqual ( comparison , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import vcr [EOL] [EOL] test_vcr = vcr . VCR ( cassette_library_dir = [string] , record_mode = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] from unittest import TestCase [EOL] [EOL] from its . application import APP [EOL] [EOL] [EOL] class TestCorsHeaders ( TestCase ) : [EOL] @ classmethod def setUpClass ( self ) : [EOL] APP . config [ [string] ] = True [EOL] self . client = APP . test_client ( ) [EOL] [EOL] def test_cors_on_get ( self ) : [EOL] resp = self . client . get ( [string] , headers = [ [ [string] , [string] ] ] ) [EOL] assert resp . headers . get ( [string] ) == [string] [EOL] [EOL] resp = self . client . get ( [string] , headers = [ [ [string] , [string] ] ] ) [EOL] assert resp . headers . get ( [string] ) == [string] [EOL] [EOL] resp = self . client . get ( [string] , headers = [ [ [string] , [string] ] ] ) [EOL] assert resp . headers . get ( [string] ) is None [EOL] [EOL] def test_cors_on_options ( self ) : [EOL] resp = self . client . options ( [string] , headers = [ [ [string] , [string] ] ] ) [EOL] assert resp . headers . get ( [string] ) == [string] [EOL] [EOL] resp = self . client . options ( [string] , headers = [ [ [string] , [string] ] ] ) [EOL] assert resp . headers . get ( [string] ) == [string] [EOL] [EOL] resp = self . client . options ( [string] , headers = [ [ [string] , [string] ] ] ) [EOL] assert resp . headers . get ( [string] ) is None [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from its . application import APP [EOL] [EOL] from . import test_vcr [EOL] [EOL] [EOL] class TestRedirects ( TestCase ) : [EOL] @ classmethod def setUpClass ( self ) : [EOL] APP . config [ [string] ] = True [EOL] self . client = APP . test_client ( ) [EOL] [EOL] @ test_vcr . use_cassette ( ) def test_merlin_http ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] @ test_vcr . use_cassette ( ) def test_self_referential_http_backend_use ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] @ test_vcr . use_cassette ( ) def test_http_backend_404 ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from its . application import APP [EOL] [EOL] [EOL] class TestRedirects ( TestCase ) : [EOL] @ classmethod def setUpClass ( self ) : [EOL] APP . config [ [string] ] = True [EOL] self . client = APP . test_client ( ) [EOL] [EOL] def test_bad_resize_argument ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] body = response . data . decode ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert [string] in body [EOL] [EOL] def test_bad_format_argument ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] body = response . data . decode ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert [string] in body [EOL] [EOL] def test_zero_fit_argument ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] body = response . data . decode ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert [string] in body [EOL] [EOL] def test_strange_punctuation_legacy_resize ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] body = response . data . decode ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert [string] in body [EOL] [EOL] def test_strange_arguments_legacy_pipeline ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
import pytest [EOL] [EOL] [EOL] def pytest_collection_finish ( session ) : [EOL] [docstring] [EOL] from pyannotate_runtime import collect_types [EOL] [EOL] collect_types . init_types_collection ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def collect_types_fixture ( ) : [EOL] from pyannotate_runtime import collect_types [EOL] [EOL] collect_types . resume ( ) [EOL] yield [EOL] collect_types . pause ( ) [EOL] [EOL] [EOL] def pytest_sessionfinish ( session , exitstatus ) : [EOL] from pyannotate_runtime import collect_types [EOL] [EOL] collect_types . dump_stats ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from its . application import APP [EOL] [EOL] [EOL] class TestRedirects ( TestCase ) : [EOL] @ classmethod def setUpClass ( self ) : [EOL] APP . config [ [string] ] = True [EOL] self . client = APP . test_client ( ) [EOL] [EOL] def test_redirect ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert ( response . location == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Dict , Tuple , Any , List [EOL] import typing [EOL] import io [EOL] import itertools [EOL] import os [EOL] import tempfile [EOL] import unittest [EOL] from io import BytesIO [EOL] from pathlib import Path [EOL] from unittest import TestCase [EOL] from unittest . mock import patch [EOL] [EOL] from PIL import Image [EOL] [EOL] import its . errors [EOL] from its . application import APP [EOL] from its . optimize import has_transparent_background , optimize [EOL] from its . pipeline import process_transforms [EOL] [EOL] [EOL] def get_pixels ( image ) : [EOL] [comment] [EOL] coords = list ( itertools . product ( range ( image . width ) , range ( image . height ) ) ) [EOL] [comment] [EOL] pixels = [ image . getpixel ( coord ) for coord in coords ] [EOL] [EOL] return pixels [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def compare_pixels ( img1 , img2 , tolerance = [number] , is_white_or_black_image = False ) : [EOL] number_of_color_indices = [number] [EOL] if is_white_or_black_image : [EOL] number_of_color_indices = [number] [EOL] [EOL] def pixel_matches ( pixel1 , pixel2 , tolerance ) : [EOL] matching_vals = [ abs ( pixel1 [ i ] - pixel2 [ i ] ) <= tolerance for i in range ( number_of_color_indices ) ] [EOL] return all ( matching_vals ) [EOL] [EOL] img1_pixels = get_pixels ( img1 ) [EOL] img2_pixels = get_pixels ( img2 ) [EOL] matches = [number] [EOL] total = len ( img1_pixels ) [comment] [EOL] [EOL] for pixel_pair in zip ( img1_pixels , img2_pixels ) : [EOL] if pixel_matches ( pixel_pair [ [number] ] , pixel_pair [ [number] ] , tolerance ) : [EOL] matches += [number] [EOL] [EOL] return matches / total [EOL] [EOL] [EOL] class TestFitTransform ( TestCase ) : [EOL] @ classmethod def setUpClass ( self ) : [EOL] self . img_dir = Path ( __file__ ) . parent / [string] [EOL] [EOL] @ patch ( [string] ) def test_default_fit_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] @ patch ( [string] ) def test_default_crop_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] @ patch ( [string] ) def test_focal_fit_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] @ patch ( [string] ) def test_focal_crop_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] @ patch ( [string] ) def test_focal_1x1_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] @ patch ( [string] ) def test_focalcrop_1x1_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] @ patch ( [string] ) def test_focal_100x100_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] @ patch ( [string] ) def test_focalcrop_100x100_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] @ patch ( [string] ) def test_smart_70x1_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] @ patch ( [string] ) def test_smartcrop_70x1_no_alpha ( self , MockFitTransform ) : [EOL] fit_transform = MockFitTransform ( ) [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] fit_transform . return_value = True [EOL] fit_transform ( test_image , query ) [EOL] fit_transform . assert_called_with ( test_image , query ) [EOL] [EOL] def test_invalid_fit_size ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] [EOL] with self . assertRaises ( its . errors . ITSClientError ) : [EOL] process_transforms ( test_image , query ) [EOL] [EOL] def test_invalid_crop_size ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] [EOL] with self . assertRaises ( its . errors . ITSClientError ) : [EOL] process_transforms ( test_image , query ) [EOL] [EOL] def test_invalid_focal_percentages ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] [EOL] with self . assertRaises ( its . errors . ITSClientError ) : [EOL] process_transforms ( test_image , query ) [EOL] [EOL] def test_invalid_crop_focal_percentages ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] [EOL] with self . assertRaises ( its . errors . ITSClientError ) : [EOL] process_transforms ( test_image , query ) [EOL] [EOL] [EOL] class TestResizeTransform ( TestCase ) : [EOL] @ classmethod def setUpClass ( self ) : [EOL] [comment] [EOL] self . img_dir = Path ( __file__ ) . parent / [string] [EOL] self . threshold = [number] [EOL] [EOL] def test_resize_size ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] result = process_transforms ( test_image , query ) [EOL] self . assertEqual ( result . size , ( [number] , [number] ) ) [EOL] [EOL] def test_resize_without_height ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] result = process_transforms ( test_image , query ) [EOL] self . assertEqual ( result . width , [number] ) [EOL] self . assertEqual ( result . height , [number] ) [EOL] [EOL] def test_resize_without_width ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] result = process_transforms ( test_image , query ) [EOL] self . assertEqual ( result . width , [number] ) [EOL] self . assertEqual ( result . height , [number] ) [EOL] [EOL] def test_resize_integrity_smaller ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] expected = Image . open ( self . img_dir / [string] ) [EOL] actual = process_transforms ( test_image , query ) [EOL] [comment] [EOL] comparison = compare_pixels ( expected , actual ) [EOL] self . assertGreaterEqual ( comparison , self . threshold ) [EOL] [EOL] def test_resize_integrity_smaller_noscaleup ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] expected = Image . open ( self . img_dir / [string] ) [EOL] actual = process_transforms ( test_image , query ) [EOL] [comment] [EOL] assert actual . width == expected . width [EOL] assert actual . height == expected . height [EOL] comparison = compare_pixels ( expected , actual ) [EOL] self . assertGreaterEqual ( comparison , self . threshold ) [EOL] [EOL] def test_resize_integrity_larger ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] expected = Image . open ( self . img_dir / [string] ) [EOL] actual = process_transforms ( test_image , query ) [EOL] comparison = compare_pixels ( expected , actual ) [EOL] self . assertGreaterEqual ( comparison , self . threshold ) [EOL] [EOL] def test_resize_integrity_larger_noscaleup ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] [comment] [EOL] expected = Image . open ( self . img_dir / [string] ) [EOL] actual = process_transforms ( test_image , query ) [EOL] comparison = compare_pixels ( expected , actual ) [EOL] assert actual . width == expected . width [EOL] assert actual . height == expected . height [EOL] self . assertGreaterEqual ( comparison , self . threshold ) [EOL] [EOL] def test_resize_integrity_larger_noscaleup_width_only ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] expected = Image . open ( self . img_dir / [string] ) [EOL] actual = process_transforms ( test_image , query ) [EOL] assert actual . width == expected . width [EOL] assert actual . height == expected . height [EOL] comparison = compare_pixels ( expected , actual ) [EOL] self . assertGreaterEqual ( comparison , self . threshold ) [EOL] [EOL] def test_resize_integrity_larger_noscaleup_height_only ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] test_image . info [ [string] ] = [string] [EOL] query = { [string] : [string] } [EOL] expected = Image . open ( self . img_dir / [string] ) [EOL] actual = process_transforms ( test_image , query ) [EOL] assert actual . width == expected . width [EOL] assert actual . height == expected . height [EOL] comparison = compare_pixels ( expected , actual ) [EOL] self . assertGreaterEqual ( comparison , self . threshold ) [EOL] [EOL] def test_invalid_resize ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] query = { [string] : [string] } [EOL] [EOL] with self . assertRaises ( its . errors . ITSClientError ) : [EOL] process_transforms ( test_image , query ) [EOL] [EOL] def test_resize_format ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] query = { [string] : [string] , [string] : [string] } [EOL] [EOL] with self . assertRaises ( its . errors . ITSClientError ) : [EOL] result = process_transforms ( test_image , query ) [EOL] optimize ( result , query ) [EOL] [EOL] [EOL] class TestImageResults ( TestCase ) : [EOL] @ classmethod def setUpClass ( self ) : [EOL] [comment] [EOL] self . img_dir = Path ( __file__ ) . parent / [string] [EOL] [EOL] def test_jpg_progressive ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] result = optimize ( test_image , { [string] : [string] } ) [EOL] self . assertEqual ( result . info [ [string] ] , [number] ) [EOL] [EOL] def test_jpg_quality_vs_size ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] quality_1 = optimize ( test_image , { [string] : [number] , [string] : [string] } ) [EOL] with tempfile . NamedTemporaryFile ( dir = [string] , delete = True ) as tmp_file_1 : [EOL] quality_1 . save ( tmp_file_1 . name , format = quality_1 . format ) [EOL] q1_size = os . stat ( tmp_file_1 . name ) . st_size [EOL] [EOL] quality_10 = optimize ( test_image , { [string] : [number] , [string] : [string] } ) [EOL] with tempfile . NamedTemporaryFile ( dir = [string] , delete = True ) as tmp_file_2 : [EOL] quality_10 . save ( tmp_file_2 . name , format = quality_10 . format ) [EOL] q10_size = os . stat ( tmp_file_2 . name ) . st_size [EOL] [EOL] self . assertLessEqual ( q1_size , q10_size ) [EOL] [EOL] def test_png_quality_vs_size ( self ) : [EOL] test_image = Image . open ( self . img_dir / [string] ) [EOL] quality_1 = optimize ( test_image , { [string] : [string] } ) [EOL] with tempfile . NamedTemporaryFile ( dir = [string] , delete = True ) as tmp_file_1 : [EOL] quality_1 . save ( tmp_file_1 . name , format = quality_1 . format ) [EOL] q1_size = os . stat ( tmp_file_1 . name ) . st_size [EOL] [EOL] quality_10 = optimize ( test_image , { [string] : [string] } ) [EOL] with tempfile . NamedTemporaryFile ( dir = [string] , delete = True ) as tmp_file_2 : [EOL] quality_10 . save ( tmp_file_2 . name , format = quality_10 . format ) [EOL] q10_size = os . stat ( tmp_file_2 . name ) . st_size [EOL] [EOL] self . assertLessEqual ( q1_size , q10_size ) [EOL] [EOL] [EOL] class TestPipelineEndToEnd ( TestCase ) : [EOL] @ classmethod def setUpClass ( self ) : [EOL] APP . config [ [string] ] = True [EOL] self . client = APP . test_client ( ) [EOL] self . img_dir = Path ( __file__ ) . parent / [string] [EOL] self . threshold = [number] [EOL] [EOL] def test_secret_png ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_cmyk_jpg_to_rgb_png ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_svg_passthrough ( self ) : [EOL] reference_image = BytesIO ( open ( self . img_dir / [string] , [string] ) . read ( ) ) [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] assert response . data == reference_image . getvalue ( ) [EOL] [EOL] def test_grayscale_png_to_jpg ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_jpg_to_webp ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_jpg_without_extension_to_png ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_jpg_without_extension_to_focalcrop ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_focal_crop_without_filename_priority ( self ) : [EOL] [comment] [EOL] ref_img_500_500_50_10 = Image . open ( [string] . format ( self . img_dir ) ) [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] comparison = compare_pixels ( ref_img_500_500_50_10 , Image . open ( BytesIO ( response . data ) ) , tolerance = [number] ) [EOL] self . assertGreaterEqual ( comparison , [number] ) [EOL] [EOL] def test_focal_crop_filename_priority ( self ) : [EOL] [comment] [EOL] ref_img_500_500_10_90 = Image . open ( [string] . format ( self . img_dir ) ) [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] comparison = compare_pixels ( ref_img_500_500_10_90 , Image . open ( BytesIO ( response . data ) ) , tolerance = [number] ) [EOL] self . assertGreaterEqual ( comparison , [number] ) [EOL] [EOL] def test_small_vertical_resize ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_auto_format_flat_jpeg ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_auto_format_complex_transparent_png ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_transparent_png_with_icc ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] response_image = Image . open ( BytesIO ( response . data ) ) [EOL] assert has_transparent_background ( response_image ) [EOL] [EOL] def test_auto_format_complex_opaque_png ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_cache_control_on_200 ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] assert response . headers [ [string] ] == [string] [EOL] [EOL] def test_auto_format_complex_jpeg ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_icc_profile_converted ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] actual = Image . open ( BytesIO ( response . data ) ) [EOL] expected = Image . open ( self . img_dir / [string] ) [EOL] comparison = compare_pixels ( expected , actual ) [EOL] self . assertGreaterEqual ( comparison , self . threshold ) [EOL] assert [string] not in actual . info [EOL] [EOL] def test_white_transparent_background_converted ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] actual = Image . open ( BytesIO ( response . data ) ) [EOL] expected = Image . open ( self . img_dir / [string] ) [EOL] comparison = compare_pixels ( expected , actual , is_white_or_black_image = True ) [EOL] self . assertGreaterEqual ( comparison , self . threshold ) [EOL] [EOL] def test_focalcrop_parity ( self ) : [EOL] old_style_response = self . client . get ( [string] ) [EOL] new_style_response = self . client . get ( [string] ) [EOL] comparison = compare_pixels ( Image . open ( BytesIO ( old_style_response . data ) ) , Image . open ( BytesIO ( new_style_response . data ) ) , ) [EOL] self . assertGreaterEqual ( comparison , self . threshold ) [EOL] [EOL] def test_resize_without_height ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] [EOL] def test_valid_blur_request ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_blur_zero_value_parity ( self ) : [EOL] old_style_response = self . client . get ( [string] ) [EOL] new_style_response = self . client . get ( [string] ) [EOL] comparison = compare_pixels ( Image . open ( BytesIO ( old_style_response . data ) ) , Image . open ( BytesIO ( new_style_response . data ) ) , ) [EOL] [EOL] self . assertEqual ( comparison , [number] ) [EOL] [EOL] def test_blur_non_parity ( self ) : [EOL] old_style_response = self . client . get ( [string] ) [EOL] new_style_response = self . client . get ( [string] ) [EOL] comparison = compare_pixels ( Image . open ( BytesIO ( old_style_response . data ) ) , Image . open ( BytesIO ( new_style_response . data ) ) , ) [EOL] self . assertLessEqual ( comparison , self . threshold ) [EOL] [EOL] def test_invalid_blur_request_alpha_value ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_invalid_blur_request_no_value ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_untransformable_icc_profile ( self ) : [EOL] [comment] [EOL] [comment] [EOL] response = self . client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . mimetype == [string] [EOL] image = Image . open ( BytesIO ( response . data ) ) [EOL] assert [string] not in image . info [EOL] [EOL] def test_progressive_jpeg ( self ) : [EOL] [comment] [EOL] def is_progressive ( buffer ) : [EOL] prog_jpeg_header_marker = [string] [EOL] prog_jpeg_scan_start_marker = [string] [EOL] buffer . seek ( [number] ) [EOL] content = buffer . read ( ) [EOL] if not content . find ( prog_jpeg_header_marker ) : [EOL] return False [EOL] if content . count ( prog_jpeg_scan_start_marker ) < [number] : [EOL] return False [EOL] return True [EOL] [EOL] response = self . client . get ( [string] ) [EOL] assert response . mimetype == [string] [EOL] buffer = BytesIO ( response . data ) [EOL] assert is_progressive ( buffer ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.BytesIO$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . blur import BlurTransform [comment] [EOL] from . fit import FitTransform [comment] [EOL] from . overlay import OverlayTransform [comment] [EOL] from . resize import ResizeTransform [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import Sequence [EOL] [EOL] from PIL import ImageFilter [EOL] [EOL] from . . errors import ITSClientError [EOL] from . . settings import DELIMITERS_RE [EOL] from . base import BaseTransform [EOL] [EOL] [EOL] class BlurTransform ( BaseTransform ) : [EOL] [EOL] slug = [string] [EOL] [EOL] @ staticmethod def derive_parameters ( query ) : [EOL] return re . split ( DELIMITERS_RE , query ) [EOL] [EOL] def apply_transform ( self , img , parameters ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] blur = int ( parameters [ [number] ] ) [EOL] except ValueError : [EOL] raise ITSClientError ( error = [string] ) [EOL] [EOL] return img . filter ( ImageFilter . GaussianBlur ( blur ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
from typing import Sequence , Union [EOL] import typing [EOL] import builtins [EOL] import PIL [EOL] from typing import Sequence , Union [EOL] [EOL] from PIL import Image [EOL] [EOL] [EOL] class BaseTransform : [EOL] [EOL] [docstring] [EOL] [EOL] slug = None [comment] [EOL] [EOL] @ staticmethod def apply_transform ( img , parameters ) : [EOL] raise NotImplementedError [EOL] [EOL] @ staticmethod def derive_parameters ( query ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str]$ 0 0 0 0 0 0 0 0 $PIL.Image.Image$ 0 $PIL.Image.Image$ 0 $typing.Sequence[typing.Union[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Union[builtins.str,builtins.int]]$ 0 $builtins.str$ 0 0 0 0 0 0
from typing import Type , Any , List , Sequence [EOL] import typing [EOL] import its [EOL] import builtins [EOL] import logging [EOL] import pathlib [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Sequence [EOL] [EOL] from PIL import Image [EOL] [EOL] from . . errors import ConfigError , ITSClientError , ITSTransformError [EOL] from . . loaders import BaseLoader [EOL] from . . settings import NAMESPACES , OVERLAYS [EOL] from . base import BaseTransform [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] OVERLAY_PROPORTION = [number] [EOL] [EOL] [EOL] def get_loader ( overlay_loader ) : [EOL] [EOL] loader_classes = BaseLoader . __subclasses__ ( ) [EOL] [EOL] loader = [ loader for loader in loader_classes if loader . slug == overlay_loader ] [EOL] [EOL] if not loader : [EOL] raise ITSTransformError ( [string] + [string] % overlay_loader ) [EOL] if len ( loader ) > [number] : [EOL] raise ITSTransformError ( [string] + [string] % overlay_loader ) [EOL] [EOL] return loader [EOL] [EOL] [EOL] class OverlayTransform ( BaseTransform ) : [EOL] [EOL] [docstring] [EOL] [EOL] slug = [string] [EOL] [EOL] @ staticmethod def derive_parameters ( query ) : [EOL] [comment] [EOL] return [ query ] [EOL] [EOL] def apply_transform ( self , img , parameters ) : [EOL] if not parameters : [EOL] raise ITSClientError ( [string] ) [EOL] [EOL] if len ( parameters ) > [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] overlay = parameters [ [number] ] [EOL] if not overlay : [EOL] raise ITSClientError ( [string] ) [EOL] [EOL] if [string] in NAMESPACES : [EOL] loader = get_loader ( NAMESPACES [ [string] ] [ [string] ] ) [EOL] else : [EOL] raise ConfigError ( [string] ) [EOL] [EOL] if overlay . lower ( ) not in OVERLAYS : [EOL] namespace , * filename = overlay . strip ( [string] ) . split ( [string] ) [EOL] filename = Path ( [string] . join ( filename ) ) [EOL] overlay_image = loader [ [number] ] . load_image ( namespace , filename ) [EOL] else : [EOL] namespace , * filename = OVERLAYS [ overlay . lower ( ) ] . split ( [string] ) [EOL] filename = Path ( [string] . join ( filename ) ) [EOL] overlay_image = loader [ [number] ] . load_image ( namespace , filename ) [EOL] [EOL] height = img . height [EOL] overlay_size = int ( height * OVERLAY_PROPORTION ) [EOL] resized_overlay = overlay_image . resize ( ( overlay_size , overlay_size ) , Image . ANTIALIAS ) [EOL] [EOL] [comment] [EOL] if img . mode != [string] : [EOL] new_img = img . copy ( ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] new_img = Image . new ( [string] , img . size ) [EOL] new_img = Image . alpha_composite ( new_img , img ) [EOL] [EOL] padding_top = int ( height * [number] ) [EOL] padding_left = int ( height * [number] ) [EOL] new_img . paste ( resized_overlay , ( padding_top , padding_left ) , mask = resized_overlay ) [EOL] [EOL] return new_img [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0
from typing import Optional , Any , Sequence [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from math import floor [EOL] from typing import Sequence [EOL] [EOL] from PIL import Image [EOL] [EOL] from . . errors import ITSClientError [EOL] from . . settings import DELIMITERS_RE [EOL] from . base import BaseTransform [EOL] [EOL] [EOL] class ResizeTransform ( BaseTransform ) : [EOL] [EOL] slug = [string] [EOL] [EOL] @ staticmethod def derive_parameters ( query ) : [EOL] return re . split ( DELIMITERS_RE , query ) [EOL] [EOL] def apply_transform ( self , img , parameters ) : [EOL] [docstring] [EOL] option = [string] [EOL] if len ( parameters ) == [number] : [EOL] width , height = parameters [EOL] elif len ( parameters ) == [number] : [EOL] width , height , option = parameters [EOL] else : [EOL] raise ITSClientError ( [string] ) [EOL] [EOL] if img . width == [number] or img . height == [number] : [EOL] raise ITSClientError ( [string] [string] ) [EOL] [EOL] try : [EOL] width = int ( width ) if width != [string] else None [EOL] height = int ( height ) if height != [string] else None [EOL] except ValueError : [EOL] raise ITSClientError ( [string] [string] [string] [string] ) [EOL] [EOL] if width is None and height is None : [EOL] raise ITSClientError ( [string] [string] [string] [string] ) [EOL] [EOL] if width and height and width * height > Image . MAX_IMAGE_PIXELS : [EOL] raise ITSClientError ( [string] . format ( w = width , h = height ) ) [EOL] [EOL] if width is None : [EOL] tgt_width = floor ( ( img . width / img . height ) * height ) [EOL] tgt_height = height [EOL] elif height is None : [EOL] tgt_height = floor ( ( img . height / img . width ) * width ) [EOL] tgt_width = width [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] ratio = min ( width / img . width , height / img . height ) [EOL] [comment] [EOL] tgt_width = max ( floor ( img . width * ratio ) , [number] ) [EOL] tgt_height = max ( floor ( img . height * ratio ) , [number] ) [EOL] [EOL] if option == [string] and ( tgt_width > img . width or tgt_height > img . height ) : [EOL] tgt_height = img . height [EOL] tgt_width = img . width [EOL] [EOL] resized = img . resize ( [ tgt_width , tgt_height ] , Image . ANTIALIAS ) [EOL] [EOL] [comment] [EOL] resized . format = img . format [EOL] [EOL] return resized [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from . base import BaseLoader [comment] [EOL] from . file_system import FileSystemLoader [comment] [EOL] from . http import HTTPLoader [comment] [EOL] from . s3_loader import S3Loader [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import typing [EOL] import requests [EOL] from io import BytesIO [EOL] [EOL] import requests [EOL] from PIL import Image [EOL] [EOL] from . . errors import ITSLoaderError , NotFoundError [EOL] from . . settings import NAMESPACES [EOL] from . . util import validate_image_type [EOL] from . base import BaseLoader [EOL] [EOL] [EOL] class HTTPLoader ( BaseLoader ) : [EOL] [EOL] slug = [string] [EOL] parameter_name = [string] [EOL] [EOL] @ staticmethod def get_fileobj ( namespace , filename ) : [EOL] [docstring] [EOL] prefixes = set ( filename . rsplit ( [string] , [number] ) [ [number] ] . split ( [string] ) ) [comment] [EOL] params = NAMESPACES [ namespace ] [ HTTPLoader . parameter_name ] [EOL] intersect = set ( params ) . intersection ( prefixes ) [EOL] [EOL] if not intersect : [EOL] raise NotFoundError ( [string] . format ( namespace ) ) [EOL] [EOL] if filename . startswith ( [string] ) : [EOL] url = filename [EOL] else : [EOL] url = [string] . format ( filename ) [EOL] response = requests . get ( url ) [EOL] [EOL] if response . status_code in [ [number] , [number] ] : [EOL] raise NotFoundError ( [string] . format ( namespace = namespace , filename = filename ) ) [EOL] if response . status_code != [number] : [EOL] raise ITSLoaderError ( [string] . format ( code = response . status_code , namespace = namespace , filename = filename ) , status_code = [number] , ) [EOL] [EOL] [comment] [EOL] return BytesIO ( response . content ) [EOL] [EOL] @ staticmethod def load_image ( namespace , filename ) : [EOL] [docstring] [EOL] try : [EOL] file_obj = HTTPLoader . get_fileobj ( namespace , filename ) [EOL] img = Image . open ( file_obj ) [EOL] [EOL] except NotFoundError as error : [EOL] raise NotFoundError ( [string] % str ( error ) ) [EOL] [EOL] validate_image_type ( img ) [EOL] [EOL] return img [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import io [EOL] import logging [EOL] from io import BytesIO [EOL] [EOL] import boto3 [EOL] from botocore . exceptions import ClientError [EOL] from PIL import Image [EOL] [EOL] from . . errors import NotFoundError [EOL] from . . settings import NAMESPACES [EOL] from . . util import validate_image_type [EOL] from . base import BaseLoader [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class S3Loader ( BaseLoader ) : [EOL] [EOL] slug = [string] [EOL] parameter_name = [string] [EOL] [EOL] @ staticmethod def get_fileobj ( namespace , filename ) : [EOL] [docstring] [EOL] [comment] [EOL] s3_resource = boto3 . resource ( [string] ) [EOL] [EOL] config = NAMESPACES [ namespace ] [EOL] path = config . get ( [string] , namespace ) . strip ( [string] ) [EOL] key = [string] . format ( path = path , filename = filename ) . strip ( [string] ) [EOL] bucket_name = config [ S3Loader . parameter_name ] [EOL] s3_object = s3_resource . Object ( bucket_name = bucket_name , key = key ) [EOL] [EOL] [comment] [EOL] file_obj = BytesIO ( ) [EOL] s3_object . download_fileobj ( file_obj ) [EOL] [EOL] return file_obj [EOL] [EOL] @ staticmethod def load_image ( namespace , filename ) : [EOL] [docstring] [EOL] try : [EOL] file_obj = S3Loader . get_fileobj ( namespace , filename ) [EOL] except ClientError as error : [EOL] error_code = error . response [ [string] ] [ [string] ] [EOL] [EOL] if error_code == [string] : [EOL] raise NotFoundError ( [string] % str ( error ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if error_code == [string] : [EOL] LOGGER . warning ( [string] , NAMESPACES [ namespace ] [ S3Loader . parameter_name ] , ) [EOL] raise NotFoundError ( [string] % str ( error ) ) [EOL] [EOL] raise error [EOL] [EOL] image = Image . open ( file_obj ) [EOL] [EOL] validate_image_type ( image ) [EOL] [EOL] return image [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 $typing.Any$ 0 0 0 $io.BytesIO$ 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0
from typing import Any , Union [EOL] import typing [EOL] import PIL [EOL] import builtins [EOL] import pathlib [EOL] import io [EOL] from io import BytesIO [EOL] from pathlib import Path , PosixPath [EOL] from typing import Union [EOL] [EOL] from enforce import runtime_validation [EOL] from PIL import Image [EOL] from PIL . JpegImagePlugin import JpegImageFile [EOL] from PIL . PngImagePlugin import PngImageFile [EOL] [EOL] from . . errors import NotFoundError [EOL] from . . settings import ENFORCE_TYPE_CHECKS [EOL] from . . util import validate_image_type [EOL] from . base import BaseLoader [EOL] [EOL] [EOL] class FileSystemLoader ( BaseLoader ) : [EOL] [EOL] slug = [string] [EOL] parameter_name = [string] [EOL] [EOL] @ runtime_validation ( enabled = ENFORCE_TYPE_CHECKS ) @ staticmethod def load_image ( namespace , filename ) : [EOL] [docstring] [EOL] if isinstance ( filename , PosixPath ) : [EOL] filename = str ( filename ) [EOL] [comment] [EOL] try : [EOL] image_bytes = FileSystemLoader . get_fileobj ( namespace , filename ) [EOL] image = Image . open ( image_bytes ) [EOL] except FileNotFoundError : [EOL] raise NotFoundError ( [string] % ( Path ( namespace + [string] + filename ) ) ) [EOL] validate_image_type ( image ) [EOL] [EOL] return image [EOL] [EOL] @ runtime_validation ( enabled = ENFORCE_TYPE_CHECKS ) @ staticmethod def get_fileobj ( namespace , filename ) : [EOL] [docstring] [EOL] api_root = Path ( __file__ ) . parents [ [number] ] [EOL] image_path = Path ( api_root / namespace / filename ) [EOL] return BytesIO ( open ( image_path , [string] ) . read ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[PIL.JpegImagePlugin.JpegImageFile,PIL.PngImagePlugin.PngImageFile]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0
from typing import Union [EOL] import typing [EOL] import builtins [EOL] from typing import Union [EOL] [EOL] [EOL] class BaseLoader : [EOL] [docstring] [EOL] [EOL] slug = None [EOL] parameter_name = None [EOL] [EOL] def __init__ ( self , arg ) : [EOL] super ( BaseLoader , self ) . __init__ ( ) [EOL] self . arg = arg [EOL] [EOL] @ staticmethod def load_image ( namespace , filename ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] @ staticmethod def get_fileobj ( namespace , filename ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str]$ 0 0 0 $typing.Union[None,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0