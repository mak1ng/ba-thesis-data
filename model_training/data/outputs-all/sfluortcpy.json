import builtins [EOL] import socket [EOL] import struct [EOL] [EOL] from . constants import ETH_P_ARP , ETH_P_IP [EOL] [EOL] [EOL] class EthernetHeader : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , dmac , smac , typ , payload ) : [EOL] [docstring] [EOL] self . dmac = dmac [EOL] self . smac = smac [EOL] self . typ = typ [EOL] self . payload = payload [EOL] [EOL] def encode ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] t = struct . pack ( [string] , socket . htons ( self . typ ) ) [EOL] return self . dmac + self . smac + t + self . payload [EOL] [EOL] @ classmethod def decode ( cls , raw ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dmac = raw [ : [number] ] [EOL] smac = raw [ [number] : [number] ] [EOL] typ = socket . htons ( struct . unpack ( [string] , raw [ [number] : [number] ] ) [ [number] ] ) [EOL] payload = raw [ [number] : ] [EOL] return EthernetHeader ( dmac = dmac , smac = smac , typ = typ , payload = payload ) [EOL] [EOL] def is_arp ( self ) : [EOL] [docstring] [EOL] return self . typ == ETH_P_ARP [EOL] [EOL] def is_ip ( self ) : [EOL] [docstring] [EOL] return self . typ == ETH_P_IP [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $"EthernetHeader"$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
IFF_TUN = [number] [comment] [EOL] IFF_TAP = [number] [comment] [EOL] IFF_NO_PI = [number] [comment] [EOL] IFF_ONE_QUEUE = [number] [comment] [EOL] TUNSETIFF = [number] [EOL] [EOL] ETH_P_ARP = [number] [comment] [EOL] ETH_P_IP = [number] [comment] [EOL] [EOL] ARP_ETHERNET = [number] [EOL] ARP_IPV4 = [number] [EOL] [EOL] ARP_REQUEST = [number] [EOL] ARP_REPLY = [number] [EOL] [EOL] ICMP = [number] [EOL] IPV4 = [number] [EOL] IP_TCP = [number] [EOL] [EOL] ICMP_V4_REPLY = [number] [EOL] ICMP_V4_ECHO = [number] [EOL] [EOL] TCP_FIN = [number] [EOL] TCP_SYN = [number] [EOL] TCP_RST = [number] [EOL] TCP_PSH = [number] [EOL] TCP_ACK = [number] [EOL]	$builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
from typing import Any [EOL] import ip [EOL] import typing [EOL] import builtins [EOL] import socket [EOL] import struct [EOL] [EOL] from . constants import TCP_ACK , TCP_SYN [EOL] from . ip import IPHeader [EOL] from . ip_util import ip_checksum , sum_by_16bits [EOL] [EOL] TCP_HEADER_SIZE = [number] [EOL] [EOL] [EOL] class TCPHeader : [EOL] [EOL] [docstring] [EOL] [EOL] fmt = [string] [EOL] [EOL] def __init__ ( self , src_port , dst_port , seq , ack , hl , flags , win_size , csum , uptr , additional_fields , payload , ) : [EOL] [docstring] [EOL] self . src_port = src_port [EOL] self . dst_port = dst_port [EOL] self . _seq = seq [EOL] self . _ack = ack [EOL] self . _hl = hl [EOL] self . _flags = flags [EOL] self . _win_size = win_size [EOL] self . _csum = csum [EOL] self . _uptr = uptr [EOL] self . _additional_fields = additional_fields [EOL] self . _payload = payload [EOL] [EOL] @ classmethod def decode ( cls , raw ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] ( src_port , dst_port , seq , ack , hl , flags , win_size , csum , uptr ) = struct . unpack ( cls . fmt , raw [ : TCP_HEADER_SIZE ] ) [EOL] hl = hl >> [number] [EOL] additional_fields = raw [ TCP_HEADER_SIZE : [number] * hl ] [EOL] payload = raw [ [number] * hl : ] [EOL] return TCPHeader ( src_port = src_port , dst_port = dst_port , seq = seq , ack = ack , hl = hl , flags = flags , win_size = win_size , csum = csum , uptr = uptr , additional_fields = additional_fields , payload = payload , ) [EOL] [EOL] def encode ( self ) : [EOL] [docstring] [EOL] return ( struct . pack ( TCPHeader . fmt , self . src_port , self . dst_port , self . _seq , self . _ack , self . _hl << [number] , self . _flags , self . _win_size , self . _csum , self . _uptr , ) + self . _additional_fields + self . _payload ) [EOL] [EOL] def adjust_checksum ( self , ip_hdr ) : [EOL] [docstring] [EOL] self . _csum = [number] [EOL] [comment] [EOL] self . _csum = self . checksum ( ip_hdr ) [EOL] [EOL] def checksum ( self , ip_hdr ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] iphdr_fmt = [string] [EOL] [EOL] [comment] [EOL] length = socket . htons ( TCP_HEADER_SIZE + len ( self . _additional_fields ) + len ( self . _payload ) ) [EOL] [EOL] pseudo_hdr = struct . pack ( iphdr_fmt , ip_hdr . daddr , ip_hdr . saddr , [number] , ip_hdr . proto , length , ) [EOL] [EOL] return ip_checksum ( self . encode ( ) , start = sum_by_16bits ( pseudo_hdr ) ) [EOL] [EOL] def reply ( self , ip_hdr ) : [EOL] [docstring] [EOL] [comment] [EOL] self . src_port , self . dst_port = self . dst_port , self . src_port [EOL] [EOL] if self . _flags & TCP_SYN : [EOL] self . _flags |= TCP_ACK [EOL] self . _ack = self . _seq + [number] [EOL] [comment] [EOL] self . _seq = socket . htonl ( [number] ) [EOL] [EOL] [comment] [EOL] self . _hl = [number] [EOL] self . _additional_fields = [string] [EOL] [EOL] self . adjust_checksum ( ip_hdr ) [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 $"TCPHeader"$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $ip.IPHeader$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $ip.IPHeader$ 0 0 0 0 $builtins.int$ 0 0 0 $ip.IPHeader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 $ip.IPHeader$ 0 0 0 $ip.IPHeader$ 0 0 0 0 0 $ip.IPHeader$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $"TCPHeader"$ 0 0 0 $ip.IPHeader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $ip.IPHeader$ 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import tcpy [EOL] import eth [EOL] import multiprocessing [EOL] import ip [EOL] import builtins [EOL] import os [EOL] import socket [EOL] from multiprocessing import Process [EOL] from typing import Optional [EOL] [EOL] from . arp import mac2b [EOL] from . arp_table import ARPTable [EOL] from . constants import ETH_P_IP , ICMP , IP_TCP [EOL] from . eth import EthernetHeader [EOL] from . icmpv4 import ICMPv4Header [EOL] from . ip import IPHeader [EOL] from . tcp import TCPHeader [EOL] from . tuntap import open_tun [EOL] [EOL] [EOL] def to_run ( name ) : [EOL] return f" [string] { name } [string] { name } [string] " [EOL] [EOL] [EOL] class Stack : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ip = [string] , mac = [string] , interf = [string] , ) : [EOL] [docstring] [EOL] [EOL] self . _ip = ip [EOL] self . _mac = mac [EOL] self . _interf = interf [EOL] self . proc = None [EOL] self . fd = [number] [EOL] self . table = ARPTable ( self . _ip , self . _mac ) [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] self . proc = Process ( target = self . start_in_fg ) [EOL] self . proc . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] if self . proc is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . proc . terminate ( ) [EOL] [EOL] def start_in_fg ( self ) : [EOL] [docstring] [EOL] ( self . fd , ( name , mode ) ) = open_tun ( self . _interf ) [EOL] [EOL] print ( [string] . format ( name = name ) ) [EOL] print ( f" [string] { to_run ( name ) }" ) [EOL] [EOL] while True : [EOL] [comment] [EOL] raw = os . read ( self . fd , [number] ) [EOL] [comment] [EOL] eth = EthernetHeader . decode ( raw ) [EOL] [EOL] if eth . is_arp ( ) : [EOL] self . _handle_arp ( eth ) [EOL] elif eth . is_ip ( ) : [EOL] self . _handle_ip ( eth ) [EOL] else : [EOL] print ( f" [string] { eth } [string] { eth . typ }" ) [EOL] [EOL] def _handle_arp ( self , eth ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] resp = self . table . process_arp ( eth ) [EOL] if resp is not None : [EOL] os . write ( self . fd , resp . encode ( ) ) [EOL] [EOL] def _handle_ip ( self , eth ) : [EOL] [docstring] [EOL] ip_hdr = IPHeader . decode ( eth . payload ) [EOL] if ip_hdr . is_icmp ( ) : [EOL] self . _handle_icmp ( eth , ip_hdr ) [EOL] elif ip_hdr . is_tcp ( ) : [EOL] self . _handle_tcp ( eth , ip_hdr ) [EOL] else : [EOL] print ( f" [string] { ip_hdr . proto }" ) [EOL] [EOL] def _handle_icmp ( self , eth , ip_hdr ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] [EOL] icmp_hdr = ICMPv4Header . decode ( ip_hdr . payload ) [EOL] icmp_r = icmp_hdr . reply ( ) [EOL] ip_r = ip_hdr . reply ( self . _ip , icmp_r . encode ( ) , ICMP ) [EOL] [EOL] self . ip_output ( ip_hdr . saddr , ip_r . encode ( ) ) [EOL] [EOL] def _handle_tcp ( self , eth , ip_hdr ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] [EOL] tcp_hdr = TCPHeader . decode ( ip_hdr . payload ) [EOL] tcp_r = tcp_hdr . reply ( ip_hdr ) [EOL] ip_r = ip_hdr . reply ( self . _ip , tcp_r . encode ( ) , IP_TCP ) [EOL] [EOL] self . ip_output ( ip_hdr . saddr , ip_r . encode ( ) ) [EOL] [EOL] def ip_output ( self , daddr , payload ) : [EOL] [docstring] [EOL] resp = self . _build_eth_reply ( ETH_P_IP , daddr , payload ) [EOL] encoded = resp . encode ( ) [EOL] [EOL] [comment] [EOL] os . write ( self . fd , encoded ) [EOL] [EOL] def _build_eth_reply ( self , typ , daddr , payload ) : [EOL] dmac = self . table . get_mac_for_ip ( socket . htonl ( daddr ) ) [EOL] return EthernetHeader ( typ = typ , smac = mac2b ( self . _mac ) , dmac = dmac , payload = payload ) [EOL] [EOL] [EOL] def hex_debug ( raw , desc = [string] ) : [EOL] [docstring] [EOL] hexa = [string] . join ( [ [string] . format ( x ) for x in raw ] ) [EOL] [EOL] print ( f" [string] { desc } [string] { hexa } [string] { [string] * [number] }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[multiprocessing.Process]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $tcpy.arp_table.ARPTable$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Optional[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tcpy.eth.EthernetHeader$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $tcpy.eth.EthernetHeader$ 0 0 0 0 0 0 0 0 0 0 $tcpy.eth.EthernetHeader$ 0 0 0 $tcpy.eth.EthernetHeader$ 0 0 0 0 0 0 0 0 0 0 $tcpy.eth.EthernetHeader$ 0 0 0 0 0 0 0 0 0 0 $tcpy.eth.EthernetHeader$ 0 0 0 $tcpy.eth.EthernetHeader$ 0 0 0 0 0 0 0 $None$ 0 0 0 $eth.EthernetHeader$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[tcpy.eth.EthernetHeader]$ 0 0 0 0 0 0 0 $eth.EthernetHeader$ 0 0 0 $typing.Optional[tcpy.eth.EthernetHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[tcpy.eth.EthernetHeader]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $eth.EthernetHeader$ 0 0 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 0 0 $eth.EthernetHeader$ 0 0 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 0 0 0 0 0 0 0 $eth.EthernetHeader$ 0 $tcpy.ip.IPHeader$ 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 0 0 0 0 0 0 0 $eth.EthernetHeader$ 0 $tcpy.ip.IPHeader$ 0 0 0 0 0 0 0 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 0 0 0 0 $None$ 0 0 0 $eth.EthernetHeader$ 0 $ip.IPHeader$ 0 0 0 0 0 0 0 0 0 0 0 $tcpy.icmpv4.ICMPv4Header$ 0 0 0 0 0 $ip.IPHeader$ 0 0 0 0 $tcpy.icmpv4.ICMPv4Header$ 0 $tcpy.icmpv4.ICMPv4Header$ 0 0 0 0 0 $tcpy.ip.IPHeader$ 0 $ip.IPHeader$ 0 0 0 0 0 0 0 $tcpy.icmpv4.ICMPv4Header$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ip.IPHeader$ 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $eth.EthernetHeader$ 0 $ip.IPHeader$ 0 0 0 0 0 0 0 0 0 0 0 $tcpy.tcp.TCPHeader$ 0 0 0 0 0 $ip.IPHeader$ 0 0 0 0 $tcpy.tcp.TCPHeader$ 0 $tcpy.tcp.TCPHeader$ 0 0 0 $ip.IPHeader$ 0 0 $tcpy.ip.IPHeader$ 0 $ip.IPHeader$ 0 0 0 0 0 0 0 $tcpy.tcp.TCPHeader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ip.IPHeader$ 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 $tcpy.eth.EthernetHeader$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 $builtins.bytes$ 0 $tcpy.eth.EthernetHeader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $eth.EthernetHeader$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tcpy [EOL] import builtins [EOL] import socket [EOL] import struct [EOL] [EOL] from . constants import ICMP_V4_REPLY [EOL] from . ip_util import ip_checksum [EOL] [EOL] [EOL] class ICMPv4Header : [EOL] [EOL] [docstring] [EOL] [EOL] fmt = [string] [EOL] [EOL] def __init__ ( self , typ , code , csum , data ) : [EOL] [docstring] [EOL] [EOL] self . _typ = typ [EOL] self . _code = code [EOL] self . _csum = csum [EOL] self . _data = data [EOL] [EOL] def adjust_checksum ( self ) : [EOL] [docstring] [EOL] self . _csum = [number] [EOL] [comment] [EOL] self . _csum = socket . htons ( ip_checksum ( self . encode ( ) ) ) [EOL] [EOL] def encode ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return ( struct . pack ( ICMPv4Header . fmt , self . _typ , self . _code , self . _csum ) + self . _data ) [EOL] [EOL] @ classmethod def decode ( cls , raw ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] ( typ , code , csum ) = struct . unpack ( cls . fmt , raw [ : [number] ] ) [EOL] icmp = ICMPv4Header ( typ = typ , code = code , csum = csum , data = raw [ [number] : ] ) [EOL] [EOL] [comment] [EOL] computed_csum = ip_checksum ( raw ) [EOL] if computed_csum != [number] : [EOL] raise ValueError ( f" [string] { computed_csum } [string] " ) [EOL] [EOL] return icmp [EOL] [EOL] def reply ( self ) : [EOL] [docstring] [EOL] self . typ = ICMP_V4_REPLY [EOL] self . adjust_checksum ( ) [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ICMPv4Header"$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $tcpy.icmpv4.ICMPv4Header$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $tcpy.icmpv4.ICMPv4Header$ 0 0 0 $"ICMPv4Header"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import socket [EOL] import struct [EOL] [EOL] [EOL] def ip_checksum ( hdr_raw , start = [number] ) : [EOL] [docstring] [EOL] [EOL] csum = start + sum_by_16bits ( hdr_raw ) [EOL] [EOL] while csum >> [number] : [EOL] csum = ( csum & [number] ) + ( csum >> [number] ) [EOL] [EOL] return csum ^ [number] [EOL] [EOL] [EOL] def sum_by_16bits ( raw ) : [EOL] [docstring] [EOL] csum , idx = [number] , [number] [EOL] length = len ( raw ) [EOL] [EOL] while idx + [number] < length : [EOL] csum += struct . unpack ( [string] , raw [ idx : idx + [number] ] ) [ [number] ] [EOL] idx += [number] [EOL] [EOL] if idx < length : [EOL] csum += int ( raw [ idx ] ) [EOL] [EOL] return csum [EOL] [EOL] [EOL] def ip2int ( addr ) : [EOL] [docstring] [EOL] return struct . unpack ( [string] , socket . inet_aton ( addr ) ) [ [number] ] [EOL] [EOL] [EOL] def int2ip ( addr ) : [EOL] [docstring] [EOL] return socket . inet_ntoa ( struct . pack ( [string] , addr ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import typing [EOL] import tcpy [EOL] import builtins [EOL] import socket [EOL] import struct [EOL] [EOL] from . constants import ICMP , IP_TCP , IPV4 [EOL] from . ip_util import ip2int , ip_checksum [EOL] [EOL] [EOL] class IPHeader : [EOL] [EOL] [docstring] [EOL] [EOL] fmt = [string] [EOL] [EOL] def __init__ ( self , version , ihl , tos , len , id , flags , frag_offset , ttl , proto , csum , saddr , daddr , payload , ) : [EOL] [docstring] [EOL] [EOL] self . _version = version [EOL] self . _ihl = ihl [EOL] self . _tos = tos [EOL] self . len = len [EOL] self . id = id [EOL] self . _flags = flags [EOL] self . _frag_offset = frag_offset [EOL] self . _ttl = ttl [EOL] self . proto = proto [EOL] self . _csum = csum [EOL] self . saddr = saddr [EOL] self . daddr = daddr [EOL] self . payload = payload [EOL] [EOL] def is_tcp ( self ) : [EOL] [docstring] [EOL] return self . proto == IP_TCP [EOL] [EOL] def is_icmp ( self ) : [EOL] [docstring] [EOL] return self . proto == ICMP [EOL] [EOL] def adjust_checksum ( self ) : [EOL] [docstring] [EOL] self . _csum = [number] [EOL] [comment] [EOL] self . _csum = socket . htons ( ip_checksum ( self . encode ( ) [ : [number] ] ) ) [EOL] [EOL] def encode ( self ) : [EOL] [docstring] [EOL] version_ihl = self . _version << [number] | self . _ihl [EOL] flags_fragoffset = self . _flags << [number] | self . _frag_offset [EOL] [EOL] raw = struct . pack ( IPHeader . fmt , version_ihl , self . _tos , self . len , self . id , flags_fragoffset , self . _ttl , self . proto , self . _csum , self . saddr , self . daddr , ) [EOL] return raw + self . payload [EOL] [EOL] @ classmethod def decode ( cls , raw ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] fields = struct . unpack ( cls . fmt , raw [ : [number] ] ) [EOL] version_ihl = fields [ [number] ] [EOL] flags_fragoffset = fields [ [number] ] [EOL] vals = [ ( version_ihl & [number] ) >> [number] , version_ihl & [number] , * fields [ [number] : [number] ] , ( flags_fragoffset & [number] ) >> [number] , flags_fragoffset & [number] , * fields [ [number] : ] , raw [ [number] : ] , ] [EOL] ip_hdr = IPHeader ( * vals ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] computed_csum = ip_checksum ( raw [ : [number] ] ) [EOL] if computed_csum != [number] : [EOL] raise ValueError ( f" [string] { computed_csum } [string] " ) [EOL] [EOL] return ip_hdr [EOL] [EOL] def is_supported ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] return self . _version == [number] and self . _ihl >= [number] and self . _ttl != [number] [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __dict__ }" [EOL] [EOL] def reply ( self , src_ip , payload , proto ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] ip_r = IPHeader ( version = IPV4 , ihl = [number] , tos = [number] , len = socket . htons ( len ( payload ) + [number] ) , id = self . id , flags = [number] , frag_offset = socket . htons ( [number] ) , ttl = [number] , proto = proto , csum = [number] , saddr = socket . htonl ( ip2int ( src_ip ) ) , daddr = self . saddr , payload = payload , ) [EOL] ip_r . adjust_checksum ( ) [EOL] [EOL] return ip_r [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $"IPHeader"$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"IPHeader"$ 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $tcpy.ip.IPHeader$ 0 0 0 0 0 0 0 $tcpy.ip.IPHeader$ 0
from typing import Any , Type , Tuple , Callable [EOL] import typing [EOL] import tcpy [EOL] import builtins [EOL] import array [EOL] import socket [EOL] import struct [EOL] from typing import Callable [EOL] [EOL] from . constants import ARP_ETHERNET , ARP_IPV4 , ARP_REPLY , ARP_REQUEST [EOL] [EOL] [EOL] def _check_opcode_fn ( opcode ) : [EOL] def f ( self ) : [EOL] return self . opcode == opcode [EOL] [EOL] return f [EOL] [EOL] [EOL] class ARPHeader : [EOL] [EOL] [docstring] [EOL] [EOL] fmt = [string] [EOL] [EOL] [comment] [EOL] def __init__ ( self , hwtype , protype , hwsize , prosize , opcode , data , ) : [EOL] [docstring] [EOL] [EOL] self . hwtype = hwtype [EOL] self . protype = protype [EOL] self . _hwsize = hwsize [EOL] self . _prosize = prosize [EOL] self . opcode = opcode [EOL] self . _data = data [EOL] [EOL] is_arp_request = _check_opcode_fn ( ARP_REQUEST ) [EOL] is_arp_reply = _check_opcode_fn ( ARP_REPLY ) [EOL] [EOL] def is_supported ( self ) : [EOL] [docstring] [EOL] return self . hwtype == ARP_ETHERNET and self . protype == ARP_IPV4 [EOL] [EOL] def ipv4_data ( self ) : [EOL] [docstring] [EOL] [EOL] if not self . protype == ARP_IPV4 : [EOL] raise ValueError ( [string] ) [EOL] [EOL] return ARPIPv4 . decode ( self . _data ) [EOL] [EOL] def replace_data ( self , data ) : [EOL] [docstring] [EOL] self . _data = data [EOL] [EOL] def encode ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] raw = struct . pack ( ARPHeader . fmt , socket . htons ( self . hwtype ) , socket . htons ( self . protype ) , self . _hwsize , self . _prosize , socket . htons ( self . opcode ) , ) [EOL] [EOL] return raw + self . _data [EOL] [EOL] @ classmethod def decode ( cls , raw ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] arp_hdr = struct . unpack ( cls . fmt , raw [ : [number] ] ) [EOL] hwtype = socket . htons ( arp_hdr [ [number] ] ) [EOL] protype = socket . htons ( arp_hdr [ [number] ] ) [EOL] hwsize = arp_hdr [ [number] ] [EOL] prosize = arp_hdr [ [number] ] [EOL] opcode = socket . htons ( arp_hdr [ [number] ] ) [EOL] return ARPHeader ( hwtype = hwtype , protype = protype , hwsize = hwsize , prosize = prosize , opcode = opcode , data = raw [ [number] : ] , ) [EOL] [EOL] [EOL] class ARPIPv4 : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , smac , sip , dmac , dip ) : [EOL] [docstring] [EOL] [EOL] self . smac = smac [EOL] self . sip = sip [EOL] self . dmac = dmac [EOL] self . dip = dip [EOL] [EOL] def encode ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] return ( self . smac + socket . inet_aton ( self . sip ) + self . dmac + socket . inet_aton ( self . dip ) ) [EOL] [EOL] @ classmethod def decode ( cls , raw ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] smac = raw [ : [number] ] [EOL] dmac = raw [ [number] : [number] ] [EOL] sip = socket . inet_ntoa ( raw [ [number] : [number] ] ) [EOL] dip = socket . inet_ntoa ( raw [ [number] : [number] ] ) [EOL] return ARPIPv4 ( smac = smac , sip = sip , dmac = dmac , dip = dip ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( fmt_mac ( self . smac ) , self . sip , fmt_mac ( self . dmac ) , self . dip ) [EOL] [EOL] [EOL] def fmt_mac ( tup ) : [EOL] [docstring] [EOL] return [string] . format ( * tup ) [EOL] [EOL] [EOL] def mac2b ( addr ) : [EOL] [docstring] [EOL] return array . array ( [string] , [ int ( x , [number] ) for x in addr . split ( [string] ) ] ) . tobytes ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 $typing.Type[tcpy.arp.ARPHeader]$ 0 0 0 0 0 0 $typing.Type[tcpy.arp.ARPHeader]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ARPIPv4"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $"ARPHeader"$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.str$ 0 $builtins.bytes$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ARPIPv4"$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import struct [EOL] from fcntl import ioctl [EOL] from typing import Tuple [EOL] [EOL] from . constants import IFF_NO_PI , IFF_TAP , TUNSETIFF [EOL] [EOL] IFREQ_STRUCT = [string] [EOL] [EOL] [EOL] def open_tun ( interf ) : [EOL] [docstring] [EOL] fd = os . open ( [string] , os . O_RDWR ) [EOL] mode = IFF_TAP | IFF_NO_PI [EOL] ifs = ioctl ( fd , TUNSETIFF , encode_ifreq ( interf , mode ) ) [EOL] return ( fd , decode_ifreq ( ifs ) ) [EOL] [EOL] [EOL] def encode_ifreq ( name , mode ) : [EOL] [docstring] [EOL] return struct . pack ( IFREQ_STRUCT , name . encode ( ) , mode ) [EOL] [EOL] [EOL] def decode_ifreq ( raw ) : [EOL] [docstring] [EOL] tup = struct . unpack ( IFREQ_STRUCT , raw ) [EOL] return ( tup [ [number] ] . strip ( [string] ) . decode ( ) , tup [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . utils import run_cmd_with_stack [EOL] [EOL] [EOL] def test_arping ( ) : [EOL] [comment] [EOL] run_cmd_with_stack ( [ [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import tcpy [EOL] import builtins [EOL] import os [EOL] import subprocess [EOL] from typing import List [EOL] [EOL] from tcpy . stack import Stack [EOL] [EOL] [EOL] def setup_virt_interf ( ) : [EOL] subprocess . check_output ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] subprocess . check_output ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def run_cmd_with_stack ( cmd ) : [EOL] if not os . geteuid ( ) == [number] : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] print ( [string] ) [EOL] s = Stack ( ) [EOL] s . start ( ) [EOL] [EOL] print ( [string] ) [EOL] setup_virt_interf ( ) [EOL] [EOL] [comment] [EOL] subprocess . check_output ( cmd ) [EOL] [EOL] s . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import tcpy [EOL] from tcpy . ip import IPHeader [EOL] from tcpy . tcp import TCPHeader [EOL] [EOL] from . utils import run_cmd_with_stack [EOL] [EOL] [EOL] def test_tcp_handshake ( ) : [EOL] run_cmd_with_stack ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def test_decode_encode_tcp_hdr ( ) : [EOL] raw = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] res = TCPHeader . decode ( bytes ( raw ) ) [EOL] res_dict = res . __dict__ [EOL] expected = TCPHeader ( src_port = [number] , dst_port = [number] , seq = [number] , ack = [number] , hl = [number] , flags = [number] , win_size = [number] , csum = [number] , uptr = [number] , additional_fields = bytes ( raw ) [ [number] : ] , payload = bytes ( [ ] ) , ) . __dict__ [EOL] [EOL] assert len ( res_dict ) == len ( expected ) [EOL] for k , v in res_dict . items ( ) : [EOL] assert v == expected [ k ] [EOL] [EOL] encoded = res . encode ( ) [EOL] assert bytes ( raw ) == encoded [EOL] [EOL] [EOL] def test_tcp_checksum ( ) : [EOL] raw = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] ip_hdr = IPHeader . decode ( bytes ( raw ) ) [EOL] tcp_hdr = TCPHeader . decode ( ip_hdr . payload ) [EOL] [EOL] assert [number] == tcp_hdr . checksum ( ip_hdr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . utils import run_cmd_with_stack [EOL] [EOL] [EOL] def test_arping ( ) : [EOL] [comment] [EOL] run_cmd_with_stack ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from tcpy . ip_util import ip_checksum [EOL] [EOL] [EOL] def test_ip_checksum ( ) : [EOL] hdr = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] assert ip_checksum ( bytes ( hdr ) ) == [number] [EOL] [EOL] [comment] [EOL] hdr2 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] assert ip_checksum ( bytes ( hdr2 ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0