[comment] [EOL] from typing import List , Dict , Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] [EOL] from codecs import open [EOL] [EOL] from setuptools import setup [EOL] [EOL] here = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [comment] [EOL] if sys . argv [ - [number] ] == [string] : [EOL] os . system ( [string] ) [EOL] os . system ( [string] ) [EOL] sys . exit ( ) [EOL] [EOL] packages = [ [string] ] [EOL] [EOL] requires = [ [string] , [string] ] [EOL] [EOL] about = { } [EOL] with open ( os . path . join ( here , [string] , [string] ) , [string] , [string] ) as f : [EOL] exec ( f . read ( ) , about ) [EOL] [EOL] with open ( [string] , [string] , [string] ) as f : [EOL] readme = f . read ( ) [EOL] [EOL] setup ( name = about [ [string] ] , version = about [ [string] ] , description = about [ [string] ] , long_description = readme , long_description_content_type = [string] , author = about [ [string] ] , author_email = about [ [string] ] , url = about [ [string] ] , packages = packages , package_data = { [string] : [ [string] , [string] ] } , package_dir = { [string] : [string] } , include_package_data = True , python_requires = [string] , install_requires = requires , license = about [ [string] ] , zip_safe = False , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , Type , Tuple [EOL] import mew [EOL] import uuid [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] import datetime as dt [EOL] import enum [EOL] import json [EOL] import sys [EOL] import uuid [EOL] from abc import ABC , abstractmethod [EOL] from collections . abc import Collection , Mapping [EOL] from typing import Any , Callable , Dict , List , Union [EOL] from dataclasses import asdict , is_dataclass [EOL] [EOL] import yaml [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] [comment] [EOL] from backports . datetime_fromisoformat import MonkeyPatch [EOL] [EOL] MonkeyPatch . patch_fromisoformat ( ) [EOL] [EOL] [EOL] NoneType = type ( None ) [EOL] SUPPORTED_FORMATS = ( [string] , [string] ) [EOL] [EOL] PRIMITIVE_TYPES = ( str , int , float , bool , type ( None ) ) [EOL] SCALAR_TYPES = ( uuid . UUID , dt . date , dt . datetime , dt . time , * PRIMITIVE_TYPES ) [EOL] [EOL] [EOL] class ScalarTypeSerializer ( ABC ) : [EOL] @ property @ classmethod @ abstractmethod def type ( cls ) : [EOL] ... [EOL] [EOL] @ staticmethod @ abstractmethod def serialize ( obj ) : [EOL] ... [EOL] [EOL] @ staticmethod @ abstractmethod def deserialize ( value ) : [EOL] ... [EOL] [EOL] [EOL] class StringSerializer ( ScalarTypeSerializer ) : [EOL] [EOL] type = str [EOL] [EOL] @ staticmethod def serialize ( obj ) : [EOL] return obj [EOL] [EOL] @ staticmethod def deserialize ( value ) : [EOL] return value [EOL] [EOL] [EOL] class IntSerializer ( ScalarTypeSerializer ) : [EOL] [EOL] type = int [EOL] [EOL] @ staticmethod def serialize ( obj ) : [EOL] return obj [EOL] [EOL] @ staticmethod def deserialize ( value ) : [EOL] return value [EOL] [EOL] [EOL] class FloatSerializer ( ScalarTypeSerializer ) : [EOL] [EOL] type = float [EOL] [EOL] @ staticmethod def serialize ( obj ) : [EOL] return obj [EOL] [EOL] @ staticmethod def deserialize ( value ) : [EOL] return value [EOL] [EOL] [EOL] class BooleanSerializer ( ScalarTypeSerializer ) : [EOL] [EOL] type = bool [EOL] [EOL] @ staticmethod def serialize ( obj ) : [EOL] return obj [EOL] [EOL] @ staticmethod def deserialize ( value ) : [EOL] return value [EOL] [EOL] [EOL] class NoneTypeSerializer : [EOL] [EOL] type = type ( None ) [EOL] [EOL] @ staticmethod def serialize ( obj ) : [EOL] return obj [EOL] [EOL] @ staticmethod def deserialize ( value ) : [EOL] return value [EOL] [EOL] [EOL] class UUIDSerializer ( ScalarTypeSerializer ) : [EOL] type = uuid . UUID [EOL] [EOL] @ staticmethod def serialize ( obj ) : [EOL] [comment] [EOL] return str ( obj ) [EOL] [EOL] @ staticmethod def deserialize ( value ) : [EOL] return uuid . UUID ( value ) [EOL] [EOL] [EOL] class DateTimeSerializer ( ScalarTypeSerializer ) : [EOL] type = dt . datetime [EOL] [EOL] @ staticmethod def serialize ( obj ) : [EOL] [comment] [EOL] return obj . isoformat ( ) [EOL] [EOL] @ staticmethod def deserialize ( value ) : [EOL] return dt . datetime . fromisoformat ( value ) [EOL] [EOL] [EOL] class DateSerializer ( ScalarTypeSerializer ) : [EOL] [EOL] type = dt . date [EOL] [EOL] @ staticmethod def serialize ( obj ) : [EOL] [comment] [EOL] return obj . isoformat ( ) [EOL] [EOL] @ staticmethod def deserialize ( value ) : [EOL] return dt . date . fromisoformat ( value ) [EOL] [EOL] [EOL] class TimeSerializer ( ScalarTypeSerializer ) : [EOL] [EOL] type = dt . time [EOL] [EOL] @ staticmethod def serialize ( obj ) : [EOL] [comment] [EOL] return obj . isoformat ( ) [EOL] [EOL] @ staticmethod def deserialize ( value ) : [EOL] return dt . time . fromisoformat ( value ) [EOL] [EOL] [EOL] class MultiTypeSerializer : [EOL] [EOL] default_serializers = ( StringSerializer , IntSerializer , FloatSerializer , BooleanSerializer , NoneTypeSerializer , UUIDSerializer , DateTimeSerializer , DateSerializer , TimeSerializer , ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . serializers = { serializer . type : serializer for serializer in self . default_serializers } [EOL] [EOL] def serialize ( self , obj , convert_key = lambda x : x ) : [EOL] for t in self . serializers : [EOL] if isinstance ( obj , t ) : [EOL] return self . serializers [ t ] . serialize ( obj ) [EOL] [EOL] [comment] [EOL] if isinstance ( obj , enum . Enum ) : [EOL] return obj . value [EOL] [EOL] [comment] [EOL] if isinstance ( obj , Mapping ) : [EOL] [comment] [EOL] return { convert_key ( k ) : self . serialize ( v , convert_key ) for k , v in obj . items ( ) } [EOL] [EOL] [comment] [EOL] if is_dataclass ( obj ) and not isinstance ( obj , type ) : [EOL] return self . serialize ( asdict ( obj ) , convert_key ) [EOL] [EOL] [comment] [EOL] if isinstance ( obj , Collection ) and not isinstance ( obj , str ) : [EOL] return [ self . serialize ( i , convert_key ) for i in obj ] [EOL] [EOL] [comment] [EOL] return obj [EOL] [EOL] def deserialize ( self , t , value , convert_key = lambda x : x ) : [EOL] if t in self . serializers : [EOL] return self . serializers [ t ] . deserialize ( value ) [EOL] if is_dataclass ( t ) : [EOL] return t ( ** { convert_key ( k ) : self . deserialize ( t . __dataclass_fields__ [ convert_key ( k ) ] . type , v , convert_key ) for k , v in value . items ( ) } ) [EOL] [EOL] if isinstance ( t , type ) : [EOL] if issubclass ( t , enum . Enum ) : [EOL] for item in t : [comment] [EOL] if item . value == value : [EOL] return item [EOL] raise Exception ( f" [string] { t } [string] { value }" ) [EOL] if issubclass ( t , tuple ) : [EOL] return t ( * value ) [EOL] [EOL] [comment] [EOL] if hasattr ( t , [string] ) and hasattr ( t , [string] ) : [EOL] origin = t . __origin__ [EOL] args = t . __args__ [EOL] if origin in ( list , List ) : [EOL] return [ self . deserialize ( args [ [number] ] , item , convert_key ) for item in value ] [EOL] if origin == Union : [EOL] for arg in args : [EOL] try : [EOL] return self . deserialize ( arg , value , convert_key ) [EOL] except TypeError : [EOL] pass [EOL] raise Exception ( f" [string] { t } [string] { value }" ) [EOL] [comment] [EOL] raise Exception ( f" [string] { t } [string] { value }" ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def dumps ( o , * , format = [string] , convert_key = lambda x : x , ** kwargs ) : [EOL] [comment] [EOL] serialized = MultiTypeSerializer ( ) . serialize ( o , convert_key = convert_key ) [EOL] if format == [string] : [EOL] return json . dumps ( serialized , ** kwargs ) [EOL] if format == [string] : [EOL] return yaml . dump ( serialized , ** kwargs ) [EOL] raise ValueError ( f' [string] { [string] . join ( SUPPORTED_FORMATS ) } [string] ' f" [string] { format }" ) [EOL] [EOL] [EOL] def loads ( t , data , format = [string] , convert_key = lambda x : x ) : [EOL] if format == [string] : [EOL] data_asdict = json . loads ( data ) [EOL] elif format == [string] : [EOL] data_asdict = yaml . load ( data ) [EOL] else : [EOL] raise ValueError ( f' [string] { [string] . join ( SUPPORTED_FORMATS ) } [string] ' f" [string] { format }" ) [EOL] [comment] [EOL] return MultiTypeSerializer ( ) . deserialize ( t , data_asdict , convert_key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $NoneType$ 0 $NoneType$ 0 0 0 0 $NoneType$ 0 0 0 0 0 $NoneType$ 0 $NoneType$ 0 0 0 0 $NoneType$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[uuid.UUID]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 $uuid.UUID$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[datetime.date]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.date$ 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[datetime.time]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.time$ 0 0 0 0 0 0 $datetime.time$ 0 0 0 0 0 0 0 0 0 $datetime.time$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[mew.serializer.StringSerializer],typing.Type[mew.serializer.IntSerializer],typing.Type[mew.serializer.FloatSerializer],typing.Type[mew.serializer.BooleanSerializer],typing.Type[mew.serializer.NoneTypeSerializer],typing.Type[mew.serializer.UUIDSerializer],typing.Type[mew.serializer.DateTimeSerializer],typing.Type[mew.serializer.DateSerializer],typing.Type[mew.serializer.TimeSerializer]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.type,ScalarTypeSerializer]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from dataclasses import is_dataclass [EOL] import enum [EOL] import typing [EOL] [EOL] from mew . serializer import dumps , loads , SCALAR_TYPES [EOL] [EOL] [EOL] class NotSupported ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , types , message ) : [EOL] self . types = types [EOL] self . message = message [EOL] [EOL] [EOL] def is_namedtuple ( t ) : [EOL] b = t . __bases__ [EOL] if len ( b ) != [number] or b [ [number] ] != tuple : [EOL] return False [EOL] f = getattr ( t , [string] , None ) [EOL] if not isinstance ( f , tuple ) : [EOL] return False [EOL] return all ( type ( n ) == str for n in f ) [EOL] [EOL] [EOL] def find_unsupported ( t ) : [EOL] if t in SCALAR_TYPES : [EOL] return [ ] [EOL] if isinstance ( t , type ) : [comment] [EOL] if issubclass ( t , enum . Enum ) : [EOL] return [ ] [EOL] if is_dataclass ( t ) : [EOL] return [ v . type for v in t . __dataclass_fields__ . values ( ) if find_unsupported ( v . type ) ] [EOL] if is_namedtuple ( t ) and hasattr ( t , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [ v for v in t . _field_types . values ( ) if find_unsupported ( v ) ] [EOL] if hasattr ( t , [string] ) : [comment] [EOL] origin = t . __origin__ [EOL] if origin == typing . Union : [EOL] return [ arg for arg in t . __args__ if find_unsupported ( arg ) ] [EOL] if origin in ( list , typing . List ) : [comment] [EOL] return find_unsupported ( t . __args__ [ [number] ] ) [EOL] [comment] [EOL] return [ t ] [EOL] [EOL] [EOL] def serializable ( t ) : [EOL] [docstring] [EOL] unsupported_types = find_unsupported ( t ) [EOL] if unsupported_types : [EOL] raise NotSupported ( unsupported_types , f" [string] { unsupported_types }" ) [EOL] t . dumps = dumps [EOL] t . loads = classmethod ( loads ) [EOL] return t [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Pattern [EOL] import typing [EOL] import re [EOL] [EOL] CAP_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] def to_pascal_case ( name ) : [EOL] [docstring] [EOL] return name . title ( ) . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def from_pascal_case ( name ) : [EOL] [docstring] [EOL] return CAP_RE . sub ( [string] , name ) . lower ( ) [EOL] [EOL] [EOL] def to_camel_case ( name ) : [EOL] [docstring] [EOL] output = name . title ( ) . replace ( [string] , [string] ) [EOL] return output [ [number] ] . lower ( ) + output [ [number] : ] [EOL] [EOL] [EOL] def from_camel_case ( name ) : [EOL] [docstring] [EOL] return from_pascal_case ( name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from mew . convert_case import to_pascal_case , from_pascal_case [comment] [EOL] from mew . decorator import serializable , NotSupported [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__title__ = [string] [EOL] __description__ = [string] [EOL] __url__ = [string] [EOL] __version__ = [string] [EOL] __author__ = [string] [EOL] __author_email__ = [string] [EOL] __license__ = [string] [EOL] __copyright__ = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] import datetime as dt [EOL] import re [EOL] [EOL] from mew import __version__ [EOL] [EOL] [EOL] def test_version ( ) : [EOL] [comment] [EOL] assert re . match ( [string] , __version__ . __version__ ) [EOL] [EOL] [EOL] def test_copyright ( ) : [EOL] year = dt . date . today ( ) . year [EOL] assert f" [string] { year } [string] " == __version__ . __copyright__ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pytest [EOL] from mew . convert_case import ( to_pascal_case , from_pascal_case , to_camel_case , from_camel_case , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , ) def test_pascal_and_snake_case_conversion ( pascal , snake ) : [EOL] assert pascal == to_pascal_case ( snake ) [EOL] assert snake == from_pascal_case ( pascal ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , ) def test_camel_and_snake_case_conversion ( camel , snake ) : [EOL] assert camel == to_camel_case ( snake ) [EOL] assert snake == from_camel_case ( camel ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any [EOL] import typing [EOL] import typing [EOL] [EOL] from hypothesis import given [EOL] from hypothesis import strategies as st [EOL] [EOL] from mew . serializer import dumps , loads , StringSerializer , IntSerializer [EOL] [EOL] [EOL] @ given ( st . text ( ) ) def test_string_serializer ( text ) : [EOL] assert StringSerializer . serialize ( text ) == text [EOL] assert StringSerializer . deserialize ( text ) == text [EOL] [EOL] [EOL] @ given ( st . integers ( ) ) def test_int_serializer ( integer ) : [EOL] assert IntSerializer . serialize ( integer ) == integer [EOL] assert IntSerializer . deserialize ( integer ) == integer [EOL] [EOL] [EOL] def test_dumps_yaml ( ) : [EOL] origin = [ [string] , [string] ] [EOL] result = dumps ( origin , format = [string] , default_flow_style = False ) [EOL] assert result == [string] [EOL] assert loads ( typing . List [ str ] , result , format = [string] ) == origin [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0