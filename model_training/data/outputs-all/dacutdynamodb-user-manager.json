[comment] [EOL] import os . path [EOL] from setuptools import setup [EOL] [EOL] project_root = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] with open ( os . path . join ( project_root , [string] ) , encoding = [string] ) as fd : [EOL] readme = fd . read ( ) [EOL] [EOL] setup ( name = [string] , description = [string] , long_description = readme , long_description_content_type = [string] , version = [string] , packages = [ [string] ] , entry_points = { [string] : [ [string] , [string] , ] } , install_requires = [ [string] , [string] , [string] , [string] ] , tests_require = [ [string] , [string] , [string] , [string] , [string] ] , python_requires = [string] , zip_safe = False , author = [string] , author_email = [string] , license = [string] , url = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict , Optional [EOL] from . constants import GID_MIN , GID_MAX , NAME_MAX_LENGTH , NAME_PATTERN [EOL] [EOL] class Entity ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] def __init__ ( self , name , gid , password = None , modified = False ) : [EOL] [docstring] [EOL] super ( Entity , self ) . __init__ ( ) [EOL] self . name = name [EOL] self . gid = gid [EOL] self . password = password [EOL] self . modified = modified [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Entity ) : [EOL] return False [EOL] [EOL] return ( self . name == other . name and self . gid == other . gid and self . password == other . password and self . modified == other . modified ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] if not isinstance ( other , Entity ) : [EOL] return True [EOL] [EOL] return ( self . name != other . name or self . gid != other . gid or self . password != other . password or self . modified != other . modified ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ name . setter def name ( self , value ) : [EOL] if not isinstance ( value , str ) : [EOL] raise TypeError ( [string] ) [EOL] if not value : [EOL] raise ValueError ( [string] ) [EOL] if len ( value ) > NAME_MAX_LENGTH : [EOL] raise ValueError ( f" [string] { NAME_MAX_LENGTH } [string] " ) [EOL] if not NAME_PATTERN . match ( value ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . _name = value [EOL] [EOL] @ property def gid ( self ) : [EOL] [docstring] [EOL] return self . _gid [EOL] [EOL] @ gid . setter def gid ( self , value ) : [EOL] if not isinstance ( value , int ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if not GID_MIN <= value <= GID_MAX : [EOL] raise ValueError ( f" [string] { GID_MIN } [string] { GID_MAX } [string] " f"{ value }" ) [EOL] [EOL] self . _gid = value [EOL] [EOL] @ property def password ( self ) : [EOL] [docstring] [EOL] return self . _password [EOL] [EOL] @ password . setter def password ( self , value ) : [EOL] if value is None : [EOL] self . _password = None [EOL] return [EOL] [EOL] if not isinstance ( value , str ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if not value : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if [string] in value or [string] in value : [EOL] raise TypeError ( [string] ) [EOL] [EOL] self . _password = value [EOL] return [EOL] [EOL] @ property def modified ( self ) : [EOL] [docstring] [EOL] return self . _modified [EOL] [EOL] @ modified . setter def modified ( self , value ) : [EOL] self . _modified = bool ( value ) [EOL] [EOL] def _lt_check_other_type ( self , other ) : [EOL] [docstring] [EOL] if not isinstance ( other , self . __class__ ) : [EOL] raise TypeError ( f" [string] " f"{ type ( self ) . __name__ !r} [string] { type ( other ) . __name__ !r}" ) [EOL] [EOL] def update_from_dynamodb_item ( self , item ) : [EOL] [docstring] [EOL] if self . name != item [ [string] ] [ [string] ] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] gid = int ( item [ [string] ] [ [string] ] ) [EOL] if self . gid != gid : [EOL] self . gid = gid [EOL] self . modified = True [EOL] [EOL] password = item . get ( [string] , { } ) . get ( [string] ) [EOL] if self . password != password : [EOL] self . password = password [EOL] self . modified = True [EOL] [EOL] return self . modified [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0
from typing import Pattern [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import date [EOL] from re import compile as re_compile [EOL] [EOL] EPOCH = date ( year = [number] , month = [number] , day = [number] ) [EOL] [EOL] UID_MIN = [number] [EOL] UID_MAX = [number] [EOL] GID_MIN = [number] [EOL] GID_MAX = [number] [EOL] [EOL] [comment] [EOL] NAME_MAX_LENGTH = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] NAME_PATTERN = re_compile ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] FIELD_PATTERN = re_compile ( [string] ) [EOL] FIELD_FIX = re_compile ( [string] ) [EOL] [EOL] NUMERIC_FIELD_PATTERN = re_compile ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] REAL_NAME_MAX_LENGTH = [number] [EOL] [EOL] LOCK_PASSWD = [number] [EOL] LOCK_GROUP = [number] [EOL] LOCK_GSHADOW = [number] [EOL] LOCK_SHADOW = [number] [EOL] LOCK_ALL = ( LOCK_PASSWD | LOCK_GROUP | LOCK_GSHADOW | LOCK_SHADOW ) [EOL] [EOL] [comment] [EOL] LOGIN_DEFS_PATTERN = re_compile ( [string] ) [EOL] [EOL] [comment] [EOL] LOGIN_DEFS_FILE = [string] [EOL] PASSWD_FILE = [string] [EOL] GROUP_FILE = [string] [EOL] GSHADOW_FILE = [string] [EOL] SHADOW_FILE = [string] [EOL] [EOL] [comment] [EOL] DDBUM_CONFIG_FILENAME = [string] [EOL] KEY_AWS_ACCESS_KEY = [string] [EOL] KEY_AWS_PROFILE = [string] [EOL] KEY_AWS_REGION = [string] [EOL] KEY_AWS_SECRET_KEY = [string] [EOL] KEY_AWS_SESSION_TOKEN = [string] [EOL] KEY_FULL_UPDATE_JITTER = [string] [EOL] KEY_FULL_UPDATE_PERIOD = [string] [EOL] KEY_GROUP_TABLE_NAME = [string] [EOL] KEY_LOGGING = [string] [EOL] KEY_USER_TABLE_NAME = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
	0
from typing import Collection , Dict , Union , Optional , Set , TypeVar , Tuple , List , Any , Type [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [EOL] from functools import total_ordering [EOL] from typing import ( Any , Collection , Dict , List , NamedTuple , Optional , Set , Tuple , Type , TypeVar , Union ) [EOL] [EOL] from . constants import NAME_PATTERN [EOL] from . entity import Entity [EOL] [EOL] class GroupTuple ( NamedTuple ) : [EOL] [docstring] [EOL] name = ... [EOL] gid = ... [EOL] administrators = ... [EOL] members = ... [EOL] password = ... [EOL] modified = ... [EOL] [EOL] G = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] @ total_ordering class Group ( Entity ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] def __init__ ( self , name , gid , administrators = None , members = None , password = None , modified = False ) : [EOL] [docstring] [EOL] super ( Group , self ) . __init__ ( name = name , gid = gid , password = password , modified = modified ) [EOL] self . administrators = administrators [EOL] self . members = members [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Group ) : [EOL] return False [EOL] [EOL] return self . as_tuple == other . as_tuple [EOL] [EOL] def __ne__ ( self , other ) : [EOL] if not isinstance ( other , Group ) : [EOL] return True [EOL] [EOL] return self . as_tuple != other . as_tuple [EOL] [EOL] def __lt__ ( self , other ) : [EOL] self . _lt_check_other_type ( other ) [EOL] return self . as_tuple < other . as_tuple [EOL] [EOL] @ property def administrators ( self ) : [EOL] [docstring] [EOL] return set ( self . _administrators ) [EOL] [EOL] @ administrators . setter def administrators ( self , value ) : [EOL] if value is None : [EOL] self . _administrators = set ( ) [comment] [EOL] return [EOL] [EOL] if ( not isinstance ( value , ( list , set , tuple ) ) or not all ( [ isinstance ( el , str ) for el in value ] ) ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] for username in value : [EOL] if not username : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not NAME_PATTERN . match ( username ) : [EOL] raise ValueError ( f" [string] { username }" ) [EOL] [EOL] self . _administrators = set ( value ) [EOL] return [EOL] [EOL] @ property def members ( self ) : [EOL] [docstring] [EOL] return set ( self . _members ) [EOL] [EOL] @ members . setter def members ( self , value ) : [EOL] if value is None : [EOL] self . _members = set ( ) [comment] [EOL] return [EOL] [EOL] if ( not isinstance ( value , ( list , set , tuple ) ) or not all ( [ isinstance ( el , str ) for el in value ] ) ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] for username in value : [EOL] if not username : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if not NAME_PATTERN . match ( username ) : [EOL] raise ValueError ( f" [string] { username }" ) [EOL] [EOL] self . _members = set ( value ) [EOL] [EOL] def add_member ( self , name ) : [EOL] [docstring] [EOL] if not isinstance ( name , str ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if not NAME_PATTERN . match ( name ) : [EOL] raise ValueError ( f" [string] { name }" ) [EOL] [EOL] self . _members . add ( name ) [EOL] [EOL] def remove_member ( self , name ) : [EOL] [docstring] [EOL] self . _members . remove ( name ) [EOL] [EOL] @ property def as_tuple ( self ) : [EOL] [docstring] [EOL] return GroupTuple ( name = self . name , gid = self . gid , administrators = self . administrators , members = self . members , password = self . password , modified = self . modified , ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return repr ( self . as_tuple ) [EOL] [EOL] def update_from_dynamodb_item ( self , item ) : [EOL] [docstring] [EOL] super ( Group , self ) . update_from_dynamodb_item ( item ) [EOL] [EOL] administrators = set ( item . get ( [string] , { } ) . get ( [string] , [ ] ) ) [EOL] if self . administrators != administrators : [EOL] self . administrators = administrators [EOL] self . modified = True [EOL] [EOL] members = set ( item . get ( [string] , { } ) . get ( [string] , [ ] ) ) [EOL] if self . members != members : [EOL] self . members = members [EOL] self . modified = True [EOL] [EOL] return self . modified [EOL] [EOL] @ classmethod def from_dynamodb_item ( cls , item ) : [EOL] [docstring] [EOL] return cls ( name = item [ [string] ] [ [string] ] , gid = int ( item [ [string] ] [ [string] ] ) , password = item . get ( [string] , { } ) . get ( [string] ) , administrators = set ( item . get ( [string] , { } ) . get ( [string] , [ ] ) ) , members = set ( item . get ( [string] , { } ) . get ( [string] , [ ] ) ) , modified = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $"Group"$ 0 0 0 0 0 0 0 $"Group"$ 0 0 0 0 0 0 0 $"Group"$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]]$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $GroupTuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 $typing.Union[None,typing.List[builtins.str],typing.Set[builtins.str],typing.Tuple[builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $G$ 0 $typing.Type[G]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Type[G]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0