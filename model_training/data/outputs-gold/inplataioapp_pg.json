from typing import Dict , Union , Type , Any [EOL] import aioapp [EOL] import asyncio [EOL] import examples [EOL] import typing [EOL] import os [EOL] import time [EOL] import logging [EOL] import asyncio [EOL] from functools import partial [EOL] from aioapp . app import Application [EOL] from aioapp import config [EOL] from aioapp . tracer import Span [EOL] from aioapp_pg import Postgres [EOL] [EOL] [EOL] class Config ( config . Config ) : [EOL] db_url = ... [EOL] _vars = { [string] : { [string] : str , [string] : [string] , [string] : [string] [string] } } [EOL] [EOL] [EOL] async def do_something ( app , ctx ) : [EOL] [docstring] [EOL] res = await app . db . query_one ( ctx , [string] , [string] , time . time ( ) ) [EOL] print ( [string] , res [ [string] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] [EOL] cfg = Config ( os . environ ) [EOL] [EOL] app = Application ( loop = loop ) [EOL] app . add ( [string] , Postgres ( url = cfg . db_url , pool_min_size = [number] , pool_max_size = [number] , pool_max_queries = [number] , pool_max_inactive_connection_lifetime = [number] , connect_max_attempts = [number] , connect_retry_delay = [number] ) , stop_after = [ ] ) [EOL] app . on_start = partial ( do_something , app ) [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Type[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 $examples.pg.Config$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 $asyncio.events.AbstractEventLoop$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $examples.pg.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0
from typing import Any [EOL] import aioapp_pg [EOL] import builtins [EOL] import aioapp [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] from aioapp . app import Application [EOL] from aioapp_pg import Postgres , PostgresTracerConfig [EOL] from aioapp . error import PrepareError [EOL] import pytest [EOL] import string [EOL] from aioapp . misc import rndstr [EOL] from aioapp . tracer import Span [EOL] from aioapp . misc import async_call [EOL] [EOL] [EOL] async def _start_postgres ( app , url , connect_max_attempts = [number] , connect_retry_delay = [number] ) : [EOL] db = Postgres ( url , connect_max_attempts = connect_max_attempts , connect_retry_delay = connect_retry_delay ) [EOL] app . add ( [string] , db ) [EOL] await app . run_prepare ( ) [EOL] await db . start ( ) [EOL] return db [EOL] [EOL] [EOL] def _create_span ( app ) : [EOL] if app . tracer : [EOL] return app . tracer . new_trace ( sampled = False , debug = False ) [EOL] [EOL] [EOL] async def test_postgres ( app , postgres ) : [EOL] table_name = [string] + rndstr ( [number] , string . ascii_lowercase + string . digits ) [EOL] db = await _start_postgres ( app , postgres ) [EOL] span = _create_span ( app ) [EOL] [EOL] res = await db . execute ( span , [string] , [string] , [number] , timeout = [number] , tracer_config = PostgresTracerConfig ( ) ) [EOL] assert res is not None [EOL] [EOL] res = await db . query_one ( span , [string] , [string] , [number] , { } , { } , timeout = [number] ) [EOL] assert res is not None [EOL] assert len ( res ) == [number] [EOL] assert res [ [number] ] == [number] [EOL] assert res [ [number] ] == { } [EOL] assert res [ [number] ] == { } [EOL] assert res [ [string] ] == [number] [EOL] [EOL] res = await db . query_one ( span , [string] , [string] , [number] , timeout = [number] ) [EOL] assert res is None [EOL] [EOL] res = await db . query_all ( span , [string] , [string] , [number] , [number] , timeout = [number] ) [EOL] assert res is not None [EOL] assert len ( res ) == [number] [EOL] assert res [ [number] ] [ [number] ] == [number] [EOL] assert res [ [number] ] [ [number] ] == [number] [EOL] assert res [ [number] ] [ [string] ] == [number] [EOL] assert res [ [number] ] [ [string] ] == [number] [EOL] [EOL] res = await db . query_all ( span , [string] , [string] , [number] , timeout = [number] ) [EOL] assert res is not None [EOL] assert len ( res ) == [number] [EOL] [EOL] async with db . connection ( span ) as conn : [EOL] async with conn . xact ( span ) : [EOL] await conn . execute ( span , [string] , [string] % table_name ) [EOL] await conn . execute ( span , [string] , [string] % table_name ) [EOL] [EOL] res = await db . query_one ( span , [string] , [string] % table_name , timeout = [number] ) [EOL] assert res [ [number] ] == [number] [EOL] [EOL] try : [EOL] async with db . connection ( span ) as conn : [EOL] async with conn . xact ( span , isolation_level = [string] ) : [EOL] await conn . execute ( span , [string] , [string] % table_name ) [EOL] raise UserWarning ( ) [EOL] except UserWarning : [EOL] pass [EOL] [EOL] res = await db . query_one ( span , [string] , [string] % table_name , timeout = [number] ) [EOL] [EOL] async with db . connection ( span ) as conn : [EOL] stmt = await conn . prepare ( span , [string] , [string] ) [EOL] assert ( await stmt . fetchrow ( [number] ) ) [ [number] ] == [number] [EOL] assert ( await stmt . fetchrow ( [number] ) ) [ [number] ] == [number] [EOL] [EOL] assert res [ [number] ] == [number] [EOL] [EOL] [EOL] async def test_postgres_prepare_failure ( app , unused_tcp_port ) : [EOL] with pytest . raises ( PrepareError ) : [EOL] await _start_postgres ( app , [string] [string] % ( [string] , unused_tcp_port ) , connect_max_attempts = [number] , connect_retry_delay = [number] ) [EOL] [EOL] [EOL] async def test_postgres_health_bad ( app , unused_tcp_port , loop ) : [EOL] url = [string] % ( [string] , unused_tcp_port ) [EOL] [EOL] db = Postgres ( url ) [EOL] app . add ( [string] , db ) [EOL] [EOL] async def start ( ) : [EOL] await app . run_prepare ( ) [EOL] await db . start ( ) [EOL] [EOL] res = async_call ( loop , start ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] result = await app . health ( ) [EOL] assert [string] in result [EOL] assert result [ [string] ] is not None [EOL] assert isinstance ( result [ [string] ] , BaseException ) [EOL] [EOL] if res [ [string] ] is not None : [EOL] res [ [string] ] . cancel ( ) [EOL] [EOL] [EOL] async def test_postgres_health_ok ( app , postgres , loop ) : [EOL] db = Postgres ( postgres ) [EOL] app . add ( [string] , db ) [EOL] [EOL] async def start ( ) : [EOL] await app . run_prepare ( ) [EOL] await db . start ( ) [EOL] [EOL] res = async_call ( loop , start ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] result = await app . health ( ) [EOL] assert [string] in result [EOL] assert result [ [string] ] is None [EOL] [EOL] if res [ [string] ] is not None : [EOL] res [ [string] ] . cancel ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioapp_pg.Postgres$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioapp.tracer.Span$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0