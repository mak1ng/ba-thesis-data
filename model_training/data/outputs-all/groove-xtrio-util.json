[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List [EOL] import typing [EOL] import os [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] from trio_util import __version__ as version [EOL] release = version [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] autodoc_member_order = [string] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import trio_util [EOL] import typing [EOL] from functools import partial [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] import trio [EOL] from trio . testing import assert_checkpoints , wait_all_tasks_blocked [EOL] [EOL] from trio_util import AsyncValue , compose_values [EOL] from trio_util . _async_value import _ValueWrapper [EOL] [EOL] [EOL] async def test_value_event ( nursery ) : [EOL] async def waiter ( event ) : [EOL] [comment] [EOL] assert event . value == [number] [EOL] with assert_checkpoints ( ) : [EOL] assert await event . wait_value ( lambda x : x == [number] ) == [number] [EOL] print ( [string] ) [EOL] assert await event . wait_value ( lambda x : x > [number] ) == [number] [EOL] print ( [string] ) [EOL] [comment] [EOL] assert await event . wait_transition ( ) == ( [number] , [number] ) [EOL] print ( [string] ) [EOL] assert await event . wait_transition ( lambda val , old : val is None and old is not None ) == ( None , [number] ) [EOL] print ( [string] ) [EOL] assert await event . wait_value ( lambda x : x > [number] ) == [number] [EOL] await wait_all_tasks_blocked ( ) [EOL] assert event . value == [number] [EOL] print ( [string] ) [EOL] [EOL] foo = AsyncValue ( [number] ) [EOL] assert foo . value == [number] [EOL] foo . value = [number] [EOL] assert foo . value == [number] [EOL] [EOL] [comment] [EOL] nursery . start_soon ( waiter , foo ) [EOL] await wait_all_tasks_blocked ( ) [EOL] [comment] [EOL] foo . value = [number] [EOL] await wait_all_tasks_blocked ( ) [EOL] [comment] [EOL] foo . value = [number] [EOL] await wait_all_tasks_blocked ( ) [EOL] [comment] [EOL] [comment] [EOL] foo . value = None [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] foo . value = [number] [EOL] foo . value = [number] [EOL] await wait_all_tasks_blocked ( ) [EOL] [EOL] [EOL] async def test_wait_value_held_for ( nursery , autojump_clock ) : [EOL] test1_done = trio . Event ( ) [EOL] test2_done = trio . Event ( ) [EOL] [EOL] async def listener ( event ) : [EOL] assert event . value == [number] [comment] [EOL] t0 = trio . current_time ( ) [EOL] assert await event . wait_value ( lambda x : x == [number] , held_for = [number] ) == [number] [EOL] assert trio . current_time ( ) - t0 == [number] [EOL] test1_done . set ( ) [EOL] [EOL] assert event . value < [number] [comment] [EOL] t0 = trio . current_time ( ) [EOL] assert await event . wait_value ( lambda x : x >= [number] , held_for = [number] ) == [number] [EOL] assert trio . current_time ( ) - t0 == [number] [EOL] test2_done . set ( ) [EOL] [EOL] x = AsyncValue ( [number] ) [EOL] nursery . start_soon ( listener , x ) [EOL] await test1_done . wait ( ) [EOL] [EOL] x . value = [number] [EOL] await trio . sleep ( [number] ) [EOL] x . value = [number] [EOL] await trio . sleep ( [number] ) [EOL] x . value = [number] [EOL] await test2_done . wait ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( AsyncValue . wait_value , False ) , ( partial ( AsyncValue . wait_value , held_for = [number] ) , True ) , ( AsyncValue . wait_transition , False ) , ] ) async def test_predicate_eval_scope ( wait_function , predicate_return , nursery ) : [EOL] [comment] [EOL] x = AsyncValue ( [number] ) [EOL] predicate = Mock ( return_value = predicate_return ) [EOL] cancel_scope = trio . CancelScope ( ) [EOL] [EOL] @ nursery . start_soon async def _wait ( ) : [EOL] with cancel_scope : [EOL] await wait_function ( x , predicate ) [EOL] [EOL] await wait_all_tasks_blocked ( ) [EOL] predicate_call_count = predicate . call_count [EOL] cancel_scope . cancel ( ) [EOL] await wait_all_tasks_blocked ( ) [EOL] x . value = [number] [EOL] assert predicate . call_count == predicate_call_count [EOL] [EOL] [EOL] async def test_wait_value_by_value ( nursery ) : [EOL] done = trio . Event ( ) [EOL] [EOL] async def listener ( event ) : [EOL] assert event . value == [number] [EOL] assert await event . wait_value ( [number] ) == [number] [EOL] assert await event . wait_value ( [number] ) == [number] [EOL] done . set ( ) [EOL] [EOL] x = AsyncValue ( [number] ) [EOL] nursery . start_soon ( listener , x ) [EOL] await wait_all_tasks_blocked ( ) [EOL] x . value = [number] [EOL] await done . wait ( ) [EOL] [EOL] [EOL] async def test_wait_transition_by_value ( nursery ) : [EOL] done = trio . Event ( ) [EOL] [EOL] async def listener ( event ) : [EOL] assert event . value == [number] [EOL] assert await event . wait_transition ( [number] ) == ( [number] , [number] ) [EOL] done . set ( ) [EOL] [EOL] x = AsyncValue ( [number] ) [EOL] nursery . start_soon ( listener , x ) [EOL] await wait_all_tasks_blocked ( ) [EOL] assert not done . is_set ( ) [EOL] x . value = [number] [EOL] x . value = [number] [EOL] await done . wait ( ) [EOL] [EOL] [EOL] def _always_false ( val ) : [EOL] return False [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [ ] ) , ( [string] , [string] , [ _ValueWrapper ] ) , ( False , True , [ _ValueWrapper ] ) , ( None , { } , [ _ValueWrapper , _ValueWrapper ] ) , ( None , _always_false , [ type ( _always_false ) ] ) , ] ) async def test_wait_queue ( initial_val , wait_val , expected_queue_key_types , nursery ) : [EOL] [comment] [EOL] [EOL] async def listener ( event ) : [EOL] assert event . value == initial_val [EOL] await event . wait_value ( wait_val ) [EOL] [EOL] x = AsyncValue ( initial_val ) [EOL] nursery . start_soon ( listener , x ) [EOL] nursery . start_soon ( listener , x ) [EOL] await wait_all_tasks_blocked ( ) [EOL] assert [ type ( val ) for val in x . _level_results ] == expected_queue_key_types [EOL] [EOL] [EOL] async def test_compose_values ( nursery ) : [EOL] async_x = AsyncValue ( [number] ) [EOL] async_y = AsyncValue ( [number] ) [EOL] done = trio . Event ( ) [EOL] [EOL] @ nursery . start_soon async def _wait ( ) : [EOL] async with compose_values ( x = async_x , y = async_y ) as composite : [EOL] assert ( composite . value . x , composite . value . y ) == ( [number] , [number] ) [EOL] assert await composite . wait_value ( lambda val : val . x < [number] < val . y ) == ( - [number] , [number] ) [EOL] done . set ( ) [EOL] [EOL] await wait_all_tasks_blocked ( ) [EOL] async_x . value = - [number] [EOL] await wait_all_tasks_blocked ( ) [EOL] async_x . value = [number] [EOL] async_y . value = [number] [EOL] await wait_all_tasks_blocked ( ) [EOL] async_y . value = [number] [EOL] async_x . value = - [number] [comment] [EOL] await done . wait ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ compose_values , partial ( compose_values , AsyncValue ( [number] ) ) , partial ( compose_values , x = [number] ) , ] ) async def test_compose_values_wrong_usage ( context ) : [EOL] with pytest . raises ( TypeError ) : [EOL] async with context ( ) : [EOL] pass [EOL] [EOL] [EOL] async def test_compose_values_nested ( nursery ) : [EOL] async_x , async_y = AsyncValue ( [number] ) , AsyncValue ( [number] ) [EOL] async_text = AsyncValue ( [string] ) [EOL] done = trio . Event ( ) [EOL] [EOL] @ nursery . start_soon async def _wait ( ) : [EOL] async with compose_values ( x = async_x , y = async_y ) as async_xy , compose_values ( xy = async_xy , text = async_text ) as composite : [EOL] assert composite . value == ( ( [number] , [number] ) , [string] ) [EOL] assert await composite . wait_value ( lambda val : val . xy . x < [number] < val . xy . y and val . text == [string] ) == ( ( - [number] , [number] ) , [string] ) [EOL] done . set ( ) [EOL] [EOL] await wait_all_tasks_blocked ( ) [EOL] async_x . value = - [number] [EOL] async_y . value = [number] [EOL] await wait_all_tasks_blocked ( ) [EOL] async_text . value = [string] [EOL] await wait_all_tasks_blocked ( ) [EOL] await done . wait ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from functools import partial [EOL] [EOL] import trio [EOL] [EOL] from trio_util import wait_all , wait_any [EOL] [EOL] [EOL] async def test_all ( nursery , autojump_clock ) : [EOL] count = [number] [EOL] [EOL] async def foo ( duration ) : [EOL] await trio . sleep ( duration ) [EOL] nonlocal count [EOL] count += [number] [EOL] [EOL] await wait_all ( partial ( foo , [number] ) , partial ( foo , [number] ) ) [EOL] assert count == [number] [EOL] [EOL] [EOL] async def test_any ( nursery , autojump_clock ) : [EOL] count = [number] [EOL] [EOL] async def foo ( duration ) : [EOL] await trio . sleep ( duration ) [EOL] nonlocal count [EOL] count += [number] [EOL] [EOL] await wait_any ( partial ( foo , [number] ) , partial ( foo , [number] ) ) [EOL] assert count == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import trio [EOL] from trio_util import AsyncDictionary [EOL] [EOL] async def test_async_dictionary ( nursery , autojump_clock ) : [EOL] async def reader ( d ) : [EOL] assert await d . get_wait ( [string] ) == [number] [EOL] assert [string] in d [EOL] assert await d . pop_wait ( [string] ) == [string] [EOL] assert [string] not in d [EOL] with trio . move_on_after ( [number] ) : [EOL] await d . get_wait ( [string] ) [EOL] assert False [EOL] [EOL] async def writer ( d ) : [EOL] await trio . sleep ( [number] ) [EOL] assert d . is_waiting ( [string] ) [EOL] d [ [string] ] = [number] [EOL] await trio . sleep ( [number] ) [EOL] assert d . is_waiting ( [string] ) [EOL] d [ [string] ] = [string] [EOL] [EOL] d = AsyncDictionary ( foo = [number] ) [EOL] assert len ( d ) == [number] [EOL] assert [string] in d [EOL] assert list ( d ) == [ [string] ] [EOL] assert await d . get_wait ( [string] ) == [number] [EOL] assert not d . is_waiting ( [string] ) [EOL] del d [ [string] ] [EOL] assert not d [EOL] nursery . start_soon ( reader , d ) [EOL] nursery . start_soon ( writer , d ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from trio_util import AsyncBool [EOL] [EOL] [EOL] async def test_bool_event ( ) : [EOL] event = AsyncBool ( ) [EOL] assert event . value is False [EOL] await event . wait_value ( False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Iterator , Any [EOL] import typing [EOL] from itertools import zip_longest [EOL] [EOL] import trio [EOL] [EOL] from trio_util import azip , azip_longest [EOL] [EOL] [EOL] async def periodic_iter ( it ) : [EOL] for x in it : [EOL] yield x [EOL] await trio . sleep ( [number] ) [EOL] [EOL] [EOL] async def test_azip ( autojump_clock ) : [EOL] t0 = trio . current_time ( ) [EOL] expected = zip ( range ( [number] ) , range ( [number] ) , range ( [number] ) ) [EOL] async for item in azip ( periodic_iter ( range ( [number] ) ) , periodic_iter ( range ( [number] ) ) , periodic_iter ( range ( [number] ) ) ) : [EOL] assert item == next ( expected ) [EOL] assert trio . current_time ( ) - t0 == [number] [EOL] [EOL] [EOL] async def test_azip_longest ( autojump_clock ) : [EOL] t0 = trio . current_time ( ) [EOL] expected = zip_longest ( range ( [number] ) , range ( [number] ) , fillvalue = - [number] ) [EOL] async for item in azip_longest ( periodic_iter ( range ( [number] ) ) , periodic_iter ( range ( [number] ) ) , fillvalue = - [number] ) : [EOL] assert item == next ( expected ) [EOL] assert trio . current_time ( ) - t0 == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] import trio [EOL] [EOL] from trio_util import defer_to_cancelled , multi_error_defer_to [EOL] [EOL] [EOL] def _cancelled ( ) : [EOL] return trio . Cancelled . _create ( ) [EOL] [EOL] [EOL] class MyExceptionBase ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class MyException ( MyExceptionBase ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( defer_to_cancelled ( ValueError ) , ValueError , ValueError ) , ( defer_to_cancelled ( ValueError ) , trio . MultiError ( [ _cancelled ( ) , ValueError ( ) ] ) , trio . Cancelled ) , ( defer_to_cancelled ( ValueError , KeyError ) , trio . MultiError ( [ _cancelled ( ) , ValueError ( ) , KeyError ( ) ] ) , trio . Cancelled ) , ( defer_to_cancelled ( ValueError ) , trio . MultiError ( [ ValueError ( ) , trio . MultiError ( [ _cancelled ( ) , _cancelled ( ) ] ) ] ) , trio . Cancelled ) , ( defer_to_cancelled ( ValueError ) , trio . MultiError ( [ _cancelled ( ) , KeyError ( ) ] ) , trio . MultiError ) , ] ) async def test_defer_to_cancelled ( context , to_raise , expected_exception ) : [EOL] with pytest . raises ( expected_exception ) : [EOL] with context : [EOL] raise to_raise [EOL] [EOL] [EOL] async def test_defer_to_cancelled_simple_cancel ( ) : [EOL] with trio . move_on_after ( [number] ) as cancel_scope : [EOL] with defer_to_cancelled ( ValueError ) : [EOL] cancel_scope . cancel ( ) [EOL] await trio . sleep ( [number] ) [EOL] [EOL] [EOL] async def test_defer_to_cancelled_decorating_async ( ) : [EOL] @ defer_to_cancelled ( ValueError ) async def foo ( ) : [EOL] raise trio . MultiError ( [ _cancelled ( ) , ValueError ( ) ] ) [EOL] [EOL] with pytest . raises ( trio . Cancelled ) : [EOL] await foo ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( multi_error_defer_to ( trio . Cancelled , ValueError ) , ValueError , ValueError ) , ( multi_error_defer_to ( trio . Cancelled , ValueError ) , trio . MultiError ( [ _cancelled ( ) , ValueError ( ) ] ) , trio . Cancelled ) , ( multi_error_defer_to ( trio . Cancelled , ValueError ) , trio . MultiError ( [ ValueError ( ) , trio . MultiError ( [ _cancelled ( ) , _cancelled ( ) ] ) ] ) , trio . Cancelled ) , ( multi_error_defer_to ( MyExceptionBase , trio . Cancelled ) , trio . MultiError ( [ _cancelled ( ) , MyException ( ) ] ) , MyException ) , ( multi_error_defer_to ( ValueError , trio . Cancelled ) , trio . MultiError ( [ ValueError ( ) , ValueError ( ) , _cancelled ( ) ] ) , ValueError ) , ( multi_error_defer_to ( ValueError , trio . Cancelled ) , trio . MultiError ( [ ValueError ( [string] ) , ValueError ( [string] ) , _cancelled ( ) ] ) , trio . MultiError ) , ( multi_error_defer_to ( ValueError , trio . Cancelled , propagate_multi_error = False ) , trio . MultiError ( [ ValueError ( [string] ) , ValueError ( [string] ) , _cancelled ( ) ] ) , RuntimeError ) , ( multi_error_defer_to ( ValueError , trio . Cancelled , strict = False ) , trio . MultiError ( [ ValueError ( [string] ) , ValueError ( [string] ) , _cancelled ( ) ] ) , ValueError ) , ( multi_error_defer_to ( trio . Cancelled , ValueError ) , trio . MultiError ( [ _cancelled ( ) , KeyError ( ) ] ) , trio . MultiError ) , ( multi_error_defer_to ( trio . Cancelled , ValueError , propagate_multi_error = False ) , trio . MultiError ( [ _cancelled ( ) , KeyError ( ) ] ) , RuntimeError ) , ] ) async def test_multi_error_defer_to ( context , to_raise , expected_exception ) : [EOL] with pytest . raises ( expected_exception ) : [EOL] with context : [EOL] raise to_raise [EOL] [EOL] [EOL] async def test_multi_error_defer_simple_cancel ( ) : [EOL] with trio . move_on_after ( [number] ) as cancel_scope : [EOL] with multi_error_defer_to ( trio . Cancelled , ValueError ) : [EOL] cancel_scope . cancel ( ) [EOL] await trio . sleep ( [number] ) [EOL] [EOL] [EOL] async def test_multi_error_defer_decorating_async ( ) : [EOL] @ multi_error_defer_to ( trio . Cancelled , ValueError ) async def foo ( ) : [EOL] raise trio . MultiError ( [ _cancelled ( ) , ValueError ( ) ] ) [EOL] [EOL] with pytest . raises ( trio . Cancelled ) : [EOL] await foo ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] import trio [EOL] from trio . testing import wait_all_tasks_blocked [EOL] [EOL] from trio_util import UnqueuedRepeatedEvent , MailboxRepeatedEvent [EOL] [EOL] [EOL] async def test_unqueued_repeated_event ( nursery , autojump_clock ) : [EOL] event = UnqueuedRepeatedEvent ( ) [EOL] count = [number] [EOL] [EOL] [comment] [EOL] event . set ( ) [EOL] [EOL] @ nursery . start_soon async def _listener ( ) : [EOL] async for _ in event : [EOL] nonlocal count [EOL] count += [number] [EOL] await trio . sleep ( [number] ) [EOL] [EOL] await wait_all_tasks_blocked ( ) [EOL] assert count == [number] [EOL] [EOL] event . set ( ) [EOL] await wait_all_tasks_blocked ( ) [EOL] assert count == [number] [EOL] [EOL] [comment] [EOL] event . set ( ) [EOL] await wait_all_tasks_blocked ( ) [EOL] assert count == [number] [EOL] [EOL] await trio . sleep ( [number] ) [EOL] event . set ( ) [EOL] await wait_all_tasks_blocked ( ) [EOL] assert count == [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) : [EOL] async for _ in event : [EOL] pass [EOL] [EOL] [EOL] async def test_mailbox_repeated_event ( nursery , autojump_clock ) : [EOL] event = MailboxRepeatedEvent ( ) [EOL] count = [number] [EOL] [EOL] [comment] [EOL] event . set ( ) [EOL] [EOL] @ nursery . start_soon async def _listener ( ) : [EOL] async for _ in event : [EOL] nonlocal count [EOL] count += [number] [EOL] await trio . sleep ( [number] ) [EOL] [EOL] await wait_all_tasks_blocked ( ) [EOL] assert count == [number] [EOL] [EOL] [comment] [EOL] event . set ( ) [EOL] await wait_all_tasks_blocked ( ) [EOL] assert count == [number] [EOL] await trio . sleep ( [number] ) [EOL] assert count == [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) : [EOL] async for _ in event : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] import pytest [EOL] import trio [EOL] [EOL] from trio_util import TaskStats [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None , time . process_time ] ) def test_trio_timer ( time_func , autojump_clock ) : [EOL] async def run ( ) : [EOL] await trio . sleep ( [number] ) [EOL] async with trio . open_nursery ( ) as nursery : [EOL] nursery . start_soon ( trio . sleep , [number] ) [EOL] nursery . start_soon ( trio . sleep , [number] ) [EOL] [EOL] trio . run ( run , clock = autojump_clock , instruments = [ TaskStats ( time_func ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import trio [EOL] [EOL] from trio_util import periodic [EOL] [EOL] async def test_periodic ( autojump_clock ) : [EOL] count = [number] [EOL] t0 = trio . current_time ( ) [EOL] async for elapsed , dt in periodic ( [number] ) : [EOL] assert elapsed == count * [number] [EOL] assert dt == ( [number] if count != [number] else None ) [EOL] if count == [number] : [EOL] break [EOL] await trio . sleep ( [number] ) [EOL] count += [number] [EOL] total_elapsed = trio . current_time ( ) - t0 [EOL] assert total_elapsed == [number] [EOL] [EOL] async def test_periodic_overrun ( autojump_clock ) : [EOL] count = [number] [EOL] t0 = trio . current_time ( ) [EOL] async for elapsed , dt in periodic ( [number] ) : [EOL] assert elapsed == count * [number] [EOL] assert dt == ( [number] if count != [number] else None ) [EOL] if count == [number] : [EOL] break [EOL] await trio . sleep ( [number] ) [EOL] count += [number] [EOL] total_elapsed = trio . current_time ( ) - t0 [EOL] [comment] [EOL] [comment] [EOL] assert total_elapsed == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] import trio [EOL] [EOL] [EOL] async def _azip ( * aiterables , fillvalue , stop_any ) : [EOL] iters = [ item . __aiter__ ( ) for item in aiterables ] [EOL] while True : [EOL] stop_count = [number] [EOL] items = [ fillvalue ] * len ( iters ) [EOL] [EOL] async def collect ( i , iterator ) : [EOL] try : [EOL] items [ i ] = await iterator . __anext__ ( ) [EOL] except StopAsyncIteration : [EOL] nonlocal stop_count [EOL] stop_count += [number] [comment] [EOL] [EOL] async with trio . open_nursery ( ) as nursery : [EOL] for i , iterator in enumerate ( iters ) : [EOL] nursery . start_soon ( collect , i , iterator ) [EOL] [EOL] if stop_count >= ( [number] if stop_any else len ( iters ) ) : [EOL] break [EOL] yield tuple ( items ) [EOL] [EOL] [EOL] def azip ( * aiterables ) : [EOL] [docstring] [EOL] return _azip ( * aiterables , fillvalue = None , stop_any = True ) [EOL] [EOL] [EOL] def azip_longest ( * aiterables , fillvalue = None ) : [EOL] [docstring] [EOL] return _azip ( * aiterables , fillvalue = fillvalue , stop_any = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import trio [EOL] [EOL] [EOL] async def _wait_and_call ( f1 , f2 ) : [EOL] [docstring] [EOL] await f1 ( ) [EOL] f2 ( ) [EOL] [EOL] [EOL] async def wait_any ( * args ) : [EOL] [docstring] [EOL] async with trio . open_nursery ( ) as nursery : [EOL] cancel = nursery . cancel_scope . cancel [EOL] for f in args : [EOL] nursery . start_soon ( _wait_and_call , f , cancel ) [EOL] [EOL] [EOL] async def wait_all ( * args ) : [EOL] [docstring] [EOL] async with trio . open_nursery ( ) as nursery : [EOL] for f in args : [EOL] nursery . start_soon ( f ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
try : [EOL] from trio . lowlevel import ParkingLot as WaitQueue [EOL] except ImportError : [EOL] from trio . hazmat import ParkingLot as WaitQueue [EOL] [EOL] [EOL] class UnqueuedRepeatedEvent : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _wait_queue = WaitQueue ( ) [EOL] self . _iteration_open = False [EOL] [EOL] def set ( self ) : [EOL] [docstring] [EOL] self . _wait_queue . unpark_all ( ) [EOL] [EOL] def __aiter__ ( self ) : [EOL] if self . _iteration_open : [EOL] raise RuntimeError ( f'{ self . __class__ . __name__ } [string] ' ) [EOL] return self . _listen ( ) [EOL] [EOL] async def _listen ( self ) : [EOL] self . _iteration_open = True [EOL] try : [EOL] while True : [EOL] await self . _wait_queue . park ( ) [EOL] yield [EOL] finally : [EOL] self . _iteration_open = False [EOL] [EOL] [EOL] class MailboxRepeatedEvent : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _requested = False [EOL] self . _wait_queue = WaitQueue ( ) [EOL] self . _iteration_open = False [EOL] [EOL] def set ( self ) : [EOL] [docstring] [EOL] self . _requested = True [EOL] self . _wait_queue . unpark_all ( ) [EOL] [EOL] def __aiter__ ( self ) : [EOL] if self . _iteration_open : [EOL] raise RuntimeError ( f'{ self . __class__ . __name__ } [string] ' ) [EOL] return self . _listen ( ) [EOL] [EOL] async def _listen ( self ) : [EOL] self . _iteration_open = True [EOL] try : [EOL] while True : [EOL] if not self . _requested : [EOL] await self . _wait_queue . park ( ) [EOL] self . _requested = False [EOL] yield [EOL] finally : [EOL] self . _iteration_open = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import trio [EOL] [EOL] async def periodic ( period ) : [EOL] [docstring] [EOL] t0 = trio . current_time ( ) [EOL] t_last = None [EOL] while True : [EOL] t_start = t0 if t_last is None else trio . current_time ( ) [EOL] yield t_start - t0 , None if t_last is None else t_start - t_last [EOL] user_elapsed = trio . current_time ( ) - t_start [EOL] await trio . sleep ( max ( [number] , period - user_elapsed ) ) [EOL] t_last = t_start [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] from collections import defaultdict [EOL] [EOL] import trio [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] RATE_MEASURE_PERIOD = [number] [EOL] [EOL] [EOL] class TaskStats ( trio . abc . Instrument ) : [EOL] [docstring] [EOL] def __init__ ( self , current_time = trio . current_time ) : [EOL] super ( ) . __init__ ( ) [EOL] self . current_time = current_time [EOL] self . scheduled_start = { } [EOL] self . max_wait = [number] [EOL] self . task_step_start = None [EOL] self . max_task_step = ( None , [number] ) [EOL] self . schedule_counts = defaultdict ( int ) [EOL] self . rate_start = [number] [EOL] self . max_schedule_rate = ( None , [number] ) [EOL] [EOL] def task_scheduled ( self , task ) : [EOL] t = self . current_time ( ) [EOL] self . scheduled_start [ task ] = t [EOL] if t - self . rate_start > RATE_MEASURE_PERIOD : [EOL] name , count = max ( self . schedule_counts . items ( ) , default = ( None , [number] ) , key = lambda item : item [ [number] ] ) [EOL] rate = count / RATE_MEASURE_PERIOD [EOL] if rate > self . max_schedule_rate [ [number] ] : [EOL] self . max_schedule_rate = ( name , rate ) [EOL] self . rate_start = t [EOL] self . schedule_counts . clear ( ) [EOL] self . schedule_counts [ task . name ] += [number] [EOL] [EOL] def before_task_step ( self , task ) : [EOL] t = self . current_time ( ) [EOL] start = self . scheduled_start . pop ( task , None ) [EOL] if start : [EOL] dt = t - start [EOL] self . max_wait = max ( self . max_wait , dt ) [EOL] self . task_step_start = t [EOL] [EOL] def after_task_step ( self , task ) : [EOL] start = self . task_step_start [EOL] if start : [EOL] dt = self . current_time ( ) - start [EOL] if dt > self . max_task_step [ [number] ] : [EOL] self . max_task_step = ( task . name , dt ) [EOL] self . task_step_start = None [EOL] [EOL] def after_run ( self ) : [EOL] logger . info ( f' [string] { self . max_wait * [number] : [string] } [string] ' ) [EOL] max_task_name , max_task_time = self . max_task_step [EOL] logger . info ( f' [string] { max_task_time * [number] : [string] } [string] { max_task_name }' ) [EOL] max_rate_name , max_rate = self . max_schedule_rate [EOL] logger . info ( f' [string] { max_rate : [string] } [string] { max_rate_name }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from . _version import __version__ [EOL] from . _async_bool import AsyncBool [EOL] from . _async_dictionary import AsyncDictionary [EOL] from . _async_itertools import azip , azip_longest [EOL] from . _async_value import AsyncValue , compose_values [EOL] from . _awaitables import wait_all , wait_any [EOL] from . _exceptions import defer_to_cancelled , multi_error_defer_to [EOL] from . _periodic import periodic [EOL] from . _repeated_event import UnqueuedRepeatedEvent , MailboxRepeatedEvent [EOL] from . _task_stats import TaskStats [EOL] [EOL] def _metadata_fix ( ) : [EOL] [comment] [EOL] import sys [EOL] if [string] in sys . modules : [EOL] return [EOL] [EOL] for name , value in globals ( ) . items ( ) : [EOL] if not name . startswith ( [string] ) : [EOL] value . __module__ = __name__ [EOL] [EOL] _metadata_fix ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . _async_value import AsyncValue [EOL] [EOL] [EOL] class AsyncBool ( AsyncValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value = False ) : [EOL] super ( ) . __init__ ( value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , ValuesView , List , Any , Type [EOL] import src [EOL] import typing [EOL] from collections import defaultdict , namedtuple [EOL] from contextlib import asynccontextmanager [EOL] from functools import partial [EOL] [EOL] import trio [EOL] [EOL] try : [EOL] from trio . lowlevel import ParkingLot as WaitQueue [EOL] except ImportError : [EOL] from trio . hazmat import ParkingLot as WaitQueue [EOL] [EOL] [EOL] def _ANY_TRANSITION ( value , old_value ) : [EOL] return True [EOL] [EOL] [EOL] class _Result : [EOL] __slots__ = [ [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self ) : [EOL] self . event = WaitQueue ( ) [EOL] self . value = None [EOL] self . refs = [number] [EOL] [EOL] [EOL] class _ValueWrapper : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __new__ ( cls , value_or_predicate ) : [EOL] return value_or_predicate if callable ( value_or_predicate ) else super ( ) . __new__ ( cls ) [EOL] [EOL] def __init__ ( self , value ) : [EOL] self . value = value [EOL] [EOL] def __hash__ ( self ) : [EOL] try : [EOL] return hash ( self . value ) [EOL] except TypeError : [EOL] return super ( ) . __hash__ ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . value . __eq__ ( other . value ) [EOL] [EOL] def __call__ ( self , x , * args ) : [EOL] return x == self . value [EOL] [EOL] [EOL] class AsyncValue : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] self . _value = value [EOL] self . _level_results = defaultdict ( _Result ) [EOL] self . _edge_results = defaultdict ( _Result ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . value } [string] " [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return self . _value [EOL] [EOL] @ value . setter def value ( self , x ) : [EOL] if self . _value != x : [EOL] old = self . _value [EOL] new = self . _value = x [EOL] for f , result in list ( self . _level_results . items ( ) ) : [EOL] if f ( new ) : [EOL] result . value = new [EOL] result . event . unpark_all ( ) [EOL] for f , result in list ( self . _edge_results . items ( ) ) : [EOL] if f ( new , old ) : [EOL] result . value = ( new , old ) [EOL] result . event . unpark_all ( ) [EOL] [EOL] @ staticmethod async def _wait_predicate ( result_map , predicate ) : [EOL] result = result_map [ predicate ] [EOL] result . refs += [number] [EOL] try : [EOL] await result . event . park ( ) [EOL] finally : [EOL] result . refs -= [number] [EOL] if not result . refs : [EOL] del result_map [ predicate ] [EOL] return result . value [EOL] [EOL] async def wait_value ( self , value_or_predicate , * , held_for = [number] ) : [EOL] [docstring] [EOL] predicate = _ValueWrapper ( value_or_predicate ) [EOL] while True : [EOL] if not predicate ( self . _value ) : [EOL] value = await self . _wait_predicate ( self . _level_results , predicate ) [EOL] else : [EOL] value = self . _value [EOL] await trio . sleep ( [number] ) [EOL] if held_for > [number] : [EOL] with trio . move_on_after ( held_for ) : [EOL] await self . wait_value ( lambda v : not predicate ( v ) ) [EOL] continue [EOL] break [EOL] return value [EOL] [EOL] [comment] [EOL] async def wait_transition ( self , value_or_predicate = _ANY_TRANSITION ) : [EOL] [docstring] [EOL] return await self . _wait_predicate ( self . _edge_results , _ValueWrapper ( value_or_predicate ) ) [EOL] [EOL] [EOL] @ asynccontextmanager async def compose_values ( ** value_map ) : [EOL] [docstring] [EOL] async with trio . open_nursery ( ) as nursery : [EOL] values = value_map . values ( ) [EOL] [comment] [EOL] if not ( values and all ( isinstance ( e , AsyncValue ) for e in values ) ) : [EOL] raise TypeError ( [string] ) [EOL] value_type = namedtuple ( [string] , value_map . keys ( ) ) [EOL] composite = AsyncValue ( value_type . _make ( e . value for e in values ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def _update_composite ( name , val , _ ) : [EOL] composite . value = composite . value . _replace ( ** { name : val } ) [EOL] return False [EOL] [EOL] for name , e in value_map . items ( ) : [EOL] nursery . start_soon ( e . wait_transition , partial ( _update_composite , name ) ) [EOL] [EOL] yield composite [EOL] nursery . cancel_scope . cancel ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.trio_util._async_value._ValueWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.trio_util._async_value._ValueWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.trio_util._async_value._ValueWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.trio_util._async_value._ValueWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Type [EOL] import builtins [EOL] import typing [EOL] from collections import defaultdict [EOL] from contextlib import _GeneratorContextManager [EOL] from functools import wraps [EOL] from inspect import iscoroutinefunction [EOL] from typing import Type , Dict , List [EOL] [EOL] import trio [EOL] [EOL] [EOL] class _AsyncFriendlyGeneratorContextManager ( _GeneratorContextManager ) : [EOL] [docstring] [EOL] [EOL] def __call__ ( self , func ) : [EOL] if iscoroutinefunction ( func ) : [EOL] wraps ( func ) [EOL] async def inner ( * args , ** kwargs ) : [EOL] with self . _recreate_cm ( ) : [comment] [EOL] return await func ( * args , ** kwargs ) [EOL] else : [EOL] wraps ( func ) [EOL] def inner ( * args , ** kwargs ) : [EOL] with self . _recreate_cm ( ) : [comment] [EOL] return func ( * args , ** kwargs ) [EOL] return inner [EOL] [EOL] [EOL] def _async_friendly_contextmanager ( func ) : [EOL] [docstring] [EOL] @ wraps ( func ) def helper ( * args , ** kwargs ) : [EOL] return _AsyncFriendlyGeneratorContextManager ( func , args , kwargs ) [EOL] return helper [EOL] [EOL] [EOL] def defer_to_cancelled ( * args ) : [EOL] [docstring] [EOL] return multi_error_defer_to ( trio . Cancelled , * args ) [EOL] [EOL] [EOL] @ _async_friendly_contextmanager def multi_error_defer_to ( * privileged_types , propagate_multi_error = True , strict = True ) : [EOL] [docstring] [EOL] try : [EOL] yield [EOL] except trio . MultiError as root_multi_error : [EOL] [comment] [EOL] multi_errors = [ root_multi_error ] [EOL] errors_by_repr = { } [comment] [EOL] while multi_errors : [EOL] multi_error = multi_errors . pop ( ) [EOL] for e in multi_error . exceptions : [EOL] if isinstance ( e , trio . MultiError ) : [EOL] multi_errors . append ( e ) [EOL] continue [EOL] if not isinstance ( e , privileged_types ) : [EOL] [comment] [EOL] if propagate_multi_error : [EOL] raise [EOL] raise RuntimeError ( [string] ) [EOL] errors_by_repr [ repr ( e ) ] = e [EOL] [comment] [EOL] [comment] [EOL] errors_by_priority = defaultdict ( list ) [EOL] for e in errors_by_repr . values ( ) : [EOL] for priority , privileged_type in enumerate ( privileged_types ) : [EOL] if isinstance ( e , privileged_type ) : [EOL] errors_by_priority [ priority ] . append ( e ) [EOL] [comment] [EOL] priority_errors = errors_by_priority [ min ( errors_by_priority ) ] [EOL] if strict and len ( priority_errors ) > [number] : [EOL] [comment] [EOL] if propagate_multi_error : [EOL] raise [EOL] raise RuntimeError ( [string] ) [EOL] raise priority_errors [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0