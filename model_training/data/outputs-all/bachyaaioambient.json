from typing import Any [EOL] import aioambient [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import aiohttp [EOL] import pytest [EOL] from socketio . exceptions import SocketIOError [EOL] [EOL] from aioambient import Client [EOL] from aioambient . errors import WebsocketError [EOL] from aioambient . websocket import WebsocketWatchdog [EOL] [EOL] from tests . async_mock import AsyncMock , MagicMock [EOL] from tests . common import TEST_API_KEY , TEST_APP_KEY [EOL] [EOL] [EOL] async def test_connect_async_success ( event_loop ) : [EOL] [docstring] [EOL] async with aiohttp . ClientSession ( loop = event_loop ) as session : [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY , session = session ) [EOL] client . websocket . _sio . eio . _trigger_event = AsyncMock ( ) [EOL] client . websocket . _sio . eio . connect = AsyncMock ( ) [EOL] [EOL] async_on_connect = AsyncMock ( ) [EOL] client . websocket . async_on_connect ( async_on_connect ) [EOL] [EOL] await client . websocket . connect ( ) [EOL] client . websocket . _sio . eio . connect . assert_called_once_with ( f" [string] { TEST_APP_KEY }" , engineio_path = [string] , headers = { } , transports = [ [string] ] , ) [EOL] [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] ) [EOL] async_on_connect . assert_called_once ( ) [EOL] [EOL] [EOL] async def test_connect_sync_success ( event_loop ) : [EOL] [docstring] [EOL] async with aiohttp . ClientSession ( loop = event_loop ) as session : [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY , session = session ) [EOL] client . websocket . _sio . eio . _trigger_event = AsyncMock ( ) [EOL] client . websocket . _sio . eio . connect = AsyncMock ( ) [EOL] [EOL] async_on_connect = AsyncMock ( ) [EOL] client . websocket . async_on_connect ( async_on_connect ) [EOL] [EOL] await client . websocket . connect ( ) [EOL] client . websocket . _sio . eio . connect . assert_called_once_with ( f" [string] { TEST_APP_KEY }" , engineio_path = [string] , headers = { } , transports = [ [string] ] , ) [EOL] [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] ) [EOL] async_on_connect . assert_called_once ( ) [EOL] [EOL] [EOL] async def test_connect_failure ( event_loop ) : [EOL] [docstring] [EOL] async with aiohttp . ClientSession ( loop = event_loop ) as session : [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY , session = session ) [EOL] client . websocket . _sio . eio . connect = AsyncMock ( side_effect = SocketIOError ( ) ) [EOL] [EOL] with pytest . raises ( WebsocketError ) : [EOL] await client . websocket . connect ( ) [EOL] [EOL] [EOL] async def test_data_async ( event_loop ) : [EOL] [docstring] [EOL] async with aiohttp . ClientSession ( loop = event_loop ) as session : [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY , session = session ) [EOL] client . websocket . _sio . eio . _trigger_event = AsyncMock ( ) [EOL] client . websocket . _sio . eio . connect = AsyncMock ( ) [EOL] client . websocket . _sio . eio . disconnect = AsyncMock ( ) [EOL] [EOL] async_on_connect = AsyncMock ( ) [EOL] async_on_data = AsyncMock ( ) [EOL] async_on_disconnect = AsyncMock ( ) [EOL] async_on_subscribed = AsyncMock ( ) [EOL] [EOL] client . websocket . async_on_connect ( async_on_connect ) [EOL] client . websocket . async_on_data ( async_on_data ) [EOL] client . websocket . async_on_disconnect ( async_on_disconnect ) [EOL] client . websocket . async_on_subscribed ( async_on_subscribed ) [EOL] [EOL] await client . websocket . connect ( ) [EOL] client . websocket . _sio . eio . connect . assert_called_once_with ( f" [string] { TEST_APP_KEY }" , engineio_path = [string] , headers = { } , transports = [ [string] ] , ) [EOL] [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] ) [EOL] async_on_connect . assert_called_once ( ) [EOL] [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] , { [string] : [string] } ) [EOL] async_on_data . assert_called_once ( ) [EOL] [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] , { [string] : [string] } ) [EOL] async_on_subscribed . assert_called ( ) [EOL] [EOL] await client . websocket . disconnect ( ) [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] ) [EOL] async_on_disconnect . assert_called_once ( ) [EOL] client . websocket . _sio . eio . disconnect . assert_called_once_with ( abort = True ) [EOL] [EOL] [EOL] async def test_data_sync ( event_loop ) : [EOL] [docstring] [EOL] async with aiohttp . ClientSession ( loop = event_loop ) as session : [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY , session = session ) [EOL] client . websocket . _sio . eio . _trigger_event = AsyncMock ( ) [EOL] client . websocket . _sio . eio . connect = AsyncMock ( ) [EOL] client . websocket . _sio . eio . disconnect = AsyncMock ( ) [EOL] [EOL] on_connect = MagicMock ( ) [EOL] on_data = MagicMock ( ) [EOL] on_disconnect = MagicMock ( ) [EOL] on_subscribed = MagicMock ( ) [EOL] [EOL] client . websocket . on_connect ( on_connect ) [EOL] client . websocket . on_data ( on_data ) [EOL] client . websocket . on_disconnect ( on_disconnect ) [EOL] client . websocket . on_subscribed ( on_subscribed ) [EOL] [EOL] await client . websocket . connect ( ) [EOL] client . websocket . _sio . eio . connect . assert_called_once_with ( f" [string] { TEST_APP_KEY }" , engineio_path = [string] , headers = { } , transports = [ [string] ] , ) [EOL] [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] ) [EOL] on_connect . assert_called_once ( ) [EOL] [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] , { [string] : [string] } ) [EOL] on_data . assert_called_once ( ) [EOL] [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] , { [string] : [string] } ) [EOL] on_subscribed . assert_called ( ) [EOL] [EOL] await client . websocket . disconnect ( ) [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] ) [EOL] on_disconnect . assert_called_once ( ) [EOL] client . websocket . _sio . eio . disconnect . assert_called_once_with ( abort = True ) [EOL] [EOL] [EOL] async def test_reconnect ( event_loop ) : [EOL] [docstring] [EOL] async with aiohttp . ClientSession ( loop = event_loop ) as session : [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY , session = session ) [EOL] client . websocket . _sio . eio . _trigger_event = AsyncMock ( ) [EOL] client . websocket . _sio . eio . connect = AsyncMock ( ) [EOL] [EOL] async_on_connect = AsyncMock ( ) [EOL] async_on_disconnect = AsyncMock ( ) [EOL] [EOL] client . websocket . async_on_connect ( async_on_connect ) [EOL] client . websocket . async_on_disconnect ( async_on_disconnect ) [EOL] [EOL] await client . websocket . reconnect ( ) [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] ) [EOL] async_on_disconnect . assert_called_once ( ) [EOL] await client . websocket . _sio . _trigger_event ( [string] , [string] ) [EOL] async_on_connect . assert_called_once ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_watchdog_firing ( ) : [EOL] [docstring] [EOL] mock_coro = AsyncMock ( ) [EOL] mock_coro . __name__ = [string] [EOL] [EOL] watchdog = WebsocketWatchdog ( mock_coro ) [EOL] [EOL] await watchdog . on_expire ( ) [EOL] mock_coro . assert_called_once ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] import os [EOL] [EOL] TEST_API_KEY = [string] [EOL] TEST_APP_KEY = [string] [EOL] TEST_MAC = [string] [EOL] [EOL] [EOL] def load_fixture ( filename ) : [EOL] [docstring] [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , [string] , filename ) [EOL] with open ( path , encoding = [string] ) as fptr : [EOL] return fptr . read ( ) [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import sys [EOL] [EOL] if sys . version_info [ : [number] ] < ( [number] , [number] ) : [EOL] from asynctest . mock import * [comment] [EOL] [EOL] AsyncMock = CoroutineMock [comment] [EOL] else : [EOL] from unittest . mock import * [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import aioambient [EOL] import typing [EOL] [docstring] [EOL] import datetime [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] [EOL] from aioambient import Client [EOL] from aioambient . errors import RequestError [EOL] [EOL] from . common import TEST_API_KEY , TEST_APP_KEY , TEST_MAC , load_fixture [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_api_error ( aresponses ) : [EOL] [docstring] [EOL] aresponses . add ( [string] , [string] , [string] , aresponses . Response ( text = [string] , status = [number] ) , ) [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY , session = session ) [EOL] [EOL] with pytest . raises ( RequestError ) : [EOL] await client . api . get_devices ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_device_details ( aresponses ) : [EOL] [docstring] [EOL] aresponses . add ( [string] , f" [string] { TEST_MAC }" , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY , session = session ) [EOL] [EOL] device_details = await client . api . get_device_details ( TEST_MAC , end_date = datetime . datetime ( [number] , [number] , [number] ) ) [EOL] assert len ( device_details ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_devices ( aresponses ) : [EOL] [docstring] [EOL] aresponses . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY , session = session ) [EOL] [EOL] devices = await client . api . get_devices ( ) [EOL] assert len ( devices ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_session_from_scratch ( aresponses ) : [EOL] [docstring] [EOL] aresponses . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] client = Client ( TEST_API_KEY , TEST_APP_KEY ) [EOL] [EOL] devices = await client . api . get_devices ( ) [EOL] assert len ( devices ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Callable , Optional , Any , Awaitable [EOL] import typing [EOL] import logging [EOL] import socketio [EOL] import asyncio [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from typing import Awaitable , Callable , Optional [EOL] [EOL] from aiohttp . client_exceptions import ClientConnectionError , ClientOSError [EOL] from socketio import AsyncClient [EOL] from socketio . exceptions import ( ConnectionError , SocketIOError , ) [EOL] [EOL] from . errors import WebsocketError [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_WATCHDOG_TIMEOUT = [number] [EOL] [EOL] WEBSOCKET_API_BASE = [string] [EOL] [EOL] [EOL] class WebsocketWatchdog : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , action , * , timeout_seconds = DEFAULT_WATCHDOG_TIMEOUT , ) : [EOL] [docstring] [EOL] self . _action = action [EOL] self . _loop = asyncio . get_event_loop ( ) [EOL] self . _timer_task = None [EOL] self . _timeout = timeout_seconds [EOL] [EOL] def cancel ( self ) : [EOL] [docstring] [EOL] if self . _timer_task : [EOL] self . _timer_task . cancel ( ) [EOL] self . _timer_task = None [EOL] [EOL] async def on_expire ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , self . _action . __name__ ) [EOL] await self . _action ( ) [EOL] [EOL] async def trigger ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , self . _timeout ) [EOL] [EOL] if self . _timer_task : [EOL] self . _timer_task . cancel ( ) [EOL] [EOL] self . _timer_task = self . _loop . call_later ( self . _timeout , lambda : asyncio . create_task ( self . on_expire ( ) ) ) [EOL] [EOL] [EOL] class Websocket : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , application_key , api_key , api_version ) : [EOL] [docstring] [EOL] self . _api_key = api_key [EOL] self . _api_version = api_version [EOL] self . _app_key = application_key [EOL] self . _async_user_connect_handler = None [EOL] self . _sio = AsyncClient ( ) [EOL] self . _user_connect_handler = None [EOL] self . _watchdog = WebsocketWatchdog ( self . reconnect ) [EOL] [EOL] async def _init_connection ( self ) : [EOL] [docstring] [EOL] await self . _sio . emit ( [string] , { [string] : [ self . _api_key ] } ) [EOL] await self . _watchdog . trigger ( ) [EOL] [EOL] if self . _async_user_connect_handler : [EOL] await self . _async_user_connect_handler ( ) [comment] [EOL] elif self . _user_connect_handler : [EOL] self . _user_connect_handler ( ) [EOL] [EOL] def async_on_connect ( self , target ) : [EOL] [docstring] [EOL] self . _async_user_connect_handler = target [EOL] self . _user_connect_handler = None [EOL] [EOL] def on_connect ( self , target ) : [EOL] [docstring] [EOL] self . _async_user_connect_handler = None [EOL] self . _user_connect_handler = target [EOL] [EOL] def async_on_data ( self , target ) : [comment] [EOL] [docstring] [EOL] [EOL] async def _async_on_data ( data ) : [EOL] [docstring] [EOL] await self . _watchdog . trigger ( ) [EOL] await target ( data ) [EOL] [EOL] self . _sio . on ( [string] , _async_on_data ) [EOL] [EOL] def on_data ( self , target ) : [comment] [EOL] [docstring] [EOL] [EOL] async def _async_on_data ( data ) : [EOL] [docstring] [EOL] await self . _watchdog . trigger ( ) [EOL] target ( data ) [EOL] [EOL] self . _sio . on ( [string] , _async_on_data ) [EOL] [EOL] def async_on_disconnect ( self , target ) : [EOL] [docstring] [EOL] self . _sio . on ( [string] , target ) [EOL] [EOL] def on_disconnect ( self , target ) : [EOL] [docstring] [EOL] self . _sio . on ( [string] , target ) [EOL] [EOL] def async_on_subscribed ( self , target ) : [comment] [EOL] [docstring] [EOL] [EOL] async def _async_on_subscribed ( data ) : [EOL] [docstring] [EOL] await self . _watchdog . trigger ( ) [EOL] await target ( data ) [EOL] [EOL] self . _sio . on ( [string] , _async_on_subscribed ) [EOL] [EOL] def on_subscribed ( self , target ) : [comment] [EOL] [docstring] [EOL] [EOL] async def _async_on_subscribed ( data ) : [EOL] [docstring] [EOL] await self . _watchdog . trigger ( ) [EOL] target ( data ) [EOL] [EOL] self . _sio . on ( [string] , _async_on_subscribed ) [EOL] [EOL] async def connect ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _sio . on ( [string] , self . _init_connection ) [EOL] await self . _sio . connect ( f"{ WEBSOCKET_API_BASE } [string] { self . _api_version } [string] { self . _app_key }" , transports = [ [string] ] , ) [EOL] except ( ClientConnectionError , ClientOSError , ConnectionError , SocketIOError , ) as err : [EOL] raise WebsocketError ( err ) from None [EOL] [EOL] async def disconnect ( self ) : [EOL] [docstring] [EOL] await self . _sio . disconnect ( ) [EOL] self . _watchdog . cancel ( ) [EOL] [EOL] async def reconnect ( self ) : [EOL] [docstring] [EOL] await self . disconnect ( ) [EOL] await asyncio . sleep ( [number] ) [EOL] await self . connect ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Awaitable]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Awaitable]$ 0 $typing.Callable[...,typing.Awaitable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[asyncio.TimerHandle]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[asyncio.events.TimerHandle]$ 0 0 0 0 $typing.Optional[asyncio.events.TimerHandle]$ 0 0 0 0 0 0 0 $typing.Optional[asyncio.events.TimerHandle]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[asyncio.events.TimerHandle]$ 0 0 0 0 $typing.Optional[asyncio.events.TimerHandle]$ 0 0 0 0 0 0 0 0 $typing.Optional[asyncio.events.TimerHandle]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Callable[...,typing.Awaitable]]$ 0 0 0 0 0 $socketio.AsyncClient$ 0 0 0 0 0 0 0 $typing.Optional[typing.Callable]$ 0 0 0 0 0 $WebsocketWatchdog$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Callable[...,typing.Awaitable[typing.Any]]]$ 0 $typing.Callable[...,typing.Awaitable]$ 0 0 0 $typing.Optional[typing.Callable[...,typing.Any]]$ 0 0 0 0 0 $None$ 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 $typing.Optional[typing.Callable[...,typing.Awaitable[typing.Any]]]$ 0 0 0 0 0 $typing.Optional[typing.Callable[...,typing.Any]]$ 0 $typing.Callable$ 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Awaitable]$ 0 0 0 0 $None$ 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any [EOL] import datetime [EOL] import typing [EOL] import aiohttp [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import datetime [EOL] from typing import Any , Dict , Optional [EOL] [EOL] from aiohttp import ClientSession , ClientTimeout [EOL] from aiohttp . client_exceptions import ClientError [EOL] [EOL] from . errors import RequestError [EOL] [EOL] REST_API_BASE = [string] [EOL] [EOL] DEFAULT_LIMIT = [number] [EOL] DEFAULT_TIMEOUT = [number] [EOL] [EOL] [EOL] class API : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , application_key , api_key , api_version , session = None , ) : [EOL] [docstring] [EOL] self . _api_key = api_key [EOL] self . _api_version = api_version [EOL] self . _application_key = application_key [EOL] self . _session = session [EOL] [EOL] async def _request ( self , method , endpoint , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] url = f"{ REST_API_BASE } [string] { self . _api_version } [string] { endpoint }" [EOL] [EOL] kwargs . setdefault ( [string] , { } ) [EOL] kwargs [ [string] ] [ [string] ] = self . _api_key [EOL] kwargs [ [string] ] [ [string] ] = self . _application_key [EOL] [EOL] use_running_session = self . _session and not self . _session . closed [EOL] [EOL] if use_running_session : [EOL] session = self . _session [EOL] else : [EOL] session = ClientSession ( timeout = ClientTimeout ( total = DEFAULT_TIMEOUT ) ) [EOL] [EOL] try : [EOL] async with session . request ( method , url , ** kwargs ) as resp : [EOL] resp . raise_for_status ( ) [EOL] return await resp . json ( content_type = None ) [EOL] except ClientError as err : [EOL] raise RequestError ( f" [string] { url } [string] { err }" ) [EOL] finally : [EOL] if not use_running_session : [EOL] await session . close ( ) [EOL] [EOL] async def get_devices ( self ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , [string] ) [EOL] [EOL] async def get_device_details ( self , mac_address , * , end_date = None , limit = DEFAULT_LIMIT ) : [EOL] [docstring] [EOL] params = { [string] : limit } [EOL] if end_date : [EOL] params [ [string] ] = end_date . isoformat ( ) [EOL] [EOL] return await self . _request ( [string] , f" [string] { mac_address }" , params = params ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Optional[aiohttp.ClientSession]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $aiohttp.ClientSession$ 0 $typing.Optional[aiohttp.ClientSession]$ 0 0 0 0 $builtins.list$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 $builtins.str$ 0 0 0 $datetime.datetime$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 $datetime.datetime$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0
[docstring] [EOL] from . client import Client [comment] [EOL]	0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import logging [EOL] import aiohttp [EOL] import websocket [EOL] import api [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] from typing import Optional [EOL] [EOL] from aiohttp import ClientSession [EOL] [EOL] from . api import API [EOL] from . websocket import Websocket [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_API_VERSION = [number] [EOL] [EOL] [EOL] class Client : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_key , application_key , * , api_version = DEFAULT_API_VERSION , session = None , ) : [EOL] [docstring] [EOL] self . api = API ( application_key , api_key , api_version , session ) [EOL] self . websocket = Websocket ( application_key , api_key , api_version ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Optional[aiohttp.ClientSession]$ 0 0 0 0 0 0 0 0 0 0 $api.API$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Optional[aiohttp.ClientSession]$ 0 0 0 0 $websocket.Websocket$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0
[docstring] [EOL] [EOL] [EOL] class AmbientError ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class RequestError ( AmbientError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class WebsocketError ( AmbientError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import aioambient [EOL] import asyncio [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from aiohttp import ClientSession [EOL] [EOL] from aioambient import Client [EOL] from aioambient . errors import WebsocketError [EOL] [EOL] _LOGGER = logging . getLogger ( ) [EOL] [EOL] API_KEY = [string] [EOL] APP_KEY = [string] [EOL] [EOL] [EOL] def print_data ( data ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , data ) [EOL] [EOL] [EOL] def print_goodbye ( ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] [EOL] def print_hello ( ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] [EOL] def print_subscribed ( data ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , data ) [EOL] [EOL] [EOL] async def main ( ) : [EOL] [docstring] [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] [EOL] async with ClientSession ( ) as session : [EOL] client = Client ( API_KEY , APP_KEY , session = session ) [EOL] [EOL] client . websocket . on_connect ( print_hello ) [EOL] client . websocket . on_data ( print_data ) [EOL] client . websocket . on_disconnect ( print_goodbye ) [EOL] client . websocket . on_subscribed ( print_subscribed ) [EOL] [EOL] try : [EOL] await client . websocket . connect ( ) [EOL] except WebsocketError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] return [EOL] [EOL] while True : [EOL] _LOGGER . info ( [string] ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . create_task ( main ( ) ) [EOL] loop . run_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import aioambient [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from aiohttp import ClientSession [EOL] [EOL] from aioambient import Client [EOL] from aioambient . errors import AmbientError [EOL] [EOL] _LOGGER = logging . getLogger ( ) [EOL] [EOL] API_KEY = [string] [EOL] APP_KEY = [string] [EOL] [EOL] [EOL] async def main ( ) : [EOL] [docstring] [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] async with ClientSession ( ) as session : [EOL] try : [EOL] client = Client ( API_KEY , APP_KEY , session = session ) [EOL] [EOL] devices = await client . api . get_devices ( ) [EOL] _LOGGER . info ( [string] , devices ) [EOL] [EOL] for device in devices : [EOL] details = await client . api . get_device_details ( device [ [string] ] ) [EOL] _LOGGER . info ( [string] , device [ [string] ] , details ) [EOL] [EOL] except AmbientError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] [EOL] [EOL] asyncio . run ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0