import builtins [EOL] from chain import Hash [EOL] [EOL] [EOL] class Block : [EOL] def __init__ ( self , index , prev_hash , timestamp , data , nonce , target , hash , ) : [EOL] self . index = index [EOL] self . prev_hash = prev_hash [EOL] self . timestamp = timestamp [EOL] self . data = data [EOL] self . nonce = nonce [EOL] self . target = target [EOL] self . hash = hash [EOL] [EOL] assert self . valid [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Block ) : [EOL] return False [EOL] [EOL] if self . index != other . index : [EOL] return False [EOL] [EOL] if self . hash != other . hash : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( repr ( self . index ) , repr ( self . prev_hash ) , repr ( self . timestamp ) , repr ( self . data ) , repr ( self . nonce ) , repr ( self . target ) , repr ( self . hash ) , ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return int ( self . hash , [number] ) [EOL] [EOL] def serialize ( self ) : [EOL] return dict ( index = self . index , prev_hash = self . prev_hash , timestamp = self . timestamp , data = self . data , nonce = self . nonce , target = self . target , hash = self . hash , ) [EOL] [EOL] @ property def valid ( self ) : [EOL] return self . is_valid_hash ( ) and self . is_valid_difficulty ( ) [EOL] [EOL] def is_valid_hash ( self ) : [EOL] return self . recalculate_hash ( ) == self . hash [EOL] [EOL] def is_valid_difficulty ( self ) : [EOL] return Block . validate_difficulty ( self . hash , self . target ) [EOL] [EOL] def recalculate_hash ( self ) : [EOL] return Block . calculate_hash ( self . index , self . prev_hash , self . timestamp , self . data , self . nonce , self . target , ) [EOL] [EOL] @ staticmethod def calculate_hash ( index , prev_hash , timestamp , data , nonce , target ) : [EOL] s = f"{ index }{ prev_hash }{ timestamp }{ data }{ nonce }{ target }" . encode ( ) [EOL] return Hash ( s ) . hexdigest ( ) [EOL] [EOL] @ staticmethod def validate_difficulty ( hash , target ) : [EOL] return int ( hash , [number] ) <= int ( target , [number] ) [EOL] [EOL] @ staticmethod def deserialize ( other ) : [EOL] return Block ( ** other ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $"Block"$ 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0
from typing import Type , Tuple , Coroutine , List , Dict , Callable , Any , Set [EOL] import typing [EOL] import asyncio [EOL] import kademlia [EOL] import builtins [EOL] import chain [EOL] import random [EOL] import asyncio [EOL] import time [EOL] from typing import List , Callable , Dict [EOL] from enum import Enum , auto [EOL] [EOL] import umsgpack as msgpack [EOL] from umsgpack import UnpackException [EOL] from kademlia . network import Server [EOL] from kademlia . protocol import KademliaProtocol [EOL] from kademlia . node import Node [EOL] [EOL] from chain import Block , BlockChain [EOL] from chain . transaction import Transaction [EOL] from chain . utils . log import logger [EOL] [EOL] [EOL] class Message ( Enum ) : [EOL] REQUEST_LATEST_BLOCK = auto ( ) [comment] [EOL] RECEIVE_LATEST_BLOCK = auto ( ) [EOL] REQUEST_BLOCKCHAIN = auto ( ) [EOL] RECEIVE_BLOCKCHAIN = auto ( ) [EOL] REQUEST_BLOCKS = auto ( ) [EOL] RECEIVE_BLOCKS = auto ( ) [EOL] REQUEST_TRANSACTIONS = auto ( ) [EOL] RECEIVE_TRANSACTIONS = auto ( ) [EOL] [EOL] @ classmethod def get_latest_block ( cls ) : [EOL] return dict ( type = cls . REQUEST_LATEST_BLOCK . value ) [EOL] [EOL] @ classmethod def send_latest_block ( cls , block ) : [EOL] return dict ( type = cls . RECEIVE_LATEST_BLOCK . value , block = block . serialize ( ) ) [EOL] [EOL] @ classmethod def get_blocks ( cls , start_index , end_index ) : [EOL] return dict ( type = cls . REQUEST_BLOCKS , start_index = start_index , end_index = end_index ) [EOL] [EOL] @ classmethod def send_blocks ( cls , start_index , end_index , blocks ) : [EOL] return dict ( type = cls . RECEIVE_BLOCKS , start_index = start_index , end_index = end_index , blocks = [ b . serialize ( ) for b in blocks ] , ) [EOL] [EOL] @ classmethod def get_blockchain ( cls ) : [EOL] return dict ( type = cls . REQUEST_BLOCKCHAIN . value ) [EOL] [EOL] @ classmethod def send_blockchain ( cls , blockchain ) : [EOL] return dict ( type = cls . RECEIVE_BLOCKCHAIN . value , blockchain = blockchain . serialize ( ) ) [EOL] [EOL] @ classmethod def get_transactions ( cls ) : [EOL] return dict ( type = cls . REQUEST_TRANSACTIONS . value ) [EOL] [EOL] @ classmethod def send_transactions ( cls , transactions ) : [EOL] return dict ( type = cls . RECEIVE_TRANSACTIONS , transactions = [ t . serialize ( ) for t in transactions ] , ) [EOL] [EOL] [EOL] class UDPProtocal ( KademliaProtocol ) : [EOL] def get_refresh_ids ( self ) : [EOL] [docstring] [EOL] all_buckets = self . router . buckets [EOL] assert all_buckets [EOL] [EOL] ids = [ ] [EOL] count = max ( [number] , len ( all_buckets ) // [number] ) [EOL] for bucket in random . sample ( all_buckets , count ) : [EOL] rid = random . randint ( * bucket . range ) . to_bytes ( [number] , byteorder = [string] ) [EOL] ids . append ( rid ) [EOL] return ids [EOL] [EOL] [EOL] class TCPProtocol ( asyncio . Protocol ) : [EOL] def __init__ ( self , server ) : [EOL] self . server = server [EOL] self . blockchain = self . server . blockchain [EOL] [EOL] def reply ( self , data ) : [EOL] self . transport . write ( msgpack . dumps ( data ) ) [EOL] [EOL] def handle_request_latest_block ( self ) : [EOL] self . reply ( Message . send_latest_block ( self . blockchain . latest_block ) ) [EOL] [comment] [EOL] [EOL] def handle_receive_latest_block ( self , block ) : [EOL] peer_block = Block . deserialize ( block ) [EOL] latest_block = self . blockchain . latest_block [EOL] is_added = self . blockchain . add_block ( peer_block ) [EOL] if is_added : [EOL] self . server . broadcast_message ( Message . send_latest_block ( peer_block ) ) [EOL] elif latest_block . index < peer_block . index : [EOL] [comment] [EOL] logger . debug ( [string] ) [EOL] self . server . broadcast_message ( Message . get_blockchain ( ) ) [EOL] else : [EOL] [comment] [EOL] pass [EOL] [EOL] self . transport . close ( ) [EOL] [EOL] def handle_request_blockchain ( self ) : [EOL] self . reply ( Message . send_blockchain ( self . blockchain ) ) [EOL] [EOL] def handle_receive_blockchain ( self , blockchain ) : [EOL] other_blockchain = BlockChain . deserialize ( blockchain ) [EOL] [EOL] if other_blockchain . length > self . blockchain . length : [EOL] self . blockchain . replace ( other_blockchain ) [EOL] [EOL] self . transport . close ( ) [EOL] [EOL] def handle_message ( self , msg ) : [EOL] try : [EOL] message = msgpack . loads ( msg ) [EOL] msg_type = Message ( message . pop ( [string] ) ) [EOL] logger . info ( f" [string] { msg_type }" ) [EOL] func_mapping = { Message . REQUEST_LATEST_BLOCK : self . handle_request_latest_block , Message . RECEIVE_LATEST_BLOCK : self . handle_receive_latest_block , Message . REQUEST_BLOCKCHAIN : self . handle_request_blockchain , Message . RECEIVE_BLOCKCHAIN : self . handle_receive_blockchain , } [EOL] func_mapping [ msg_type ] ( ** message ) [EOL] except ( UnpackException , KeyError , ValueError ) as e : [EOL] logger . error ( [string] ) [EOL] logger . error ( f"{ e }" ) [EOL] [EOL] def connection_made ( self , transport ) : [EOL] peername = transport . get_extra_info ( [string] ) [EOL] logger . debug ( f" [string] { peername }" ) [EOL] self . transport = transport [EOL] [EOL] def data_received ( self , data ) : [EOL] logger . debug ( f" [string] { data [ : [number] ] !r}" ) [EOL] self . handle_message ( data ) [EOL] [EOL] def connection_lost ( self , exc ) : [EOL] logger . debug ( [string] ) [EOL] [EOL] [EOL] class TCPClientProtocol ( TCPProtocol ) : [EOL] def __init__ ( self , server , data ) : [EOL] super ( ) . __init__ ( server ) [EOL] self . data = data [EOL] [EOL] def connection_made ( self , transport ) : [EOL] peername = transport . get_extra_info ( [string] ) [EOL] logger . debug ( f" [string] { peername }" ) [EOL] self . transport = transport [EOL] self . transport . write ( self . data ) [EOL] [EOL] def data_received ( self , data ) : [EOL] logger . debug ( f" [string] { data [ : [number] ] !r}" ) [EOL] self . handle_message ( data ) [EOL] [EOL] def connection_lost ( self , exc ) : [EOL] logger . debug ( [string] ) [EOL] [EOL] [EOL] class P2PServer ( Server ) : [EOL] protocol_class = UDPProtocal [EOL] [EOL] def __init__ ( self , ksize = [number] , alpha = [number] , node_id = None , storage = None , mining = True ) : [EOL] super ( ) . __init__ ( ksize , alpha , node_id , storage ) [EOL] self . mining = mining [EOL] self . read_blockchain ( ) [EOL] self . tcp_server = None [EOL] self . sync_loop = None [EOL] [EOL] def listen ( self , port , interface = [string] ) : [EOL] logger . info ( f" [string] { self . node . long_id } [string] { interface } [string] { port }" ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] listen_udp = loop . create_datagram_endpoint ( self . _create_protocol , local_addr = ( interface , port ) ) [EOL] self . transport , self . protocol = loop . run_until_complete ( listen_udp ) [EOL] [EOL] listen_tcp = loop . create_server ( lambda : TCPProtocol ( self ) , interface , port ) [EOL] self . tcp_server = loop . run_until_complete ( listen_tcp ) [EOL] [EOL] self . refresh_table ( ) [EOL] self . sync_blockchain ( ) [EOL] [EOL] def stop ( self ) : [EOL] super ( ) . stop ( ) [EOL] [EOL] for task in asyncio . Task . all_tasks ( ) : [EOL] logger . debug ( f" [string] { task }" ) [EOL] task . cancel ( ) [EOL] [EOL] if self . tcp_server : [EOL] self . tcp_server . close ( ) [EOL] [EOL] if self . sync_loop : [EOL] self . sync_loop . cancel ( ) [EOL] [EOL] def refresh_table ( self ) : [EOL] logger . debug ( [string] ) [EOL] asyncio . ensure_future ( self . _refresh_table ( ) ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] self . refresh_loop = loop . call_later ( [number] , self . refresh_table ) [EOL] [EOL] def get_mempool ( self ) : [EOL] return [string] [EOL] [EOL] def read_blockchain ( self ) : [EOL] [comment] [EOL] self . blockchain = BlockChain ( ) [EOL] [EOL] async def _mine ( self , data ) : [EOL] [comment] [EOL] loop = asyncio . get_event_loop ( ) [EOL] return await loop . run_in_executor ( None , self . blockchain . mine , data ) [EOL] [EOL] async def mine_blockchain ( self ) : [EOL] if not self . mining : [EOL] return [EOL] [EOL] data = self . get_mempool ( ) [EOL] while True : [EOL] start = time . time ( ) [EOL] logger . debug ( [string] ) [EOL] mined = await self . _mine ( data ) [EOL] if mined : [EOL] logger . debug ( f" [string] { time . time ( ) - start : [string] } [string] " ) [EOL] self . broadcast_message ( Message . send_latest_block ( self . blockchain . latest_block ) ) [EOL] else : [EOL] logger . debug ( f" [string] " ) [EOL] self . broadcast_message ( Message . get_blockchain ( ) ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] def sync_blockchain ( self ) : [EOL] [comment] [EOL] self . broadcast_message ( Message . get_latest_block ( ) ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] self . sync_loop = loop . call_later ( self . blockchain . interval , self . sync_blockchain ) [EOL] [EOL] def broadcast_message ( self , message ) : [EOL] asyncio . ensure_future ( self . broadcast ( msgpack . dumps ( message ) ) ) [EOL] [EOL] def get_peers ( self ) : [EOL] protocol = self . protocol [EOL] return protocol . router . find_neighbors ( self . node , self . alpha ) [EOL] [EOL] async def connect_peer ( self , ip , port , data ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] try : [EOL] await loop . create_connection ( lambda : TCPClientProtocol ( self , data ) , ip , port ) [EOL] except ConnectionRefusedError : [EOL] logger . debug ( [string] ) [EOL] [EOL] async def broadcast ( self , data ) : [EOL] peers = { ( p . ip , p . port ) for p in self . get_peers ( ) } [EOL] for ip , port in peers : [EOL] await self . connect_peer ( ip , port , data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from chain . utils import elliptic [EOL] [EOL] [EOL] class Wallet : [EOL] def __init__ ( self , password = None ) : [EOL] self . _key_pair = elliptic . generate_keypair ( ) [EOL] self . _password = password [EOL] [EOL] def get_public_key ( self ) : [EOL] return self . _key_pair [ [number] ] [EOL] [EOL] def get_private_key ( self , password = None ) : [EOL] if self . _password != password : [EOL] raise ValueError ( [string] ) [EOL] [EOL] return self . _key_pair [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import chain [EOL] import builtins [EOL] import decimal [EOL] from decimal import Decimal [EOL] from typing import List [EOL] [EOL] from chain import Hash [EOL] from chain . utils import elliptic [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class TxIn : [EOL] def __init__ ( self , tx_index , tx_hash , amount , pubkey , signature = [string] , ) : [EOL] self . tx_index = tx_index [EOL] self . tx_hash = tx_hash [EOL] self . amount = amount [EOL] self . pubkey = pubkey [EOL] self . _signature = signature [EOL] self . _hash = self . calculate_hash ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , TxIn ) : [EOL] return False [EOL] return self . hash == other . hash [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( repr ( self . tx_index ) , repr ( self . tx_hash ) , repr ( self . amount ) , repr ( self . pubkey ) , repr ( self . signature ) , ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return int ( self . hash , [number] ) [EOL] [EOL] @ property def signature ( self ) : [EOL] return self . _signature [EOL] [EOL] @ property def hash ( self ) : [EOL] return self . _hash [EOL] [EOL] @ property def valid ( self ) : [EOL] return self . verify ( quiet = True ) [EOL] [EOL] def serialize ( self ) : [EOL] return dict ( tx_index = self . tx_index , tx_hash = self . tx_hash , amount = str ( self . amount ) , pubkey = self . pubkey , signature = self . signature , ) [EOL] [EOL] def calculate_hash ( self ) : [EOL] s = f"{ self . tx_index }{ self . tx_hash }{ self . amount }{ self . pubkey }" . encode ( ) [EOL] return Hash ( s ) . hexdigest ( ) [EOL] [EOL] def sign ( self , key ) : [EOL] self . _signature = elliptic . sign ( key , self . hash ) [EOL] return self . signature [EOL] [EOL] def verify ( self , quiet = False ) : [EOL] computed_hash = self . calculate_hash ( ) [EOL] try : [EOL] verified = elliptic . verify ( self . pubkey , self . signature , computed_hash ) [EOL] if not verified : [EOL] raise ValueError ( [string] ) [EOL] except Exception as e : [EOL] verified = False [EOL] if not quiet : [EOL] raise e [EOL] [EOL] return verified [EOL] [EOL] @ staticmethod def deserialize ( other ) : [EOL] other [ [string] ] = Decimal ( other [ [string] ] ) [EOL] return TxIn ( ** other ) [EOL] [EOL] [EOL] class TxOut : [EOL] def __init__ ( self , amount , address ) : [EOL] self . _amount = amount [EOL] self . _address = address [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , TxOut ) : [EOL] return False [EOL] return ( self . amount , self . address ) == ( other . amount , other . address ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { repr ( self . amount ) } [string] { repr ( self . address ) } [string] " [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . amount , self . address ) ) [EOL] [EOL] @ property def amount ( self ) : [EOL] return self . _amount [EOL] [EOL] @ property def address ( self ) : [EOL] return self . _address [EOL] [EOL] def serialize ( self ) : [EOL] return dict ( amount = str ( self . amount ) , address = self . address ) [EOL] [EOL] @ staticmethod def deserialize ( other ) : [EOL] other [ [string] ] = Decimal ( other [ [string] ] ) [EOL] return TxOut ( ** other ) [EOL] [EOL] [EOL] TX_REGULAR = [string] [EOL] TX_COINBASE = [string] [EOL] [EOL] ALL_TX_TYPES = [ TX_REGULAR , TX_COINBASE ] [EOL] [EOL] [EOL] class Transaction : [EOL] [EOL] _reward = [number] [EOL] [EOL] def __init__ ( self , type , inputs = [ ] , outputs = [ ] ) : [EOL] self . _type = type [EOL] assert self . _type in ALL_TX_TYPES [EOL] self . _inputs = inputs [EOL] self . _outputs = outputs [EOL] self . _hash = self . calculate_hash ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Transaction ) : [EOL] return False [EOL] return self . hash == other . hash [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( f" [string] { repr ( self . type ) } [string] { repr ( self . inputs ) } [string] { repr ( self . outputs ) } [string] " ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return int ( self . hash , [number] ) [EOL] [EOL] @ property def reward ( self ) : [EOL] return self . _reward [EOL] [EOL] @ property def type ( self ) : [EOL] return self . _type [EOL] [EOL] @ property def inputs ( self ) : [EOL] return self . _inputs [EOL] [EOL] @ property def outputs ( self ) : [EOL] return self . _outputs [EOL] [EOL] @ property def hash ( self ) : [EOL] return self . _hash [EOL] [EOL] @ property def total_input ( self ) : [EOL] return sum ( [ i . amount for i in self . inputs ] , Decimal ( [number] ) ) [EOL] [EOL] @ property def total_output ( self ) : [EOL] return sum ( [ o . amount for o in self . outputs ] , Decimal ( [number] ) ) [EOL] [EOL] @ property def has_enough_balance ( self ) : [EOL] return self . total_input >= self . total_output [EOL] [EOL] @ property def fee ( self ) : [EOL] assert self . type == TX_REGULAR [EOL] return self . total_input - self . total_output [EOL] [EOL] @ property def valid ( self ) : [EOL] if not self . has_enough_balance : [EOL] return False [EOL] [EOL] return all ( [ txin . valid for txin in self . inputs ] ) [EOL] [EOL] def has_same_inputs ( self , other ) : [EOL] for our_in in self . inputs : [EOL] for their_in in other . inputs : [EOL] if our_in == their_in : [EOL] return True [EOL] return False [EOL] [EOL] def serialize ( self ) : [EOL] return dict ( type = self . type , inputs = [ txin . serialize ( ) for txin in self . inputs ] , outputs = [ txin . serialize ( ) for txin in self . outputs ] , ) [EOL] [EOL] def calculate_hash ( self ) : [EOL] s = f"{ self . type }{ self . inputs }{ self . outputs }" . encode ( ) [EOL] return Hash ( s ) . hexdigest ( ) [EOL] [EOL] @ staticmethod def deserialize ( other ) : [EOL] inputs = [ TxIn . deserialize ( txin ) for txin in other [ [string] ] ] [EOL] outputs = [ TxOut . deserialize ( txout ) for txout in other [ [string] ] ] [EOL] return Transaction ( other [ [string] ] , inputs , outputs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $decimal.Decimal$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $decimal.Decimal$ 0 $decimal.Decimal$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $"TxIn"$ 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $decimal.Decimal$ 0 $builtins.str$ 0 0 0 0 0 $decimal.Decimal$ 0 $decimal.Decimal$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TxOut"$ 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[TxIn]$ 0 0 0 0 $typing.List[TxOut]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[chain.transaction.TxIn]$ 0 $typing.List[TxIn]$ 0 0 0 $typing.List[chain.transaction.TxOut]$ 0 $typing.List[TxOut]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $"Transaction"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Transaction"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $"Transaction"$ 0 $builtins.dict$ 0 0 0 $typing.List[chain.transaction.TxIn]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.List[chain.transaction.TxOut]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $typing.List[chain.transaction.TxIn]$ 0 $typing.List[chain.transaction.TxOut]$ 0 0
from typing import List [EOL] import hashlib [EOL] import typing [EOL] import functools [EOL] from hashlib import blake2b [EOL] from functools import partial [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] Hash = partial ( blake2b , digest_size = [number] ) [EOL] [EOL] from chain . block import Block [comment] [EOL] from chain . blockchain import BlockChain [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $functools.partial[hashlib._BlakeHash]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , List [EOL] import typing [EOL] import chain [EOL] import builtins [EOL] from typing import Set [EOL] [EOL] from chain . transaction import Transaction [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] class Mempool : [EOL] def __init__ ( self , transactions = set ( ) ) : [EOL] self . transactions = transactions [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { repr ( self . transactions ) } [string] " [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Mempool ) : [EOL] return False [EOL] return self . transactions == other . transactions [EOL] [EOL] def trim_txs ( self , block_txs ) : [EOL] self . transactions . difference_update ( block_txs ) [EOL] [EOL] def is_double_spent ( self , transaction ) : [EOL] for tx in self . transactions : [EOL] if tx . has_same_inputs ( transaction ) : [EOL] return True [EOL] return False [EOL] [EOL] def add ( self , transaction ) : [EOL] if self . is_double_spent ( transaction ) : [EOL] return False [EOL] [EOL] self . transactions . add ( transaction ) [EOL] [EOL] return True [EOL] [EOL] def remove ( self , transaction ) : [EOL] self . transactions . discard ( transaction ) [EOL] [EOL] def serialize ( self ) : [EOL] return dict ( transactions = list ( self . transactions ) ) [EOL] [EOL] @ staticmethod def deserialize ( other ) : [EOL] return Mempool ( transactions = set ( other [ [string] ] ) ) [EOL] [EOL] [EOL] _mempool = Mempool ( ) [EOL] [EOL] [EOL] def get_mempool ( ) : [EOL] return _mempool [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Set[chain.transaction.Transaction]$ 0 0 0 0 0 0 0 0 0 $typing.Set[chain.transaction.Transaction]$ 0 $typing.Set[chain.transaction.Transaction]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Set[chain.transaction.Transaction]$ 0 0 0 0 0 0 0 0 0 $typing.Set[chain.transaction.Transaction]$ 0 0 0 0 $builtins.bool$ 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Mempool"$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 0 0 0 0 0 $Mempool$ 0 0 0 0 0 $chain.mempool.Mempool$ 0
[comment] [EOL] import asyncio [EOL] import chain [EOL] import argparse [EOL] import argparse [EOL] import asyncio [EOL] [EOL] from chain . p2p import P2PServer as Server [EOL] from chain . utils . log import logger [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] [EOL] parser . add_argument ( [string] , type = int , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = lambda x : int ( x ) if x . isdigit ( ) else x , action = [string] , metavar = ( [string] , [string] ) , nargs = [number] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] server = Server ( mining = args . mine ) [EOL] server . listen ( args . port ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . set_debug ( args . debug ) [EOL] [EOL] [EOL] if args . bootstrap : [EOL] logger . debug ( loop . run_until_complete ( server . bootstrap ( [ ( ip , port ) for ip , port in args . bootstrap ] ) ) ) [EOL] [EOL] try : [EOL] if server . mining : [EOL] loop . run_until_complete ( server . mine_blockchain ( ) ) [EOL] else : [EOL] loop . run_forever ( ) [EOL] except KeyboardInterrupt : [EOL] logger . debug ( server . blockchain [ - [number] : ] ) [EOL] server . stop ( ) [EOL] finally : [EOL] loop . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $chain.p2p.P2PServer$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $chain.p2p.P2PServer$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $chain.p2p.P2PServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $chain.p2p.P2PServer$ 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $chain.p2p.P2PServer$ 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.p2p.P2PServer$ 0 0 0 0 0 0 0 0 0 $chain.p2p.P2PServer$ 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0
	0
from typing import Tuple , List , Any [EOL] import typing [EOL] import builtins [EOL] import codecs [EOL] from typing import Tuple [EOL] [EOL] from coincurve . utils import get_valid_secret [EOL] from eth_keys import keys [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def remove_0x ( s ) : [EOL] if s . startswith ( [string] ) or s . startswith ( [string] ) : [EOL] return s [ [number] : ] [EOL] return s [EOL] [EOL] [EOL] def decode_hex ( s ) : [EOL] return codecs . decode ( remove_0x ( s ) , [string] ) [comment] [EOL] [EOL] [EOL] def generate_keypair ( ) : [EOL] k = keys . PrivateKey ( get_valid_secret ( ) ) [EOL] return k . to_hex ( ) , k . public_key . to_hex ( ) [EOL] [EOL] [EOL] def sign ( priv_key , msg ) : [EOL] prv = keys . PrivateKey ( decode_hex ( priv_key ) ) [EOL] return prv . sign_msg ( msg . encode ( ) ) . to_hex ( ) [EOL] [EOL] [EOL] def verify ( pub_key , sig , msg ) : [EOL] [docstring] [EOL] pub = keys . PublicKey ( decode_hex ( pub_key ) ) [EOL] signature = keys . Signature ( decode_hex ( sig ) ) [EOL] return pub . verify_msg ( msg . encode ( ) , signature ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import chain [EOL] from decimal import Decimal [EOL] import binascii [EOL] [EOL] from chain . transaction import TxIn , TxOut , Transaction , TX_REGULAR [EOL] from chain . mempool import get_mempool , Mempool [EOL] from chain . utils . elliptic import generate_keypair [EOL] [EOL] from chain . tests import TestCase [EOL] [EOL] [EOL] class TestTx ( TestCase ) : [EOL] def test_txin ( self ) : [EOL] priv , pub = generate_keypair ( ) [EOL] ti = TxIn ( [number] , [string] , Decimal ( [number] ) , pub ) [EOL] self . assertFalse ( ti . valid ) [EOL] [EOL] [comment] [EOL] ti . sign ( priv . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] self . assertFalse ( ti . valid ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( binascii . Error ) : [EOL] ti . sign ( [string] ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( ValueError ) : [EOL] ti . verify ( ) [EOL] [EOL] [comment] [EOL] ti . sign ( priv ) [EOL] self . assertTrue ( ti . valid ) [EOL] [EOL] self . assertSerializable ( TxIn , ti , globals ( ) ) [EOL] [EOL] def test_txout ( self ) : [EOL] priv , pub = generate_keypair ( ) [EOL] to = TxOut ( Decimal ( [number] ) , [string] ) [EOL] self . assertSerializable ( TxOut , to , globals ( ) ) [EOL] [EOL] to = TxOut ( Decimal ( [number] ) , [string] ) [EOL] self . assertSerializable ( TxOut , to , globals ( ) ) [EOL] [EOL] def test_transaction ( self ) : [EOL] priv , pub = generate_keypair ( ) [EOL] inputs = [ TxIn ( [number] , [string] , Decimal ( [number] ) , pub ) ] [EOL] outputs = [ TxOut ( Decimal ( [number] ) , [string] ) , TxOut ( Decimal ( [number] ) , [string] ) ] [EOL] [EOL] for ti in inputs : [EOL] ti . sign ( priv ) [EOL] [EOL] tx = Transaction ( TX_REGULAR , inputs , outputs ) [EOL] self . assertSerializable ( Transaction , tx , globals ( ) ) [EOL] [EOL] self . assertTrue ( tx . has_enough_balance ) [EOL] self . assertEqual ( tx . fee , Decimal ( [number] ) ) [EOL] self . assertTrue ( tx . valid ) [EOL] [EOL] tx1 = Transaction ( TX_REGULAR , [ inputs [ [number] ] , TxIn ( [number] , [string] , Decimal ( [number] ) , pub ) ] , outputs ) [EOL] tx2 = Transaction ( TX_REGULAR , [ TxIn ( [number] , [string] , Decimal ( [number] ) , pub ) ] , outputs ) [EOL] self . assertTrue ( tx . has_same_inputs ( tx1 ) ) [EOL] self . assertFalse ( tx . has_same_inputs ( tx2 ) ) [EOL] [EOL] mempool = get_mempool ( ) [EOL] self . assertSerializable ( Mempool , mempool , globals ( ) ) [EOL] [EOL] self . assertIs ( mempool , get_mempool ( ) ) [EOL] self . assertEqual ( mempool , get_mempool ( ) ) [EOL] self . assertTrue ( mempool . add ( tx ) ) [EOL] self . assertFalse ( mempool . add ( tx ) ) [EOL] [EOL] self . assertTrue ( mempool . is_double_spent ( tx ) ) [EOL] self . assertTrue ( mempool . is_double_spent ( tx1 ) ) [EOL] self . assertFalse ( mempool . is_double_spent ( tx2 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxIn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxIn$ 0 0 0 0 0 0 0 $chain.transaction.TxIn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxIn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxIn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxIn$ 0 0 0 0 0 0 0 0 $chain.transaction.TxIn$ 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxIn$ 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxIn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxOut$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxOut$ 0 0 0 0 0 0 0 $chain.transaction.TxOut$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.TxOut$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[chain.transaction.TxIn]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[chain.transaction.TxOut]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[chain.transaction.TxIn]$ 0 0 0 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 $typing.List[chain.transaction.TxIn]$ 0 $typing.List[chain.transaction.TxOut]$ 0 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 $typing.List[chain.transaction.TxIn]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[chain.transaction.TxOut]$ 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[chain.transaction.TxOut]$ 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 $chain.transaction.Transaction$ 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 0 0 0 0 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 0 0 0 0 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 0 0 0 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 0 0 0 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 $chain.transaction.Transaction$ 0 0 0 0 0 0 0 $chain.mempool.Mempool$ 0 0 0 $chain.transaction.Transaction$ 0 0 0
import unittest [EOL] from collections . abc import Hashable [EOL] [EOL] [EOL] class TestCase ( unittest . TestCase ) : [EOL] def assertSerializable ( self , cls , obj , env = { } ) : [EOL] self . assertIsInstance ( obj , cls ) [EOL] self . assertNotEqual ( obj , [number] ) [EOL] self . assertNotEqual ( obj , [string] ) [EOL] self . assertNotEqual ( obj , object ( ) ) [EOL] self . assertEqual ( obj , eval ( repr ( obj ) , env ) ) [EOL] self . assertIsNot ( obj , eval ( repr ( obj ) , env ) ) [EOL] self . assertEqual ( obj , cls . deserialize ( obj . serialize ( ) ) ) [EOL] self . assertIsNot ( obj , cls . deserialize ( obj . serialize ( ) ) ) [EOL] if isinstance ( obj , Hashable ) : [EOL] self . assertEqual ( hash ( obj ) , hash ( cls . deserialize ( obj . serialize ( ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from chain . utils . elliptic import generate_keypair , sign , verify [EOL] from chain . utils . log import logger [EOL] [EOL] from chain . tests import TestCase [EOL] [EOL] [EOL] class TestUtils ( TestCase ) : [EOL] def test_elliptic ( self ) : [EOL] prv , pub = generate_keypair ( ) [EOL] msg = [string] * [number] * [number] * [number] [comment] [EOL] self . assertTrue ( verify ( pub , sign ( prv , msg ) , msg ) ) [EOL] [EOL] def test_log ( self ) : [EOL] print ( ) [EOL] [EOL] logger . info ( [string] ) [EOL] logger . warning ( [string] ) [EOL] logger . error ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . info ( self ) [EOL] logger . error ( [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Literal , Any [EOL] import typing [EOL] import typing_extensions [EOL] import chain [EOL] import time [EOL] [EOL] from chain import Block , BlockChain [EOL] [EOL] from . import TestCase [EOL] [EOL] [EOL] class TestBlockChain ( TestCase ) : [EOL] def test_block ( self ) : [EOL] args = ( [number] , [string] , int ( time . time ( ) ) , [string] ) [EOL] nonce = [number] [EOL] target = [string] * [number] [EOL] hash = Block . calculate_hash ( * args , nonce , target ) [EOL] b = Block ( * args , nonce = nonce , target = target , hash = hash ) [EOL] self . assertSerializable ( Block , b , globals ( ) ) [EOL] self . assertTrue ( b . valid ) [EOL] b . hash = [string] [EOL] self . assertFalse ( b . valid ) [EOL] [EOL] def test_blockchain ( self ) : [EOL] bc = BlockChain ( ) [EOL] blocks_to_mine = [number] [EOL] for i in range ( blocks_to_mine ) : [EOL] bc . mine ( [string] ) [EOL] [EOL] self . assertSerializable ( BlockChain , bc , globals ( ) ) [EOL] [EOL] self . assertTrue ( bc . validate_blocks ( [number] , [number] ) ) [EOL] self . assertTrue ( bc . validate_blocks ( [number] , [number] ) ) [EOL] self . assertTrue ( bc . is_valid_chain ( ) ) [EOL] self . assertFalse ( bc . replace ( bc ) ) [EOL] self . assertEqual ( bc . blocks , bc . blocks ) [EOL] self . assertIs ( bc [ [number] ] , bc . blocks [ [number] ] ) [EOL] self . assertEqual ( len ( bc ) , blocks_to_mine + [number] ) [EOL] self . assertEqual ( bc [ [number] : - [number] : [number] ] , bc . blocks [ [number] : - [number] : [number] ] ) [EOL] self . assertEqual ( bc [ : : - [number] ] , bc . blocks [ : : - [number] ] ) [EOL] [EOL] last_block = bc [ - [number] ] [EOL] bc1 = BlockChain ( ) [EOL] bc1 . mine ( [string] ) [EOL] self . assertFalse ( bc1 . add_block ( last_block ) ) [EOL] self . assertNotEqual ( bc , bc1 ) [EOL] self . assertFalse ( bc . replace ( bc1 ) ) [EOL] self . assertEqual ( bc [ - [number] ] , last_block ) [EOL] self . assertTrue ( bc1 . replace ( bc ) ) [EOL] self . assertEqual ( bc1 , bc ) [EOL] print ( ) [EOL] for i in range ( blocks_to_mine ) : [EOL] bc1 . mine ( [string] ) [EOL] [EOL] self . assertIs ( bc1 . blocks , bc . blocks ) [EOL] self . assertEqual ( bc , bc1 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,builtins.int,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,builtins.int,typing_extensions.Literal]$ 0 $builtins.int$ 0 $builtins.str$ 0 0 $chain.block.Block$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,builtins.int,typing_extensions.Literal]$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $chain.block.Block$ 0 0 0 0 0 0 0 0 0 0 $chain.block.Block$ 0 0 0 0 $chain.block.Block$ 0 $builtins.str$ 0 0 0 0 0 0 0 $chain.block.Block$ 0 0 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 $chain.blockchain.BlockChain$ 0 0 0 0 0 0 0 0 $chain.blockchain.BlockChain$ 0 $chain.blockchain.BlockChain$ 0 0