from typing import Any [EOL] import picamraw [EOL] import typing [EOL] from . import resolution as module [EOL] [EOL] [EOL] class TestPiResolution : [EOL] def test_pad__adds_default_padding ( self ) : [EOL] actual = module . PiResolution ( [number] , [number] ) . pad ( ) [EOL] expected = module . PiResolution ( width = [number] , height = [number] ) [EOL] [EOL] assert actual == expected [EOL] [EOL] def test_pad__adds_custom_padding ( self ) : [EOL] actual = module . PiResolution ( [number] , [number] ) . pad ( [number] , [number] ) [EOL] expected = module . PiResolution ( width = [number] , height = [number] ) [EOL] [EOL] assert actual == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.resolution.PiResolution$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $picamraw.resolution.PiResolution$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.resolution.PiResolution$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $picamraw.resolution.PiResolution$ 0
from . main import PiRawBayer [comment] [EOL] from . constants import PiCameraVersion [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any , Type [EOL] import picamraw [EOL] import typing [EOL] import unittest [EOL] import pkg_resources [EOL] from unittest . mock import sentinel , MagicMock [EOL] [EOL] import numpy as np [EOL] import pytest [EOL] [EOL] from . constants import BayerOrder , PiCameraVersion [EOL] from . import main as module [EOL] [EOL] picamv2_jpeg_path = pkg_resources . resource_filename ( __name__ , [string] ) [EOL] picamv2_BGGR_bayer_array_path = pkg_resources . resource_filename ( __name__ , [string] ) [EOL] picamv2_3d_path = pkg_resources . resource_filename ( __name__ , [string] ) [EOL] picamv2_rgb_path = pkg_resources . resource_filename ( __name__ , [string] ) [EOL] [EOL] [EOL] class TestGetRawBayerBytes : [EOL] def test_get_raw_bayer_bytes ( self , mocker ) : [EOL] mock_stream_with_correct_prefix = [string] [EOL] [EOL] mocker . patch . object ( module , [string] ) . return_value = [number] [EOL] [EOL] actual = module . _get_raw_bayer_bytes ( jpeg_data_as_bytes = mock_stream_with_correct_prefix , camera_version = sentinel . camera_version , sensor_mode = sentinel . sensor_mode , ) [EOL] [EOL] assert actual == [string] [EOL] [EOL] def test_get_raw_bayer_bytes__raises_if_missing_prefix ( self , mocker ) : [EOL] with pytest . raises ( ValueError ) : [EOL] mock_stream_with_missing_prefix = [string] [EOL] [EOL] mocker . patch . object ( module , [string] ) . return_value = [number] [EOL] module . _get_raw_bayer_bytes ( jpeg_data_as_bytes = mock_stream_with_missing_prefix , camera_version = sentinel . camera_version , sensor_mode = sentinel . sensor_mode , ) [EOL] [EOL] [EOL] class TestGetRawBlockSize : [EOL] @ pytest . mark . parametrize ( [string] , [ ( camera_version_enum , sensor_mode ) for camera_version_enum in PiCameraVersion for sensor_mode in range ( [number] , [number] ) ] ) def test_get_raw_block_size__has_values_for_all_camera_versions_and_sensor_modes ( self , camera_version , sensor_mode ) : [EOL] actual = module . _get_raw_block_size ( camera_version , sensor_mode ) [EOL] assert actual is not None [EOL] [EOL] [EOL] class TestExtractRawFromJpeg : [EOL] bayer_array , bayer_order = module . extract_raw_from_jpeg ( filepath = picamv2_jpeg_path , camera_version = PiCameraVersion . V2 , sensor_mode = [number] ) [EOL] [EOL] def test_extracts_bayer_order ( self ) : [EOL] assert self . bayer_order == BayerOrder . BGGR [EOL] [EOL] def test_extracts_raw_data ( self ) : [EOL] [comment] [EOL] assert self . bayer_array [ [number] ] [ [number] ] == [number] [EOL] assert self . bayer_array [ - [number] ] [ - [number] ] == [number] [EOL] [EOL] [comment] [EOL] actual = self . bayer_array [EOL] expected = np . load ( picamv2_BGGR_bayer_array_path ) [EOL] [EOL] np . testing . assert_array_equal ( actual , expected ) [EOL] [EOL] [EOL] class TestBayerArrayTo3D : [EOL] bayer_array = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] , ] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( BayerOrder . RGGB , np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , ] ) ) , ( BayerOrder . GBRG , np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , ] ) ) , ( BayerOrder . BGGR , np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , ] ) ) , ( BayerOrder . GRBG , np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , ] ) ) , ] ) def test_splits_to_rgb_using_bayer_order ( self , bayer_order , expected ) : [EOL] actual = module . bayer_array_to_3d ( self . bayer_array , bayer_order ) [EOL] [EOL] np . testing . assert_array_equal ( actual , expected ) [EOL] [EOL] def test_integration ( self ) : [EOL] bayer_array = np . load ( picamv2_BGGR_bayer_array_path ) [EOL] actual = module . bayer_array_to_3d ( bayer_array , BayerOrder . BGGR ) [EOL] [EOL] expected = np . load ( picamv2_3d_path ) [EOL] [EOL] np . testing . assert_array_equal ( actual , expected ) [EOL] [EOL] [EOL] class TestBayerArrayToRGB : [EOL] @ pytest . mark . parametrize ( [string] , [ ( BayerOrder . RGGB , np . array ( [ [ [ [number] , [number] , [number] ] ] , ] ) ) , ( BayerOrder . GBRG , np . array ( [ [ [ [number] , [number] , [number] ] ] , ] ) ) , ( BayerOrder . BGGR , np . array ( [ [ [ [number] , [number] , [number] ] ] , ] ) ) , ( BayerOrder . GRBG , np . array ( [ [ [ [number] , [number] , [number] ] ] , ] ) ) , ] ) def test_splits_to_rgb_using_bayer_order ( self , bayer_order , expected ) : [EOL] bayer_array = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] , ] ) [EOL] actual = module . bayer_array_to_rgb ( bayer_array , bayer_order ) [EOL] [EOL] np . testing . assert_array_equal ( actual , expected ) [EOL] [EOL] def test_uneven_shape_raises ( self ) : [EOL] bayer_array = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , ] ) [EOL] [EOL] [comment] [EOL] expected_error_message = [string] [EOL] with pytest . raises ( ValueError , match = expected_error_message ) : [EOL] module . bayer_array_to_rgb ( bayer_array , BayerOrder . RGGB ) [EOL] [EOL] def test_integration ( self ) : [EOL] bayer_array = np . load ( picamv2_BGGR_bayer_array_path ) [EOL] actual = module . bayer_array_to_rgb ( bayer_array , BayerOrder . BGGR ) [EOL] [EOL] expected = np . load ( picamv2_rgb_path ) [EOL] [EOL] np . testing . assert_array_equal ( actual , expected ) [EOL] [EOL] [EOL] class TestUnpack10BitValues : [EOL] def test_unpack_10bit_values ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] input_five_byte_set = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] expected_ten_bit_outputs = [ [number] , [number] , [number] , [number] , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pixel_bytes_2d = np . array ( [ input_five_byte_set * [number] , input_five_byte_set * [number] , ] , dtype = np . uint8 , ) [EOL] [EOL] expected = np . array ( [ expected_ten_bit_outputs * [number] , expected_ten_bit_outputs * [number] , ] , dtype = np . uint16 , ) [EOL] [EOL] actual = module . _unpack_10bit_values ( mock_pixel_bytes_2d ) [EOL] [EOL] np . testing . assert_array_equal ( actual , expected ) [EOL] [EOL] def test_unpack_10bit_values__correct_shape_doesnt_raise ( self ) : [EOL] mock_pixel_bytes_2d = np . zeros ( ( [number] , [number] ) ) . astype ( np . uint8 ) [EOL] module . _unpack_10bit_values ( mock_pixel_bytes_2d ) [EOL] [EOL] def test_unpack_10bit_values__incorrect_shape_raises ( self ) : [EOL] [comment] [EOL] expected_error_message = [string] [EOL] with pytest . raises ( ValueError , match = expected_error_message ) : [EOL] mock_pixel_bytes_2d = np . zeros ( ( [number] , [number] ) ) [EOL] module . _unpack_10bit_values ( mock_pixel_bytes_2d ) [EOL] [EOL] [EOL] class TestPixelBytesToArray : [EOL] def test_pixel_bytes_to_array ( self ) : [EOL] mock_header = MagicMock ( height = [number] , width = [number] , padding_right = [number] , padding_down = [number] , ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] five_byte_group = [ [number] , [number] , [number] , [number] , [number] ] [EOL] expected_output_byte = [number] [EOL] [comment] [EOL] [comment] [EOL] mock_32_byte_row = five_byte_group * [number] + [ [number] ] * [number] [EOL] mock_1D_pixel_array = np . array ( mock_32_byte_row * [number] , dtype = np . uint8 ) [EOL] [EOL] [comment] [EOL] expected = np . ones ( ( [number] , [number] ) , dtype = np . uint16 ) * expected_output_byte [EOL] [EOL] actual = module . _pixel_bytes_to_array ( mock_1D_pixel_array , mock_header ) [EOL] [EOL] np . testing . assert_array_equal ( actual , expected ) [EOL] [EOL] [EOL] [comment] [EOL] class TestPiRawBayer : [EOL] def test_extracts_raw_data ( self ) : [EOL] raw_bayer = module . PiRawBayer ( filepath = picamv2_jpeg_path , camera_version = PiCameraVersion . V2 , sensor_mode = [number] ) [EOL] [EOL] assert raw_bayer . bayer_order == BayerOrder . BGGR [EOL] [EOL] [comment] [EOL] assert raw_bayer . bayer_array [ [number] ] [ [number] ] == [number] [EOL] assert raw_bayer . bayer_array [ - [number] ] [ - [number] ] == [number] [EOL] [EOL] [comment] [EOL] actual = raw_bayer . bayer_array [EOL] expected = np . load ( picamv2_BGGR_bayer_array_path ) [EOL] [EOL] np . testing . assert_array_equal ( actual , expected ) [EOL] [EOL] def test_rgb_array_property ( self , mocker ) : [EOL] mocker . patch . object ( module , [string] ) . return_value = sentinel . rgb_array [EOL] [EOL] raw_bayer = module . PiRawBayer ( filepath = picamv2_jpeg_path , camera_version = PiCameraVersion . V2 , sensor_mode = [number] ) [EOL] [EOL] assert raw_bayer . to_rgb ( ) == sentinel . rgb_array [EOL] [EOL] def test_array_3d_property ( self , mocker ) : [EOL] mocker . patch . object ( module , [string] ) . return_value = sentinel . array_3d [EOL] [EOL] raw_bayer = module . PiRawBayer ( filepath = picamv2_jpeg_path , camera_version = PiCameraVersion . V2 , sensor_mode = [number] ) [EOL] [EOL] assert raw_bayer . to_3d ( ) == sentinel . array_3d [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.main.PiRawBayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.main.PiRawBayer$ 0 0 0 0 0 0 0 0 0 0 0 $picamraw.main.PiRawBayer$ 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.main.PiRawBayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.main.PiRawBayer$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.main.PiRawBayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.main.PiRawBayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.main.PiRawBayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $picamraw.main.PiRawBayer$ 0 0 0 0 0 0 0 0 0
import typing [EOL] from collections import namedtuple [EOL] [EOL] [EOL] class PiResolution ( namedtuple ( [string] , ( [string] , [string] ) ) ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( ) [comment] [EOL] [EOL] def pad ( self , pad_width = [number] , pad_height = [number] ) : [EOL] [docstring] [EOL] return PiResolution ( width = ( ( self . width + ( pad_width - [number] ) ) // pad_width ) * pad_width , height = ( ( self . height + ( pad_height - [number] ) ) // pad_height ) * pad_height , ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . width , self . height ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple [EOL] import picamraw [EOL] import typing [EOL] from enum import Enum [EOL] [EOL] [EOL] class PiCameraVersion ( Enum ) : [EOL] V1 = [string] [EOL] V2 = [string] [EOL] [EOL] [EOL] class BayerOrder ( Enum ) : [EOL] [docstring] [EOL] [EOL] RGGB = [string] [EOL] GBRG = [string] [EOL] BGGR = [string] [EOL] GRBG = [string] [EOL] [EOL] [EOL] BAYER_ORDER_TO_RGB_CHANNEL_COORDINATES = { BayerOrder . RGGB : ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , BayerOrder . GBRG : ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , BayerOrder . BGGR : ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , BayerOrder . GRBG : ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[picamraw.constants.BayerOrder,typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0