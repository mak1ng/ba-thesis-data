from typing import List [EOL] import src [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] from src . game import Game [EOL] from src . player import Player [EOL] [EOL] def header ( ) : [EOL] [docstring] [EOL] print ( [string] * [number] ) [EOL] print ( [string] ) [EOL] print ( [string] * [number] ) [EOL] print ( [string] ) [EOL] [EOL] def menu ( ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] [EOL] def options ( ) : [EOL] [docstring] [EOL] items = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] line1 = items [ [number] : : [number] ] [EOL] line2 = items [ [number] : : [number] ] [EOL] line3 = items [ [number] : : [number] ] [EOL] [EOL] print ( [string] ) [EOL] for lin1 , lin2 , lin3 in zip ( line1 , line2 , line3 ) : [EOL] print ( f"{ lin1 : [string] }{ lin2 : [string] }{ lin3 : [string] }" ) [EOL] print ( [string] ) [EOL] [EOL] def menu_input ( prompt ) : [EOL] [docstring] [EOL] while True : [EOL] try : [EOL] option = Game . menu_input ( prompt ) [EOL] return option [EOL] except ValueError as exception : [EOL] print ( str ( exception ) ) [EOL] [EOL] def user_name_input ( prompt ) : [EOL] [docstring] [EOL] while True : [EOL] try : [EOL] player = Player ( [string] ) [EOL] player . name = input ( prompt ) [EOL] return player [EOL] except ValueError as exception : [EOL] print ( str ( exception ) ) [EOL] [EOL] def rounds_input ( prompt , game ) : [EOL] [docstring] [EOL] while True : [EOL] try : [EOL] rounds = input ( prompt ) [EOL] if len ( rounds ) > [number] : [EOL] game . rounds = rounds [EOL] return game . rounds [EOL] else : [EOL] return game . rounds [EOL] except ValueError as exception : [EOL] print ( str ( exception ) ) [EOL] [EOL] def items_input ( prompt ) : [EOL] [docstring] [EOL] while True : [EOL] try : [EOL] option = Player . pick_element ( prompt , Game . items ) [EOL] return option [EOL] except ValueError as exception : [EOL] print ( str ( exception ) ) [EOL] [EOL] def start ( ) : [EOL] [docstring] [EOL] [comment] [EOL] header ( ) [EOL] [EOL] [comment] [EOL] menu ( ) [EOL] [EOL] exit_game = False [EOL] [EOL] [comment] [EOL] menu_choice = menu_input ( [string] ) [EOL] [EOL] while not exit_game : [EOL] [EOL] if menu_choice == [number] : [EOL] [comment] [EOL] options ( ) [EOL] [EOL] [comment] [EOL] player = user_name_input ( [string] ) [EOL] [EOL] [comment] [EOL] game = Game ( player ) [EOL] [EOL] [comment] [EOL] rounds = rounds_input ( [string] , game ) [EOL] [EOL] [comment] [EOL] for game_rounds in range ( rounds ) : [EOL] print ( f" [string] { game_rounds + [number] } [string] " ) [EOL] game . player . choice = items_input ( [string] ) [EOL] computer_choice = game . computer_choice [EOL] print ( f" [string] { computer_choice }" ) [EOL] print ( f" [string] { game . winner ( ) }" ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] if game . player . score > game . computer_score : [EOL] print ( f" [string] { game . player . name } [string] " ) [EOL] print ( f" [string] { game . player . score } [string] { game . computer_score }" ) [EOL] elif game . player . score < game . computer_score : [EOL] print ( [string] ) [EOL] print ( f" [string] { game . computer_score } [string] { game . player . score }" ) [EOL] elif game . player . score == game . computer_score : [EOL] print ( f" [string] " ) [EOL] [EOL] [comment] [EOL] play_again = menu_input ( [string] ) [EOL] [EOL] if play_again == [number] : [EOL] menu_choice = [number] [EOL] continue [EOL] elif play_again == [number] : [EOL] exit_game = True [EOL] elif menu_choice == [number] : [EOL] exit_game = True [EOL] [EOL] if __name__ == [string] : [EOL] start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any [EOL] import src [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] [comment] [EOL] from unittest import mock [EOL] from unittest . mock import MagicMock [EOL] [EOL] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [comment] [EOL] from src import player [EOL] from src import game [EOL] [EOL] @ pytest . fixture def player_fixture ( ) : [EOL] [docstring] [EOL] human_player = player . Player ( [string] ) [EOL] human_player . choice = [string] [EOL] return human_player [EOL] [EOL] def test_player_instance ( player_fixture ) : [EOL] [docstring] [EOL] assert player_fixture is not None [EOL] [EOL] def test_player_score ( player_fixture ) : [EOL] [docstring] [EOL] assert player_fixture . score == [number] [EOL] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] player_fixture . score = [string] [EOL] assert str ( exception . value ) == [string] [EOL] [EOL] def test_player_name ( player_fixture ) : [EOL] [docstring] [EOL] assert player_fixture . name == [string] [EOL] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] player_fixture . name = [number] [EOL] assert str ( exception . value ) == [string] [EOL] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] player_fixture . name = [string] [EOL] assert str ( exception . value ) == [string] [EOL] [EOL] def test_player_choice ( player_fixture ) : [EOL] [docstring] [EOL] assert player_fixture . choice == [string] [EOL] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] player_fixture . choice = [number] [EOL] assert str ( exception . value ) == [string] [EOL] [EOL] @ mock . patch ( [string] ) def test_pick_element ( fake_input ) : [EOL] [docstring] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] fake_input . return_value = [string] [EOL] result = player . Player . pick_element ( [string] , game . Game . items ) [EOL] assert result == [string] [EOL] [EOL] fake_input . return_value = [string] [EOL] result = player . Player . pick_element ( [string] , game . Game . items ) [EOL] assert result == [string] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import src [EOL] [docstring] [EOL] [comment] [EOL] from src . game import Game [EOL] from src . player import Player [EOL] [EOL] def test_game ( ) : [EOL] [docstring] [EOL] [comment] [EOL] player = Player ( [string] ) [EOL] [EOL] [comment] [EOL] player . choice = [string] [EOL] [EOL] game = Game ( player ) [EOL] game . winner ( ) == [string] [EOL] print ( f" [string] { game . computer_choice }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] from typing import List [EOL] import src [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] from importlib import reload [EOL] from unittest import mock [EOL] from importlib import reload [EOL] from unittest . mock import MagicMock [EOL] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [comment] [EOL] from src import game [EOL] from src import player [EOL] [EOL] @ pytest . fixture def game_instance ( ) : [EOL] [docstring] [EOL] [comment] [EOL] human_player = player . Player ( [string] ) [EOL] [EOL] [comment] [EOL] game_instance = game . Game ( human_player ) [EOL] [EOL] return game_instance [EOL] [EOL] def test_game_instance ( game_instance ) : [EOL] [docstring] [EOL] assert game_instance is not None [EOL] [EOL] def test_game_items ( ) : [EOL] [docstring] [EOL] assert type ( game . Game . items ) == list [EOL] assert len ( game . Game . items ) == [number] [EOL] [EOL] def test_game_rounds ( game_instance ) : [EOL] [docstring] [EOL] assert type ( game_instance . rounds ) == int [EOL] assert game_instance . rounds == [number] [EOL] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] game_instance . rounds = [string] [EOL] assert str ( exception . value ) == [string] [EOL] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] game_instance . rounds = [string] [EOL] expected = [string] [EOL] assert str ( exception . value ) == expected [EOL] [EOL] game_instance . rounds = [number] [EOL] assert game_instance . rounds == [number] [EOL] [EOL] def test_computer_choice ( game_instance ) : [EOL] [docstring] [EOL] with mock . patch ( [string] , lambda seq : seq [ [number] ] ) : [EOL] reload ( game ) [EOL] human = player . Player ( [string] ) [EOL] new_game = game . Game ( human ) [EOL] assert new_game . computer_choice == [string] [EOL] reload ( game ) [EOL] [EOL] def test_calculate ( game_instance ) : [EOL] [docstring] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] result = game_instance . _calculate ( ) [EOL] assert str ( exception . value ) == [string] [EOL] [EOL] [comment] [EOL] game_instance . player . choice = [string] [EOL] result = game_instance . _calculate ( ) [EOL] assert type ( result ) == list [EOL] assert len ( result ) == [number] [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] assert result == expected [EOL] [EOL] def test_winner ( game_instance ) : [EOL] [docstring] [EOL] [comment] [EOL] with mock . patch ( [string] , lambda seq : [string] ) : [EOL] [comment] [EOL] reload ( game ) [EOL] [EOL] [comment] [EOL] human = player . Player ( [string] ) [EOL] new_game = game . Game ( human ) [EOL] [EOL] new_game . player . choice = [string] [EOL] computer_choice = new_game . computer_choice [EOL] result = new_game . winner ( ) [EOL] assert result == [string] [EOL] reload ( game ) [EOL] [EOL] [comment] [EOL] with mock . patch ( [string] , lambda seq : [string] ) : [EOL] [comment] [EOL] reload ( game ) [EOL] [EOL] [comment] [EOL] human = player . Player ( [string] ) [EOL] new_game = game . Game ( human ) [EOL] [EOL] new_game . player . choice = [string] [EOL] computer_choice = new_game . computer_choice [EOL] result = new_game . winner ( ) [EOL] assert result == [string] [EOL] reload ( game ) [EOL] [EOL] [comment] [EOL] with mock . patch ( [string] , lambda seq : [string] ) : [EOL] [comment] [EOL] reload ( game ) [EOL] [EOL] [comment] [EOL] human = player . Player ( [string] ) [EOL] new_game = game . Game ( human ) [EOL] [EOL] new_game . player . choice = [string] [EOL] computer_choice = new_game . computer_choice [EOL] result = new_game . winner ( ) [EOL] assert result == [string] [EOL] [comment] [EOL] assert new_game . player . score > new_game . computer_score [EOL] reload ( game ) [EOL] [EOL] @ mock . patch ( [string] ) def test_menu_input ( fake_input ) : [EOL] [docstring] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] fake_input . return_value = [string] [EOL] result = game . Game . menu_input ( [string] ) [EOL] assert str ( exception . value ) == [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exception : [EOL] fake_input . return_value = [string] [EOL] result = game . Game . menu_input ( [string] ) [EOL] expected = [string] [EOL] assert str ( exception . value ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] from typing import List [EOL] [EOL] class Player : [EOL] [docstring] [EOL] def __init__ ( self , name ) : [EOL] self . _name = name [EOL] self . _choice = None [EOL] self . _score = [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ name . setter def name ( self , value ) : [EOL] [docstring] [EOL] if type ( value ) != str : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if value . isdigit ( ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . _name = value [EOL] [EOL] @ property def score ( self ) : [EOL] [docstring] [EOL] return self . _score [EOL] [EOL] @ score . setter def score ( self , value ) : [EOL] [docstring] [EOL] if type ( value ) != int : [EOL] raise ValueError ( [string] ) [EOL] self . _score = value [EOL] [EOL] @ property def choice ( self ) : [EOL] [docstring] [EOL] return self . _choice [EOL] [EOL] @ choice . setter def choice ( self , value ) : [EOL] [docstring] [EOL] if type ( value ) != str : [EOL] raise ValueError ( [string] ) [EOL] self . _choice = value [EOL] [EOL] @ staticmethod def pick_element ( prompt , elements ) : [EOL] [docstring] [EOL] pick = input ( prompt ) . title ( ) [EOL] if pick not in elements : [EOL] raise ValueError ( [string] ) [EOL] return pick [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
	0
from typing import List [EOL] import src [EOL] import builtins [EOL] import typing [EOL] import player [EOL] [docstring] [EOL] [comment] [EOL] from typing import List [EOL] import random [EOL] [EOL] [comment] [EOL] from . player import Player [EOL] [EOL] class Game : [EOL] [docstring] [EOL] [comment] [EOL] items = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , player , rounds = [number] ) : [EOL] self . _player = player [EOL] self . _rounds = rounds [EOL] self . _computer_choice = [string] [EOL] self . _computer_score = [number] [EOL] [EOL] @ property def player ( self ) : [EOL] [docstring] [EOL] return self . _player [EOL] [EOL] @ player . setter def player ( self , value ) : [EOL] [docstring] [EOL] if not isinstance ( value , Player ) : [EOL] raise ValueError ( [string] ) [EOL] self . _player = value [EOL] [EOL] @ property def computer_choice ( self ) : [EOL] [docstring] [EOL] self . _computer_choice = random . choice ( Game . items ) [EOL] return self . _computer_choice [EOL] [EOL] @ property def computer_score ( self ) : [EOL] [docstring] [EOL] return self . _computer_score [EOL] [EOL] @ property def rounds ( self ) : [EOL] [docstring] [EOL] return self . _rounds [EOL] [EOL] @ rounds . setter def rounds ( self , value ) : [EOL] [docstring] [EOL] if type ( value ) == str and not value . isdigit ( ) : [EOL] raise ValueError ( [string] ) [EOL] value = int ( value ) [EOL] [EOL] if value < [number] or value > [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . _rounds = value [EOL] [EOL] def _calculate ( self ) : [EOL] [docstring] [EOL] if not self . player . choice or self . player . choice not in Game . items : [EOL] raise ValueError ( [string] ) [EOL] [EOL] player_index = Game . items . index ( self . player . choice ) [EOL] [EOL] return Game . items [ player_index + [number] : player_index + [number] ] [EOL] [EOL] def winner ( self ) : [EOL] [docstring] [EOL] items = self . _calculate ( ) [EOL] if self . player . choice == self . _computer_choice : [EOL] return [string] [EOL] elif self . _computer_choice in self . _calculate ( ) : [EOL] self . _computer_score += [number] [EOL] return f" [string] " [EOL] else : [EOL] self . player . score += [number] [EOL] return f"{ self . player . name } [string] " [EOL] [EOL] @ staticmethod def menu_input ( prompt ) : [EOL] [docstring] [EOL] option = input ( prompt ) [EOL] if type ( option ) == str and not option . isdigit ( ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] option_int = int ( option ) [EOL] [EOL] if option_int < [number] or option_int > [number] : [EOL] raise ValueError ( [string] ) [EOL] return option_int [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Game.player.Player$ 0 0 0 0 0 0 0 0 0 $src.player.Player$ 0 $Game.player.Player$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0