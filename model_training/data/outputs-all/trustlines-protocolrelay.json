[comment] [EOL] [EOL] from typing import List , Any [EOL] import tests [EOL] import typing [EOL] import requests [EOL] import functools [EOL] [docstring] [EOL] import functools [EOL] import time [EOL] from typing import Any , List [EOL] [EOL] import requests [EOL] [EOL] [EOL] class Client : [EOL] def __init__ ( self , host ) : [EOL] self . host = host [EOL] [EOL] def post ( self , path , data ) : [EOL] r = requests . post ( self . host + path , json = data ) [EOL] r . raise_for_status ( ) [EOL] return r . json ( ) [EOL] [EOL] def get ( self , path , params = None ) : [EOL] r = requests . get ( self . build_url ( path ) , params = params ) [EOL] r . raise_for_status ( ) [EOL] return r . json ( ) [EOL] [EOL] def build_url ( self , path ) : [EOL] return self . host + path [EOL] [EOL] def networks ( self ) : [EOL] return self . get ( [string] ) [EOL] [EOL] def users ( self , network ) : [EOL] return self . get ( f" [string] { network } [string] " ) [EOL] [EOL] def trustlines ( self , network , user ) : [EOL] return self . get ( f" [string] { network } [string] { user } [string] " ) [EOL] [EOL] def close_trustline_path_info ( self , network , user , other_user ) : [EOL] return self . post ( f" [string] { network } [string] " , { [string] : user , [string] : other_user } , ) [EOL] [EOL] def transfer_details ( self , block_hash , log_index ) : [EOL] details = self . get ( f" [string] " , params = { [string] : block_hash , [string] : log_index } ) [EOL] return details [ [number] ] [EOL] [EOL] def transfer_status ( self , transaction_hash ) : [EOL] status = self . get ( f" [string] { transaction_hash } [string] " ) [EOL] return status [EOL] [EOL] def transfers ( self , network ) : [EOL] return self . get ( f" [string] { network } [string] " , params = { [string] : [string] } ) [EOL] [EOL] def user_events ( self , network , user ) : [EOL] return self . get ( f" [string] { user } [string] " ) [EOL] [EOL] [EOL] def time_it ( fun ) : [EOL] start = time . time ( ) [EOL] fun ( ) [EOL] return time . time ( ) - start [EOL] [EOL] [EOL] def run_performance_test ( calls , * , wait_between_calls = [number] ) : [EOL] print ( [string] ) [EOL] [EOL] def run ( call ) : [EOL] dur = time_it ( call ) [EOL] time . sleep ( wait_between_calls ) [EOL] return dur [EOL] [EOL] durations = [ run ( call ) for call in calls ] [EOL] [EOL] print ( [string] ) [EOL] print ( f" [string] { max ( durations ) }" ) [EOL] print ( f" [string] { min ( durations ) }" ) [EOL] print ( f" [string] { sum ( durations ) / len ( durations ) }" ) [EOL] [EOL] [EOL] def run_all_close_trustline_path_info ( client ) : [EOL] [docstring] [EOL] all_networks = client . networks ( ) [EOL] for network_info in all_networks : [EOL] print ( [string] , network_info ) [EOL] network_address = network_info [ [string] ] [EOL] [EOL] users = client . users ( network_address ) [EOL] print ( f" [string] { len ( users ) } [string] " ) [EOL] for user in users : [EOL] trustlines = client . trustlines ( network_address , user ) [EOL] print ( f" [string] { user } [string] { len ( trustlines ) } [string] " ) [EOL] for t in trustlines : [EOL] res = client . close_trustline_path_info ( network_address , user , t [ [string] ] ) [EOL] if res . get ( [string] ) : [EOL] print ( res , t ) [EOL] [EOL] [EOL] def show_all_user_events ( client ) : [EOL] all_networks = client . networks ( ) [EOL] for network_info in all_networks : [EOL] print ( [string] , network_info ) [EOL] network_address = network_info [ [string] ] [EOL] [EOL] users = client . users ( network_address ) [EOL] print ( f" [string] { len ( users ) } [string] " ) [EOL] for user in users : [EOL] events = client . user_events ( network_address , user ) [EOL] print ( user , network_address , events ) [EOL] [EOL] [EOL] def performance_test_transfer_details ( client ) : [EOL] networks = [ network [ [string] ] for network in client . networks ( ) ] [EOL] print ( f" [string] { len ( networks ) } [string] " ) [EOL] [EOL] transfers = [ ] [EOL] for network in networks : [EOL] transfers . extend ( client . transfers ( network ) ) [EOL] [EOL] print ( f" [string] { len ( transfers ) } [string] " ) [EOL] [EOL] calls = [ functools . partial ( client . transfer_details , transfer [ [string] ] , transfer [ [string] ] ) for transfer in transfers ] [EOL] [EOL] run_performance_test ( calls ) [EOL] [EOL] [EOL] def performance_test_transfer_status ( client ) : [EOL] networks = [ network [ [string] ] for network in client . networks ( ) ] [EOL] print ( f" [string] { len ( networks ) } [string] " ) [EOL] [EOL] transfers = [ ] [EOL] for network in networks : [EOL] transfers . extend ( client . transfers ( network ) ) [EOL] [EOL] print ( f" [string] { len ( transfers ) } [string] " ) [EOL] [EOL] calls = [ functools . partial ( client . transfer_status , transfer [ [string] ] ) for transfer in transfers ] [EOL] [EOL] [comment] [EOL] run_performance_test ( calls , wait_between_calls = [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] client = Client ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] performance_test_transfer_details ( client ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.tlclient.Client$ 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from relay . signing import eth_sign , eth_validate [EOL] [EOL] pytestmark = pytest . mark . unit [EOL] [EOL] [EOL] def test_eth_validate ( test_account ) : [EOL] msg_hash = bytes ( [number] ) [EOL] vrs = eth_sign ( msg_hash , test_account . private_key ) [EOL] assert eth_validate ( msg_hash , vrs , test_account . address ) [EOL] [EOL] [EOL] def test_eth_validate_fail ( test_account ) : [EOL] msg_hash1 = bytes ( [number] ) [EOL] msg_hash2 = [number] . to_bytes ( [number] , byteorder = [string] ) [EOL] vrs = eth_sign ( msg_hash1 , test_account . private_key ) [EOL] assert not eth_validate ( msg_hash2 , vrs , test_account . address ) [EOL] [EOL] [EOL] def test_eth_validate_fail2 ( test_account ) : [EOL] msg_hash = bytes ( [number] ) [EOL] v = [number] [EOL] r = [number] [EOL] s = [number] [EOL] assert not eth_validate ( msg_hash , ( v , r , s ) , test_account . address ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Dict , List , Any , Type , Union [EOL] import tests [EOL] import typing [EOL] import random [EOL] [docstring] [EOL] import abc [EOL] import itertools [EOL] import json [EOL] import os [EOL] import random [EOL] import sys [EOL] [EOL] import click [EOL] import eth_utils [EOL] import tldeploy . core [EOL] from deploy_tools . deploy import wait_for_successful_transaction_receipt [EOL] from web3 import Web3 [EOL] [EOL] [EOL] class TestDataGenerator ( metaclass = abc . ABCMeta ) : [EOL] def __init__ ( self , web3 , contract ) : [EOL] self . web3 = web3 [EOL] self . contract = contract [EOL] [EOL] @ classmethod def name ( cls ) : [EOL] return cls . __name__ [EOL] [EOL] @ abc . abstractmethod def generate_input_data ( self ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def compute_one_result ( self , ** kw ) : [EOL] pass [EOL] [EOL] def make_test_data ( self ) : [EOL] result = [ ] [EOL] for input_data in self . generate_input_data ( ) : [EOL] result . append ( dict ( input_data = input_data , ** self . compute_one_result ( ** input_data ) ) ) [EOL] sys . stdout . write ( [string] ) [EOL] sys . stdout . flush ( ) [EOL] sys . stdout . write ( [string] ) [EOL] return dict ( name = self . name ( ) , data = result ) [EOL] [EOL] [EOL] class CalculateFee ( TestDataGenerator ) : [EOL] def generate_input_data ( self ) : [EOL] prng = random . Random ( [string] ) [EOL] for capacity_imbalance_fee_divisor in [ [number] , [number] , [number] , [number] , [number] ] : [EOL] for imbalance_generated in itertools . chain ( [ [number] , [number] , [number] ] , ( prng . randint ( [number] , [number] ) for _ in range ( [number] ) ) ) : [EOL] yield dict ( imbalance_generated = imbalance_generated , capacity_imbalance_fee_divisor = capacity_imbalance_fee_divisor , ) [EOL] [EOL] def compute_one_result ( self , imbalance_generated , capacity_imbalance_fee_divisor ) : [EOL] return dict ( fees = self . contract . functions . testCalculateFees ( imbalance_generated , capacity_imbalance_fee_divisor ) . call ( ) , fees_reverse = self . contract . functions . testCalculateFeesReverse ( imbalance_generated , capacity_imbalance_fee_divisor ) . call ( ) , ) [EOL] [EOL] [EOL] class ImbalanceGenerated ( TestDataGenerator ) : [EOL] MAX_BALANCE = [number] ** [number] - [number] [EOL] MIN_BALANCE = - MAX_BALANCE [EOL] [EOL] balances = ( MIN_BALANCE , MIN_BALANCE + [number] , - [number] , - [number] , [number] , [number] , [number] , MAX_BALANCE - [number] , MAX_BALANCE , ) [EOL] values = ( [number] , [number] , [number] , [number] , [number] , [number] ** [number] - [number] ) [EOL] [EOL] def generate_input_data ( self ) : [EOL] for balance in self . balances : [EOL] for value in self . values : [EOL] yield dict ( value = value , balance = balance ) [EOL] [EOL] def compute_one_result ( self , value , balance ) : [EOL] return dict ( imbalance_generated = self . contract . functions . testImbalanceGenerated ( value , balance ) . call ( ) ) [EOL] [EOL] [EOL] class Transfer ( TestDataGenerator ) : [EOL] def _gen_addresses ( self , num_addresses ) : [EOL] return [ eth_utils . to_checksum_address ( f" [string] { address : [string] }" ) for address in range ( [number] , num_addresses + [number] ) ] [EOL] [EOL] def generate_input_data ( self ) : [EOL] return itertools . chain ( self . _generate_input_data0 ( ) , self . _generate_input_data1 ( ) ) [EOL] [EOL] def _generate_input_data1 ( self ) : [EOL] [comment] [EOL] prng = random . Random ( [string] ) [EOL] for testdata in self . _generate_input_data0 ( ) : [EOL] num_balances = len ( testdata [ [string] ] ) [EOL] if num_balances != [number] : [comment] [EOL] continue [EOL] balances_before = [ prng . choice ( [ [number] , [number] , - [number] , [number] , - [number] , [number] , - [number] ] ) for _ in range ( num_balances ) ] [EOL] testdata [ [string] ] = balances_before [EOL] yield testdata [EOL] [EOL] def _generate_input_data0 ( self ) : [EOL] for num_hops in range ( [number] , [number] ) : [EOL] addresses = self . _gen_addresses ( num_hops + [number] ) [EOL] balances_before = [ [number] ] * num_hops [EOL] assert len ( addresses ) - [number] == num_hops [EOL] for fees_paid_by in [ [string] , [string] ] : [EOL] for capacity_imbalance_fee_divisor in [ [number] , [number] , [number] ] : [EOL] for value in [ [number] , [number] , [number] ] : [EOL] yield dict ( fees_paid_by = fees_paid_by , value = value , capacity_imbalance_fee_divisor = capacity_imbalance_fee_divisor , addresses = addresses , balances_before = balances_before , ) [EOL] [EOL] def compute_one_result ( self , fees_paid_by , value , capacity_imbalance_fee_divisor , addresses , balances_before , ) : [EOL] self . contract . functions . setCapacityImbalanceFeeDivisor ( capacity_imbalance_fee_divisor ) . transact ( ) [EOL] [EOL] for a , b , balance in zip ( addresses , addresses [ [number] : ] , balances_before ) : [EOL] txid = self . contract . functions . setAccount ( a , b , [number] , [number] , [number] , [number] , False , [number] , balance ) . transact ( ) [EOL] [EOL] [comment] [EOL] wait_for_successful_transaction_receipt ( self . contract . web3 , txid ) [EOL] [EOL] assert fees_paid_by in ( [string] , [string] ) [EOL] if fees_paid_by == [string] : [EOL] fn = self . contract . functions . testTransferSenderPays [EOL] elif fees_paid_by == [string] : [EOL] fn = self . contract . functions . testTransferReceiverPays [EOL] txid = fn ( value , value , addresses ) . transact ( ) [EOL] wait_for_successful_transaction_receipt ( self . contract . web3 , txid ) [EOL] balances = [ self . contract . functions . getAccount ( a , b ) . call ( ) [ - [number] ] for a , b in zip ( addresses , addresses [ [number] : ] ) ] [EOL] [EOL] return dict ( balances_after = balances ) [EOL] [EOL] [EOL] def generate_and_write_testdata ( generator_class , web3 , contract , output_directory ) : [EOL] generator = generator_class ( web3 , contract ) [EOL] print ( f" [string] { generator . name ( ) }" ) [EOL] testdata = generator . make_test_data ( ) [EOL] filename = os . path . join ( output_directory , f"{ generator . name ( ) } [string] " ) [EOL] print ( f" [string] { filename }" ) [EOL] with open ( filename , [string] ) as outfile : [EOL] json . dump ( testdata , outfile , indent = [number] , sort_keys = True ) [EOL] outfile . write ( [string] ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , help = [string] , default = [string] , ) @ click . option ( [string] , help = [string] , default = [string] ) @ click . argument ( [string] , nargs = - [number] ) def main ( url , output_directory , generator_names ) : [EOL] if not os . path . isdir ( output_directory ) : [EOL] click . echo ( [string] ) [EOL] sys . exit ( [number] ) [EOL] web3 = Web3 ( Web3 . HTTPProvider ( url ) ) [EOL] [EOL] def make_contract ( ) : [EOL] return tldeploy . core . deploy_network ( web3 = web3 , name = [string] , symbol = [string] , decimals = [number] , fee_divisor = [number] , currency_network_contract_name = [string] , expiration_time = [number] , ) [EOL] [EOL] name2cls = { cls . name ( ) : cls for cls in ( CalculateFee , ImbalanceGenerated , Transfer ) } [EOL] if not generator_names : [EOL] generator_names = list ( name2cls . keys ( ) ) [EOL] for generator_name in generator_names : [EOL] cls = name2cls [ generator_name ] [EOL] generate_and_write_testdata ( cls , web3 , make_contract ( ) , output_directory = output_directory ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $random.Random$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $random.Random$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import time [EOL] [EOL] import gevent [EOL] import pytest [EOL] [EOL] from relay . network_graph . graph import CurrencyNetworkGraph [EOL] [EOL] [EOL] def link_graph ( proxy , graph , full_sync_interval = None ) : [EOL] if full_sync_interval is not None : [EOL] proxy . start_listen_on_full_sync ( _create_on_full_sync ( graph ) , full_sync_interval ) [EOL] greenlet_balance = proxy . start_listen_on_balance ( _create_on_balance ( graph ) ) [EOL] greenlet_trustline = proxy . start_listen_on_trustline ( _create_on_trustline ( graph ) ) [EOL] return [ greenlet_balance , greenlet_trustline ] [EOL] [EOL] [EOL] def _create_on_balance ( graph ) : [EOL] def update_balance ( event ) : [EOL] graph . update_balance ( event . from_ , event . to , event . value ) [EOL] [EOL] return update_balance [EOL] [EOL] [EOL] def _create_on_trustline ( graph ) : [EOL] def update_trustline ( event ) : [EOL] graph . update_trustline ( event . from_ , event . to , event . creditline_given , event . creditline_received , event . interest_rate_given , event . interest_rate_received , ) [EOL] [EOL] return update_trustline [EOL] [EOL] [EOL] def _create_on_full_sync ( graph ) : [EOL] def update_community ( graph_rep ) : [EOL] graph . gen_network ( graph_rep ) [EOL] [EOL] return update_community [EOL] [EOL] [EOL] @ pytest . fixture ( ) def community_with_trustlines ( currency_network_with_trustlines ) : [EOL] community = CurrencyNetworkGraph ( [number] ) [EOL] community . gen_network ( currency_network_with_trustlines . gen_graph_representation ( ) ) [EOL] greenlets = link_graph ( currency_network_with_trustlines , community ) [EOL] gevent . sleep ( [number] ) [EOL] yield community [EOL] gevent . killall ( greenlets ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def fresh_community ( currency_network ) : [EOL] community = CurrencyNetworkGraph ( [number] ) [EOL] greenlets = link_graph ( currency_network , community ) [EOL] gevent . sleep ( [number] ) [EOL] yield community [EOL] gevent . killall ( greenlets ) [EOL] [EOL] [EOL] def test_path ( community_with_trustlines , accounts ) : [EOL] community = community_with_trustlines [EOL] A , B , C , D , E , * rest = accounts [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [EOL] assert path == [ A , B ] [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , D , [number] ) [EOL] assert path == [ A , E , D ] [EOL] [EOL] [EOL] def test_no_capacity ( community_with_trustlines , accounts ) : [EOL] community = community_with_trustlines [EOL] A , B , C , D , E , * rest = accounts [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , E , [number] ) [EOL] assert path == [ A , E ] [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , E , [number] ) [EOL] assert path == [ ] [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( E , A , [number] ) [EOL] assert path == [ E , A ] [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( E , A , [number] ) [EOL] assert path == [ ] [EOL] [EOL] [EOL] def test_trustline_update ( fresh_community , currency_network , accounts ) : [EOL] A , B , * rest = accounts [EOL] [EOL] currency_network . update_trustline ( A , B , [number] , [number] , [number] , [number] ) [EOL] currency_network . update_trustline ( B , A , [number] , [number] , [number] , [number] ) [EOL] [EOL] gevent . sleep ( [number] ) [EOL] [EOL] account_sum = fresh_community . get_account_sum ( A , B , timestamp = int ( time . time ( ) ) ) [EOL] assert account_sum . creditline_given == [number] [EOL] assert account_sum . creditline_received == [number] [EOL] assert account_sum . interest_rate_given == [number] [EOL] assert account_sum . interest_rate_received == [number] [EOL] [EOL] [EOL] def test_transfer_update ( fresh_community , currency_network , accounts ) : [EOL] A , B , * rest = accounts [EOL] [EOL] currency_network . update_trustline ( A , B , [number] , [number] ) [EOL] currency_network . update_trustline ( B , A , [number] , [number] ) [EOL] currency_network . transfer ( B , [number] , [number] , [ B , A ] ) [EOL] [EOL] gevent . sleep ( [number] ) [EOL] [EOL] account_sum = fresh_community . get_account_sum ( A , B , timestamp = int ( time . time ( ) ) ) [EOL] assert account_sum . creditline_given == [number] [EOL] assert account_sum . creditline_received == [number] [EOL] assert account_sum . balance == [number] [EOL] assert account_sum . creditline_left_given == [number] [EOL] assert account_sum . creditline_left_received == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from relay . blockchain . node import Node , TransactionStatus [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def node ( web3 ) : [EOL] return Node ( web3 ) [EOL] [EOL] [EOL] def test_tx_status_success ( web3 , node , accounts ) : [EOL] tx_hash = web3 . eth . sendTransaction ( { [string] : accounts [ [number] ] , [string] : accounts [ [number] ] , [string] : [number] } ) [EOL] assert node . get_transaction_status ( tx_hash ) == TransactionStatus . SUCCESS [EOL] [EOL] [EOL] def test_tx_status_not_found ( node ) : [EOL] unfindable_hash = [string] + [string] * [number] [EOL] assert node . get_transaction_status ( unfindable_hash ) == TransactionStatus . NOT_FOUND [EOL] [EOL] [EOL] def test_tx_status_pending ( web3 , node , accounts , chain ) : [EOL] chain . disable_auto_mine_transactions ( ) [EOL] [EOL] tx_hash = web3 . eth . sendTransaction ( { [string] : accounts [ [number] ] , [string] : accounts [ [number] ] , [string] : [number] } ) [EOL] assert node . get_transaction_status ( tx_hash ) == TransactionStatus . PENDING [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict , Union [EOL] import tests [EOL] import typing [EOL] import eth_tester [EOL] import pytest [EOL] from tlbin import load_packaged_contracts [EOL] from tldeploy . core import deploy_network , deploy_networks [EOL] from tldeploy . identity import MetaTransaction [EOL] [EOL] from relay . blockchain import currency_network_proxy [EOL] [EOL] EXPIRATION_TIME = [number] [comment] [EOL] [EOL] [EOL] NETWORK_SETTINGS = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : True , [string] : EXPIRATION_TIME , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : False , [string] : EXPIRATION_TIME , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : False , [string] : EXPIRATION_TIME , } , ] [EOL] [EOL] [EOL] [docstring] [EOL] assert eth_tester . backends . pyevm . main . GENESIS_GAS_LIMIT < [number] * [number] ** [number] [EOL] eth_tester . backends . pyevm . main . GENESIS_GAS_LIMIT = [number] * [number] ** [number] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def expiration_time ( ) : [EOL] return EXPIRATION_TIME [EOL] [EOL] [EOL] @ pytest . fixture def maker ( accounts ) : [EOL] [docstring] [EOL] return accounts [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture def maker_key ( account_keys ) : [EOL] [docstring] [EOL] return account_keys [ [number] ] . to_bytes ( ) [EOL] [EOL] [EOL] @ pytest . fixture def taker ( accounts ) : [EOL] [docstring] [EOL] return accounts [ [number] ] [EOL] [EOL] [EOL] class CurrencyNetworkProxy ( currency_network_proxy . CurrencyNetworkProxy ) : [EOL] def setup_trustlines ( self , trustlines ) : [EOL] for ( A , B , clAB , clBA ) in trustlines : [EOL] txid = self . _proxy . functions . setAccount ( A , B , clAB , clBA , [number] , [number] , False , [number] , [number] ) . transact ( ) [EOL] self . _web3 . eth . waitForTransactionReceipt ( txid ) [EOL] [EOL] def setup_trustlines_with_interests_with_updates ( self , trustlines_with_interests ) : [EOL] [comment] [EOL] for ( A , B , clAB , clBA , intAB , intBA ) in trustlines_with_interests : [EOL] self . update_trustline_with_accept ( A , B , clAB , clBA , intAB , intBA ) [EOL] [EOL] def update_trustline ( self , from_ , to , creditline_given , creditline_received , interest_rate_given = None , interest_rate_received = None , is_frozen = False , ) : [EOL] if interest_rate_given is None or interest_rate_received is None : [EOL] txid = self . _proxy . functions . updateCreditlimits ( to , creditline_given , creditline_received ) . transact ( { [string] : from_ } ) [EOL] else : [EOL] txid = self . _proxy . functions . updateTrustline ( to , creditline_given , creditline_received , interest_rate_given , interest_rate_received , is_frozen , ) . transact ( { [string] : from_ } ) [EOL] self . _web3 . eth . waitForTransactionReceipt ( txid ) [EOL] [EOL] def cancel_trustline_update ( self , from_ , to ) : [EOL] txid = self . _proxy . functions . cancelTrustlineUpdate ( to ) . transact ( { [string] : from_ } ) [EOL] self . _web3 . eth . waitForTransactionReceipt ( txid ) [EOL] [EOL] def update_trustline_with_accept ( self , from_ , to , creditline_given , creditline_received , interest_rate_given = None , interest_rate_received = None , is_frozen = False , ) : [EOL] self . update_trustline ( from_ , to , creditline_given , creditline_received , interest_rate_given , interest_rate_received , is_frozen , ) [EOL] self . update_trustline ( to , from_ , creditline_received , creditline_given , interest_rate_received , interest_rate_given , is_frozen , ) [EOL] [EOL] def update_trustline_and_cancel ( self , from_ , to , creditline_given , creditline_received , interest_rate_given = None , interest_rate_received = None , is_frozen = False , ) : [EOL] self . update_trustline ( from_ , to , creditline_given , creditline_received , interest_rate_given , interest_rate_received , is_frozen , ) [EOL] self . cancel_trustline_update ( from_ , to ) [EOL] [EOL] def update_trustline_and_reject ( self , from_ , to , creditline_given , creditline_received , interest_rate_given = None , interest_rate_received = None , is_frozen = False , ) : [EOL] self . update_trustline ( from_ , to , creditline_given , creditline_received , interest_rate_given , interest_rate_received , is_frozen , ) [EOL] self . cancel_trustline_update ( to , from_ ) [EOL] [EOL] def transfer ( self , from_ , value , max_fee , path , extra_data = [string] ) : [EOL] txid = self . _proxy . functions . transfer ( value , max_fee , path , extra_data ) . transact ( { [string] : from_ } ) [EOL] self . _web3 . eth . waitForTransactionReceipt ( txid ) [EOL] [EOL] def transfer_on_path ( self , value , path , max_fee = None , extra_data = [string] ) : [EOL] if max_fee is None : [EOL] max_fee = value [EOL] tx_id = self . _proxy . functions . transfer ( value , max_fee , path , extra_data ) . transact ( { [string] : path [ [number] ] } ) [EOL] self . _web3 . eth . waitForTransactionReceipt ( tx_id ) [EOL] return tx_id [EOL] [EOL] def transfer_receiver_pays_on_path ( self , value , path , max_fee = None , extra_data = [string] ) : [EOL] if max_fee is None : [EOL] max_fee = value [EOL] tx_id = self . _proxy . functions . transferReceiverPays ( value , max_fee , path , extra_data ) . transact ( { [string] : path [ [number] ] } ) [EOL] self . _web3 . eth . waitForTransactionReceipt ( tx_id ) [EOL] return tx_id [EOL] [EOL] def transfer_meta_transaction ( self , value , max_fee , path , extra_data = [string] ) : [EOL] [EOL] function_call = self . _proxy . functions . transfer ( value , max_fee , path , extra_data ) [EOL] meta_transaction = MetaTransaction . from_function_call ( function_call , to = self . address ) [EOL] [EOL] return meta_transaction [EOL] [EOL] def get_balance ( self , from_ , to ) : [EOL] return self . _proxy . functions . balance ( from_ , to ) . call ( ) [EOL] [EOL] def freeze_network ( self ) : [EOL] self . _proxy . functions . freezeNetwork ( ) . transact ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def trustlines ( accounts ) : [EOL] return [ ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) , ] [comment] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def trustlines_with_interests ( accounts ) : [EOL] return [ ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] , [number] , [number] ) , ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] , [number] , [number] ) , ] [comment] [EOL] [EOL] [EOL] def deploy_test_network ( web3 ) : [EOL] return deploy_network ( web3 , [string] , [string] , [number] , fee_divisor = [number] , expiration_time = EXPIRATION_TIME , currency_network_contract_name = [string] , ) [EOL] [EOL] [EOL] def deploy_test_networks ( web3 ) : [EOL] return deploy_networks ( web3 , NETWORK_SETTINGS ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def contracts ( ) : [EOL] return load_packaged_contracts ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def currency_network_abi ( contracts ) : [EOL] return contracts [ [string] ] [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def exchange_abi ( contracts ) : [EOL] return contracts [ [string] ] [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def token_abi ( contracts ) : [EOL] return contracts [ [string] ] [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def testnetwork1_address ( web3 ) : [EOL] return deploy_test_network ( web3 ) . address [EOL] [EOL] [EOL] @ pytest . fixture ( ) def testnetwork2_address ( web3 ) : [EOL] return deploy_test_network ( web3 ) . address [EOL] [EOL] [EOL] @ pytest . fixture ( ) def testnetwork3_address ( web3 ) : [EOL] return deploy_test_network ( web3 ) . address [EOL] [EOL] [EOL] @ pytest . fixture ( ) def testnetworks ( web3 , maker , taker ) : [EOL] ( currency_network_contracts , exchange_contract , unw_eth_contract , ) = deploy_test_networks ( web3 ) [EOL] [EOL] unw_eth_contract . functions . deposit ( ) . transact ( { [string] : taker , [string] : [number] } ) [EOL] [EOL] currency_network = currency_network_contracts [ [number] ] [EOL] currency_network . functions . updateCreditlimits ( maker , [number] , [number] ) . transact ( { [string] : taker } ) [EOL] currency_network . functions . updateCreditlimits ( taker , [number] , [number] ) . transact ( { [string] : maker } ) [EOL] [EOL] return currency_network_contracts , exchange_contract , unw_eth_contract [EOL] [EOL] [EOL] @ pytest . fixture ( ) def exchange_address ( testnetworks ) : [EOL] return testnetworks [ [number] ] . address [EOL] [EOL] [EOL] @ pytest . fixture ( ) def unw_eth_address ( testnetworks ) : [EOL] return testnetworks [ [number] ] . address [EOL] [EOL] [EOL] @ pytest . fixture ( ) def network_addresses_with_exchange ( testnetworks ) : [EOL] return [ network . address for network in testnetworks [ [number] ] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def currency_network ( web3 , currency_network_abi , testnetwork1_address ) : [EOL] currency_network = CurrencyNetworkProxy ( web3 , currency_network_abi , testnetwork1_address ) [EOL] return currency_network [EOL] [EOL] [EOL] @ pytest . fixture ( ) def currency_network_with_trustlines ( web3 , currency_network_abi , testnetwork2_address , trustlines ) : [EOL] currency_network = CurrencyNetworkProxy ( web3 , currency_network_abi , testnetwork2_address ) [EOL] currency_network . setup_trustlines ( trustlines ) [EOL] [EOL] return currency_network [EOL] [EOL] [EOL] @ pytest . fixture ( ) def currency_network_with_trustlines_and_interests ( web3 , currency_network_abi , testnetwork2_address , trustlines_with_interests ) : [EOL] currency_network = CurrencyNetworkProxy ( web3 , currency_network_abi , testnetwork2_address ) [EOL] currency_network . setup_trustlines_with_interests_with_updates ( trustlines_with_interests ) [EOL] [EOL] return currency_network [EOL] [EOL] [EOL] @ pytest . fixture ( ) def address_oracle ( testnetworks ) : [EOL] class AddressOracle : [EOL] def is_currency_network ( self , address ) : [EOL] return address in [ network . address for network in testnetworks [ [number] ] ] [EOL] [EOL] def is_trusted_token ( self , address ) : [EOL] print ( address ) [EOL] print ( testnetworks [ [number] ] . address ) [EOL] return address == testnetworks [ [number] ] . address [EOL] [EOL] return AddressOracle ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import gevent [EOL] [EOL] [EOL] def context_switch ( ) : [EOL] gevent . sleep ( [number] ) [EOL] [EOL] [EOL] def test_decimals ( currency_network ) : [EOL] assert currency_network . decimals == [number] [EOL] [EOL] [EOL] def test_name ( currency_network ) : [EOL] assert currency_network . name == [string] [EOL] [EOL] [EOL] def test_symbol ( currency_network ) : [EOL] assert currency_network . symbol == [string] [EOL] [EOL] [EOL] def test_address ( currency_network , testnetwork1_address ) : [EOL] assert currency_network . address == testnetwork1_address [EOL] [EOL] [EOL] def test_friends1 ( currency_network_with_trustlines , accounts ) : [EOL] assert set ( currency_network_with_trustlines . fetch_friends ( accounts [ [number] ] ) ) == { accounts [ [number] ] , accounts [ [number] ] , } [EOL] [EOL] [EOL] def test_friends2 ( currency_network_with_trustlines , accounts ) : [EOL] assert set ( currency_network_with_trustlines . fetch_friends ( accounts [ [number] ] ) ) == { accounts [ [number] ] , accounts [ [number] ] , } [EOL] [EOL] [EOL] def test_account1 ( currency_network_with_trustlines , accounts ) : [EOL] assert currency_network_with_trustlines . fetch_account ( accounts [ [number] ] , accounts [ [number] ] ) == [ [number] , [number] , [number] , [number] , False , [number] , [number] , ] [EOL] [EOL] [EOL] def test_account2 ( currency_network_with_trustlines , accounts ) : [EOL] assert currency_network_with_trustlines . fetch_account ( accounts [ [number] ] , accounts [ [number] ] ) == [ [number] , [number] , [number] , [number] , False , [number] , [number] , ] [EOL] [EOL] [EOL] def test_users ( currency_network_with_trustlines , accounts ) : [EOL] assert currency_network_with_trustlines . fetch_users ( ) == accounts [ [number] : [number] ] [EOL] [EOL] [EOL] def test_gen_graph_representation ( currency_network_with_trustlines , accounts ) : [EOL] graph_representation = currency_network_with_trustlines . gen_graph_representation ( ) [EOL] [EOL] for account in accounts [ [number] : [number] ] : [EOL] assert account in ( trustline . user for trustline in graph_representation ) or ( account in ( trustline . counter_party for trustline in graph_representation ) ) [EOL] [EOL] [EOL] def test_listen_on_balance_update ( currency_network , accounts ) : [EOL] events = [ ] [EOL] [EOL] def f ( event ) : [EOL] events . append ( event ) [EOL] [EOL] greenlet = currency_network . start_listen_on_balance ( f ) [EOL] context_switch ( ) [EOL] currency_network . update_trustline_with_accept ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) [EOL] currency_network . transfer ( accounts [ [number] ] , [number] , [number] , [ accounts [ [number] ] , accounts [ [number] ] ] ) [EOL] gevent . sleep ( [number] ) [EOL] [EOL] assert len ( events ) == [number] [EOL] assert events [ [number] ] . from_ == accounts [ [number] ] or events [ [number] ] . from_ == accounts [ [number] ] [EOL] assert events [ [number] ] . to == accounts [ [number] ] or events [ [number] ] . to == accounts [ [number] ] [EOL] assert - [number] < events [ [number] ] . value < [number] [comment] [EOL] [EOL] greenlet . kill ( ) [EOL] [EOL] [EOL] def test_listen_on_transfer ( currency_network , accounts ) : [EOL] events = [ ] [EOL] [EOL] def f ( event ) : [EOL] events . append ( event ) [EOL] [EOL] greenlet = currency_network . start_listen_on_transfer ( f ) [EOL] context_switch ( ) [EOL] currency_network . update_trustline_with_accept ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) [EOL] currency_network . transfer ( accounts [ [number] ] , [number] , [number] , [ accounts [ [number] ] , accounts [ [number] ] ] ) [EOL] gevent . sleep ( [number] ) [EOL] [EOL] print ( events ) [EOL] assert len ( events ) == [number] [EOL] assert events [ [number] ] . from_ == accounts [ [number] ] [EOL] assert events [ [number] ] . to == accounts [ [number] ] [EOL] assert events [ [number] ] . value == [number] [EOL] [EOL] greenlet . kill ( ) [EOL] [EOL] [EOL] def test_listen_on_trustline_update ( currency_network , accounts ) : [EOL] events = [ ] [EOL] [EOL] def f ( event ) : [EOL] events . append ( event ) [EOL] [EOL] greenlet = currency_network . start_listen_on_trustline ( f ) [EOL] context_switch ( ) [EOL] currency_network . update_trustline ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) [EOL] currency_network . update_trustline ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] ) [EOL] gevent . sleep ( [number] ) [EOL] [EOL] assert len ( events ) == [number] [EOL] assert events [ [number] ] . from_ == accounts [ [number] ] [EOL] assert events [ [number] ] . to == accounts [ [number] ] [EOL] assert events [ [number] ] . creditline_given == [number] [EOL] assert events [ [number] ] . creditline_received == [number] [EOL] assert events [ [number] ] . is_frozen is False [EOL] [EOL] greenlet . kill ( ) [EOL] [EOL] [EOL] def test_listen_on_trustline_update_with_interests ( currency_network , accounts ) : [EOL] events = [ ] [EOL] [EOL] def f ( event ) : [EOL] events . append ( event ) [EOL] [EOL] greenlet = currency_network . start_listen_on_trustline ( f ) [EOL] context_switch ( ) [EOL] currency_network . update_trustline ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] , [number] , [number] ) [EOL] currency_network . update_trustline ( accounts [ [number] ] , accounts [ [number] ] , [number] , [number] , [number] , [number] ) [EOL] gevent . sleep ( [number] ) [EOL] [EOL] assert len ( events ) == [number] [EOL] assert events [ [number] ] . from_ == accounts [ [number] ] [EOL] assert events [ [number] ] . to == accounts [ [number] ] [EOL] assert events [ [number] ] . creditline_given == [number] [EOL] assert events [ [number] ] . creditline_received == [number] [EOL] assert events [ [number] ] . interest_rate_given == [number] [EOL] assert events [ [number] ] . interest_rate_received == [number] [EOL] assert events [ [number] ] . is_frozen is False [EOL] [EOL] greenlet . kill ( ) [EOL] [EOL] [EOL] def test_listen_on_freeze_network ( currency_network , chain , expiration_time ) : [EOL] chain . time_travel ( expiration_time ) [EOL] chain . mine_block ( ) [EOL] [EOL] events = [ ] [EOL] [EOL] def f ( event ) : [EOL] events . append ( event ) [EOL] [EOL] greenlet = currency_network . start_listen_on_network_freeze ( f ) [EOL] context_switch ( ) [EOL] currency_network . freeze_network ( ) [EOL] gevent . sleep ( [number] ) [EOL] [EOL] assert len ( events ) == [number] [EOL] assert events [ [number] ] . network_address == currency_network . address [EOL] [EOL] greenlet . kill ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from sqlalchemy import create_engine [EOL] [EOL] from relay . blockchain . exchange_proxy import ExchangeProxy [EOL] from relay . exchange . orderbook import OrderBookGreenlet [EOL] [EOL] [EOL] @ pytest . fixture ( ) def engine ( ) : [EOL] return create_engine ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def orderBook ( engine , web3 , exchange_abi , token_abi , testnetworks , is_currency_network_function ) : [EOL] exchange_address = testnetworks [ [number] ] . address [EOL] orderBook = OrderBookGreenlet ( ) [EOL] orderBook . connect_db ( engine ) [EOL] [EOL] orderBook . add_exchange ( ExchangeProxy ( web3 , exchange_abi , token_abi , exchange_address , is_currency_network_function , ) ) [EOL] [EOL] return orderBook [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import gevent [EOL] import pytest [EOL] [EOL] from relay . blockchain . exchange_proxy import ExchangeProxy [EOL] from relay . constants import NULL_ADDRESS [EOL] from relay . exchange . order import SignableOrder [EOL] [EOL] [EOL] @ pytest . fixture ( ) def order_token ( exchange_address , network_addresses_with_exchange , unw_eth_address , maker , maker_key ) : [EOL] order = SignableOrder ( exchange_address = exchange_address , maker_address = maker , taker_address = NULL_ADDRESS , maker_token = unw_eth_address , taker_token = network_addresses_with_exchange [ [number] ] , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) [EOL] order . sign ( maker_key ) [EOL] return order [EOL] [EOL] [EOL] @ pytest . fixture ( ) def order_trustlines ( exchange_address , network_addresses_with_exchange , unw_eth_address , maker , maker_key ) : [EOL] order = SignableOrder ( exchange_address = exchange_address , maker_address = maker , taker_address = NULL_ADDRESS , maker_token = network_addresses_with_exchange [ [number] ] , taker_token = unw_eth_address , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) [EOL] order . sign ( maker_key ) [EOL] return order [EOL] [EOL] [EOL] @ pytest . fixture ( ) def exchange_proxy ( web3 , exchange_abi , token_abi , exchange_address , address_oracle ) : [EOL] return ExchangeProxy ( web3 , exchange_abi , token_abi , exchange_address , address_oracle ) [EOL] [EOL] [EOL] def test_validate ( order_trustlines , exchange_proxy ) : [EOL] assert exchange_proxy . validate ( order_trustlines ) [EOL] [EOL] [EOL] def test_not_enough_funds ( order_token , exchange_proxy ) : [EOL] assert not exchange_proxy . validate_funds ( order_token ) [EOL] assert not exchange_proxy . validate ( order_token ) [EOL] [EOL] [EOL] def test_enough_funds ( order_token , exchange_proxy , testnetworks ) : [EOL] unw_eth_contract = testnetworks [ [number] ] [EOL] unw_eth_contract . functions . deposit ( ) . transact ( { [string] : order_token . maker_address , [string] : [number] } ) [EOL] [EOL] assert exchange_proxy . validate_funds ( order_token ) [EOL] assert exchange_proxy . validate ( order_token ) [EOL] [EOL] [EOL] def test_no_filled_amount ( order_token , exchange_proxy ) : [EOL] assert exchange_proxy . get_filled_amount ( order_token ) == [number] [EOL] [EOL] [EOL] def test_filled_amount ( order_trustlines , exchange_proxy , testnetworks , maker , taker ) : [EOL] order = order_trustlines [EOL] [EOL] assert maker == order . maker_address [EOL] exchange_contract = testnetworks [ [number] ] [EOL] exchange_contract . functions . fillOrderTrustlines ( [ order . maker_address , order . taker_address , order . maker_token , order . taker_token , order . fee_recipient , ] , [ order . maker_token_amount , order . taker_token_amount , order . maker_fee , order . taker_fee , order . expiration_timestamp_in_sec , order . salt , ] , [number] , [ maker , taker ] , [ ] , order . v , order . r , order . s , ) . transact ( { [string] : taker } ) [EOL] [EOL] assert exchange_proxy . get_filled_amount ( order ) == [number] [EOL] assert exchange_proxy . validate_filled_amount ( order ) [EOL] [EOL] exchange_contract . functions . fillOrderTrustlines ( [ order . maker_address , order . taker_address , order . maker_token , order . taker_token , order . fee_recipient , ] , [ order . maker_token_amount , order . taker_token_amount , order . maker_fee , order . taker_fee , order . expiration_timestamp_in_sec , order . salt , ] , [number] , [ maker , taker ] , [ ] , order . v , order . r , order . s , ) . transact ( { [string] : taker } ) [EOL] [EOL] assert exchange_proxy . get_filled_amount ( order ) == [number] [EOL] assert not exchange_proxy . validate_filled_amount ( order ) [EOL] [EOL] [EOL] def test_cancelled_amount ( order_trustlines , exchange_proxy , testnetworks , maker , taker ) : [EOL] order = order_trustlines [EOL] [EOL] exchange_contract = testnetworks [ [number] ] [EOL] exchange_contract . functions . cancelOrder ( [ order . maker_address , order . taker_address , order . maker_token , order . taker_token , order . fee_recipient , ] , [ order . maker_token_amount , order . taker_token_amount , order . maker_fee , order . taker_fee , order . expiration_timestamp_in_sec , order . salt , ] , [number] , ) . transact ( { [string] : maker } ) [EOL] [EOL] assert exchange_proxy . get_cancelled_amount ( order ) == [number] [EOL] [EOL] [EOL] def test_unavailable_amount ( order_trustlines , exchange_proxy , testnetworks , maker , taker ) : [EOL] order = order_trustlines [EOL] [EOL] exchange_contract = testnetworks [ [number] ] [EOL] [EOL] exchange_contract . functions . fillOrderTrustlines ( [ order . maker_address , order . taker_address , order . maker_token , order . taker_token , order . fee_recipient , ] , [ order . maker_token_amount , order . taker_token_amount , order . maker_fee , order . taker_fee , order . expiration_timestamp_in_sec , order . salt , ] , [number] , [ maker , taker ] , [ ] , order . v , order . r , order . s , ) . transact ( { [string] : taker } ) [EOL] [EOL] exchange_contract . functions . cancelOrder ( [ order . maker_address , order . taker_address , order . maker_token , order . taker_token , order . fee_recipient , ] , [ order . maker_token_amount , order . taker_token_amount , order . maker_fee , order . taker_fee , order . expiration_timestamp_in_sec , order . salt , ] , [number] , ) . transact ( { [string] : maker } ) [EOL] [EOL] assert exchange_proxy . get_unavailable_amount ( order ) == [number] [EOL] [EOL] [EOL] def test_listen_on_fill ( order_trustlines , exchange_proxy , testnetworks , maker , taker ) : [EOL] logs = [ ] [EOL] [EOL] def log ( order_hash , maker_token_amount , taker_token_amount ) : [EOL] logs . append ( ( order_hash , maker_token_amount , taker_token_amount ) ) [EOL] [EOL] order = order_trustlines [EOL] [EOL] greenlet = exchange_proxy . start_listen_on_fill ( log ) [EOL] gevent . sleep ( [number] ) [EOL] [EOL] exchange_contract = testnetworks [ [number] ] [EOL] exchange_contract . functions . fillOrderTrustlines ( [ order . maker_address , order . taker_address , order . maker_token , order . taker_token , order . fee_recipient , ] , [ order . maker_token_amount , order . taker_token_amount , order . maker_fee , order . taker_fee , order . expiration_timestamp_in_sec , order . salt , ] , [number] , [ maker , taker ] , [ ] , order . v , order . r , order . s , ) . transact ( { [string] : taker } ) [EOL] [EOL] gevent . sleep ( [number] ) [EOL] [EOL] log1 = logs [ [number] ] [EOL] assert log1 [ [number] ] == order . hash ( ) [EOL] assert log1 [ [number] ] == [number] [EOL] assert log1 [ [number] ] == [number] [EOL] [EOL] greenlet . kill ( ) [EOL] [EOL] [EOL] def test_listen_on_cancel ( order_token , exchange_proxy , testnetworks , maker , taker ) : [EOL] logs = [ ] [EOL] [EOL] def log ( order_hash , maker_token_amount , taker_token_amount ) : [EOL] logs . append ( ( order_hash , maker_token_amount , taker_token_amount ) ) [EOL] [EOL] order = order_token [EOL] [EOL] greenlet = exchange_proxy . start_listen_on_cancel ( log ) [EOL] gevent . sleep ( [number] ) [EOL] [EOL] exchange_contract = testnetworks [ [number] ] [EOL] exchange_contract . functions . cancelOrder ( [ order . maker_address , order . taker_address , order . maker_token , order . taker_token , order . fee_recipient , ] , [ order . maker_token_amount , order . taker_token_amount , order . maker_fee , order . taker_fee , order . expiration_timestamp_in_sec , order . salt , ] , [number] , ) . transact ( { [string] : maker } ) [EOL] [EOL] gevent . sleep ( [number] ) [EOL] [EOL] log1 = logs [ [number] ] [EOL] assert log1 [ [number] ] == order . hash ( ) [EOL] assert log1 [ [number] ] == [number] [EOL] assert log1 [ [number] ] == [number] [EOL] [EOL] greenlet . kill ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , List , Any [EOL] import typing [EOL] import attr [EOL] import pytest [EOL] from eth_utils import to_checksum_address [EOL] from tldeploy . identity import ( Identity , MetaTransaction , UnexpectedIdentityContractException , deploy_identity_implementation , deploy_identity_proxy_factory , deploy_proxied_identity , ) [EOL] from web3 import Web3 [EOL] [EOL] from relay . blockchain . delegate import ( Delegate , DelegationFees , GasPriceMethod , InvalidDelegationFeesException , InvalidMetaTransactionException , ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def delegate_address ( web3 ) : [EOL] return web3 . eth . coinbase [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def delegate_config ( ) : [EOL] return { [string] : GasPriceMethod . FIXED , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def delegate ( web3 , delegate_address , contracts , proxy_factory , currency_network , delegate_config ) : [EOL] identity_contract_abi = contracts [ [string] ] [ [string] ] [EOL] base_fee = [number] [EOL] return Delegate ( web3 , delegate_address , identity_contract_abi , [ proxy_factory . address ] , delegation_fees = [ DelegationFees ( base_fee = base_fee , currency_network_of_fees = currency_network . address ) ] , config = delegate_config , ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def delegate_with_one_fees ( web3 , delegate_address , contracts , proxy_factory , currency_network , delegate_config ) : [EOL] identity_contract_abi = contracts [ [string] ] [ [string] ] [EOL] base_fee = [number] [EOL] return Delegate ( web3 , delegate_address , identity_contract_abi , [ proxy_factory . address ] , delegation_fees = [ DelegationFees ( base_fee = base_fee , currency_network_of_fees = currency_network . address ) ] , config = delegate_config , ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def owner ( accounts ) : [EOL] return accounts [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def owner_key ( account_keys ) : [EOL] return account_keys [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def proxy_factory ( web3 ) : [EOL] [EOL] return deploy_identity_proxy_factory ( web3 = web3 ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def identity_implementation ( web3 ) : [EOL] [EOL] return deploy_identity_implementation ( web3 = web3 ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def signature_of_owner_on_implementation ( owner_key , identity_implementation , proxy_factory ) : [EOL] abi_types = [ [string] , [string] , [string] , [string] ] [EOL] to_hash = [ [string] , [string] , proxy_factory . address , identity_implementation . address ] [EOL] to_sign = Web3 . solidityKeccak ( abi_types , to_hash ) [EOL] return owner_key . sign_msg_hash ( to_sign ) . to_bytes ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def identity_contract ( web3 , proxy_factory , identity_implementation , signature_of_owner_on_implementation , owner , ) : [EOL] identity_contract = deploy_proxied_identity ( web3 , proxy_factory . address , identity_implementation . address , signature_of_owner_on_implementation , ) [EOL] web3 . eth . sendTransaction ( { [string] : identity_contract . address , [string] : owner , [string] : [number] } ) [EOL] [EOL] return identity_contract [EOL] [EOL] [EOL] @ pytest . fixture ( ) def identity ( identity_contract , owner_key ) : [EOL] return Identity ( contract = identity_contract , owner_private_key = owner_key ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def chain_id ( web3 ) : [EOL] return int ( web3 . eth . chainId ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def build_meta_transaction ( chain_id ) : [EOL] [docstring] [EOL] [EOL] def f ( * args , ** kwargs ) : [EOL] return MetaTransaction ( * args , ** kwargs , chain_id = chain_id ) [EOL] [EOL] return f [EOL] [EOL] [EOL] @ pytest . fixture ( ) def signed_meta_transaction ( identity , owner_key , accounts , build_meta_transaction ) : [EOL] meta_transaction = build_meta_transaction ( from_ = identity . address , to = accounts [ [number] ] , value = [number] , data = [number] . to_bytes ( [number] , byteorder = [string] ) , nonce = [number] , ) [EOL] [EOL] return meta_transaction . signed ( owner_key ) [EOL] [EOL] [EOL] def meta_transaction_for_currency_network_transfer ( currency_network , identity , source , destination ) : [EOL] [EOL] trustlines = [ ( source , destination , [number] , [number] ) ] [EOL] currency_network . setup_trustlines ( trustlines ) [EOL] meta_transaction = currency_network . transfer_meta_transaction ( [number] , [number] , [ source , destination ] ) [EOL] meta_transaction = identity . filled_and_signed_meta_transaction ( meta_transaction ) [EOL] [EOL] return meta_transaction [EOL] [EOL] [EOL] def test_delegate_meta_transaction ( delegate , identity , web3 , signed_meta_transaction ) : [EOL] [docstring] [EOL] [EOL] tx_hash = delegate . send_signed_meta_transaction ( signed_meta_transaction ) [EOL] tx = web3 . eth . getTransaction ( tx_hash ) [EOL] [EOL] assert tx [ [string] ] == web3 . eth . coinbase [EOL] assert to_checksum_address ( tx [ [string] ] ) == identity . address [EOL] [EOL] [EOL] def test_delegated_transaction_trustlines_flow ( currency_network , identity , delegate , accounts ) : [EOL] [docstring] [EOL] [EOL] source = identity . address [EOL] destination = accounts [ [number] ] [EOL] [EOL] meta_transaction = meta_transaction_for_currency_network_transfer ( currency_network , identity , source , destination ) [EOL] [EOL] delegate . send_signed_meta_transaction ( meta_transaction ) [EOL] [EOL] assert currency_network . get_balance ( source , destination ) == - [number] [EOL] [EOL] [EOL] def test_deploy_identity ( currency_network , delegate , accounts , proxy_factory , owner_key , identity_implementation , signature_of_owner_on_implementation , ) : [EOL] [docstring] [EOL] [EOL] identity_contract_address = delegate . deploy_identity ( proxy_factory . address , identity_implementation . address , signature_of_owner_on_implementation , ) [EOL] [EOL] destination = accounts [ [number] ] [EOL] [EOL] meta_transaction = currency_network . transfer_meta_transaction ( [number] , [number] , [ identity_contract_address , destination ] ) [EOL] signed_meta_transaction = attr . evolve ( meta_transaction , from_ = identity_contract_address , nonce = [number] ) . signed ( owner_key ) [EOL] [EOL] currency_network . setup_trustlines ( [ ( identity_contract_address , destination , [number] , [number] ) ] ) [EOL] delegate . send_signed_meta_transaction ( signed_meta_transaction ) [EOL] assert currency_network . get_balance ( identity_contract_address , destination ) == - [number] [EOL] [EOL] [EOL] def test_next_nonce ( delegate , identity_contract , accounts , owner_key , build_meta_transaction ) : [EOL] [EOL] source = identity_contract . address [EOL] destination = accounts [ [number] ] [EOL] [EOL] meta_transaction = build_meta_transaction ( from_ = source , to = destination , value = [number] , nonce = delegate . calc_next_nonce ( source ) ) [EOL] signed_meta_transaction = meta_transaction . signed ( owner_key ) [EOL] [EOL] assert delegate . calc_next_nonce ( source ) == [number] [EOL] delegate . send_signed_meta_transaction ( signed_meta_transaction ) [EOL] assert delegate . calc_next_nonce ( source ) == [number] [EOL] [EOL] meta_transaction = build_meta_transaction ( from_ = source , to = destination , value = [number] , nonce = delegate . calc_next_nonce ( source ) ) [EOL] signed_meta_transaction = meta_transaction . signed ( owner_key ) [EOL] [EOL] assert delegate . calc_next_nonce ( source ) == [number] [EOL] delegate . send_signed_meta_transaction ( signed_meta_transaction ) [EOL] assert delegate . calc_next_nonce ( source ) == [number] [EOL] [EOL] [EOL] def test_delegated_transaction_invalid_signature ( identity , delegate , accounts , account_keys , build_meta_transaction ) : [EOL] to = accounts [ [number] ] [EOL] value = [number] [EOL] [EOL] meta_transaction = build_meta_transaction ( from_ = identity . address , to = to , value = value , nonce = [number] ) . signed ( account_keys [ [number] ] ) [EOL] [EOL] with pytest . raises ( InvalidMetaTransactionException ) : [EOL] delegate . send_signed_meta_transaction ( meta_transaction ) [EOL] [EOL] [EOL] def test_delegated_transaction_invalid_nonce ( identity , delegate , accounts ) : [EOL] to = accounts [ [number] ] [EOL] value = [number] [EOL] [EOL] meta_transaction1 = identity . filled_and_signed_meta_transaction ( MetaTransaction ( to = to , value = value , nonce = [number] ) ) [EOL] meta_transaction2 = identity . filled_and_signed_meta_transaction ( MetaTransaction ( to = to , value = value , nonce = [number] ) ) [EOL] [EOL] delegate . send_signed_meta_transaction ( meta_transaction1 ) [EOL] [EOL] with pytest . raises ( InvalidMetaTransactionException ) : [EOL] delegate . send_signed_meta_transaction ( meta_transaction2 ) [EOL] [EOL] [EOL] def test_delegated_transaction_invalid_identity_contract ( delegate , accounts , account_keys , build_meta_transaction ) : [EOL] from_ = accounts [ [number] ] [EOL] to = accounts [ [number] ] [EOL] value = [number] [EOL] [EOL] meta_transaction = build_meta_transaction ( from_ = from_ , to = to , value = value , nonce = [number] ) . signed ( account_keys [ [number] ] ) [EOL] [EOL] with pytest . raises ( UnexpectedIdentityContractException ) : [EOL] delegate . send_signed_meta_transaction ( meta_transaction ) [EOL] [EOL] [EOL] def test_meta_transaction_fees_valid ( delegate_with_one_fees , signed_meta_transaction , owner_key ) : [EOL] [docstring] [EOL] [EOL] delegation_fees = delegate_with_one_fees . calculate_fees_for_meta_transaction ( signed_meta_transaction ) [ [number] ] [EOL] meta_transaction_with_fees = attr . evolve ( signed_meta_transaction , base_fee = delegation_fees . base_fee , currency_network_of_fees = delegation_fees . currency_network_of_fees , ) [EOL] signed_meta_transaction_with_fees = meta_transaction_with_fees . signed ( owner_key ) [EOL] delegate_with_one_fees . validate_meta_transaction_fees ( signed_meta_transaction_with_fees ) [EOL] [EOL] [EOL] def test_meta_transaction_fees_invalid_value ( delegate_with_one_fees , signed_meta_transaction , owner_key ) : [EOL] [docstring] [EOL] [EOL] delegation_fees = delegate_with_one_fees . calculate_fees_for_meta_transaction ( signed_meta_transaction ) [ [number] ] [EOL] [EOL] wrong_fees_value = [number] [EOL] assert delegation_fees . base_fee >= wrong_fees_value [EOL] [EOL] meta_transaction_with_fees = attr . evolve ( signed_meta_transaction , base_fee = wrong_fees_value , currency_network_of_fees = delegation_fees . currency_network_of_fees , ) [EOL] signed_meta_transaction_with_fees = meta_transaction_with_fees . signed ( owner_key ) [EOL] [EOL] with pytest . raises ( InvalidDelegationFeesException ) : [EOL] delegate_with_one_fees . validate_meta_transaction_fees ( signed_meta_transaction_with_fees ) [EOL] [EOL] [EOL] def test_meta_transaction_fees_invalid_network ( delegate_with_one_fees , signed_meta_transaction , owner_key ) : [EOL] [docstring] [EOL] [EOL] delegation_fees = delegate_with_one_fees . calculate_fees_for_meta_transaction ( signed_meta_transaction ) [ [number] ] [EOL] [EOL] wrong_network = signed_meta_transaction . from_ [EOL] assert delegation_fees . currency_network_of_fees != wrong_network [EOL] [EOL] meta_transaction_with_fees = attr . evolve ( signed_meta_transaction , base_fee = delegation_fees . base_fee , currency_network_of_fees = wrong_network , ) [EOL] signed_meta_transaction_with_fees = meta_transaction_with_fees . signed ( owner_key ) [EOL] [EOL] with pytest . raises ( InvalidDelegationFeesException ) : [EOL] delegate_with_one_fees . validate_meta_transaction_fees ( signed_meta_transaction_with_fees ) [EOL] [EOL] [EOL] def test_meta_transaction_fee_recipient_invalid ( delegate_with_one_fees , signed_meta_transaction , owner_key ) : [EOL] [docstring] [EOL] [EOL] delegation_fees = delegate_with_one_fees . calculate_fees_for_meta_transaction ( signed_meta_transaction ) [ [number] ] [EOL] [EOL] wrong_recipient = signed_meta_transaction . from_ [EOL] assert delegation_fees . fee_recipient != wrong_recipient [EOL] [EOL] meta_transaction_with_fees = attr . evolve ( signed_meta_transaction , base_fee = delegation_fees . base_fee , currency_network_of_fees = delegation_fees . currency_network_of_fees , fee_recipient = wrong_recipient , ) [EOL] signed_meta_transaction_with_fees = meta_transaction_with_fees . signed ( owner_key ) [EOL] with pytest . raises ( InvalidDelegationFeesException ) : [EOL] delegate_with_one_fees . validate_meta_transaction_fees ( signed_meta_transaction_with_fees ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( { [string] : GasPriceMethod . FIXED , [string] : [number] } , [number] , ) , ( { [string] : GasPriceMethod . RPC } , [number] ) , ( { [string] : GasPriceMethod . BOUND , [string] : [number] , [string] : [number] , } , [number] , ) , ( { [string] : GasPriceMethod . BOUND , [string] : [number] , [string] : [number] , } , [number] , ) , ] , ) def test_gas_pricing ( delegate , delegate_config , gas_price_config , gas_price ) : [EOL] config = dict ( ** delegate_config ) [EOL] config . update ( gas_price_config ) [EOL] [EOL] delegate . config = config [EOL] [EOL] assert delegate . _calculate_gas_price ( MetaTransaction ( ) ) == gas_price [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from relay . blockchain . currency_network_events import ( TransferEventType , TrustlineRequestCancelEventType , TrustlineRequestEventType , TrustlineUpdateEventType , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def web3_event ( ) : [EOL] return { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . fixture ( ) def web3_event_trustline_update ( web3_event ) : [EOL] trustline_update_event = web3_event . copy ( ) [EOL] trustline_update_event . update ( { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : True , } , [string] : TrustlineUpdateEventType , } ) [EOL] return trustline_update_event [EOL] [EOL] [EOL] @ pytest . fixture ( ) def web3_event_trustline_request ( web3_event ) : [EOL] trustline_request_event = web3_event . copy ( ) [EOL] trustline_request_event . update ( { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : True , } , [string] : TrustlineRequestEventType , } ) [EOL] return trustline_request_event [EOL] [EOL] [EOL] @ pytest . fixture ( ) def web3_event_trustline_request_cancel ( web3_event ) : [EOL] trustline_request_cancel_event = web3_event . copy ( ) [EOL] trustline_request_cancel_event . update ( { [string] : { [string] : [string] , [string] : [string] } , [string] : TrustlineRequestCancelEventType , } ) [EOL] return trustline_request_cancel_event [EOL] [EOL] [EOL] @ pytest . fixture ( ) def web3_event_transfer ( web3_event , test_extra_data ) : [EOL] trustlines_transfer_event = web3_event . copy ( ) [EOL] trustlines_transfer_event . update ( { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : test_extra_data , } , [string] : TransferEventType , } ) [EOL] return trustlines_transfer_event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] [EOL] from relay import main [EOL] [EOL] [EOL] def test_get_version ( ) : [EOL] version = main . get_version ( ) [EOL] print ( f" [string] { version !r}" ) [EOL] assert re . match ( [string] , version ) , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import tests [EOL] import typing [EOL] import gevent [EOL] [EOL] from relay . concurrency_utils import synchronized [EOL] [EOL] [EOL] def unsafe_list_operation ( lst ) : [EOL] [docstring] [EOL] count = len ( lst ) [EOL] gevent . sleep ( [number] ) [EOL] lst . append ( count ) [EOL] [EOL] [EOL] def test_synchronized_function ( ) : [EOL] [docstring] [EOL] lst = [ ] [EOL] [EOL] @ synchronized def doit ( ) : [EOL] unsafe_list_operation ( lst ) [EOL] [EOL] greenlets = [ gevent . spawn ( doit ) for i in range ( [number] ) ] [EOL] gevent . joinall ( greenlets , raise_error = True ) [EOL] [EOL] assert lst == list ( range ( [number] ) ) [EOL] [EOL] [EOL] def test_synchronized_method ( ) : [EOL] [docstring] [EOL] lst = [ ] [EOL] [EOL] class Foo : [EOL] @ synchronized def doit ( self ) : [EOL] unsafe_list_operation ( lst ) [EOL] [EOL] foo = Foo ( ) [EOL] greenlets = [ gevent . spawn ( foo . doit ) for i in range ( [number] ) ] [EOL] gevent . joinall ( greenlets , raise_error = True ) [EOL] [EOL] assert lst == list ( range ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from relay . blockchain . currency_network_events import TransferEvent , TrustlineUpdateEvent [EOL] [EOL] [EOL] def test_trustline_update_event ( web3_event_trustline_update ) : [EOL] event = TrustlineUpdateEvent ( web3_event_trustline_update , [number] , [number] , [string] ) [EOL] [EOL] assert event . from_ == [string] [EOL] assert event . to == [string] [EOL] assert event . user == [string] [EOL] assert event . counter_party == [string] [EOL] assert event . creditline_given == [number] [EOL] assert event . creditline_received == [number] [EOL] assert event . is_frozen is True [EOL] assert event . status == [string] [EOL] assert event . direction == [string] [EOL] [EOL] [EOL] def test_transfer_event ( web3_event_transfer , test_extra_data ) : [EOL] event = TransferEvent ( web3_event_transfer , [number] , [number] , [string] ) [EOL] [EOL] assert event . from_ == [string] [EOL] assert event . to == [string] [EOL] assert event . user == [string] [EOL] assert event . counter_party == [string] [EOL] assert event . value == [number] [EOL] assert event . status == [string] [EOL] assert event . direction == [string] [EOL] assert event . extra_data == test_extra_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Type [EOL] import tests [EOL] import typing [EOL] import pathlib [EOL] [EOL] import pytest [EOL] from marshmallow import Schema , ValidationError , fields [EOL] [EOL] from relay . config . config import ( _remove_empty_dicts , generate_default_config , load_config , validation_error_string , ) [EOL] [EOL] [EOL] class NestedSchema ( Schema ) : [EOL] a_string = fields . String ( required = True ) [EOL] [EOL] [EOL] class TestSchema ( Schema ) : [EOL] an_int = fields . Integer ( required = True ) [EOL] nested = fields . Nested ( NestedSchema ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def example_config_filepath ( ) : [EOL] return str ( pathlib . Path ( __file__ ) . parent . parent . parent . joinpath ( [string] ) . absolute ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def uncommented_example_config_filepath ( example_config_filepath , tmp_path ) : [EOL] [comment] [EOL] d = tmp_path / [string] [EOL] [EOL] with open ( example_config_filepath ) as file : [EOL] with open ( d , [string] ) as output_file : [EOL] for line in file . readlines ( ) : [EOL] output_file . writelines ( [ line . replace ( [string] , [string] ) ] ) [EOL] [EOL] return str ( d ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def correct_fees_config_file ( tmp_path ) : [EOL] folder = tmp_path / [string] [EOL] folder . mkdir ( ) [EOL] file_path = folder / [string] [EOL] file_path . write_text ( [string] . join ( ( [string] , [string] , [string] , [string] , ) ) ) [EOL] return file_path [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( { } , { } ) , ( { [string] : { } } , { } ) , ( { [string] : None , [string] : { [string] : { } , [string] : None } } , { } ) , ( { [string] : None , [string] : { [string] : { } , [string] : None , [string] : [number] } } , { [string] : { [string] : [number] } } , ) , ] , ) def test_remove_empty_dicts ( test_input , expected_output ) : [EOL] assert _remove_empty_dicts ( test_input ) == expected_output [EOL] [EOL] [EOL] def test_example_file_matches_default_config ( example_config_filepath ) : [EOL] [docstring] [EOL] assert load_config ( example_config_filepath ) == generate_default_config ( ) [EOL] [EOL] [EOL] def test_uncommented_default_config_is_valid ( uncommented_example_config_filepath ) : [EOL] [docstring] [EOL] load_config ( uncommented_example_config_filepath ) [EOL] [EOL] [EOL] def test_correct_fee_config_is_valid ( correct_fees_config_file ) : [EOL] load_config ( correct_fees_config_file ) [EOL] [EOL] [EOL] def test_validation_error_message ( ) : [EOL] error_message = [string] [EOL] try : [EOL] TestSchema ( ) . load ( { [string] : [string] , [string] : { [string] : [number] } } ) [EOL] except ValidationError as e : [EOL] error_message = validation_error_string ( e ) [EOL] [EOL] messages = [ [string] , [string] , ] [EOL] assert error_message == [string] . join ( messages ) or error_message == [string] . join ( reversed ( messages ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from relay . utils import sha3 [EOL] [EOL] [EOL] def test_sha3 ( ) : [EOL] assert ( sha3 ( [string] ) == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Type , Union [EOL] import tests [EOL] import typing [EOL] import relay [EOL] from collections import namedtuple [EOL] [EOL] import gevent [EOL] import pytest [EOL] [EOL] from relay . events import MessageEvent [EOL] from relay . streams import ( Client , DisconnectedError , Event , MessagingSubject , Subject , Subscription , ) [EOL] [EOL] IdEventTuple = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] class LogClient ( Client ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . events = [ ] [EOL] [EOL] def _execute_send ( self , subscription , event ) : [EOL] if isinstance ( event , MessageEvent ) and event . message == [string] : [EOL] raise DisconnectedError [EOL] self . events . append ( IdEventTuple ( subscription . id , event ) ) [EOL] [EOL] [EOL] class SafeLogClient ( Client ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . events = [ ] [EOL] [EOL] def _execute_send ( self , subscription , event ) : [EOL] self . events . append ( IdEventTuple ( subscription . id , event ) ) [EOL] [EOL] [EOL] class GeventClient ( Client ) : [EOL] def _execute_send ( self , subscription , event ) : [EOL] gevent . sleep ( [number] ) [EOL] raise DisconnectedError [EOL] [EOL] [EOL] @ pytest . fixture ( ) def subject ( ) : [EOL] return Subject ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def messaging_subject ( ) : [EOL] return MessagingSubject ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def client ( ) : [EOL] return LogClient ( ) [EOL] [EOL] [EOL] def test_subscription ( subject , client ) : [EOL] subscription = subject . subscribe ( client ) [EOL] subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) [EOL] id = subscription . id [EOL] item = client . events [ [number] ] [EOL] assert item . id == id [EOL] assert item . event . message == [string] [EOL] assert not subscription . closed [EOL] assert len ( subject . subscriptions ) == [number] [EOL] [EOL] [EOL] def test_cancel_subscription ( subject , client ) : [EOL] subscription = subject . subscribe ( client ) [EOL] subscription . unsubscribe ( ) [EOL] subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) [EOL] assert client . events == [ ] [EOL] assert subscription . closed [EOL] assert len ( subject . subscriptions ) == [number] [EOL] [EOL] [EOL] def test_auto_unsubscribe ( subject , client ) : [EOL] subscription = subject . subscribe ( client ) [EOL] subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) [comment] [EOL] subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) [EOL] assert client . events == [ ] [EOL] assert subscription . closed [EOL] assert len ( subject . subscriptions ) == [number] [EOL] [EOL] [EOL] def test_auto_unsubscribe_dont_skip ( subject ) : [EOL] [docstring] [EOL] clients = [ LogClient ( ) , SafeLogClient ( ) ] [EOL] for c in clients : [EOL] subject . subscribe ( c ) [EOL] subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) [comment] [EOL] assert clients [ [number] ] . events , [string] [EOL] [EOL] [EOL] def test_subscription_after_puplish ( messaging_subject , client ) : [EOL] assert not messaging_subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) [EOL] subscription = messaging_subject . subscribe ( client ) [EOL] missed_messages = messaging_subject . get_missed_messages ( ) [EOL] assert len ( missed_messages ) == [number] [EOL] assert missed_messages [ [number] ] . message == [string] [EOL] assert not subscription . closed [EOL] [EOL] [EOL] def test_subscription_after_resubscribe ( messaging_subject , client ) : [EOL] messaging_subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) [EOL] subscription = messaging_subject . subscribe ( client ) [EOL] messaging_subject . get_missed_messages ( ) [EOL] subscription . unsubscribe ( ) [EOL] client . events . clear ( ) [EOL] messaging_subject . subscribe ( client ) [EOL] assert messaging_subject . get_missed_messages ( ) == [ ] [EOL] assert client . events == [ ] [EOL] [EOL] [EOL] def test_subscription_both ( messaging_subject , client ) : [EOL] assert not messaging_subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) [EOL] subscription = messaging_subject . subscribe ( client ) [EOL] assert messaging_subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) [EOL] id = subscription . id [EOL] missed_messages = messaging_subject . get_missed_messages ( ) [EOL] assert len ( missed_messages ) == [number] [EOL] assert missed_messages [ [number] ] . message == [string] [EOL] item = client . events [ [number] ] [EOL] assert item . id == id [EOL] assert item . event . message == [string] [EOL] assert not subscription . closed [EOL] [EOL] [EOL] def test_unsubscription_race_condition ( subject ) : [EOL] [docstring] [EOL] client1 = GeventClient ( ) [EOL] subject . subscribe ( client1 ) [EOL] [comment] [EOL] gevent . joinall ( ( gevent . spawn ( subject . publish , MessageEvent ( [string] , timestamp = [number] ) ) , gevent . spawn ( subject . publish , MessageEvent ( [string] , timestamp = [number] ) ) , ) , raise_error = True , ) [EOL] assert subject . subscriptions == [ ] [EOL] [EOL] [EOL] def test_many_subscription ( subject ) : [EOL] client = SafeLogClient ( ) [EOL] subject . subscribe ( client ) [EOL] subject . subscribe ( client ) [EOL] assert len ( client . subscriptions ) == [number] [EOL] [EOL] [EOL] def test_stop_subscription ( subject ) : [EOL] client = SafeLogClient ( ) [EOL] subscription1 = subject . subscribe ( client ) [EOL] subject . subscribe ( client ) [EOL] subscription1 . unsubscribe ( ) [EOL] assert len ( client . subscriptions ) == [number] [EOL] [EOL] [EOL] def test_close_client ( subject ) : [EOL] client = SafeLogClient ( ) [EOL] subscription1 = subject . subscribe ( client ) [EOL] subscription2 = subject . subscribe ( client ) [EOL] client . close ( ) [EOL] assert client . closed [EOL] assert len ( client . subscriptions ) == [number] [EOL] assert subscription1 . closed [EOL] assert subscription2 . closed [EOL] [EOL] [EOL] def test_not_reading_client_does_not_mark_as_read ( messaging_subject , client ) : [EOL] [comment] [EOL] messaging_subject . subscribe ( client , silent = True ) [EOL] assert messaging_subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) == [number] [EOL] missed_messages = messaging_subject . get_missed_messages ( ) [EOL] assert len ( missed_messages ) == [number] [EOL] [EOL] [comment] [EOL] messaging_subject . subscribe ( client , silent = False ) [EOL] assert messaging_subject . publish ( event = MessageEvent ( [string] , timestamp = [number] ) ) == [number] [EOL] missed_messages = messaging_subject . get_missed_messages ( ) [EOL] assert len ( missed_messages ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.unit.test_streams.IdEventTuple]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $relay.streams.Subscription$ 0 $relay.streams.Event$ 0 0 0 0 0 0 $relay.streams.Event$ 0 0 0 0 $relay.streams.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.unit.test_streams.IdEventTuple]$ 0 $relay.streams.Subscription$ 0 0 0 $relay.streams.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $relay.streams.Subscription$ 0 $relay.streams.Event$ 0 0 0 0 0 0 0 0 0 $typing.Type[tests.unit.test_streams.IdEventTuple]$ 0 $relay.streams.Subscription$ 0 0 0 $relay.streams.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $relay.streams.Subscription$ 0 $relay.streams.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from eth_utils import to_checksum_address [EOL] [EOL] from relay . constants import NULL_ADDRESS [EOL] from relay . exchange . order import Order , SignableOrder [EOL] [EOL] [EOL] @ pytest . fixture ( ) def invalid_signature_order ( addresses ) : [EOL] A , B , C , D = addresses [EOL] return Order ( exchange_address = A , maker_address = B , taker_address = NULL_ADDRESS , maker_token = C , taker_token = D , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , v = [number] , r = [number] . to_bytes ( [number] , byteorder = [string] ) , s = [number] . to_bytes ( [number] , byteorder = [string] ) , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def invalid_exchange_order ( addresses , test_account ) : [EOL] A , B , C , D = addresses [EOL] maker = test_account . address [EOL] order = SignableOrder ( exchange_address = [string] , maker_address = to_checksum_address ( maker ) , taker_address = NULL_ADDRESS , maker_token = C , taker_token = D , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) [EOL] order . sign ( test_account . private_key ) [EOL] return order [EOL] [EOL] [EOL] @ pytest . fixture ( ) def invalid_taker_order ( addresses , test_account ) : [EOL] A , B , C , D = addresses [EOL] maker = test_account . address [EOL] order = SignableOrder ( exchange_address = A , maker_address = to_checksum_address ( maker ) , taker_address = B , maker_token = C , taker_token = D , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) [EOL] order . sign ( test_account . private_key ) [EOL] return order [EOL] [EOL] [EOL] @ pytest . fixture ( ) def expired_order ( addresses , test_account ) : [EOL] A , B , C , D = addresses [EOL] maker = test_account . address [EOL] order = SignableOrder ( exchange_address = A , maker_address = to_checksum_address ( maker ) , taker_address = C , maker_token = C , taker_token = D , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) [EOL] order . sign ( test_account . private_key ) [EOL] return order [EOL] [EOL] [EOL] @ pytest . fixture ( ) def valid_order ( addresses , test_account ) : [EOL] A , B , C , D = addresses [EOL] maker = test_account . address [EOL] order = SignableOrder ( exchange_address = A , maker_address = to_checksum_address ( maker ) , taker_address = NULL_ADDRESS , maker_token = C , taker_token = D , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) [EOL] order . sign ( test_account . private_key ) [EOL] [EOL] return order [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import relay [EOL] import pytest [EOL] [EOL] from relay . blockchain . exchange_proxy import DummyExchangeProxy [EOL] from relay . exchange . order import Order [EOL] from relay . exchange . orderbook import OrderBook , OrderInvalidException [EOL] [EOL] [EOL] @ pytest . fixture ( ) def orderbook ( ) : [EOL] return OrderBook ( ) [EOL] [EOL] [EOL] def test_invalid_signature_order ( orderbook , invalid_signature_order ) : [EOL] orderbook . add_exchange ( DummyExchangeProxy ( invalid_signature_order . exchange_address ) ) [EOL] assert not orderbook . validate ( invalid_signature_order ) [EOL] with pytest . raises ( OrderInvalidException ) : [EOL] orderbook . add_order ( invalid_signature_order ) [EOL] [EOL] [EOL] def test_invalid_exchange_order ( orderbook , valid_order ) : [EOL] assert not orderbook . validate ( valid_order ) [EOL] with pytest . raises ( OrderInvalidException ) : [EOL] orderbook . add_order ( valid_order ) [EOL] [EOL] [EOL] def test_invalid_taker_order ( orderbook , invalid_taker_order ) : [EOL] orderbook . add_exchange ( DummyExchangeProxy ( invalid_taker_order . exchange_address ) ) [EOL] assert not orderbook . validate ( invalid_taker_order ) [EOL] with pytest . raises ( OrderInvalidException ) : [EOL] orderbook . add_order ( invalid_taker_order ) [EOL] [EOL] [EOL] def test_expired_order ( orderbook , expired_order ) : [EOL] orderbook . add_exchange ( DummyExchangeProxy ( expired_order . exchange_address ) ) [EOL] assert not orderbook . validate ( expired_order ) [EOL] with pytest . raises ( OrderInvalidException ) : [EOL] orderbook . add_order ( expired_order ) [EOL] [EOL] [EOL] def test_valid_order ( orderbook , valid_order ) : [EOL] orderbook . add_exchange ( DummyExchangeProxy ( valid_order . exchange_address ) ) [EOL] assert orderbook . validate ( valid_order ) [EOL] orderbook . add_order ( valid_order ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import relay [EOL] from relay . exchange . order import Order [EOL] [EOL] [EOL] def test_invalid_signature ( invalid_signature_order ) : [EOL] assert not invalid_signature_order . validate_signature ( ) [EOL] assert not invalid_signature_order . validate ( ) [EOL] [EOL] [EOL] def test_invalid_address ( invalid_exchange_order ) : [EOL] assert not invalid_exchange_order . validate_addresses ( ) [EOL] assert not invalid_exchange_order . validate ( ) [EOL] [EOL] [EOL] def test_valid_order ( valid_order ) : [EOL] assert valid_order . validate_addresses ( ) [EOL] assert valid_order . validate_signature ( ) [EOL] assert valid_order . validate ( ) [EOL] [EOL] [EOL] def test_expired ( valid_order ) : [EOL] assert not valid_order . is_expired ( [number] ) [EOL] assert valid_order . is_expired ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import networkx as nx [EOL] import pytest [EOL] [EOL] from relay . network_graph import alg [EOL] [EOL] [EOL] class FeeCostAccumulator ( alg . CostAccumulator ) : [EOL] def zero ( self ) : [EOL] return [number] [EOL] [EOL] def total_cost_from_start_to_dst ( self , cost_from_start_to_node , node , dst , graph_data ) : [EOL] return cost_from_start_to_node + graph_data [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def graph ( ) : [EOL] g = nx . Graph ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] g . add_edge ( [number] , [number] , fee = [number] ) [EOL] g . add_edge ( [number] , [number] , fee = [number] ) [EOL] g . add_edge ( [number] , [number] , fee = [number] ) [EOL] return g [EOL] [EOL] [EOL] def sanity_check_fees ( graph , cost_path ) : [EOL] print ( f" [string] { cost_path }" ) [EOL] cost , path = cost_path [EOL] [EOL] sum_fees = [number] [EOL] for source , target in zip ( path , path [ [number] : ] ) : [EOL] fee = graph [ source ] [ target ] [ [string] ] [EOL] sum_fees += fee [EOL] print ( f"{ source } [string] { target } [string] { fee } [string] { sum_fees }" ) [EOL] assert sum_fees == cost , f" [string] { cost_path }" [EOL] [EOL] [EOL] def test_find_path_cost_wrong_bug_issue_219 ( graph ) : [EOL] [docstring] [EOL] cost_path = alg . least_cost_path ( graph = graph , starting_nodes = { [number] } , target_nodes = { [number] } , cost_accumulator = FeeCostAccumulator ( ) , ) [EOL] sanity_check_fees ( graph , cost_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from relay . network_graph . fees import ( calculate_fees , calculate_fees_reverse , imbalance_generated , ) [EOL] [EOL] [EOL] def test_imbalance_generated ( ImbalanceGenerated ) : [EOL] balance = ImbalanceGenerated [ [string] ] [ [string] ] [EOL] value = ImbalanceGenerated [ [string] ] [ [string] ] [EOL] expected_imbalance_generated = ImbalanceGenerated [ [string] ] [EOL] assert ( imbalance_generated ( balance = balance , value = value ) == expected_imbalance_generated ) [EOL] [EOL] [EOL] def test_calculate_fees ( CalculateFee ) : [EOL] capacity_imbalance_fee_divisor = CalculateFee [ [string] ] [ [string] ] [EOL] imbalance_generated = CalculateFee [ [string] ] [ [string] ] [EOL] expected_fees = CalculateFee [ [string] ] [EOL] assert ( calculate_fees ( imbalance_generated , capacity_imbalance_fee_divisor ) == expected_fees ) [EOL] [EOL] [EOL] def test_calculate_fees_reverse ( CalculateFee ) : [EOL] capacity_imbalance_fee_divisor = CalculateFee [ [string] ] [ [string] ] [EOL] imbalance_generated = CalculateFee [ [string] ] [ [string] ] [EOL] expected_fees_reverse = CalculateFee [ [string] ] [EOL] assert ( calculate_fees_reverse ( imbalance_generated , capacity_imbalance_fee_divisor ) == expected_fees_reverse ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from relay . network_graph . trustline_data import ( get , get_balance , get_creditline , get_interest_rate , get_mtime , set , set_balance , set_creditline , set_interest_rate , set_mtime , ) [EOL] [EOL] a = [string] [EOL] b = [string] [EOL] key = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def data ( ) : [EOL] return { } [EOL] [EOL] [EOL] def test_set_get ( data ) : [EOL] set ( data , a , b , { key : [number] } , { key : - [number] } ) [EOL] assert get ( a , b , data [ key ] , - data [ key ] ) == [number] [EOL] assert get ( b , a , data [ key ] , - data [ key ] ) == - [number] [EOL] [EOL] [EOL] def test_balance ( data ) : [EOL] set_balance ( data , a , b , [number] ) [EOL] assert get_balance ( data , a , b ) == [number] [EOL] assert get_balance ( data , b , a ) == - [number] [EOL] [EOL] [EOL] def test_creditline ( data ) : [EOL] set_creditline ( data , a , b , [number] ) [EOL] set_creditline ( data , b , a , [number] ) [EOL] assert get_creditline ( data , a , b ) == [number] [EOL] assert get_creditline ( data , b , a ) == [number] [EOL] [EOL] [EOL] def test_interests ( data ) : [EOL] set_interest_rate ( data , a , b , [number] ) [EOL] set_interest_rate ( data , b , a , [number] ) [EOL] assert get_interest_rate ( data , a , b ) == [number] [EOL] assert get_interest_rate ( data , b , a ) == [number] [EOL] [EOL] [EOL] def test_mtime ( data ) : [EOL] set_mtime ( data , [number] ) [EOL] assert get_mtime ( data ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import tests [EOL] import typing [EOL] import networkx as nx [EOL] [EOL] from relay . network_graph import alg [EOL] [EOL] [EOL] class FeeCostAccumulatorCounter ( alg . CostAccumulator ) : [EOL] def __init__ ( self ) : [EOL] self . num_calls = [number] [EOL] [EOL] def zero ( self ) : [EOL] return [number] [EOL] [EOL] def total_cost_from_start_to_dst ( self , cost_from_start_to_node , node , dst , graph_data ) : [EOL] self . num_calls += [number] [EOL] return cost_from_start_to_node + graph_data [ [string] ] [EOL] [EOL] [EOL] def test_optimize_number_of_costfn_calls ( ) : [EOL] [docstring] [EOL] g = nx . Graph ( ) [EOL] nodes = list ( range ( [number] , [number] ) ) [EOL] for src , dst in zip ( nodes , nodes [ [number] : ] ) : [EOL] g . add_edge ( src , dst , fee = [number] ) [EOL] [EOL] cost_accumulator = FeeCostAccumulatorCounter ( ) [EOL] alg . least_cost_path ( graph = g , starting_nodes = { nodes [ [number] ] } , target_nodes = { nodes [ - [number] ] } , cost_accumulator = cost_accumulator , ) [EOL] assert cost_accumulator . num_calls == len ( nodes ) - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from relay . blockchain . currency_network_proxy import Trustline [EOL] from relay . network_graph . graph import ( CurrencyNetworkGraphForTesting as CurrencyNetworkGraph , ) [EOL] [EOL] addresses = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] A , B , C , D , E , F , G , H = addresses [EOL] [EOL] [EOL] @ pytest . fixture def trustlines ( ) : [EOL] return [ Trustline ( A , B , [number] , [number] ) , Trustline ( A , E , [number] , [number] ) , Trustline ( B , C , [number] , [number] ) , Trustline ( C , D , [number] , [number] ) , Trustline ( D , E , [number] , [number] ) , ] [EOL] [EOL] [EOL] @ pytest . fixture def community_with_trustlines ( trustlines ) : [EOL] community = CurrencyNetworkGraph ( ) [EOL] community . gen_network ( trustlines ) [EOL] return community [EOL] [EOL] [EOL] @ pytest . fixture def community_with_trustlines_and_fees ( trustlines ) : [EOL] community = CurrencyNetworkGraph ( [number] ) [EOL] community . gen_network ( trustlines ) [EOL] return community [EOL] [EOL] [EOL] @ pytest . fixture ( ) def configurable_community ( request ) : [EOL] [docstring] [EOL] community = CurrencyNetworkGraph . from_config ( request . param ) [EOL] return community [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import time [EOL] [EOL] import pytest [EOL] from tests . unit . network_graph . conftest import addresses [EOL] [EOL] from relay . blockchain . currency_network_proxy import Trustline [EOL] from relay . network_graph . graph import ( CurrencyNetworkGraphForTesting as CurrencyNetworkGraph , ) [EOL] from relay . network_graph . payment_path import FeePayer , PaymentPath [EOL] [EOL] A , B , C , D , E , F , G , H = addresses [EOL] [EOL] [EOL] def assert_maximum_path ( community , max_path , max_amount ) : [EOL] [docstring] [EOL] fee , path = community . find_transfer_path_sender_pays_fees ( max_path [ [number] ] , max_path [ - [number] ] , max_amount ) [EOL] assert path == max_path [EOL] fee , path = community . find_transfer_path_sender_pays_fees ( max_path [ [number] ] , max_path [ - [number] ] , max_amount + [number] ) [EOL] assert path == [ ] [EOL] [EOL] [EOL] @ pytest . fixture def complextrustlines ( ) : [EOL] return [ Trustline ( A , B , [number] , [number] ) , Trustline ( A , C , [number] , [number] ) , Trustline ( B , D , [number] , [number] ) , Trustline ( C , D , [number] , [number] ) , Trustline ( D , E , [number] , [number] ) , Trustline ( E , F , [number] , [number] ) , Trustline ( F , G , [number] , [number] ) , Trustline ( G , H , [number] , [number] ) , ] [EOL] [EOL] [EOL] @ pytest . fixture def balance_trustlines ( ) : [EOL] return [ Trustline ( A , B , [number] , [number] , balance = [number] ) , Trustline ( B , C , [number] , [number] , balance = - [number] ) ] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def address_not_used_in_graphs ( complextrustlines , balance_trustlines ) : [EOL] unused_address = [string] [EOL] [EOL] for trustline in complextrustlines + balance_trustlines : [EOL] assert unused_address != trustline . counter_party [EOL] assert unused_address != trustline . user [EOL] [EOL] [EOL] @ pytest . fixture def balances_community ( balance_trustlines ) : [EOL] community = CurrencyNetworkGraph ( ) [EOL] community . gen_network ( balance_trustlines ) [EOL] return community [EOL] [EOL] [EOL] @ pytest . fixture def complex_community_with_trustlines_and_fees ( complextrustlines ) : [EOL] community = CurrencyNetworkGraph ( capacity_imbalance_fee_divisor = [number] ) [EOL] community . gen_network ( complextrustlines ) [EOL] return community [EOL] [EOL] [EOL] @ pytest . fixture def complex_community_with_trustlines_and_fees_33 ( complextrustlines ) : [EOL] community = CurrencyNetworkGraph ( capacity_imbalance_fee_divisor = [number] ) [EOL] community . gen_network ( complextrustlines ) [EOL] return community [EOL] [EOL] [EOL] @ pytest . fixture def complex_community_with_trustlines_and_fees_202 ( complextrustlines ) : [EOL] community = CurrencyNetworkGraph ( capacity_imbalance_fee_divisor = [number] ) [EOL] community . gen_network ( complextrustlines ) [EOL] return community [EOL] [EOL] [EOL] @ pytest . fixture def complex_community_with_trustlines_and_fees_10 ( complextrustlines ) : [EOL] community = CurrencyNetworkGraph ( capacity_imbalance_fee_divisor = [number] ) [EOL] community . gen_network ( complextrustlines ) [EOL] return community [EOL] [EOL] [EOL] @ pytest . fixture def complex_community_with_trustlines ( complextrustlines ) : [EOL] community = CurrencyNetworkGraph ( ) [EOL] community . gen_network ( complextrustlines ) [EOL] return community [EOL] [EOL] [EOL] @ pytest . fixture ( ) def complex_community_with_trustlines_and_fees_configurable_balances ( complex_community_with_trustlines , request ) : [EOL] [docstring] [EOL] for user , counter_party , balance in request . param : [EOL] complex_community_with_trustlines . update_balance ( user , counter_party , balance ) [EOL] return complex_community_with_trustlines [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ CurrencyNetworkGraph . find_transfer_path_sender_pays_fees , CurrencyNetworkGraph . find_transfer_path_receiver_pays_fees , ] ) def parametrised_find_transfer_path_function ( community_with_trustlines , request ) : [EOL] [EOL] return request . param [EOL] [EOL] [EOL] def test_users ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] assert len ( community . users ) == [number] [comment] [EOL] assert ( len ( set ( community . users ) & set ( addresses ) ) == [number] ) [comment] [EOL] [EOL] [EOL] def test_friends ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] assert A in community . get_friends ( B ) [comment] [EOL] assert C in community . get_friends ( B ) [EOL] [EOL] [EOL] def test_account ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] account = community . get_account_sum ( D , C ) [EOL] assert account . balance == [number] [EOL] assert account . creditline_given == [number] [EOL] assert account . creditline_received == [number] [EOL] [EOL] [EOL] def test_account_sum ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] account = community . get_account_sum ( A ) [EOL] assert account . balance == [number] [EOL] assert account . creditline_given == [number] [EOL] assert account . creditline_received == [number] [EOL] [EOL] [EOL] def test_frozen_account_summary ( community_with_trustlines ) : [EOL] community_with_trustlines . freeze_trustline ( D , C ) [EOL] account = community_with_trustlines . get_account_sum ( D , C ) [EOL] [EOL] assert account . is_frozen is True [EOL] assert account . available == [number] [EOL] [EOL] [EOL] def test_frozen_aggregated_account_summary ( community_with_trustlines ) : [EOL] community_with_trustlines . update_balance ( A , E , [number] ) [EOL] [EOL] account = community_with_trustlines . get_account_sum ( A ) [EOL] assert account . balance == [number] [EOL] [EOL] community_with_trustlines . freeze_trustline ( A , E ) [EOL] account = community_with_trustlines . get_account_sum ( A ) [EOL] assert account . balance == [number] [EOL] [EOL] [EOL] def test_update_trustline ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] assert community . get_account_sum ( B , A ) . creditline_received == [number] [EOL] community . update_trustline ( A , B , [number] , [number] , [number] , [number] ) [EOL] account_sum = community . get_account_sum ( B , A ) [EOL] assert account_sum . creditline_given == [number] [EOL] assert account_sum . creditline_received == [number] [EOL] assert account_sum . interest_rate_given == [number] [EOL] assert account_sum . interest_rate_received == [number] [EOL] [EOL] [EOL] def test_update_balance ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] assert community . get_account_sum ( B ) . balance == [number] [EOL] community . update_balance ( A , B , [number] ) [EOL] community . update_balance ( B , C , [number] ) [EOL] assert community . get_account_sum ( B ) . balance == - [number] [EOL] [EOL] [EOL] def test_close_trustline_no_cost_exact_amount ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , B , - [number] ) [comment] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , C , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( B , D , - [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( C , D , [number] ) [EOL] now = int ( time . time ( ) ) [EOL] payment_path = complex_community_with_trustlines_and_fees . close_trustline_path_triangulation ( now , A , B ) [EOL] assert payment_path == PaymentPath ( fee = [number] , path = [ A , C , D , B , A ] , value = [number] , fee_payer = FeePayer . SENDER ) [EOL] [EOL] [EOL] def test_close_trustline_not_enough_capacity ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , B , - [number] ) [comment] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , C , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( B , D , - [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( C , D , [number] ) [EOL] now = int ( time . time ( ) ) [EOL] payment_path = complex_community_with_trustlines_and_fees . close_trustline_path_triangulation ( now , A , B ) [EOL] assert payment_path == PaymentPath ( fee = [number] , path = [ ] , value = [number] , fee_payer = FeePayer . SENDER ) [EOL] [EOL] [EOL] def test_close_trustline_first_edge_insufficient_capacity ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , B , - [number] ) [comment] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , C , - [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( B , D , - [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( C , D , [number] ) [EOL] now = int ( time . time ( ) ) [EOL] payment_path = complex_community_with_trustlines_and_fees . close_trustline_path_triangulation ( now , A , B ) [EOL] assert payment_path . path == [ ] [EOL] [EOL] [EOL] def test_close_trustline_last_edge_insufficient_capacity ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , B , [number] ) [comment] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , C , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( B , D , - [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( C , D , [number] ) [EOL] now = int ( time . time ( ) ) [EOL] payment_path = complex_community_with_trustlines_and_fees . close_trustline_path_triangulation ( now , A , B ) [EOL] assert payment_path . path == [ ] [EOL] [EOL] [EOL] def test_close_trustline_source_not_in_graph ( balances_community , address_not_used_in_graphs ) : [EOL] [docstring] [EOL] now = int ( time . time ( ) ) [EOL] payment_path = balances_community . close_trustline_path_triangulation ( now , address_not_used_in_graphs , A ) [EOL] assert payment_path == PaymentPath ( fee = [number] , path = [ ] , value = [number] , fee_payer = FeePayer . SENDER ) [EOL] [EOL] [EOL] def test_close_trustline_target_not_in_graph ( balances_community , address_not_used_in_graphs ) : [EOL] [docstring] [EOL] now = int ( time . time ( ) ) [EOL] payment_path = balances_community . close_trustline_path_triangulation ( now , A , address_not_used_in_graphs ) [EOL] assert payment_path == PaymentPath ( fee = [number] , path = [ ] , value = [number] , fee_payer = FeePayer . SENDER ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ ] , A , B ) , ( [ ] , A , C ) , ( [ ] , A , D ) , ( [ ] , A , E ) , ( [ ( A , B , [number] ) ] , A , B ) , ( [ ( A , B , [number] ) , ( A , C , - [number] ) ] , A , B ) , ( [ ( A , B , - [number] + [number] ) , ( A , C , - [number] ) ] , A , B ) , ( [ ( A , B , [number] ) ] , A , B ) , ( [ ( A , C , [number] ) , ( C , D , [number] ) ] , A , D ) , ] , indirect = [ [string] ] , ) def test_capacity_is_maximum ( complex_community_with_trustlines_and_fees_configurable_balances , source , destination , ) : [EOL] [docstring] [EOL] ( sendable , max_path , ) = complex_community_with_trustlines_and_fees_configurable_balances . find_maximum_capacity_path ( source , destination ) [EOL] assert_maximum_path ( complex_community_with_trustlines_and_fees_configurable_balances , max_path , sendable , ) [EOL] [EOL] [EOL] def test_capacity_path_single_hop ( complex_community_with_trustlines ) : [EOL] [docstring] [EOL] source = A [EOL] destination = B [EOL] [EOL] sendable , max_path = complex_community_with_trustlines . find_maximum_capacity_path ( source , destination ) [EOL] assert max_path == [ A , B ] [EOL] assert sendable == [number] [EOL] [EOL] [EOL] def test_capacity_path_single_hop_more_capacity ( complex_community_with_trustlines ) : [EOL] [docstring] [EOL] complex_community_with_trustlines . update_balance ( A , B , [number] ) [EOL] value , path = complex_community_with_trustlines . find_maximum_capacity_path ( A , B ) [EOL] assert path == [ A , B ] [EOL] assert value == [number] [EOL] [EOL] [EOL] def test_capacity_path_single_hop_less_capacity ( complex_community_with_trustlines ) : [EOL] [docstring] [EOL] complex_community_with_trustlines . update_balance ( A , B , - [number] ) [EOL] complex_community_with_trustlines . update_balance ( A , C , - [number] ) [EOL] value , path = complex_community_with_trustlines . find_maximum_capacity_path ( A , B ) [EOL] assert path == [ A , B ] [EOL] assert value == [number] [EOL] [EOL] [EOL] def test_capacity_path_multi_hops_negative_balance ( complex_community_with_trustlines ) : [EOL] [docstring] [EOL] complex_community_with_trustlines . update_balance ( A , C , - [number] ) [EOL] [EOL] value , path = complex_community_with_trustlines . find_maximum_capacity_path ( A , E ) [EOL] [EOL] assert path == [ A , B , D , E ] [EOL] assert value == [number] [EOL] [EOL] [EOL] def test_capacity_path_multi_hops_negative_balance_lowers_capacity ( complex_community_with_trustlines , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines . update_balance ( A , C , - [number] ) [EOL] complex_community_with_trustlines . update_balance ( A , B , - [number] ) [EOL] [EOL] value , path = complex_community_with_trustlines . find_maximum_capacity_path ( A , E ) [EOL] [EOL] assert path == [ A , B , D , E ] [EOL] assert value == [number] [EOL] [EOL] [EOL] def test_capacity_path_multi_hops_positive_balance ( complex_community_with_trustlines ) : [EOL] [docstring] [EOL] complex_community_with_trustlines . update_balance ( A , C , [number] ) [EOL] complex_community_with_trustlines . update_balance ( C , D , [number] ) [EOL] complex_community_with_trustlines . update_balance ( D , E , [number] ) [EOL] [EOL] value , path = complex_community_with_trustlines . find_maximum_capacity_path ( A , E ) [EOL] [EOL] assert path == [ A , C , D , E ] [EOL] assert value == [number] [EOL] [EOL] [EOL] def test_capacity_path_single_hop_with_fees ( complex_community_with_trustlines_and_fees ) : [EOL] [docstring] [EOL] source = A [EOL] destination = B [EOL] [EOL] ( sendable , max_path , ) = complex_community_with_trustlines_and_fees . find_maximum_capacity_path ( source , destination ) [EOL] assert max_path == [ A , B ] [EOL] assert sendable == [number] [EOL] [EOL] [EOL] def test_capacity_path_multi_hop_with_fees ( complex_community_with_trustlines_and_fees ) : [EOL] [docstring] [EOL] source = A [EOL] destination = E [EOL] [EOL] ( sendable , max_path , ) = complex_community_with_trustlines_and_fees . find_maximum_capacity_path ( source , destination ) [EOL] assert max_path == [ A , B , D , E ] [EOL] assert sendable == [number] [EOL] [EOL] [EOL] def test_capacity_path_multi_hop_with_fees_one_hop_no_fee ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( B , D , [number] ) [comment] [EOL] [EOL] source = A [EOL] destination = E [EOL] [EOL] ( sendable , max_path , ) = complex_community_with_trustlines_and_fees . find_maximum_capacity_path ( source , destination ) [EOL] assert max_path == [ A , B , D , E ] [EOL] assert sendable == [number] [EOL] [EOL] [EOL] def test_max_capacity_estimation_no_fees_on_one_path ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_trustline ( A , B , [number] , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_trustline ( B , D , [number] , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_trustline ( A , C , [number] , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_trustline ( C , D , [number] , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , C , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( C , D , [number] ) [EOL] [EOL] source = A [EOL] destination = D [EOL] [EOL] ( sendable , max_path , ) = complex_community_with_trustlines_and_fees . find_maximum_capacity_path ( source , destination ) [EOL] [EOL] assert max_path == [ A , C , D ] [EOL] assert sendable == [number] [EOL] assert_maximum_path ( complex_community_with_trustlines_and_fees , max_path , sendable ) [EOL] [EOL] [EOL] def test_max_capacity_estimation_different_length_paths ( community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] community_with_trustlines_and_fees . update_trustline ( A , E , [number] , [number] ) [EOL] [EOL] source = A [EOL] destination = E [EOL] [EOL] sendable , max_path = community_with_trustlines_and_fees . find_maximum_capacity_path ( source , destination ) [EOL] assert max_path == [ A , E ] [EOL] assert sendable == [number] [EOL] assert_maximum_path ( community_with_trustlines_and_fees , max_path , sendable ) [EOL] [EOL] [EOL] def test_capacity_path_single_hop_reducing_imbalance ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , B , [number] ) [EOL] [EOL] source = A [EOL] destination = B [EOL] [EOL] ( sendable , max_path , ) = complex_community_with_trustlines_and_fees . find_maximum_capacity_path ( source , destination ) [EOL] [EOL] assert_maximum_path ( complex_community_with_trustlines_and_fees , max_path , sendable ) [EOL] [EOL] [EOL] def test_max_capacity_estimation_long_path ( complex_community_with_trustlines_and_fees_10 , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( A , C , - [number] ) [EOL] [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( A , B , - [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( B , D , - [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( D , E , - [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( E , F , - [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( F , G , - [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( G , H , - [number] ) [EOL] [EOL] source = A [EOL] destination = H [EOL] [EOL] ( sendable , max_path , ) = complex_community_with_trustlines_and_fees_10 . find_maximum_capacity_path ( source , destination ) [EOL] [EOL] assert max_path == [ A , B , D , E , F , G , H ] [EOL] assert_maximum_path ( complex_community_with_trustlines_and_fees_10 , max_path , sendable ) [EOL] [EOL] [EOL] def test_max_capacity_estimation_long_path_offset_by_two ( complex_community_with_trustlines_and_fees_10 , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( A , C , - [number] ) [EOL] [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( A , B , - [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( B , D , - [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( D , E , - [number] + [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( E , F , - [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( F , G , - [number] ) [EOL] complex_community_with_trustlines_and_fees_10 . update_balance ( G , H , - [number] ) [EOL] [EOL] source = A [EOL] destination = H [EOL] [EOL] ( sendable , max_path , ) = complex_community_with_trustlines_and_fees_10 . find_maximum_capacity_path ( source , destination ) [EOL] assert max_path == [ A , B , D , E , F , G , H ] [EOL] [EOL] assert_maximum_path ( complex_community_with_trustlines_and_fees_10 , max_path , sendable ) [EOL] [EOL] [EOL] def test_max_path_closed_trustlines ( balances_community ) : [EOL] [docstring] [EOL] [EOL] balances_community . update_trustline ( B , C , [number] , [number] ) [EOL] value , path = balances_community . find_maximum_capacity_path ( B , C ) [EOL] [EOL] assert value == [number] [EOL] assert path == [ ] [EOL] [EOL] [EOL] def test_max_path_ignores_frozen_lines ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] [EOL] value , path = community . find_maximum_capacity_path ( A , D ) [EOL] assert path == [ A , E , D ] [EOL] [EOL] community . freeze_trustline ( A , E ) [EOL] value , path = community . find_maximum_capacity_path ( A , D ) [EOL] assert path == [ A , B , C , D ] [EOL] [EOL] [EOL] def test_mediated_transfer ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] community . mediated_transfer ( A , C , [number] ) [EOL] assert community . get_account_sum ( A ) . balance == - [number] [EOL] assert community . get_account_sum ( B ) . balance == [number] [EOL] assert community . get_account_sum ( C ) . balance == [number] [EOL] assert community . get_account_sum ( A , B ) . balance == - [number] [EOL] assert community . get_account_sum ( B , C ) . balance == - [number] [EOL] [EOL] [EOL] def test_path ( community_with_trustlines , parametrised_find_transfer_path_function ) : [EOL] find_path = parametrised_find_transfer_path_function [EOL] community = community_with_trustlines [EOL] [EOL] cost , path = find_path ( community , A , B , [number] ) [EOL] assert path == [ A , B ] [EOL] assert cost == [number] [EOL] cost , path = find_path ( community , A , D , [number] ) [EOL] assert path == [ A , E , D ] [EOL] assert cost == [number] [EOL] [EOL] [EOL] def test_no_path ( community_with_trustlines , parametrised_find_transfer_path_function ) : [EOL] community = community_with_trustlines [EOL] find_path = parametrised_find_transfer_path_function [EOL] [EOL] community . update_trustline ( F , G , [number] , [number] ) [EOL] cost , path = find_path ( community , G , F , [number] ) [EOL] assert path == [ G , F ] [EOL] cost , path = find_path ( community , A , G , [number] ) [comment] [EOL] assert path == [ ] [EOL] [EOL] [EOL] def test_no_capacity ( community_with_trustlines , parametrised_find_transfer_path_function ) : [EOL] community = community_with_trustlines [EOL] find_path = parametrised_find_transfer_path_function [EOL] [EOL] cost , path = find_path ( community , A , E , [number] ) [EOL] assert path == [ A , E ] [EOL] cost , path = find_path ( community , A , E , [number] ) [EOL] assert path == [ ] [EOL] cost , path = find_path ( community , E , A , [number] ) [EOL] assert path == [ E , A ] [EOL] cost , path = find_path ( community , E , A , [number] ) [EOL] assert path == [ ] [EOL] [EOL] [EOL] def test_no_direction ( community_with_trustlines , parametrised_find_transfer_path_function ) : [EOL] community = community_with_trustlines [EOL] find_path = parametrised_find_transfer_path_function [EOL] [EOL] community . update_trustline ( F , G , [number] , [number] ) [EOL] cost , path = find_path ( community_with_trustlines , G , F , [number] ) [EOL] assert path == [ G , F ] [EOL] cost , path = find_path ( community_with_trustlines , F , G , [number] ) [comment] [EOL] assert path == [ ] [EOL] [EOL] [EOL] def test_valid_path_raises_no_value_error ( complex_community_with_trustlines_and_fees ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , B , - [number] ) [comment] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , C , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( B , D , - [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( C , D , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( D , E , [number] ) [EOL] [comment] [EOL] ( cost , path , ) = complex_community_with_trustlines_and_fees . find_transfer_path_sender_pays_fees ( E , A , [number] ) [EOL] [EOL] [EOL] def test_max_hops ( community_with_trustlines , parametrised_find_transfer_path_function ) : [EOL] community = community_with_trustlines [EOL] find_path = parametrised_find_transfer_path_function [EOL] [EOL] cost , path = find_path ( community , A , D , [number] ) [EOL] assert path == [ A , E , D ] [EOL] cost , path = find_path ( community , A , D , [number] , max_hops = [number] ) [EOL] assert path == [ ] [EOL] [EOL] [EOL] def test_finding_path_ignores_frozen_lines ( community_with_trustlines , parametrised_find_transfer_path_function ) : [EOL] community = community_with_trustlines [EOL] find_path = parametrised_find_transfer_path_function [EOL] [EOL] cost , path = find_path ( community , A , D , [number] ) [EOL] assert path == [ A , E , D ] [EOL] community . freeze_trustline ( A , E ) [EOL] [EOL] cost , path = find_path ( community , A , D , [number] ) [EOL] assert path == [ A , B , C , D ] [EOL] [EOL] [EOL] def test_send_back ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , C , D , E , A , ] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ A , B ] [EOL] community . mediated_transfer ( A , B , [number] ) [EOL] assert community . get_account_sum ( B , A ) . balance == [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , A ] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ A , E , D , C , B , ] [EOL] community . mediated_transfer ( B , A , [number] ) [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] [EOL] [EOL] def test_send_more ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] assert community . get_account_sum ( A , B ) . creditline_left_received == [number] [EOL] assert community . get_account_sum ( B , A ) . creditline_left_received == [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ A , B ] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , C , D , E , A , ] [EOL] community . mediated_transfer ( A , B , [number] ) [EOL] assert community . get_account_sum ( B , A ) . balance == [number] [EOL] assert community . get_account_sum ( B , A ) . creditline_left_received == [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ A , E , D , C , B , ] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , A ] [EOL] community . mediated_transfer ( B , A , [number] ) [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] [EOL] [EOL] def test_send_more_nopath ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] assert community . get_account_sum ( A , B ) . creditline_left_received == [number] [EOL] assert community . get_account_sum ( B , A ) . creditline_left_received == [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ A , E , D , C , B , ] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , C , D , E , A , ] [EOL] community . mediated_transfer ( A , B , [number] ) [EOL] assert community . get_account_sum ( B , A ) . balance == [number] [EOL] assert community . get_account_sum ( A , B ) . creditline_left_received == [number] [EOL] assert community . get_account_sum ( B , A ) . creditline_left_received == [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ A , E , D , C , B , ] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , C , D , E , A , ] [EOL] community . mediated_transfer ( B , A , [number] ) [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] [EOL] [EOL] def test_no_money_created ( community_with_trustlines ) : [EOL] community = community_with_trustlines [EOL] assert community . money_created == [number] [EOL] [EOL] [EOL] def test_money_created ( balances_community ) : [EOL] community = balances_community [EOL] assert community . money_created == [number] [EOL] [EOL] [EOL] def test_no_creditlines ( ) : [EOL] community = CurrencyNetworkGraph ( ) [EOL] assert community . total_creditlines == [number] [EOL] [EOL] [EOL] def test_total_creditlines ( balances_community ) : [EOL] community = balances_community [EOL] assert community . total_creditlines == [number] [EOL] [EOL] [EOL] def test_mediated_transfer_with_fees ( community_with_trustlines_and_fees ) : [EOL] community = community_with_trustlines_and_fees [EOL] community . mediated_transfer ( A , C , [number] ) [EOL] assert community . get_account_sum ( A ) . balance == - [number] + - [number] [EOL] assert community . get_account_sum ( B ) . balance == [number] + [number] [EOL] assert community . get_account_sum ( C ) . balance == [number] [EOL] assert community . get_account_sum ( A , B ) . balance == - [number] + - [number] [EOL] assert community . get_account_sum ( B , C ) . balance == - [number] [EOL] [EOL] [EOL] def test_path_with_fees_sender_pays ( community_with_trustlines_and_fees ) : [EOL] community = community_with_trustlines_and_fees [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [EOL] assert path == [ A , B ] [EOL] assert cost == [number] [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , D , [number] ) [EOL] assert path == [ A , E , D ] [EOL] assert cost == [number] [EOL] [EOL] [EOL] def test_path_with_fees_receiver_pays ( community_with_trustlines_and_fees ) : [EOL] community = community_with_trustlines_and_fees [EOL] cost , path = community . find_transfer_path_receiver_pays_fees ( A , B , [number] ) [EOL] assert path == [ A , B ] [EOL] assert cost == [number] [EOL] cost , path = community . find_transfer_path_receiver_pays_fees ( A , D , [number] ) [EOL] assert path == [ A , E , D ] [EOL] assert cost == [number] [EOL] [EOL] [EOL] def test_path_fee_symmetry_sanity ( complex_community_with_trustlines_and_fees ) : [EOL] community = complex_community_with_trustlines_and_fees [EOL] [EOL] sender_pays = [number] [EOL] [EOL] cost , path = community . find_transfer_path_receiver_pays_fees ( A , H , sender_pays ) [EOL] assert path == [ A , B , D , E , F , G , H ] [EOL] assert cost == [number] [EOL] [EOL] receiver_receives = sender_pays - cost [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , H , receiver_receives ) [EOL] assert path == [ A , B , D , E , F , G , H ] [EOL] assert cost == [number] [EOL] [EOL] [EOL] def test_max_fees ( community_with_trustlines_and_fees ) : [EOL] community = community_with_trustlines_and_fees [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , D , [number] ) [EOL] assert path == [ A , E , D ] [EOL] assert cost == [number] [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , D , [number] , max_fees = [number] ) [EOL] assert path == [ ] [EOL] [EOL] [EOL] def test_no_capacity_with_fees ( community_with_trustlines_and_fees ) : [EOL] community = community_with_trustlines_and_fees [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , E , [number] ) [EOL] assert path == [ A , E ] [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( A , E , [number] ) [EOL] assert path == [ ] [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( E , A , [number] ) [EOL] assert path == [ E , A ] [EOL] cost , path = community . find_transfer_path_sender_pays_fees ( E , A , [number] ) [EOL] assert path == [ ] [EOL] [EOL] [EOL] def test_send_back_with_fees ( community_with_trustlines_and_fees ) : [EOL] community = community_with_trustlines_and_fees [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , C , D , E , A , ] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ A , B ] [EOL] assert community . mediated_transfer ( A , B , [number] ) == [number] [EOL] assert community . get_account_sum ( B , A ) . balance == [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , A ] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ A , E , D , C , B , ] [EOL] assert community . mediated_transfer ( B , A , [number] ) == [number] [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] [EOL] [EOL] def test_send_more_with_fees ( community_with_trustlines_and_fees ) : [EOL] community = community_with_trustlines_and_fees [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] assert community . get_account_sum ( A , B ) . creditline_left_received == [number] [EOL] assert community . get_account_sum ( B , A ) . creditline_left_received == [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ A , B ] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , C , D , E , A , ] [EOL] assert community . mediated_transfer ( A , B , [number] ) == [number] [EOL] assert community . get_account_sum ( B , A ) . balance == [number] + [number] [EOL] assert community . get_account_sum ( B , A ) . creditline_left_received == [number] + [number] [EOL] assert community . find_transfer_path_sender_pays_fees ( A , B , [number] ) [ [number] ] == [ ] [EOL] assert community . find_transfer_path_sender_pays_fees ( B , A , [number] ) [ [number] ] == [ B , A ] [EOL] assert community . mediated_transfer ( B , A , [number] ) == [number] [EOL] assert community . get_account_sum ( A , B ) . balance == [number] [EOL] [EOL] [EOL] def test_close_trustline_zero_balance ( complex_community_with_trustlines_and_fees ) : [EOL] [docstring] [EOL] result = complex_community_with_trustlines_and_fees . close_trustline_path_triangulation ( timestamp = int ( time . time ( ) ) , source = C , target = H ) [EOL] assert result == PaymentPath ( fee = [number] , path = [ ] , value = [number] , fee_payer = FeePayer . SENDER ) [EOL] [EOL] [EOL] def test_close_trustline_positive_balance ( complex_community_with_trustlines_and_fees ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( C , H , [number] ) [EOL] result = complex_community_with_trustlines_and_fees . close_trustline_path_triangulation ( timestamp = int ( time . time ( ) ) , source = C , target = H ) [EOL] assert result == PaymentPath ( fee = [number] , path = [ C , H , G , F , E , D , C ] , value = [number] , fee_payer = FeePayer . RECEIVER ) [EOL] [EOL] [EOL] def test_close_trustline_negative_balance ( complex_community_with_trustlines_and_fees ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( C , H , - [number] ) [EOL] result = complex_community_with_trustlines_and_fees . close_trustline_path_triangulation ( timestamp = int ( time . time ( ) ) , source = C , target = H ) [EOL] assert result == PaymentPath ( fee = [number] , path = [ C , D , E , F , G , H , C ] , value = [number] , fee_payer = FeePayer . SENDER ) [EOL] [EOL] [EOL] def test_close_trustline_with_cost_exact_amount ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , B , - [number] ) [comment] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , C , - [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( B , D , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( C , D , - [number] ) [EOL] result = complex_community_with_trustlines_and_fees . close_trustline_path_triangulation ( timestamp = int ( time . time ( ) ) , source = A , target = B ) [EOL] assert result == PaymentPath ( fee = [number] , path = [ A , C , D , B , A ] , value = [number] , fee_payer = FeePayer . SENDER ) [EOL] [EOL] [EOL] def test_close_trustline_multi ( complex_community_with_trustlines_and_fees ) : [EOL] [docstring] [EOL] complex_community_with_trustlines_and_fees . update_balance ( A , H , - [number] ) [EOL] result = complex_community_with_trustlines_and_fees . close_trustline_path_triangulation ( timestamp = int ( time . time ( ) ) , source = A , target = H ) [EOL] assert result in [ PaymentPath ( fee = [number] , path = [ A , B , D , E , F , G , H , A ] , value = [number] , fee_payer = FeePayer . SENDER , ) , PaymentPath ( fee = [number] , path = [ A , C , D , E , F , G , H , A ] , value = [number] , fee_payer = FeePayer . SENDER , ) , ] [EOL] [EOL] [EOL] def test_update_to_closed_trustlines_remove_from_graph ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] assert complex_community_with_trustlines_and_fees . graph . has_edge ( G , H ) [EOL] complex_community_with_trustlines_and_fees . update_trustline ( G , H , [number] , [number] ) [EOL] assert complex_community_with_trustlines_and_fees . graph . has_edge ( G , H ) is False [EOL] assert complex_community_with_trustlines_and_fees . graph . has_node ( G ) [EOL] assert complex_community_with_trustlines_and_fees . graph . has_node ( H ) is False [EOL] [EOL] [EOL] def test_update_balance_to_closed_trustlines_remove_from_graph ( complex_community_with_trustlines_and_fees , ) : [EOL] [docstring] [EOL] [comment] [EOL] complex_community_with_trustlines_and_fees . update_balance ( G , H , [number] ) [EOL] complex_community_with_trustlines_and_fees . update_trustline ( G , H , [number] , [number] ) [EOL] [EOL] assert complex_community_with_trustlines_and_fees . graph . has_edge ( G , H ) [EOL] complex_community_with_trustlines_and_fees . update_balance ( G , H , [number] ) [EOL] assert complex_community_with_trustlines_and_fees . graph . has_edge ( G , H ) is False [EOL] assert complex_community_with_trustlines_and_fees . graph . has_node ( G ) [EOL] assert complex_community_with_trustlines_and_fees . graph . has_node ( H ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import math [EOL] [EOL] import pytest [EOL] from tests . unit . network_graph . conftest import addresses [EOL] [EOL] from relay . blockchain . currency_network_proxy import Trustline [EOL] from relay . network_graph . graph import Account , NetworkGraphConfig [EOL] from relay . network_graph . graph_constants import ( balance_ab , creditline_ab , creditline_ba , interest_ab , interest_ba , m_time , ) [EOL] from relay . network_graph . interests import ( DELTA_TIME_MINIMAL_ALLOWED_VALUE , calculate_interests , ) [EOL] [EOL] A , B , C , D , E , F , G , H = addresses [EOL] [EOL] [EOL] SECONDS_PER_YEAR = [number] * [number] * [number] * [number] [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ [number] , - [number] , DELTA_TIME_MINIMAL_ALLOWED_VALUE ] ) def small_non_positive_delta_time ( request ) : [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . fixture def basic_data ( ) : [EOL] data = { creditline_ab : [number] , creditline_ba : [number] , interest_ab : [number] , interest_ba : [number] , m_time : [number] , balance_ab : [number] , } [EOL] [EOL] return data [EOL] [EOL] [EOL] @ pytest . fixture ( ) def basic_account ( basic_data ) : [EOL] return Account ( basic_data , A , B ) [EOL] [EOL] [EOL] def test_interests_calculation_zero_interest_rate ( ) : [EOL] assert ( calculate_interests ( balance = [number] , internal_interest_rate = [number] , delta_time_in_seconds = SECONDS_PER_YEAR , ) == [number] ) [EOL] [EOL] [EOL] def test_interests_calculation_returns_integer ( ) : [EOL] assert isinstance ( calculate_interests ( balance = [number] , internal_interest_rate = [number] , delta_time_in_seconds = SECONDS_PER_YEAR , ) , int , ) [EOL] [EOL] [EOL] def test_interests_calculation_low_interest_rate ( ) : [EOL] assert ( calculate_interests ( balance = [number] , internal_interest_rate = [number] , delta_time_in_seconds = SECONDS_PER_YEAR , ) == [number] ) [EOL] [EOL] [EOL] def test_interests_calculation_high_interest_rate ( ) : [EOL] assert calculate_interests ( balance = [number] , internal_interest_rate = [number] , delta_time_in_seconds = SECONDS_PER_YEAR , ) == pytest . approx ( [number] * ( math . exp ( [number] ) - [number] ) , rel = [number] ) [EOL] [EOL] [EOL] def test_interests_calculation_gives_same_result_as_smart_contracts ( ) : [EOL] assert ( calculate_interests ( balance = [number] , internal_interest_rate = [number] , delta_time_in_seconds = SECONDS_PER_YEAR , ) == [number] ) [comment] [EOL] [EOL] [EOL] def tests_interests_calculation_no_time ( ) : [EOL] assert ( calculate_interests ( balance = [number] , internal_interest_rate = [number] , delta_time_in_seconds = [number] ) == [number] ) [EOL] [EOL] [EOL] def test_interests_calculation_negative_balance ( ) : [EOL] assert ( calculate_interests ( balance = - [number] , internal_interest_rate = [number] , delta_time_in_seconds = SECONDS_PER_YEAR , ) == - [number] ) [EOL] [EOL] [EOL] def test_interests_calculation_from_A_balance_positive_relevant_interests ( basic_account , ) : [EOL] basic_account . balance = [number] [comment] [EOL] basic_account . interest_rate = [number] [comment] [EOL] assert basic_account . balance_with_interests ( SECONDS_PER_YEAR ) == [number] [EOL] [EOL] [EOL] def test_interests_calculation_from_A_balance_negative_relevant_interests ( basic_account , ) : [EOL] basic_account . balance = - [number] [comment] [EOL] basic_account . reverse_interest_rate = [number] [comment] [EOL] assert basic_account . balance_with_interests ( SECONDS_PER_YEAR ) == - [number] [EOL] [EOL] [EOL] def test_interests_calculation_from_A_balance_positive_irrelevant_interests ( basic_account , ) : [EOL] basic_account . balance = [number] [comment] [EOL] basic_account . reverse_interest_rate = [number] [comment] [EOL] assert basic_account . balance_with_interests ( SECONDS_PER_YEAR ) == [number] [EOL] [EOL] [EOL] def test_interests_calculation_from_A_balance_negative_irrelevant_interests ( basic_account , ) : [EOL] basic_account . balance = - [number] [comment] [EOL] basic_account . interest_rate = [number] [comment] [EOL] assert basic_account . balance_with_interests ( SECONDS_PER_YEAR ) == - [number] [EOL] [EOL] [EOL] def test_interests_calculation_delta_time ( basic_account ) : [EOL] basic_account . balance = [number] [EOL] basic_account . m_time = SECONDS_PER_YEAR [EOL] basic_account . interest_rate = [number] [EOL] assert basic_account . balance_with_interests ( [number] * SECONDS_PER_YEAR ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ NetworkGraphConfig ( trustlines = [ Trustline ( A , B , [number] , [number] , balance = [number] , m_time = [number] , interest_rate_given = [number] ) ] ) ] , indirect = [ [string] ] , ) def test_interests_path_from_A_balance_positive_relevant_interests ( configurable_community , ) : [EOL] [comment] [EOL] [comment] [EOL] cost , path = configurable_community . find_transfer_path_sender_pays_fees ( A , B , [number] , timestamp = SECONDS_PER_YEAR ) [EOL] assert path == [ A , B ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ NetworkGraphConfig ( trustlines = [ Trustline ( A , B , [number] , [number] , balance = - [number] , m_time = [number] , interest_rate_received = [number] ) ] ) ] , indirect = [ [string] ] , ) def test_interests_path_from_A_balance_negative_relevant_interests ( configurable_community , ) : [EOL] [comment] [EOL] [comment] [EOL] cost , path = configurable_community . find_transfer_path_sender_pays_fees ( A , B , [number] , timestamp = SECONDS_PER_YEAR ) [EOL] assert path == [ ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ NetworkGraphConfig ( trustlines = [ Trustline ( A , B , [number] , [number] , balance = [number] , m_time = [number] , interest_rate_received = [number] ) ] ) ] , indirect = [ [string] ] , ) def test_interests_path_from_A_balance_positive_irrelevant_interests ( configurable_community , ) : [EOL] [comment] [EOL] [comment] [EOL] cost , path = configurable_community . find_transfer_path_sender_pays_fees ( A , B , [number] , timestamp = SECONDS_PER_YEAR ) [EOL] assert path == [ A , B ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ NetworkGraphConfig ( trustlines = [ Trustline ( A , B , [number] , [number] , balance = - [number] , m_time = [number] , interest_rate_given = [number] ) ] ) ] , indirect = [ [string] ] , ) def test_interests_path_from_A_balance_negative_irrelevant_interests ( configurable_community , ) : [EOL] [comment] [EOL] [comment] [EOL] cost , path = configurable_community . find_transfer_path_sender_pays_fees ( A , B , [number] , timestamp = SECONDS_PER_YEAR ) [EOL] assert path == [ A , B ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ NetworkGraphConfig ( trustlines = [ Trustline ( A , B , [number] , [number] , balance = [number] , m_time = [number] , interest_rate_given = [number] ) ] ) ] , indirect = [ [string] ] , ) def test_interests_path_from_B_balance_positive_relevant_interests ( configurable_community , ) : [EOL] [comment] [EOL] [comment] [EOL] cost , path = configurable_community . find_transfer_path_sender_pays_fees ( B , A , [number] , timestamp = SECONDS_PER_YEAR ) [EOL] assert path == [ ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ NetworkGraphConfig ( trustlines = [ Trustline ( A , B , [number] , [number] , balance = - [number] , m_time = [number] , interest_rate_received = [number] ) ] ) ] , indirect = [ [string] ] , ) def test_interests_path_from_B_balance_negative_relevant_interests ( configurable_community , ) : [EOL] [comment] [EOL] [comment] [EOL] cost , path = configurable_community . find_transfer_path_sender_pays_fees ( B , A , [number] , timestamp = SECONDS_PER_YEAR ) [EOL] assert path == [ B , A ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ NetworkGraphConfig ( trustlines = [ Trustline ( A , B , [number] , [number] , balance = [number] , m_time = [number] , interest_rate_received = [number] ) ] ) ] , indirect = [ [string] ] , ) def test_interests_path_from_B_balance_positive_irrelevant_interests ( configurable_community , ) : [EOL] [comment] [EOL] [comment] [EOL] cost , path = configurable_community . find_transfer_path_sender_pays_fees ( B , A , [number] , timestamp = SECONDS_PER_YEAR ) [EOL] assert path == [ B , A ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ NetworkGraphConfig ( trustlines = [ Trustline ( A , B , [number] , [number] , balance = - [number] , m_time = [number] , interest_rate_given = [number] ) ] ) ] , indirect = [ [string] ] , ) def test_interests_path_from_B_balance_negative_irrelevant_interests ( configurable_community , ) : [EOL] [comment] [EOL] [comment] [EOL] cost , path = configurable_community . find_transfer_path_sender_pays_fees ( B , A , [number] , timestamp = SECONDS_PER_YEAR ) [EOL] assert path == [ B , A ] [EOL] [EOL] [EOL] def test_calculate_interests_time_glitch ( small_non_positive_delta_time ) : [EOL] calculate_interests ( balance = [number] , internal_interest_rate = [number] , delta_time_in_seconds = small_non_positive_delta_time , ) == [number] [EOL] [EOL] [EOL] def test_calculate_interests_delta_time_out_of_bounds ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] calculate_interests ( balance = [number] , internal_interest_rate = [number] , delta_time_in_seconds = DELTA_TIME_MINIMAL_ALLOWED_VALUE - [number] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] import attr [EOL] import networkx as nx [EOL] import pytest [EOL] [EOL] from relay . network_graph import alg , graph [EOL] from relay . network_graph . trustline_data import set_balance , set_creditline [EOL] [EOL] [EOL] def zero_edge_data ( ) : [EOL] return dict ( creditline_ab = [number] , creditline_ba = [number] , interest_ab = [number] , interest_ba = [number] , m_time = [number] , balance_ab = [number] , is_frozen = False , ) [EOL] [EOL] [EOL] @ pytest . fixture def simplegraph ( ) : [EOL] graph = nx . graph . Graph ( ) [EOL] [EOL] for i in range ( [number] , [number] ) : [EOL] edge_data = zero_edge_data ( ) [EOL] set_creditline ( edge_data , i , i + [number] , [number] ) [comment] [EOL] set_creditline ( edge_data , i + [number] , i , [number] ) [comment] [EOL] graph . add_edge ( i , i + [number] , ** edge_data ) [EOL] return graph [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ graph . SenderPaysCostAccumulatorSnapshot , graph . ReceiverPaysCostAccumulatorSnapshot , ] ) def cost_accumulator_class ( request ) : [EOL] return request . param [EOL] [EOL] [EOL] def test_cost_accumulator_max_hops ( cost_accumulator_class , simplegraph ) : [EOL] acc = graph . SenderPaysCostAccumulatorSnapshot ( timestamp = [number] , value = [number] , capacity_imbalance_fee_divisor = [number] , max_hops = [number] ) [EOL] [EOL] fee , num_hops = acc . compute_cost_for_path ( simplegraph , list ( range ( [number] , [number] ) ) ) [EOL] assert num_hops == [number] [EOL] assert fee >= [number] [EOL] [EOL] [EOL] def test_cost_accumulator_max_hops_exceeded ( cost_accumulator_class , simplegraph ) : [EOL] acc = graph . SenderPaysCostAccumulatorSnapshot ( timestamp = [number] , value = [number] , capacity_imbalance_fee_divisor = [number] , max_hops = [number] ) [EOL] [EOL] with pytest . raises ( nx . NetworkXNoPath ) : [EOL] acc . compute_cost_for_path ( simplegraph , list ( range ( [number] , [number] ) ) ) [EOL] [EOL] [EOL] def test_max_fees ( cost_accumulator_class , simplegraph ) : [EOL] acc = graph . SenderPaysCostAccumulatorSnapshot ( timestamp = [number] , value = [number] , capacity_imbalance_fee_divisor = [number] ) [EOL] fee , num_hops = acc . compute_cost_for_path ( simplegraph , list ( range ( [number] , [number] ) ) ) [EOL] [EOL] acc2 = graph . SenderPaysCostAccumulatorSnapshot ( timestamp = [number] , value = [number] , capacity_imbalance_fee_divisor = [number] , max_fees = fee , ) [EOL] [EOL] assert fee , num_hops == acc2 . compute_cost_for_path ( simplegraph , list ( range ( [number] , [number] ) ) ) [EOL] [EOL] acc3 = graph . SenderPaysCostAccumulatorSnapshot ( timestamp = [number] , value = [number] , capacity_imbalance_fee_divisor = [number] , max_fees = fee - [number] , ) [EOL] [EOL] with pytest . raises ( nx . NetworkXNoPath ) : [EOL] acc3 . compute_cost_for_path ( simplegraph , list ( range ( [number] , [number] ) ) ) [EOL] [EOL] [EOL] @ pytest . fixture def capgraph ( ) : [EOL] capgraph = nx . graph . Graph ( ) [EOL] edge_data = zero_edge_data ( ) [EOL] set_balance ( edge_data , [number] , [number] , [number] ) [EOL] set_creditline ( edge_data , [number] , [number] , [number] ) [comment] [EOL] capgraph . add_edge ( [number] , [number] , ** edge_data ) [EOL] return capgraph [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) def test_capacity ( cost_accumulator_class , value , capgraph ) : [EOL] [docstring] [EOL] [EOL] if cost_accumulator_class == graph . SenderPaysCostAccumulatorSnapshot : [EOL] path = [ [number] , [number] ] [comment] [EOL] else : [EOL] path = [ [number] , [number] ] [EOL] [EOL] acc = cost_accumulator_class ( timestamp = [number] , value = value , capacity_imbalance_fee_divisor = [number] ) [EOL] assert acc . compute_cost_for_path ( capgraph , path ) [ [number] ] == [number] [EOL] [EOL] [EOL] def test_capacity_exceeded ( cost_accumulator_class , capgraph ) : [EOL] [docstring] [EOL] if cost_accumulator_class == graph . SenderPaysCostAccumulatorSnapshot : [EOL] path = [ [number] , [number] ] [comment] [EOL] else : [EOL] path = [ [number] , [number] ] [EOL] [EOL] with pytest . raises ( nx . NetworkXNoPath ) : [EOL] acc = cost_accumulator_class ( timestamp = [number] , value = [number] , capacity_imbalance_fee_divisor = [number] ) [EOL] acc . compute_cost_for_path ( capgraph , path ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def build_graph ( * , addresses , creditlines , balances ) : [EOL] [docstring] [EOL] assert len ( creditlines ) == len ( addresses ) - [number] [EOL] gr = nx . graph . Graph ( ) [EOL] for a , b , creditline , balance in zip ( addresses , addresses [ [number] : ] , creditlines , balances ) : [EOL] edge = zero_edge_data ( ) [EOL] set_creditline ( edge , b , a , creditline ) [comment] [EOL] set_balance ( edge , a , b , balance ) [EOL] gr . add_edge ( a , b , ** edge ) [EOL] return gr [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True ) class TransferInfo : [EOL] addresses = ... [EOL] path = ... [EOL] capacity_imbalance_fee_divisor = ... [EOL] fees_paid_by = ... [EOL] value = ... [EOL] timestamp = ... [EOL] balances_before_transfer = ... [EOL] balances_after_transfer = ... [EOL] expected_fees = ... [EOL] cost_accumulator = ... [EOL] minimal_creditlines = ... [EOL] [EOL] def assert_expected_cost ( self , gr ) : [EOL] [docstring] [EOL] result = self . cost_accumulator . compute_cost_for_path ( gr , self . path ) [EOL] print ( [string] , result ) [EOL] assert result [ [number] ] == self . expected_fees [EOL] [EOL] def assert_find_path ( self , gr ) : [EOL] [docstring] [EOL] cost , path_found = alg . least_cost_path ( graph = gr , starting_nodes = { self . path [ [number] ] } , target_nodes = { self . path [ - [number] ] } , cost_accumulator = self . cost_accumulator , ) [EOL] assert cost [ [number] ] == self . expected_fees [EOL] assert path_found == self . path [EOL] [EOL] def insufficient_creditlines ( self ) : [EOL] [docstring] [EOL] num_hops = len ( self . addresses ) - [number] [EOL] for i in range ( num_hops ) : [EOL] creditlines = [ [number] ] * num_hops [EOL] creditlines [ i ] = self . minimal_creditlines [ i ] - [number] [EOL] yield creditlines [EOL] [EOL] [EOL] @ pytest . fixture def transfer_info ( Transfer ) : [EOL] [docstring] [EOL] addresses = Transfer [ [string] ] [ [string] ] [EOL] capacity_imbalance_fee_divisor = Transfer [ [string] ] [ [string] ] [EOL] fees_paid_by = Transfer [ [string] ] [ [string] ] [EOL] value = Transfer [ [string] ] [ [string] ] [EOL] balances_before_transfer = Transfer [ [string] ] [ [string] ] [EOL] [EOL] balances_after_transfer = Transfer [ [string] ] [EOL] [EOL] timestamp = [number] [EOL] if fees_paid_by == [string] : [EOL] cost_accumulator = graph . SenderPaysCostAccumulatorSnapshot ( timestamp = timestamp , value = value , capacity_imbalance_fee_divisor = capacity_imbalance_fee_divisor , ) [EOL] path = list ( reversed ( addresses ) ) [EOL] [comment] [EOL] [comment] [EOL] expected_fees = balances_before_transfer [ [number] ] - value - balances_after_transfer [ [number] ] [EOL] else : [EOL] cost_accumulator = graph . ReceiverPaysCostAccumulatorSnapshot ( timestamp = timestamp , value = value , capacity_imbalance_fee_divisor = capacity_imbalance_fee_divisor , ) [EOL] path = addresses [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] expected_fees = ( balances_after_transfer [ - [number] ] - balances_before_transfer [ - [number] ] + value ) [EOL] [EOL] return TransferInfo ( addresses = addresses , balances_after_transfer = balances_after_transfer , capacity_imbalance_fee_divisor = capacity_imbalance_fee_divisor , fees_paid_by = fees_paid_by , value = value , timestamp = [number] , path = path , expected_fees = expected_fees , cost_accumulator = cost_accumulator , minimal_creditlines = [ - b for b in balances_after_transfer ] , balances_before_transfer = balances_before_transfer , ) [EOL] [EOL] [EOL] def test_transfer_ample_creditlines ( transfer_info ) : [EOL] [docstring] [EOL] print ( transfer_info ) [EOL] gr = build_graph ( addresses = transfer_info . addresses , creditlines = [ [number] ] * ( len ( transfer_info . addresses ) - [number] ) , balances = transfer_info . balances_before_transfer , ) [EOL] transfer_info . assert_expected_cost ( gr ) [EOL] transfer_info . assert_find_path ( gr ) [EOL] [EOL] [EOL] def test_transfer_minimal_creditlines ( transfer_info ) : [EOL] [docstring] [EOL] print ( transfer_info ) [EOL] gr = build_graph ( addresses = transfer_info . addresses , creditlines = transfer_info . minimal_creditlines , balances = transfer_info . balances_before_transfer , ) [EOL] transfer_info . assert_expected_cost ( gr ) [EOL] transfer_info . assert_find_path ( gr ) [EOL] [EOL] [EOL] def test_transfer_creditlines_insufficient ( transfer_info ) : [EOL] [docstring] [EOL] print ( transfer_info ) [EOL] for creditlines in transfer_info . insufficient_creditlines ( ) : [EOL] gr = build_graph ( addresses = transfer_info . addresses , creditlines = creditlines , balances = transfer_info . balances_before_transfer , ) [EOL] with pytest . raises ( nx . NetworkXNoPath ) : [EOL] transfer_info . assert_expected_cost ( gr ) [EOL] [EOL] [EOL] def test_find_path_creditlines_insufficient ( transfer_info ) : [EOL] [docstring] [EOL] print ( transfer_info ) [EOL] for creditlines in transfer_info . insufficient_creditlines ( ) : [EOL] gr = build_graph ( addresses = transfer_info . addresses , creditlines = creditlines , balances = transfer_info . balances_before_transfer , ) [EOL] with pytest . raises ( nx . NetworkXNoPath ) : [EOL] transfer_info . assert_find_path ( gr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 $typing.List$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.List$ 0 0 0 $typing.List$ 0 0 0 $builtins.int$ 0 0 0 $relay.network_graph.alg.CostAccumulator$ 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List , Dict [EOL] import tests [EOL] import typing [EOL] import json [EOL] import time [EOL] [EOL] import firebase_admin [EOL] import pytest [EOL] from firebase_admin import messaging [EOL] [EOL] from relay . blockchain . currency_network_events import ( TransferEvent , TrustlineRequestCancelEvent , TrustlineRequestEvent , TrustlineUpdateEvent , ) [EOL] from relay . events import MessageEvent [EOL] from relay . pushservice . pushservice import ( FirebaseRawPushService , _build_data_message , _build_data_prop , ) [EOL] [EOL] from . utils import MockAdapter , MockCredential [EOL] [EOL] requestMessagePayload = ( [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] requestDeclineMessagePayload = ( [string] [string] ) [EOL] [EOL] payment_request_message_event = MessageEvent ( message = requestMessagePayload , type = [string] , timestamp = int ( time . time ( ) ) ) [EOL] [EOL] payment_request_decline_message_event = MessageEvent ( message = requestDeclineMessagePayload , type = [string] , timestamp = int ( time . time ( ) ) , ) [EOL] [EOL] cred = MockCredential ( ) [EOL] all_options = { [string] : [string] } [EOL] admin_app = firebase_admin . initialize_app ( cred , all_options ) [EOL] [EOL] _DEFAULT_RESPONSE = json . dumps ( { [string] : [string] } ) [EOL] [EOL] [EOL] def _instrument_messaging_service ( app , status = [number] , payload = _DEFAULT_RESPONSE ) : [EOL] fcm_service = messaging . _get_messaging_service ( app ) [EOL] recorder = [ ] [EOL] fcm_service . _client . session . mount ( [string] , MockAdapter ( payload , status , recorder ) ) [EOL] return fcm_service , recorder [EOL] [EOL] [EOL] @ pytest . fixture ( ) def raw_push_service ( ) : [EOL] return FirebaseRawPushService ( app = admin_app ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def recorder ( raw_push_service ) : [EOL] _ , recorder = _instrument_messaging_service ( app = raw_push_service . _app ) [EOL] return recorder [EOL] [EOL] [EOL] def assert_body_has_correct_payload ( recorder , events ) : [EOL] assert len ( recorder ) == len ( events ) [EOL] [EOL] for i , event in enumerate ( events ) : [EOL] body = { [string] : messaging . _MessagingService . encode_message ( _build_data_message ( client_token = [string] , event = event ) ) } [EOL] assert json . loads ( recorder [ i ] . body . decode ( ) ) == body [EOL] [EOL] [EOL] def test_send_on_blockchain_event ( raw_push_service , recorder , web3_event_transfer , web3_event_trustline_request , web3_event_trustline_request_cancel , web3_event_trustline_update , ) : [EOL] events = [ TransferEvent ( web3_event = web3_event_transfer , current_blocknumber = [number] , timestamp = [number] , user = [string] , ) , TrustlineRequestEvent ( web3_event = web3_event_trustline_request , current_blocknumber = [number] , timestamp = [number] , user = [string] , ) , TrustlineRequestCancelEvent ( web3_event = web3_event_trustline_request_cancel , current_blocknumber = [number] , timestamp = [number] , user = [string] , ) , TrustlineUpdateEvent ( web3_event = web3_event_trustline_update , current_blocknumber = [number] , timestamp = [number] , user = [string] , ) , ] [EOL] [EOL] for event in events : [EOL] raw_push_service . send_event ( client_token = [string] , event = event ) [EOL] [EOL] assert_body_has_correct_payload ( recorder , events ) [EOL] [EOL] [EOL] def test_send_on_non_blockchain_event ( raw_push_service , recorder ) : [EOL] message_events = [ payment_request_message_event , payment_request_decline_message_event , ] [EOL] [EOL] for message_event in message_events : [EOL] raw_push_service . send_event ( client_token = [string] , event = message_event ) [EOL] [EOL] assert_body_has_correct_payload ( recorder , message_events ) [EOL] [EOL] [EOL] def test_build_data_prop_trustline_update ( web3_event_trustline_update ) : [EOL] event = TrustlineUpdateEvent ( web3_event_trustline_update , [number] , [number] , [string] ) [EOL] data = _build_data_prop ( event ) [EOL] assert data == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def test_build_data_prop_trustline_transfer ( web3_event_transfer ) : [EOL] event = TransferEvent ( web3_event = web3_event_transfer , current_blocknumber = [number] , timestamp = [number] , user = [string] , ) [EOL] [EOL] data = _build_data_prop ( event ) [EOL] assert data == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def test_build_data_prop_trustline_request_event ( web3_event_trustline_request ) : [EOL] event = TrustlineRequestEvent ( web3_event = web3_event_trustline_request , current_blocknumber = [number] , timestamp = [number] , user = [string] , ) [EOL] [EOL] data = _build_data_prop ( event ) [EOL] assert data == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def test_build_data_prop_trustline_request_cancel_event ( web3_event_trustline_request_cancel , ) : [EOL] event = TrustlineRequestCancelEvent ( web3_event = web3_event_trustline_request_cancel , current_blocknumber = [number] , timestamp = [number] , user = [string] , ) [EOL] [EOL] data = _build_data_prop ( event ) [EOL] assert data == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def test_build_data_prop_payment_request ( ) : [EOL] payment_request_event = MessageEvent ( message = requestMessagePayload , type = [string] , timestamp = int ( time . time ( ) ) ) [EOL] [EOL] data = _build_data_prop ( payment_request_event ) [EOL] [EOL] assert data == { [string] : requestMessagePayload , [string] : [string] } [EOL] [EOL] [EOL] def test_build_data_prop_payment_request_decline ( ) : [EOL] payment_request_decline_event = MessageEvent ( message = requestDeclineMessagePayload , type = [string] , timestamp = int ( time . time ( ) ) , ) [EOL] [EOL] data = _build_data_prop ( payment_request_decline_event ) [EOL] [EOL] assert data == { [string] : requestDeclineMessagePayload , [string] : [string] , } [EOL] [EOL] [EOL] def test_build_firebase_data_message ( web3_event_trustline_request ) : [EOL] request_event = TrustlineRequestEvent ( web3_event = web3_event_trustline_request , current_blocknumber = [number] , timestamp = [number] , user = [string] , ) [EOL] data = _build_data_prop ( request_event ) [EOL] [EOL] message = _build_data_message ( client_token = [string] , event = request_event ) [EOL] [EOL] assert message . data [ [string] ] == data [ [string] ] [EOL] assert message . data [ [string] ] == data [ [string] ] [EOL] assert message . data [ [string] ] == data [ [string] ] [EOL] assert message . data [ [string] ] == data [ [string] ] [EOL] assert message . data [ [string] ] == data [ [string] ] [EOL] assert message . token == [string] [EOL] assert message . android . priority == [string] [EOL] assert message . apns . payload . aps . content_available == [number] [EOL] assert message . apns . headers [ [string] ] == [string] [EOL] assert message . apns . headers [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.unit.pushnotifications.utils.MockCredential$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $tests.unit.pushnotifications.utils.MockCredential$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import relay [EOL] import pytest [EOL] from sqlalchemy import create_engine [EOL] [EOL] from relay . pushservice . client_token_db import ( ClientTokenAlreadyExistsException , ClientTokenDB , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def client_token_db ( ) : [EOL] return ClientTokenDB ( create_engine ( [string] ) ) [EOL] [EOL] [EOL] def test_add_client_token ( client_token_db ) : [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] assert client_token_db . get_client_tokens ( [string] ) == [ [string] ] [EOL] [EOL] [EOL] def test_add_multiple_client_token ( client_token_db ) : [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] assert set ( client_token_db . get_client_tokens ( [string] ) ) == { [string] , [string] , [string] , } [EOL] [EOL] [EOL] def test_cannot_add_same_token_twice ( client_token_db ) : [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] with pytest . raises ( ClientTokenAlreadyExistsException ) : [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] assert client_token_db . get_client_tokens ( [string] ) == [ [string] ] [EOL] [EOL] [EOL] def test_delete_token ( client_token_db ) : [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] client_token_db . delete_client_token ( [string] , [string] ) [EOL] assert client_token_db . get_client_tokens ( [string] ) == [ ] [EOL] [EOL] [EOL] def test_delete_non_existent_token ( client_token_db ) : [EOL] client_token_db . delete_client_token ( [string] , [string] ) [EOL] assert client_token_db . get_client_tokens ( [string] ) == [ ] [EOL] [EOL] [EOL] def test_get_client_tokens ( client_token_db ) : [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] assert client_token_db . get_client_tokens ( [string] ) == [ [string] ] [EOL] [EOL] [EOL] def test_all_tokens ( client_token_db ) : [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] client_token_db . add_client_token ( [string] , [string] ) [EOL] assert set ( client_token_db . get_all_client_tokens ( ) ) == { ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import tests [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import io [EOL] [EOL] import firebase_admin [EOL] from google . auth import credentials , transport [EOL] from requests import adapters , models [EOL] [EOL] [EOL] class MockResponse ( transport . Response ) : [EOL] def __init__ ( self , status , response ) : [EOL] self . _status = status [EOL] self . _response = response [EOL] [EOL] @ property def status ( self ) : [EOL] return self . _status [EOL] [EOL] @ property def headers ( self ) : [EOL] return { } [EOL] [EOL] @ property def data ( self ) : [EOL] return self . _response . encode ( ) [EOL] [EOL] [EOL] class MockRequest ( transport . Request ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , status , response ) : [EOL] self . response = MockResponse ( status , response ) [EOL] self . log = [ ] [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [comment] [EOL] self . log . append ( ( args , kwargs ) ) [EOL] return self . response [EOL] [EOL] [EOL] class MockFailedRequest ( transport . Request ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , error ) : [EOL] self . error = error [EOL] self . log = [ ] [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [comment] [EOL] self . log . append ( ( args , kwargs ) ) [EOL] raise self . error [EOL] [EOL] [EOL] class MockGoogleCredential ( credentials . Credentials ) : [EOL] [docstring] [EOL] [EOL] def refresh ( self , request ) : [EOL] self . token = [string] [EOL] [EOL] [EOL] class MockCredential ( firebase_admin . credentials . Base ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _g_credential = MockGoogleCredential ( ) [EOL] [EOL] def get_credential ( self ) : [EOL] return self . _g_credential [EOL] [EOL] [EOL] class MockMultiRequestAdapter ( adapters . HTTPAdapter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , responses , statuses , recorder ) : [EOL] [docstring] [EOL] adapters . HTTPAdapter . __init__ ( self ) [EOL] if len ( responses ) != len ( statuses ) : [EOL] raise ValueError ( [string] ) [EOL] self . _current_response = [number] [EOL] self . _responses = list ( responses ) [comment] [EOL] self . _statuses = list ( statuses ) [EOL] self . _recorder = recorder [EOL] [EOL] def send ( self , request , ** kwargs ) : [comment] [EOL] request . _extra_kwargs = kwargs [EOL] self . _recorder . append ( request ) [EOL] resp = models . Response ( ) [EOL] resp . url = request . url [EOL] resp . status_code = self . _statuses [ self . _current_response ] [EOL] resp . raw = io . BytesIO ( self . _responses [ self . _current_response ] . encode ( ) ) [EOL] self . _current_response = min ( self . _current_response + [number] , len ( self . _responses ) - [number] ) [EOL] return resp [EOL] [EOL] [EOL] class MockAdapter ( MockMultiRequestAdapter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , status , recorder ) : [EOL] super ( MockAdapter , self ) . __init__ ( [ data ] , [ status ] , recorder ) [EOL] [EOL] @ property def status ( self ) : [EOL] return self . _statuses [ [number] ] [EOL] [EOL] @ property def data ( self ) : [EOL] return self . _responses [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.unit.pushnotifications.utils.MockResponse$ 0 0 0 0 0 $tests.unit.pushnotifications.utils.MockResponse$ 0 0 0 0 0 $tests.unit.pushnotifications.utils.MockResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.unit.pushnotifications.utils.MockGoogleCredential$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $requests.models.Response$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $requests.models.Response$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import attr [EOL] import pytest [EOL] from hexbytes import HexBytes [EOL] from marshmallow import ValidationError [EOL] from tldeploy import identity [EOL] from web3 . datastructures import AttributeDict [EOL] [EOL] from relay . api import schemas [EOL] from relay . blockchain . currency_network_events import TransferEvent [EOL] from relay . network_graph . payment_path import FeePayer , PaymentPath [EOL] [EOL] a_valid_meta_transaction = identity . MetaTransaction ( from_ = [string] , to = [string] , chain_id = [number] , value = [number] , data = bytes . fromhex ( [string] ) , nonce = [number] , signature = bytes . fromhex ( [string] [string] ) , ) [EOL] [EOL] [EOL] web3_transfer_event = AttributeDict ( { [string] : AttributeDict ( { [string] : [string] , [string] : [string] , [string] : [number] , [string] : HexBytes ( [string] ) , } ) , [string] : [string] , [string] : [number] , [string] : [number] , [string] : HexBytes ( [string] ) , [string] : [string] , [string] : HexBytes ( [string] ) , [string] : [number] , } ) [EOL] [EOL] [EOL] def gen_meta_transactions ( ) : [EOL] mt = a_valid_meta_transaction [EOL] return [ mt , attr . evolve ( mt , data = [string] ) , attr . evolve ( mt , nonce = [number] ) , attr . evolve ( mt , value = [number] ) , attr . evolve ( mt , nonce = [number] ** [number] - [number] ) , attr . evolve ( mt , data = HexBytes ( [string] ) ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , gen_meta_transactions ( ) ) def test_meta_transaction_roundtrip ( meta_transaction ) : [EOL] dumped = schemas . MetaTransactionSchema ( ) . dump ( meta_transaction ) [EOL] print ( [string] , dumped ) [EOL] [EOL] loaded = schemas . MetaTransactionSchema ( ) . load ( dumped ) [EOL] print ( [string] , loaded ) [EOL] [EOL] assert loaded == meta_transaction [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ dict ( nonce = [string] ) , dict ( nonce = [number] ) , dict ( nonce = str ( [number] ** [number] ) ) , dict ( data = [string] ) , dict ( data = [string] ) , dict ( data = [string] ) , dict ( data = [string] ) , dict ( value = [string] ) , dict ( value = str ( [number] ** [number] ) ) , dict ( value = [string] ) , dict ( signature = [string] ) , dict ( signature = [string] + [string] * [number] ) , dict ( signature = [string] + [string] * [number] ) , ] , ) def test_load_meta_transaction_invalid_values ( values ) : [EOL] dumped = schemas . MetaTransactionSchema ( ) . dump ( a_valid_meta_transaction ) [EOL] dumped . update ( values ) [EOL] with pytest . raises ( ValidationError ) : [EOL] schemas . MetaTransactionSchema ( ) . load ( dumped ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ dict ( nonce = [string] ) , dict ( data = [string] ) , dict ( data = [string] ) , dict ( feeRecipient = [string] + [string] * [number] ) , dict ( nonce = str ( [number] ** [number] - [number] ) ) , dict ( value = [string] ) , dict ( value = str ( [number] ** [number] - [number] ) ) , dict ( value = [string] ) , dict ( signature = [string] + [string] * [number] ) , ] , ) def test_load_meta_transaction_valid_values ( values ) : [EOL] dumped = schemas . MetaTransactionSchema ( ) . dump ( a_valid_meta_transaction ) [EOL] dumped . update ( values ) [EOL] [comment] [EOL] schemas . MetaTransactionSchema ( ) . load ( dumped ) [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ FeePayer . SENDER , FeePayer . RECEIVER ] ) def payment_path ( request ) : [EOL] [EOL] cost = [number] [EOL] path = [ ] [EOL] value = [number] [EOL] fee_payer = request . param [EOL] [EOL] return PaymentPath ( cost , path , value , fee_payer = fee_payer ) [EOL] [EOL] [EOL] def test_payment_path_roundtrip ( payment_path ) : [EOL] [EOL] dumped = schemas . PaymentPathSchema ( ) . dump ( payment_path ) [EOL] print ( [string] , dumped ) [EOL] [EOL] loaded = schemas . PaymentPathSchema ( ) . load ( dumped ) [EOL] print ( [string] , loaded ) [EOL] [EOL] assert loaded == payment_path [EOL] [EOL] [EOL] def test_no_class_type_in_event ( ) : [EOL] event = TransferEvent ( web3_transfer_event , [number] , [number] ) [EOL] [EOL] dumped = schemas . AnyEventSchema ( ) . dump ( event ) [EOL] [EOL] assert dumped . get ( schemas . AnyEventSchema . type_field ) is None [EOL] assert dumped [ [string] ] == str ( event . value ) [EOL] assert dumped [ [string] ] == event . from_ [EOL] assert dumped [ [string] ] == event . extra_data . hex ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from relay . api . exchange . schemas import OrderSchema [EOL] from relay . exchange . order import Order [EOL] [EOL] [EOL] @ pytest . fixture ( ) def order ( ) : [EOL] return Order ( [string] , [string] , [string] , [string] , [string] , [string] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , bytes ( [ [number] ] ) , bytes ( [ [number] ] ) , ) [EOL] [EOL] [EOL] def test_sig_v ( order ) : [EOL] serialized_order = OrderSchema ( ) . dump ( order ) [EOL] assert type ( serialized_order [ [string] ] [ [string] ] ) == int [EOL] [EOL] [EOL] def test_sig_rs ( order ) : [EOL] serialized_order = OrderSchema ( ) . dump ( order ) [EOL] r = serialized_order [ [string] ] [ [string] ] [EOL] s = serialized_order [ [string] ] [ [string] ] [EOL] for x in r , s : [EOL] assert type ( s ) == str [EOL] assert x [ [number] : [number] ] == [string] [EOL] assert len ( x ) == [number] [EOL] [EOL] [EOL] def test_sig_lowercase ( order ) : [EOL] serialized_order = OrderSchema ( ) . dump ( order ) [EOL] r = serialized_order [ [string] ] [ [string] ] [EOL] s = serialized_order [ [string] ] [ [string] ] [EOL] for x in r , s : [EOL] assert x . islower ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import pytest [EOL] from sqlalchemy import create_engine [EOL] [EOL] from relay . constants import NULL_ADDRESS [EOL] from relay . exchange . order import SignableOrder [EOL] [EOL] [EOL] @ pytest . fixture ( ) def engine ( ) : [EOL] return create_engine ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def orders ( addresses , test_account ) : [EOL] A , B , C , D = addresses [EOL] maker = test_account . address [EOL] orders = [ SignableOrder ( exchange_address = A , maker_address = maker , taker_address = NULL_ADDRESS , maker_token = C , taker_token = D , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) , SignableOrder ( exchange_address = A , maker_address = maker , taker_address = NULL_ADDRESS , maker_token = C , taker_token = D , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) , SignableOrder ( exchange_address = A , maker_address = maker , taker_address = NULL_ADDRESS , maker_token = B , taker_token = D , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) , SignableOrder ( exchange_address = A , maker_address = maker , taker_address = NULL_ADDRESS , maker_token = D , taker_token = C , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) , SignableOrder ( exchange_address = A , maker_address = maker , taker_address = NULL_ADDRESS , maker_token = C , taker_token = D , fee_recipient = NULL_ADDRESS , maker_token_amount = [number] , taker_token_amount = [number] , maker_fee = [number] , taker_fee = [number] , expiration_timestamp_in_sec = [number] , salt = [number] , ) , ] [EOL] for order in orders : [EOL] order . sign ( test_account . private_key ) [EOL] return orders [EOL] [EOL] [EOL] @ pytest . fixture ( ) def order ( orders ) : [EOL] return orders [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Sequence [EOL] import typing [EOL] import relay [EOL] import builtins [EOL] from typing import Sequence [EOL] [EOL] import pytest [EOL] [EOL] from relay . exchange . exchange_db import OrderBookDB [EOL] from relay . exchange . order import Order [EOL] [EOL] [EOL] @ pytest . fixture ( ) def orderbook_db ( engine ) : [EOL] return OrderBookDB ( engine ) [EOL] [EOL] [EOL] def test_get_order ( order , orderbook_db ) : [EOL] [EOL] orderbook_db . add_order ( order ) [EOL] [EOL] assert orderbook_db . get_order_by_hash ( order . hash ( ) ) == order [EOL] [EOL] [EOL] def test_get_orders ( orders , orderbook_db , addresses ) : [EOL] A , B , C , D = addresses [EOL] [EOL] orderbook_db . add_orders ( orders ) [EOL] [EOL] orders_result = orderbook_db . get_orderbook_by_tokenpair ( ( C , D ) ) [EOL] [EOL] assert len ( orders_result ) == [number] [EOL] [EOL] [EOL] def test_same_order_not_added ( order , orderbook_db , addresses ) : [EOL] A , B , C , D = addresses [EOL] [EOL] orderbook_db . add_order ( order ) [EOL] orderbook_db . add_order ( order ) [EOL] [EOL] orders_result = orderbook_db . get_orderbook_by_tokenpair ( ( C , D ) ) [EOL] [EOL] assert len ( orders_result ) == [number] [EOL] [EOL] [EOL] def test_get_orders_order ( orders , orderbook_db , addresses ) : [EOL] A , B , C , D = addresses [EOL] o1 , o2 , o3 , o4 , o5 = orders [EOL] [EOL] orderbook_db . add_orders ( orders ) [EOL] [EOL] orders_result = orderbook_db . get_orderbook_by_tokenpair ( ( C , D ) ) [EOL] [EOL] assert list ( orders_result ) == [ o5 , o1 , o2 ] [EOL] [EOL] [EOL] def test_get_orders_order_price_desc ( orders , orderbook_db , addresses ) : [EOL] A , B , C , D = addresses [EOL] o1 , o2 , o3 , o4 , o5 = orders [EOL] [EOL] orderbook_db . add_orders ( orders ) [EOL] [EOL] orders_result = orderbook_db . get_orderbook_by_tokenpair ( ( C , D ) , desc_price = True ) [EOL] [EOL] assert list ( orders_result ) == [ o1 , o2 , o5 ] [EOL] [EOL] [EOL] def test_delete_order ( orders , orderbook_db , addresses ) : [EOL] A , B , C , D = addresses [EOL] o1 , o2 , o3 , o4 , o5 = orders [EOL] [EOL] orderbook_db . add_orders ( orders ) [EOL] orderbook_db . delete_order_by_hash ( o2 . hash ( ) ) [EOL] [EOL] orders_result = orderbook_db . get_orderbook_by_tokenpair ( ( C , D ) ) [EOL] [EOL] assert list ( orders_result ) == [ o5 , o1 ] [EOL] [EOL] [EOL] def test_delete_orders ( orders , orderbook_db , addresses ) : [EOL] A , B , C , D = addresses [EOL] o1 , o2 , o3 , o4 , o5 = orders [EOL] [EOL] orderbook_db . add_orders ( orders ) [EOL] orderbook_db . delete_orders_by_hash ( [ o2 . hash ( ) , o5 . hash ( ) ] ) [EOL] [EOL] orders_result = orderbook_db . get_orderbook_by_tokenpair ( ( C , D ) ) [EOL] [EOL] assert list ( orders_result ) == [ o1 ] [EOL] [EOL] [EOL] def test_delete_old_orders ( orders , orderbook_db , addresses ) : [EOL] A , B , C , D = addresses [EOL] o1 , o2 , o3 , o4 , o5 = orders [EOL] [EOL] orderbook_db . add_orders ( orders ) [EOL] orderbook_db . delete_old_orders ( [number] ) [EOL] [EOL] orders_result = orderbook_db . get_orderbook_by_tokenpair ( ( C , D ) ) [EOL] [EOL] assert list ( orders_result ) == [ o5 , o2 ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $relay.exchange.exchange_db.OrderBookDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import relay [EOL] import pytest [EOL] [EOL] from relay . blockchain . exchange_proxy import DummyExchangeProxy [EOL] from relay . exchange . orderbook import OrderBook [EOL] [EOL] [EOL] @ pytest . fixture ( ) def orderbook ( engine , addresses ) : [EOL] orderbook = OrderBook ( ) [EOL] orderbook . connect_db ( engine ) [EOL] A , * rest = addresses [EOL] orderbook . add_exchange ( DummyExchangeProxy ( A ) ) [EOL] return orderbook [EOL] [EOL] [EOL] def test_bids ( orderbook , orders , addresses ) : [EOL] A , B , C , D = addresses [EOL] o1 , o2 , o3 , o4 , o5 = orders [EOL] [EOL] orderbook . add_orders ( orders ) [EOL] [EOL] assert orderbook . get_bids_by_tokenpair ( ( C , D ) ) == [ o4 ] [EOL] [EOL] [EOL] def test_asks ( orderbook , orders , addresses ) : [EOL] A , B , C , D = addresses [EOL] o1 , o2 , o3 , o4 , o5 = orders [EOL] [EOL] orderbook . add_orders ( orders ) [EOL] [EOL] assert orderbook . get_asks_by_tokenpair ( ( C , D ) ) == [ o5 , o1 , o2 ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
NULL_ADDRESS = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] import gevent [EOL] import gevent . lock [EOL] import wrapt [EOL] [EOL] [EOL] [comment] [EOL] @ wrapt . decorator def synchronized ( wrapped , instance , args , kwargs ) : [EOL] if instance is None : [EOL] owner = wrapped [EOL] else : [EOL] owner = instance [EOL] [EOL] lock = vars ( owner ) . get ( [string] , None ) [EOL] [EOL] [comment] [EOL] if lock is None : [EOL] lock = gevent . lock . RLock ( ) [EOL] setattr ( owner , [string] , lock ) [EOL] [EOL] with lock : [EOL] return wrapped ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import copy [EOL] import logging [EOL] [EOL] import eth_utils [EOL] from web3 . middleware import construct_sign_and_send_raw_middleware [EOL] [EOL] from relay . concurrency_utils import synchronized [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ synchronized def _eth_send_transaction ( make_request , w3 , method , params ) : [EOL] [docstring] [EOL] assert method == [string] [EOL] if [string] not in params [ [number] ] : [EOL] params [ [number] ] [ [string] ] = int ( w3 . manager . request_blocking ( [string] , [ params [ [number] ] [ [string] ] ] ) , [number] ) [EOL] nonce = params [ [number] ] [ [string] ] [EOL] logger . debug ( [string] , nonce , params ) [EOL] [EOL] res = make_request ( method , params ) [EOL] logger . debug ( [string] , nonce , res ) [EOL] return res [EOL] [EOL] [EOL] def make_prepare_signing_middleware ( default_from_address ) : [EOL] [docstring] [EOL] [EOL] def prepare_signing_middleware ( make_request , w3 ) : [EOL] def middleware ( method , params ) : [EOL] if method != [string] : [EOL] return make_request ( method , params ) [EOL] from_address = params [ [number] ] . get ( [string] ) [EOL] if from_address is not None and not eth_utils . is_same_address ( from_address , default_from_address ) : [EOL] return make_request ( method , params ) [EOL] params = copy . deepcopy ( params ) [EOL] params [ [number] ] [ [string] ] = default_from_address [EOL] return _eth_send_transaction ( make_request , w3 , method , params ) [EOL] [EOL] return middleware [EOL] [EOL] return prepare_signing_middleware [EOL] [EOL] [EOL] def install_signing_middleware ( w3 , account ) : [EOL] if w3 . eth . defaultAccount : [EOL] raise RuntimeError ( [string] ) [EOL] w3 . middleware_onion . add ( construct_sign_and_send_raw_middleware ( account ) ) [EOL] w3 . eth . defaultAccount = account . address [EOL] w3 . middleware_onion . add ( make_prepare_signing_middleware ( account . address ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import MutableMapping , Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] from enum import Enum [EOL] from typing import MutableMapping [EOL] [EOL] from web3 import HTTPProvider , IPCProvider , WebsocketProvider [EOL] from web3 . providers . auto import load_provider_from_uri [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class ProviderType ( Enum ) : [EOL] HTTP = [string] [EOL] WEBSOCKET = [string] [EOL] IPC = [string] [EOL] [EOL] [EOL] def create_provider_from_config ( rpc_config ) : [EOL] uri = rpc_config . get ( [string] , None ) [EOL] if uri is not None : [EOL] logger . info ( f" [string] { uri }" ) [EOL] provider = load_provider_from_uri ( uri ) [EOL] logger . info ( f" [string] { provider . __class__ . __name__ }" ) [EOL] return provider [EOL] [EOL] provider_type = rpc_config [ [string] ] [EOL] if provider_type is ProviderType . HTTP : [EOL] url = [string] . format ( [string] if rpc_config [ [string] ] else [string] , rpc_config [ [string] ] , rpc_config [ [string] ] , ) [EOL] logger . info ( [string] . format ( url ) ) [EOL] return HTTPProvider ( url ) [EOL] elif provider_type is ProviderType . WEBSOCKET : [EOL] url = [string] . format ( [string] if rpc_config [ [string] ] else [string] , rpc_config [ [string] ] , rpc_config [ [string] ] , ) [EOL] logger . info ( [string] . format ( url ) ) [EOL] return WebsocketProvider ( url ) [EOL] elif provider_type is ProviderType . IPC : [EOL] file_path = rpc_config [ [string] ] [EOL] logger . info ( [string] . format ( file_path ) ) [EOL] return IPCProvider ( file_path ) [EOL] else : [EOL] raise ValueError ( f" [string] { provider_type }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import builtins [EOL] import typing [EOL] from typing import Tuple [EOL] [EOL] from eth_keys import keys [EOL] from eth_keys . exceptions import BadSignature [EOL] from eth_utils import decode_hex , is_0x_prefixed , keccak [EOL] [EOL] [EOL] def pack ( * args ) : [EOL] [docstring] [EOL] [EOL] def format_int ( value , size ) : [EOL] assert isinstance ( value , int ) [EOL] assert isinstance ( size , int ) [EOL] if value >= [number] : [EOL] return decode_hex ( [string] . format ( value ) . zfill ( size // [number] ) ) [EOL] else : [EOL] return decode_hex ( [string] . format ( ( [number] << size ) + value ) ) [EOL] [EOL] msg = [string] [EOL] for arg in args : [EOL] assert arg is not None [EOL] if isinstance ( arg , bytes ) : [EOL] msg += arg [EOL] elif isinstance ( arg , str ) : [EOL] if is_0x_prefixed ( arg ) : [EOL] msg += decode_hex ( arg ) [EOL] else : [EOL] msg += arg . encode ( ) [EOL] elif isinstance ( arg , bool ) : [EOL] msg += format_int ( int ( arg ) , [number] ) [EOL] elif isinstance ( arg , int ) : [EOL] msg += format_int ( arg , [number] ) [EOL] elif isinstance ( arg , tuple ) : [EOL] msg += format_int ( arg [ [number] ] , arg [ [number] ] ) [EOL] else : [EOL] raise ValueError ( [string] . format ( type ( arg ) ) ) [EOL] [EOL] return msg [EOL] [EOL] [EOL] def keccak256 ( * args ) : [EOL] return keccak ( pack ( * args ) ) [EOL] [EOL] [EOL] def eth_sign ( hash , key ) : [EOL] v , r , s = ( keys . PrivateKey ( key ) . sign_msg_hash ( keccak256 ( [string] , hash ) ) . vrs ) [EOL] if v < [number] : [EOL] v += [number] [EOL] r = r . to_bytes ( [number] , byteorder = [string] ) [EOL] s = s . to_bytes ( [number] , byteorder = [string] ) [EOL] return v , r , s [EOL] [EOL] [EOL] def eth_validate ( msg_hash , vrs , address ) : [EOL] v , r , s = vrs [EOL] if isinstance ( v , bytes ) : [EOL] v = int . from_bytes ( r , byteorder = [string] ) [EOL] if isinstance ( r , bytes ) : [EOL] r = int . from_bytes ( r , byteorder = [string] ) [EOL] if isinstance ( s , bytes ) : [EOL] s = int . from_bytes ( s , byteorder = [string] ) [EOL] if v >= [number] : [EOL] v -= [number] [EOL] sig = keys . Signature ( vrs = ( v , r , s ) ) [EOL] try : [EOL] pubkey = sig . recover_public_key_from_msg_hash ( keccak256 ( [string] , msg_hash ) ) [EOL] return pubkey . to_checksum_address ( ) == address [EOL] except BadSignature : [EOL] return False [EOL] [EOL] [EOL] def priv_to_pubkey ( key ) : [EOL] return keys . PrivateKey ( key ) . public_key . to_checksum_address ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.bytes,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] import pkg_resources [EOL] import web3 [EOL] [EOL] [EOL] def merge_two_dicts ( x , y ) : [EOL] [docstring] [EOL] z = x . copy ( ) [EOL] z . update ( y ) [EOL] return z [EOL] [EOL] [EOL] def trim_args ( args ) : [EOL] trimmed_args = { } [EOL] for key in args : [EOL] trimmed_args [ key [ [number] : len ( key ) ] ] = args [ key ] [EOL] return trimmed_args [EOL] [EOL] [EOL] def sha3 ( text ) : [EOL] return web3 . Web3 . keccak ( text = text ) . hex ( ) [EOL] [EOL] [EOL] def get_version ( ) : [EOL] try : [EOL] return pkg_resources . get_distribution ( [string] ) . version [EOL] except pkg_resources . DistributionNotFound : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , List , Dict , Type [EOL] import typing [EOL] import src [EOL] import builtins [EOL] import tldeploy [EOL] from enum import Enum [EOL] from typing import List [EOL] [EOL] import attr [EOL] from deploy_tools . deploy import TransactionFailed [EOL] from tldeploy . identity import ( Delegate as DelegateImplementation , MetaTransaction , UnexpectedIdentityContractException , deploy_proxied_identity , get_pinned_proxy_interface , ) [EOL] from web3 . exceptions import BadFunctionCallOutput [EOL] [EOL] ZERO_ADDRESS = [string] + [string] * [number] [EOL] [EOL] [EOL] class GasPriceMethod ( Enum ) : [EOL] RPC = [string] [EOL] FIXED = [string] [EOL] BOUND = [string] [EOL] [EOL] [EOL] @ attr . s class DelegationFees : [EOL] currency_network_of_fees = attr . ib ( ) [EOL] fee_recipient = attr . ib ( default = ZERO_ADDRESS ) [EOL] base_fee = attr . ib ( default = [number] ) [EOL] gas_price = attr . ib ( default = [number] ) [EOL] [EOL] [EOL] class Delegate : [EOL] def __init__ ( self , web3 , node_address , identity_contract_abi , known_factories , delegation_fees , config , ) : [EOL] self . _web3 = web3 [EOL] [EOL] self . delegate = DelegateImplementation ( node_address , web3 = web3 , identity_contract_abi = identity_contract_abi ) [EOL] self . known_factories = known_factories [EOL] self . delegation_fees = delegation_fees [EOL] self . config = config [EOL] [EOL] def send_signed_meta_transaction ( self , signed_meta_transaction ) : [EOL] self . raise_on_invalid_signed_meta_transaction ( signed_meta_transaction ) [EOL] self . validate_meta_transaction_fees ( signed_meta_transaction ) [EOL] [EOL] transaction_options = { [string] : self . _calculate_gas_limit ( meta_transaction = signed_meta_transaction ) , [string] : self . _calculate_gas_price ( meta_transaction = signed_meta_transaction ) , } [EOL] [EOL] return self . delegate . send_signed_meta_transaction ( signed_meta_transaction , transaction_options = transaction_options ) [EOL] [EOL] def deploy_identity ( self , factory_address , implementation_address , signature ) : [EOL] if factory_address not in self . known_factories : [EOL] raise UnknownIdentityFactoryException ( factory_address ) [EOL] transaction_options = { [string] : self . _calculate_gas_price ( meta_transaction = None ) } [EOL] try : [EOL] [comment] [EOL] return self . _web3 . toChecksumAddress ( deploy_proxied_identity ( self . _web3 , factory_address , implementation_address , signature , transaction_options = transaction_options , ) . address ) [EOL] except TransactionFailed : [EOL] raise IdentityDeploymentFailedException [EOL] [EOL] def calc_next_nonce ( self , identity_address ) : [EOL] try : [EOL] return self . delegate . get_next_nonce ( identity_address ) [EOL] except UnexpectedIdentityContractException : [EOL] raise InvalidIdentityContractException [EOL] [EOL] def get_implementation_address ( self , identity_address ) : [EOL] proxy_abi = get_pinned_proxy_interface ( ) [ [string] ] [EOL] proxy_contract = self . _web3 . eth . contract ( abi = proxy_abi , address = identity_address ) [EOL] try : [EOL] return proxy_contract . functions . implementation ( ) . call ( ) [EOL] except BadFunctionCallOutput : [EOL] raise InvalidIdentityContractException [EOL] [EOL] def calculate_fees_for_meta_transaction ( self , meta_transaction ) : [EOL] self . raise_on_invalid_meta_transaction ( meta_transaction ) [EOL] return self . _calculate_fees_for_meta_transaction ( meta_transaction ) [EOL] [EOL] def _calculate_fees_for_meta_transaction ( self , meta_transaction ) : [EOL] [docstring] [EOL] return self . delegation_fees [EOL] [EOL] def validate_meta_transaction_fees ( self , meta_transaction ) : [EOL] fees_estimations = self . _calculate_fees_for_meta_transaction ( meta_transaction ) [EOL] [EOL] for fees_estimation in fees_estimations : [EOL] if fees_estimation . base_fee == [number] and fees_estimation . gas_price == [number] : [EOL] return [EOL] [comment] [EOL] if ( fees_estimation . currency_network_of_fees == meta_transaction . currency_network_of_fees [EOL] and fees_estimation . base_fee <= meta_transaction . base_fee [EOL] and fees_estimation . gas_price <= meta_transaction . gas_price [EOL] and ( fees_estimation . fee_recipient == meta_transaction . fee_recipient or meta_transaction . fee_recipient == ZERO_ADDRESS ) ) : [EOL] return [EOL] [EOL] raise InvalidDelegationFeesException ( ) [EOL] [EOL] def raise_on_invalid_meta_transaction ( self , meta_transaction ) : [EOL] if not self . delegate . validate_time_limit ( meta_transaction ) : [EOL] raise InvalidTimeLimit [EOL] if not self . delegate . validate_chain_id ( meta_transaction ) : [EOL] raise InvalidChainId [EOL] if not self . delegate . validate_nonce ( meta_transaction ) : [EOL] raise InvalidNonceHashPair [EOL] [EOL] def raise_on_invalid_signed_meta_transaction ( self , signed_meta_transaction ) : [EOL] self . raise_on_invalid_meta_transaction ( signed_meta_transaction ) [EOL] if not self . delegate . validate_signature ( signed_meta_transaction ) : [EOL] raise InvalidSignature [EOL] [EOL] def _calculate_gas_price ( self , meta_transaction = None ) : [EOL] method = self . config [ [string] ] [EOL] if method == GasPriceMethod . FIXED : [EOL] return self . config [ [string] ] [EOL] elif method == GasPriceMethod . BOUND : [EOL] return min ( max ( self . _fetch_rpc_gas_price ( ) , self . config [ [string] ] ) , self . config [ [string] ] , ) [EOL] elif method == GasPriceMethod . RPC : [EOL] return self . _fetch_rpc_gas_price ( ) [EOL] else : [EOL] raise ValueError ( f" [string] { method }" ) [EOL] [EOL] def _calculate_gas_limit ( self , meta_transaction = None ) : [EOL] return self . config [ [string] ] [EOL] [EOL] def _fetch_rpc_gas_price ( self ) : [EOL] raw_value = self . _web3 . manager . request_blocking ( [string] , [ ] ) [EOL] if isinstance ( raw_value , int ) : [EOL] return raw_value [EOL] elif isinstance ( raw_value , str ) : [EOL] return int ( raw_value , [number] ) [EOL] else : [EOL] raise RuntimeError ( f" [string] { raw_value }" ) [EOL] [EOL] def get_meta_transaction_status ( self , identity_address , hash ) : [EOL] return self . delegate . get_meta_transaction_status ( identity_address , hash ) [EOL] [EOL] [EOL] class InvalidIdentityContractException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidMetaTransactionException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidTimeLimit ( InvalidMetaTransactionException ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidChainId ( InvalidMetaTransactionException ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidNonceHashPair ( InvalidMetaTransactionException ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidSignature ( InvalidMetaTransactionException ) : [EOL] pass [EOL] [EOL] [EOL] class IdentityDeploymentFailedException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class UnknownIdentityFactoryException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidDelegationFeesException ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[DelegationFees]$ 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 $typing.List[DelegationFees]$ 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 $typing.List[src.relay.blockchain.delegate.DelegationFees]$ 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 $typing.List[src.relay.blockchain.delegate.DelegationFees]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $tldeploy.identity.MetaTransaction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import builtins [EOL] import logging [EOL] import src [EOL] import typing [EOL] import logging [EOL] import os [EOL] from collections import namedtuple [EOL] from enum import Enum [EOL] [EOL] from web3 . exceptions import TransactionNotFound [EOL] [EOL] from relay . concurrency_utils import synchronized [EOL] [EOL] TxInfos = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class TransactionStatus ( Enum ) : [EOL] SUCCESS = [string] [EOL] FAILURE = [string] [EOL] PENDING = [string] [EOL] NOT_FOUND = [string] [EOL] [EOL] [EOL] class Node : [EOL] def __init__ ( self , web3 , * , is_parity = True , fixed_gas_price = None ) : [EOL] [docstring] [EOL] self . _web3 = web3 [EOL] self . is_parity = is_parity [EOL] self . fixed_gas_price = fixed_gas_price [EOL] if is_parity : [EOL] logger . info ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if os . environ . get ( [string] , [string] ) == [string] : [EOL] logger . warning ( [string] ) [EOL] self . _send_tx = synchronized ( self . _web3 . eth . sendRawTransaction ) [EOL] else : [EOL] self . _send_tx = self . _web3 . eth . sendRawTransaction [EOL] [EOL] def relay_tx ( self , rawtxn ) : [EOL] return self . _send_tx ( rawtxn ) [EOL] [EOL] def transaction_receipt ( self , txn_hash ) : [EOL] return self . _web3 . eth . getTransactionReceipt ( txn_hash ) [EOL] [EOL] def get_tx_infos ( self , user_address , block_identifier = [string] ) : [EOL] if self . is_parity and block_identifier == [string] : [EOL] nonce = int ( self . _web3 . manager . request_blocking ( [string] , [ user_address ] ) , [number] , ) [EOL] else : [EOL] nonce = self . _web3 . eth . getTransactionCount ( user_address , block_identifier = block_identifier ) [EOL] return TxInfos ( balance = self . _web3 . eth . getBalance ( user_address , block_identifier = block_identifier ) , nonce = nonce , gas_price = self . fetch_gas_price ( ) , ) [EOL] [EOL] def fetch_gas_price ( self ) : [EOL] if self . fixed_gas_price is not None : [EOL] return self . fixed_gas_price [EOL] else : [EOL] return self . _web3 . eth . gasPrice [EOL] [EOL] @ property def address ( self ) : [EOL] return self . _web3 . eth . coinbase [EOL] [EOL] @ property def blocknumber ( self ) : [EOL] return self . _web3 . eth . blockNumber [EOL] [EOL] def balance ( self , address ) : [EOL] return self . _web3 . eth . getBalance ( address ) [EOL] [EOL] def send_ether ( self , address ) : [EOL] if self . _web3 . eth . getBalance ( address ) <= [number] : [EOL] return self . _web3 . eth . sendTransaction ( { [string] : self . _web3 . eth . coinbase , [string] : address , [string] : [number] , } ) . hex ( ) [EOL] else : [EOL] return None [EOL] [EOL] def get_block_timestamp ( self , block_number ) : [EOL] return self . _web3 . eth . getBlock ( block_number ) . timestamp [EOL] [EOL] def get_transaction_status ( self , hash ) : [EOL] try : [EOL] [comment] [EOL] status = self . _web3 . eth . getTransactionReceipt ( hash ) [ [string] ] [EOL] if status : [EOL] return TransactionStatus . SUCCESS [EOL] else : [EOL] return TransactionStatus . FAILURE [EOL] except TransactionNotFound : [EOL] try : [EOL] [comment] [EOL] self . _web3 . eth . getTransaction ( hash ) [EOL] return TransactionStatus . PENDING [EOL] except TransactionNotFound : [EOL] return TransactionStatus . NOT_FOUND [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import re [EOL] [EOL] import hexbytes [EOL] from eth_utils import is_address , to_checksum_address [EOL] from marshmallow import fields [EOL] from tldeploy . identity import MetaTransaction , MetaTransactionStatus [EOL] from webargs import ValidationError [EOL] [EOL] from relay . blockchain . node import TransactionStatus [EOL] from relay . network_graph . payment_path import FeePayer [EOL] [EOL] [EOL] class Address ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] return super ( ) . _serialize ( value , attr , obj , ** kwargs ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] if not is_address ( value ) : [EOL] raise ValidationError ( f" [string] { attr } [string] { value }" ) [EOL] [EOL] return to_checksum_address ( value ) [EOL] [EOL] [EOL] class Hash ( fields . String ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] if isinstance ( value , str ) or not re . match ( [string] , value ) : [EOL] raise ValidationError ( f" [string] { attr } [string] { value }" ) [EOL] [EOL] return value [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] if not isinstance ( value , str ) or not re . match ( [string] , value ) : [EOL] raise ValidationError ( f" [string] { attr } [string] { value }" ) [EOL] [EOL] return value [EOL] [EOL] [EOL] class BigInteger ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] assert isinstance ( value , int ) [EOL] value = str ( value ) [EOL] return super ( ) . _serialize ( value , attr , obj , ** kwargs ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] if not isinstance ( value , str ) : [EOL] raise ValidationError ( f"{ attr } [string] " ) [EOL] try : [EOL] int_value = int ( value ) [EOL] except ValueError : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] return int_value [EOL] [EOL] [EOL] class HexBytes ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] return [string] . format ( int . from_bytes ( value , [string] ) ) . lower ( ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] try : [EOL] hex_bytes = hexbytes . HexBytes ( value ) [EOL] except ValueError : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] return hex_bytes [EOL] [EOL] [EOL] class HexEncodedBytes ( fields . Field ) : [EOL] [docstring] [EOL] [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] if isinstance ( value , hexbytes . HexBytes ) : [EOL] return value . hex ( ) [EOL] elif isinstance ( value , bytes ) : [EOL] return [string] + value . hex ( ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] if not ( isinstance ( value , str ) and value . startswith ( [string] ) ) : [EOL] raise ValidationError ( f" [string] { attr } [string] { value }" ) [EOL] try : [EOL] [comment] [EOL] return hexbytes . HexBytes ( bytes . fromhex ( value [ [number] : ] ) ) [EOL] except ValueError : [EOL] raise ValidationError ( f" [string] { attr } [string] { value }" ) [EOL] [EOL] [EOL] class FeePayerField ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] [EOL] if isinstance ( value , FeePayer ) : [EOL] [comment] [EOL] return value . value [EOL] else : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] [EOL] [comment] [EOL] try : [EOL] return FeePayer ( value ) [EOL] except ValueError : [EOL] raise ValidationError ( f" [string] { attr } [string] { value } [string] " f"{ [ fee_payer . value for fee_payer in FeePayer ] }" ) [EOL] [EOL] [EOL] class MetaTransactionStatusField ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] [EOL] if isinstance ( value , MetaTransactionStatus ) : [EOL] [comment] [EOL] return value . value [EOL] else : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] [EOL] [comment] [EOL] try : [EOL] return MetaTransactionStatus ( value ) [EOL] except ValueError : [EOL] raise ValidationError ( f" [string] { attr } [string] { value } [string] " f"{ [ status . value for status in MetaTransactionStatus ] }" ) [EOL] [EOL] [EOL] class TransactionStatusField ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] [EOL] if isinstance ( value , TransactionStatus ) : [EOL] [comment] [EOL] return value . value [EOL] else : [EOL] raise ValidationError ( f" [string] { value }" ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] [EOL] [comment] [EOL] try : [EOL] return MetaTransactionStatus ( value ) [EOL] except ValueError : [EOL] raise ValidationError ( f" [string] { attr } [string] { value } [string] " f"{ [ status . value for status in TransactionStatus ] }" ) [EOL] [EOL] [EOL] class OperationTypeField ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] [EOL] if isinstance ( value , MetaTransaction . OperationType ) : [EOL] [comment] [EOL] return value . value [EOL] else : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] [EOL] [comment] [EOL] try : [EOL] return MetaTransaction . OperationType ( value ) [EOL] except ValueError : [EOL] raise ValidationError ( f" [string] { attr } [string] { value } [string] " f"{ [ operation_type . value for operation_type in MetaTransaction . OperationType ] }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from functools import wraps [EOL] [EOL] from marshmallow import ValidationError [EOL] from tinyrpc . protocols . jsonrpc import JSONRPCInvalidParamsError [EOL] [EOL] [EOL] def validating_rpc_caller ( method , args , kwargs , client ) : [EOL] if len ( args ) > [number] : [EOL] raise JSONRPCInvalidParamsError ( [string] ) [EOL] try : [EOL] return method ( client , ** kwargs ) [EOL] except ValidationError as e : [EOL] raise JSONRPCInvalidParamsError ( [string] + str ( e . messages ) ) [EOL] except Exception as e : [EOL] raise Exception ( [string] + str ( e ) ) [EOL] [EOL] [EOL] def check_args ( schema ) : [EOL] def check_args_decorator ( func ) : [EOL] @ wraps ( func ) def func_wrapper ( * args , ** kwargs ) : [EOL] data = schema . load ( kwargs ) [EOL] return func ( * args , ** data ) [EOL] [EOL] return func_wrapper [EOL] [EOL] return check_args_decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type [EOL] import src [EOL] import typing [EOL] from marshmallow import Schema , fields [EOL] [EOL] from . . fields import Address , BigInteger , HexBytes [EOL] [EOL] [EOL] class SignatureSchema ( Schema ) : [EOL] [EOL] v = fields . Integer ( ) [EOL] r = HexBytes ( ) [EOL] s = HexBytes ( ) [EOL] [EOL] [EOL] class OrderSchema ( Schema ) : [EOL] [EOL] exchangeContractAddress = Address ( attribute = [string] ) [EOL] maker = Address ( attribute = [string] ) [EOL] taker = Address ( attribute = [string] ) [EOL] makerTokenAddress = Address ( attribute = [string] ) [EOL] takerTokenAddress = Address ( attribute = [string] ) [EOL] feeRecipient = Address ( attribute = [string] ) [EOL] makerTokenAmount = BigInteger ( attribute = [string] ) [EOL] takerTokenAmount = BigInteger ( attribute = [string] ) [EOL] filledMakerTokenAmount = BigInteger ( attribute = [string] ) [EOL] filledTakerTokenAmount = BigInteger ( attribute = [string] ) [EOL] cancelledMakerTokenAmount = BigInteger ( attribute = [string] ) [EOL] cancelledTakerTokenAmount = BigInteger ( attribute = [string] ) [EOL] availableMakerTokenAmount = BigInteger ( attribute = [string] ) [EOL] availableTakerTokenAmount = BigInteger ( attribute = [string] ) [EOL] makerFee = BigInteger ( attribute = [string] ) [EOL] takerFee = BigInteger ( attribute = [string] ) [EOL] expirationUnixTimestampSec = BigInteger ( attribute = [string] ) [EOL] salt = BigInteger ( attribute = [string] ) [EOL] ecSignature = fields . Nested ( SignatureSchema , attribute = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Any , Type , Iterable [EOL] import typing [EOL] import src [EOL] import builtins [EOL] from collections import namedtuple [EOL] from contextlib import contextmanager [EOL] from typing import Iterable [EOL] [EOL] from sqlalchemy import Column , String [EOL] from sqlalchemy . exc import IntegrityError [EOL] from sqlalchemy . ext . declarative import declarative_base [EOL] from sqlalchemy . orm import sessionmaker [EOL] [EOL] Base = declarative_base ( ) [EOL] [EOL] [EOL] class TokenMappingORM ( Base ) : [comment] [EOL] __tablename__ = [string] [EOL] user_address = Column ( String , index = True , primary_key = True ) [EOL] client_token = Column ( String , primary_key = True ) [EOL] [EOL] [EOL] class ClientTokenDBException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class ClientTokenAlreadyExistsException ( ClientTokenDBException ) : [EOL] pass [EOL] [EOL] [EOL] TokenMapping = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] [EOL] [EOL] class ClientTokenDB : [EOL] def __init__ ( self , engine ) : [EOL] self . _make_session = sessionmaker ( bind = engine ) [EOL] Base . metadata . create_all ( engine ) [EOL] [EOL] @ contextmanager def session ( self ) : [EOL] [docstring] [EOL] session = self . _make_session ( ) [EOL] try : [EOL] yield session [EOL] session . commit ( ) [EOL] except BaseException : [EOL] session . rollback ( ) [EOL] raise [EOL] finally : [EOL] session . close ( ) [EOL] [EOL] def get_client_tokens ( self , user_address ) : [EOL] with self . session ( ) as session : [EOL] return [ client_token for ( client_token , ) in session . query ( TokenMappingORM . client_token ) . filter ( TokenMappingORM . user_address == user_address ) . all ( ) ] [EOL] [EOL] def get_all_client_tokens ( self ) : [EOL] with self . session ( ) as session : [EOL] return [ TokenMapping ( token_mapping_orm . user_address , token_mapping_orm . client_token ) for token_mapping_orm in ( session . query ( TokenMappingORM ) . all ( ) ) ] [EOL] [EOL] def add_client_token ( self , user_address , client_token ) : [EOL] [docstring] [EOL] with self . session ( ) as session : [EOL] tokenMappingOrm = TokenMappingORM ( user_address = user_address , client_token = client_token ) [EOL] try : [EOL] session . add ( tokenMappingOrm ) [EOL] session . commit ( ) [EOL] except IntegrityError as e : [EOL] raise ClientTokenAlreadyExistsException from e [EOL] [EOL] def delete_client_token ( self , user_address , client_token ) : [EOL] [docstring] [EOL] with self . session ( ) as session : [EOL] session . query ( TokenMappingORM ) . filter ( TokenMappingORM . user_address == user_address , TokenMappingORM . client_token == client_token , ) . delete ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[src.relay.pushservice.client_token_db.TokenMappingORM]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.relay.pushservice.client_token_db.TokenMappingORM]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.relay.pushservice.client_token_db.TokenMapping]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Iterable[TokenMapping]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.relay.pushservice.client_token_db.TokenMapping]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0
	0
import builtins [EOL] from typing import Type , Any , Set [EOL] import typing [EOL] import src [EOL] from eth_utils import is_address , to_checksum_address [EOL] from marshmallow import Schema , ValidationError , fields , pre_load , validates_schema [EOL] [EOL] from relay . blockchain . delegate import GasPriceMethod [EOL] from relay . web3provider import ProviderType [EOL] [EOL] [EOL] class LoggingField ( fields . Mapping ) : [EOL] pass [EOL] [EOL] [EOL] class AddressField ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] return to_checksum_address ( value ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] if not is_address ( value ) : [EOL] raise ValidationError ( f" [string] { attr } [string] { value }" ) [EOL] [EOL] return to_checksum_address ( value ) [EOL] [EOL] [EOL] class FeeSettingsSchema ( Schema ) : [EOL] base_fee = fields . Integer ( required = True ) [EOL] gas_price = fields . Integer ( required = True ) [EOL] fee_recipient = AddressField ( ) [EOL] currency_network = AddressField ( missing = None ) [EOL] [EOL] @ validates_schema def validate_currency_network ( self , in_data , ** kwargs ) : [EOL] base_fee = in_data [ [string] ] [EOL] gas_price = in_data [ [string] ] [EOL] currency_network = in_data [ [string] ] [EOL] if base_fee != [number] or gas_price != [number] : [EOL] if not currency_network : [EOL] raise ValidationError ( [string] ) [EOL] elif base_fee == [number] and gas_price == [number] : [EOL] if currency_network : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] [EOL] class GasPriceComputationSchema ( Schema ) : [EOL] method = fields . String ( missing = [string] ) [EOL] gas_price = fields . Integer ( missing = [number] ) [EOL] [EOL] [EOL] class FaucetSchema ( Schema ) : [EOL] enable = fields . Boolean ( missing = False ) [EOL] [EOL] [EOL] class TrustlineIndexSchema ( Schema ) : [EOL] enable = fields . Boolean ( missing = True ) [EOL] full_sync_interval = fields . Integer ( missing = [number] ) [EOL] [EOL] [EOL] class GasPriceMethodField ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] [EOL] if isinstance ( value , GasPriceMethod ) : [EOL] [comment] [EOL] return value . value [EOL] else : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] [EOL] [comment] [EOL] try : [EOL] return GasPriceMethod ( value ) [EOL] except ValueError : [EOL] raise ValidationError ( f" [string] { attr } [string] { value } [string] " f"{ [ gas_price_method . value for gas_price_method in GasPriceMethod ] }" ) [EOL] [EOL] [EOL] class DelegateSchema ( Schema ) : [EOL] enable = fields . Boolean ( missing = True ) [EOL] enable_deploy_identity = fields . Boolean ( missing = True ) [EOL] fees = fields . List ( fields . Nested ( FeeSettingsSchema ( ) ) , missing = list ) [EOL] gas_price_method = GasPriceMethodField ( missing = GasPriceMethod . RPC ) [EOL] gas_price = fields . Integer ( ) [EOL] min_gas_price = fields . Integer ( ) [EOL] max_gas_price = fields . Integer ( ) [EOL] max_gas_limit = fields . Integer ( missing = [number] ) [EOL] [EOL] @ validates_schema def validate_gas_price_method ( self , in_data , ** kwargs ) : [EOL] gas_price_method = in_data [ [string] ] [EOL] is_gas_price_given = [string] in in_data [EOL] is_min_gas_price_given = [string] in in_data [EOL] is_max_gas_price_given = [string] in in_data [EOL] [EOL] if gas_price_method is GasPriceMethod . FIXED : [EOL] if not is_gas_price_given : [EOL] raise ValidationError ( [string] ) [EOL] else : [EOL] if is_gas_price_given : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] if gas_price_method is GasPriceMethod . BOUND : [EOL] if not is_min_gas_price_given or not is_max_gas_price_given : [EOL] raise ValidationError ( [string] ) [EOL] else : [EOL] if is_min_gas_price_given or is_max_gas_price_given : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] [EOL] class ExchangeSchema ( Schema ) : [EOL] enable = fields . Boolean ( missing = True ) [EOL] [EOL] [EOL] class TxRelaySchema ( Schema ) : [EOL] enable = fields . Boolean ( missing = True ) [EOL] [EOL] [EOL] class MessagingSchema ( Schema ) : [EOL] enable = fields . Boolean ( missing = True ) [EOL] [EOL] [EOL] class PushNotificationSchema ( Schema ) : [EOL] enable = fields . Boolean ( missing = False ) [EOL] firebase_credentials_path = fields . String ( missing = [string] ) [EOL] [EOL] [EOL] class RESTSchema ( Schema ) : [EOL] host = fields . String ( missing = [string] ) [EOL] port = fields . Integer ( missing = [number] ) [EOL] [EOL] [EOL] class ProviderTypeField ( fields . Field ) : [EOL] def _serialize ( self , value , attr , obj , ** kwargs ) : [EOL] [EOL] if isinstance ( value , ProviderType ) : [EOL] [comment] [EOL] return value . value [EOL] else : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] def _deserialize ( self , value , attr , data , ** kwargs ) : [EOL] [EOL] [comment] [EOL] try : [EOL] return ProviderType ( value ) [EOL] except ValueError : [EOL] raise ValidationError ( f" [string] { attr } [string] { value } [string] " f"{ [ possible_value . value for possible_value in ProviderType ] }" ) [EOL] [EOL] [EOL] class ChainNodeRPCSchema ( Schema ) : [EOL] type = ProviderTypeField ( missing = ProviderType . HTTP ) [EOL] host = fields . String ( missing = [string] ) [EOL] port = fields . Integer ( missing = [number] ) [EOL] use_ssl = fields . Boolean ( missing = False ) [EOL] file_path = fields . String ( ) [EOL] uri = fields . String ( ) [EOL] [EOL] @ validates_schema ( pass_original = True ) def validate_only_one_provider ( self , in_data , original_data , ** kwargs ) : [EOL] is_uri_set = [string] in in_data [EOL] is_provider_type_given = [string] in original_data [EOL] [EOL] provider_type = in_data [ [string] ] [EOL] [EOL] if is_uri_set and is_provider_type_given : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] is_file_path_set = [string] in in_data [EOL] if provider_type is ProviderType . IPC : [EOL] if not is_file_path_set : [EOL] raise ValidationError ( [string] ) [EOL] else : [EOL] if is_file_path_set : [EOL] raise ValidationError ( [string] ) [EOL] [EOL] [EOL] class RelaySchema ( Schema ) : [EOL] gas_price_computation = fields . Nested ( GasPriceComputationSchema ( ) ) [EOL] addresses_filepath = fields . String ( missing = [string] ) [EOL] [EOL] @ pre_load def load_defaults ( self , data , ** kwargs ) : [EOL] [docstring] [EOL] for field_name in [ [string] ] : [EOL] data [ field_name ] = { } [EOL] return data [EOL] [EOL] [EOL] class AccountSchema ( Schema ) : [EOL] keystore_path = fields . String ( required = True ) [EOL] keystore_password_path = fields . String ( required = True ) [EOL] [EOL] [EOL] class SentrySchema ( Schema ) : [EOL] dsn = fields . String ( required = True ) [EOL] [EOL] [EOL] class ConfigSchema ( Schema ) : [EOL] relay = fields . Nested ( RelaySchema ( ) ) [EOL] faucet = fields . Nested ( FaucetSchema ( ) ) [EOL] trustline_index = fields . Nested ( TrustlineIndexSchema ( ) ) [EOL] delegate = fields . Nested ( DelegateSchema ( ) ) [EOL] exchange = fields . Nested ( ExchangeSchema ( ) ) [EOL] tx_relay = fields . Nested ( TxRelaySchema ( ) ) [EOL] messaging = fields . Nested ( MessagingSchema ( ) ) [EOL] push_notification = fields . Nested ( PushNotificationSchema ( ) ) [EOL] rest = fields . Nested ( RESTSchema ( ) ) [EOL] node_rpc = fields . Nested ( ChainNodeRPCSchema ( ) ) [EOL] logging = LoggingField ( ) [EOL] sentry = fields . Nested ( SentrySchema ( ) ) [EOL] account = fields . Nested ( AccountSchema ( ) ) [EOL] [EOL] @ pre_load def load_defaults ( self , data , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] needs_values = { [string] , [string] } [EOL] for field_name in self . fields . keys ( ) : [EOL] if field_name not in needs_values and field_name not in data : [EOL] data [ field_name ] = { } [EOL] return data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Iterable , List , Any , Union , MutableMapping [EOL] import builtins [EOL] import marshmallow [EOL] import logging [EOL] import typing [EOL] import logging [EOL] from typing import Dict , Iterable , List , MutableMapping , Union [EOL] [EOL] import toml [EOL] from marshmallow import ValidationError [EOL] from toolz import get_in , update_in [EOL] [EOL] from . schema import ConfigSchema [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] def load_config ( path ) : [EOL] raw_data = toml . load ( path ) [EOL] raw_data = convert_legacy_format ( raw_data ) [EOL] return ConfigSchema ( ) . load ( raw_data ) [EOL] [EOL] [EOL] def dump_config ( config , path ) : [EOL] with open ( path , [string] ) as file : [EOL] toml . dump ( ConfigSchema ( ) . dump ( config ) , file ) [EOL] [EOL] [EOL] def dump_default_config ( path ) : [EOL] dump_config ( generate_default_config ( ) , path ) [EOL] [EOL] [EOL] def generate_default_config ( ) : [EOL] return ConfigSchema ( ) . load ( { } ) [EOL] [EOL] [EOL] def validation_error_string ( validation_error ) : [EOL] [docstring] [EOL] messages = validation_error . messages [EOL] [EOL] def _validation_error_string ( whole_key , messages ) : [EOL] error_list = [ ] [EOL] for key , value in messages . items ( ) : [EOL] if key != [string] : [EOL] key = f"{ whole_key } [string] { key }" [EOL] else : [EOL] [comment] [EOL] key = whole_key [EOL] if isinstance ( value , str ) : [EOL] error_list . append ( f"{ key } [string] { value }" ) [EOL] elif isinstance ( value , list ) : [EOL] for v in value : [EOL] error_list . append ( f"{ key } [string] { v }" ) [EOL] else : [EOL] error_list . extend ( _validation_error_string ( key , value ) ) [EOL] return error_list [EOL] [EOL] if isinstance ( messages , list ) : [EOL] error_list = messages [EOL] else : [EOL] error_list = _validation_error_string ( [string] , messages ) [EOL] return [string] . join ( error_list ) [EOL] [EOL] [EOL] def convert_legacy_format ( raw_data ) : [EOL] [docstring] [EOL] [EOL] def convert_delegation_fees ( old_fees ) : [EOL] new_fees = [ ] [EOL] for old_fee in old_fees : [EOL] new_fee = { } [EOL] mapping = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] for old_key , new_key in mapping . items ( ) : [EOL] value = old_fee . get ( old_key , None ) [EOL] if value is not None : [EOL] new_fee [ new_key ] = value [EOL] [EOL] new_fees . append ( new_fee ) [EOL] return new_fees [EOL] [EOL] old_delegation_key = [string] [EOL] if _get_nested_dict ( raw_data , old_delegation_key ) is not None : [EOL] raw_data = _update_nested_dict ( raw_data , old_delegation_key , convert_delegation_fees ( _get_nested_dict ( raw_data , old_delegation_key ) ) , ) [EOL] [EOL] mapping_old_config_format = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] not_supported_anymore_config = [ [string] , [string] , ] [EOL] deprecated_config = [ [string] , [string] , ] [EOL] for old_path , new_path in mapping_old_config_format . items ( ) : [EOL] raw_data = _remap_config_entry ( raw_data , old_path , new_path ) [EOL] raw_data = _handle_deprecated_config ( raw_data , deprecated_config ) [EOL] _handle_not_supported_config ( raw_data , not_supported_anymore_config ) [EOL] return _remove_empty_dicts ( raw_data ) [EOL] [EOL] [EOL] def _update_nested_dict ( d , path , value ) : [EOL] return update_in ( d , path . split ( [string] ) , lambda x : value ) [EOL] [EOL] [EOL] def _get_nested_dict ( d , path , default = None ) : [EOL] return get_in ( path . split ( [string] ) , d , default = default ) [EOL] [EOL] [EOL] def _remap_config_entry ( d , old_path , new_path ) : [EOL] value = _get_nested_dict ( d , old_path ) [EOL] if value is not None : [EOL] if _get_nested_dict ( d , new_path ) is not None : [EOL] raise ValidationError ( { old_path : f" [string] { new_path } [string] " } ) [EOL] logger . warning ( f"{ old_path } [string] { new_path }" ) [EOL] [comment] [EOL] d = _update_nested_dict ( d , old_path , None ) [EOL] d = _update_nested_dict ( d , new_path , value ) [EOL] return d [EOL] [EOL] [EOL] def _handle_deprecated_config ( config , deprecated_keys ) : [EOL] for deprecated_key in deprecated_keys : [EOL] value = _get_nested_dict ( config , deprecated_key ) [EOL] if value is not None : [EOL] logger . warning ( f"{ deprecated_key } [string] " ) [EOL] config = _update_nested_dict ( config , deprecated_key , None ) [EOL] return config [EOL] [EOL] [EOL] def _handle_not_supported_config ( config , not_supported_keys ) : [EOL] for key in not_supported_keys : [EOL] value = _get_nested_dict ( config , key ) [EOL] if value is not None : [EOL] raise ValidationError ( { not_supported_keys : [string] } ) [EOL] [EOL] [EOL] def _remove_empty_dicts ( data , factory = dict ) : [EOL] [docstring] [EOL] d = factory ( ) [EOL] [EOL] for key , value in data . items ( ) : [EOL] if value is None : [EOL] [comment] [EOL] pass [EOL] elif isinstance ( value , Dict ) : [EOL] sub_dict = _remove_empty_dicts ( value , factory = factory ) [EOL] if sub_dict : [EOL] d [ key ] = sub_dict [EOL] else : [EOL] d [ key ] = value [EOL] [EOL] return d [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
creditline_ab = [string] [EOL] creditline_ba = [string] [EOL] interest_ab = [string] [EOL] interest_ba = [string] [EOL] is_frozen = [string] [EOL] m_time = [string] [EOL] balance_ab = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
def calculate_fees ( imbalance_generated , capacity_imbalance_fee_divisor ) : [EOL] if capacity_imbalance_fee_divisor == [number] or imbalance_generated == [number] : [EOL] return [number] [EOL] return ( imbalance_generated - [number] ) // capacity_imbalance_fee_divisor + [number] [EOL] [EOL] [EOL] def calculate_fees_reverse ( imbalance_generated , capacity_imbalance_fee_divisor ) : [EOL] if capacity_imbalance_fee_divisor == [number] or imbalance_generated == [number] : [EOL] return [number] [EOL] return ( imbalance_generated - [number] ) // ( capacity_imbalance_fee_divisor - [number] ) + [number] [EOL] [EOL] [EOL] def imbalance_generated ( * , value , balance ) : [EOL] assert value >= [number] [EOL] [EOL] if balance <= [number] : [EOL] return value [EOL] [EOL] return max ( value - balance , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] SECONDS_PER_YEAR = [number] * [number] * [number] * [number] [EOL] INTERESTS_DECIMALS = [number] [EOL] DELTA_TIME_MINIMAL_ALLOWED_VALUE = - [number] [EOL] [EOL] [EOL] def _ensure_non_negative_delta_time ( delta_time ) : [EOL] [docstring] [EOL] if delta_time < DELTA_TIME_MINIMAL_ALLOWED_VALUE : [EOL] raise ValueError ( [string] ) [EOL] return max ( delta_time , [number] ) [EOL] [EOL] [EOL] def calculate_interests ( balance , internal_interest_rate , delta_time_in_seconds , highest_order = [number] , ) : [EOL] delta_time_in_seconds = _ensure_non_negative_delta_time ( delta_time_in_seconds ) [EOL] intermediate_order = balance [EOL] interests = [number] [EOL] [comment] [EOL] for order in range ( [number] , highest_order + [number] ) : [EOL] intermediate_order = int ( intermediate_order * internal_interest_rate * delta_time_in_seconds / ( SECONDS_PER_YEAR * [number] * [number] ** INTERESTS_DECIMALS * order ) ) [EOL] [EOL] if intermediate_order == [number] : [EOL] break [EOL] interests += intermediate_order [EOL] [EOL] return interests [EOL] [EOL] [EOL] def balance_with_interests ( balance , internal_interest_rate_positive_balance , internal_interest_rate_negative_balance , delta_time_in_seconds , ) : [EOL] delta_time_in_seconds = _ensure_non_negative_delta_time ( delta_time_in_seconds ) [EOL] if balance > [number] : [EOL] interest = calculate_interests ( balance , internal_interest_rate_positive_balance , delta_time_in_seconds ) [EOL] else : [EOL] interest = calculate_interests ( balance , internal_interest_rate_negative_balance , delta_time_in_seconds ) [EOL] total = balance + interest [EOL] assert isinstance ( total , int ) [EOL] return total [EOL]	0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from enum import Enum [EOL] from typing import List [EOL] [EOL] import attr [EOL] [EOL] [EOL] class FeePayer ( Enum ) : [EOL] SENDER = [string] [EOL] RECEIVER = [string] [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True ) class PaymentPath : [EOL] fee = ... [EOL] path = ... [EOL] value = ... [EOL] fee_payer = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List$ 0 0 0 $builtins.int$ 0 0 0 $FeePayer$ 0 0 0
[docstring] [EOL] from relay . network_graph . graph_constants import ( balance_ab , creditline_ab , creditline_ba , interest_ab , interest_ba , is_frozen , m_time , ) [EOL] [EOL] [EOL] def get ( user , counter_party , value , reverse_value ) : [EOL] if user < counter_party : [EOL] return value [EOL] else : [EOL] return reverse_value [EOL] [EOL] [EOL] def set ( data , user , counter_party , setter_dict , reverse_setter_dict ) : [EOL] if user < counter_party : [EOL] for key , value in setter_dict . items ( ) : [EOL] data [ key ] = value [EOL] else : [EOL] for key , value in reverse_setter_dict . items ( ) : [EOL] data [ key ] = value [EOL] [EOL] [EOL] def get_balance ( data , user , counter_party ) : [EOL] [docstring] [EOL] return get ( user , counter_party , data [ balance_ab ] , - data [ balance_ab ] ) [EOL] [EOL] [EOL] def set_balance ( data , user , counter_party , balance ) : [EOL] [docstring] [EOL] set ( data , user , counter_party , { balance_ab : balance } , { balance_ab : - balance } ) [EOL] [EOL] [EOL] def get_creditline ( data , user , counter_party ) : [EOL] [docstring] [EOL] return get ( user , counter_party , data [ creditline_ab ] , data [ creditline_ba ] ) [EOL] [EOL] [EOL] def set_creditline ( data , user , counter_party , creditline ) : [EOL] [docstring] [EOL] set ( data , user , counter_party , { creditline_ab : creditline } , { creditline_ba : creditline } , ) [EOL] [EOL] [EOL] def get_interest_rate ( data , user , counter_party ) : [EOL] [docstring] [EOL] return get ( user , counter_party , data [ interest_ab ] , data [ interest_ba ] ) [EOL] [EOL] [EOL] def set_interest_rate ( data , user , counter_party , interest_rate ) : [EOL] [docstring] [EOL] set ( data , user , counter_party , { interest_ab : interest_rate } , { interest_ba : interest_rate } , ) [EOL] [EOL] [EOL] def get_is_frozen ( data ) : [EOL] return data [ is_frozen ] [EOL] [EOL] [EOL] def set_is_frozen ( data , _is_frozen ) : [EOL] data [ is_frozen ] = _is_frozen [EOL] [EOL] [EOL] def get_mtime ( data ) : [EOL] [docstring] [EOL] return data [ m_time ] [EOL] [EOL] [EOL] def set_mtime ( data , timestamp ) : [EOL] [docstring] [EOL] data [ m_time ] = timestamp [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Type , Optional , Sequence [EOL] import typing [EOL] import builtins [EOL] import hexbytes [EOL] import src [EOL] import order [EOL] from typing import Optional , Sequence , Tuple [EOL] [EOL] import hexbytes [EOL] from eth_typing import HexStr [EOL] from eth_utils . hexadecimal import remove_0x_prefix [EOL] from sqlalchemy import BigInteger , Column , Float , Integer , String [EOL] from sqlalchemy . ext . declarative import declarative_base [EOL] from sqlalchemy . orm import sessionmaker [EOL] [EOL] from relay . concurrency_utils import synchronized [EOL] [EOL] from . order import Order [EOL] [EOL] Base = declarative_base ( ) [EOL] [EOL] [EOL] class OrderORM ( Base ) : [comment] [EOL] __tablename__ = [string] [EOL] exchange_address = Column ( String ) [EOL] maker_address = Column ( String ) [EOL] taker_address = Column ( String ) [EOL] maker_token = Column ( String ) [EOL] taker_token = Column ( String ) [EOL] fee_recipient = Column ( String ) [EOL] maker_token_amount = Column ( BigInteger ) [EOL] taker_token_amount = Column ( BigInteger ) [EOL] filled_maker_token_amount = Column ( BigInteger ) [EOL] filled_taker_token_amount = Column ( BigInteger ) [EOL] cancelled_maker_token_amount = Column ( BigInteger ) [EOL] cancelled_taker_token_amount = Column ( BigInteger ) [EOL] price = Column ( Float ) [EOL] maker_fee = Column ( Integer ) [EOL] taker_fee = Column ( Integer ) [EOL] expiration_timestamp_in_sec = Column ( BigInteger ) [EOL] salt = Column ( BigInteger ) [EOL] v = Column ( Integer ) [EOL] r = Column ( String ) [EOL] s = Column ( String ) [EOL] msg_hash = Column ( String , primary_key = True ) [EOL] [EOL] @ classmethod def from_order ( cls , order ) : [EOL] return cls ( exchange_address = order . exchange_address , maker_address = order . maker_address , taker_address = order . taker_address , maker_token = order . maker_token , taker_token = order . taker_token , fee_recipient = order . fee_recipient , maker_token_amount = order . maker_token_amount , taker_token_amount = order . taker_token_amount , filled_maker_token_amount = order . filled_maker_token_amount , filled_taker_token_amount = order . filled_taker_token_amount , cancelled_maker_token_amount = order . cancelled_maker_token_amount , cancelled_taker_token_amount = order . cancelled_taker_token_amount , price = order . price , maker_fee = order . maker_fee , taker_fee = order . taker_fee , expiration_timestamp_in_sec = order . expiration_timestamp_in_sec , salt = order . salt , v = order . v , r = remove_0x_prefix ( HexStr ( order . r . hex ( ) ) ) , s = remove_0x_prefix ( HexStr ( order . s . hex ( ) ) ) , msg_hash = remove_0x_prefix ( HexStr ( order . hash ( ) . hex ( ) ) ) , ) [EOL] [EOL] def to_order ( self ) : [EOL] return Order ( exchange_address = self . exchange_address , maker_address = self . maker_address , taker_address = self . taker_address , maker_token = self . maker_token , taker_token = self . taker_token , fee_recipient = self . fee_recipient , maker_token_amount = self . maker_token_amount , taker_token_amount = self . taker_token_amount , filled_maker_token_amount = self . filled_maker_token_amount , filled_taker_token_amount = self . filled_taker_token_amount , cancelled_maker_token_amount = self . cancelled_maker_token_amount , cancelled_taker_token_amount = self . cancelled_taker_token_amount , maker_fee = self . maker_fee , taker_fee = self . taker_fee , expiration_timestamp_in_sec = self . expiration_timestamp_in_sec , salt = self . salt , v = self . v , r = hexbytes . HexBytes ( self . r ) , s = hexbytes . HexBytes ( self . s ) , ) [EOL] [EOL] [EOL] class OrderBookDB ( object ) : [EOL] def __init__ ( self , engine ) : [EOL] Session = sessionmaker ( bind = engine ) [EOL] Base . metadata . create_all ( engine ) [EOL] self . session = Session ( ) [EOL] [EOL] @ synchronized def add_order ( self , order ) : [EOL] order_orm = self . session . query ( OrderORM ) . get ( remove_0x_prefix ( HexStr ( order . hash ( ) . hex ( ) ) ) ) [EOL] if order_orm is None : [EOL] order_orm = OrderORM . from_order ( order ) [EOL] self . session . add ( order_orm ) [EOL] self . session . commit ( ) [EOL] [EOL] @ synchronized def add_orders ( self , orders ) : [EOL] for order in orders : [EOL] self . add_order ( order ) [EOL] [EOL] @ synchronized def get_order_by_hash ( self , order_hash ) : [EOL] [comment] [EOL] order_orm = self . session . query ( OrderORM ) . get ( remove_0x_prefix ( HexStr ( order_hash . hex ( ) ) ) ) [EOL] if order_orm is None : [EOL] return None [EOL] return order_orm . to_order ( ) [EOL] [EOL] @ synchronized def get_orderbook_by_tokenpair ( self , token_pair , desc_price = False ) : [EOL] orders_orm = ( self . session . query ( OrderORM ) . filter ( OrderORM . maker_token == token_pair [ [number] ] , OrderORM . taker_token == token_pair [ [number] ] , ) . order_by ( OrderORM . price . desc ( ) if desc_price else OrderORM . price , OrderORM . expiration_timestamp_in_sec , ) ) [EOL] return [ order_orm . to_order ( ) for order_orm in orders_orm ] [EOL] [EOL] @ synchronized def get_orders ( self , filter_exchange_address = None , filter_token_address = None , filter_maker_token_address = None , filter_taker_token_address = None , filter_trader_address = None , filter_maker_address = None , filter_taker_address = None , filter_fee_recipient_address = None , ) : [EOL] orders_orm = self . session . query ( OrderORM ) [EOL] [EOL] if filter_exchange_address is not None : [EOL] orders_orm . filter ( OrderORM . exchange_address == filter_exchange_address ) [EOL] if filter_token_address is not None : [EOL] orders_orm . filter ( ( OrderORM . maker_token == filter_token_address ) | ( OrderORM . taker_token == filter_token_address ) ) [EOL] if filter_maker_token_address is not None : [EOL] orders_orm . filter ( OrderORM . maker_token == filter_maker_token_address ) [EOL] if filter_taker_token_address is not None : [EOL] orders_orm . filter ( OrderORM . taker_token == filter_taker_token_address ) [EOL] if filter_trader_address is not None : [EOL] orders_orm . filter ( ( OrderORM . maker_address == filter_trader_address ) | ( OrderORM . taker_address == filter_trader_address ) ) [EOL] if filter_maker_address is not None : [EOL] orders_orm . filter ( OrderORM . maker_address == filter_maker_address ) [EOL] if filter_taker_address is not None : [EOL] orders_orm . filter ( OrderORM . taker_address == filter_taker_address ) [EOL] if filter_fee_recipient_address is not None : [EOL] orders_orm . filter ( OrderORM . fee_recipient == filter_fee_recipient_address ) [EOL] [EOL] return [ order_orm . to_order ( ) for order_orm in orders_orm ] [EOL] [EOL] @ synchronized def delete_order_by_hash ( self , order_hash ) : [EOL] self . session . query ( OrderORM ) . filter_by ( msg_hash = remove_0x_prefix ( HexStr ( order_hash . hex ( ) ) ) ) . delete ( synchronize_session = False ) [EOL] self . session . commit ( ) [EOL] [EOL] @ synchronized def delete_orders_by_hash ( self , order_hashes ) : [EOL] for order_hash in order_hashes : [EOL] self . session . query ( OrderORM ) . filter_by ( msg_hash = remove_0x_prefix ( HexStr ( order_hash . hex ( ) ) ) ) . delete ( synchronize_session = False ) [EOL] self . session . commit ( ) [EOL] [EOL] @ synchronized def delete_old_orders ( self , timestamp ) : [EOL] self . session . query ( OrderORM ) . filter ( OrderORM . expiration_timestamp_in_sec < timestamp ) . delete ( synchronize_session = False ) [EOL] self . session . commit ( ) [EOL] [EOL] @ synchronized def order_filled ( self , order_hash , filled_maker_token_amount , filled_taker_token_amount , ) : [EOL] order_orm = ( self . session . query ( OrderORM ) . filter_by ( msg_hash = remove_0x_prefix ( HexStr ( order_hash . hex ( ) ) ) ) . first ( ) ) [EOL] if order_orm is not None : [EOL] order_orm . filled_maker_token_amount += filled_maker_token_amount [EOL] order_orm . filled_taker_token_amount += filled_taker_token_amount [EOL] if order_orm . to_order ( ) . is_filled ( ) : [EOL] self . session . delete ( order_orm ) [EOL] self . session . commit ( ) [EOL] [EOL] @ synchronized def order_cancelled ( self , order_hash , cancelled_maker_token_amount , cancelled_taker_token_amount , ) : [EOL] order_orm = ( self . session . query ( OrderORM ) . filter_by ( msg_hash = remove_0x_prefix ( HexStr ( order_hash . hex ( ) ) ) ) . first ( ) ) [EOL] if order_orm is not None : [EOL] order_orm . cancelled_maker_token_amount += cancelled_maker_token_amount [EOL] order_orm . cancelled_taker_token_amount += cancelled_taker_token_amount [EOL] if order_orm . to_order ( ) . is_filled ( ) : [EOL] self . session . delete ( order_orm ) [EOL] self . session . commit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.relay.exchange.exchange_db.OrderORM]$ 0 0 0 0 0 0 $typing.Type[src.relay.exchange.exchange_db.OrderORM]$ 0 0 0 0 0 0 $typing.Type[src.relay.exchange.exchange_db.OrderORM]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"OrderORM"$ 0 0 0 $order.Order$ 0 0 0 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 0 0 0 0 $order.Order$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $order.Order$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $order.Order$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $order.Order$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $order.Order$ 0 0 0 $src.relay.exchange.exchange_db.OrderORM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $order.Order$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.relay.exchange.exchange_db.OrderORM$ 0 0 0 0 $src.relay.exchange.exchange_db.OrderORM$ 0 0 0 0 0 $order.Order$ 0 0 0 0 0 0 0 0 $src.relay.exchange.exchange_db.OrderORM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[order.Order]$ 0 0 0 0 0 0 $typing.Sequence[order.Order]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[order.Order]$ 0 0 0 $hexbytes.HexBytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexbytes.HexBytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[order.Order]$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Sequence[order.Order]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 $hexbytes.HexBytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexbytes.HexBytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[hexbytes.HexBytes]$ 0 0 0 0 0 0 $typing.Sequence[hexbytes.HexBytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $hexbytes.HexBytes$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexbytes.HexBytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $hexbytes.HexBytes$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexbytes.HexBytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type [EOL] import builtins [EOL] import src [EOL] import hexbytes [EOL] import typing [EOL] from collections import namedtuple [EOL] [EOL] import hexbytes [EOL] from eth_utils import is_checksum_address [EOL] [EOL] from relay . signing import eth_sign , eth_validate , keccak256 [EOL] [EOL] EcSignature = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] class Order ( object ) : [EOL] def __init__ ( self , exchange_address , maker_address , taker_address , maker_token , taker_token , fee_recipient , maker_token_amount , taker_token_amount , maker_fee , taker_fee , expiration_timestamp_in_sec , salt , v , r , s , filled_maker_token_amount = [number] , filled_taker_token_amount = [number] , cancelled_maker_token_amount = [number] , cancelled_taker_token_amount = [number] , ) : [EOL] self . exchange_address = exchange_address [EOL] self . maker_address = maker_address [EOL] self . taker_address = taker_address [EOL] self . maker_token = maker_token [EOL] self . taker_token = taker_token [EOL] self . fee_recipient = fee_recipient [EOL] self . maker_token_amount = maker_token_amount [EOL] self . taker_token_amount = taker_token_amount [EOL] self . maker_fee = maker_fee [EOL] self . taker_fee = taker_fee [EOL] self . expiration_timestamp_in_sec = expiration_timestamp_in_sec [EOL] self . salt = salt [EOL] self . v = v [EOL] self . r = r [EOL] self . s = s [EOL] self . filled_maker_token_amount = filled_maker_token_amount [EOL] self . filled_taker_token_amount = filled_taker_token_amount [EOL] self . cancelled_maker_token_amount = cancelled_maker_token_amount [EOL] self . cancelled_taker_token_amount = cancelled_taker_token_amount [EOL] [EOL] @ property def price ( self ) : [EOL] return self . taker_token_amount / self . maker_token_amount [EOL] [EOL] @ property def available_maker_token_amount ( self ) : [EOL] return ( self . maker_token_amount - self . filled_maker_token_amount - self . cancelled_maker_token_amount ) [EOL] [EOL] @ property def available_taker_token_amount ( self ) : [EOL] return ( self . taker_token_amount - self . filled_taker_token_amount - self . cancelled_taker_token_amount ) [EOL] [EOL] @ property def ec_signature ( self ) : [EOL] return EcSignature ( self . v , self . r , self . s ) [EOL] [EOL] def validate ( self ) : [EOL] return self . validate_signature ( ) and self . validate_addresses ( ) [EOL] [EOL] def validate_signature ( self ) : [EOL] return eth_validate ( self . hash ( ) , ( self . v , self . r , self . s ) , self . maker_address ) [EOL] [EOL] def validate_addresses ( self ) : [EOL] for address in [ self . exchange_address , self . maker_token , self . taker_token , self . fee_recipient , ] : [EOL] if not is_checksum_address ( address ) : [EOL] return False [EOL] return True [EOL] [EOL] def is_expired ( self , current_timestamp_in_sec ) : [EOL] return current_timestamp_in_sec > self . expiration_timestamp_in_sec [EOL] [EOL] def is_filled ( self ) : [EOL] return ( self . available_maker_token_amount <= [number] or self . available_taker_token_amount <= [number] ) [EOL] [EOL] def hash ( self ) : [EOL] return hexbytes . HexBytes ( keccak256 ( self . exchange_address , self . maker_address , self . taker_address , self . maker_token , self . taker_token , self . fee_recipient , self . maker_token_amount , self . taker_token_amount , self . maker_fee , self . taker_fee , self . expiration_timestamp_in_sec , self . salt , ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , Order ) : [EOL] return self . hash ( ) == other . hash ( ) [EOL] else : [EOL] return False [EOL] [EOL] [EOL] class SignableOrder ( Order ) : [EOL] def __init__ ( self , exchange_address , maker_address , taker_address , maker_token , taker_token , fee_recipient , maker_token_amount , taker_token_amount , maker_fee , taker_fee , expiration_timestamp_in_sec , salt , ) : [EOL] super ( ) . __init__ ( exchange_address , maker_address , taker_address , maker_token , taker_token , fee_recipient , maker_token_amount , taker_token_amount , maker_fee , taker_fee , expiration_timestamp_in_sec , salt , v = [number] , r = hexbytes . HexBytes ( [string] ) , s = hexbytes . HexBytes ( [string] ) , ) [EOL] [EOL] def sign ( self , key ) : [EOL] v , r , s = eth_sign ( self . hash ( ) , key ) [EOL] self . v = v [EOL] self . r = hexbytes . HexBytes ( r ) [EOL] self . s = hexbytes . HexBytes ( s ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.relay.exchange.order.EcSignature]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.relay.exchange.order.EcSignature]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hexbytes.HexBytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0