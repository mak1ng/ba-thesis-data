from typing import Union , Optional , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import builtins [EOL] import os [EOL] [EOL] [EOL] def get_bool ( key ) : [EOL] value = os . getenv ( key ) [EOL] if value : [EOL] return value . lower ( ) in [ [string] , [string] , [string] ] [EOL] return False [EOL] [EOL] [EOL] DEBUG = get_bool ( [string] ) [EOL] [EOL] SENTRY_DSN = os . getenv ( [string] ) [EOL] [EOL] GOOGLE_OAUTH2_CLIENT_ID = os . getenv ( [string] ) [EOL] [EOL] REDIS_HOST = os . getenv ( [string] , [string] ) [EOL] REDIS_DB = int ( os . getenv ( [string] , [string] ) ) [EOL] REDIS_POOL_MIN = int ( os . getenv ( [string] , [string] ) ) [EOL] REDIS_POOL_MAX = int ( os . getenv ( [string] , [string] ) ) [EOL] [EOL] _MIN = [number] [EOL] [EOL] RIDE_REQUEST_TTL = [number] * _MIN [EOL] RIDE_TTL = [number] * _MIN [EOL] PROFILE_TTL = [number] * _MIN [EOL] [EOL] PUBLISH_MAP_FREQUENCY = [number] [EOL] READ_STREAM_FREQUENCY = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
from typing import Any [EOL] import typing [EOL] import sentry_sdk [EOL] from fastapi import FastAPI [EOL] from sentry_asgi import SentryMiddleware [EOL] [EOL] from excars import api , config , oauth2_redirect , redis [EOL] [EOL] app = FastAPI ( title = [string] , debug = config . DEBUG ) [EOL] app . include_router ( api . v1 . router , prefix = [string] ) [EOL] app . include_router ( oauth2_redirect . router ) [EOL] [EOL] if config . SENTRY_DSN : [comment] [EOL] sentry_sdk . init ( dsn = config . SENTRY_DSN ) [EOL] app . add_middleware ( SentryMiddleware ) [EOL] [EOL] [EOL] @ app . on_event ( [string] ) async def startup ( ) : [EOL] app . redis_cli = await redis . setup ( ) [EOL] [EOL] [EOL] @ app . on_event ( [string] ) async def shutdown ( ) : [EOL] await redis . stop ( app . redis_cli ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
import aioredis [EOL] import aioredis [EOL] from aioredis import Redis [EOL] [EOL] from excars import config [EOL] [EOL] [EOL] async def setup ( ) : [EOL] return await aioredis . create_redis_pool ( config . REDIS_HOST , db = config . REDIS_DB , minsize = config . REDIS_POOL_MIN , maxsize = config . REDIS_POOL_MAX ) [EOL] [EOL] [EOL] async def stop ( redis_cli ) : [EOL] redis_cli . close ( ) [EOL] await redis_cli . wait_closed ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from fastapi import APIRouter [EOL] from starlette . responses import HTMLResponse [EOL] [EOL] router = APIRouter ( ) [EOL] [EOL] [EOL] @ router . get ( [string] , include_in_schema = False ) def oauth2_redirect ( ) : [EOL] return HTMLResponse ( get_oauth2_redirect_html ( ) ) [EOL] [EOL] [EOL] def get_oauth2_redirect_html ( ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from . import v1 [comment] [EOL]	0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import aioredis [EOL] import starlette [EOL] import excars [EOL] import typing [EOL] import asyncio [EOL] [EOL] from aioredis import Redis [EOL] from pydantic import ValidationError [EOL] from starlette . websockets import WebSocket , WebSocketState [EOL] [EOL] from excars import config , repositories [EOL] from excars . models . messages import Message [EOL] from excars . models . user import User [EOL] [EOL] [EOL] async def init ( redis_cli , user_id ) : [EOL] await repositories . stream . create ( redis_cli , user_id ) [EOL] [EOL] [EOL] async def listen ( websocket , user , redis_cli ) : [EOL] while websocket . application_state == WebSocketState . CONNECTED : [EOL] messages = await repositories . stream . list_messages_for ( redis_cli , user_id = user . user_id ) [EOL] for stream_message in messages : [EOL] try : [EOL] message = Message . parse_raw ( stream_message . data [ [string] ] ) [EOL] except ( KeyError , ValidationError ) : [EOL] continue [EOL] await websocket . send_text ( message . json ( ) ) [EOL] await repositories . stream . ack ( redis_cli , user_id = user . user_id , message_id = stream_message . message_id ) [EOL] await asyncio . sleep ( config . READ_STREAM_FREQUENCY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import starlette [EOL] import typing [EOL] import excars [EOL] import aioredis [EOL] from aioredis import Redis [EOL] from pydantic import ValidationError [EOL] from starlette . websockets import WebSocket [EOL] [EOL] from excars import repositories [EOL] from excars . models . locations import Location [EOL] from excars . models . messages import Message , MessageType [EOL] from excars . models . user import User [EOL] [EOL] [EOL] async def listen ( websocket , user , redis_cli ) : [EOL] while True : [EOL] data = await websocket . receive_json ( ) [EOL] try : [EOL] message = Message ( ** data ) [EOL] await handle ( message , user , redis_cli ) [EOL] except ValidationError as exc : [EOL] await websocket . send_text ( Message ( type = MessageType . error , data = exc . errors ( ) ) . json ( ) ) [EOL] [EOL] [EOL] async def handle ( message , user , redis_cli ) : [EOL] if message . type == MessageType . location : [EOL] await receive_location ( Location ( ** message . data ) , user , redis_cli ) [EOL] [EOL] [EOL] async def receive_location ( location , user , redis_cli ) : [EOL] await repositories . locations . save_for ( redis_cli , user . user_id , location ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import starlette [EOL] from starlette . requests import Request [EOL] [EOL] [EOL] def get_redis_cli ( request ) : [EOL] return request . app . redis_cli [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List , Awaitable [EOL] import builtins [EOL] import aioredis [EOL] import starlette [EOL] import excars [EOL] import typing [EOL] import asyncio [EOL] from typing import Awaitable , List [EOL] [EOL] from aioredis import Redis [EOL] from starlette . websockets import WebSocket , WebSocketState [EOL] [EOL] from excars import config , repositories [EOL] from excars . models . locations import MapItem , UserLocation [EOL] from excars . models . messages import Message , MessageType [EOL] from excars . models . user import User [EOL] [EOL] [EOL] def send ( websocket , user , redis_cli ) : [EOL] return [ publish_map ( websocket , user , redis_cli ) ] [EOL] [EOL] [EOL] async def publish_map ( websocket , user , redis_cli ) : [EOL] while websocket . application_state == WebSocketState . CONNECTED : [EOL] locations = await repositories . locations . list_for ( redis_cli , user_id = user . user_id ) [EOL] map_items = await _prepare_map ( user . user_id , locations , redis_cli ) [EOL] message = Message ( type = MessageType . map , data = map_items ) [EOL] await websocket . send_text ( message . json ( ) ) [EOL] await asyncio . sleep ( config . PUBLISH_MAP_FREQUENCY ) [EOL] [EOL] [EOL] async def _prepare_map ( user_id , locations , redis_cli ) : [EOL] user_ride_id = await repositories . rides . get_ride_id ( redis_cli , user_id ) [EOL] [EOL] map_items = [ ] [EOL] for location in locations : [EOL] if location . user_id == user_id : [EOL] continue [EOL] [EOL] profile = await repositories . profile . get ( redis_cli , location . user_id ) [EOL] if not profile : [EOL] continue [EOL] [EOL] ride_id = await repositories . rides . get_ride_id ( redis_cli , profile . user_id ) [EOL] if ride_id and ride_id != user_ride_id : [EOL] continue [EOL] [EOL] map_items . append ( MapItem ( user_id = profile . user_id , role = profile . role , location = location , has_same_ride = bool ( user_ride_id and ( user_ride_id == ride_id ) ) , ) ) [EOL] [EOL] return map_items [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Awaitable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[excars.models.locations.MapItem]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import excars [EOL] import aioredis [EOL] from functools import lru_cache [EOL] [EOL] from aioredis import Redis [EOL] from fastapi import Depends , HTTPException , Security [EOL] from fastapi . openapi . models import OAuthFlowAuthorizationCode , OAuthFlows [EOL] from fastapi . security import OAuth2 [EOL] from google . auth import jwt [EOL] from google . auth . transport . requests import Request [EOL] from google . oauth2 import id_token [EOL] from pydantic import ValidationError [EOL] from starlette . status import HTTP_400_BAD_REQUEST , HTTP_403_FORBIDDEN [EOL] [EOL] from excars import config , repositories [EOL] from excars . api . utils . redis import get_redis_cli [EOL] from excars . models . token import TokenPayload [EOL] from excars . models . user import User [EOL] [EOL] oauth2 = OAuth2 ( flows = OAuthFlows ( authorizationCode = OAuthFlowAuthorizationCode ( authorizationUrl = [string] , tokenUrl = [string] , ) ) ) [EOL] [EOL] [EOL] async def get_current_user ( token = Security ( oauth2 ) , redis_cli = Depends ( get_redis_cli ) ) : [EOL] try : [EOL] payload = verify_id_token ( token . rpartition ( [string] ) [ - [number] ] ) [EOL] except ValueError as exc : [EOL] raise HTTPException ( status_code = HTTP_403_FORBIDDEN , detail = str ( exc ) ) from exc [EOL] [EOL] if payload [ [string] ] not in [ [string] , [string] ] : [EOL] raise HTTPException ( status_code = HTTP_403_FORBIDDEN , detail = [string] ) [EOL] [EOL] try : [EOL] token_data = TokenPayload ( ** payload ) [EOL] except ValidationError as exc : [EOL] raise HTTPException ( status_code = HTTP_400_BAD_REQUEST , detail = exc . json ( indent = None ) ) from exc [EOL] [EOL] user = await repositories . users . get ( redis_cli , user_id = token_data . sub ) [EOL] if user is None : [EOL] user = User . from_token ( token_data ) [EOL] await repositories . users . save ( redis_cli , user ) [EOL] return user [EOL] [EOL] [EOL] def verify_id_token ( token ) : [EOL] return jwt . decode ( token , certs = fetch_certs ( ) , audience = config . GOOGLE_OAUTH2_CLIENT_ID ) [EOL] [EOL] [EOL] @ lru_cache ( ) def fetch_certs ( ) : [EOL] return id_token . _fetch_certs ( Request ( ) , id_token . _GOOGLE_OAUTH2_CERTS_URL ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $excars.models.user.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import starlette [EOL] import typing [EOL] import excars [EOL] import asyncio [EOL] [EOL] from fastapi import APIRouter , HTTPException [EOL] from starlette . websockets import WebSocket , WebSocketDisconnect [EOL] [EOL] from excars import config , repositories [EOL] from excars . api . utils import receivers , senders , stream [EOL] from excars . api . utils . security import get_current_user [EOL] [EOL] router = APIRouter ( ) [EOL] [EOL] [EOL] @ router . websocket_route ( [string] ) async def websocket_endpoint ( websocket ) : [EOL] redis_cli = websocket . app . redis_cli [EOL] try : [EOL] user = await get_current_user ( websocket . headers . get ( [string] , [string] ) , redis_cli = redis_cli ) [EOL] except HTTPException : [EOL] await websocket . accept ( ) [EOL] await websocket . close ( ) [EOL] return [EOL] [EOL] await asyncio . gather ( repositories . profile . persist ( redis_cli , user . user_id ) , repositories . rides . persist ( redis_cli , user . user_id ) , stream . init ( redis_cli , user . user_id ) , ) [EOL] [EOL] await websocket . accept ( ) [EOL] [EOL] try : [EOL] await asyncio . gather ( receivers . listen ( websocket , user , redis_cli ) , stream . listen ( websocket , user , redis_cli ) , * senders . send ( websocket , user , redis_cli ) , ) [EOL] except WebSocketDisconnect : [EOL] pass [EOL] finally : [EOL] await repositories . profile . expire ( redis_cli , user . user_id ) [EOL] profile = await repositories . profile . get ( redis_cli , user . user_id ) [EOL] if profile is not None : [EOL] await repositories . rides . delete_or_exclude ( redis_cli , profile , config . PROFILE_TTL ) [EOL] await websocket . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import excars [EOL] import aioredis [EOL] from aioredis import Redis [EOL] from fastapi import APIRouter , Depends , HTTPException [EOL] [EOL] from excars import repositories [EOL] from excars . api . utils . redis import get_redis_cli [EOL] from excars . api . utils . security import get_current_user [EOL] from excars . models . profiles import Profile , Role [EOL] from excars . models . rides import Ride , RideRequest , RideRequestCreate , RideRequestStatus , RideRequestUpdate [EOL] from excars . models . user import User [EOL] [EOL] router = APIRouter ( ) [EOL] [EOL] [EOL] @ router . post ( [string] , response_model = RideRequest ) async def create_ride_request ( ride_create , user = Depends ( get_current_user ) , redis_cli = Depends ( get_redis_cli ) ) : [EOL] [docstring] [EOL] receiver = await repositories . profile . get ( redis_cli , ride_create . receiver ) [EOL] if receiver is None : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] [EOL] sender = await repositories . profile . get ( redis_cli , user . user_id ) [EOL] if sender is None : [EOL] sender = Profile . from_user ( user , role = Role . opposite ( receiver . role ) , destination = receiver . destination ) [EOL] await repositories . profile . save ( redis_cli , sender ) [EOL] [EOL] ride_request = RideRequest ( sender = sender , receiver = receiver , status = RideRequestStatus . requested ) [EOL] await repositories . rides . create_request ( redis_cli , ride_request ) [EOL] await repositories . stream . ride_requested ( redis_cli , ride_request ) [EOL] [EOL] return ride_request [EOL] [EOL] [EOL] @ router . delete ( [string] , status_code = [number] ) async def leave_ride ( user = Depends ( get_current_user ) , redis_cli = Depends ( get_redis_cli ) ) : [EOL] [docstring] [EOL] profile = await repositories . profile . get ( redis_cli , user . user_id ) [EOL] if profile is None : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] [EOL] ride_id = await repositories . rides . get_ride_id ( redis_cli , user_id = user . user_id ) [EOL] if ride_id is None : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] [EOL] ride = await repositories . rides . get ( redis_cli , ride_id = ride_id ) [EOL] if ride is None : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] [EOL] await repositories . rides . delete_or_exclude ( redis_cli , profile ) [EOL] if profile . role == Role . driver : [EOL] await repositories . stream . ride_cancelled ( redis_cli , ride ) [EOL] else : [EOL] await repositories . stream . ride_updated ( redis_cli , ride ) [EOL] [EOL] [EOL] @ router . get ( [string] , response_model = Ride ) async def get_current_ride ( user = Depends ( get_current_user ) , redis_cli = Depends ( get_redis_cli ) ) : [EOL] [docstring] [EOL] ride_id = await repositories . rides . get_ride_id ( redis_cli , user . user_id ) [EOL] if ride_id is None : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] ride = await repositories . rides . get ( redis_cli , ride_id ) [EOL] return ride [EOL] [EOL] [EOL] @ router . put ( [string] , response_model = RideRequest ) async def update_ride_request ( * , ride_update , user = Depends ( get_current_user ) , redis_cli = Depends ( get_redis_cli ) , ) : [EOL] [docstring] [EOL] receiver = await repositories . profile . get ( redis_cli , user . user_id ) [EOL] if receiver is None : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] [EOL] sender = await repositories . profile . get ( redis_cli , ride_update . sender ) [EOL] if sender is None : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] [EOL] ride_request = RideRequest ( sender = sender , receiver = receiver , status = ride_update . status ) [EOL] if not await repositories . rides . request_exists ( redis_cli , ride_request ) : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] [EOL] await repositories . rides . update_request ( redis_cli , ride_request ) [EOL] await repositories . stream . request_updated ( redis_cli , ride_request ) [EOL] [EOL] ride = await repositories . rides . get ( redis_cli , ride_request . ride_id ) [EOL] assert ride is not None [EOL] await repositories . stream . ride_updated ( redis_cli , ride ) [EOL] [EOL] return ride_request [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import builtins [EOL] import typing [EOL] import excars [EOL] import aioredis [EOL] from aioredis import Redis [EOL] from fastapi import APIRouter , Depends , HTTPException [EOL] [EOL] from excars import repositories [EOL] from excars . api . utils . redis import get_redis_cli [EOL] from excars . api . utils . security import get_current_user [EOL] from excars . models . profiles import JoinRequest , Profile [EOL] from excars . models . user import User [EOL] [EOL] router = APIRouter ( ) [EOL] [EOL] [EOL] @ router . post ( [string] , response_model = Profile ) async def join ( * , join_request , user = Depends ( get_current_user ) , redis_cli = Depends ( get_redis_cli ) ) : [EOL] [docstring] [EOL] profile = Profile . from_user ( user , role = join_request . role , destination = join_request . destination ) [EOL] await repositories . profile . save ( redis_cli , profile ) [EOL] return profile [EOL] [EOL] [EOL] @ router . get ( [string] , response_model = Profile ) async def get_profile ( profile_id , user = Depends ( get_current_user ) , redis_cli = Depends ( get_redis_cli ) ) : [EOL] [docstring] [EOL] del user [EOL] profile = await repositories . profile . get ( redis_cli , profile_id ) [EOL] if not profile : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] return profile [EOL] [EOL] [EOL] @ router . delete ( [string] , status_code = [number] ) async def leave ( * , user = Depends ( get_current_user ) , redis_cli = Depends ( get_redis_cli ) ) : [EOL] [docstring] [EOL] await repositories . profile . delete ( redis_cli , user . user_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import excars [EOL] from fastapi import APIRouter , Depends [EOL] [EOL] from excars . api . utils . security import get_current_user [EOL] from excars . models . user import User [EOL] [EOL] router = APIRouter ( ) [EOL] [EOL] [EOL] @ router . get ( [string] , response_model = User ) async def retrieve_me ( user = Depends ( get_current_user ) ) : [EOL] [docstring] [EOL] return user [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from fastapi import APIRouter [EOL] [EOL] from . import profiles , rides , users , ws [EOL] [EOL] router = APIRouter ( ) [EOL] router . include_router ( profiles . router , tags = [ [string] ] ) [EOL] router . include_router ( rides . router , tags = [ [string] ] ) [EOL] router . include_router ( users . router , tags = [ [string] ] ) [EOL] router . include_router ( ws . router ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0
	0
[comment] [EOL] [EOL] from typing import Dict , Optional , Any [EOL] import builtins [EOL] import asyncio [EOL] import starlette [EOL] import excars [EOL] import typing [EOL] import asyncio [EOL] import random [EOL] from typing import Optional [EOL] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture def make_token_payload ( faker ) : [EOL] def token_payload ( ** kwargs ) : [EOL] defaults = { [string] : faker . pyint ( ) , [string] : [string] , [string] : faker . email ( ) , [string] : faker . name ( ) , [string] : faker . url ( ) , [string] : faker . first_name ( ) , [string] : faker . last_name ( ) , } [EOL] defaults . update ( kwargs ) [EOL] return defaults [EOL] [EOL] return token_payload [EOL] [EOL] [EOL] @ pytest . fixture def make_token_headers ( mocker , faker , make_token_payload ) : [EOL] def token_headers_for ( user_id = None ) : [EOL] user_id = user_id or faker . pyint ( ) [EOL] payload = make_token_payload ( sub = user_id ) [EOL] mocker . patch ( [string] , return_value = payload ) [EOL] return { [string] : [string] } [EOL] [EOL] return token_headers_for [EOL] [EOL] [EOL] @ pytest . yield_fixture def client ( mocker ) : [EOL] from starlette . testclient import TestClient , WebSocketTestSession [EOL] from starlette . types import Message [EOL] [EOL] from excars . main import app [EOL] [EOL] [comment] [EOL] class WebSocketTestSessionMonkeyPatch ( WebSocketTestSession ) : [EOL] __loop = asyncio . get_event_loop ( ) [EOL] [EOL] @ property def _loop ( self ) : [EOL] return self . __loop [EOL] [EOL] @ _loop . setter def _loop ( self , value ) : [comment] [EOL] value . stop ( ) [EOL] value . close ( ) [EOL] [EOL] [comment] [EOL] async def _asgi_receive ( self ) : [EOL] while self . _receive_queue . empty ( ) : [EOL] await asyncio . sleep ( [number] ) [EOL] return self . _receive_queue . get ( ) [EOL] [EOL] mocker . patch ( [string] , WebSocketTestSessionMonkeyPatch ) [EOL] [EOL] try : [EOL] yield TestClient ( app ) [EOL] finally : [EOL] with TestClient ( app ) as cli : [EOL] asyncio . get_event_loop ( ) . run_until_complete ( cli . app . redis_cli . flushdb ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture def profile_factory ( client , faker ) : [EOL] def make_profile ( ** kwargs ) : [EOL] from excars . models . profiles import Profile , Role [EOL] [EOL] defaults = { [string] : faker . pyint ( ) , [string] : faker . name ( ) , [string] : faker . url ( ) , [string] : random . choice ( [ Role . driver , Role . hitchhiker ] ) , [string] : { [string] : faker . name ( ) , [string] : faker . latitude ( ) , [string] : faker . longitude ( ) } , } [EOL] defaults . update ( kwargs ) [EOL] profile = Profile ( ** defaults ) [EOL] [EOL] from excars import repositories [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] with client as cli : [EOL] loop . run_until_complete ( repositories . profile . save ( cli . app . redis_cli , profile ) ) [EOL] [EOL] return profile [EOL] [EOL] return make_profile [EOL] [EOL] [EOL] @ pytest . fixture def location_factory ( client , faker ) : [EOL] latitude = float ( faker . coordinate ( center = [number] ) ) [comment] [EOL] longitude = float ( faker . longitude ( ) ) [EOL] [EOL] def make_location ( * , user_id = None ) : [EOL] from excars . models . locations import Location [EOL] [EOL] location = Location ( latitude = latitude + [number] , longitude = longitude + [number] , course = faker . coordinate ( ) ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] user_id = user_id or faker . pyint ( ) [EOL] with client as cli : [EOL] from excars import repositories [EOL] [EOL] loop . run_until_complete ( repositories . locations . save_for ( cli . app . redis_cli , user_id , location ) ) [EOL] [EOL] return location [EOL] [EOL] return make_location [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $starlette.types.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import excars [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] [EOL] import pytest [EOL] [EOL] from excars import repositories [EOL] from excars . models . profiles import Role [EOL] from excars . models . rides import Ride , RideRequest , RideRequestStatus [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_create_ride_request ( client , profile_factory , make_token_headers , role ) : [EOL] receiver = profile_factory ( role = role ) [EOL] sender = profile_factory ( role = Role . opposite ( role ) ) [EOL] [EOL] with client as cli : [EOL] headers = make_token_headers ( sender . user_id ) [EOL] response = cli . post ( [string] , headers = headers , json = { [string] : receiver . user_id } ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert RideRequest ( ** response . json ( ) ) [EOL] [EOL] [EOL] def test_create_ride_request_raises_404 ( client , faker , make_token_headers ) : [EOL] with client as cli : [EOL] response = cli . post ( [string] , headers = make_token_headers ( ) , json = { [string] : faker . pyint ( ) } ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_create_ride_request_when_sender_is_not_joined ( client , profile_factory , make_token_headers ) : [EOL] receiver = profile_factory ( save = True ) [EOL] [EOL] with client as cli : [EOL] response = cli . post ( [string] , headers = make_token_headers ( ) , json = { [string] : receiver . user_id } ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert RideRequest ( ** response . json ( ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_update_ride ( client , profile_factory , make_token_headers , role ) : [EOL] receiver = profile_factory ( role = role ) [EOL] sender = profile_factory ( role = Role . opposite ( receiver . role ) ) [EOL] ride_request = RideRequest ( sender = sender , receiver = receiver , status = RideRequestStatus . requested ) [EOL] [EOL] with client as cli : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( repositories . rides . create_request ( cli . app . redis_cli , ride_request ) ) [EOL] response = cli . put ( f" [string] { ride_request . ride_id }" , headers = make_token_headers ( receiver . user_id ) , json = { [string] : RideRequestStatus . accepted . value , [string] : sender . user_id } , ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert RideRequest ( ** response . json ( ) ) [EOL] [EOL] [EOL] def test_update_ride_receiver_not_found ( client , faker , make_token_headers ) : [EOL] with client as cli : [EOL] response = cli . put ( f" [string] { faker . pyint ( ) }" , headers = make_token_headers ( ) , json = { [string] : RideRequestStatus . accepted . value , [string] : faker . pyint ( ) } , ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] def test_update_ride_sender_not_found ( client , faker , profile_factory , make_token_headers ) : [EOL] receiver = profile_factory ( role = Role . hitchhiker ) [EOL] with client as cli : [EOL] headers = make_token_headers ( receiver . user_id ) [EOL] response = cli . put ( f" [string] { faker . pyint ( ) }" , headers = headers , json = { [string] : RideRequestStatus . accepted . value , [string] : faker . pyint ( ) } , ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] def test_update_ride_ride_request_not_found ( client , profile_factory , make_token_headers ) : [EOL] receiver = profile_factory ( role = Role . hitchhiker ) [EOL] sender = profile_factory ( role = Role . opposite ( receiver . role ) ) [EOL] with client as cli : [EOL] headers = make_token_headers ( receiver . user_id ) [EOL] response = cli . put ( f" [string] { sender . user_id }" , headers = headers , json = { [string] : RideRequestStatus . accepted . value , [string] : sender . user_id } , ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_leaves_ride ( client , profile_factory , make_token_headers , role ) : [EOL] sender = profile_factory ( role = role ) [EOL] receiver = profile_factory ( role = Role . opposite ( role ) ) [EOL] ride_request = RideRequest ( sender = sender , receiver = receiver , status = RideRequestStatus . accepted ) [EOL] with client as cli : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( repositories . rides . update_request ( cli . app . redis_cli , ride_request ) ) [EOL] response = cli . delete ( [string] , headers = make_token_headers ( sender . user_id ) ) [EOL] assert response . status_code == [number] [EOL] assert response . text == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_leaves_ride_when_no_ride_exists ( client , profile_factory , make_token_headers , role ) : [EOL] profile = profile_factory ( role = role ) [EOL] with client as cli : [EOL] response = cli . delete ( [string] , headers = make_token_headers ( profile . user_id ) ) [EOL] assert response . status_code == [number] [EOL] assert response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] def test_leave_ride_raises_404 ( client , make_token_headers ) : [EOL] with client as cli : [EOL] response = cli . delete ( [string] , headers = make_token_headers ( ) ) [EOL] assert response . status_code == [number] [EOL] assert response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_get_current_ride ( client , profile_factory , make_token_headers , role ) : [EOL] sender = profile_factory ( role = role ) [EOL] receiver = profile_factory ( role = Role . opposite ( role ) ) [EOL] ride_request = RideRequest ( sender = sender , receiver = receiver , status = RideRequestStatus . accepted ) [EOL] with client as cli : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( repositories . rides . update_request ( cli . app . redis_cli , ride_request ) ) [EOL] response = cli . get ( [string] , headers = make_token_headers ( sender . user_id ) ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert Ride ( ** response . json ( ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_get_current_ride_404 ( client , profile_factory , make_token_headers , role ) : [EOL] profile = profile_factory ( role = role ) [EOL] with client as cli : [EOL] response = cli . get ( [string] , headers = make_token_headers ( profile . user_id ) ) [EOL] assert response . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import excars [EOL] import asyncio [EOL] import asyncio [EOL] from typing import Any , Dict [EOL] [EOL] import pytest [EOL] from starlette . websockets import WebSocketDisconnect [EOL] [EOL] from excars import repositories [EOL] from excars . models . locations import Location , MapItem [EOL] from excars . models . messages import MessageType [EOL] from excars . models . profiles import Role [EOL] from excars . models . rides import RideRequest , RideRequestStatus [EOL] [EOL] [EOL] def assert_map_item ( message , user_id , location , has_same_ride ) : [EOL] assert message [ [string] ] == MessageType . map [EOL] map_item = MapItem ( ** message [ [string] ] [ [number] ] ) [EOL] assert map_item . user_id == user_id [EOL] assert map_item . location . user_id == user_id [EOL] assert map_item . location . latitude == location . latitude [EOL] assert map_item . location . longitude == location . longitude [EOL] assert map_item . has_same_ride == has_same_ride [EOL] [EOL] [EOL] def wait_for_message_type ( ws , message_type , count = [number] ) : [comment] [EOL] for _ in range ( count ) : [EOL] data = ws . receive_json ( ) [EOL] if data [ [string] ] == message_type : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def test_ws_close_for_unauthorized_user ( client ) : [EOL] with pytest . raises ( WebSocketDisconnect ) : [EOL] with client as cli , cli . websocket_connect ( [string] ) as ws : [EOL] ws . receive_json ( ) [EOL] [EOL] [EOL] def test_ws_receive_empty_map ( client , make_token_headers ) : [EOL] with client as cli , cli . websocket_connect ( [string] , headers = make_token_headers ( ) ) as ws : [EOL] data = ws . receive_json ( ) [EOL] assert data == { [string] : MessageType . map , [string] : [ ] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_ws_receive_map_for_user_without_ride ( client , location_factory , profile_factory , make_token_headers , role ) : [EOL] sender = profile_factory ( role = role ) [EOL] location = location_factory ( user_id = sender . user_id ) [EOL] [EOL] receiver = profile_factory ( role = Role . opposite ( role ) ) [EOL] location_factory ( user_id = receiver . user_id ) [EOL] [EOL] with client as cli : [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( receiver . user_id ) ) as ws : [EOL] assert_map_item ( ws . receive_json ( ) , sender . user_id , location , has_same_ride = False ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_ws_receive_map_without_ride_and_profile ( client , location_factory , profile_factory , make_token_headers , role ) : [EOL] sender = profile_factory ( role = role ) [EOL] location = location_factory ( user_id = sender . user_id ) [EOL] [EOL] receiver_user_id = sender . user_id + [string] [EOL] location_factory ( user_id = receiver_user_id ) [EOL] [EOL] with client as cli : [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( receiver_user_id ) ) as ws : [EOL] assert_map_item ( ws . receive_json ( ) , sender . user_id , location , has_same_ride = False ) [EOL] [EOL] [EOL] def test_ws_receive_no_map_without_profile ( client , faker , location_factory , make_token_headers ) : [EOL] receiver_user_id = faker . pyint ( ) [EOL] location_factory ( user_id = receiver_user_id ) [EOL] location_factory ( ) [EOL] [EOL] with client as cli : [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( receiver_user_id ) ) as ws : [EOL] data = ws . receive_json ( ) [EOL] assert data == { [string] : MessageType . map , [string] : [ ] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_ws_receive_map_within_same_ride ( client , location_factory , profile_factory , make_token_headers , role ) : [EOL] ride_request = RideRequest ( sender = profile_factory ( role = role ) , receiver = profile_factory ( role = Role . opposite ( role ) ) , status = RideRequestStatus . accepted , ) [EOL] location = location_factory ( user_id = ride_request . sender . user_id ) [EOL] location_factory ( user_id = ride_request . receiver . user_id ) [EOL] [EOL] with client as cli : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( repositories . rides . update_request ( cli . app . redis_cli , ride_request ) ) [EOL] [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( ride_request . receiver . user_id ) ) as ws : [EOL] assert_map_item ( ws . receive_json ( ) , ride_request . sender . user_id , location , has_same_ride = True ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_ws_receive_map_within_different_ride ( client , location_factory , profile_factory , make_token_headers , role ) : [EOL] ride_request = RideRequest ( sender = profile_factory ( role = role ) , receiver = profile_factory ( role = Role . opposite ( role ) ) , status = RideRequestStatus . accepted , ) [EOL] location_factory ( user_id = ride_request . receiver . user_id ) [EOL] [EOL] receiver = profile_factory ( role = role ) [EOL] location_factory ( user_id = receiver . user_id ) [EOL] [EOL] with client as cli : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( repositories . rides . update_request ( cli . app . redis_cli , ride_request ) ) [EOL] [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( receiver . user_id ) ) as ws : [EOL] assert ws . receive_json ( ) == { [string] : MessageType . map , [string] : [ ] } [EOL] [EOL] [EOL] def test_ws_send_location ( client , profile_factory , make_token_headers ) : [EOL] sender = profile_factory ( role = Role . driver ) [EOL] [EOL] with client as cli : [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( sender . user_id ) ) as ws : [EOL] ws . send_json ( { [string] : MessageType . location , [string] : { [string] : [number] , [string] : [number] , [string] : - [number] } } ) [EOL] [EOL] [EOL] def test_ws_send_invalid_data ( client , profile_factory , make_token_headers ) : [EOL] sender = profile_factory ( role = Role . driver ) [EOL] [EOL] with client as cli : [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( sender . user_id ) ) as ws : [EOL] ws . send_json ( { [string] : MessageType . location , [string] : { [string] : [number] } } ) [EOL] message = ws . receive_json ( ) [EOL] assert message [ [string] ] == MessageType . error [EOL] assert isinstance ( message [ [string] ] , list ) [EOL] [EOL] [EOL] def test_ws_receive_ride_requested ( client , profile_factory , make_token_headers ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] ride_request = RideRequest ( sender = profile_factory ( role = Role . driver ) , receiver = profile_factory ( role = Role . hitchhiker ) , status = RideRequestStatus . requested , ) [EOL] [EOL] with client as cli : [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( ride_request . receiver . user_id ) ) as ws : [EOL] asyncio . run_coroutine_threadsafe ( repositories . stream . ride_requested ( cli . app . redis_cli , ride_request ) , loop ) [EOL] assert wait_for_message_type ( ws , MessageType . ride_requested ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( RideRequestStatus . accepted , MessageType . ride_request_accepted ) , ( RideRequestStatus . declined , MessageType . ride_request_declined ) , ] , ) def test_ws_receive_ride_request_updated ( client , profile_factory , make_token_headers , status , expected ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] ride_request = RideRequest ( sender = profile_factory ( role = Role . driver ) , receiver = profile_factory ( role = Role . hitchhiker ) , status = status ) [EOL] [EOL] with client as cli : [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( ride_request . sender . user_id ) ) as ws : [EOL] asyncio . run_coroutine_threadsafe ( repositories . stream . request_updated ( cli . app . redis_cli , ride_request ) , loop ) [EOL] assert wait_for_message_type ( ws , expected ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Role . driver , Role . hitchhiker ] ) def test_ws_ride_updated ( client , profile_factory , make_token_headers , role ) : [EOL] ride_request = RideRequest ( sender = profile_factory ( role = role ) , receiver = profile_factory ( role = Role . opposite ( role ) ) , status = RideRequestStatus . accepted , ) [EOL] [EOL] with client as cli : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( repositories . rides . update_request ( cli . app . redis_cli , ride_request ) ) [EOL] ride = loop . run_until_complete ( repositories . rides . get ( cli . app . redis_cli , ride_request . ride_id ) ) [EOL] [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( ride_request . sender . user_id ) ) as ws : [EOL] asyncio . run_coroutine_threadsafe ( repositories . stream . ride_updated ( cli . app . redis_cli , ride ) , loop ) [EOL] assert wait_for_message_type ( ws , MessageType . ride_updated ) [EOL] [EOL] [EOL] def test_ws_ride_cancelled ( client , profile_factory , make_token_headers ) : [EOL] ride_request = RideRequest ( sender = profile_factory ( role = Role . driver ) , receiver = profile_factory ( role = Role . hitchhiker ) , status = RideRequestStatus . accepted , ) [EOL] [EOL] with client as cli : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( repositories . rides . update_request ( cli . app . redis_cli , ride_request ) ) [EOL] ride = loop . run_until_complete ( repositories . rides . get ( cli . app . redis_cli , ride_request . ride_id ) ) [EOL] [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( ride_request . receiver . user_id ) ) as ws : [EOL] asyncio . run_coroutine_threadsafe ( repositories . stream . ride_cancelled ( cli . app . redis_cli , ride ) , loop ) [EOL] assert wait_for_message_type ( ws , MessageType . ride_cancelled ) [EOL] [EOL] [EOL] def test_ws_reconnect ( client , profile_factory , make_token_headers ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] ride_request = RideRequest ( sender = profile_factory ( role = Role . driver ) , receiver = profile_factory ( role = Role . hitchhiker ) , status = RideRequestStatus . requested , ) [EOL] [EOL] with client as cli : [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( ride_request . receiver . user_id ) ) as ws : [EOL] asyncio . run_coroutine_threadsafe ( repositories . stream . ride_requested ( cli . app . redis_cli , ride_request ) , loop ) [EOL] assert wait_for_message_type ( ws , MessageType . ride_requested ) [EOL] [EOL] with cli . websocket_connect ( [string] , headers = make_token_headers ( ride_request . receiver . user_id ) ) as ws : [EOL] asyncio . run_coroutine_threadsafe ( repositories . stream . ride_requested ( cli . app . redis_cli , ride_request ) , loop ) [EOL] assert wait_for_message_type ( ws , MessageType . ride_requested ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def test_users_me ( client , make_token_headers ) : [EOL] with client as cli : [EOL] response = cli . get ( [string] , headers = make_token_headers ( ) ) [EOL] assert response . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import excars [EOL] import random [EOL] [EOL] from excars . models . profiles import Profile , Role [EOL] [EOL] [EOL] def test_join ( client , faker , make_token_headers ) : [EOL] role = random . choice ( [ Role . driver , Role . hitchhiker ] ) [EOL] with client as cli : [EOL] response = cli . post ( [string] , headers = make_token_headers ( ) , json = { [string] : role , [string] : { [string] : faker . name ( ) , [string] : str ( faker . latitude ( ) ) , [string] : str ( faker . longitude ( ) ) , } , } , ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert response . json ( ) [ [string] ] == role [EOL] [EOL] [EOL] def test_get_profile ( client , profile_factory , make_token_headers ) : [EOL] profile = profile_factory ( ) [EOL] [EOL] with client as cli : [EOL] response = cli . get ( f" [string] { profile . user_id }" , headers = make_token_headers ( ) ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert Profile ( ** response . json ( ) ) == profile [EOL] [EOL] [EOL] def test_get_profile_returns_404 ( client , faker , make_token_headers ) : [EOL] with client as cli : [EOL] response = cli . get ( f" [string] { faker . pyint ( ) }" , headers = make_token_headers ( ) ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_delete_profile ( client , make_token_headers ) : [EOL] with client as cli : [EOL] response = cli . delete ( f" [string] " , headers = make_token_headers ( ) ) [EOL] assert response . status_code == [number] [EOL] assert response . text == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . import locations [comment] [EOL] from . import profile [comment] [EOL] from . import rides [comment] [EOL] from . import stream [comment] [EOL] from . import users [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] import excars [EOL] import aioredis [EOL] import asyncio [EOL] from typing import Optional [EOL] [EOL] from aioredis import Redis [EOL] [EOL] from excars import config [EOL] from excars . models . profiles import Profile , Role [EOL] from excars . models . rides import Passenger , Ride , RideRequest [EOL] [EOL] from . import profile as profile_repo [EOL] [EOL] [EOL] def _get_ride_key ( ride_id , passenger_id ) : [EOL] return f" [string] { ride_id } [string] { passenger_id }" [EOL] [EOL] [EOL] def _get_ride_request_key ( ride_id , passenger_id ) : [EOL] return f" [string] { ride_id } [string] { passenger_id }" [EOL] [EOL] [EOL] async def create_request ( redis_cli , ride_request ) : [EOL] await redis_cli . setex ( _get_ride_request_key ( ride_request . ride_id , ride_request . passenger . user_id ) , value = ride_request . status . value , seconds = config . RIDE_REQUEST_TTL , ) [EOL] [EOL] [EOL] async def update_request ( redis_cli , ride_request ) : [EOL] await redis_cli . delete ( _get_ride_request_key ( ride_request . ride_id , ride_request . passenger . user_id ) ) [EOL] await redis_cli . set ( _get_ride_key ( ride_request . ride_id , ride_request . passenger . user_id ) , value = ride_request . status . value , expire = config . RIDE_TTL , ) [EOL] [EOL] [EOL] async def request_exists ( redis_cli , ride_request ) : [EOL] return bool ( await redis_cli . exists ( _get_ride_request_key ( ride_request . ride_id , ride_request . passenger . user_id ) ) ) [EOL] [EOL] [EOL] async def delete_or_exclude ( redis_cli , profile , timeout = [number] ) : [EOL] if profile . role == Role . hitchhiker : [EOL] await _exclude ( redis_cli , profile . user_id , timeout ) [EOL] elif profile . role == Role . driver : [EOL] await _delete ( redis_cli , profile . user_id , timeout ) [EOL] [EOL] [EOL] async def _delete ( redis_cli , ride_id , timeout ) : [EOL] ride = await get ( redis_cli , ride_id ) [EOL] if ride is not None : [EOL] keys = [ _get_ride_key ( ride_id , passenger . profile . user_id ) for passenger in ride . passengers ] [EOL] await asyncio . gather ( * [ redis_cli . expire ( key , timeout ) for key in keys ] ) [EOL] [EOL] [EOL] async def _exclude ( redis_cli , user_id , timeout ) : [EOL] ride_id = await get_ride_id ( redis_cli , user_id ) [EOL] if ride_id : [EOL] await redis_cli . expire ( _get_ride_key ( ride_id , user_id ) , timeout ) [EOL] [EOL] [EOL] async def get ( redis_cli , ride_id ) : [EOL] keys = [ key async for key in redis_cli . iscan ( match = _get_ride_key ( ride_id , [string] ) ) ] [EOL] if not keys : [EOL] return None [EOL] passengers_key = [ key . decode ( ) . rpartition ( [string] ) [ - [number] ] for key in keys ] [EOL] [EOL] driver = await profile_repo . get ( redis_cli , ride_id ) [EOL] if driver is None : [EOL] return None [EOL] [EOL] passengers = [ ] [EOL] for key in passengers_key : [EOL] profile = await profile_repo . get ( redis_cli , key ) [EOL] if profile is None : [EOL] continue [EOL] passengers . append ( Passenger ( profile = profile , status = ( await redis_cli . get ( _get_ride_key ( ride_id , key ) ) ) . decode ( ) ) ) [EOL] if not passengers : [EOL] return None [EOL] [EOL] return Ride ( ride_id = ride_id , driver = driver , passengers = passengers ) [EOL] [EOL] [EOL] async def get_ride_id ( redis_cli , user_id ) : [EOL] async for key in redis_cli . iscan ( match = _get_ride_key ( [string] , user_id ) ) : [EOL] return str ( key . decode ( ) . split ( [string] ) [ [number] ] ) [EOL] [EOL] async for _ in redis_cli . iscan ( match = _get_ride_key ( user_id , [string] ) ) : [comment] [EOL] return user_id [EOL] [EOL] return None [EOL] [EOL] [EOL] async def persist ( redis_cli , user_id ) : [EOL] ride_id = await get_ride_id ( redis_cli , user_id ) [EOL] if ride_id is not None : [EOL] keys = [ key async for key in redis_cli . iscan ( match = _get_ride_key ( ride_id , [string] ) ) ] [EOL] await asyncio . gather ( * [ redis_cli . persist ( key ) for key in keys ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[excars.models.rides.Ride]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import builtins [EOL] import typing [EOL] import excars [EOL] import aioredis [EOL] from typing import Optional [EOL] [EOL] from aioredis import Redis [EOL] [EOL] from excars . models . user import User [EOL] [EOL] [EOL] def _get_key_for ( user_id ) : [EOL] return f" [string] { user_id }" [EOL] [EOL] [EOL] async def get ( redis_cli , user_id ) : [EOL] data = await redis_cli . get ( _get_key_for ( user_id ) ) [EOL] if not data : [EOL] return None [EOL] return User . parse_raw ( data ) [EOL] [EOL] [EOL] async def save ( redis_cli , user ) : [EOL] await redis_cli . set ( _get_key_for ( user . user_id ) , user . json ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[excars.models.user.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import builtins [EOL] import typing [EOL] import excars [EOL] import aioredis [EOL] from typing import Optional [EOL] [EOL] from aioredis import Redis [EOL] [EOL] from excars import config [EOL] from excars . models . profiles import Profile [EOL] [EOL] [EOL] def _get_key_for ( user_id ) : [EOL] return f" [string] { user_id } [string] " [EOL] [EOL] [EOL] async def save ( redis_cli , profile ) : [EOL] await redis_cli . set ( _get_key_for ( profile . user_id ) , profile . json ( ) ) [EOL] [EOL] [EOL] async def get ( redis_cli , user_id ) : [EOL] data = await redis_cli . get ( _get_key_for ( user_id ) ) [EOL] if not data : [EOL] return None [EOL] return Profile . parse_raw ( data ) [EOL] [EOL] [EOL] async def delete ( redis_cli , user_id ) : [EOL] await redis_cli . delete ( _get_key_for ( user_id ) ) [EOL] [EOL] [EOL] async def persist ( redis_cli , user_id ) : [EOL] await redis_cli . persist ( _get_key_for ( user_id ) ) [EOL] [EOL] [EOL] async def expire ( redis_cli , user_id ) : [EOL] await redis_cli . expire ( _get_key_for ( user_id ) , timeout = config . PROFILE_TTL ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[excars.models.profiles.Profile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import excars [EOL] import aioredis [EOL] import asyncio [EOL] import time [EOL] from typing import List [EOL] [EOL] from aioredis import Redis [EOL] [EOL] from excars . models . locations import Location , UserLocation [EOL] [EOL] [EOL] def _get_key ( ) : [EOL] return [string] [EOL] [EOL] [EOL] def _get_key_for ( user_id ) : [EOL] return f" [string] { user_id } [string] " [EOL] [EOL] [EOL] def _decode ( data ) : [EOL] return { k . decode ( ) : v . decode ( ) for k , v in data . items ( ) } [EOL] [EOL] [EOL] async def list_for ( redis_cli , user_id ) : [EOL] if await redis_cli . zrank ( _get_key ( ) , user_id ) is None : [EOL] return [ ] [EOL] [EOL] geomembers = await redis_cli . georadiusbymember ( _get_key ( ) , member = user_id , radius = [number] , unit = [string] ) [EOL] locations = await asyncio . gather ( * [ redis_cli . hgetall ( _get_key_for ( geomember . decode ( ) ) ) for geomember in geomembers ] ) [EOL] locations = [ _decode ( location ) for location in locations ] [EOL] return [ UserLocation ( ** location ) for location in locations ] [EOL] [EOL] [EOL] async def save_for ( redis_cli , user_id , location ) : [EOL] await redis_cli . geoadd ( _get_key ( ) , latitude = str ( location . latitude ) , longitude = str ( location . longitude ) , member = str ( user_id ) ) [EOL] await redis_cli . hmset_dict ( _get_key_for ( user_id ) , user_id = user_id , latitude = str ( location . latitude ) , longitude = str ( location . longitude ) , course = str ( location . course ) , ts = str ( time . time ( ) ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[excars.models.locations.UserLocation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import excars [EOL] from enum import Enum [EOL] from typing import Any , List [EOL] [EOL] from pydantic import BaseModel [EOL] [EOL] from excars . models . profiles import Profile , Role [EOL] [EOL] [EOL] class RideRequestStatus ( str , Enum ) : [EOL] requested = [string] [EOL] accepted = [string] [EOL] declined = [string] [EOL] [EOL] [EOL] class RideRequest ( BaseModel ) : [EOL] ride_id = None [comment] [EOL] sender = ... [EOL] receiver = ... [EOL] status = ... [EOL] [EOL] def __init__ ( self , ** data ) : [EOL] super ( ) . __init__ ( ** data ) [EOL] self . ride_id = self . _get_profile_by_role ( Role . driver ) . user_id [EOL] [EOL] @ property def passenger ( self ) : [EOL] return self . _get_profile_by_role ( Role . hitchhiker ) [EOL] [EOL] def _get_profile_by_role ( self , role ) : [EOL] if self . sender . role == role : [EOL] return self . sender [EOL] if self . receiver . role == role : [EOL] return self . receiver [EOL] raise Exception ( ) [EOL] [EOL] [EOL] class RideRequestCreate ( BaseModel ) : [EOL] receiver = ... [EOL] [EOL] [EOL] class RideRequestUpdate ( BaseModel ) : [EOL] status = ... [EOL] sender = ... [EOL] [EOL] [EOL] class Passenger ( BaseModel ) : [EOL] profile = ... [EOL] status = ... [EOL] [EOL] [EOL] class Ride ( BaseModel ) : [EOL] ride_id = ... [EOL] driver = ... [EOL] passengers = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $excars.models.profiles.Profile$ 0 0 0 $excars.models.profiles.Profile$ 0 0 0 $RideRequestStatus$ 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $excars.models.profiles.Profile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $excars.models.profiles.Profile$ 0 0 0 $excars.models.profiles.Role$ 0 0 0 0 0 0 0 0 $excars.models.profiles.Role$ 0 $excars.models.profiles.Role$ 0 0 0 0 0 0 0 0 0 0 0 0 $excars.models.profiles.Role$ 0 $excars.models.profiles.Role$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $RideRequestStatus$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $excars.models.profiles.Profile$ 0 0 0 $RideRequestStatus$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $excars.models.profiles.Profile$ 0 0 0 $typing.List[Passenger]$ 0 0 0
from typing import Dict [EOL] import typing [EOL] import excars [EOL] from decimal import Decimal [EOL] from enum import Enum [EOL] [EOL] from pydantic import BaseModel [EOL] [EOL] from excars . models . user import User [EOL] [EOL] [EOL] class Role ( str , Enum ) : [EOL] driver = [string] [EOL] hitchhiker = [string] [EOL] [EOL] @ classmethod def opposite ( cls , role ) : [EOL] role_map = { cls . driver : cls . hitchhiker , cls . hitchhiker : cls . driver } [EOL] return role_map [ role ] [EOL] [EOL] [EOL] class Destination ( BaseModel ) : [EOL] name = ... [EOL] latitude = ... [EOL] longitude = ... [EOL] [EOL] [EOL] class JoinRequest ( BaseModel ) : [EOL] role = ... [EOL] destination = ... [EOL] [EOL] [EOL] class Profile ( BaseModel ) : [EOL] user_id = ... [EOL] name = ... [EOL] avatar = ... [EOL] role = ... [EOL] destination = ... [EOL] [EOL] @ classmethod def from_user ( cls , user , role , destination ) : [EOL] return cls ( user_id = user . user_id , name = user . name , avatar = user . avatar , role = role , destination = destination ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $"Role"$ 0 0 0 $"Role"$ 0 0 0 $typing.Dict[excars.models.profiles.Role,excars.models.profiles.Role]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[excars.models.profiles.Role,excars.models.profiles.Role]$ 0 $"Role"$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $decimal.Decimal$ 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 $Role$ 0 0 0 $Destination$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $Role$ 0 0 0 $Destination$ 0 0 0 0 0 0 0 0 0 0 0 $excars.models.user.User$ 0 $Role$ 0 $Destination$ 0 0 0 0 0 0 0 0 $excars.models.user.User$ 0 0 0 0 0 $excars.models.user.User$ 0 0 0 0 0 $excars.models.user.User$ 0 0 0 $Role$ 0 $Role$ 0 $Destination$ 0 $Destination$ 0 0
import excars [EOL] from pydantic import BaseModel [EOL] [EOL] from excars . models . token import TokenPayload [EOL] [EOL] [EOL] class User ( BaseModel ) : [EOL] user_id = ... [EOL] email = ... [EOL] name = ... [EOL] first_name = ... [EOL] last_name = ... [EOL] avatar = ... [EOL] [EOL] @ classmethod def from_token ( cls , token ) : [EOL] return cls ( user_id = token . sub , email = token . email , name = token . name , first_name = token . family_name , last_name = token . given_name , avatar = token . picture , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $"User"$ 0 0 0 $excars.models.token.TokenPayload$ 0 0 0 0 0 0 0 0 $excars.models.token.TokenPayload$ 0 0 0 0 0 $excars.models.token.TokenPayload$ 0 0 0 0 0 $excars.models.token.TokenPayload$ 0 0 0 0 0 $excars.models.token.TokenPayload$ 0 0 0 0 0 $excars.models.token.TokenPayload$ 0 0 0 0 0 $excars.models.token.TokenPayload$ 0 0 0 0 0
from decimal import Decimal [EOL] from typing import Optional [EOL] [EOL] from pydantic import BaseModel [EOL] [EOL] from . profiles import Role [EOL] [EOL] [EOL] class Location ( BaseModel ) : [EOL] latitude = ... [EOL] longitude = ... [EOL] course = ... [EOL] [EOL] [EOL] class UserLocation ( BaseModel ) : [EOL] user_id = ... [EOL] latitude = ... [EOL] longitude = ... [EOL] course = ... [EOL] ts = ... [EOL] [EOL] [EOL] class MapItem ( BaseModel ) : [EOL] user_id = ... [EOL] role = ... [EOL] location = ... [EOL] has_same_ride = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 $decimal.Decimal$ 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $decimal.Decimal$ 0 0 0 $decimal.Decimal$ 0 0 0 $decimal.Decimal$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[profiles.Role]$ 0 0 0 $UserLocation$ 0 0 0 $builtins.bool$ 0 0 0
from typing import Optional [EOL] [EOL] from pydantic import BaseModel [EOL] [EOL] [EOL] class TokenPayload ( BaseModel ) : [EOL] sub = ... [EOL] email = ... [EOL] name = ... [EOL] family_name = ... [EOL] given_name = ... [EOL] picture = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0
from enum import Enum [EOL] from typing import Any , Dict , NamedTuple [EOL] [EOL] from pydantic import BaseModel [EOL] [EOL] [EOL] class MessageType ( str , Enum ) : [EOL] location = [string] [EOL] map = [string] [EOL] ride_requested = [string] [EOL] ride_request_accepted = [string] [EOL] ride_request_declined = [string] [EOL] ride_updated = [string] [EOL] ride_cancelled = [string] [EOL] [EOL] socket_close = [string] [EOL] socket_open = [string] [EOL] [EOL] error = [string] [EOL] [EOL] [EOL] class Message ( BaseModel ) : [EOL] type = ... [EOL] data = ... [EOL] [EOL] [EOL] class StreamMessage ( NamedTuple ) : [EOL] stream = ... [EOL] message_id = ... [EOL] data = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $MessageType$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.bytes,typing.Any]$ 0 0 0