[EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import glob [EOL] import pickle [EOL] import numpy as np [EOL] from music21 import converter , instrument , note , chord , stream [EOL] from keras . models import Sequential [EOL] from keras . layers import Dense [EOL] from keras . layers import Dropout [EOL] from keras . layers import LSTM [EOL] from keras . layers import Activation [EOL] from keras . utils import np_utils [EOL] from keras . callbacks import ModelCheckpoint [EOL] [EOL] def train_network ( ) : [EOL] [docstring] [EOL] [EOL] notes = get_notes ( ) [EOL] [EOL] [comment] [EOL] n_vocab = len ( set ( notes ) ) [EOL] [EOL] network_input , network_output = prepare_sequences ( notes , n_vocab ) [EOL] [EOL] model = create_network ( network_input , n_vocab ) [EOL] [EOL] train ( model , network_input , network_output ) [EOL] [EOL] def get_notes ( ) : [EOL] [docstring] [EOL] [EOL] notes = [ ] [EOL] [EOL] for file in glob . glob ( [string] ) : [EOL] midi = converter . parse ( file ) [EOL] notes_to_parse = None [EOL] [EOL] parts = instrument . partitionByInstrument ( midi ) [EOL] [EOL] if parts : [comment] [EOL] notes_to_parse = parts . parts [ [number] ] . recurse ( ) [EOL] else : [comment] [EOL] notes_to_parse = midi . flat . notes [EOL] [EOL] for element in notes_to_parse : [EOL] if isinstance ( element , note . Note ) : [EOL] notes . append ( str ( element . pitch ) ) [EOL] elif isinstance ( element , chord . Chord ) : [EOL] notes . append ( [string] . join ( str ( n ) for n in element . normalOrder ) ) [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] pickle . dump ( notes , f ) [EOL] [EOL] return notes [EOL] [EOL] def prepare_sequences ( notes , n_vocab ) : [EOL] sequence_length = [number] [EOL] [EOL] [comment] [EOL] pitchnames = sorted ( set ( item for item in notes ) ) [EOL] [EOL] [comment] [EOL] note_to_int = dict ( ( note , number ) for number , note in enumerate ( pitchnames ) ) [EOL] [EOL] network_input = [ ] [EOL] network_output = [ ] [EOL] [EOL] [comment] [EOL] for i in range ( [number] , len ( notes ) - sequence_length , [number] ) : [EOL] sequence_in = notes [ i : i + sequence_length ] [EOL] sequence_out = notes [ i + sequence_length ] [EOL] [EOL] network_input . append ( [ note_to_int [ char ] for char in sequence_in ] ) [EOL] network_output . append ( note_to_int [ sequence_out ] ) [EOL] [EOL] n_patterns = len ( network_input ) [EOL] [EOL] [comment] [EOL] network_input = np . reshape ( network_input , ( n_patterns , sequence_length , [number] ) ) [EOL] [EOL] [comment] [EOL] network_input = network_input / float ( n_vocab ) [EOL] [EOL] network_output = np_utils . to_categorical ( network_output ) [EOL] [EOL] return ( network_input , network_output ) [EOL] [EOL] def create_network ( network_input , n_vocab ) : [EOL] [docstring] [EOL] model = Sequential ( ) [EOL] model . add ( LSTM ( [number] , input_shape = ( network_input . shape [ [number] ] , network_input . shape [ [number] ] ) , return_sequences = True ) ) [EOL] model . add ( Dropout ( [number] ) ) [EOL] model . add ( LSTM ( [number] , return_sequences = True ) ) [EOL] model . add ( Dropout ( [number] ) ) [EOL] model . add ( LSTM ( [number] ) ) [EOL] model . add ( Dense ( [number] ) ) [EOL] model . add ( Dropout ( [number] ) ) [EOL] model . add ( Dense ( n_vocab ) ) [EOL] model . add ( Activation ( [string] ) ) [EOL] model . compile ( loss = [string] , optimizer = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return model [EOL] [EOL] def train ( model , network_input , network_output ) : [EOL] [docstring] [EOL] [EOL] filepath = [string] [EOL] checkpoint = ModelCheckpoint ( filepath , monitor = [string] , verbose = [number] , save_best_only = True , mode = [string] ) [EOL] [EOL] callback_list = [ checkpoint ] [EOL] [EOL] model . fit ( network_input , network_output , epochs = [number] , batch_size = [number] , callbacks = callback_list ) [EOL] [EOL] def generate_notes ( model , network_input , pitchnames , n_vocab ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] start = np . random . randint ( [number] , len ( network_input ) - [number] ) [EOL] [EOL] int_to_note = dict ( ( number , note ) for number , note in enumerate ( pitchnames ) ) [EOL] [EOL] pattern = network_input [ start ] [EOL] prediction_output = [ ] [EOL] [EOL] [comment] [EOL] for note_index in range ( [number] ) : [EOL] prediction_input = np . reshape ( pattern , ( [number] , len ( pattern ) , [number] ) ) [EOL] prediction_input = model . predict ( prediction_input , verbose = [number] ) [EOL] [EOL] index = np . argmax ( prediction_input ) [EOL] [EOL] result = int_to_note [ index ] [EOL] prediction_output . append ( result ) [EOL] [EOL] pattern . append ( index ) [EOL] pattern = pattern [ [number] : ] [EOL] [EOL] return prediction_output [EOL] [EOL] def create_midi ( prediction_output ) : [EOL] offset = [number] [EOL] output_notes = [ ] [EOL] [EOL] [comment] [EOL] [EOL] for pattern in prediction_output : [EOL] [comment] [EOL] if ( [string] in pattern ) or pattern . isdigit ( ) : [EOL] notes_in_chord = pattern . split ( [string] ) [EOL] notes = [ ] [EOL] [EOL] for current_note in notes_in_chord : [EOL] new_note = note . Note ( int ( current_note ) ) [EOL] new_note . storedInstrument = instrument . Piano ( ) [EOL] notes . append ( new_note ) [EOL] [EOL] new_chord = chord . Chord ( notes ) [EOL] new_chord . offset = offset [EOL] [EOL] output_notes . append ( new_chord ) [EOL] [EOL] [comment] [EOL] else : [EOL] new_note = note . Note ( pattern ) [EOL] new_note . offset = offset [EOL] new_note . storedInstrument = instrument . Piano ( ) [EOL] [EOL] output_notes . append ( new_note ) [EOL] [EOL] offset += [number] [EOL] [EOL] midi_stream = stream . Stream ( output_notes ) [EOL] [EOL] midi_stream . write ( [string] , fp = [string] ) [EOL] [EOL] def main ( ) : [EOL] train_network ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from classical_piano_composer import __version__ [EOL] [EOL] [EOL] def test_version ( ) : [EOL] assert __version__ == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0