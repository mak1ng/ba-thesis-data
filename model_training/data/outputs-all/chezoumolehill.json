from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
import molehill [EOL] from molehill . utils import build_query [EOL] [EOL] [EOL] def test_build_query ( ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] assert build_query ( [ [string] , [string] ] , [string] ) == ret_sql [EOL] [EOL] [EOL] def test_build_query_without_semicolon ( ) : [EOL] ret_sql = f""" [string] """ [EOL] assert build_query ( [ [string] , [string] ] , [string] , without_semicolon = True ) == ret_sql [EOL] [EOL] [EOL] def test_build_query_with_condition ( ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] cond = [string] [EOL] assert build_query ( [ [string] , [string] ] , [string] , condition = cond ) == ret_sql [EOL] [EOL] [EOL] def test_build_query_with_clause ( ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] with_clause = [string] [EOL] assert build_query ( [ [string] , [string] ] , [string] , with_clauses = { [string] : with_clause } ) == ret_sql [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import filecmp [EOL] import typing [EOL] import molehill [EOL] import pathlib [EOL] import filecmp [EOL] import pytest [EOL] import os [EOL] from pathlib import Path [EOL] from molehill . pipeline import Pipeline [EOL] [EOL] TEST_DATA_DIR = Path ( __file__ ) . resolve ( ) . parent / [string] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def change_dir ( tmp_path ) : [EOL] current_dir = os . curdir [EOL] os . chdir ( tmp_path ) [EOL] yield [EOL] os . chdir ( current_dir ) [EOL] [EOL] [EOL] def test_dump_yaml ( ) : [EOL] dig_file = Path ( [string] ) [EOL] input_yaml = TEST_DATA_DIR / [string] [EOL] test_query_dir = TEST_DATA_DIR / [string] [EOL] test_dig_file = TEST_DATA_DIR / [string] [EOL] [EOL] pipeline = Pipeline ( ) [EOL] pipeline . dump_pipeline ( input_yaml , dig_file , False ) [EOL] assert dig_file . read_text ( ) == test_dig_file . read_text ( ) [EOL] dc = filecmp . dircmp ( test_query_dir , [string] ) [EOL] for diff_file in dc . diff_files : [EOL] assert ( test_query_dir / diff_file ) . read_text ( ) == ( Path ( [string] ) / diff_file ) . read_text ( ) [EOL] [EOL] assert len ( dc . diff_files ) == [number] [EOL] [EOL] [EOL] def test_dump_yaml_oversample ( ) : [EOL] dig_file = Path ( [string] ) [EOL] input_yaml = TEST_DATA_DIR / [string] [EOL] test_query_dir = TEST_DATA_DIR / [string] [EOL] test_dig_file = TEST_DATA_DIR / [string] [EOL] [EOL] pipeline = Pipeline ( ) [EOL] pipeline . dump_pipeline ( input_yaml , dig_file , False ) [EOL] assert dig_file . read_text ( ) == test_dig_file . read_text ( ) [EOL] dc = filecmp . dircmp ( test_query_dir , [string] ) [EOL] for diff_file in dc . diff_files : [EOL] assert ( test_query_dir / diff_file ) . read_text ( ) == ( Path ( [string] ) / diff_file ) . read_text ( ) [EOL] [EOL] assert len ( dc . diff_files ) == [number] [EOL] [EOL] [EOL] def test_dump_yaml_pos_oversample ( ) : [EOL] dig_file = Path ( [string] ) [EOL] input_yaml = TEST_DATA_DIR / [string] [EOL] test_query_dir = TEST_DATA_DIR / [string] [EOL] test_dig_file = TEST_DATA_DIR / [string] [EOL] [EOL] pipeline = Pipeline ( ) [EOL] pipeline . dump_pipeline ( input_yaml , dig_file , False ) [EOL] assert dig_file . read_text ( ) == test_dig_file . read_text ( ) [EOL] dc = filecmp . dircmp ( test_query_dir , [string] ) [EOL] for diff_file in dc . diff_files : [EOL] assert ( test_query_dir / diff_file ) . read_text ( ) == ( Path ( [string] ) / diff_file ) . read_text ( ) [EOL] [EOL] assert len ( dc . diff_files ) == [number] [EOL] [EOL] [EOL] def test_dump_yaml_randomforest ( ) : [EOL] dig_file = Path ( [string] ) [EOL] input_yaml = TEST_DATA_DIR / [string] [EOL] test_query_dir = TEST_DATA_DIR / [string] [EOL] test_dig_file = TEST_DATA_DIR / [string] [EOL] [EOL] pipeline = Pipeline ( ) [EOL] pipeline . dump_pipeline ( input_yaml , dig_file , False ) [EOL] assert dig_file . read_text ( ) == test_dig_file . read_text ( ) [EOL] dc = filecmp . dircmp ( test_query_dir , [string] ) [EOL] for diff_file in dc . diff_files : [EOL] assert ( test_query_dir / diff_file ) . read_text ( ) == ( Path ( [string] ) / diff_file ) . read_text ( ) [EOL] [EOL] assert len ( dc . diff_files ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import molehill [EOL] from molehill . stats import compute_stats , combine_train_test_stats [EOL] [EOL] [EOL] def test_compute_stats ( ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] assert compute_stats ( [string] , [ [string] , [string] ] ) == ret_sql [EOL] [EOL] [EOL] def test_combine_train_test_stats ( ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert combine_train_test_stats ( [string] , [ [string] ] ) == ret_sql [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import pytest [EOL] import molehill [EOL] from molehill . evaluation import evaluate [EOL] [EOL] [EOL] def test_evaluate_with_auc ( ) : [EOL] metrics = [ [string] , [string] ] [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] assert evaluate ( metrics , [string] , [string] , [string] , [string] , [string] ) == ret_sql [EOL] [EOL] [EOL] def test_evaluate_with_logloss ( ) : [EOL] metrics = [ [string] ] [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] assert evaluate ( metrics , [string] , [string] ) == ret_sql [EOL] [EOL] [EOL] def test_evaluate_fmeasure ( ) : [EOL] metrics = [ [string] ] [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] assert evaluate ( metrics , [string] , [string] ) == ret_sql [EOL] [EOL] [EOL] def test_evaluate_with_accuracy_precision_recall ( ) : [EOL] metrics = [ [string] , [string] , [string] ] [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] assert evaluate ( metrics , [string] , [string] ) == ret_sql [EOL] [EOL] [EOL] def test_evaluate_unknown_measure ( ) : [EOL] metrics = [ [string] ] [EOL] with pytest . raises ( ValueError ) : [EOL] evaluate ( metrics , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] import molehill [EOL] from molehill . model import train_randomforest_classifier , train_randomforest_regressor [EOL] from molehill . model import predict_randomforest_classifier , predict_randomforest_regressor [EOL] from molehill . model import _extract_attrs [EOL] [EOL] [EOL] @ pytest . fixture def categorical_cols ( ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] [EOL] @ pytest . fixture def numerical_cols ( ) : [EOL] return [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_extract_attrs ( categorical_cols , numerical_cols ) : [EOL] assert _extract_attrs ( categorical_cols , numerical_cols ) == [string] [EOL] assert _extract_attrs ( [ ] , numerical_cols ) == [string] [EOL] assert _extract_attrs ( categorical_cols , [ ] ) == [string] [EOL] [EOL] [EOL] class TestSparseTrainModel : [EOL] def test_train_randomforest_classifier ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_randomforest_classifier ( [string] , [string] , [string] , sparse = True ) == ret_sql [EOL] [EOL] def test_train_randomforest_regressor ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_randomforest_regressor ( [string] , [string] , sparse = True ) == ret_sql [EOL] [EOL] [EOL] class TestDenseTrainModel : [EOL] def test_train_randomforest_classifier ( self , categorical_cols , numerical_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_randomforest_classifier ( [string] , [string] , [string] , categorical_columns = categorical_cols , numerical_columns = numerical_cols ) == ret_sql [EOL] [EOL] def test_train_randomforest_regressor ( self , categorical_cols , numerical_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_randomforest_regressor ( [string] , [string] , categorical_columns = categorical_cols , numerical_columns = numerical_cols ) == ret_sql [EOL] [EOL] [EOL] class TestPredictClassifier : [EOL] def test_predict_randomforest_classifier ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] pred_sql , pred_col = predict_randomforest_classifier ( [string] , [string] , [string] ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] def test_predict_randomforest_classifier_hashing ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_randomforest_classifier ( [string] , [string] , [string] , hashing = True ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] [EOL] class TestPredictRegressor : [EOL] def test_predict_randomforest_regressor ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_randomforest_regressor ( [string] , [string] , [string] ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] def test_predict_regressor_hashing ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_randomforest_regressor ( [string] , [string] , [string] , hashing = True ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
import molehill [EOL] from molehill . model import train_classifier , train_regressor [EOL] from molehill . model import predict_classifier , predict_regressor [EOL] [EOL] [EOL] class TestTrainClassifier : [EOL] def test_train_classifier ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_classifier ( [string] , [string] ) == ret_sql [EOL] [EOL] def test_train_classifier_pos_oversampling ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_classifier ( [string] , [string] , oversample_pos_n_times = [string] ) == ret_sql [EOL] [EOL] def test_train_classifier_oversampling ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_classifier ( [string] , [string] , oversample_n_times = [string] ) == ret_sql [EOL] [EOL] def test_train_classifier_bias ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_classifier ( [string] , [string] , bias = True ) == ret_sql [EOL] [EOL] def test_train_classifier_hashing ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_classifier ( [string] , [string] , hashing = True ) == ret_sql [EOL] [EOL] def test_train_classifier_bias_hashing ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_classifier ( [string] , [string] , bias = True , hashing = True ) == ret_sql [EOL] [EOL] [EOL] def test_train_regressor ( ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert train_regressor ( [string] , [string] ) == ret_sql [EOL] [EOL] [EOL] class TestPredictClassifier : [EOL] def test_predict_classifier ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_classifier ( [string] , [string] , [string] ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] def test_predict_classifier_bias ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_classifier ( [string] , [string] , [string] , bias = True ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] def test_predict_classifier_hashing ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_classifier ( [string] , [string] , [string] , hashing = True ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] def test_predict_classifier_bias_hashing ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_classifier ( [string] , [string] , [string] , bias = True , hashing = True ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] def test_predict_classifier_wo_sigmoid ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_classifier ( [string] , [string] , [string] , sigmoid = False ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] [EOL] class TestPredictRegressor : [EOL] def test_predict_regressor ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_regressor ( [string] , [string] , [string] , [string] ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] def test_predict_regressor_bias ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_regressor ( [string] , [string] , [string] , [string] , bias = True ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] def test_predict_regressor_hashing ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_regressor ( [string] , [string] , [string] , [string] , hashing = True ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL] [EOL] def test_predict_regressor_bias_hashing ( self ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] pred_sql , pred_col = predict_regressor ( [string] , [string] , [string] , [string] , bias = True , hashing = True ) [EOL] assert pred_sql == ret_sql [EOL] assert pred_col == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
import molehill [EOL] import pytest [EOL] from molehill . preprocessing . normalization import Normalizer [EOL] [EOL] [EOL] @ pytest . fixture ( ) def num_cols ( ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] [EOL] def test_normalizer_minmax ( num_cols ) : [EOL] ret_sql = [string] [EOL] [EOL] inv_sql = [string] [EOL] [EOL] normalizer = Normalizer ( [string] , [string] ) [EOL] assert normalizer . transform ( num_cols ) == ret_sql [EOL] assert normalizer . invert_transform ( num_cols ) == inv_sql [EOL] [EOL] [EOL] def test_normalizer_minmax_without_phase ( num_cols ) : [EOL] ret_sql = [string] [EOL] [EOL] inv_sql = [string] [EOL] [EOL] normalizer = Normalizer ( [string] , None ) [EOL] assert normalizer . transform ( num_cols ) == ret_sql [EOL] assert normalizer . invert_transform ( num_cols ) == inv_sql [EOL] [EOL] [EOL] def test_normalizer_standardize ( num_cols ) : [EOL] ret_sql = [string] [EOL] [EOL] inv_sql = [string] [EOL] [EOL] normalizer = Normalizer ( [string] , [string] ) [EOL] assert normalizer . transform ( num_cols ) == ret_sql [EOL] assert normalizer . invert_transform ( num_cols ) == inv_sql [EOL] [EOL] [EOL] def test_normalize_log1p ( num_cols ) : [EOL] ret_sql = [string] [EOL] [EOL] inv_sql = [string] [EOL] [EOL] normalizer = Normalizer ( [string] ) [EOL] assert normalizer . transform ( num_cols ) == ret_sql [EOL] assert normalizer . invert_transform ( num_cols ) == inv_sql [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] import molehill [EOL] from molehill . preprocessing . vectorization import vectorize [EOL] [EOL] [EOL] @ pytest . fixture ( ) def num_cols ( ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def cat_cols ( ) : [EOL] return [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_vectorize ( num_cols , cat_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , [string] ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_without_cols ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] vectorize ( [string] , [string] ) [EOL] [EOL] [EOL] def test_vectorize_with_num_cols ( num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , numerical_columns = num_cols ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_with_cat_cols ( cat_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] assert vectorize ( [string] , [string] , categorical_columns = cat_cols ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_with_bias ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , bias = True ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_with_hashing ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , hashing = True ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_with_hashing_cardinality ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , hashing = True , feature_cardinality = [number] ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_with_bias_hashing ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , bias = True , hashing = True ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_with_emit_null ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , emit_null = True ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_with_force_value ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , force_value = True ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_with_emit_null_force_value ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , emit_null = True , force_value = True ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_dense ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , dense = True ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_dense_with_hashing ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , dense = True , hashing = True ) == ret_sql [EOL] [EOL] [EOL] def test_vectorize_dense_with_hashing_cardinality ( cat_cols , num_cols ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert vectorize ( [string] , [string] , cat_cols , num_cols , dense = True , hashing = True , feature_cardinality = [number] ) == ret_sql [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import molehill [EOL] from molehill . preprocessing import shuffle , train_test_split [EOL] [EOL] [EOL] def test_shuffle ( ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert shuffle ( [ [string] , [string] ] , [string] , [string] , [string] ) == ret_sql [EOL] [EOL] [EOL] def test_stratified_shuffle ( ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert shuffle ( [ [string] , [string] ] , [string] , [string] , [string] , stratify = True ) == ret_sql [EOL] [EOL] [EOL] def test_train_test_split ( ) : [EOL] train_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] test_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] gen_train , gen_test = train_test_split ( [string] , [number] ) [EOL] assert gen_train == train_sql [EOL] assert gen_test == test_sql [EOL] [EOL] [EOL] def test_train_test_split_stratify ( ) : [EOL] train_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] test_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] gen_train , gen_test = train_test_split ( [string] , [number] , stratify = True ) [EOL] assert gen_train == train_sql [EOL] assert gen_test == test_sql [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import molehill [EOL] from molehill . preprocessing import downsampling_rate [EOL] [EOL] [EOL] def test_downsampling_rate ( ) : [EOL] ret_sql = f""" [string] { molehill . __version__ } [string] """ [EOL] [EOL] assert downsampling_rate ( [string] , [string] ) == ret_sql [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import molehill [EOL] import pytest [EOL] from molehill . preprocessing . impute import Imputer [EOL] [EOL] [EOL] @ pytest . fixture ( ) def num_cols ( ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def cat_cols ( ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] [EOL] def test_numeric_imputer ( num_cols ) : [EOL] ret_sql = [string] [EOL] [EOL] numeric_imputer = Imputer ( [string] , [string] ) [EOL] assert numeric_imputer . transform ( num_cols ) == ret_sql [EOL] [EOL] [EOL] def test_categorical_imputer ( cat_cols ) : [EOL] ret_sql = [string] [EOL] [EOL] categorical_imputer = Imputer ( [string] , [string] , [string] , categorical = True ) [EOL] assert categorical_imputer . transform ( cat_cols ) == ret_sql [EOL] [EOL] [EOL] def test_numeric_imputer_without_phase ( num_cols ) : [EOL] ret_sql = [string] [EOL] [EOL] numeric_imputer = Imputer ( [string] , None ) [EOL] assert numeric_imputer . transform ( num_cols ) == ret_sql [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any , List , Union [EOL] import builtins [EOL] import typing [EOL] import textwrap [EOL] from typing import Union , List [EOL] from . utils import build_query [EOL] [EOL] [EOL] [comment] [EOL] KNOWN_METRICS = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] } [EOL] [comment] [EOL] EXTENDED_METRICS = { [string] , [string] , [string] , [string] } [EOL] PROBABILITY_REQUIRE_METRICS = { [string] , [string] } [EOL] [EOL] [EOL] def _build_evaluate_clause ( metrics , scoring_template , inv_template , predicted_column , target_column ) : [EOL] [EOL] true_positive = f" [string] { predicted_column } [string] { target_column } [string] { target_column } [string] " [EOL] _results = [ ] [EOL] for _metric in metrics : [EOL] if _metric == [string] : [EOL] _results . append ( inv_template . format_map ( { [string] : _metric , [string] : predicted_column , [string] : target_column , [string] : [string] } ) ) [EOL] elif _metric == [string] : [EOL] _results . append ( inv_template . format_map ( { [string] : _metric , [string] : predicted_column , [string] : target_column , [string] : [string] } ) ) [EOL] elif _metric in PROBABILITY_REQUIRE_METRICS : [EOL] _results . append ( scoring_template . format_map ( { [string] : _metric , [string] : [string] , [string] : target_column } ) ) [EOL] elif _metric == [string] : [EOL] _results . append ( f" [string] { true_positive } [string] " ) [EOL] [comment] [EOL] elif _metric == [string] : [EOL] _results . append ( f" [string] { true_positive } [string] { predicted_column } [string] " ) [EOL] elif _metric == [string] : [EOL] _results . append ( f" [string] { true_positive } [string] { target_column } [string] " ) [EOL] else : [EOL] _results . append ( scoring_template . format_map ( { [string] : _metric , [string] : predicted_column , [string] : target_column } ) ) [EOL] [EOL] return _results [EOL] [EOL] [EOL] def evaluate ( metrics , target_column , predicted_column , target_table = [string] , prediction_table = [string] , id_column = [string] ) : [EOL] [docstring] [EOL] [EOL] _metrics = [ metrics ] if isinstance ( metrics , str ) else metrics [EOL] _metrics = [ metric . lower ( ) for metric in metrics ] [EOL] [EOL] if len ( set ( _metrics ) - KNOWN_METRICS - EXTENDED_METRICS ) > [number] : [EOL] unknown_metrics = [ s for s in metrics if s not in KNOWN_METRICS ] [EOL] [EOL] raise ValueError ( [string] . format ( [string] . join ( unknown_metrics ) ) ) [EOL] [EOL] has_auc = [string] in _metrics [EOL] [EOL] if has_auc : [EOL] scoring_template = [string] [EOL] inv_template = [string] [EOL] [EOL] evaluations = _build_evaluate_clause ( _metrics , scoring_template , inv_template , predicted_column , target_column ) [EOL] [EOL] select_clause = f" [string] { predicted_column } [string] { target_column }" [EOL] [EOL] cond = textwrap . dedent ( [string] . format_map ( { [string] : target_table , [string] : id_column } ) ) [EOL] [EOL] return build_query ( evaluations , [string] . format ( textwrap . indent ( build_query ( [ select_clause ] , f"{ prediction_table } [string] " , cond , without_semicolon = True ) , [string] ) ) ) [EOL] [EOL] else : [EOL] scoring_template = [string] [EOL] inv_template = [string] [EOL] [EOL] [comment] [EOL] evaluations = _build_evaluate_clause ( _metrics , scoring_template , inv_template , predicted_column , target_column ) [EOL] [EOL] cond = textwrap . dedent ( f""" [string] { target_table } [string] { id_column } [string] { id_column } [string] """ ) [EOL] [EOL] return build_query ( evaluations , f"{ prediction_table } [string] " , cond ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import OrderedDict , Any , List , Optional [EOL] import collections [EOL] import builtins [EOL] import typing [EOL] import textwrap [EOL] import molehill [EOL] from collections import OrderedDict [EOL] from typing import List , Optional [EOL] [EOL] [EOL] def build_query ( select_clauses , source , condition = None , without_semicolon = False , with_clauses = None ) : [EOL] [docstring] [EOL] [EOL] if not isinstance ( select_clauses , list ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] query = [string] [EOL] [EOL] [comment] [EOL] if not without_semicolon : [EOL] query += f" [string] { molehill . __version__ } [string] " [EOL] [EOL] if not with_clauses : [EOL] with_clauses = OrderedDict ( ) [EOL] [EOL] _with_clauses = [ ] [EOL] [EOL] for k , v in with_clauses . items ( ) : [EOL] tmp = f""" [string] { k } [string] { textwrap . indent ( v , [string] ) } [string] """ [EOL] _with_clauses . append ( tmp ) [EOL] [EOL] if len ( with_clauses ) > [number] : [EOL] query += [string] . format ( _with = [string] . join ( _with_clauses ) ) [EOL] [EOL] query += [string] [EOL] _query = [string] [EOL] _query += [string] . join ( select_clauses ) [EOL] query += textwrap . indent ( _query , [string] ) [EOL] [EOL] query += f""" [string] { textwrap . indent ( source , [string] ) }""" [EOL] [EOL] if condition : [EOL] query += f" [string] { condition }" [EOL] [EOL] if not without_semicolon or not len ( with_clauses ) == [number] : [EOL] query += [string] [EOL] [EOL] return query [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import textwrap [EOL] import itertools [EOL] from typing import List [EOL] from . utils import build_query [EOL] [EOL] [EOL] def compute_stats ( source , numerical_columns ) : [EOL] numerical_template = textwrap . dedent ( [string] ) [EOL] [EOL] _query = [string] [EOL] _query += [string] . join ( numerical_template . format_map ( { [string] : column } ) for column in numerical_columns ) [EOL] [EOL] return build_query ( [ _query ] , source ) [EOL] [EOL] [EOL] def combine_train_test_stats ( source , numerical_columns ) : [EOL] numerical_template = textwrap . dedent ( [string] ) [EOL] [EOL] _query = [string] [EOL] _query += [string] . join ( numerical_template . format_map ( { [string] : column , [string] : phase , [string] : f" [string] { phase }" if phase != [string] else [string] } ) for column , phase in itertools . product ( numerical_columns , [ [string] , [string] , [string] ] ) ) [EOL] [EOL] _source = f"{ source } [string] { source } [string] { source } [string] " [EOL] return build_query ( [ _query ] , _source ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0