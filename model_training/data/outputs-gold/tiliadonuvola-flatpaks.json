[comment] [EOL] [EOL] from typing import List , Any , Iterable [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] from os . path import join [EOL] from typing import List , Iterable [EOL] [EOL] AUTO_MODULE_TEMPLATE = [string] [EOL] [EOL] [EOL] def list_modules ( root_dir , packages ) : [EOL] [docstring] [EOL] modules = [ ] [EOL] for package in packages : [EOL] for root , _dirs , files in os . walk ( join ( root_dir , package ) ) : [EOL] for file in files : [EOL] if file == [string] : [EOL] path = root [EOL] elif file . endswith ( [string] ) : [EOL] path = join ( root , file [ : - [number] ] ) [EOL] else : [EOL] continue [EOL] modules . append ( path [ len ( root_dir ) + [number] : ] . replace ( [string] , [string] ) ) [EOL] modules . sort ( ) [EOL] return modules [EOL] [EOL] [EOL] def generate_auto_doc ( modules ) : [EOL] [docstring] [EOL] output = [ ] [EOL] prev_module = None [EOL] for module in reversed ( modules ) : [EOL] if module . endswith ( [string] ) or [string] in module : [EOL] continue [EOL] if prev_module and prev_module . startswith ( module + [string] ) : [EOL] heading = f' [string] { module } [string] ' [EOL] else : [EOL] heading = f' [string] { module } [string] ' [EOL] output . append ( AUTO_MODULE_TEMPLATE . format ( module = module ) ) [EOL] output . append ( ( [string] if [string] in module else [string] ) * ( len ( heading ) - [number] ) ) [EOL] output . append ( heading ) [EOL] prev_module = module [EOL] output . reverse ( ) [EOL] return [string] . join ( output ) [EOL] [EOL] [EOL] def main ( root , packages ) : [EOL] [docstring] [EOL] [EOL] modules = list_modules ( root , packages ) [EOL] output = generate_auto_doc ( modules ) [EOL] print ( output ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import clizy [EOL] clizy . run ( main ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] import nufb [EOL] import pathlib [EOL] [docstring] [EOL] from pathlib import Path [EOL] [EOL] from nufb . wrappers import Manifest [EOL] [EOL] [EOL] [comment] [EOL] class Task : [EOL] [docstring] [EOL] manifest = ... [EOL] name = ... [EOL] resources_dir = ... [EOL] build_root = ... [EOL] build_dir = ... [EOL] result_dir = ... [EOL] global_state_dir = ... [EOL] working_state_dir = ... [EOL] manifest_json = ... [EOL] [EOL] def __init__ ( self , build_root , resources_dir , manifest ) : [EOL] self . resources_dir = resources_dir [EOL] self . manifest = manifest [EOL] self . name = f'{ manifest . id } [string] { manifest . branch }' [EOL] self . build_root = build_root [EOL] self . build_dir = build_root / self . name [EOL] self . result_dir = self . build_dir / [string] [EOL] self . global_state_dir = build_root / [string] [EOL] self . working_state_dir = self . build_dir / [string] [EOL] self . manifest_json = self . build_dir / ( self . name + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $nufb.wrappers.Manifest$ 0 $nufb.wrappers.Manifest$ 0 0 0 $builtins.str$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 $builtins.str$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Union , List [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] [EOL] LOGGING_CONFIG = dict ( version = [number] , disable_existing_loggers = False , formatters = { [string] : { [string] : [string] , [string] : [string] , } , } , handlers = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , } , loggers = { [string] : { [string] : [ [string] ] , [string] : [string] , [string] : True , } , } ) [EOL] [EOL] [EOL] def get_logger ( name ) : [EOL] [docstring] [EOL] return logging . getLogger ( name ) [EOL] [EOL] [EOL] def set_up_logging ( ) : [EOL] [docstring] [EOL] from logging . config import dictConfig [EOL] dictConfig ( LOGGING_CONFIG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] __version__ = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Dict , Any , Optional [EOL] import nufb [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Optional , List [EOL] [EOL] [EOL] [comment] [EOL] class Helper : [EOL] [docstring] [EOL] def __init__ ( self , name , * , command = None , sources = None , install = None , stage = None , keep = None , remove = None , ) : [EOL] [EOL] def expand ( s ) : [EOL] return s . replace ( [string] , name ) [EOL] if command : [EOL] command = expand ( command ) [EOL] for lst in install , stage , keep , remove : [EOL] if lst : [EOL] lst [ : ] = ( expand ( s ) for s in lst ) [EOL] if sources : [EOL] for item in sources : [EOL] try : [EOL] item [ [string] ] = expand ( item [ [string] ] ) [EOL] except KeyError : [EOL] pass [EOL] [EOL] self . name = name [EOL] self . command = command [EOL] self . sources = sources [EOL] self . install = install [EOL] self . stage = stage [EOL] self . keep = keep [EOL] self . remove = remove [EOL] [EOL] [EOL] NO_RUBBISH_SCRIPT = Helper ( [string] , command = [string] , sources = [ { [string] : [string] , [string] : [string] } ] , install = [ [string] ] , keep = [ [string] ] , remove = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 0 0 0 0 $typing.Optional[typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 $typing.Optional[typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $nufb.helpers.Helper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import nufb [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import json [EOL] import os [EOL] import subprocess [EOL] from shutil import rmtree [EOL] [EOL] from nufb import utils [EOL] from nufb . task import Task [EOL] [EOL] [EOL] class Builder : [EOL] [docstring] [EOL] task = ... [EOL] [EOL] def __init__ ( self , task ) : [EOL] self . task = task [EOL] [EOL] def build ( self , keep_build_dirs = False , delete_build_dirs = False ) : [EOL] [docstring] [EOL] [comment] [EOL] clean_up = delete_build_dirs [EOL] try : [EOL] self . set_up ( ) [EOL] self . copy_resources ( ) [EOL] self . build_flatpak ( keep_build_dirs = keep_build_dirs , delete_build_dirs = delete_build_dirs ) [EOL] [comment] [EOL] clean_up = not keep_build_dirs [EOL] finally : [EOL] if clean_up : [EOL] self . clean_up ( ) [EOL] [EOL] def set_up ( self ) : [EOL] [docstring] [EOL] try : [EOL] rmtree ( self . task . build_dir ) [EOL] except FileNotFoundError : [EOL] pass [EOL] self . task . build_dir . mkdir ( parents = True ) [EOL] [EOL] def copy_resources ( self ) : [EOL] [docstring] [EOL] for module in self . task . manifest . modules : [EOL] for source in module . sources : [EOL] if isinstance ( source , str ) : [EOL] path = source [EOL] elif source [ [string] ] in ( [string] , [string] , [string] ) : [EOL] path = source . get ( [string] ) [EOL] else : [EOL] continue [EOL] [EOL] if not path or os . path . isabs ( path ) : [EOL] continue [EOL] [EOL] source_path = self . task . resources_dir / path [EOL] destination_path = self . task . build_dir / path [EOL] try : [EOL] destination_path . unlink ( ) [EOL] except FileNotFoundError : [EOL] pass [EOL] destination_path . parent . mkdir ( parents = True , exist_ok = True ) [EOL] utils . hardlink_or_copy ( source_path , destination_path ) [EOL] [EOL] def build_flatpak ( self , disable_cache = False , require_changes = True , keep_build_dirs = False , delete_build_dirs = False , ) : [EOL] [docstring] [EOL] with self . task . manifest_json . open ( [string] ) as fh : [EOL] json . dump ( self . task . manifest . data , fh , indent = [number] ) [EOL] [EOL] work_dir = self . task . build_dir [EOL] [EOL] [comment] [EOL] [comment] [EOL] global_state = self . task . global_state_dir [EOL] global_state . mkdir ( exist_ok = True ) [EOL] local_state = self . task . working_state_dir [EOL] local_state . mkdir ( exist_ok = True ) [EOL] for symlink in [string] , [string] , [string] , [string] , [string] : [EOL] target = global_state / symlink [EOL] target . mkdir ( exist_ok = True ) [EOL] ( local_state / symlink ) . symlink_to ( target ) [EOL] [EOL] argv = [ [string] , [string] , [string] ] [EOL] if disable_cache : [EOL] argv . append ( [string] ) [EOL] if require_changes : [EOL] argv . append ( [string] ) [EOL] if keep_build_dirs : [EOL] argv . append ( [string] ) [EOL] if delete_build_dirs : [EOL] argv . append ( [string] ) [EOL] [EOL] argv . extend ( [ str ( self . task . result_dir . relative_to ( work_dir ) ) , str ( self . task . manifest_json . relative_to ( work_dir ) ) ] ) [EOL] [EOL] print ( argv ) [EOL] subprocess . run ( argv , cwd = str ( work_dir ) , check = True ) [EOL] [EOL] def clean_up ( self ) : [EOL] [docstring] [EOL] try : [EOL] rmtree ( self . task . build_dir ) [EOL] except FileNotFoundError : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nufb.task.Task$ 0 0 0 0 0 0 0 0 0 $nufb.task.Task$ 0 0 0 0 0 $nufb.task.Task$ 0 $nufb.task.Task$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import nufb [EOL] import logging [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] [EOL] from nufb import utils , log [EOL] from nufb . builder import Builder [EOL] from nufb . task import Task [EOL] from nufb . wrappers import Manifest [EOL] [EOL] L = log . get_logger ( __name__ ) [EOL] [EOL] [EOL] def build ( build_root , resources_dir , manifests_dir , manifest_id , branch , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] L . debug ( [string] , build_root , resources_dir , manifests_dir , manifest_id , branch ) [EOL] [EOL] data = utils . load_yaml ( manifests_dir / branch / ( manifest_id + [string] ) ) [EOL] manifest = Manifest ( data ) [EOL] task = Task ( build_root , resources_dir , manifest ) [EOL] builder = Builder ( task ) [EOL] builder . build ( ** kwargs ) [EOL] [EOL] [EOL] def buildcdk ( branch , * , keep_build_dirs = False , delete_build_dirs = False ) : [EOL] [docstring] [EOL] build ( utils . get_user_cache_dir ( [string] ) , Path . cwd ( ) / [string] , Path . cwd ( ) / [string] , [string] , branch , keep_build_dirs = keep_build_dirs , delete_build_dirs = delete_build_dirs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Union , Any , List [EOL] import os [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] import os [EOL] from os . path import expanduser [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] from nufb import utils [EOL] [EOL] KEY = [string] [EOL] DEFAULT = [string] [EOL] [EOL] [EOL] class TestExpectType : [EOL] [docstring] [EOL] [EOL] def test_none ( self ) : [EOL] [docstring] [EOL] with pytest . raises ( TypeError , match = [string] ) : [EOL] utils . expect_type ( None , int ) [EOL] [EOL] def test_wrong_type ( self ) : [EOL] [docstring] [EOL] with pytest . raises ( TypeError , match = [string] ) : [EOL] utils . expect_type ( [string] , int ) [EOL] [EOL] def test_correct_type ( self ) : [EOL] [docstring] [EOL] value = [string] [EOL] result = utils . expect_type ( value , str ) [EOL] assert id ( value ) == id ( result ) [EOL] [EOL] [EOL] class TestEnsureList : [EOL] [docstring] [EOL] [EOL] def test_missing_key ( self ) : [EOL] [docstring] [EOL] dictionary = { } [EOL] result = utils . ensure_list ( dictionary , KEY ) [EOL] assert result == [ ] [EOL] assert id ( dictionary [ KEY ] ) == id ( result ) [EOL] assert id ( utils . ensure_list ( dictionary , KEY ) ) == id ( result ) [EOL] [EOL] def test_empty_list ( self ) : [EOL] [docstring] [EOL] empty = [ ] [EOL] dictionary = { KEY : empty } [EOL] result = utils . ensure_list ( dictionary , KEY ) [EOL] assert id ( result ) == id ( empty ) [EOL] assert result == [ ] [EOL] assert id ( utils . ensure_list ( dictionary , KEY ) ) == id ( empty ) [EOL] [EOL] def test_non_empty_list ( self ) : [EOL] [docstring] [EOL] not_empty = [ [string] ] [EOL] dictionary = { KEY : not_empty } [EOL] result = utils . ensure_list ( dictionary , KEY ) [EOL] assert id ( result ) == id ( not_empty ) [EOL] assert result == [ [string] ] [EOL] assert id ( utils . ensure_list ( dictionary , KEY ) ) == id ( not_empty ) [EOL] [EOL] def test_wrong_type ( self ) : [EOL] [docstring] [EOL] dictionary = { KEY : [string] } [EOL] with pytest . raises ( TypeError ) : [EOL] utils . ensure_list ( dictionary , KEY ) [EOL] [EOL] [EOL] class TestEnsureString : [EOL] [docstring] [EOL] [EOL] def test_missing_key_without_default ( self ) : [EOL] [docstring] [EOL] dictionary = { } [EOL] with pytest . raises ( TypeError ) : [EOL] utils . ensure_string ( dictionary , KEY ) [EOL] assert KEY not in dictionary [EOL] [EOL] def test_missing_key_with_default ( self ) : [EOL] [docstring] [EOL] dictionary = { } [EOL] result = utils . ensure_string ( dictionary , KEY , DEFAULT ) [EOL] assert id ( dictionary [ KEY ] ) == id ( result ) == id ( DEFAULT ) [EOL] assert id ( utils . ensure_string ( dictionary , KEY ) ) == id ( result ) [EOL] [EOL] def test_empty_string ( self ) : [EOL] [docstring] [EOL] empty = [string] [EOL] dictionary = { KEY : empty } [EOL] result = utils . ensure_string ( dictionary , KEY , DEFAULT ) [EOL] assert id ( result ) == id ( empty ) [EOL] assert id ( utils . ensure_string ( dictionary , KEY ) ) == id ( empty ) [EOL] [EOL] def test_non_empty_string ( self ) : [EOL] [docstring] [EOL] not_empty = [string] [EOL] dictionary = { KEY : not_empty } [EOL] result = utils . ensure_string ( dictionary , KEY , DEFAULT ) [EOL] assert id ( result ) == id ( not_empty ) [EOL] assert result == [string] [EOL] assert id ( utils . ensure_string ( dictionary , KEY ) ) == id ( not_empty ) [EOL] [EOL] def test_wrong_type ( self ) : [EOL] [docstring] [EOL] dictionary = { KEY : [ [string] ] } [EOL] with pytest . raises ( TypeError ) : [EOL] utils . ensure_string ( dictionary , KEY ) [EOL] [EOL] [EOL] class TestLoadYaml : [EOL] [docstring] [EOL] [EOL] def test_load_string ( self ) : [EOL] [docstring] [EOL] result = utils . load_yaml ( [string] ) [EOL] assert result == { [string] : [string] , [string] : [string] } [EOL] [EOL] def test_load_file ( self , data_dir ) : [EOL] [docstring] [EOL] path = data_dir / [string] [EOL] result = utils . load_yaml ( path ) [EOL] assert result == { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] class TestAddUnique : [EOL] [docstring] [EOL] [EOL] def test_string ( self ) : [EOL] [docstring] [EOL] value1 = [string] [EOL] value2 = [string] [EOL] value3 = [string] [EOL] lst = [ ] [EOL] [EOL] assert utils . add_unique ( lst , value1 ) [EOL] assert lst == [ value1 ] [EOL] assert not utils . add_unique ( lst , value2 ) [EOL] assert lst == [ value1 ] [EOL] assert utils . add_unique ( lst , value3 ) [EOL] assert lst == [ value1 , value3 ] [EOL] [EOL] def test_dict ( self ) : [EOL] [docstring] [EOL] value1 = { [string] : [string] } [EOL] value2 = { [string] : [string] } [EOL] value3 = { [string] : [string] , [string] : [number] } [EOL] lst = [ ] [EOL] [EOL] assert utils . add_unique ( lst , value1 ) [EOL] assert lst == [ value1 ] [EOL] assert not utils . add_unique ( lst , value2 ) [EOL] assert lst == [ value1 ] [EOL] assert utils . add_unique ( lst , value3 ) [EOL] assert lst == [ value1 , value3 ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , expanduser ( [string] ) , expanduser ( [string] ) ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ] ) def test_get_user_cache_dir ( xdg_variable , without_subdir , with_subdir ) : [EOL] [docstring] [EOL] environ = os . environ [EOL] try : [EOL] os . environ = { [string] : xdg_variable } if xdg_variable else { } [EOL] assert utils . get_user_cache_dir ( ) == Path ( without_subdir ) [EOL] assert utils . get_user_cache_dir ( [string] ) == Path ( with_subdir ) [EOL] finally : [EOL] os . environ = environ [EOL] [EOL] [EOL] def test_subclasses ( ) : [EOL] [docstring] [EOL] [EOL] class ClassA : [EOL] [docstring] [EOL] [EOL] class ClassB ( ClassA ) : [EOL] [docstring] [EOL] [EOL] class ClassC ( ClassA ) : [EOL] [docstring] [EOL] [EOL] class ClassD ( ClassB ) : [EOL] [docstring] [EOL] [EOL] class ClassE ( ClassD ) : [EOL] [docstring] [EOL] [EOL] assert tuple ( utils . subclasses ( ClassA ) ) == ( ClassB , ClassD , ClassE , ClassC ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , List , Optional [EOL] import nufb [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from nufb import wrappers [EOL] [EOL] [EOL] [comment] [EOL] class TestManifest : [EOL] [docstring] [EOL] [EOL] def test_construct_no_data ( self ) : [EOL] [docstring] [EOL] manifest = wrappers . Manifest ( ) [EOL] assert manifest . data == { } [EOL] [EOL] def test_construct_empty_data ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] manifest = wrappers . Manifest ( data ) [EOL] assert manifest . data == { } [EOL] assert id ( manifest . data ) == id ( data ) [EOL] [EOL] def test_id_field_present ( self ) : [EOL] [docstring] [EOL] app_id = [string] [EOL] assert id ( wrappers . Manifest ( { [string] : app_id } ) . id ) == id ( app_id ) [EOL] assert id ( wrappers . Manifest ( { [string] : app_id } ) . id ) == id ( app_id ) [EOL] [EOL] def test_duplicate_id_field ( self ) : [EOL] [docstring] [EOL] data = { [string] : [string] , [string] : [string] } [EOL] with pytest . raises ( ValueError ) : [EOL] wrappers . Manifest ( data ) [EOL] [EOL] def test_id_field_missing ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] with pytest . raises ( TypeError ) : [EOL] _ = wrappers . Manifest ( data ) . id [comment] [EOL] [EOL] def test_id_field_invalid ( self ) : [EOL] [docstring] [EOL] data = { [string] : [number] } [EOL] with pytest . raises ( TypeError ) : [EOL] _ = wrappers . Manifest ( data ) . id [comment] [EOL] [EOL] def test_set_id_field ( self ) : [EOL] [docstring] [EOL] data = { [string] : [string] } [EOL] manifest = wrappers . Manifest ( data ) [EOL] my_id = [string] [EOL] manifest . id = my_id [EOL] assert data [ [string] ] == manifest . id == my_id [EOL] assert [string] not in data [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] manifest . id = [number] [EOL] assert data [ [string] ] == manifest . id == my_id [EOL] [EOL] def test_branch_field_missing ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] assert wrappers . Manifest ( data ) . branch == [string] [EOL] [EOL] def test_branch_field_invalid ( self ) : [EOL] [docstring] [EOL] data = { [string] : [number] } [EOL] with pytest . raises ( TypeError ) : [EOL] _ = wrappers . Manifest ( data ) . branch [comment] [EOL] [EOL] def test_branch_field_valid ( self ) : [EOL] [docstring] [EOL] data = { [string] : [string] } [EOL] assert wrappers . Manifest ( data ) . branch == [string] [EOL] [EOL] def test_set_branch_field ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] manifest = wrappers . Manifest ( data ) [EOL] branch = [string] [EOL] manifest . branch = branch [EOL] assert data [ [string] ] == manifest . branch == branch [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] manifest . branch = [number] [EOL] assert data [ [string] ] == manifest . branch == branch [EOL] [EOL] def test_raw_modules_no_data ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] manifest = wrappers . Manifest ( data ) [EOL] assert manifest . raw_modules == [ ] [EOL] assert id ( manifest . raw_modules ) == id ( data [ [string] ] ) [EOL] [EOL] def test_raw_modules_empty ( self ) : [EOL] [docstring] [EOL] modules = [ ] [EOL] data = { [string] : modules } [EOL] manifest = wrappers . Manifest ( data ) [EOL] assert manifest . raw_modules == modules == [ ] [EOL] assert id ( manifest . raw_modules ) == id ( data [ [string] ] ) == id ( modules ) [EOL] [EOL] def test_raw_modules_not_empty ( self ) : [EOL] [docstring] [EOL] module = { [string] : None } [EOL] modules = [ module ] [EOL] data = { [string] : modules } [EOL] manifest = wrappers . Manifest ( data ) [EOL] assert manifest . raw_modules == modules == [ module ] [EOL] assert id ( manifest . raw_modules ) == id ( data [ [string] ] ) == id ( modules ) [EOL] [EOL] def test_modules_no_data ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] manifest = wrappers . Manifest ( data ) [EOL] assert manifest . modules == [ ] [EOL] assert id ( manifest . modules ) != id ( data [ [string] ] ) [EOL] [EOL] def test_modules_empty ( self ) : [EOL] [docstring] [EOL] modules = [ ] [EOL] data = { [string] : modules } [EOL] manifest = wrappers . Manifest ( data ) [EOL] assert manifest . modules == [ ] [EOL] assert id ( manifest . modules ) != id ( modules ) [EOL] [EOL] def test_modules_not_empty ( self ) : [EOL] [docstring] [EOL] module = { [string] : [string] } [EOL] modules = [ module ] [EOL] data = { [string] : modules } [EOL] manifest = wrappers . Manifest ( data ) [EOL] assert manifest . modules != [ module ] [EOL] assert id ( manifest . modules ) != id ( data [ [string] ] ) [EOL] assert manifest . modules [ [number] ] . data == module [EOL] assert id ( manifest . modules [ [number] ] . data ) == id ( module ) [EOL] [EOL] def test_str_no_data ( self ) : [EOL] [docstring] [EOL] assert str ( wrappers . Manifest ( ) ) == [string] [EOL] [EOL] def test_str_invalid_id_and_branch ( self ) : [EOL] [docstring] [EOL] data = { [string] : [number] , [string] : [number] } [EOL] assert str ( wrappers . Manifest ( data ) ) == [string] [EOL] [EOL] def test_str_valid_id_and_branch ( self ) : [EOL] [docstring] [EOL] data = { [string] : [string] , [string] : [string] } [EOL] assert str ( wrappers . Manifest ( data ) ) == [string] [EOL] [EOL] def test_add_module ( self ) : [EOL] [docstring] [EOL] module = wrappers . Module ( ) [EOL] [EOL] manifest = wrappers . Manifest ( ) [EOL] manifest . add_module ( module , - [number] ) [EOL] assert len ( manifest . modules ) == [number] [EOL] assert manifest . modules [ [number] ] == module [EOL] [EOL] manifest = wrappers . Manifest ( ) [EOL] assert not manifest . modules [EOL] manifest . add_module ( module ) [EOL] assert len ( manifest . modules ) == [number] [EOL] assert manifest . modules [ [number] ] == module [EOL] [EOL] modules = [ { } , { } , { } , { } ] [EOL] data = { [string] : modules } [EOL] manifest = wrappers . Manifest ( data ) [EOL] manifest . add_module ( module , [number] ) [EOL] assert len ( manifest . modules ) == [number] [EOL] assert manifest . modules [ [number] ] == module [EOL] manifest . add_module ( module , - [number] ) [EOL] assert len ( manifest . modules ) == [number] [EOL] assert manifest . modules [ [number] ] == module [EOL] manifest . add_module ( module ) [EOL] assert len ( manifest . modules ) == [number] [EOL] assert manifest . modules [ [number] ] == module [EOL] [EOL] def test_find_module ( self ) : [EOL] [docstring] [EOL] name = [string] [EOL] module = { [string] : name } [EOL] data = { [string] : [ module ] } [EOL] assert wrappers . Manifest ( ) . find_module ( name ) is None [EOL] assert id ( wrappers . Manifest ( data ) . find_module ( name ) . data ) == id ( module ) [EOL] [EOL] def test_init_module ( self ) : [EOL] [docstring] [EOL] assert wrappers . Manifest ( ) . init_module . name == [string] [EOL] [EOL] module = { [string] : [string] } [EOL] data = { [string] : [ module ] } [EOL] assert id ( wrappers . Manifest ( data ) . init_module . data ) == id ( module ) [EOL] assert module == { [string] : [string] , [string] : [string] , [string] : [ ] } [EOL] [EOL] module = { [string] : [string] , [string] : [string] } [EOL] data = { [string] : [ module ] } [EOL] assert wrappers . Manifest ( data ) . init_module . data == { [string] : [string] , [string] : [string] , [string] : [ ] } [EOL] [EOL] def test_finish_module ( self ) : [EOL] [docstring] [EOL] assert wrappers . Manifest ( ) . finish_module . name == [string] [EOL] [EOL] module = { [string] : [string] } [EOL] data = { [string] : [ module ] } [EOL] assert id ( wrappers . Manifest ( data ) . finish_module . data ) == id ( module ) [EOL] assert module == { [string] : [string] , [string] : [string] , [string] : [ ] } [EOL] [EOL] module = { [string] : [string] , [string] : [string] } [EOL] data = { [string] : [ module ] } [EOL] assert wrappers . Manifest ( data ) . finish_module . data == { [string] : [string] , [string] : [string] , [string] : [ ] } [EOL] [EOL] def test_hooks_field ( self ) : [EOL] [docstring] [EOL] assert wrappers . Manifest ( ) . hooks == [ ] [EOL] [EOL] empty = [ ] [EOL] data = { [string] : empty } [EOL] manifest = wrappers . Manifest ( data ) [EOL] assert manifest . hooks == [ ] [EOL] assert id ( manifest . hooks ) == id ( empty ) [EOL] [EOL] hooks = [ [string] ] [EOL] data = { [string] : hooks } [EOL] manifest = wrappers . Manifest ( data ) [EOL] assert manifest . hooks == [ [string] ] [EOL] assert id ( manifest . hooks ) == id ( hooks ) [EOL] del manifest . hooks [EOL] assert [string] not in data [EOL] [EOL] [EOL] class TestModule : [EOL] [docstring] [EOL] def test_construct ( self ) : [EOL] [docstring] [EOL] assert wrappers . Module ( ) . data == { } [EOL] data = { } [EOL] assert id ( wrappers . Module ( data ) . data ) == id ( data ) [EOL] [EOL] def test_new ( self ) : [EOL] [docstring] [EOL] name = [string] [EOL] module = wrappers . Module . new ( name , size = [number] ) [EOL] assert module . name == name [EOL] assert module . data [ [string] ] == [number] [EOL] [EOL] def test_name_field ( self ) : [EOL] [docstring] [EOL] module = wrappers . Module ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] _ = module . name [comment] [EOL] [EOL] name = [string] [EOL] module . name = name [EOL] assert module . name == name [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] module . name = [number] [EOL] assert module . name == name [EOL] [EOL] def test_build_system_field ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] module = wrappers . Module ( data ) [EOL] assert module . build_system is None [EOL] module . build_system = [string] [EOL] assert module . build_system == data [ [string] ] == [string] [EOL] with pytest . raises ( ValueError ) : [EOL] module . build_system = [string] [EOL] assert module . build_system == [string] [EOL] [EOL] module = wrappers . Module ( { [string] : [string] } ) [EOL] with pytest . raises ( ValueError ) : [EOL] __ = module . build_system [comment] [EOL] module . build_system = [string] [EOL] assert module . build_system == [string] [EOL] [EOL] module = wrappers . Module ( { [string] : [string] } ) [EOL] assert module . build_system == [string] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , None , [ { [string] : [string] } ] ) , ( [string] , None , [ { [string] : [string] } ] ) , ( [string] , None , [ [string] ] ) , ( [string] , None , [ [string] ] ) , ( [string] , [string] , [ [string] ] ) , ( [string] , [string] , [ [string] ] ) , ] ) def test_fields_of_type_list ( self , field , key , values ) : [EOL] [docstring] [EOL] if not key : [EOL] key = field . replace ( [string] , [string] ) [EOL] [EOL] assert getattr ( wrappers . Module ( ) , field ) == [ ] [EOL] [EOL] empty = [ ] [EOL] data = { key : empty } [EOL] module = wrappers . Module ( data ) [EOL] result = getattr ( module , field ) [EOL] assert result == [ ] [EOL] assert id ( result ) == id ( empty ) [EOL] [EOL] data = { key : values } [EOL] original_values = values [ : ] [EOL] module = wrappers . Module ( data ) [EOL] result = getattr ( module , field ) [EOL] assert result == original_values [EOL] assert id ( result ) == id ( values ) [EOL] [EOL] data = { key : [number] } [EOL] with pytest . raises ( TypeError ) : [EOL] getattr ( wrappers . Module ( data ) , field ) [EOL] [EOL] def test_str ( self ) : [EOL] [docstring] [EOL] assert str ( wrappers . Module ( ) ) == [string] [EOL] assert str ( wrappers . Module ( { [string] : [number] } ) ) == [string] [EOL] assert str ( wrappers . Module ( { [string] : [string] } ) ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $nufb.wrappers.Manifest$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $nufb.wrappers.Manifest$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $nufb.wrappers.Manifest$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.str$ 0 0 0 $nufb.wrappers.Manifest$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $nufb.wrappers.Manifest$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $nufb.wrappers.Manifest$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,None]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,None]]$ 0 0 $typing.List[typing.Dict[builtins.str,None]]$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,None]]]$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,None]]$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,None]]]$ 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 $typing.List[typing.Dict[builtins.str,None]]$ 0 0 $typing.List[typing.Dict[builtins.str,None]]$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,None]]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $nufb.wrappers.Manifest$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[typing.Any,typing.Any]]]$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $nufb.wrappers.Manifest$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $nufb.wrappers.Manifest$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $nufb.wrappers.Manifest$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $nufb.wrappers.Module$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $nufb.wrappers.Module$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $nufb.wrappers.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $nufb.wrappers.Module$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $nufb.wrappers.Module$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $nufb.wrappers.Module$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Module$ 0 $builtins.str$ 0 0 0 0 $nufb.wrappers.Module$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $nufb.wrappers.Module$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $nufb.wrappers.Module$ 0 $typing.Optional[builtins.str]$ 0 0 0 $nufb.wrappers.Module$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $nufb.wrappers.Module$ 0 $typing.Optional[builtins.str]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Module$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $nufb.wrappers.Module$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $nufb.wrappers.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $nufb.wrappers.Module$ 0 $typing.Optional[builtins.str]$ 0 0 $nufb.wrappers.Module$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $nufb.wrappers.Module$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $nufb.wrappers.Module$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Module$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.list$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.str$ 0 $builtins.list$ 0 0 $nufb.wrappers.Module$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 $nufb.wrappers.Module$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.list$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.str$ 0 $builtins.list$ 0 0 $typing.List[typing.Any]$ 0 $builtins.list$ 0 0 0 0 $nufb.wrappers.Module$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 $nufb.wrappers.Module$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.list$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Optional [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] from typing import Optional [EOL] [EOL] [EOL] def make_file ( path , content = None ) : [EOL] [docstring] [EOL] path . parent . mkdir ( parents = True , exist_ok = True ) [EOL] path . write_text ( str ( path . name ) if content is None else content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import nufb [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] from nufb . wrappers import Manifest [EOL] [EOL] [EOL] @ pytest . fixture def data_dir ( ) : [EOL] [docstring] [EOL] return Path ( __file__ ) . parent / [string] [EOL] [EOL] [EOL] @ pytest . fixture def manifest ( ) : [EOL] [docstring] [EOL] return Manifest ( { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nufb.wrappers.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] MANIFEST_JSON = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0