from typing import Any , Dict , Type , Optional [EOL] import beeminder_sync [EOL] import halo [EOL] import configparser [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] [docstring] [EOL] [EOL] from configparser import ConfigParser [EOL] import os [EOL] import pathlib [EOL] import shutil [EOL] import sys [EOL] from typing import Dict , Optional [EOL] [EOL] import click [EOL] from halo import Halo [EOL] [EOL] from . config import read_config , verify_config , write_config [EOL] [EOL] [EOL] class BeeSync : [EOL] [docstring] [EOL] _config_template_path = pathlib . Path ( __file__ ) . parent / [string] [EOL] [EOL] def __init__ ( self , base_dir , config_path , spinner = True ) : [EOL] self . _spinner = Halo ( text = [string] , color = [string] , spinner = [string] , enabled = spinner ) [EOL] self . _spinner . start ( ) [EOL] self . base_dir = pathlib . Path ( base_dir ) [EOL] if not self . base_dir . is_dir ( ) : [EOL] self . _spinner . text = [string] [EOL] os . mkdir ( self . base_dir ) [EOL] [comment] [EOL] if config_path : [EOL] config_file = pathlib . Path ( config_path ) [EOL] else : [EOL] config_file = self . base_dir / [string] [EOL] if not config_file . exists ( ) : [EOL] new_config_path = self . base_dir / [string] [EOL] self . _spinner . fail ( [string] ) [EOL] answer = click . confirm ( f" [string] { new_config_path } [string] " , default = False , abort = True ) [EOL] if answer : [EOL] self . _spinner . text = [string] [EOL] self . _create_config ( new_config_path ) [EOL] self . _spinner . succeed ( [string] ) [EOL] sys . exit ( ) [EOL] if self . _verify_config ( config_file ) : [EOL] self . _spinner . fail ( [string] ) [EOL] self . config_path = config_file [EOL] self . config = self . _read_replace_config ( ) [EOL] self . _spinner . succeed ( text = [string] ) [EOL] [EOL] def _create_config ( self , config_path ) : [EOL] [docstring] [EOL] shutil . copy ( self . _config_template_path , config_path ) [EOL] os . chmod ( config_path , [number] ) [EOL] [EOL] def _verify_config ( self , config_path ) : [EOL] [docstring] [EOL] validity = False [EOL] if config_path . is_file ( ) : [EOL] if verify_config ( config_path ) : [EOL] validity = True [EOL] else : [EOL] self . _spinner . fail ( f" [string] { config_path } [string] " ) [EOL] return validity [EOL] [EOL] def _read_replace_config ( self ) : [EOL] [docstring] [EOL] base_config = self . base_dir / [string] [EOL] if base_config != self . config_path and base_config . exists ( ) : [EOL] answer = click . confirm ( [string] , default = False , abort = True , ) [EOL] if answer : [EOL] shutil . copy ( base_config , self . base_dir / [string] ) [EOL] shutil . copy ( self . config_path , base_config ) [EOL] os . chmod ( base_config , [number] ) [EOL] elif base_config != self . config_path : [EOL] shutil . copy ( self . config_path , base_config ) [EOL] os . chmod ( base_config , [number] ) [EOL] return read_config ( base_config ) [EOL] [EOL] def update ( self , section , option , value , silent = False ) : [EOL] [docstring] [EOL] if not silent : [EOL] self . _spinner . color = [string] [EOL] self . _spinner . text = [string] [EOL] self . _spinner . start ( ) [EOL] if section in self . config . sections ( ) and option in self . config . options ( section ) : [EOL] if not silent : [EOL] self . _spinner . info ( [string] ) [EOL] self . config . set ( section , option , value = value ) [EOL] write_config ( self . config_path , self . config ) [EOL] if not silent : [EOL] self . _spinner . succeed ( text = [string] ) [EOL] return self . config . get ( section , option ) [EOL] [EOL] def get ( self , section , option , silent = False ) : [EOL] [docstring] [EOL] if not silent : [EOL] self . _spinner . color = [string] [EOL] self . _spinner . text = [string] [EOL] self . _spinner . start ( ) [EOL] if section in self . config . sections ( ) and option in self . config . options ( section ) : [EOL] val = self . config . get ( section , option ) [EOL] if not silent : [EOL] self . _spinner . succeed ( text = f"{ section } [string] { option } [string] { val }" ) [EOL] return val [EOL] else : [EOL] self . _spinner . fail ( [string] ) [EOL] click . secho ( [string] ) [EOL] for section in self . config . sections ( ) : [EOL] click . secho ( f" [string] { section } [string] { self . config . options ( section ) }" ) [EOL] [EOL] def set_spinner ( self , settings ) : [EOL] [docstring] [EOL] for key in settings : [EOL] if key in [ [string] , [string] , [string] ] : [EOL] setattr ( self . _spinner , key , settings [ key ] ) [EOL] else : [EOL] raise KeyError ( [string] ) [EOL] return self . _spinner [EOL] [EOL] def fail ( self , text ) : [EOL] [docstring] [EOL] self . _spinner . fail ( text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $halo.Halo$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any , Dict , List , Union [EOL] import typing [EOL] import beeminder_sync [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] [EOL] import click [EOL] [EOL] from . import BeeSync , BASE_DIR [EOL] from . beeminder import Beeminder [EOL] [EOL] [EOL] @ click . group ( ) @ click . option ( [string] , [string] , default = str ( BASE_DIR ) , type = click . Path ( ) , help = [string] ) @ click . option ( [string] , [string] , default = None , type = click . Path ( ) , help = [string] ) @ click . pass_context def cli ( ctx , basedir , config ) : [EOL] [docstring] [EOL] ctx . obj [ [string] ] = BeeSync ( basedir , config ) [EOL] return None [EOL] [EOL] [EOL] @ cli . command ( ) @ click . option ( [string] , [string] , help = [string] ) @ click . option ( [string] , [string] , help = [string] ) @ click . argument ( [string] , default = [string] ) @ click . pass_context def config ( ctx , section , option , value ) : [EOL] [docstring] [EOL] beesync = ctx . obj [ [string] ] [EOL] if value : [EOL] conf_val = beesync . update ( section , option , value ) [EOL] else : [EOL] conf_val = beesync . get ( section , option ) [EOL] return conf_val [EOL] [EOL] [EOL] @ cli . command ( ) @ click . option ( [string] , [string] , default = None , help = [string] ) @ click . option ( [string] , [string] , default = None , help = [string] ) @ click . option ( [string] , [string] , default = None , type = click . INT , help = [string] ) @ click . option ( [string] , [string] , default = [string] , help = [string] ) @ click . option ( [string] , [string] , default = None , help = [string] ) @ click . option ( [string] , [string] , default = None , help = [string] ) @ click . option ( [string] , [string] , default = [string] , help = [string] ) @ click . pass_context def beeminder ( ctx , method , goal , value , comment , timestamp , query , output ) : [EOL] [docstring] [EOL] beesync = ctx . obj [ [string] ] [EOL] bee = Beeminder . from_config ( beesync ) [EOL] if not method : [EOL] response = bee . user_details [EOL] elif not goal : [EOL] response = { [string] : bee . goals } [EOL] elif method == [string] : [EOL] response = bee . get_datapoints ( goal ) [EOL] elif method == [string] : [EOL] if timestamp : [EOL] response = bee . create_datapoint ( goal , value , comment , timestamp ) [EOL] else : [EOL] response = bee . create_datapoint ( goal , value , comment ) [EOL] else : [EOL] bee . fail ( f" [string] { method } [string] " ) [EOL] if query : [EOL] queried_response = bee . query ( response , query ) [EOL] else : [EOL] queried_response = response [EOL] click . secho ( [string] + [string] * [number] + [string] + [string] * [number] , fg = [string] , bold = True ) [EOL] click . secho ( bee . output ( queried_response , output ) ) [EOL] return [number] [EOL] [EOL] [EOL] def main ( ) : [EOL] cli ( obj = { } ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL] __version__ = [string] [EOL] [EOL] import pathlib [EOL] import os [EOL] [EOL] import click [EOL] [EOL] from . beeminder_sync import BeeSync [EOL] [EOL] [EOL] BEESYNC_DIR = pathlib . Path ( click . get_app_dir ( [string] ) ) [EOL] ENV_PATH = os . environ . get ( [string] ) [EOL] BASE_DIR = pathlib . Path ( ENV_PATH ) if ENV_PATH else BEESYNC_DIR [EOL] if not BASE_DIR . exists ( ) : [EOL] BASE_DIR . mkdir ( parents = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] [EOL] [EOL] import logging [EOL] import pathlib [EOL] import os [EOL] [EOL] from . import BASE_DIR [EOL] [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] handler = logging . FileHandler ( BASE_DIR / [string] ) [EOL] formatter = logging . Formatter ( [string] ) [EOL] handler . setFormatter ( formatter ) [EOL] log . addHandler ( handler ) [EOL] log . setLevel ( logging . DEBUG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.FileHandler$ 0 0 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 $logging.FileHandler$ 0 0 0 $logging.Formatter$ 0 0 $logging.Logger$ 0 0 0 $logging.FileHandler$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
from . manage import read_config , verify_config , write_config [EOL]	0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import builtins [EOL] import configparser [EOL] import pathlib [EOL] import typing [EOL] [docstring] [EOL] [EOL] from configparser import ConfigParser [EOL] import pathlib [EOL] [EOL] [EOL] REQ_SECTIONS = [ [string] , [string] ] [EOL] REQ_OPTIONS = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] ] } [EOL] [EOL] [EOL] def read_config ( config_path ) : [EOL] [docstring] [EOL] config = ConfigParser ( ) [EOL] with open ( config_path , [string] ) as fid : [EOL] config . read_file ( fid ) [EOL] return config [EOL] [EOL] [EOL] def verify_config ( config_path ) : [EOL] [docstring] [EOL] config = ConfigParser ( ) [EOL] try : [EOL] with open ( config_path , [string] ) as fid : [EOL] config . read_file ( fid ) [EOL] if any ( not config . has_section ( section ) for section in REQ_SECTIONS ) : [EOL] return False [EOL] for section in REQ_OPTIONS : [EOL] for option in REQ_OPTIONS [ [string] ] : [EOL] if not config . has_option ( section , option ) : [EOL] return False [EOL] return True [EOL] except : [EOL] return False [EOL] [EOL] [EOL] def write_config ( config_path , config ) : [EOL] [docstring] [EOL] with open ( config_path , [string] ) as fid : [EOL] config . write ( fid ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . beeminder import Beeminder [EOL]	0 0 0 0 0 0
from typing import Dict , Optional , Any , List , Union [EOL] import beeminder_sync [EOL] import halo [EOL] import requests [EOL] import builtins [EOL] import furl [EOL] import typing [EOL] [docstring] [EOL] [EOL] import maya [EOL] import sys [EOL] from typing import Any , Dict , List , Union [EOL] import requests [EOL] [EOL] from furl import furl [EOL] from halo import Halo [EOL] [EOL] from beeminder_sync . logger import log [EOL] from . . beeminder_sync import BeeSync [EOL] from . . query import query [EOL] from . . output import output [EOL] [EOL] [EOL] class Beeminder : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , base_url , user_name , auth_token , spinner = True ) : [EOL] self . _spinner = Halo ( text = [string] , color = [string] , spinner = [string] , enabled = spinner ) [EOL] self . _spinner . start ( ) [EOL] self . _base_url = base_url [EOL] self . _user_name = user_name [EOL] self . _auth_token = auth_token [EOL] self . goals = self . _get_goals ( ) [EOL] return None [EOL] [EOL] def _url_maker ( self , endpoint ) : [EOL] [docstring] [EOL] url = furl ( self . _base_url ) [EOL] if endpoint == [string] : [EOL] url . add ( path = f" [string] { self . _user_name } [string] " ) [EOL] elif endpoint in [ [string] , [string] ] : [EOL] url . add ( path = f" [string] { self . _user_name } [string] " ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] url . add ( args = { [string] : self . _auth_token } ) [EOL] return url [EOL] [EOL] @ property def user_details ( self ) : [EOL] [docstring] [EOL] data = { i : self . _user_resource [ i ] for i in [ [string] , [string] , [string] , [string] , [string] ] } [EOL] return { [string] : data } [EOL] [EOL] [comment] [EOL] def _get_goals ( self ) : [EOL] [docstring] [EOL] self . _spinner . text = [string] [EOL] self . _spinner . start ( ) [EOL] user_url = self . _url_maker ( [string] ) [EOL] response = requests . get ( user_url ) [EOL] log . info ( f" [string] { user_url }" ) [EOL] response . raise_for_status ( ) [EOL] log . info ( [string] ) [EOL] response_data = response . json ( ) [EOL] self . _user_resource = response_data [EOL] self . _spinner . succeed ( [string] ) [EOL] return response_data [ [string] ] [EOL] [EOL] def __getitem__ ( self , goal ) : [EOL] [docstring] [EOL] if goal not in self . goals : [EOL] raise KeyError ( f"{ goal } [string] " ) [EOL] goal_url = self . _url_maker ( [string] ) [EOL] goal_url . add ( path = f"{ goal } [string] " ) [EOL] response = requests . get ( goal_url ) [EOL] log . info ( f" [string] { goal_url }" ) [EOL] response . raise_for_status ( ) [EOL] log . info ( f" [string] { goal }" ) [EOL] return { [string] : response . json ( ) } [EOL] [EOL] def get_datapoints ( self , goal ) : [EOL] [docstring] [EOL] self . _spinner . text = [string] [EOL] self . _spinner . start ( ) [EOL] data_url = self . _url_maker ( [string] ) [EOL] data_url . add ( path = f"{ goal } [string] " ) [EOL] response = requests . get ( data_url ) [EOL] log . info ( f" [string] { data_url }" ) [EOL] try : [EOL] response . raise_for_status ( ) [EOL] except requests . HTTPError : [EOL] raise ValueError ( f" [string] { goal } [string] { self . goals }" ) [EOL] log . info ( f" [string] { goal }" ) [EOL] self . _spinner . succeed ( f" [string] { goal } [string] " ) [EOL] return { [string] : response . json ( ) } [EOL] [EOL] def create_datapoint ( self , goal , value , comment = [string] , timestamp = maya . now ( ) . epoch ) : [EOL] [docstring] [EOL] self . _spinner . text = [string] [EOL] self . _spinner . start ( ) [EOL] data_url = self . _url_maker ( [string] ) [EOL] data_url . add ( path = f"{ goal } [string] " ) [EOL] if isinstance ( timestamp , str ) : [EOL] try : [EOL] timestamp = maya . parse ( timestamp ) . epoch [EOL] except : [EOL] self . _spinner . fail ( f" [string] { timestamp }" ) [EOL] sys . exit ( ) [EOL] data_url . add ( args = { [string] : value , [string] : timestamp , [string] : comment } ) [EOL] response = requests . post ( data_url ) [EOL] log . info ( f" [string] { data_url }" ) [EOL] response . raise_for_status ( ) [EOL] log . info ( f" [string] { goal }" ) [EOL] self . _spinner . succeed ( [string] ) [EOL] return { [string] : response . json ( ) } [EOL] [EOL] @ classmethod def from_config ( cls , beesync ) : [EOL] [docstring] [EOL] base_url = beesync . get ( [string] , [string] , silent = True ) [EOL] user_name = beesync . get ( [string] , [string] , silent = True ) [EOL] auth_token = beesync . get ( [string] , [string] , silent = True ) [EOL] return cls ( base_url , user_name , auth_token ) [EOL] [EOL] def set_spinner ( self , settings ) : [EOL] [docstring] [EOL] for key in settings : [EOL] if key in [ [string] , [string] , [string] ] : [EOL] setattr ( self . _spinner , key , settings [ key ] ) [EOL] else : [EOL] raise KeyError ( [string] ) [EOL] return self . _spinner [EOL] [EOL] def fail ( self , text ) : [EOL] [docstring] [EOL] self . _spinner . fail ( text ) [EOL] [EOL] @ staticmethod def query ( response , query_string ) : [EOL] [docstring] [EOL] return query ( response , query_string ) [EOL] [EOL] @ staticmethod def output ( response , format ) : [EOL] [docstring] [EOL] return output ( response , format ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Beeminder"$ 0 0 0 $beeminder_sync.BeeSync$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $halo.Halo$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.str$ 0 0
[docstring] [EOL]	0 0
	0
from . query import query [EOL]	0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import pyjq [EOL] [EOL] [EOL] def query ( response , query_string ) : [EOL] [docstring] [EOL] key = query_string . split ( [string] ) [ [number] ] . strip ( ) . split ( [string] ) [ [number] ] . strip ( [string] ) [EOL] result = pyjq . all ( query_string , response ) [EOL] if len ( result ) == [number] and isinstance ( result [ [number] ] , list ) : [EOL] result = result [ [number] ] [EOL] return { key : result } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . output import output [EOL]	0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import json [EOL] [EOL] [EOL] def json_output ( response ) : [EOL] [docstring] [EOL] return json . dumps ( response , indent = [number] , sort_keys = True ) [EOL] [EOL] [EOL] def table_output ( response ) : [EOL] [docstring] [EOL] [comment] [EOL] width = [number] [EOL] [comment] [EOL] header = list ( response . keys ( ) ) [ [number] ] [EOL] rows = list ( response [ header ] ) [EOL] [comment] [EOL] cols = list ( rows [ [number] ] . keys ( ) ) [EOL] table = [ [string] * width ] [EOL] table . append ( [string] . format ( content = header , width = width - [number] ) ) [EOL] table . append ( [string] * width ) [EOL] col_width = width // len ( cols ) [EOL] col_headers = [ ] [EOL] for col in cols : [EOL] col_headers . append ( [string] . format ( content = col , width = col_width - [number] ) ) [EOL] table . append ( [string] . join ( col_headers ) ) [EOL] table . append ( [string] * width ) [EOL] for row in rows : [EOL] row_data = [ [string] ] * len ( row ) [EOL] for key , value in row . items ( ) : [EOL] ind = cols . index ( key ) [EOL] if value is None : [EOL] value = [string] [EOL] row_data [ ind ] = [string] . format ( content = value , width = col_width - [number] ) [EOL] table . append ( [string] . join ( row_data ) ) [EOL] return [string] . join ( table ) [EOL] [EOL] [EOL] def output ( response , format = [string] ) : [EOL] [docstring] [EOL] if format == [string] : [EOL] return json_output ( response ) [EOL] if format == [string] : [EOL] return table_output ( response ) [EOL] raise ValueError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import beeminder_sync [EOL] [docstring] [EOL] [EOL] [EOL] import pytest [EOL] [EOL] from beeminder_sync import BeeSync [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) class TestBeeminderSync : [EOL] [docstring] [EOL] [EOL] def test_init ( self , config_paths ) : [EOL] bee_sync = BeeSync ( * config_paths , spinner = False ) [EOL] assert bee_sync . base_dir == config_paths [ [number] ] [EOL] assert bee_sync . config_path == config_paths [ [number] ] [EOL] assert [string] in bee_sync . config . sections ( ) [EOL] options = bee_sync . config . options ( [string] ) [EOL] assert all ( x in options for x in [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_update_get ( self , config_paths ) : [EOL] bee_sync = BeeSync ( * config_paths , spinner = False ) [EOL] bee_sync . update ( [string] , [string] , [string] ) [EOL] assert bee_sync . get ( [string] , [string] ) == [string] [EOL] bee_sync . update ( [string] , [string] , [string] ) [EOL] assert bee_sync . get ( [string] , [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0 0 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 $typing.Any$ 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0 0 $beeminder_sync.beeminder_sync.BeeSync$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import click [EOL] import typing [EOL] [docstring] [EOL] [EOL] from click . testing import CliRunner [EOL] import pytest [EOL] [EOL] from beeminder_sync import cli [EOL] [EOL] [EOL] def test_cli_config ( tmpdir ) : [EOL] [docstring] [EOL] base_dir = tmpdir . mkdir ( [string] ) [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli . cli , [ [string] , base_dir , [string] , [string] , [string] , [string] , [string] ] , input = [string] , obj = { } ) [EOL] if result . exit_code == [number] : [EOL] result = runner . invoke ( cli . cli , [ [string] , base_dir , [string] , [string] , [string] , [string] , [string] ] , input = [string] , obj = { } ) [EOL] assert result . exit_code == [number] [EOL] [comment] [EOL] [EOL] [EOL] def test_main_cli ( ) : [EOL] [docstring] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli . cli ) [EOL] assert result . exit_code == [number] [EOL] assert [string] in result . output [EOL] help_result = runner . invoke ( cli . cli , [ [string] ] ) [EOL] assert help_result . exit_code == [number] [EOL] assert [string] in help_result . output [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import beeminder_sync [EOL] import requests [EOL] import configparser [EOL] import pathlib [EOL] import typing [EOL] [docstring] [EOL] [EOL] from configparser import ConfigParser [EOL] import pathlib [EOL] import requests [EOL] import shutil [EOL] [EOL] import pytest [EOL] [EOL] from beeminder_sync . beeminder import Beeminder [EOL] from beeminder_sync import BeeSync [EOL] [EOL] [EOL] BASE_DIR = pathlib . Path . cwd ( ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . fixture ( scope = [string] ) def config_paths ( tmpdir_factory ) : [EOL] [docstring] [EOL] base_factory = tmpdir_factory . mktemp ( [string] ) [EOL] base_path = pathlib . Path ( str ( base_factory ) ) [EOL] config_path = base_path / [string] [EOL] shutil . copy ( BeeSync . _config_template_path , config_path ) [EOL] return base_path , config_path [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def config ( ) : [EOL] [docstring] [EOL] fpath = BASE_DIR / [string] [EOL] config = ConfigParser ( ) [EOL] with open ( fpath , [string] ) as fid : [EOL] config . read_file ( fid ) [EOL] return config [EOL] [EOL] [EOL] @ pytest . fixture def beeminder_config ( config ) : [EOL] [docstring] [EOL] assert [string] in config . keys ( ) [EOL] data = dict ( config [ [string] ] ) [EOL] data [ [string] ] = [ [string] , [string] , [string] ] [EOL] return data [EOL] [EOL] [EOL] @ pytest . fixture def beeminder_interface ( beeminder_config ) : [EOL] [docstring] [EOL] base_url = beeminder_config [ [string] ] [EOL] username = beeminder_config [ [string] ] [EOL] auth_token = beeminder_config [ [string] ] [EOL] interface = Beeminder ( base_url , username , auth_token , spinner = False ) [EOL] return interface [EOL] [EOL] [EOL] @ pytest . fixture def github_json ( ) : [EOL] [docstring] [EOL] url = [string] [EOL] response = requests . get ( url ) [EOL] return response . json ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import requests [EOL] import typing [EOL] import beeminder_sync [EOL] [docstring] [EOL] [EOL] import random [EOL] import requests [EOL] [EOL] import pytest [EOL] from furl import furl [EOL] [EOL] from beeminder_sync . beeminder import Beeminder [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) class TestBeeminderApi : [EOL] [docstring] [EOL] [EOL] def test_config ( self , beeminder_config ) : [EOL] [docstring] [EOL] for req_field in beeminder_config [ [string] ] : [EOL] assert req_field in beeminder_config . keys ( ) , [string] [EOL] assert beeminder_config [ req_field ] , [string] [EOL] [EOL] def test_credentials ( self , beeminder_config ) : [EOL] [docstring] [EOL] base_url = beeminder_config [ [string] ] [EOL] username = beeminder_config [ [string] ] [EOL] auth_token = beeminder_config [ [string] ] [EOL] user_url = furl ( base_url ) [EOL] user_url . add ( path = f" [string] { username } [string] " ) [EOL] user_url . add ( args = { [string] : auth_token } ) [EOL] response = requests . get ( user_url ) [EOL] assert response . status_code != [number] [EOL] response_data = response . json ( ) [EOL] assert response_data [ [string] ] == username [EOL] [EOL] def test_interface ( self , beeminder_config ) : [EOL] [docstring] [EOL] base_url = beeminder_config [ [string] ] [EOL] username = beeminder_config [ [string] ] [EOL] auth_token = beeminder_config [ [string] ] [EOL] Beeminder ( base_url , username , auth_token , spinner = False ) [EOL] with pytest . raises ( requests . exceptions . HTTPError ) : [EOL] Beeminder ( base_url , [string] , [string] , spinner = False ) [EOL] [EOL] def test_getitem ( self , beeminder_config ) : [EOL] [docstring] [EOL] base_url = beeminder_config [ [string] ] [EOL] username = beeminder_config [ [string] ] [EOL] auth_token = beeminder_config [ [string] ] [EOL] interface = Beeminder ( base_url , username , auth_token , spinner = False ) [EOL] goal = random . choice ( interface . goals ) [EOL] goal_data = interface [ goal ] [EOL] assert goal_data [ [string] ] [ [string] ] == goal [EOL] [EOL] def test_get_datapoints ( self , beeminder_interface ) : [EOL] goal = random . choice ( beeminder_interface . goals ) [EOL] datapoints = beeminder_interface . get_datapoints ( goal ) [EOL] assert len ( datapoints ) >= [number] [EOL] [EOL] def test_create_datapoint ( self , beeminder_interface ) : [EOL] goal = random . choice ( beeminder_interface . goals ) [EOL] dpt1 = ( beeminder_interface . create_datapoint ( goal , [number] , comment = [string] ) ) [EOL] assert dpt1 [ [string] ] [ [string] ] == [string] [EOL] dpt1 [ [string] ] . pop ( [string] , None ) [EOL] actual_dpts = beeminder_interface . get_datapoints ( goal ) [EOL] assert dpt1 [ [string] ] == actual_dpts [ [string] ] [ [number] ] [EOL] dpt2 = ( beeminder_interface . create_datapoint ( goal , - [number] , comment = [string] ) ) [EOL] assert dpt2 [ [string] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $beeminder_sync.beeminder.beeminder.Beeminder$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $beeminder_sync.beeminder.beeminder.Beeminder$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $beeminder_sync.beeminder.beeminder.Beeminder$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pytest [EOL] [EOL] from beeminder_sync . query import query [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) class TestQuery : [EOL] [docstring] [EOL] [EOL] def test_query ( self , github_json ) : [EOL] query_string1 = [string] [EOL] data1 = query ( github_json , query_string1 ) [EOL] assert isinstance ( data1 [ [string] ] , list ) [EOL] assert len ( data1 ) == [number] [EOL] query_string2 = [string] [EOL] data2 = query ( github_json , query_string2 ) [EOL] assert isinstance ( data2 [ [string] ] , list ) [EOL] assert len ( data2 [ [string] ] ) > [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0