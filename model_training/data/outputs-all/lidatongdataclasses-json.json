import argparse [EOL] import argparse [EOL] import re [EOL] import subprocess [EOL] [EOL] version_pattern = [string] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] if not re . match ( version_pattern , args . version ) : [EOL] print ( [string] ) [EOL] else : [EOL] with open ( [string] ) as fp : [EOL] old_setupfile = fp . read ( ) [EOL] new_setupfile = re . sub ( f" [string] { version_pattern } [string] " , f" [string] { args . version } [string] " , old_setupfile ) [EOL] with open ( [string] , [string] ) as fp : [EOL] print ( new_setupfile , file = fp ) [EOL] [EOL] subprocess . run ( [ [string] , [string] + args . version ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0
from setuptools import setup , find_packages [EOL] [EOL] with open ( [string] , [string] , encoding = [string] ) as f : [EOL] readme = f . read ( ) [EOL] [EOL] setup ( name = [string] , version = [string] , packages = find_packages ( exclude = ( [string] , ) ) , package_data = { [string] : [ [string] ] } , author = [string] , author_email = [string] , description = [string] , long_description = readme , long_description_content_type = [string] , url = [string] , license = [string] , keywords = [string] , install_requires = [ [string] , [string] , [string] , [string] , [string] ] , python_requires = [string] , extras_require = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] } , include_package_data = True , scripts = [ [string] ] ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , Optional , Callable , Any , List , Type , Union , Dict , Tuple [EOL] import builtins [EOL] import typing [EOL] import dataclasses_json [EOL] import abc [EOL] import json [EOL] from enum import Enum [EOL] from typing import ( Any , Callable , Dict , List , Optional , Tuple , Type , TypeVar , Union ) [EOL] [EOL] from stringcase import ( camelcase , pascalcase , snakecase , spinalcase ) [comment] [EOL] [EOL] from dataclasses_json . cfg import config [EOL] from dataclasses_json . core import ( Json , _ExtendedEncoder , _asdict , _decode_dataclass ) [EOL] from dataclasses_json . mm import ( JsonData , SchemaType , build_schema ) [EOL] from dataclasses_json . undefined import Undefined [EOL] from dataclasses_json . utils import ( _handle_undefined_parameters_safe , _undefined_parameter_action_safe ) [EOL] [EOL] A = TypeVar ( [string] , bound = [string] ) [EOL] B = TypeVar ( [string] ) [EOL] C = TypeVar ( [string] ) [EOL] Fields = List [ Tuple [ str , Any ] ] [EOL] [EOL] [EOL] class LetterCase ( Enum ) : [EOL] CAMEL = camelcase [EOL] KEBAB = spinalcase [EOL] SNAKE = snakecase [EOL] PASCAL = pascalcase [EOL] [EOL] [EOL] class DataClassJsonMixin ( abc . ABC ) : [EOL] [docstring] [EOL] dataclass_json_config = None [EOL] [EOL] def to_json ( self , * , skipkeys = False , ensure_ascii = True , check_circular = True , allow_nan = True , indent = None , separators = None , default = None , sort_keys = False , ** kw ) : [EOL] return json . dumps ( self . to_dict ( encode_json = False ) , cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw ) [EOL] [EOL] @ classmethod def from_json ( cls , s , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) : [EOL] kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) [EOL] return cls . from_dict ( kvs , infer_missing = infer_missing ) [EOL] [EOL] @ classmethod def from_dict ( cls , kvs , * , infer_missing = False ) : [EOL] return _decode_dataclass ( cls , kvs , infer_missing ) [EOL] [EOL] def to_dict ( self , encode_json = False ) : [EOL] return _asdict ( self , encode_json = encode_json ) [EOL] [EOL] @ classmethod def schema ( cls , * , infer_missing = False , only = None , exclude = ( ) , many = False , context = None , load_only = ( ) , dump_only = ( ) , partial = False , unknown = None ) : [EOL] Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) [EOL] [EOL] if unknown is None : [EOL] undefined_parameter_action = _undefined_parameter_action_safe ( cls ) [EOL] if undefined_parameter_action is not None : [EOL] [comment] [EOL] unknown = undefined_parameter_action . name . lower ( ) [EOL] [EOL] return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown ) [EOL] [EOL] [EOL] def dataclass_json ( _cls = None , * , letter_case = None , undefined = None ) : [EOL] [docstring] [EOL] [EOL] def wrap ( cls ) : [EOL] return _process_class ( cls , letter_case , undefined ) [EOL] [EOL] if _cls is None : [EOL] return wrap [EOL] return wrap ( _cls ) [EOL] [EOL] [EOL] def _process_class ( cls , letter_case , undefined ) : [EOL] if letter_case is not None or undefined is not None : [EOL] cls . dataclass_json_config = config ( letter_case = letter_case , undefined = undefined ) [ [string] ] [EOL] [EOL] cls . to_json = DataClassJsonMixin . to_json [EOL] [comment] [EOL] [comment] [EOL] cls . from_json = classmethod ( DataClassJsonMixin . from_json . __func__ ) [EOL] cls . to_dict = DataClassJsonMixin . to_dict [EOL] cls . from_dict = classmethod ( DataClassJsonMixin . from_dict . __func__ ) [EOL] cls . schema = classmethod ( DataClassJsonMixin . schema . __func__ ) [EOL] [EOL] cls . __init__ = _handle_undefined_parameters_safe ( cls , kvs = ( ) , usage = [string] ) [EOL] [comment] [EOL] DataClassJsonMixin . register ( cls ) [EOL] return cls [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 $typing.Callable$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.Optional[typing.Union[builtins.int,builtins.str]]$ 0 $typing.Optional[typing.Union[builtins.int,builtins.str]]$ 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $typing.Callable$ 0 $typing.Callable$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $A$ 0 $typing.Type[A]$ 0 $dataclasses_json.mm.JsonData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $dataclasses_json.mm.JsonData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[A]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $A$ 0 $typing.Type[A]$ 0 $dataclasses_json.core.Json$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[A]$ 0 $dataclasses_json.core.Json$ 0 0 0 0 0 0 $typing.Dict[builtins.str,dataclasses_json.core.Json]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dataclasses_json.mm.SchemaType$ 0 $typing.Type[A]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Type[dataclasses_json.mm.SchemaF[typing.Any]]$ 0 0 0 $typing.Type[A]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Type[A]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Type[dataclasses_json.mm.SchemaF[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , TypeVar , Optional [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import inspect [EOL] import sys [EOL] from datetime import datetime , timezone [EOL] from typing import Collection , Mapping , Optional , TypeVar , Any [EOL] [EOL] [EOL] def _get_type_cons ( type_ ) : [EOL] [docstring] [EOL] if sys . version_info . minor == [number] : [EOL] try : [EOL] cons = type_ . __extra__ [EOL] except AttributeError : [EOL] try : [EOL] cons = type_ . __origin__ [EOL] except AttributeError : [EOL] cons = type_ [EOL] else : [EOL] cons = type_ if cons is None else cons [EOL] else : [EOL] try : [EOL] cons = type_ . __origin__ if cons is None else cons [EOL] except AttributeError : [EOL] cons = type_ [EOL] else : [EOL] cons = type_ . __origin__ [EOL] return cons [EOL] [EOL] [EOL] def _get_type_origin ( type_ ) : [EOL] [docstring] [EOL] try : [EOL] origin = type_ . __origin__ [EOL] except AttributeError : [EOL] if sys . version_info . minor == [number] : [EOL] try : [EOL] origin = type_ . __extra__ [EOL] except AttributeError : [EOL] origin = type_ [EOL] else : [EOL] origin = type_ if origin is None else origin [EOL] else : [EOL] origin = type_ [EOL] return origin [EOL] [EOL] [EOL] def _hasargs ( type_ , * args ) : [EOL] try : [EOL] res = all ( arg in type_ . __args__ for arg in args ) [EOL] except AttributeError : [EOL] return False [EOL] else : [EOL] return res [EOL] [EOL] [EOL] def _isinstance_safe ( o , t ) : [EOL] try : [EOL] result = isinstance ( o , t ) [EOL] except Exception : [EOL] return False [EOL] else : [EOL] return result [EOL] [EOL] [EOL] def _issubclass_safe ( cls , classinfo ) : [EOL] try : [EOL] return issubclass ( cls , classinfo ) [EOL] except Exception : [EOL] return ( _is_new_type_subclass_safe ( cls , classinfo ) [EOL] if _is_new_type ( cls ) [EOL] else False ) [EOL] [EOL] [EOL] def _is_new_type_subclass_safe ( cls , classinfo ) : [EOL] super_type = getattr ( cls , [string] , None ) [EOL] [EOL] if super_type : [EOL] return _is_new_type_subclass_safe ( super_type , classinfo ) [EOL] [EOL] try : [EOL] return issubclass ( cls , classinfo ) [EOL] except Exception : [EOL] return False [EOL] [EOL] [EOL] def _is_new_type ( type_ ) : [EOL] return inspect . isfunction ( type_ ) and hasattr ( type_ , [string] ) [EOL] [EOL] [EOL] def _is_optional ( type_ ) : [EOL] return ( _issubclass_safe ( type_ , Optional ) or _hasargs ( type_ , type ( None ) ) or type_ is Any ) [EOL] [EOL] [EOL] def _is_mapping ( type_ ) : [EOL] return _issubclass_safe ( _get_type_origin ( type_ ) , Mapping ) [EOL] [EOL] [EOL] def _is_collection ( type_ ) : [EOL] return _issubclass_safe ( _get_type_origin ( type_ ) , Collection ) [EOL] [EOL] [EOL] def _is_nonstr_collection ( type_ ) : [EOL] return ( _issubclass_safe ( _get_type_origin ( type_ ) , Collection ) [EOL] and not _issubclass_safe ( type_ , str ) ) [EOL] [EOL] [EOL] def _timestamp_to_dt_aware ( timestamp ) : [EOL] tz = datetime . now ( timezone . utc ) . astimezone ( ) . tzinfo [EOL] dt = datetime . fromtimestamp ( timestamp , tz = tz ) [EOL] return dt [EOL] [EOL] [EOL] def _undefined_parameter_action_safe ( cls ) : [EOL] try : [EOL] if cls . dataclass_json_config is None : [EOL] return [EOL] action_enum = cls . dataclass_json_config [ [string] ] [EOL] except ( AttributeError , KeyError ) : [EOL] return [EOL] [EOL] if action_enum is None or action_enum . value is None : [EOL] return [EOL] [EOL] return action_enum [EOL] [EOL] [EOL] def _handle_undefined_parameters_safe ( cls , kvs , usage ) : [EOL] [docstring] [EOL] undefined_parameter_action = _undefined_parameter_action_safe ( cls ) [EOL] usage = usage . lower ( ) [EOL] if undefined_parameter_action is None : [EOL] return kvs if usage != [string] else cls . __init__ [EOL] if usage == [string] : [EOL] return undefined_parameter_action . value . handle_from_dict ( cls = cls , kvs = kvs ) [EOL] elif usage == [string] : [EOL] return undefined_parameter_action . value . handle_to_dict ( obj = cls , kvs = kvs ) [EOL] elif usage == [string] : [EOL] return undefined_parameter_action . value . handle_dump ( obj = cls ) [EOL] elif usage == [string] : [EOL] return undefined_parameter_action . value . create_init ( obj = cls ) [EOL] else : [EOL] raise ValueError ( f" [string] " f" [string] { usage } [string] " ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] CatchAllVar = TypeVar ( [string] , bound = Mapping ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , List , Type , Dict , Tuple [EOL] import builtins [EOL] import dataclasses [EOL] import typing [EOL] import inspect [EOL] import abc [EOL] import dataclasses [EOL] import functools [EOL] import inspect [EOL] from dataclasses import Field , fields [EOL] from typing import Any , Callable , Dict , Optional , Tuple [EOL] from enum import Enum [EOL] [EOL] from marshmallow import ValidationError [EOL] [EOL] from dataclasses_json . utils import CatchAllVar [EOL] [EOL] KnownParameters = Dict [ str , Any ] [EOL] UnknownParameters = Dict [ str , Any ] [EOL] [EOL] [EOL] class _UndefinedParameterAction ( abc . ABC ) : [EOL] @ staticmethod @ abc . abstractmethod def handle_from_dict ( cls , kvs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ staticmethod def handle_to_dict ( obj , kvs ) : [EOL] [docstring] [EOL] return kvs [EOL] [EOL] @ staticmethod def handle_dump ( obj ) : [EOL] [docstring] [EOL] return { } [EOL] [EOL] @ staticmethod def create_init ( obj ) : [EOL] return obj . __init__ [EOL] [EOL] @ staticmethod def _separate_defined_undefined_kvs ( cls , kvs ) : [EOL] [docstring] [EOL] class_fields = fields ( cls ) [EOL] field_names = [ field . name for field in class_fields ] [EOL] unknown_given_parameters = { k : v for k , v in kvs . items ( ) if k not in field_names } [EOL] known_given_parameters = { k : v for k , v in kvs . items ( ) if k in field_names } [EOL] return known_given_parameters , unknown_given_parameters [EOL] [EOL] [EOL] class _RaiseUndefinedParameters ( _UndefinedParameterAction ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def handle_from_dict ( cls , kvs ) : [EOL] known , unknown = _UndefinedParameterAction . _separate_defined_undefined_kvs ( cls = cls , kvs = kvs ) [EOL] if len ( unknown ) > [number] : [EOL] raise UndefinedParameterError ( f" [string] { unknown }" ) [EOL] return known [EOL] [EOL] [EOL] CatchAll = Optional [ CatchAllVar ] [EOL] [EOL] [EOL] class _IgnoreUndefinedParameters ( _UndefinedParameterAction ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def handle_from_dict ( cls , kvs ) : [EOL] known_given_parameters , _ = _UndefinedParameterAction . _separate_defined_undefined_kvs ( cls = cls , kvs = kvs ) [EOL] return known_given_parameters [EOL] [EOL] @ staticmethod def create_init ( obj ) : [EOL] original_init = obj . __init__ [EOL] init_signature = inspect . signature ( original_init ) [EOL] [EOL] @ functools . wraps ( obj . __init__ ) def _ignore_init ( self , * args , ** kwargs ) : [EOL] known_kwargs , _ = _CatchAllUndefinedParameters . _separate_defined_undefined_kvs ( obj , kwargs ) [EOL] num_params_takeable = len ( init_signature . parameters ) - [number] [comment] [EOL] num_args_takeable = num_params_takeable - len ( known_kwargs ) [EOL] [EOL] args = args [ : num_args_takeable ] [EOL] bound_parameters = init_signature . bind_partial ( self , * args , ** known_kwargs ) [EOL] bound_parameters . apply_defaults ( ) [EOL] [EOL] arguments = bound_parameters . arguments [EOL] arguments . pop ( [string] , None ) [EOL] final_parameters = _IgnoreUndefinedParameters . handle_from_dict ( obj , arguments ) [EOL] original_init ( self , ** final_parameters ) [EOL] [EOL] return _ignore_init [EOL] [EOL] [EOL] class _CatchAllUndefinedParameters ( _UndefinedParameterAction ) : [EOL] [docstring] [EOL] [EOL] class _SentinelNoDefault : [EOL] pass [EOL] [EOL] @ staticmethod def handle_from_dict ( cls , kvs ) : [EOL] known , unknown = _UndefinedParameterAction . _separate_defined_undefined_kvs ( cls = cls , kvs = kvs ) [EOL] catch_all_field = _CatchAllUndefinedParameters . _get_catch_all_field ( cls = cls ) [EOL] [EOL] if catch_all_field . name in known : [EOL] [EOL] already_parsed = isinstance ( known [ catch_all_field . name ] , dict ) [EOL] default_value = _CatchAllUndefinedParameters . _get_default ( catch_all_field = catch_all_field ) [EOL] received_default = default_value == known [ catch_all_field . name ] [EOL] [EOL] value_to_write = ... [EOL] if received_default and len ( unknown ) == [number] : [EOL] value_to_write = default_value [EOL] elif received_default and len ( unknown ) > [number] : [EOL] value_to_write = unknown [EOL] elif already_parsed : [EOL] [comment] [EOL] value_to_write = known [ catch_all_field . name ] [EOL] if len ( unknown ) > [number] : [EOL] value_to_write . update ( unknown ) [EOL] else : [EOL] error_message = f" [string] " f" [string] " f" [string] { catch_all_field . name } [string] " f" [string] { known [ catch_all_field . name ] } [string] " [EOL] raise UndefinedParameterError ( error_message ) [EOL] else : [EOL] value_to_write = unknown [EOL] [EOL] known [ catch_all_field . name ] = value_to_write [EOL] return known [EOL] [EOL] @ staticmethod def _get_default ( catch_all_field ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] has_default = not isinstance ( catch_all_field . default , dataclasses . _MISSING_TYPE ) [EOL] [comment] [EOL] has_default_factory = not isinstance ( catch_all_field . default_factory , dataclasses . _MISSING_TYPE ) [EOL] default_value = _CatchAllUndefinedParameters . _SentinelNoDefault [EOL] if has_default : [EOL] default_value = catch_all_field . default [EOL] elif has_default_factory : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] default_value = catch_all_field . default_factory ( ) [comment] [EOL] [EOL] return default_value [EOL] [EOL] @ staticmethod def handle_to_dict ( obj , kvs ) : [EOL] catch_all_field = _CatchAllUndefinedParameters . _get_catch_all_field ( obj ) [EOL] undefined_parameters = kvs . pop ( catch_all_field . name ) [EOL] if isinstance ( undefined_parameters , dict ) : [EOL] kvs . update ( undefined_parameters ) [comment] [EOL] return kvs [EOL] [EOL] @ staticmethod def handle_dump ( obj ) : [EOL] catch_all_field = _CatchAllUndefinedParameters . _get_catch_all_field ( cls = obj ) [EOL] return getattr ( obj , catch_all_field . name ) [EOL] [EOL] @ staticmethod def create_init ( obj ) : [EOL] original_init = obj . __init__ [EOL] init_signature = inspect . signature ( original_init ) [EOL] [EOL] @ functools . wraps ( obj . __init__ ) def _catch_all_init ( self , * args , ** kwargs ) : [EOL] known_kwargs , unknown_kwargs = _CatchAllUndefinedParameters . _separate_defined_undefined_kvs ( obj , kwargs ) [EOL] num_params_takeable = len ( init_signature . parameters ) - [number] [comment] [EOL] if _CatchAllUndefinedParameters . _get_catch_all_field ( obj ) . name not in known_kwargs : [EOL] num_params_takeable -= [number] [EOL] num_args_takeable = num_params_takeable - len ( known_kwargs ) [EOL] [EOL] args , unknown_args = args [ : num_args_takeable ] , args [ num_args_takeable : ] [EOL] bound_parameters = init_signature . bind_partial ( self , * args , ** known_kwargs ) [EOL] [EOL] unknown_args = { f" [string] { i }" : v for i , v in enumerate ( unknown_args ) } [EOL] arguments = bound_parameters . arguments [EOL] arguments . update ( unknown_args ) [EOL] arguments . update ( unknown_kwargs ) [EOL] arguments . pop ( [string] , None ) [EOL] final_parameters = _CatchAllUndefinedParameters . handle_from_dict ( obj , arguments ) [EOL] original_init ( self , ** final_parameters ) [EOL] [EOL] return _catch_all_init [EOL] [EOL] @ staticmethod def _get_catch_all_field ( cls ) : [EOL] catch_all_fields = list ( filter ( lambda f : f . type == Optional [ CatchAllVar ] , fields ( cls ) ) ) [EOL] number_of_catch_all_fields = len ( catch_all_fields ) [EOL] if number_of_catch_all_fields == [number] : [EOL] raise UndefinedParameterError ( [string] ) [EOL] elif number_of_catch_all_fields > [number] : [EOL] raise UndefinedParameterError ( f" [string] " f"{ number_of_catch_all_fields } [string] " ) [EOL] else : [EOL] return catch_all_fields [ [number] ] [EOL] [EOL] [EOL] class Undefined ( Enum ) : [EOL] [docstring] [EOL] INCLUDE = _CatchAllUndefinedParameters [EOL] RAISE = _RaiseUndefinedParameters [EOL] EXCLUDE = _IgnoreUndefinedParameters [EOL] [EOL] [EOL] class UndefinedParameterError ( ValidationError ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from dataclasses_json . api import ( DataClassJsonMixin , LetterCase , dataclass_json ) [EOL] from dataclasses_json . cfg import config , global_config , Exclude [EOL] from dataclasses_json . undefined import CatchAll , Undefined [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import dataclasses_json [EOL] import datetime [EOL] import datetime [EOL] from dataclasses import dataclass , field [EOL] [EOL] import pytest [EOL] from marshmallow import fields , ValidationError [EOL] [EOL] from dataclasses_json import DataClassJsonMixin [EOL] [EOL] [EOL] @ dataclass class Car ( DataClassJsonMixin ) : [EOL] license_number = field ( metadata = { [string] : { [string] : fields . String ( required = False ) } } ) [EOL] [EOL] [EOL] @ dataclass class StringDate ( DataClassJsonMixin ) : [EOL] string_date = field ( metadata = { [string] : { [string] : str , [string] : str , [string] : fields . String ( required = False ) } } ) [EOL] [EOL] [EOL] car_schema = Car . schema ( ) [EOL] string_date_schema = StringDate . schema ( ) [EOL] [EOL] [EOL] class TestMetadata : [EOL] def test_validation_error_raises ( self ) : [EOL] with pytest . raises ( ValidationError ) as e : [EOL] car_schema . load ( { [string] : [number] } ) [EOL] assert e . value . messages == { [string] : [ [string] ] } [EOL] [EOL] def test_mm_field_takes_precedence_over_types ( self ) : [EOL] obj = string_date_schema . load ( { [string] : [string] } ) [EOL] assert isinstance ( obj , StringDate ) [EOL] assert obj . string_date == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dataclasses_json.mm.SchemaF[typing.Any]$ 0 0 0 0 0 0 0 $dataclasses_json.mm.SchemaF[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dataclasses_json.mm.SchemaF[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $dataclasses_json.mm.SchemaF[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import tests [EOL] from dataclasses import dataclass [EOL] from typing import Optional [EOL] [EOL] from dataclasses_json import DataClassJsonMixin [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Tree ( DataClassJsonMixin ) : [EOL] value = ... [EOL] left = ... [EOL] right = ... [EOL] [EOL] [EOL] family_tree_json = [string] . strip ( ) [EOL] [EOL] family_tree = Tree ( [string] , Tree ( [string] , Tree ( [string] , None , None ) , Tree ( [string] , None , None ) ) , Tree ( [string] , Tree ( [string] , None , None ) , Tree ( [string] , None , None ) ) ) [EOL] [EOL] [EOL] class TestRecursive : [EOL] def test_tree_encode ( self ) : [EOL] assert family_tree . to_json ( indent = [number] ) == family_tree_json [EOL] [EOL] def test_tree_decode ( self ) : [EOL] assert Tree . from_json ( family_tree_json ) == family_tree [EOL] [EOL] def test_tree_schema_round_trip ( self ) : [EOL] tree_dict = Tree . schema ( ) . dump ( family_tree ) [EOL] tree_obj = Tree . schema ( ) . load ( tree_dict ) [EOL] assert tree_obj == family_tree [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional['Tree']$ 0 0 0 $typing.Optional['Tree']$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $tests.test_recursive.Tree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_recursive.Tree$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $tests.test_recursive.Tree$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $tests.test_recursive.Tree$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $tests.test_recursive.Tree$ 0 0
from tests . entities import ( DataClassWithDataClass , DataClassWithList , DataClassX , DataClassXs ) [EOL] [EOL] [EOL] class TestEncoder : [EOL] def test_nested_dataclass ( self ) : [EOL] assert ( DataClassWithDataClass ( DataClassWithList ( [ [number] ] ) ) . to_json ( ) == [string] ) [EOL] [EOL] def test_nested_list_of_dataclasses ( self ) : [EOL] assert ( DataClassXs ( [ DataClassX ( [number] ) , DataClassX ( [number] ) ] ) . to_json ( ) == [string] ) [EOL] [EOL] [EOL] class TestDecoder : [EOL] def test_nested_dataclass ( self ) : [EOL] assert ( DataClassWithDataClass . from_json ( [string] ) == DataClassWithDataClass ( DataClassWithList ( [ [number] ] ) ) ) [EOL] [EOL] def test_nested_list_of_dataclasses ( self ) : [EOL] assert ( DataClassXs . from_json ( [string] ) == DataClassXs ( [ DataClassX ( [number] ) , DataClassX ( [number] ) ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from dataclasses import dataclass [EOL] [EOL] from dataclasses_json import dataclass_json [EOL] from datetime import date [EOL] import dataclasses_json [EOL] import dataclasses_json . cfg [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class Person : [EOL] name = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class PersonWithBirthday : [EOL] name = ... [EOL] birthday = ... [EOL] [EOL] [EOL] class TestGlobalConfig : [EOL] def test_encoder_override ( self ) : [EOL] dataclasses_json . cfg . global_config . encoders [ str ] = lambda s : s [ : : - [number] ] [EOL] assert Person ( [string] ) . to_json ( ) == [string] [EOL] dataclasses_json . cfg . global_config . encoders = { } [EOL] [EOL] def test_encoder_extension ( self ) : [EOL] dataclasses_json . cfg . global_config . encoders [ date ] = date . isoformat [EOL] assert PersonWithBirthday ( [string] , date ( [number] , [number] , [number] ) ) . to_json ( ) == [string] [EOL] dataclasses_json . cfg . global_config . encoders = { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union [EOL] import typing [EOL] import tests [EOL] from . entities import ( DataClassDefaultListStr , DataClassDefaultOptionalList , DataClassList , DataClassOptional , DataClassWithNestedOptional , DataClassWithNestedOptionalAny , DataClassWithNestedAny ) [EOL] from . test_letter_case import CamelCasePerson , KebabCasePerson , SnakeCasePerson , FieldNamePerson [EOL] [EOL] test_do_list = [string] [EOL] test_list = [string] [EOL] nested_optional_data = [string] [EOL] [EOL] [EOL] class TestSchema : [EOL] def test_default_list_str ( self ) : [EOL] DataClassDefaultListStr . schema ( ) . dumps ( DataClassDefaultListStr ( ) ) [EOL] assert True [EOL] [EOL] def test_default_optional_list ( self ) : [EOL] DataClassDefaultOptionalList . schema ( ) . loads ( test_do_list , many = True ) [EOL] assert True [EOL] [EOL] def test_list ( self ) : [EOL] DataClassList . schema ( ) . loads ( test_list , many = True ) [EOL] assert True [EOL] [EOL] def test_optional ( self ) : [EOL] DataClassOptional . schema ( ) . loads ( [string] ) [EOL] assert True [EOL] [EOL] def test_letter_case ( self ) : [EOL] for cls in ( CamelCasePerson , KebabCasePerson , SnakeCasePerson , FieldNamePerson ) : [EOL] p = cls ( [string] ) [EOL] assert p . to_dict ( ) == cls . schema ( ) . dump ( p ) [EOL] [EOL] def test_nested_optional ( self ) : [EOL] DataClassWithNestedOptional . schema ( ) . loads ( nested_optional_data ) [EOL] assert True [EOL] [EOL] def test_nested_optional_any ( self ) : [EOL] DataClassWithNestedOptionalAny . schema ( ) . loads ( nested_optional_data ) [EOL] assert True [EOL] [EOL] def test_nested_any_accepts_optional ( self ) : [EOL] DataClassWithNestedAny . schema ( ) . loads ( nested_optional_data ) [EOL] assert True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[tests.test_letter_case.CamelCasePerson,tests.test_letter_case.FieldNamePerson,tests.test_letter_case.KebabCasePerson,tests.test_letter_case.SnakeCasePerson]$ 0 0 0 0 0 0 0 $typing.Union[tests.test_letter_case.CamelCasePerson,tests.test_letter_case.FieldNamePerson,tests.test_letter_case.KebabCasePerson,tests.test_letter_case.SnakeCasePerson]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[tests.test_letter_case.CamelCasePerson,tests.test_letter_case.FieldNamePerson,tests.test_letter_case.KebabCasePerson,tests.test_letter_case.SnakeCasePerson]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
from collections import deque [EOL] [EOL] from tests . entities import ( DataClassIntImmutableDefault , DataClassMutableDefaultDict , DataClassMutableDefaultList , DataClassWithDeque , DataClassWithDict , DataClassWithDictInt , DataClassWithFrozenSet , DataClassWithList , DataClassWithListStr , DataClassWithMyCollection , DataClassWithOptional , DataClassWithOptionalStr , DataClassWithSet , DataClassWithTuple , DataClassWithUnionIntNone , MyCollection ) [EOL] [EOL] [EOL] class TestEncoder : [EOL] def test_list ( self ) : [EOL] assert DataClassWithList ( [ [number] ] ) . to_json ( ) == [string] [EOL] [EOL] def test_list_str ( self ) : [EOL] assert DataClassWithListStr ( [ [string] ] ) . to_json ( ) == [string] [EOL] [EOL] def test_dict ( self ) : [EOL] assert DataClassWithDict ( { [string] : [string] } ) . to_json ( ) == [string] [EOL] [EOL] def test_dict_int ( self ) : [EOL] assert DataClassWithDictInt ( { [number] : [string] } ) . to_json ( ) == [string] [EOL] [EOL] def test_set ( self ) : [EOL] assert DataClassWithSet ( { [number] } ) . to_json ( ) == [string] [EOL] [EOL] def test_tuple ( self ) : [EOL] assert DataClassWithTuple ( ( [number] , ) ) . to_json ( ) == [string] [EOL] [EOL] def test_frozenset ( self ) : [EOL] assert DataClassWithFrozenSet ( frozenset ( [ [number] ] ) ) . to_json ( ) == [string] [EOL] [EOL] def test_deque ( self ) : [EOL] assert DataClassWithDeque ( deque ( [ [number] ] ) ) . to_json ( ) == [string] [EOL] [EOL] def test_optional ( self ) : [EOL] assert DataClassWithOptional ( [number] ) . to_json ( ) == [string] [EOL] assert DataClassWithOptional ( None ) . to_json ( ) == [string] [EOL] [EOL] def test_optional_str ( self ) : [EOL] assert DataClassWithOptionalStr ( [string] ) . to_json ( ) == [string] [EOL] assert DataClassWithOptionalStr ( None ) . to_json ( ) == [string] [EOL] assert DataClassWithOptionalStr ( ) . to_json ( ) == [string] [EOL] [EOL] def test_union_int_none ( self ) : [EOL] assert DataClassWithUnionIntNone ( [number] ) . to_json ( ) == [string] [EOL] assert DataClassWithUnionIntNone ( None ) . to_json ( ) == [string] [EOL] [EOL] def test_my_collection ( self ) : [EOL] assert DataClassWithMyCollection ( MyCollection ( [ [number] ] ) ) . to_json ( ) == [string] [EOL] [EOL] def test_immutable_default ( self ) : [EOL] assert DataClassIntImmutableDefault ( ) . to_json ( ) == [string] [EOL] [EOL] def test_mutable_default_list ( self ) : [EOL] assert DataClassMutableDefaultList ( ) . to_json ( ) == [string] [EOL] [EOL] def test_mutable_default_dict ( self ) : [EOL] assert DataClassMutableDefaultDict ( ) . to_json ( ) == [string] [EOL] [EOL] [EOL] class TestDecoder : [EOL] def test_list ( self ) : [EOL] assert ( DataClassWithList . from_json ( [string] ) == DataClassWithList ( [ [number] ] ) ) [EOL] [EOL] def test_list_str ( self ) : [EOL] assert ( DataClassWithListStr . from_json ( [string] ) == DataClassWithListStr ( [ [string] ] ) ) [EOL] [EOL] def test_dict ( self ) : [EOL] assert ( DataClassWithDict . from_json ( [string] ) == DataClassWithDict ( { [string] : [string] } ) ) [EOL] [EOL] def test_dict_int ( self ) : [EOL] assert ( DataClassWithDictInt . from_json ( [string] ) == DataClassWithDictInt ( { [number] : [string] } ) ) [EOL] [EOL] def test_set ( self ) : [EOL] assert ( DataClassWithSet . from_json ( [string] ) == DataClassWithSet ( { [number] } ) ) [EOL] [EOL] def test_tuple ( self ) : [EOL] assert ( DataClassWithTuple . from_json ( [string] ) == DataClassWithTuple ( ( [number] , ) ) ) [EOL] [EOL] def test_frozenset ( self ) : [EOL] assert ( DataClassWithFrozenSet . from_json ( [string] ) == DataClassWithFrozenSet ( frozenset ( [ [number] ] ) ) ) [EOL] [EOL] def test_deque ( self ) : [EOL] assert ( DataClassWithDeque . from_json ( [string] ) == DataClassWithDeque ( deque ( [ [number] ] ) ) ) [EOL] [EOL] def test_optional ( self ) : [EOL] assert ( DataClassWithOptional . from_json ( [string] ) == DataClassWithOptional ( [number] ) ) [EOL] assert ( DataClassWithOptional . from_json ( [string] ) == DataClassWithOptional ( None ) ) [EOL] [EOL] def test_optional_str ( self ) : [EOL] assert ( DataClassWithOptionalStr . from_json ( [string] ) == DataClassWithOptionalStr ( [string] ) ) [EOL] assert ( DataClassWithOptionalStr . from_json ( [string] ) == DataClassWithOptionalStr ( None ) ) [EOL] assert ( DataClassWithOptionalStr . from_json ( [string] , infer_missing = True ) == DataClassWithOptionalStr ( ) ) [EOL] [EOL] def test_my_collection ( self ) : [EOL] assert ( DataClassWithMyCollection . from_json ( [string] ) == DataClassWithMyCollection ( MyCollection ( [ [number] ] ) ) ) [EOL] [EOL] def test_immutable_default ( self ) : [EOL] assert ( DataClassIntImmutableDefault . from_json ( [string] ) == DataClassIntImmutableDefault ( ) ) [EOL] assert ( DataClassMutableDefaultList . from_json ( [string] , infer_missing = True ) == DataClassMutableDefaultList ( ) ) [EOL] [EOL] def test_mutable_default_list ( self ) : [EOL] assert ( DataClassMutableDefaultList . from_json ( [string] ) == DataClassMutableDefaultList ( ) ) [EOL] assert ( DataClassMutableDefaultList . from_json ( [string] , infer_missing = True ) == DataClassMutableDefaultList ( ) ) [EOL] [EOL] def test_mutable_default_dict ( self ) : [EOL] assert ( DataClassMutableDefaultDict . from_json ( [string] ) == DataClassMutableDefaultDict ( ) ) [EOL] assert ( DataClassMutableDefaultDict . from_json ( [string] , infer_missing = True ) == DataClassMutableDefaultDict ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , Optional , List , Dict , Collection [EOL] import builtins [EOL] import typing [EOL] import tests [EOL] from dataclasses import dataclass , field [EOL] from decimal import Decimal [EOL] from typing import ( Collection , Deque , Dict , FrozenSet , List , NewType , Optional , Set , Tuple , TypeVar , Union , Any ) [EOL] from uuid import UUID [EOL] [EOL] from marshmallow import fields [EOL] [EOL] import dataclasses_json [EOL] from datetime import datetime [EOL] [EOL] from dataclasses_json . cfg import config [EOL] from dataclasses_json import ( DataClassJsonMixin , LetterCase , dataclass_json ) [EOL] [EOL] A = TypeVar ( [string] ) [EOL] Id = NewType ( [string] , UUID ) [EOL] ProductId = NewType ( [string] , Id ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithDecimal ( DataClassJsonMixin ) : [EOL] x = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithNewType ( DataClassJsonMixin ) : [EOL] id = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithNestedNewType ( DataClassJsonMixin ) : [EOL] id = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithList ( DataClassJsonMixin ) : [EOL] xs = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithListDefaultFactory ( DataClassJsonMixin ) : [EOL] xs = field ( default_factory = list ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithListStr ( DataClassJsonMixin ) : [EOL] xs = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithDict ( DataClassJsonMixin ) : [EOL] kvs = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithDictInt ( DataClassJsonMixin ) : [EOL] kvs = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithDictDefaultFactory ( DataClassJsonMixin ) : [EOL] kvs = field ( default_factory = dict ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithSet ( DataClassJsonMixin ) : [EOL] xs = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithTuple ( DataClassJsonMixin ) : [EOL] xs = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithFrozenSet ( DataClassJsonMixin ) : [EOL] xs = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithDeque ( DataClassJsonMixin ) : [EOL] xs = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithOptional ( DataClassJsonMixin ) : [EOL] x = ... [EOL] [EOL] [EOL] @ dataclass class DataClassWithOptionalStr ( DataClassJsonMixin ) : [EOL] x = None [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithOptionalNested ( DataClassJsonMixin ) : [EOL] x = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithUnionIntNone ( DataClassJsonMixin ) : [EOL] x = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithDataClass ( DataClassJsonMixin ) : [EOL] dc_with_list = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassX ( DataClassJsonMixin ) : [EOL] x = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassXs ( DataClassJsonMixin ) : [EOL] xs = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassIntImmutableDefault ( DataClassJsonMixin ) : [EOL] x = [number] [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassBoolImmutableDefault ( DataClassJsonMixin ) : [EOL] x = False [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassMutableDefaultList ( DataClassJsonMixin ) : [EOL] xs = field ( default_factory = list ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassMutableDefaultDict ( DataClassJsonMixin ) : [EOL] xs = field ( default_factory = dict ) [EOL] [EOL] [EOL] class MyCollection ( Collection [ A ] ) : [EOL] def __init__ ( self , xs ) : [EOL] self . xs = xs [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return False [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . xs ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . xs ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return type ( self ) == type ( other ) and self . xs == other . xs [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class DataClassWithMyCollection ( DataClassJsonMixin ) : [EOL] xs = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassJsonDecorator : [EOL] x = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassWithConfigManual : [EOL] id = field ( metadata = { [string] : { [string] : fields . Integer ( ) } } ) [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassWithConfigHelper : [EOL] id = field ( metadata = config ( encoder = str ) ) [EOL] [EOL] [EOL] @ dataclass_json ( letter_case = LetterCase . CAMEL ) @ dataclass class DataClassWithConfigDecorator : [EOL] id_field = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassWithUuid : [EOL] id = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassDefaultListStr : [EOL] value = field ( default_factory = list ) [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassChild : [EOL] name = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassDefaultOptionalList : [EOL] children = None [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassList : [EOL] children = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassOptional : [EOL] a = ... [EOL] b = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassWithOptionalDatetime : [EOL] a = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassWithOptionalDecimal : [EOL] a = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassWithOptionalUuid : [EOL] a = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassWithNestedAny : [EOL] a = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassWithNestedOptionalAny : [EOL] a = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class DataClassWithNestedOptional : [EOL] a = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Id$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ProductId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Deque[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[DataClassWithOptional]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DataClassWithList$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[DataClassX]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MyCollection[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[DataClassChild]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[DataClassChild]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[uuid.UUID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.int]]$ 0 0 0
import builtins [EOL] import tests [EOL] from dataclasses import dataclass , field [EOL] [EOL] from dataclasses_json import LetterCase , dataclass_json , config [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class CamelCasePerson : [EOL] given_name = field ( metadata = { [string] : { [string] : LetterCase . CAMEL } } ) [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class KebabCasePerson : [EOL] given_name = field ( metadata = { [string] : { [string] : LetterCase . KEBAB } } ) [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class SnakeCasePerson : [EOL] given_name = field ( metadata = { [string] : { [string] : LetterCase . SNAKE } } ) [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class PascalCasePerson : [EOL] given_name = field ( metadata = { [string] : { [string] : LetterCase . PASCAL } } ) [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class FieldNamePerson : [EOL] given_name = field ( metadata = config ( field_name = [string] ) ) [EOL] [EOL] [EOL] @ dataclass_json ( letter_case = LetterCase . CAMEL ) @ dataclass class CamelCasePersonWithOverride : [EOL] given_name = ... [EOL] years_on_earth = field ( metadata = config ( field_name = [string] ) ) [EOL] [EOL] [EOL] class TestLetterCase : [EOL] def test_camel_encode ( self ) : [EOL] assert CamelCasePerson ( [string] ) . to_json ( ) == [string] [EOL] [EOL] def test_camel_decode ( self ) : [EOL] assert CamelCasePerson . from_json ( [string] ) == CamelCasePerson ( [string] ) [EOL] [EOL] def test_kebab_encode ( self ) : [EOL] assert KebabCasePerson ( [string] ) . to_json ( ) == [string] [EOL] [EOL] def test_kebab_decode ( self ) : [EOL] assert KebabCasePerson . from_json ( [string] ) == KebabCasePerson ( [string] ) [EOL] [EOL] def test_snake_encode ( self ) : [EOL] assert SnakeCasePerson ( [string] ) . to_json ( ) == [string] [EOL] [EOL] def test_snake_decode ( self ) : [EOL] assert SnakeCasePerson . from_json ( [string] ) == SnakeCasePerson ( [string] ) [EOL] [EOL] def test_pascal_encode ( self ) : [EOL] assert PascalCasePerson ( [string] ) . to_json ( ) == [string] [EOL] [EOL] def test_pascal_decode ( self ) : [EOL] assert PascalCasePerson . from_json ( [string] ) == PascalCasePerson ( [string] ) [EOL] [EOL] def test_field_name_encode ( self ) : [EOL] assert FieldNamePerson ( [string] ) . to_json ( ) == [string] [EOL] [EOL] def test_field_name_decode ( self ) : [EOL] assert FieldNamePerson . from_json ( [string] ) == FieldNamePerson ( [string] ) [EOL] [EOL] def test_camel_with_override_encode ( self ) : [EOL] assert CamelCasePersonWithOverride ( [string] , [number] ) . to_json ( ) == [string] [EOL] [EOL] def test_camel_with_override_decode ( self ) : [EOL] expected = CamelCasePersonWithOverride ( [string] , [number] ) [EOL] assert CamelCasePersonWithOverride . from_json ( [string] ) == expected [EOL] [EOL] def test_from_dict ( self ) : [EOL] assert CamelCasePerson . from_dict ( { [string] : [string] } ) == CamelCasePerson ( [string] ) [EOL] [EOL] def test_to_dict ( self ) : [EOL] assert { [string] : [string] } == CamelCasePerson ( [string] ) . to_dict ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_letter_case.CamelCasePersonWithOverride$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_letter_case.CamelCasePersonWithOverride$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import typing [EOL] import tests [EOL] from dataclasses import dataclass [EOL] from typing import Set , Optional [EOL] [EOL] from dataclasses_json import dataclass_json [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class Student : [EOL] id = [number] [EOL] name = [string] [EOL] [EOL] [EOL] @ dataclass_json @ dataclass class Tutor : [EOL] id = ... [EOL] student = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class Professor : [EOL] id = ... [EOL] name = ... [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class Course : [EOL] id = ... [EOL] name = ... [EOL] professor = ... [EOL] students = ... [EOL] [EOL] [EOL] s1 = Student ( [number] , [string] ) [EOL] s2 = Student ( [number] , [string] ) [EOL] t = Tutor ( id = [number] , student = None ) [EOL] p = Professor ( [number] , [string] ) [EOL] c = Course ( [number] , [string] , p , { s1 } ) [EOL] [EOL] [EOL] class TestEncoder : [EOL] def test_student ( self ) : [EOL] assert s1 . to_json ( ) == [string] [EOL] [EOL] def test_professor ( self ) : [EOL] assert p . to_json ( ) == [string] [EOL] [EOL] def test_course ( self ) : [EOL] assert c . to_json ( ) == [string] [EOL] [EOL] def test_students_missing ( self ) : [EOL] s1_anon = Student ( [number] , [string] ) [EOL] s2_anon = Student ( [number] , [string] ) [EOL] one = [ s1_anon , s2_anon ] [EOL] two = [ s2_anon , s1_anon ] [EOL] actual = Student . schema ( ) . loads ( [string] , many = True ) [EOL] assert actual == one or actual == two [EOL] [EOL] [EOL] class TestDecoder : [EOL] def test_tutor ( self ) : [EOL] assert Tutor . from_json ( [string] , infer_missing = True ) == t [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[Student]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $Professor$ 0 0 0 $typing.Set[Student]$ 0 0 0 0 0 $tests.test_examples.Student$ 0 0 0 0 0 0 0 0 $tests.test_examples.Student$ 0 0 0 0 0 0 0 0 $tests.test_examples.Tutor$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_examples.Professor$ 0 0 0 0 0 0 0 0 $tests.test_examples.Course$ 0 0 0 0 0 0 0 $tests.test_examples.Professor$ 0 0 $tests.test_examples.Student$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_examples.Student$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_examples.Professor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_examples.Course$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_examples.Student$ 0 0 0 0 0 0 0 0 $tests.test_examples.Student$ 0 0 0 0 0 0 0 0 $typing.List[tests.test_examples.Student]$ 0 0 $tests.test_examples.Student$ 0 $tests.test_examples.Student$ 0 0 $typing.List[tests.test_examples.Student]$ 0 0 $tests.test_examples.Student$ 0 $tests.test_examples.Student$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[tests.test_examples.Student]$ 0 $typing.Any$ 0 $typing.List[tests.test_examples.Student]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_examples.Tutor$ 0
import builtins [EOL] from typing import Type [EOL] import typing [EOL] import tests [EOL] import datetime [EOL] from datetime import datetime , timezone [EOL] from decimal import Decimal [EOL] from uuid import UUID [EOL] [EOL] import pytest [EOL] [EOL] from tests . entities import ( DataClassBoolImmutableDefault , DataClassIntImmutableDefault , DataClassJsonDecorator , DataClassWithConfigDecorator , DataClassWithConfigHelper , DataClassWithConfigManual , DataClassWithDataClass , DataClassWithDecimal , DataClassWithList , DataClassWithNestedNewType , DataClassWithNewType , DataClassWithOptional , DataClassWithOptionalDatetime , DataClassWithOptionalDecimal , DataClassWithOptionalNested , DataClassWithOptionalUuid , DataClassWithUuid , Id , ProductId ) [EOL] [EOL] [EOL] class TestTypes : [EOL] decimal_s = [string] [EOL] dc_decimal_json = f' [string] { decimal_s } [string] ' [EOL] [EOL] uuid_s = [string] [EOL] dc_uuid_json = f' [string] { uuid_s } [string] ' [EOL] [EOL] def test_decimal_encode ( self ) : [EOL] assert ( DataClassWithDecimal ( Decimal ( self . decimal_s ) ) . to_json ( ) == self . dc_decimal_json ) [EOL] [EOL] def test_decimal_decode ( self ) : [EOL] assert ( DataClassWithDecimal . from_json ( self . dc_decimal_json ) == DataClassWithDecimal ( Decimal ( self . decimal_s ) ) ) [EOL] [EOL] [EOL] class TestGenericExtendedTypes : [EOL] def test_optional_datetime ( self ) : [EOL] dt = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = timezone . utc ) [EOL] dc = DataClassWithOptionalDatetime ( dt ) [EOL] assert ( DataClassWithOptionalDatetime . from_json ( dc . to_json ( ) ) == dc ) [EOL] [EOL] def test_optional_decimal ( self ) : [EOL] dc = DataClassWithOptionalDecimal ( Decimal ( [string] ) ) [EOL] assert ( DataClassWithOptionalDecimal . from_json ( dc . to_json ( ) ) == dc ) [EOL] [EOL] def test_optional_uuid ( self ) : [EOL] dc = DataClassWithOptionalUuid ( UUID ( [string] ) ) [EOL] assert ( DataClassWithOptionalUuid . from_json ( dc . to_json ( ) ) == dc ) [EOL] [EOL] [EOL] class TestDictDecode : [EOL] decimal_s = [string] [EOL] dc_decimal_json = { [string] : decimal_s } [EOL] [EOL] uuid_s = [string] [EOL] dc_uuid_json = { [string] : uuid_s } [EOL] [EOL] def test_decimal_decode ( self ) : [EOL] assert ( DataClassWithDecimal . from_dict ( self . dc_decimal_json ) == DataClassWithDecimal ( Decimal ( self . decimal_s ) ) ) [EOL] [EOL] def test_uuid_decode ( self ) : [EOL] assert ( DataClassWithUuid . from_dict ( self . dc_uuid_json ) == DataClassWithUuid ( UUID ( self . uuid_s ) ) ) [EOL] [EOL] [EOL] class TestNewType : [EOL] new_type_s = [string] [EOL] dc_new_type_json = f' [string] { new_type_s } [string] ' [EOL] [EOL] def test_new_type_encode ( self ) : [EOL] assert ( DataClassWithNewType ( Id ( UUID ( self . new_type_s ) ) ) . to_json ( ) == self . dc_new_type_json ) [EOL] [EOL] def test_new_type_decode ( self ) : [EOL] assert ( DataClassWithNewType . from_json ( self . dc_new_type_json ) == DataClassWithNewType ( Id ( UUID ( self . new_type_s ) ) ) ) [EOL] [EOL] def test_nested_new_type_encode ( self ) : [EOL] assert ( DataClassWithNestedNewType ( ProductId ( Id ( UUID ( self . new_type_s ) ) ) ) . to_json ( ) == self . dc_new_type_json ) [EOL] [EOL] def test_nested_new_type_decode ( self ) : [EOL] assert ( DataClassWithNestedNewType . from_json ( self . dc_new_type_json ) == DataClassWithNestedNewType ( ProductId ( Id ( UUID ( self . new_type_s ) ) ) ) ) [EOL] [EOL] [EOL] class TestInferMissing : [EOL] def test_infer_missing ( self ) : [EOL] actual = DataClassWithOptional . from_json ( [string] , infer_missing = True ) [EOL] assert ( actual == DataClassWithOptional ( None ) ) [EOL] [EOL] def test_infer_missing_is_recursive ( self ) : [EOL] actual = DataClassWithOptionalNested . from_json ( [string] , infer_missing = True ) [EOL] expected = DataClassWithOptionalNested ( DataClassWithOptional ( None ) ) [EOL] assert ( actual == expected ) [EOL] [EOL] def test_infer_missing_terminates_at_first_missing ( self ) : [EOL] actual = DataClassWithOptionalNested . from_json ( [string] , infer_missing = True ) [EOL] assert ( actual == DataClassWithOptionalNested ( None ) ) [EOL] [EOL] [EOL] class TestWarnings : [EOL] def test_warns_when_nonoptional_field_is_missing_with_infer_missing ( self ) : [EOL] with pytest . warns ( RuntimeWarning , match = [string] ) : [EOL] actual = DataClassWithDataClass . from_json ( [string] , infer_missing = True ) [EOL] expected = DataClassWithDataClass ( DataClassWithList ( None ) ) [EOL] assert ( actual == expected ) [EOL] [EOL] def test_warns_when_required_field_is_none ( self ) : [EOL] with pytest . warns ( RuntimeWarning , match = [string] ) : [EOL] assert ( DataClassWithDataClass . from_json ( [string] ) == DataClassWithDataClass ( None ) ) [EOL] [EOL] [EOL] class TestErrors : [EOL] def test_error_when_nonoptional_field_is_missing ( self ) : [EOL] with pytest . raises ( KeyError ) : [EOL] actual = DataClassWithDataClass . from_json ( [string] ) [EOL] expected = DataClassWithDataClass ( DataClassWithList ( None ) ) [EOL] assert ( actual == expected ) [EOL] [EOL] [EOL] class TestDecorator : [EOL] def test_decorator ( self ) : [EOL] json_s = [string] [EOL] assert DataClassJsonDecorator . from_json ( json_s ) . to_json ( ) == json_s [EOL] [EOL] [EOL] class TestSchema : [EOL] def test_dumps_many ( self ) : [EOL] actual = DataClassWithList . schema ( ) . dumps ( [ DataClassWithList ( [ [number] ] ) ] , many = True ) [EOL] json_s = [string] [EOL] assert actual == json_s [EOL] [EOL] def test_dumps_many_nested ( self ) : [EOL] dumped = DataClassWithDataClass . schema ( ) . dumps ( [ DataClassWithDataClass ( DataClassWithList ( [ [number] ] ) ) ] , many = True ) [EOL] json_s = [string] [EOL] assert dumped == json_s [EOL] [EOL] def test_loads_many ( self ) : [EOL] json_s = [string] [EOL] assert ( DataClassWithList . schema ( ) . loads ( json_s , many = True ) == [ DataClassWithList ( [ [number] ] ) ] ) [EOL] [EOL] def test_loads_many_nested ( self ) : [EOL] json_s = [string] [EOL] assert ( DataClassWithDataClass . schema ( ) . loads ( json_s , many = True ) == [ DataClassWithDataClass ( DataClassWithList ( [ [number] ] ) ) ] ) [EOL] [EOL] def test_loads_default ( self ) : [EOL] assert ( DataClassIntImmutableDefault . schema ( ) . loads ( [string] ) == DataClassIntImmutableDefault ( ) ) [EOL] assert ( DataClassBoolImmutableDefault . schema ( ) . loads ( [string] ) == DataClassBoolImmutableDefault ( ) ) [EOL] [EOL] def test_loads_default_many ( self ) : [EOL] assert ( DataClassIntImmutableDefault . schema ( ) . loads ( [string] , many = True ) == [ DataClassIntImmutableDefault ( ) ] ) [EOL] assert ( DataClassBoolImmutableDefault . schema ( ) . loads ( [string] , many = True ) == [ DataClassBoolImmutableDefault ( ) ] ) [EOL] [EOL] def test_dumps_default ( self ) : [EOL] d_int = DataClassIntImmutableDefault ( ) [EOL] assert d_int . x == [number] [EOL] assert DataClassIntImmutableDefault . schema ( ) . dumps ( d_int ) == [string] [EOL] d_bool = DataClassBoolImmutableDefault ( ) [EOL] assert d_bool . x is False [EOL] assert DataClassBoolImmutableDefault . schema ( ) . dumps ( d_bool ) == [string] [EOL] [EOL] def test_dumps_default_many ( self ) : [EOL] d_int = DataClassIntImmutableDefault ( ) [EOL] assert d_int . x == [number] [EOL] assert DataClassIntImmutableDefault . schema ( ) . dumps ( [ d_int ] , many = True ) == [string] [EOL] d_bool = DataClassBoolImmutableDefault ( ) [EOL] assert d_bool . x is False [EOL] assert DataClassBoolImmutableDefault . schema ( ) . dumps ( [ d_bool ] , many = True ) == [string] [EOL] [EOL] def test_dumps_new_type ( self ) : [EOL] raw_value = [string] [EOL] id_value = Id ( UUID ( raw_value ) ) [EOL] [EOL] d_new_type = DataClassWithNewType ( id_value ) [EOL] [EOL] assert DataClassWithNewType . schema ( ) . dumps ( d_new_type ) == f' [string] { raw_value } [string] ' [EOL] [EOL] def test_dumps_nested_new_type ( self ) : [EOL] raw_value = [string] [EOL] id_value = ProductId ( Id ( UUID ( raw_value ) ) ) [EOL] [EOL] d_new_type = DataClassWithNestedNewType ( id_value ) [EOL] [EOL] assert DataClassWithNestedNewType . schema ( ) . dumps ( d_new_type ) == f' [string] { raw_value } [string] ' [EOL] [EOL] def test_loads_infer_missing ( self ) : [EOL] assert ( DataClassWithOptional . schema ( infer_missing = True ) . loads ( [string] , many = True ) == [ DataClassWithOptional ( None ) ] ) [EOL] [EOL] def test_loads_infer_missing_nested ( self ) : [EOL] assert ( DataClassWithOptionalNested . schema ( infer_missing = True ) . loads ( [string] , many = True ) == [ DataClassWithOptionalNested ( None ) ] ) [EOL] [EOL] [EOL] class TestOverride : [EOL] def test_override ( self ) : [EOL] dc = DataClassWithConfigManual ( [number] ) [EOL] assert dc . to_json ( ) == [string] [EOL] assert DataClassWithConfigManual . schema ( ) . dumps ( dc ) == [string] [EOL] [EOL] def test_override_with_config_helper ( self ) : [EOL] dc = DataClassWithConfigHelper ( [number] ) [EOL] assert dc . to_json ( ) == [string] [EOL] [EOL] [EOL] class TestConfig : [EOL] def test_config_encode ( self ) : [EOL] dc = DataClassWithConfigDecorator ( [string] ) [EOL] assert dc . to_json ( ) == [string] [EOL] [EOL] def test_config_decode ( self ) : [EOL] dc = DataClassWithConfigDecorator ( [string] ) [EOL] assert DataClassWithConfigDecorator . from_json ( [string] ) == dc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithOptional$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithOptional$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithOptionalNested$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithOptionalNested$ 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithOptionalNested$ 0 $tests.entities.DataClassWithOptionalNested$ 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithOptionalNested$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithOptionalNested$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithDataClass$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithDataClass$ 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithDataClass$ 0 $tests.entities.DataClassWithDataClass$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithDataClass$ 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithDataClass$ 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithDataClass$ 0 $tests.entities.DataClassWithDataClass$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassIntImmutableDefault$ 0 0 0 0 0 0 $tests.entities.DataClassIntImmutableDefault$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassIntImmutableDefault$ 0 0 0 0 $tests.entities.DataClassBoolImmutableDefault$ 0 0 0 0 0 0 $tests.entities.DataClassBoolImmutableDefault$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassBoolImmutableDefault$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassIntImmutableDefault$ 0 0 0 0 0 0 $tests.entities.DataClassIntImmutableDefault$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassIntImmutableDefault$ 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassBoolImmutableDefault$ 0 0 0 0 0 0 $tests.entities.DataClassBoolImmutableDefault$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassBoolImmutableDefault$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $tests.entities.Id$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $tests.entities.DataClassWithNewType$ 0 0 0 $tests.entities.Id$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithNewType$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $tests.entities.ProductId$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $tests.entities.DataClassWithNestedNewType$ 0 0 0 $tests.entities.ProductId$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithNestedNewType$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithConfigManual$ 0 0 0 0 0 0 0 $tests.entities.DataClassWithConfigManual$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithConfigManual$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithConfigHelper$ 0 0 0 0 0 0 0 $tests.entities.DataClassWithConfigHelper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithConfigDecorator$ 0 0 0 0 0 0 0 $tests.entities.DataClassWithConfigDecorator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithConfigDecorator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.entities.DataClassWithConfigDecorator$ 0
import builtins [EOL] from typing import Any [EOL] import typing [EOL] import tests [EOL] import json [EOL] from enum import Enum [EOL] from typing import Dict , List [EOL] import pytest [EOL] [EOL] from dataclasses import dataclass [EOL] [EOL] from dataclasses_json import dataclass_json [EOL] [EOL] from marshmallow . exceptions import ValidationError [EOL] [EOL] [EOL] class MyEnum ( Enum ) : [EOL] STR1 = [string] [EOL] STR2 = [string] [EOL] STR3 = [string] [EOL] INT1 = [number] [EOL] FLOAT1 = [number] [EOL] [EOL] [EOL] class MyStrEnum ( str , Enum ) : [EOL] STR1 = [string] [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class DataWithEnum : [EOL] name = ... [EOL] my_enum = MyEnum . STR3 [EOL] [EOL] [EOL] d1 = DataWithEnum ( [string] , MyEnum . STR1 ) [EOL] d1_json = [string] [EOL] [EOL] [comment] [EOL] d2_using_default_value = DataWithEnum ( [string] ) [EOL] d2_json = [string] [EOL] [EOL] d3_int = DataWithEnum ( [string] , MyEnum . INT1 ) [EOL] d3_int_json = [string] [EOL] d4_float = DataWithEnum ( [string] , MyEnum . FLOAT1 ) [EOL] d4_float_json = [string] [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class DataWithStrEnum : [EOL] my_str_enum = MyEnum . STR1 [EOL] [EOL] [EOL] ds = DataWithStrEnum ( MyStrEnum . STR1 ) [EOL] ds_json = [string] [EOL] [EOL] [EOL] @ dataclass_json @ dataclass ( frozen = True ) class EnumContainer : [EOL] enum_list = ... [EOL] dict_enum_value = ... [EOL] [EOL] [EOL] container_json = [string] [EOL] container = EnumContainer ( enum_list = [ MyEnum . STR3 , MyEnum . INT1 ] , dict_enum_value = { [string] : MyEnum . STR1 , [string] : MyEnum . FLOAT1 } ) [EOL] [EOL] [EOL] class TestEncoder : [EOL] def test_data_with_enum ( self ) : [EOL] assert d1 . to_json ( ) == d1_json , f' [string] { d1 . to_json ( ) } [string] { d1_json }' [EOL] assert d3_int . to_json ( ) == d3_int_json , f' [string] { d3_int . to_json ( ) } [string] { d3_int_json }' [EOL] assert d4_float . to_json ( ) == d4_float_json , f' [string] { d4_float . to_json ( ) } [string] { d4_float_json }' [EOL] [EOL] def test_data_with_str_enum ( self ) : [EOL] assert ds . to_json ( ) == ds_json , f' [string] { ds . to_json ( ) } [string] { ds_json }' [EOL] [EOL] def test_data_with_enum_default_value ( self ) : [EOL] d2_to_json = d2_using_default_value . to_json ( ) [EOL] assert d2_to_json == d2_json , f" [string] " f" [string] { d2_json } [string] { d2_to_json }" [EOL] [EOL] def test_collection_with_enum ( self ) : [EOL] assert container . to_json ( ) == container_json [EOL] [EOL] [EOL] class TestDecoder : [EOL] def test_data_with_enum ( self ) : [EOL] d1_from_json = DataWithEnum . from_json ( d1_json ) [EOL] assert d1 == d1_from_json [EOL] assert d1_from_json . to_json ( ) == d1_json [EOL] [EOL] d3_int_from_json = DataWithEnum . from_json ( d3_int_json ) [EOL] assert d3_int == d3_int_from_json [EOL] assert d3_int_from_json . to_json ( ) == d3_int_json [EOL] [EOL] d4_float_from_json = DataWithEnum . from_json ( d4_float_json ) [EOL] assert d4_float == d4_float_from_json [EOL] assert d4_float_from_json . to_json ( ) == d4_float_json [EOL] [EOL] def test_data_with_str_enum ( self ) : [EOL] ds_from_json = DataWithStrEnum . from_json ( ds_json ) [EOL] assert ds == ds_from_json [EOL] assert ds_from_json . to_json ( ) == ds_json [EOL] [EOL] def test_data_with_enum_default_value ( self ) : [EOL] d2_from_json = DataWithEnum . from_json ( d2_json ) [EOL] assert d2_using_default_value == d2_from_json [EOL] json_from_d2 = d2_from_json . to_json ( ) [EOL] assert json_from_d2 == d2_json , f" [string] " f" [string] { d2_json } [string] { json_from_d2 }" [EOL] [EOL] def test_collection_with_enum ( self ) : [EOL] container_from_json = EnumContainer . from_json ( container_json ) [EOL] assert container == container_from_json [EOL] assert container_from_json . to_json ( ) == container_json [EOL] [EOL] [EOL] class TestValidator : [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , True ) , ( [string] , True ) , ( [string] , True ) , ( [number] , False ) , ( [number] , False ) , ( [string] , False ) , ( [number] , False ) , ( [number] , False ) , ] ) def test_data_with_enum ( self , enum_value , is_valid ) : [EOL] data = [string] + str ( enum_value ) + [string] [EOL] schema = DataWithEnum . schema ( ) [EOL] res = schema . validate ( json . loads ( data ) ) [EOL] no_errors = not res [EOL] assert no_errors == is_valid , str ( res ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , True ) , ( [string] , False ) , ] ) def test_data_with_str_enum ( self , enum_value , is_valid ) : [EOL] data = [string] + str ( enum_value ) + [string] [EOL] schema = DataWithStrEnum . schema ( ) [EOL] res = schema . validate ( json . loads ( data ) ) [EOL] no_errors = not res [EOL] assert no_errors == is_valid [EOL] [EOL] [EOL] class TestLoader : [EOL] @ pytest . mark . parametrize ( [string] , [ ( d1_json , d1 ) , ( d2_json , d2_using_default_value ) , ( d3_int_json , d3_int ) , ( d4_float_json , d4_float ) , ] ) def test_data_with_enum ( self , json_data , expected_data ) : [EOL] schema = DataWithEnum . schema ( ) [EOL] assert schema . loads ( json_data ) == expected_data [EOL] [EOL] def test_data_with_enum_exception ( self ) : [EOL] schema = DataWithEnum . schema ( ) [EOL] with pytest . raises ( ValidationError ) : [EOL] schema . loads ( [string] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( ds_json , ds ) , ] ) def test_data_with_str_enum ( self , json_data , expected_data ) : [EOL] schema = DataWithStrEnum . schema ( ) [EOL] assert schema . loads ( json_data ) == expected_data [EOL] [EOL] def test_data_with_str_enum_exception ( self ) : [EOL] schema = DataWithStrEnum . schema ( ) [EOL] with pytest . raises ( ValidationError ) : [EOL] schema . loads ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[MyEnum]$ 0 0 0 $typing.Dict[builtins.str,MyEnum]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from collections import deque [EOL] [EOL] from hypothesis . strategies import lists , none , one_of [EOL] [EOL] [EOL] def deques ( elements = None , min_size = [number] , max_size = None , unique_by = None , unique = False ) : [EOL] return lists ( ** locals ( ) ) . map ( deque ) [EOL] [EOL] [EOL] def optionals ( strategy ) : [EOL] return one_of ( strategy , none ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from hypothesis import example [EOL] [EOL] [EOL] def examples ( * args ) : [EOL] [docstring] [EOL] [EOL] def examples_decorator ( f ) : [EOL] g = f [EOL] for arg in args : [EOL] g = example ( arg ) ( g ) [EOL] return g [EOL] [EOL] return examples_decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from tests . hypothesis2 . core import examples [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List , Type , Dict , Tuple [EOL] import builtins [EOL] import typing [EOL] import tests [EOL] import dataclasses_json [EOL] import json [EOL] import logging [EOL] import os [EOL] [comment] [EOL] from dataclasses import dataclass [EOL] from io import StringIO [EOL] from typing import Any , Dict , List , NewType , Optional , Tuple , Union [EOL] [EOL] from mypy . main import main as mypy_main [EOL] [EOL] from dataclasses_json import DataClassJsonMixin , CatchAll [EOL] [EOL] [EOL] @ dataclass class User ( DataClassJsonMixin ) : [EOL] id = ... [EOL] name = [string] [EOL] ca = None [EOL] [EOL] [EOL] Filename = NewType ( [string] , str ) [EOL] LineNumber = NewType ( [string] , int ) [EOL] ErrorLevel = NewType ( [string] , str ) [EOL] ErrorMessage = NewType ( [string] , str ) [EOL] [EOL] [EOL] class TestAnnotations : [EOL] u = User ( [string] ) [EOL] j = u . to_json ( ) [EOL] u2 = User . from_json ( j ) [EOL] u2a = User . from_json ( j . encode ( ) ) [EOL] [EOL] jMany = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] sch = User . schema ( ) [EOL] users1 = sch . loads ( json . dumps ( jMany ) , many = True ) [EOL] n = users1 [ [number] ] . name [EOL] users2 = sch . load ( jMany , many = True ) [comment] [EOL] u3 = sch . load ( jMany [ [number] ] ) [EOL] j2 = sch . dump ( u ) [EOL] j3 = sch . dump ( [ u2 , u3 ] , many = True ) [EOL] j4 = sch . dumps ( u2 ) [EOL] [EOL] j4_dict = json . loads ( j4 ) [EOL] u4a = User . from_json ( j4 ) [EOL] u4b = User . from_dict ( j4_dict ) [EOL] [EOL] def filter_errors ( self , errors ) : [EOL] real_errors = list ( ) [EOL] current_file = __file__ [EOL] current_path = os . path . split ( current_file ) [EOL] [EOL] for line in errors : [EOL] line = line . strip ( ) [EOL] if ( not line ) : [EOL] continue [EOL] [EOL] fn , lno , lvl , msg = self . parse_trace_line ( line ) [EOL] if ( fn is not None ) : [EOL] _path = os . path . split ( fn ) [EOL] if ( _path [ - [number] ] != current_path [ - [number] ] ) : [EOL] continue [EOL] [EOL] real_errors . append ( line ) [EOL] [EOL] return real_errors [EOL] [EOL] def parse_trace_line ( self , line ) : [EOL] [comment] [EOL] file_name = ... [EOL] line_no = ... [EOL] level = ... [EOL] msg = ... [EOL] [EOL] where , sep , msg = line . partition ( [string] ) [EOL] if (sep) : [EOL] file_name , sep , line_no = where . rpartition ( [string] ) [EOL] file_name = Filename ( file_name ) [EOL] if (sep) : [EOL] line_no = LineNumber ( int ( line_no ) ) [EOL] else : [EOL] line_no = None [EOL] [EOL] level , sep , msg = msg . partition ( [string] ) [EOL] if (sep) : [EOL] level = ErrorLevel ( level ) [EOL] else : [EOL] msg = level [EOL] level = None [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] file_name = Filename ( [string] ) if line . startswith ( [string] ) else None [EOL] line_no = None [EOL] level = None [EOL] msg = line [EOL] [EOL] msg = ErrorMessage ( msg ) [EOL] return file_name , line_no , level , msg [EOL] [EOL] def test_type_hints ( self ) : [EOL] text_io = StringIO ( [string] ) [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] mypy_main ( None , text_io , text_io , [ __file__ ] ) [EOL] except SystemExit : [EOL] [comment] [EOL] [comment] [EOL] errors = text_io . getvalue ( ) . splitlines ( ) [EOL] errors = self . filter_errors ( errors ) [EOL] else : [EOL] errors = None [EOL] [EOL] [comment] [EOL] if (errors) : [EOL] logging . error ( [string] . join ( errors ) ) [EOL] raise AssertionError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Tuple[typing.Optional[Filename],typing.Optional[LineNumber],typing.Optional[ErrorLevel],ErrorMessage]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0