from typing import Any , List , Callable [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] import unittest [EOL] [EOL] [EOL] class Solution : [EOL] def productExceptSelf ( self , nums ) : [EOL] result = [ ] [EOL] temp = [number] [EOL] [EOL] for num in nums : [EOL] result . append ( temp ) [EOL] temp = temp * num [EOL] [EOL] temp = [number] [EOL] [EOL] for index in reversed ( range ( [number] , len ( nums ) ) ) : [EOL] result [ index ] = result [ index ] * temp [EOL] temp = temp * nums [ index ] [EOL] return result [EOL] [EOL] [EOL] class Test ( unittest . TestCase ) : [EOL] def test ( self ) : [EOL] input = [ [number] , [number] , [number] , [number] ] [EOL] solution = Solution ( ) [EOL] self . assertEqual ( solution . productExceptSelf ( input ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import os [EOL] [EOL] [EOL] def main ( ) : [EOL] location = [string] [EOL] for filename in os . listdir ( location ) : [EOL] data = filename . split ( [string] ) [EOL] if len ( data ) == [number] : [EOL] src = f"{ location } [string] { filename }" [EOL] number , name , extension = data [EOL] [comment] [EOL] name = name . replace ( [string] , [string] ) . lower ( ) [EOL] newname = f"{ number : [string] }{ name } [string] { extension }" [EOL] dst = f"{ location } [string] { newname }" [EOL] print ( newname ) [EOL] os . rename ( src , dst ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def debounce ( fn , delay ) : [EOL] fn ( ) [EOL] [EOL] [EOL] debounce ( [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import List , Dict [EOL] import unittest [EOL] [EOL] [EOL] class Solution : [EOL] def twoSum ( self , nums , target ) : [EOL] hash = { } [EOL] [EOL] for index , num in enumerate ( nums ) : [EOL] diff = target - num [EOL] if num in hash : [EOL] savedIndex = hash . get ( num , - [number] ) [EOL] return [ savedIndex , index ] [EOL] hash [ diff ] = index [EOL] [EOL] return [ ] [EOL] [EOL] [EOL] class Test ( unittest . TestCase ) : [EOL] def test ( self ) : [EOL] self . assertEqual ( Solution . twoSum ( self , [ [number] , [number] , [number] , [number] ] , [number] ) , [ [number] , [number] ] ) [EOL] self . assertEqual ( Solution . twoSum ( self , [ [number] , [number] , [number] ] , [number] ) , [ [number] , [number] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 $typing.Any$ 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Callable [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] import unittest [EOL] [EOL] [EOL] class Solution : [EOL] def isValid ( self , s ) : [EOL] hash = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] queue = [ ] [EOL] [EOL] for char in s : [EOL] value = hash . get ( char ) [EOL] if value : [EOL] queue . append ( value ) [EOL] continue [EOL] [EOL] popped = queue . pop ( ) if queue else [string] [EOL] [EOL] if char != popped : [EOL] return False [EOL] [EOL] return len ( queue ) == [number] [EOL] [EOL] [EOL] class Test ( unittest . TestCase ) : [EOL] def test ( self ) : [EOL] self . assertTrue ( Solution . isValid ( self , [string] ) ) [EOL] self . assertFalse ( Solution . isValid ( self , [string] ) ) [EOL] self . assertFalse ( Solution . isValid ( self , [string] ) ) [EOL] self . assertFalse ( Solution . isValid ( self , [string] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Callable [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] import unittest [EOL] [EOL] [EOL] class Solution : [EOL] def dfs ( self , grid , row_index , column_index ) : [EOL] if row_index < [number] or column_index < [number] : [EOL] return [EOL] [EOL] if row_index >= len ( grid ) or column_index >= len ( grid [ row_index ] ) : [EOL] return [EOL] [EOL] if grid [ row_index ] [ column_index ] == [string] : [EOL] return [EOL] [EOL] grid [ row_index ] [ column_index ] = [string] [EOL] [EOL] self . dfs ( grid , row_index + [number] , column_index ) [EOL] self . dfs ( grid , row_index - [number] , column_index ) [EOL] self . dfs ( grid , row_index , column_index + [number] ) [EOL] self . dfs ( grid , row_index , column_index - [number] ) [EOL] [EOL] def numIslands ( self , grid ) : [EOL] islands = [number] [EOL] for row_index , row in enumerate ( grid ) : [EOL] for column_index , column in enumerate ( row ) : [EOL] if column == [string] : [EOL] islands += [number] [EOL] self . dfs ( grid , row_index , column_index ) [EOL] [EOL] return islands [EOL] [EOL] [EOL] class Test ( unittest . TestCase ) : [EOL] def test1 ( self ) : [EOL] solution = Solution ( ) [EOL] input = [ [ [string] , [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] , [string] ] , ] [EOL] self . assertEqual ( solution . numIslands ( input ) , [number] ) [EOL] [EOL] def test2 ( self ) : [EOL] solution = Solution ( ) [EOL] input = [ [ [string] , [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] , [string] ] , ] [EOL] self . assertEqual ( solution . numIslands ( input ) , [number] ) [EOL] [EOL] def test3 ( self ) : [EOL] solution = Solution ( ) [EOL] input = [ [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ] [EOL] self . assertEqual ( solution . numIslands ( input ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 $builtins.int$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,None],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0