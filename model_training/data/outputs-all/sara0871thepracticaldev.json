[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , List , Any , Union [EOL] import datetime [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import datetime [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import influxdb as influx_client [EOL] [EOL] from homeassistant . setup import setup_component [EOL] import homeassistant . components . influxdb as influxdb [EOL] from homeassistant . const import EVENT_STATE_CHANGED , STATE_OFF , STATE_ON , STATE_STANDBY [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , mock . Mock ( return_value = [number] ) ) class TestInfluxDB ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . handler_method = None [EOL] self . hass . bus . listen = mock . Mock ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_config_full ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , } } [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . assertTrue ( self . hass . bus . listen . called ) [EOL] self . assertEqual ( EVENT_STATE_CHANGED , self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] ) [EOL] self . assertTrue ( mock_client . return_value . query . called ) [EOL] [EOL] def test_setup_config_defaults ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } } [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . assertTrue ( self . hass . bus . listen . called ) [EOL] self . assertEqual ( EVENT_STATE_CHANGED , self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] ) [EOL] [EOL] def test_setup_minimal_config ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { } } [EOL] [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] [EOL] def test_setup_missing_password ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] } } [EOL] [EOL] assert not setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] [EOL] def test_setup_query_fail ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } } [EOL] mock_client . return_value . query . side_effect = influx_client . exceptions . InfluxDBClientError ( [string] ) [EOL] assert not setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] [EOL] def _setup ( self , ** kwargs ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] ] , [string] : [ [string] ] } } } [EOL] config [ [string] ] . update ( kwargs ) [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] def test_event_listener ( self , mock_client ) : [EOL] [docstring] [EOL] self . _setup ( ) [EOL] [EOL] [comment] [EOL] valid = { [string] : [ None , [number] ] , [string] : [ None , [number] ] , STATE_ON : [ STATE_ON , [number] ] , STATE_OFF : [ STATE_OFF , [number] ] , STATE_STANDBY : [ STATE_STANDBY , None ] , [string] : [ [string] , None ] } [EOL] for in_ , out in valid . items ( ) : [EOL] attrs = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , [string] : [string] } [EOL] state = mock . MagicMock ( state = in_ , domain = [string] , entity_id = [string] , object_id = [string] , attributes = attrs ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] } , } ] [EOL] if out [ [number] ] is not None : [EOL] body [ [number] ] [ [string] ] [ [string] ] = out [ [number] ] [EOL] if out [ [number] ] is not None : [EOL] body [ [number] ] [ [string] ] [ [string] ] = out [ [number] ] [EOL] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_no_units ( self , mock_client ) : [EOL] [docstring] [EOL] self . _setup ( ) [EOL] [EOL] for unit in ( None , [string] ) : [EOL] if unit : [EOL] attrs = { [string] : unit } [EOL] else : [EOL] attrs = { } [EOL] state = mock . MagicMock ( state = [number] , domain = [string] , entity_id = [string] , object_id = [string] , attributes = attrs ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : [number] , [string] : { [string] : [number] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_inf ( self , mock_client ) : [EOL] [docstring] [EOL] self . _setup ( ) [EOL] [EOL] attrs = { [string] : [string] * [number] , [string] : [string] } [EOL] state = mock . MagicMock ( state = [number] , domain = [string] , entity_id = [string] , object_id = [string] , attributes = attrs ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : [number] , [string] : { [string] : [number] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_states ( self , mock_client ) : [EOL] [docstring] [EOL] self . _setup ( ) [EOL] [EOL] for state_state in ( [number] , [string] , [string] , [string] ) : [EOL] state = mock . MagicMock ( state = state_state , domain = [string] , entity_id = [string] , object_id = [string] , attributes = { } ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : [number] , [string] : { [string] : [number] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] if state_state == [number] : [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] else : [EOL] self . assertFalse ( mock_client . return_value . write_points . called ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_blacklist ( self , mock_client ) : [EOL] [docstring] [EOL] self . _setup ( ) [EOL] [EOL] for entity_id in ( [string] , [string] ) : [EOL] state = mock . MagicMock ( state = [number] , domain = [string] , entity_id = [string] . format ( entity_id ) , object_id = entity_id , attributes = { } ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] . format ( entity_id ) , [string] : { [string] : [string] , [string] : entity_id , } , [string] : [number] , [string] : { [string] : [number] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] if entity_id == [string] : [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] else : [EOL] self . assertFalse ( mock_client . return_value . write_points . called ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_blacklist_domain ( self , mock_client ) : [EOL] [docstring] [EOL] self . _setup ( ) [EOL] [EOL] for domain in ( [string] , [string] ) : [EOL] state = mock . MagicMock ( state = [number] , domain = domain , entity_id = [string] . format ( domain ) , object_id = [string] , attributes = { } ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] . format ( domain ) , [string] : { [string] : domain , [string] : [string] , } , [string] : [number] , [string] : { [string] : [number] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] if domain == [string] : [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] else : [EOL] self . assertFalse ( mock_client . return_value . write_points . called ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_whitelist ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] ] , } } } [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] for entity_id in ( [string] , [string] ) : [EOL] state = mock . MagicMock ( state = [number] , domain = [string] , entity_id = [string] . format ( entity_id ) , object_id = entity_id , attributes = { } ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] . format ( entity_id ) , [string] : { [string] : [string] , [string] : entity_id , } , [string] : [number] , [string] : { [string] : [number] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] if entity_id == [string] : [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] else : [EOL] self . assertFalse ( mock_client . return_value . write_points . called ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_whitelist_domain ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] ] , } } } [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] for domain in ( [string] , [string] ) : [EOL] state = mock . MagicMock ( state = [number] , domain = domain , entity_id = [string] . format ( domain ) , object_id = [string] , attributes = { } ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] . format ( domain ) , [string] : { [string] : domain , [string] : [string] , } , [string] : [number] , [string] : { [string] : [number] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] if domain == [string] : [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] else : [EOL] self . assertFalse ( mock_client . return_value . write_points . called ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_invalid_type ( self , mock_client ) : [EOL] [docstring] [EOL] self . _setup ( ) [EOL] [EOL] [comment] [EOL] valid = { [string] : [ None , [number] ] , [string] : [ None , [number] ] , STATE_ON : [ STATE_ON , [number] ] , STATE_OFF : [ STATE_OFF , [number] ] , STATE_STANDBY : [ STATE_STANDBY , None ] , [string] : [ [string] , None ] } [EOL] for in_ , out in valid . items ( ) : [EOL] attrs = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] } [EOL] state = mock . MagicMock ( state = in_ , domain = [string] , entity_id = [string] , object_id = [string] , attributes = attrs ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [string] } , } ] [EOL] if out [ [number] ] is not None : [EOL] body [ [number] ] [ [string] ] [ [string] ] = out [ [number] ] [EOL] if out [ [number] ] is not None : [EOL] body [ [number] ] [ [string] ] [ [string] ] = out [ [number] ] [EOL] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_default_measurement ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] ] } } } [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] for entity_id in ( [string] , [string] ) : [EOL] state = mock . MagicMock ( state = [number] , domain = [string] , entity_id = [string] . format ( entity_id ) , object_id = entity_id , attributes = { } ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] , [string] : { [string] : [string] , [string] : entity_id , } , [string] : [number] , [string] : { [string] : [number] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] if entity_id == [string] : [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] else : [EOL] self . assertFalse ( mock_client . return_value . write_points . called ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_unit_of_measurement_field ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } } [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] attrs = { [string] : [string] , } [EOL] state = mock . MagicMock ( state = [string] , domain = [string] , entity_id = [string] , object_id = [string] , attributes = attrs ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : [number] , [string] : { [string] : [string] , [string] : [string] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_tags_attributes ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] } } [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] attrs = { [string] : [string] , [string] : [string] , } [EOL] state = mock . MagicMock ( state = [number] , domain = [string] , entity_id = [string] , object_id = [string] , attributes = attrs ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : [number] , [string] : { [string] : [number] , [string] : [string] } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_event_listener_component_override_measurement ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] } } , [string] : { [string] : { [string] : [string] } } , [string] : { [string] : { [string] : [string] } } } } [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] test_components = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] for comp in test_components : [EOL] state = mock . MagicMock ( state = [number] , domain = comp [ [string] ] , entity_id = comp [ [string] ] + [string] + comp [ [string] ] , object_id = comp [ [string] ] , attributes = { } ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] body = [ { [string] : comp [ [string] ] , [string] : { [string] : comp [ [string] ] , [string] : comp [ [string] ] } , [string] : [number] , [string] : { [string] : [number] , } , } ] [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . write_points . call_args , mock . call ( body ) ) [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL] [EOL] def test_scheduled_write ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } } [EOL] assert setup_component ( self . hass , influxdb . DOMAIN , config ) [EOL] self . handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] state = mock . MagicMock ( state = [number] , domain = [string] , entity_id = [string] , object_id = [string] , attributes = { } ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] mock_client . return_value . write_points . side_effect = IOError ( [string] ) [EOL] [EOL] [comment] [EOL] with mock . patch . object ( influxdb . time , [string] ) as mock_sleep : [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] assert mock_sleep . called [EOL] json_data = mock_client . return_value . write_points . call_args [ [number] ] [ [number] ] [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] mock_client . return_value . write_points . assert_called_with ( json_data ) [EOL] [EOL] [comment] [EOL] mock_client . return_value . write_points . side_effect = None [EOL] with mock . patch . object ( influxdb . time , [string] ) as mock_sleep : [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] assert not mock_sleep . called [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] [EOL] def test_queue_backlog_full ( self , mock_client ) : [EOL] [docstring] [EOL] self . _setup ( ) [EOL] [EOL] state = mock . MagicMock ( state = [number] , domain = [string] , entity_id = [string] , object_id = [string] , attributes = { } ) [EOL] event = mock . MagicMock ( data = { [string] : state } , time_fired = [number] ) [EOL] [EOL] monotonic_time = [number] [EOL] [EOL] def fast_monotonic ( ) : [EOL] [docstring] [EOL] nonlocal monotonic_time [EOL] monotonic_time += [number] [EOL] return monotonic_time [EOL] [EOL] with mock . patch ( [string] , new = fast_monotonic ) : [EOL] self . handler_method ( event ) [EOL] self . hass . data [ influxdb . DOMAIN ] . block_till_done ( ) [EOL] [EOL] self . assertEqual ( mock_client . return_value . write_points . call_count , [number] ) [EOL] [EOL] mock_client . return_value . write_points . reset_mock ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.list]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.list]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[datetime.datetime,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[datetime.datetime,builtins.str]]$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.list]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.list]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import Mock , patch [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] from homeassistant . components . climate import ( SUPPORT_HOLD_MODE , SUPPORT_OPERATION_MODE , SUPPORT_TARGET_TEMPERATURE , STATE_HEAT , STATE_IDLE ) [EOL] import homeassistant . components . climate . nuheat as nuheat [EOL] from homeassistant . const import TEMP_CELSIUS , TEMP_FAHRENHEIT [EOL] [EOL] SCHEDULE_HOLD = [number] [EOL] SCHEDULE_RUN = [number] [EOL] SCHEDULE_TEMPORARY_HOLD = [number] [EOL] [EOL] [EOL] class TestNuHeat ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] serial_number = [string] [EOL] temperature_unit = [string] [EOL] [EOL] thermostat = Mock ( serial_number = serial_number , room = [string] , online = True , heating = True , temperature = [number] , celsius = [number] , fahrenheit = [number] , max_celsius = [number] , max_fahrenheit = [number] , min_celsius = [number] , min_fahrenheit = [number] , schedule_mode = SCHEDULE_RUN , target_celsius = [number] , target_fahrenheit = [number] ) [EOL] [EOL] thermostat . get_data = Mock ( ) [EOL] thermostat . resume_schedule = Mock ( ) [EOL] [EOL] self . api = Mock ( ) [EOL] self . api . get_thermostat . return_value = thermostat [EOL] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . thermostat = nuheat . NuHeatThermostat ( self . api , serial_number , temperature_unit ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ patch ( [string] ) def test_setup_platform ( self , mocked_thermostat ) : [EOL] [docstring] [EOL] mocked_thermostat . return_value = self . thermostat [EOL] thermostat = mocked_thermostat ( self . api , [string] , [string] ) [EOL] thermostats = [ thermostat ] [EOL] [EOL] self . hass . data [ nuheat . NUHEAT_DOMAIN ] = ( self . api , [ [string] ] ) [EOL] [EOL] config = { } [EOL] add_devices = Mock ( ) [EOL] discovery_info = { } [EOL] [EOL] nuheat . setup_platform ( self . hass , config , add_devices , discovery_info ) [EOL] add_devices . assert_called_once_with ( thermostats , True ) [EOL] [EOL] @ patch ( [string] ) def test_resume_program_service ( self , mocked_thermostat ) : [EOL] [docstring] [EOL] mocked_thermostat . return_value = self . thermostat [EOL] thermostat = mocked_thermostat ( self . api , [string] , [string] ) [EOL] thermostat . resume_program = Mock ( ) [EOL] thermostat . schedule_update_ha_state = Mock ( ) [EOL] thermostat . entity_id = [string] [EOL] [EOL] self . hass . data [ nuheat . NUHEAT_DOMAIN ] = ( self . api , [ [string] ] ) [EOL] nuheat . setup_platform ( self . hass , { } , Mock ( ) , { } ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( nuheat . DOMAIN , nuheat . SERVICE_RESUME_PROGRAM , { [string] : [string] } , True ) [EOL] [EOL] thermostat . resume_program . assert_called_with ( ) [EOL] thermostat . schedule_update_ha_state . assert_called_with ( True ) [EOL] [EOL] thermostat . resume_program . reset_mock ( ) [EOL] thermostat . schedule_update_ha_state . reset_mock ( ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( nuheat . DOMAIN , nuheat . SERVICE_RESUME_PROGRAM , { } , True ) [EOL] [EOL] thermostat . resume_program . assert_called_with ( ) [EOL] thermostat . schedule_update_ha_state . assert_called_with ( True ) [EOL] [EOL] def test_name ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . thermostat . name , [string] ) [EOL] [EOL] def test_icon ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . thermostat . icon , [string] ) [EOL] [EOL] def test_supported_features ( self ) : [EOL] [docstring] [EOL] features = ( SUPPORT_TARGET_TEMPERATURE | SUPPORT_HOLD_MODE | SUPPORT_OPERATION_MODE ) [EOL] self . assertEqual ( self . thermostat . supported_features , features ) [EOL] [EOL] def test_temperature_unit ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . thermostat . temperature_unit , TEMP_FAHRENHEIT ) [EOL] self . thermostat . _temperature_unit = [string] [EOL] self . assertEqual ( self . thermostat . temperature_unit , TEMP_CELSIUS ) [EOL] [EOL] def test_current_temperature ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . thermostat . current_temperature , [number] ) [EOL] self . thermostat . _temperature_unit = [string] [EOL] self . assertEqual ( self . thermostat . current_temperature , [number] ) [EOL] [EOL] def test_current_operation ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . thermostat . current_operation , STATE_HEAT ) [EOL] self . thermostat . _thermostat . heating = False [EOL] self . assertEqual ( self . thermostat . current_operation , STATE_IDLE ) [EOL] [EOL] def test_min_temp ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . thermostat . min_temp , [number] ) [EOL] self . thermostat . _temperature_unit = [string] [EOL] self . assertEqual ( self . thermostat . min_temp , [number] ) [EOL] [EOL] def test_max_temp ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . thermostat . max_temp , [number] ) [EOL] self . thermostat . _temperature_unit = [string] [EOL] self . assertEqual ( self . thermostat . max_temp , [number] ) [EOL] [EOL] def test_target_temperature ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . thermostat . target_temperature , [number] ) [EOL] self . thermostat . _temperature_unit = [string] [EOL] self . assertEqual ( self . thermostat . target_temperature , [number] ) [EOL] [EOL] def test_current_hold_mode ( self ) : [EOL] [docstring] [EOL] self . thermostat . _thermostat . schedule_mode = SCHEDULE_RUN [EOL] self . assertEqual ( self . thermostat . current_hold_mode , nuheat . MODE_AUTO ) [EOL] [EOL] self . thermostat . _thermostat . schedule_mode = SCHEDULE_HOLD [EOL] self . assertEqual ( self . thermostat . current_hold_mode , nuheat . MODE_HOLD_TEMPERATURE ) [EOL] [EOL] self . thermostat . _thermostat . schedule_mode = SCHEDULE_TEMPORARY_HOLD [EOL] self . assertEqual ( self . thermostat . current_hold_mode , nuheat . MODE_TEMPORARY_HOLD ) [EOL] [EOL] self . thermostat . _thermostat . schedule_mode = None [EOL] self . assertEqual ( self . thermostat . current_hold_mode , nuheat . MODE_AUTO ) [EOL] [EOL] def test_operation_list ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . thermostat . operation_list , [ STATE_HEAT , STATE_IDLE ] ) [EOL] [EOL] def test_resume_program ( self ) : [EOL] [docstring] [EOL] self . thermostat . resume_program ( ) [EOL] self . thermostat . _thermostat . resume_schedule . assert_called_once_with ( ) [EOL] self . assertTrue ( self . thermostat . _force_update ) [EOL] [EOL] def test_set_hold_mode ( self ) : [EOL] [docstring] [EOL] self . thermostat . set_hold_mode ( [string] ) [EOL] self . assertEqual ( self . thermostat . _thermostat . schedule_mode , SCHEDULE_HOLD ) [EOL] self . assertTrue ( self . thermostat . _force_update ) [EOL] [EOL] self . thermostat . set_hold_mode ( [string] ) [EOL] self . assertEqual ( self . thermostat . _thermostat . schedule_mode , SCHEDULE_TEMPORARY_HOLD ) [EOL] self . assertTrue ( self . thermostat . _force_update ) [EOL] [EOL] self . thermostat . set_hold_mode ( [string] ) [EOL] self . assertEqual ( self . thermostat . _thermostat . schedule_mode , SCHEDULE_RUN ) [EOL] self . assertTrue ( self . thermostat . _force_update ) [EOL] [EOL] def test_set_temperature ( self ) : [EOL] [docstring] [EOL] self . thermostat . set_temperature ( temperature = [number] ) [EOL] self . assertEqual ( self . thermostat . _thermostat . target_fahrenheit , [number] ) [EOL] self . assertTrue ( self . thermostat . _force_update ) [EOL] [EOL] self . thermostat . _temperature_unit = [string] [EOL] self . thermostat . set_temperature ( temperature = [number] ) [EOL] self . assertEqual ( self . thermostat . _thermostat . target_celsius , [number] ) [EOL] self . assertTrue ( self . thermostat . _force_update ) [EOL] [EOL] @ patch . object ( nuheat . NuHeatThermostat , [string] ) def test_update_without_throttle ( self , throttled_update ) : [EOL] [docstring] [EOL] self . thermostat . _force_update = True [EOL] self . thermostat . update ( ) [EOL] throttled_update . assert_called_once_with ( no_throttle = True ) [EOL] self . assertFalse ( self . thermostat . _force_update ) [EOL] [EOL] @ patch . object ( nuheat . NuHeatThermostat , [string] ) def test_update_with_throttle ( self , throttled_update ) : [EOL] [docstring] [EOL] self . thermostat . _force_update = False [EOL] self . thermostat . update ( ) [EOL] throttled_update . assert_called_once_with ( ) [EOL] self . assertFalse ( self . thermostat . _force_update ) [EOL] [EOL] def test_throttled_update ( self ) : [EOL] [docstring] [EOL] self . thermostat . _throttled_update ( ) [EOL] self . thermostat . _thermostat . get_data . assert_called_once_with ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $unittest.mock.Mock$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $unittest.mock.Mock$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Dict , List , Any , Union [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] import unittest [EOL] from unittest . mock import MagicMock , patch [EOL] from datetime import timedelta [EOL] [EOL] from requests . exceptions import HTTPError [EOL] import requests_mock [EOL] [EOL] import forecastio [EOL] [EOL] from homeassistant . components . sensor import darksky [EOL] from homeassistant . setup import setup_component [EOL] [EOL] from tests . common import ( load_fixture , get_test_home_assistant , MockDependency ) [EOL] [EOL] VALID_CONFIG_MINIMAL = { [string] : { [string] : [string] , [string] : [string] , [string] : [ [number] , [number] ] , [string] : [ [string] , [string] , [string] ] , [string] : timedelta ( seconds = [number] ) , } } [EOL] [EOL] INVALID_CONFIG_MINIMAL = { [string] : { [string] : [string] , [string] : [string] , [string] : [ [number] , [number] ] , [string] : [ [string] , [string] , [string] ] , [string] : timedelta ( seconds = [number] ) , } } [EOL] [EOL] VALID_CONFIG_LANG_DE = { [string] : { [string] : [string] , [string] : [string] , [string] : [ [number] , [number] ] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : timedelta ( seconds = [number] ) , } } [EOL] [EOL] INVALID_CONFIG_LANG = { [string] : { [string] : [string] , [string] : [string] , [string] : [ [number] , [number] ] , [string] : [string] , [string] : [ [string] , [string] , [string] ] , [string] : timedelta ( seconds = [number] ) , } } [EOL] [EOL] [EOL] def load_forecastMock ( key , lat , lon , units , lang ) : [comment] [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class TestDarkSkySetup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def add_entities ( self , new_entities , update_before_add = False ) : [EOL] [docstring] [EOL] if update_before_add : [EOL] for entity in new_entities : [EOL] entity . update ( ) [EOL] [EOL] for entity in new_entities : [EOL] self . entities . append ( entity ) [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . key = [string] [EOL] self . lat = self . hass . config . latitude = [number] [EOL] self . lon = self . hass . config . longitude = - [number] [EOL] self . entities = [ ] [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = load_forecastMock ) def test_setup_with_config ( self , mock_forecastio ) : [EOL] [docstring] [EOL] setup_component ( self . hass , [string] , VALID_CONFIG_MINIMAL ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is not None [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = load_forecastMock ) def test_setup_with_invalid_config ( self , mock_forecastio ) : [EOL] [docstring] [EOL] setup_component ( self . hass , [string] , INVALID_CONFIG_MINIMAL ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is None [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = load_forecastMock ) def test_setup_with_language_config ( self , mock_forecastio ) : [EOL] [docstring] [EOL] setup_component ( self . hass , [string] , VALID_CONFIG_LANG_DE ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is not None [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = load_forecastMock ) def test_setup_with_invalid_language_config ( self , mock_forecastio ) : [EOL] [docstring] [EOL] setup_component ( self . hass , [string] , INVALID_CONFIG_LANG ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is None [EOL] [EOL] @ patch ( [string] ) def test_setup_bad_api_key ( self , mock_get_forecast ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] url = [string] . format ( self . key , str ( self . lat ) , str ( self . lon ) ) [EOL] msg = [string] . format ( url ) [EOL] mock_get_forecast . side_effect = HTTPError ( msg , ) [EOL] [EOL] response = darksky . setup_platform ( self . hass , VALID_CONFIG_MINIMAL , MagicMock ( ) ) [EOL] self . assertFalse ( response ) [EOL] [EOL] @ requests_mock . Mocker ( ) @ patch ( [string] , wraps = forecastio . api . get_forecast ) def test_setup ( self , mock_req , mock_get_forecast ) : [EOL] [docstring] [EOL] uri = ( [string] [string] ) [EOL] mock_req . get ( re . compile ( uri ) , text = load_fixture ( [string] ) ) [EOL] [EOL] assert setup_component ( self . hass , [string] , VALID_CONFIG_MINIMAL ) [EOL] [EOL] self . assertTrue ( mock_get_forecast . called ) [EOL] self . assertEqual ( mock_get_forecast . call_count , [number] ) [EOL] self . assertEqual ( len ( self . hass . states . entity_ids ( ) ) , [number] ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is not None [EOL] self . assertEqual ( state . state , [string] ) [EOL] self . assertEqual ( state . attributes . get ( [string] ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],typing.List[builtins.str],datetime.timedelta,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from aiohttp . web_exceptions import HTTPInternalServerError [EOL] import pytest [EOL] [EOL] from homeassistant . components . http . view import HomeAssistantView [EOL] [EOL] [EOL] async def test_invalid_json ( caplog ) : [EOL] [docstring] [EOL] view = HomeAssistantView ( ) [EOL] [EOL] with pytest . raises ( HTTPInternalServerError ) : [EOL] view . json ( object ) [EOL] [EOL] assert str ( object ) in caplog . text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Any , Type [EOL] import typing [EOL] import tests [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import MagicMock [EOL] [EOL] import requests_mock [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components . binary_sensor import sleepiq [EOL] [EOL] from tests . components . test_sleepiq import mock_responses [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class TestSleepIQBinarySensorSetup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] DEVICES = [ ] [EOL] [EOL] def add_devices ( self , devices ) : [EOL] [docstring] [EOL] for device in devices : [EOL] self . DEVICES . append ( device ) [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . username = [string] [EOL] self . password = [string] [EOL] self . config = { [string] : self . username , [string] : self . password , } [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ requests_mock . Mocker ( ) def test_setup ( self , mock ) : [EOL] [docstring] [EOL] mock_responses ( mock ) [EOL] [EOL] setup_component ( self . hass , [string] , { [string] : self . config } ) [EOL] [EOL] sleepiq . setup_platform ( self . hass , self . config , self . add_devices , MagicMock ( ) ) [EOL] self . assertEqual ( [number] , len ( self . DEVICES ) ) [EOL] [EOL] left_side = self . DEVICES [ [number] ] [EOL] self . assertEqual ( [string] , left_side . name ) [EOL] self . assertEqual ( [string] , left_side . state ) [EOL] [EOL] right_side = self . DEVICES [ [number] ] [EOL] self . assertEqual ( [string] , right_side . name ) [EOL] self . assertEqual ( [string] , right_side . state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import jinja2 [EOL] [docstring] [EOL] import jinja2 [EOL] [EOL] [EOL] class HomeAssistantError ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidEntityFormatError ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class NoEntitySpecifiedError ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class TemplateError ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , exception ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( [string] . format ( exception . __class__ . __name__ , exception ) ) [EOL] [EOL] [EOL] class PlatformNotReady ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidStateError ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $jinja2.TemplateError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.TemplateError$ 0 0 0 0 0 $jinja2.TemplateError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Set , Coroutine , Any [EOL] import typing [EOL] import asyncio [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from homeassistant . const import DEVICE_DEFAULT_NAME [EOL] from homeassistant . core import callback , valid_entity_id , split_entity_id [EOL] from homeassistant . exceptions import HomeAssistantError , PlatformNotReady [EOL] from homeassistant . util . async_ import ( run_callback_threadsafe , run_coroutine_threadsafe ) [EOL] [EOL] from . event import async_track_time_interval , async_call_later [EOL] from . entity_registry import async_get_registry [EOL] [EOL] SLOW_SETUP_WARNING = [number] [EOL] SLOW_SETUP_MAX_WAIT = [number] [EOL] PLATFORM_NOT_READY_RETRIES = [number] [EOL] [EOL] [EOL] class EntityPlatform : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * , hass , logger , domain , platform_name , platform , scan_interval , entity_namespace , async_entities_added_callback ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . logger = logger [EOL] self . domain = domain [EOL] self . platform_name = platform_name [EOL] self . platform = platform [EOL] self . scan_interval = scan_interval [EOL] self . entity_namespace = entity_namespace [EOL] self . async_entities_added_callback = async_entities_added_callback [EOL] self . config_entry = None [EOL] self . entities = { } [EOL] self . _tasks = [ ] [EOL] [comment] [EOL] self . _async_unsub_polling = None [EOL] [comment] [EOL] self . _async_cancel_retry_setup = None [EOL] self . _process_updates = asyncio . Lock ( loop = hass . loop ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if platform is None : [EOL] self . parallel_updates = None [EOL] return [EOL] [EOL] [comment] [EOL] if hasattr ( platform , [string] ) : [EOL] default_parallel_updates = [number] [EOL] else : [EOL] default_parallel_updates = [number] [EOL] [EOL] parallel_updates = getattr ( platform , [string] , default_parallel_updates ) [EOL] [EOL] if parallel_updates : [EOL] self . parallel_updates = asyncio . Semaphore ( parallel_updates , loop = hass . loop ) [EOL] else : [EOL] self . parallel_updates = None [EOL] [EOL] async def async_setup ( self , platform_config , discovery_info = None ) : [EOL] [docstring] [EOL] platform = self . platform [EOL] hass = self . hass [EOL] [EOL] @ callback def async_create_setup_task ( ) : [EOL] [docstring] [EOL] if getattr ( platform , [string] , None ) : [EOL] return platform . async_setup_platform ( hass , platform_config , self . _async_schedule_add_entities , discovery_info ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] return hass . loop . run_in_executor ( None , platform . setup_platform , hass , platform_config , self . _schedule_add_entities , discovery_info ) [EOL] await self . _async_setup_platform ( async_create_setup_task ) [EOL] [EOL] async def async_setup_entry ( self , config_entry ) : [EOL] [docstring] [EOL] [comment] [EOL] self . config_entry = config_entry [EOL] platform = self . platform [EOL] [EOL] @ callback def async_create_setup_task ( ) : [EOL] [docstring] [EOL] return platform . async_setup_entry ( self . hass , config_entry , self . _async_schedule_add_entities ) [EOL] [EOL] return await self . _async_setup_platform ( async_create_setup_task ) [EOL] [EOL] async def _async_setup_platform ( self , async_create_setup_task , tries = [number] ) : [EOL] [docstring] [EOL] logger = self . logger [EOL] hass = self . hass [EOL] full_name = [string] . format ( self . domain , self . platform_name ) [EOL] [EOL] logger . info ( [string] , full_name ) [EOL] warn_task = hass . loop . call_later ( SLOW_SETUP_WARNING , logger . warning , [string] , self . platform_name , SLOW_SETUP_WARNING ) [EOL] [EOL] try : [EOL] task = async_create_setup_task ( ) [EOL] [EOL] await asyncio . wait_for ( asyncio . shield ( task , loop = hass . loop ) , SLOW_SETUP_MAX_WAIT , loop = hass . loop ) [EOL] [EOL] [comment] [EOL] if self . _tasks : [EOL] pending = [ task for task in self . _tasks if not task . done ( ) ] [EOL] self . _tasks . clear ( ) [EOL] [EOL] if pending : [EOL] await asyncio . wait ( pending , loop = self . hass . loop ) [EOL] [EOL] hass . config . components . add ( full_name ) [EOL] return True [EOL] except PlatformNotReady : [EOL] tries += [number] [EOL] wait_time = min ( tries , [number] ) * [number] [EOL] logger . warning ( [string] , self . platform_name , wait_time ) [EOL] [EOL] async def setup_again ( now ) : [EOL] [docstring] [EOL] self . _async_cancel_retry_setup = None [EOL] await self . _async_setup_platform ( async_create_setup_task , tries ) [EOL] [EOL] self . _async_cancel_retry_setup = async_call_later ( hass , wait_time , setup_again ) [EOL] return False [EOL] except asyncio . TimeoutError : [EOL] logger . error ( [string] [string] , self . platform_name , SLOW_SETUP_MAX_WAIT ) [EOL] return False [EOL] except Exception : [comment] [EOL] logger . exception ( [string] , self . platform_name ) [EOL] return False [EOL] finally : [EOL] warn_task . cancel ( ) [EOL] [EOL] def _schedule_add_entities ( self , new_entities , update_before_add = False ) : [EOL] [docstring] [EOL] run_callback_threadsafe ( self . hass . loop , self . _async_schedule_add_entities , list ( new_entities ) , update_before_add ) . result ( ) [EOL] [EOL] @ callback def _async_schedule_add_entities ( self , new_entities , update_before_add = False ) : [EOL] [docstring] [EOL] self . _tasks . append ( self . hass . async_add_job ( self . async_add_entities ( new_entities , update_before_add = update_before_add ) ) ) [EOL] [EOL] def add_entities ( self , new_entities , update_before_add = False ) : [EOL] [docstring] [EOL] [comment] [EOL] if update_before_add : [EOL] self . logger . warning ( [string] [string] ) [EOL] [EOL] run_coroutine_threadsafe ( self . async_add_entities ( list ( new_entities ) , update_before_add ) , self . hass . loop ) . result ( ) [EOL] [EOL] async def async_add_entities ( self , new_entities , update_before_add = False ) : [EOL] [docstring] [EOL] [comment] [EOL] if not new_entities : [EOL] return [EOL] [EOL] hass = self . hass [EOL] component_entities = set ( hass . states . async_entity_ids ( self . domain ) ) [EOL] [EOL] registry = await async_get_registry ( hass ) [EOL] [EOL] tasks = [ self . _async_add_entity ( entity , update_before_add , component_entities , registry ) for entity in new_entities ] [EOL] [EOL] [comment] [EOL] if not tasks : [EOL] return [EOL] [EOL] await asyncio . wait ( tasks , loop = self . hass . loop ) [EOL] self . async_entities_added_callback ( ) [EOL] [EOL] if self . _async_unsub_polling is not None or not any ( entity . should_poll for entity in self . entities . values ( ) ) : [EOL] return [EOL] [EOL] self . _async_unsub_polling = async_track_time_interval ( self . hass , self . _update_entity_states , self . scan_interval ) [EOL] [EOL] async def _async_add_entity ( self , entity , update_before_add , component_entities , registry ) : [EOL] [docstring] [EOL] if entity is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] entity . hass = self . hass [EOL] entity . platform = self [EOL] entity . parallel_updates = self . parallel_updates [EOL] [EOL] [comment] [EOL] if update_before_add : [EOL] try : [EOL] await entity . async_device_update ( warning = False ) [EOL] except Exception : [comment] [EOL] self . logger . exception ( [string] , self . platform_name ) [EOL] return [EOL] [EOL] suggested_object_id = None [EOL] [EOL] [comment] [EOL] if entity . unique_id is not None : [EOL] if entity . entity_id is not None : [EOL] suggested_object_id = split_entity_id ( entity . entity_id ) [ [number] ] [EOL] else : [EOL] suggested_object_id = entity . name [EOL] [EOL] if self . entity_namespace is not None : [EOL] suggested_object_id = [string] . format ( self . entity_namespace , suggested_object_id ) [EOL] [EOL] if self . config_entry is not None : [EOL] config_entry_id = self . config_entry . entry_id [EOL] else : [EOL] config_entry_id = None [EOL] [EOL] entry = registry . async_get_or_create ( self . domain , self . platform_name , entity . unique_id , suggested_object_id = suggested_object_id , config_entry_id = config_entry_id ) [EOL] [EOL] if entry . disabled : [EOL] self . logger . info ( [string] , entry . name or entity . name or [string] . format ( self . platform_name , entity . unique_id ) ) [EOL] return [EOL] [EOL] entity . entity_id = entry . entity_id [EOL] entity . registry_name = entry . name [EOL] entity . async_on_remove ( entry . add_update_listener ( entity ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] elif ( entity . entity_id is not None and registry . async_is_registered ( entity . entity_id ) ) : [EOL] [comment] [EOL] suggested_object_id = split_entity_id ( entity . entity_id ) [ [number] ] [EOL] entity . entity_id = None [EOL] [EOL] [comment] [EOL] if entity . entity_id is None : [EOL] suggested_object_id = suggested_object_id or entity . name or DEVICE_DEFAULT_NAME [EOL] [EOL] if self . entity_namespace is not None : [EOL] suggested_object_id = [string] . format ( self . entity_namespace , suggested_object_id ) [EOL] [EOL] entity . entity_id = registry . async_generate_entity_id ( self . domain , suggested_object_id ) [EOL] [EOL] [comment] [EOL] if not valid_entity_id ( entity . entity_id ) : [EOL] raise HomeAssistantError ( [string] . format ( entity . entity_id ) ) [EOL] elif entity . entity_id in component_entities : [EOL] msg = [string] . format ( entity . entity_id ) [EOL] if entity . unique_id is not None : [EOL] msg += [string] . format ( self . platform_name ) [EOL] raise HomeAssistantError ( msg ) [EOL] [EOL] self . entities [ entity . entity_id ] = entity [EOL] component_entities . add ( entity . entity_id ) [EOL] [EOL] if hasattr ( entity , [string] ) : [EOL] await entity . async_added_to_hass ( ) [EOL] [EOL] await entity . async_update_ha_state ( ) [EOL] [EOL] async def async_reset ( self ) : [EOL] [docstring] [EOL] if self . _async_cancel_retry_setup is not None : [EOL] self . _async_cancel_retry_setup ( ) [EOL] self . _async_cancel_retry_setup = None [EOL] [EOL] if not self . entities : [EOL] return [EOL] [EOL] tasks = [ self . _async_remove_entity ( entity_id ) for entity_id in self . entities ] [EOL] [EOL] await asyncio . wait ( tasks , loop = self . hass . loop ) [EOL] [EOL] if self . _async_unsub_polling is not None : [EOL] self . _async_unsub_polling ( ) [EOL] self . _async_unsub_polling = None [EOL] [EOL] async def async_remove_entity ( self , entity_id ) : [EOL] [docstring] [EOL] await self . _async_remove_entity ( entity_id ) [EOL] [EOL] [comment] [EOL] if ( self . _async_unsub_polling is not None and not any ( entity . should_poll for entity in self . entities . values ( ) ) ) : [EOL] self . _async_unsub_polling ( ) [EOL] self . _async_unsub_polling = None [EOL] [EOL] async def _async_remove_entity ( self , entity_id ) : [EOL] [docstring] [EOL] entity = self . entities . pop ( entity_id ) [EOL] [EOL] if hasattr ( entity , [string] ) : [EOL] await entity . async_will_remove_from_hass ( ) [EOL] [EOL] self . hass . states . async_remove ( entity_id ) [EOL] [EOL] async def _update_entity_states ( self , now ) : [EOL] [docstring] [EOL] if self . _process_updates . locked ( ) : [EOL] self . logger . warning ( [string] [string] , self . platform_name , self . domain , self . scan_interval ) [EOL] return [EOL] [EOL] async with self . _process_updates : [EOL] tasks = [ ] [EOL] for entity in self . entities . values ( ) : [EOL] if not entity . should_poll : [EOL] continue [EOL] tasks . append ( entity . async_update_ha_state ( True ) ) [EOL] [EOL] if tasks : [EOL] await asyncio . wait ( tasks , loop = self . hass . loop ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.locks.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Coroutine[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Coroutine[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Coroutine[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $None$ 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Coroutine[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Coroutine[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_HOST , CONF_PASSWORD , CONF_PORT [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers import discovery [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . dispatcher import ( async_dispatcher_connect , async_dispatcher_send ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] SIGNAL_MESSAGE_REQUEST = [string] [EOL] SIGNAL_MESSAGE_UPDATE = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_PORT ) : int , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config . get ( DOMAIN ) [EOL] [EOL] host = conf . get ( CONF_HOST ) [EOL] port = conf . get ( CONF_PORT ) [EOL] password = conf . get ( CONF_PASSWORD ) [EOL] [EOL] hass . data [ DOMAIN ] = AsteriskData ( hass , host , port , password ) [EOL] [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class AsteriskData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , host , port , password ) : [EOL] [docstring] [EOL] from asterisk_mbox import Client as asteriskClient [EOL] [EOL] self . hass = hass [EOL] self . client = asteriskClient ( host , port , password , self . handle_data ) [EOL] self . messages = [ ] [EOL] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_MESSAGE_REQUEST , self . _request_messages ) [EOL] [EOL] @ callback def handle_data ( self , command , msg ) : [EOL] [docstring] [EOL] from asterisk_mbox . commands import CMD_MESSAGE_LIST [EOL] [EOL] if command == CMD_MESSAGE_LIST : [EOL] _LOGGER . debug ( [string] ) [EOL] self . messages = sorted ( msg , key = lambda item : item [ [string] ] [ [string] ] , reverse = True ) [EOL] async_dispatcher_send ( self . hass , SIGNAL_MESSAGE_UPDATE , self . messages ) [EOL] [EOL] @ callback def _request_messages ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] self . client . messages ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , Generator , Any , List [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , EVENT_HOMEASSISTANT_START , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . helpers . dispatcher import ( async_dispatcher_send , async_dispatcher_connect ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SERVICE_START = [string] [EOL] SERVICE_STOP = [string] [EOL] SERVICE_RESTART = [string] [EOL] [EOL] SIGNAL_FFMPEG_START = [string] [EOL] SIGNAL_FFMPEG_STOP = [string] [EOL] SIGNAL_FFMPEG_RESTART = [string] [EOL] [EOL] DATA_FFMPEG = [string] [EOL] [EOL] CONF_INITIAL_STATE = [string] [EOL] CONF_INPUT = [string] [EOL] CONF_FFMPEG_BIN = [string] [EOL] CONF_EXTRA_ARGUMENTS = [string] [EOL] CONF_OUTPUT = [string] [EOL] CONF_RUN_TEST = [string] [EOL] [EOL] DEFAULT_BINARY = [string] [EOL] DEFAULT_RUN_TEST = True [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Optional ( CONF_FFMPEG_BIN , default = DEFAULT_BINARY ) : cv . string , vol . Optional ( CONF_RUN_TEST , default = DEFAULT_RUN_TEST ) : cv . boolean , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] SERVICE_FFMPEG_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] [EOL] @ callback def async_start ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else { } [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_START , data ) ) [EOL] [EOL] [EOL] @ callback def async_stop ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else { } [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_STOP , data ) ) [EOL] [EOL] [EOL] @ callback def async_restart ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else { } [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_RESTART , data ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config . get ( DOMAIN , { } ) [EOL] [EOL] manager = FFmpegManager ( hass , conf . get ( CONF_FFMPEG_BIN , DEFAULT_BINARY ) , conf . get ( CONF_RUN_TEST , DEFAULT_RUN_TEST ) ) [EOL] [EOL] [comment] [EOL] @ asyncio . coroutine def async_service_handle ( service ) : [EOL] [docstring] [EOL] entity_ids = service . data . get ( ATTR_ENTITY_ID ) [EOL] [EOL] if service . service == SERVICE_START : [EOL] async_dispatcher_send ( hass , SIGNAL_FFMPEG_START , entity_ids ) [EOL] elif service . service == SERVICE_STOP : [EOL] async_dispatcher_send ( hass , SIGNAL_FFMPEG_STOP , entity_ids ) [EOL] else : [EOL] async_dispatcher_send ( hass , SIGNAL_FFMPEG_RESTART , entity_ids ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_START , async_service_handle , schema = SERVICE_FFMPEG_SCHEMA ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_STOP , async_service_handle , schema = SERVICE_FFMPEG_SCHEMA ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_RESTART , async_service_handle , schema = SERVICE_FFMPEG_SCHEMA ) [EOL] [EOL] hass . data [ DATA_FFMPEG ] = manager [EOL] return True [EOL] [EOL] [EOL] class FFmpegManager : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , ffmpeg_bin , run_test ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _cache = { } [EOL] self . _bin = ffmpeg_bin [EOL] self . _run_test = run_test [EOL] [EOL] @ property def binary ( self ) : [EOL] [docstring] [EOL] return self . _bin [EOL] [EOL] @ asyncio . coroutine def async_run_test ( self , input_source ) : [EOL] [docstring] [EOL] from haffmpeg import Test [EOL] [EOL] if self . _run_test : [EOL] [comment] [EOL] if input_source in self . _cache : [EOL] return self . _cache [ input_source ] [EOL] [EOL] [comment] [EOL] ffmpeg_test = Test ( self . binary , loop = self . hass . loop ) [EOL] success = yield from ffmpeg_test . run_test ( input_source ) [EOL] if not success : [EOL] _LOGGER . error ( [string] , input_source ) [EOL] self . _cache [ input_source ] = False [EOL] return False [EOL] self . _cache [ input_source ] = True [EOL] return True [EOL] [EOL] [EOL] class FFmpegBase ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , initial_state = True ) : [EOL] [docstring] [EOL] self . ffmpeg = None [EOL] self . initial_state = initial_state [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_FFMPEG_START , self . _async_start_ffmpeg ) [EOL] async_dispatcher_connect ( self . hass , SIGNAL_FFMPEG_STOP , self . _async_stop_ffmpeg ) [EOL] async_dispatcher_connect ( self . hass , SIGNAL_FFMPEG_RESTART , self . _async_restart_ffmpeg ) [EOL] [EOL] [comment] [EOL] self . _async_register_events ( ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . ffmpeg . is_running [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ asyncio . coroutine def _async_start_ffmpeg ( self , entity_ids ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ asyncio . coroutine def _async_stop_ffmpeg ( self , entity_ids ) : [EOL] [docstring] [EOL] if entity_ids is None or self . entity_id in entity_ids : [EOL] yield from self . ffmpeg . close ( ) [EOL] [EOL] @ asyncio . coroutine def _async_restart_ffmpeg ( self , entity_ids ) : [EOL] [docstring] [EOL] if entity_ids is None or self . entity_id in entity_ids : [EOL] yield from self . _async_stop_ffmpeg ( None ) [EOL] yield from self . _async_start_ffmpeg ( None ) [EOL] [EOL] @ callback def _async_register_events ( self ) : [EOL] [docstring] [EOL] @ asyncio . coroutine def async_shutdown_handle ( event ) : [EOL] [docstring] [EOL] yield from self . _async_stop_ffmpeg ( None ) [EOL] [EOL] self . hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , async_shutdown_handle ) [EOL] [EOL] [comment] [EOL] if not self . initial_state : [EOL] return [EOL] [EOL] @ asyncio . coroutine def async_start_handle ( event ) : [EOL] [docstring] [EOL] yield from self . _async_start_ffmpeg ( None ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] self . hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_START , async_start_handle ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from binascii import hexlify , unhexlify [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( EVENT_HOMEASSISTANT_STOP , CONF_DEVICE , CONF_NAME , CONF_PIN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . dispatcher import ( async_dispatcher_connect , dispatcher_send ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] SIGNAL_ZIGBEE_FRAME_RECEIVED = [string] [EOL] [EOL] CONF_ADDRESS = [string] [EOL] CONF_BAUD = [string] [EOL] [EOL] DEFAULT_DEVICE = [string] [EOL] DEFAULT_BAUD = [number] [EOL] DEFAULT_ADC_MAX_VOLTS = [number] [EOL] [EOL] [comment] [EOL] GPIO_DIGITAL_OUTPUT_LOW = None [EOL] GPIO_DIGITAL_OUTPUT_HIGH = None [EOL] ADC_PERCENTAGE = None [EOL] DIGITAL_PINS = None [EOL] ANALOG_PINS = None [EOL] CONVERT_ADC = None [EOL] ZIGBEE_EXCEPTION = None [EOL] ZIGBEE_TX_FAILURE = None [EOL] [EOL] ATTR_FRAME = [string] [EOL] [EOL] DEVICE = None [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Optional ( CONF_BAUD , default = DEFAULT_BAUD ) : cv . string , vol . Optional ( CONF_DEVICE , default = DEFAULT_DEVICE ) : cv . string , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] PLATFORM_SCHEMA = vol . Schema ( { vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_PIN ) : cv . positive_int , vol . Optional ( CONF_ADDRESS ) : cv . string , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] global DEVICE [EOL] global GPIO_DIGITAL_OUTPUT_LOW [EOL] global GPIO_DIGITAL_OUTPUT_HIGH [EOL] global ADC_PERCENTAGE [EOL] global DIGITAL_PINS [EOL] global ANALOG_PINS [EOL] global CONVERT_ADC [EOL] global ZIGBEE_EXCEPTION [EOL] global ZIGBEE_TX_FAILURE [EOL] [EOL] import xbee_helper . const as xb_const [EOL] from xbee_helper import ZigBee [EOL] from xbee_helper . device import convert_adc [EOL] from xbee_helper . exceptions import ZigBeeException , ZigBeeTxFailure [EOL] from serial import Serial , SerialException [EOL] [EOL] GPIO_DIGITAL_OUTPUT_LOW = xb_const . GPIO_DIGITAL_OUTPUT_LOW [EOL] GPIO_DIGITAL_OUTPUT_HIGH = xb_const . GPIO_DIGITAL_OUTPUT_HIGH [EOL] ADC_PERCENTAGE = xb_const . ADC_PERCENTAGE [EOL] DIGITAL_PINS = xb_const . DIGITAL_PINS [EOL] ANALOG_PINS = xb_const . ANALOG_PINS [EOL] CONVERT_ADC = convert_adc [EOL] ZIGBEE_EXCEPTION = ZigBeeException [EOL] ZIGBEE_TX_FAILURE = ZigBeeTxFailure [EOL] [EOL] usb_device = config [ DOMAIN ] . get ( CONF_DEVICE , DEFAULT_DEVICE ) [EOL] baud = int ( config [ DOMAIN ] . get ( CONF_BAUD , DEFAULT_BAUD ) ) [EOL] try : [EOL] ser = Serial ( usb_device , baud ) [EOL] except SerialException as exc : [EOL] _LOGGER . exception ( [string] , exc ) [EOL] return False [EOL] DEVICE = ZigBee ( ser ) [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , close_serial_port ) [EOL] [EOL] def _frame_received ( frame ) : [EOL] [docstring] [EOL] dispatcher_send ( hass , SIGNAL_ZIGBEE_FRAME_RECEIVED , frame ) [EOL] [EOL] DEVICE . add_frame_rx_handler ( _frame_received ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def close_serial_port ( * args ) : [EOL] [docstring] [EOL] DEVICE . zb . serial . close ( ) [EOL] [EOL] [EOL] def frame_is_relevant ( entity , frame ) : [EOL] [docstring] [EOL] if frame . get ( [string] ) != entity . config . address : [EOL] return False [EOL] if [string] not in frame : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] class ZigBeeConfig : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . _config = config [EOL] self . _should_poll = config . get ( [string] , True ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _config [ [string] ] [EOL] [EOL] @ property def address ( self ) : [EOL] [docstring] [EOL] address = self . _config . get ( [string] ) [EOL] if address is not None : [EOL] address = unhexlify ( address ) [EOL] return address [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return self . _should_poll [EOL] [EOL] [EOL] class ZigBeePinConfig ( ZigBeeConfig ) : [EOL] [docstring] [EOL] [EOL] @ property def pin ( self ) : [EOL] [docstring] [EOL] return self . _config [ [string] ] [EOL] [EOL] [EOL] class ZigBeeDigitalInConfig ( ZigBeePinConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] super ( ZigBeeDigitalInConfig , self ) . __init__ ( config ) [EOL] self . _bool2state , self . _state2bool = self . boolean_maps [EOL] [EOL] @ property def boolean_maps ( self ) : [EOL] [docstring] [EOL] if self . _config . get ( [string] , [string] ) . lower ( ) == [string] : [EOL] bool2state = { True : False , False : True } [EOL] else : [EOL] bool2state = { True : True , False : False } [EOL] state2bool = { v : k for k , v in bool2state . items ( ) } [EOL] return bool2state , state2bool [EOL] [EOL] @ property def bool2state ( self ) : [EOL] [docstring] [EOL] return self . _bool2state [EOL] [EOL] @ property def state2bool ( self ) : [EOL] [docstring] [EOL] return self . _state2bool [EOL] [EOL] [EOL] class ZigBeeDigitalOutConfig ( ZigBeePinConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] super ( ZigBeeDigitalOutConfig , self ) . __init__ ( config ) [EOL] self . _bool2state , self . _state2bool = self . boolean_maps [EOL] self . _should_poll = config . get ( [string] , False ) [EOL] [EOL] @ property def boolean_maps ( self ) : [EOL] [docstring] [EOL] if self . _config . get ( [string] , [string] ) . lower ( ) == [string] : [EOL] bool2state = { True : GPIO_DIGITAL_OUTPUT_LOW , False : GPIO_DIGITAL_OUTPUT_HIGH } [EOL] else : [EOL] bool2state = { True : GPIO_DIGITAL_OUTPUT_HIGH , False : GPIO_DIGITAL_OUTPUT_LOW } [EOL] state2bool = { v : k for k , v in bool2state . items ( ) } [EOL] return bool2state , state2bool [EOL] [EOL] @ property def bool2state ( self ) : [EOL] [docstring] [EOL] return self . _bool2state [EOL] [EOL] @ property def state2bool ( self ) : [EOL] [docstring] [EOL] return self . _state2bool [EOL] [EOL] [EOL] class ZigBeeAnalogInConfig ( ZigBeePinConfig ) : [EOL] [docstring] [EOL] [EOL] @ property def max_voltage ( self ) : [EOL] [docstring] [EOL] return float ( self . _config . get ( [string] , DEFAULT_ADC_MAX_VOLTS ) ) [EOL] [EOL] [EOL] class ZigBeeDigitalIn ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] self . _config = config [EOL] self . _state = False [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] def handle_frame ( frame ) : [EOL] [docstring] [EOL] if not frame_is_relevant ( self , frame ) : [EOL] return [EOL] sample = next ( iter ( frame [ [string] ] ) ) [EOL] pin_name = DIGITAL_PINS [ self . _config . pin ] [EOL] if pin_name not in sample : [EOL] [comment] [EOL] return [EOL] [comment] [EOL] [comment] [EOL] self . _state = self . _config . state2bool [ self . _config . bool2state [ sample [ pin_name ] ] ] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_ZIGBEE_FRAME_RECEIVED , handle_frame ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _config . name [EOL] [EOL] @ property def config ( self ) : [EOL] [docstring] [EOL] return self . _config [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return self . _config . should_poll [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] sample = DEVICE . get_sample ( self . _config . address ) [EOL] except ZIGBEE_TX_FAILURE : [EOL] _LOGGER . warning ( [string] [string] , hexlify ( self . _config . address ) ) [EOL] return [EOL] except ZIGBEE_EXCEPTION as exc : [EOL] _LOGGER . exception ( [string] , exc ) [EOL] return [EOL] pin_name = DIGITAL_PINS [ self . _config . pin ] [EOL] if pin_name not in sample : [EOL] _LOGGER . warning ( [string] [string] , self . _config . pin , pin_name , hexlify ( self . _config . address ) ) [EOL] return [EOL] self . _state = self . _config . state2bool [ sample [ pin_name ] ] [EOL] [EOL] [EOL] class ZigBeeDigitalOut ( ZigBeeDigitalIn ) : [EOL] [docstring] [EOL] [EOL] def _set_state ( self , state ) : [EOL] [docstring] [EOL] try : [EOL] DEVICE . set_gpio_pin ( self . _config . pin , self . _config . bool2state [ state ] , self . _config . address ) [EOL] except ZIGBEE_TX_FAILURE : [EOL] _LOGGER . warning ( [string] [string] , hexlify ( self . _config . address ) ) [EOL] return [EOL] except ZIGBEE_EXCEPTION as exc : [EOL] _LOGGER . exception ( [string] , exc ) [EOL] return [EOL] self . _state = state [EOL] if not self . should_poll : [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _set_state ( True ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _set_state ( False ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] pin_state = DEVICE . get_gpio_pin ( self . _config . pin , self . _config . address ) [EOL] except ZIGBEE_TX_FAILURE : [EOL] _LOGGER . warning ( [string] [string] , hexlify ( self . _config . address ) ) [EOL] return [EOL] except ZIGBEE_EXCEPTION as exc : [EOL] _LOGGER . exception ( [string] , exc ) [EOL] return [EOL] self . _state = self . _config . state2bool [ pin_state ] [EOL] [EOL] [EOL] class ZigBeeAnalogIn ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] self . _config = config [EOL] self . _value = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] def handle_frame ( frame ) : [EOL] [docstring] [EOL] if not frame_is_relevant ( self , frame ) : [EOL] return [EOL] sample = frame [ [string] ] . pop ( ) [EOL] pin_name = ANALOG_PINS [ self . _config . pin ] [EOL] if pin_name not in sample : [EOL] [comment] [EOL] return [EOL] self . _value = CONVERT_ADC ( sample [ pin_name ] , ADC_PERCENTAGE , self . _config . max_voltage ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_ZIGBEE_FRAME_RECEIVED , handle_frame ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _config . name [EOL] [EOL] @ property def config ( self ) : [EOL] [docstring] [EOL] return self . _config [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return self . _config . should_poll [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _value [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _value = DEVICE . read_analog_pin ( self . _config . pin , self . _config . max_voltage , self . _config . address , ADC_PERCENTAGE ) [EOL] except ZIGBEE_TX_FAILURE : [EOL] _LOGGER . warning ( [string] [string] , hexlify ( self . _config . address ) ) [EOL] except ZIGBEE_EXCEPTION as exc : [EOL] _LOGGER . exception ( [string] , exc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 $None$ 0 0 $None$ 0 0 $None$ 0 0 $None$ 0 0 $None$ 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 $None$ 0 0 0 $None$ 0 $None$ 0 0 0 $None$ 0 $None$ 0 0 0 $None$ 0 $None$ 0 0 0 $None$ 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bool,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bool,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bool,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bool,builtins.bool]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.bool,builtins.bool]$ 0 $typing.Dict[builtins.bool,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bool,typing.Any]$ 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[builtins.bool,typing.Any]$ 0 0 0 0 $None$ 0 0 0 $None$ 0 0 $typing.Dict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bool,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.bool,typing.Any]$ 0 $typing.Dict[typing.Any,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . tesla import DOMAIN as TESLA_DOMAIN [EOL] from homeassistant . helpers . event import track_utc_time_change [EOL] from homeassistant . util import slugify [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_scanner ( hass , config , see , discovery_info = None ) : [EOL] [docstring] [EOL] TeslaDeviceTracker ( hass , config , see , hass . data [ TESLA_DOMAIN ] [ [string] ] [ [string] ] ) [EOL] return True [EOL] [EOL] [EOL] class TeslaDeviceTracker : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config , see , tesla_devices ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . see = see [EOL] self . devices = tesla_devices [EOL] self . _update_info ( ) [EOL] [EOL] track_utc_time_change ( self . hass , self . _update_info , second = range ( [number] , [number] , [number] ) ) [EOL] [EOL] def _update_info ( self , now = None ) : [EOL] [docstring] [EOL] for device in self . devices : [EOL] device . update ( ) [EOL] name = device . name [EOL] _LOGGER . debug ( [string] , name ) [EOL] dev_id = slugify ( device . uniq_name ) [EOL] location = device . get_location ( ) [EOL] if location : [EOL] lat = location [ [string] ] [EOL] lon = location [ [string] ] [EOL] attrs = { [string] : dev_id , [string] : dev_id , [string] : name } [EOL] self . see ( dev_id = dev_id , host_name = name , gps = ( lat , lon ) , attributes = attrs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . light import Light [EOL] from homeassistant . components . zigbee import ( ZigBeeDigitalOut , ZigBeeDigitalOutConfig , PLATFORM_SCHEMA ) [EOL] [EOL] CONF_ON_STATE = [string] [EOL] [EOL] DEFAULT_ON_STATE = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] STATES = [ [string] , [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_ON_STATE , default = DEFAULT_ON_STATE ) : vol . In ( STATES ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] add_devices ( [ ZigBeeLight ( hass , ZigBeeDigitalOutConfig ( config ) ) ] ) [EOL] [EOL] [EOL] class ZigBeeLight ( ZigBeeDigitalOut , Light ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import datetime [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light ) [EOL] from homeassistant import util [EOL] [EOL] _CONFIGURING = { } [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] DOMAIN = [string] [EOL] [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( milliseconds = [number] ) [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] SUPPORT_INSTEON_LOCAL = SUPPORT_BRIGHTNESS [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] insteonhub = hass . data [ [string] ] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] linked = discovery_info [ [string] ] [EOL] device_list = [ ] [EOL] for device_id in linked : [EOL] if linked [ device_id ] [ [string] ] == [string] : [EOL] device = insteonhub . dimmer ( device_id ) [EOL] device_list . append ( InsteonLocalDimmerDevice ( device ) ) [EOL] [EOL] add_devices ( device_list ) [EOL] [EOL] [EOL] class InsteonLocalDimmerDevice ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node ) : [EOL] [docstring] [EOL] self . node = node [EOL] self . _value = [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . node . device_id [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . node . device_id [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _value [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update ( self ) : [EOL] [docstring] [EOL] resp = self . node . status ( [number] ) [EOL] [EOL] while [string] in resp and resp [ [string] ] is True : [EOL] resp = self . node . status ( [number] ) [EOL] [EOL] if [string] in resp : [EOL] self . _value = int ( resp [ [string] ] , [number] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _value != [number] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_INSTEON_LOCAL [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] brightness = [number] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] brightness = int ( kwargs [ ATTR_BRIGHTNESS ] ) / [number] * [number] [EOL] [EOL] self . node . change_level ( brightness ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . node . off ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . insteon_plm import InsteonPLMEntity [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] MAX_BRIGHTNESS = [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] plm = hass . data [ [string] ] . get ( [string] ) [EOL] [EOL] address = discovery_info [ [string] ] [EOL] device = plm . devices [ address ] [EOL] state_key = discovery_info [ [string] ] [EOL] [EOL] _LOGGER . debug ( [string] , device . address . hex , device . states [ state_key ] . name ) [EOL] [EOL] new_entity = InsteonPLMDimmerDevice ( device , state_key ) [EOL] [EOL] async_add_devices ( [ new_entity ] ) [EOL] [EOL] [EOL] class InsteonPLMDimmerDevice ( InsteonPLMEntity , Light ) : [EOL] [docstring] [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] onlevel = self . _insteon_device_state . value [EOL] return int ( onlevel ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . brightness ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] brightness = int ( kwargs [ ATTR_BRIGHTNESS ] ) [EOL] self . _insteon_device_state . set_level ( brightness ) [EOL] else : [EOL] self . _insteon_device_state . on ( ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _insteon_device_state . off ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
import builtins [EOL] from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] import requests [EOL] [docstring] [EOL] [EOL] import logging [EOL] import voluptuous as vol [EOL] import requests [EOL] [EOL] from homeassistant . components . media_player import ( MediaPlayerDevice , MEDIA_TYPE_MUSIC , PLATFORM_SCHEMA , SUPPORT_PLAY , SUPPORT_PAUSE , SUPPORT_STOP , SUPPORT_PREVIOUS_TRACK , SUPPORT_NEXT_TRACK , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_VOLUME_SET , SUPPORT_VOLUME_MUTE ) [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD , STATE_OFF , STATE_IDLE , STATE_PLAYING , STATE_PAUSED ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ICON = [string] [EOL] URL = [string] [EOL] [EOL] SUPPORT_UE_SMART_RADIO = SUPPORT_PLAY | SUPPORT_PAUSE | SUPPORT_STOP | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE [EOL] [EOL] PLAYBACK_DICT = { [string] : STATE_PLAYING , [string] : STATE_PAUSED , [string] : STATE_IDLE } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , } ) [EOL] [EOL] [EOL] def send_request ( payload , session ) : [EOL] [docstring] [EOL] try : [EOL] request = requests . post ( URL , cookies = { [string] : session } , json = payload , timeout = [number] ) [EOL] except requests . exceptions . Timeout : [EOL] _LOGGER . error ( [string] ) [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] ) [EOL] else : [EOL] return request . json ( ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] email = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] session_request = requests . post ( [string] , data = { [string] : email , [string] : password } ) [EOL] session = session_request . cookies [ [string] ] [EOL] [EOL] player_request = send_request ( { [string] : [ [string] , [ [string] ] ] } , session ) [EOL] player_id = player_request [ [string] ] [ [string] ] [ [number] ] [ [string] ] [EOL] player_name = player_request [ [string] ] [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] add_devices ( [ UERadioDevice ( session , player_id , player_name ) ] ) [EOL] [EOL] [EOL] class UERadioDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session , player_id , player_name ) : [EOL] [docstring] [EOL] self . _session = session [EOL] self . _player_id = player_id [EOL] self . _name = player_name [EOL] self . _state = None [EOL] self . _volume = [number] [EOL] self . _last_volume = [number] [EOL] self . _media_title = None [EOL] self . _media_artist = None [EOL] self . _media_artwork_url = None [EOL] [EOL] def send_command ( self , command ) : [EOL] [docstring] [EOL] send_request ( { [string] : [string] , [string] : [ self . _player_id , command ] } , self . _session ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] request = send_request ( { [string] : [string] , [string] : [ self . _player_id , [ [string] , [string] , [number] , [string] ] ] } , self . _session ) [EOL] [EOL] if request [ [string] ] is not None : [EOL] self . _state = None [EOL] return [EOL] [EOL] if request [ [string] ] [ [string] ] == [number] : [EOL] self . _state = STATE_OFF [EOL] else : [EOL] self . _state = PLAYBACK_DICT [ request [ [string] ] [ [string] ] ] [EOL] [EOL] media_info = request [ [string] ] [ [string] ] [ [number] ] [EOL] [EOL] self . _volume = request [ [string] ] [ [string] ] / [number] [EOL] self . _media_artwork_url = media_info [ [string] ] [EOL] self . _media_title = media_info [ [string] ] [EOL] if [string] in media_info : [EOL] self . _media_artist = media_info [ [string] ] [EOL] else : [EOL] self . _media_artist = media_info . get ( [string] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return True if self . _volume <= [number] else False [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_UE_SMART_RADIO [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . _media_artwork_url [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . _media_artist [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _media_title [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [number] ] ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [number] ] ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] ] ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] ] ) [EOL] [EOL] def media_stop ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] ] ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [string] ] ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [string] ] ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] if mute : [EOL] self . _last_volume = self . _volume [EOL] self . send_command ( [ [string] , [string] , [number] ] ) [EOL] else : [EOL] self . send_command ( [ [string] , [string] , self . _last_volume * [number] ] ) [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [string] , volume * [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . media_player import ( SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_SELECT_SOURCE , MediaPlayerDevice , PLATFORM_SCHEMA , MEDIA_TYPE_MUSIC ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT , STATE_OFF , STATE_ON , CONF_NAME , EVENT_HOMEASSISTANT_STOP ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_RUSSOUND = SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_SET | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = [number] ) : cv . port , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] from russound_rio import Russound [EOL] [EOL] russ = Russound ( hass . loop , host , port ) [EOL] [EOL] yield from russ . connect ( ) [EOL] [EOL] [comment] [EOL] sources = yield from russ . enumerate_sources ( ) [EOL] [EOL] [comment] [EOL] valid_zones = yield from russ . enumerate_zones ( ) [EOL] [EOL] devices = [ ] [EOL] for zone_id , name in valid_zones : [EOL] yield from russ . watch_zone ( zone_id ) [EOL] dev = RussoundZoneDevice ( russ , zone_id , name , sources ) [EOL] devices . append ( dev ) [EOL] [EOL] @ callback def on_stop ( event ) : [EOL] [docstring] [EOL] hass . loop . create_task ( russ . close ( ) ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , on_stop ) [EOL] [EOL] async_add_devices ( devices ) [EOL] [EOL] [EOL] class RussoundZoneDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , russ , zone_id , name , sources ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _name = name [EOL] self . _russ = russ [EOL] self . _zone_id = zone_id [EOL] self . _sources = sources [EOL] [EOL] def _zone_var ( self , name , default = None ) : [EOL] return self . _russ . get_cached_zone_variable ( self . _zone_id , name , default ) [EOL] [EOL] def _source_var ( self , name , default = None ) : [EOL] current = int ( self . _zone_var ( [string] , [number] ) ) [EOL] if current : [EOL] return self . _russ . get_cached_source_variable ( current , name , default ) [EOL] return default [EOL] [EOL] def _source_na_var ( self , name ) : [EOL] [docstring] [EOL] current = int ( self . _zone_var ( [string] , [number] ) ) [EOL] if current : [EOL] value = self . _russ . get_cached_source_variable ( current , name , None ) [EOL] if value in ( None , [string] , [string] ) : [EOL] return None [EOL] return value [EOL] return None [EOL] [EOL] def _zone_callback_handler ( self , zone_id , * args ) : [EOL] if zone_id == self . _zone_id : [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _source_callback_handler ( self , source_id , * args ) : [EOL] current = int ( self . _zone_var ( [string] , [number] ) ) [EOL] if source_id == current : [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _russ . add_zone_callback ( self . _zone_callback_handler ) [EOL] self . _russ . add_source_callback ( self . _source_callback_handler ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _zone_var ( [string] , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] status = self . _zone_var ( [string] , [string] ) [EOL] if status == [string] : [EOL] return STATE_ON [EOL] if status == [string] : [EOL] return STATE_OFF [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_RUSSOUND [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return [ x [ [number] ] for x in self . _sources ] [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def media_album_name ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . _source_na_var ( [string] ) [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return float ( self . _zone_var ( [string] , [number] ) ) / [number] [EOL] [EOL] def async_turn_off ( self ) : [EOL] [docstring] [EOL] return self . _russ . send_zone_event ( self . _zone_id , [string] ) [EOL] [EOL] def async_turn_on ( self ) : [EOL] [docstring] [EOL] return self . _russ . send_zone_event ( self . _zone_id , [string] ) [EOL] [EOL] def async_set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] rvol = int ( volume * [number] ) [EOL] return self . _russ . send_zone_event ( self . _zone_id , [string] , [string] , rvol ) [EOL] [EOL] def async_select_source ( self , source ) : [EOL] [docstring] [EOL] for source_id , name in self . _sources : [EOL] if name . lower ( ) != source . lower ( ) : [EOL] continue [EOL] return self . _russ . send_zone_event ( self . _zone_id , [string] , source_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components import mqtt [EOL] from homeassistant . components . mqtt import MqttAvailability [EOL] from homeassistant . components . vacuum import ( SUPPORT_BATTERY , SUPPORT_CLEAN_SPOT , SUPPORT_FAN_SPEED , SUPPORT_LOCATE , SUPPORT_PAUSE , SUPPORT_RETURN_HOME , SUPPORT_SEND_COMMAND , SUPPORT_STATUS , SUPPORT_STOP , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , VacuumDevice ) [EOL] from homeassistant . const import ATTR_SUPPORTED_FEATURES , CONF_NAME [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . icon import icon_for_battery_level [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SERVICE_TO_STRING = { SUPPORT_TURN_ON : [string] , SUPPORT_TURN_OFF : [string] , SUPPORT_PAUSE : [string] , SUPPORT_STOP : [string] , SUPPORT_RETURN_HOME : [string] , SUPPORT_FAN_SPEED : [string] , SUPPORT_BATTERY : [string] , SUPPORT_STATUS : [string] , SUPPORT_SEND_COMMAND : [string] , SUPPORT_LOCATE : [string] , SUPPORT_CLEAN_SPOT : [string] , } [EOL] [EOL] STRING_TO_SERVICE = { v : k for k , v in SERVICE_TO_STRING . items ( ) } [EOL] [EOL] [EOL] def services_to_strings ( services ) : [EOL] [docstring] [EOL] strings = [ ] [EOL] for service in SERVICE_TO_STRING : [EOL] if service & services : [EOL] strings . append ( SERVICE_TO_STRING [ service ] ) [EOL] return strings [EOL] [EOL] [EOL] def strings_to_services ( strings ) : [EOL] [docstring] [EOL] services = [number] [EOL] for string in strings : [EOL] services |= STRING_TO_SERVICE [ string ] [EOL] return services [EOL] [EOL] [EOL] DEFAULT_SERVICES = SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_STOP | SUPPORT_RETURN_HOME | SUPPORT_STATUS | SUPPORT_BATTERY | SUPPORT_CLEAN_SPOT [EOL] ALL_SERVICES = DEFAULT_SERVICES | SUPPORT_PAUSE | SUPPORT_LOCATE | SUPPORT_FAN_SPEED | SUPPORT_SEND_COMMAND [EOL] [EOL] CONF_SUPPORTED_FEATURES = ATTR_SUPPORTED_FEATURES [EOL] CONF_PAYLOAD_TURN_ON = [string] [EOL] CONF_PAYLOAD_TURN_OFF = [string] [EOL] CONF_PAYLOAD_RETURN_TO_BASE = [string] [EOL] CONF_PAYLOAD_STOP = [string] [EOL] CONF_PAYLOAD_CLEAN_SPOT = [string] [EOL] CONF_PAYLOAD_LOCATE = [string] [EOL] CONF_PAYLOAD_START_PAUSE = [string] [EOL] CONF_BATTERY_LEVEL_TOPIC = [string] [EOL] CONF_BATTERY_LEVEL_TEMPLATE = [string] [EOL] CONF_CHARGING_TOPIC = [string] [EOL] CONF_CHARGING_TEMPLATE = [string] [EOL] CONF_CLEANING_TOPIC = [string] [EOL] CONF_CLEANING_TEMPLATE = [string] [EOL] CONF_DOCKED_TOPIC = [string] [EOL] CONF_DOCKED_TEMPLATE = [string] [EOL] CONF_STATE_TOPIC = [string] [EOL] CONF_STATE_TEMPLATE = [string] [EOL] CONF_FAN_SPEED_TOPIC = [string] [EOL] CONF_FAN_SPEED_TEMPLATE = [string] [EOL] CONF_SET_FAN_SPEED_TOPIC = [string] [EOL] CONF_FAN_SPEED_LIST = [string] [EOL] CONF_SEND_COMMAND_TOPIC = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_RETAIN = False [EOL] DEFAULT_SERVICE_STRINGS = services_to_strings ( DEFAULT_SERVICES ) [EOL] DEFAULT_PAYLOAD_TURN_ON = [string] [EOL] DEFAULT_PAYLOAD_TURN_OFF = [string] [EOL] DEFAULT_PAYLOAD_RETURN_TO_BASE = [string] [EOL] DEFAULT_PAYLOAD_STOP = [string] [EOL] DEFAULT_PAYLOAD_CLEAN_SPOT = [string] [EOL] DEFAULT_PAYLOAD_LOCATE = [string] [EOL] DEFAULT_PAYLOAD_START_PAUSE = [string] [EOL] [EOL] PLATFORM_SCHEMA = mqtt . MQTT_BASE_PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_SUPPORTED_FEATURES , default = DEFAULT_SERVICE_STRINGS ) : vol . All ( cv . ensure_list , [ vol . In ( STRING_TO_SERVICE . keys ( ) ) ] ) , vol . Optional ( mqtt . CONF_RETAIN , default = DEFAULT_RETAIN ) : cv . boolean , vol . Optional ( mqtt . CONF_COMMAND_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_PAYLOAD_TURN_ON , default = DEFAULT_PAYLOAD_TURN_ON ) : cv . string , vol . Optional ( CONF_PAYLOAD_TURN_OFF , default = DEFAULT_PAYLOAD_TURN_OFF ) : cv . string , vol . Optional ( CONF_PAYLOAD_RETURN_TO_BASE , default = DEFAULT_PAYLOAD_RETURN_TO_BASE ) : cv . string , vol . Optional ( CONF_PAYLOAD_STOP , default = DEFAULT_PAYLOAD_STOP ) : cv . string , vol . Optional ( CONF_PAYLOAD_CLEAN_SPOT , default = DEFAULT_PAYLOAD_CLEAN_SPOT ) : cv . string , vol . Optional ( CONF_PAYLOAD_LOCATE , default = DEFAULT_PAYLOAD_LOCATE ) : cv . string , vol . Optional ( CONF_PAYLOAD_START_PAUSE , default = DEFAULT_PAYLOAD_START_PAUSE ) : cv . string , vol . Optional ( CONF_BATTERY_LEVEL_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_BATTERY_LEVEL_TEMPLATE ) : cv . template , vol . Optional ( CONF_CHARGING_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_CHARGING_TEMPLATE ) : cv . template , vol . Optional ( CONF_CLEANING_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_CLEANING_TEMPLATE ) : cv . template , vol . Optional ( CONF_DOCKED_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_DOCKED_TEMPLATE ) : cv . template , vol . Optional ( CONF_STATE_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_STATE_TEMPLATE ) : cv . template , vol . Optional ( CONF_FAN_SPEED_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_FAN_SPEED_TEMPLATE ) : cv . template , vol . Optional ( CONF_SET_FAN_SPEED_TOPIC ) : mqtt . valid_publish_topic , vol . Optional ( CONF_FAN_SPEED_LIST , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_SEND_COMMAND_TOPIC ) : mqtt . valid_publish_topic , } ) . extend ( mqtt . MQTT_AVAILABILITY_SCHEMA . schema ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] supported_feature_strings = config . get ( CONF_SUPPORTED_FEATURES ) [EOL] supported_features = strings_to_services ( supported_feature_strings ) [EOL] [EOL] qos = config . get ( mqtt . CONF_QOS ) [EOL] retain = config . get ( mqtt . CONF_RETAIN ) [EOL] [EOL] command_topic = config . get ( mqtt . CONF_COMMAND_TOPIC ) [EOL] payload_turn_on = config . get ( CONF_PAYLOAD_TURN_ON ) [EOL] payload_turn_off = config . get ( CONF_PAYLOAD_TURN_OFF ) [EOL] payload_return_to_base = config . get ( CONF_PAYLOAD_RETURN_TO_BASE ) [EOL] payload_stop = config . get ( CONF_PAYLOAD_STOP ) [EOL] payload_clean_spot = config . get ( CONF_PAYLOAD_CLEAN_SPOT ) [EOL] payload_locate = config . get ( CONF_PAYLOAD_LOCATE ) [EOL] payload_start_pause = config . get ( CONF_PAYLOAD_START_PAUSE ) [EOL] [EOL] battery_level_topic = config . get ( CONF_BATTERY_LEVEL_TOPIC ) [EOL] battery_level_template = config . get ( CONF_BATTERY_LEVEL_TEMPLATE ) [EOL] if battery_level_template : [EOL] battery_level_template . hass = hass [EOL] [EOL] charging_topic = config . get ( CONF_CHARGING_TOPIC ) [EOL] charging_template = config . get ( CONF_CHARGING_TEMPLATE ) [EOL] if charging_template : [EOL] charging_template . hass = hass [EOL] [EOL] cleaning_topic = config . get ( CONF_CLEANING_TOPIC ) [EOL] cleaning_template = config . get ( CONF_CLEANING_TEMPLATE ) [EOL] if cleaning_template : [EOL] cleaning_template . hass = hass [EOL] [EOL] docked_topic = config . get ( CONF_DOCKED_TOPIC ) [EOL] docked_template = config . get ( CONF_DOCKED_TEMPLATE ) [EOL] if docked_template : [EOL] docked_template . hass = hass [EOL] [EOL] fan_speed_topic = config . get ( CONF_FAN_SPEED_TOPIC ) [EOL] fan_speed_template = config . get ( CONF_FAN_SPEED_TEMPLATE ) [EOL] if fan_speed_template : [EOL] fan_speed_template . hass = hass [EOL] [EOL] set_fan_speed_topic = config . get ( CONF_SET_FAN_SPEED_TOPIC ) [EOL] fan_speed_list = config . get ( CONF_FAN_SPEED_LIST ) [EOL] [EOL] send_command_topic = config . get ( CONF_SEND_COMMAND_TOPIC ) [EOL] [EOL] availability_topic = config . get ( mqtt . CONF_AVAILABILITY_TOPIC ) [EOL] payload_available = config . get ( mqtt . CONF_PAYLOAD_AVAILABLE ) [EOL] payload_not_available = config . get ( mqtt . CONF_PAYLOAD_NOT_AVAILABLE ) [EOL] [EOL] async_add_devices ( [ MqttVacuum ( name , supported_features , qos , retain , command_topic , payload_turn_on , payload_turn_off , payload_return_to_base , payload_stop , payload_clean_spot , payload_locate , payload_start_pause , battery_level_topic , battery_level_template , charging_topic , charging_template , cleaning_topic , cleaning_template , docked_topic , docked_template , fan_speed_topic , fan_speed_template , set_fan_speed_topic , fan_speed_list , send_command_topic , availability_topic , payload_available , payload_not_available ) , ] ) [EOL] [EOL] [EOL] class MqttVacuum ( MqttAvailability , VacuumDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , supported_features , qos , retain , command_topic , payload_turn_on , payload_turn_off , payload_return_to_base , payload_stop , payload_clean_spot , payload_locate , payload_start_pause , battery_level_topic , battery_level_template , charging_topic , charging_template , cleaning_topic , cleaning_template , docked_topic , docked_template , fan_speed_topic , fan_speed_template , set_fan_speed_topic , fan_speed_list , send_command_topic , availability_topic , payload_available , payload_not_available ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( availability_topic , qos , payload_available , payload_not_available ) [EOL] [EOL] self . _name = name [EOL] self . _supported_features = supported_features [EOL] self . _qos = qos [EOL] self . _retain = retain [EOL] [EOL] self . _command_topic = command_topic [EOL] self . _payload_turn_on = payload_turn_on [EOL] self . _payload_turn_off = payload_turn_off [EOL] self . _payload_return_to_base = payload_return_to_base [EOL] self . _payload_stop = payload_stop [EOL] self . _payload_clean_spot = payload_clean_spot [EOL] self . _payload_locate = payload_locate [EOL] self . _payload_start_pause = payload_start_pause [EOL] [EOL] self . _battery_level_topic = battery_level_topic [EOL] self . _battery_level_template = battery_level_template [EOL] [EOL] self . _charging_topic = charging_topic [EOL] self . _charging_template = charging_template [EOL] [EOL] self . _cleaning_topic = cleaning_topic [EOL] self . _cleaning_template = cleaning_template [EOL] [EOL] self . _docked_topic = docked_topic [EOL] self . _docked_template = docked_template [EOL] [EOL] self . _fan_speed_topic = fan_speed_topic [EOL] self . _fan_speed_template = fan_speed_template [EOL] [EOL] self . _set_fan_speed_topic = set_fan_speed_topic [EOL] self . _fan_speed_list = fan_speed_list [EOL] self . _send_command_topic = send_command_topic [EOL] [EOL] self . _cleaning = False [EOL] self . _charging = False [EOL] self . _docked = False [EOL] self . _status = [string] [EOL] self . _battery_level = [number] [EOL] self . _fan_speed = [string] [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] yield from super ( ) . async_added_to_hass ( ) [EOL] [EOL] @ callback def message_received ( topic , payload , qos ) : [EOL] [docstring] [EOL] if topic == self . _battery_level_topic and self . _battery_level_template : [EOL] battery_level = self . _battery_level_template . async_render_with_possible_json_value ( payload , error_value = None ) [EOL] if battery_level is not None : [EOL] self . _battery_level = int ( battery_level ) [EOL] [EOL] if topic == self . _charging_topic and self . _charging_template : [EOL] charging = self . _charging_template . async_render_with_possible_json_value ( payload , error_value = None ) [EOL] if charging is not None : [EOL] self . _charging = cv . boolean ( charging ) [EOL] [EOL] if topic == self . _cleaning_topic and self . _cleaning_template : [EOL] cleaning = self . _cleaning_template . async_render_with_possible_json_value ( payload , error_value = None ) [EOL] if cleaning is not None : [EOL] self . _cleaning = cv . boolean ( cleaning ) [EOL] [EOL] if topic == self . _docked_topic and self . _docked_template : [EOL] docked = self . _docked_template . async_render_with_possible_json_value ( payload , error_value = None ) [EOL] if docked is not None : [EOL] self . _docked = cv . boolean ( docked ) [EOL] [EOL] if self . _docked : [EOL] if self . _charging : [EOL] self . _status = [string] [EOL] else : [EOL] self . _status = [string] [EOL] elif self . _cleaning : [EOL] self . _status = [string] [EOL] else : [EOL] self . _status = [string] [EOL] [EOL] if topic == self . _fan_speed_topic and self . _fan_speed_template : [EOL] fan_speed = self . _fan_speed_template . async_render_with_possible_json_value ( payload , error_value = None ) [EOL] if fan_speed is not None : [EOL] self . _fan_speed = fan_speed [EOL] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] topics_list = [ topic for topic in ( self . _battery_level_topic , self . _charging_topic , self . _cleaning_topic , self . _docked_topic , self . _fan_speed_topic ) if topic ] [EOL] for topic in set ( topics_list ) : [EOL] yield from self . hass . components . mqtt . async_subscribe ( topic , message_received , self . _qos ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _cleaning [EOL] [EOL] @ property def status ( self ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_STATUS == [number] : [EOL] return [EOL] [EOL] return self . _status [EOL] [EOL] @ property def fan_speed ( self ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_FAN_SPEED == [number] : [EOL] return [EOL] [EOL] return self . _fan_speed [EOL] [EOL] @ property def fan_speed_list ( self ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_FAN_SPEED == [number] : [EOL] return [ ] [EOL] return self . _fan_speed_list [EOL] [EOL] @ property def battery_level ( self ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_BATTERY == [number] : [EOL] return [EOL] [EOL] return max ( [number] , min ( [number] , self . _battery_level ) ) [EOL] [EOL] @ property def battery_icon ( self ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_BATTERY == [number] : [EOL] return [EOL] [EOL] return icon_for_battery_level ( battery_level = self . battery_level , charging = self . _charging ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported_features [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_TURN_ON == [number] : [EOL] return [EOL] [EOL] mqtt . async_publish ( self . hass , self . _command_topic , self . _payload_turn_on , self . _qos , self . _retain ) [EOL] self . _status = [string] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_TURN_OFF == [number] : [EOL] return [EOL] [EOL] mqtt . async_publish ( self . hass , self . _command_topic , self . _payload_turn_off , self . _qos , self . _retain ) [EOL] self . _status = [string] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_stop ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_STOP == [number] : [EOL] return [EOL] [EOL] mqtt . async_publish ( self . hass , self . _command_topic , self . _payload_stop , self . _qos , self . _retain ) [EOL] self . _status = [string] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_clean_spot ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_CLEAN_SPOT == [number] : [EOL] return [EOL] [EOL] mqtt . async_publish ( self . hass , self . _command_topic , self . _payload_clean_spot , self . _qos , self . _retain ) [EOL] self . _status = [string] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_locate ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_LOCATE == [number] : [EOL] return [EOL] [EOL] mqtt . async_publish ( self . hass , self . _command_topic , self . _payload_locate , self . _qos , self . _retain ) [EOL] self . _status = [string] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_start_pause ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_PAUSE == [number] : [EOL] return [EOL] [EOL] mqtt . async_publish ( self . hass , self . _command_topic , self . _payload_start_pause , self . _qos , self . _retain ) [EOL] self . _status = [string] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_return_to_base ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_RETURN_HOME == [number] : [EOL] return [EOL] [EOL] mqtt . async_publish ( self . hass , self . _command_topic , self . _payload_return_to_base , self . _qos , self . _retain ) [EOL] self . _status = [string] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_set_fan_speed ( self , fan_speed , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_FAN_SPEED == [number] : [EOL] return [EOL] if not self . _fan_speed_list or fan_speed not in self . _fan_speed_list : [EOL] return [EOL] [EOL] mqtt . async_publish ( self . hass , self . _set_fan_speed_topic , fan_speed , self . _qos , self . _retain ) [EOL] self . _status = [string] . format ( fan_speed ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_send_command ( self , command , params = None , ** kwargs ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_SEND_COMMAND == [number] : [EOL] return [EOL] [EOL] mqtt . async_publish ( self . hass , self . _send_command_topic , command , self . _qos , self . _retain ) [EOL] self . _status = [string] . format ( command ) [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
import builtins [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] from homeassistant . components . climate import ( ClimateDevice , STATE_AUTO , SUPPORT_TARGET_TEMPERATURE , SUPPORT_OPERATION_MODE ) [EOL] from homeassistant . components . homematic import ( HMDevice , ATTR_DISCOVER_DEVICES , HM_ATTRIBUTE_SUPPORT ) [EOL] from homeassistant . const import TEMP_CELSIUS , STATE_UNKNOWN , ATTR_TEMPERATURE [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] STATE_MANUAL = [string] [EOL] STATE_BOOST = [string] [EOL] STATE_COMFORT = [string] [EOL] STATE_LOWERING = [string] [EOL] [EOL] HM_STATE_MAP = { [string] : STATE_AUTO , [string] : STATE_MANUAL , [string] : STATE_BOOST , [string] : STATE_COMFORT , [string] : STATE_LOWERING } [EOL] [EOL] HM_TEMP_MAP = [ [string] , [string] , ] [EOL] [EOL] HM_HUMI_MAP = [ [string] , [string] , ] [EOL] [EOL] HM_CONTROL_MODE = [string] [EOL] HM_IP_CONTROL_MODE = [string] [EOL] [EOL] SUPPORT_FLAGS = SUPPORT_TARGET_TEMPERATURE | SUPPORT_OPERATION_MODE [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] devices = [ ] [EOL] for conf in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] new_device = HMThermostat ( conf ) [EOL] devices . append ( new_device ) [EOL] [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class HMThermostat ( HMDevice , ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FLAGS [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] if HM_CONTROL_MODE not in self . _data : [EOL] return None [EOL] [EOL] set_point_mode = self . _data . get ( [string] , - [number] ) [EOL] control_mode = self . _data . get ( [string] , - [number] ) [EOL] boost_mode = self . _data . get ( [string] , False ) [EOL] [EOL] [comment] [EOL] if boost_mode : [EOL] return STATE_BOOST [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not set_point_mode == - [number] : [EOL] code = set_point_mode [EOL] [comment] [EOL] else : [EOL] code = control_mode [EOL] [EOL] [comment] [EOL] name = HM_ATTRIBUTE_SUPPORT [ HM_CONTROL_MODE ] [ [number] ] [ code ] [EOL] return name . lower ( ) [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] op_list = [ ] [EOL] [EOL] for mode in self . _hmdevice . ACTIONNODE : [EOL] if mode in HM_STATE_MAP : [EOL] op_list . append ( HM_STATE_MAP . get ( mode ) ) [EOL] [EOL] return op_list [EOL] [EOL] @ property def current_humidity ( self ) : [EOL] [docstring] [EOL] for node in HM_HUMI_MAP : [EOL] if node in self . _data : [EOL] return self . _data [ node ] [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] for node in HM_TEMP_MAP : [EOL] if node in self . _data : [EOL] return self . _data [ node ] [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _data . get ( self . _state ) [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if temperature is None : [EOL] return None [EOL] [EOL] self . _hmdevice . writeNodeData ( self . _state , float ( temperature ) ) [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] for mode , state in HM_STATE_MAP . items ( ) : [EOL] if state == operation_mode : [EOL] code = getattr ( self . _hmdevice , mode , [number] ) [EOL] self . _hmdevice . MODE = code [EOL] return [EOL] [EOL] @ property def min_temp ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] @ property def max_temp ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] def _init_data_struct ( self ) : [EOL] [docstring] [EOL] self . _state = next ( iter ( self . _hmdevice . WRITENODE . keys ( ) ) ) [EOL] self . _data [ self . _state ] = STATE_UNKNOWN [EOL] [EOL] if HM_CONTROL_MODE in self . _hmdevice . ATTRIBUTENODE or HM_IP_CONTROL_MODE in self . _hmdevice . ATTRIBUTENODE : [EOL] self . _data [ HM_CONTROL_MODE ] = STATE_UNKNOWN [EOL] [EOL] for node in self . _hmdevice . SENSORNODE . keys ( ) : [EOL] self . _data [ node ] = STATE_UNKNOWN [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . const import ( PRECISION_TENTHS , TEMP_CELSIUS ) [EOL] from homeassistant . components . climate import ( ClimateDevice , SUPPORT_TARGET_TEMPERATURE , SUPPORT_OPERATION_MODE ) [EOL] from homeassistant . util . temperature import convert as convert_temperature [EOL] from homeassistant . const import ATTR_TEMPERATURE [EOL] from homeassistant . components . tado import DATA_TADO [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONST_MODE_SMART_SCHEDULE = [string] [comment] [EOL] CONST_MODE_OFF = [string] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] CONST_OVERLAY_TADO_MODE = [string] [EOL] [comment] [EOL] CONST_OVERLAY_MANUAL = [string] [EOL] [comment] [EOL] CONST_OVERLAY_TIMER = [string] [EOL] [EOL] CONST_MODE_FAN_HIGH = [string] [EOL] CONST_MODE_FAN_MIDDLE = [string] [EOL] CONST_MODE_FAN_LOW = [string] [EOL] [EOL] FAN_MODES_LIST = { CONST_MODE_FAN_HIGH : [string] , CONST_MODE_FAN_MIDDLE : [string] , CONST_MODE_FAN_LOW : [string] , CONST_MODE_OFF : [string] , } [EOL] [EOL] OPERATION_LIST = { CONST_OVERLAY_MANUAL : [string] , CONST_OVERLAY_TIMER : [string] , CONST_OVERLAY_TADO_MODE : [string] , CONST_MODE_SMART_SCHEDULE : [string] , CONST_MODE_OFF : [string] , } [EOL] [EOL] SUPPORT_FLAGS = SUPPORT_TARGET_TEMPERATURE | SUPPORT_OPERATION_MODE [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] tado = hass . data [ DATA_TADO ] [EOL] [EOL] try : [EOL] zones = tado . get_zones ( ) [EOL] except RuntimeError : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] climate_devices = [ ] [EOL] for zone in zones : [EOL] device = create_climate_device ( tado , hass , zone , zone [ [string] ] , zone [ [string] ] ) [EOL] if not device : [EOL] continue [EOL] climate_devices . append ( device ) [EOL] [EOL] if climate_devices : [EOL] add_devices ( climate_devices , True ) [EOL] [EOL] [EOL] def create_climate_device ( tado , hass , zone , name , zone_id ) : [EOL] [docstring] [EOL] capabilities = tado . get_capabilities ( zone_id ) [EOL] [EOL] unit = TEMP_CELSIUS [EOL] ac_mode = capabilities [ [string] ] == [string] [EOL] [EOL] if ac_mode : [EOL] temperatures = capabilities [ [string] ] [ [string] ] [EOL] elif [string] in capabilities : [EOL] temperatures = capabilities [ [string] ] [EOL] else : [EOL] _LOGGER . debug ( [string] , name ) [EOL] return [EOL] [EOL] min_temp = float ( temperatures [ [string] ] [ [string] ] ) [EOL] max_temp = float ( temperatures [ [string] ] [ [string] ] ) [EOL] [EOL] data_id = [string] . format ( name , zone_id ) [EOL] device = TadoClimate ( tado , name , zone_id , data_id , hass . config . units . temperature ( min_temp , unit ) , hass . config . units . temperature ( max_temp , unit ) , ac_mode ) [EOL] [EOL] tado . add_sensor ( data_id , { [string] : zone_id , [string] : zone , [string] : name , [string] : device } ) [EOL] [EOL] return device [EOL] [EOL] [EOL] class TadoClimate ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , store , zone_name , zone_id , data_id , min_temp , max_temp , ac_mode , tolerance = [number] ) : [EOL] [docstring] [EOL] self . _store = store [EOL] self . _data_id = data_id [EOL] [EOL] self . zone_name = zone_name [EOL] self . zone_id = zone_id [EOL] [EOL] self . ac_mode = ac_mode [EOL] [EOL] self . _active = False [EOL] self . _device_is_active = False [EOL] [EOL] self . _unit = TEMP_CELSIUS [EOL] self . _cur_temp = None [EOL] self . _cur_humidity = None [EOL] self . _is_away = False [EOL] self . _min_temp = min_temp [EOL] self . _max_temp = max_temp [EOL] self . _target_temp = None [EOL] self . _tolerance = tolerance [EOL] self . _cooling = False [EOL] [EOL] self . _current_fan = CONST_MODE_OFF [EOL] self . _current_operation = CONST_MODE_SMART_SCHEDULE [EOL] self . _overlay_mode = CONST_MODE_SMART_SCHEDULE [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FLAGS [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . zone_name [EOL] [EOL] @ property def current_humidity ( self ) : [EOL] [docstring] [EOL] return self . _cur_humidity [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _cur_temp [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] if self . _cooling : [EOL] return [string] [EOL] return OPERATION_LIST . get ( self . _current_operation ) [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return list ( OPERATION_LIST . values ( ) ) [EOL] [EOL] @ property def current_fan_mode ( self ) : [EOL] [docstring] [EOL] if self . ac_mode : [EOL] return FAN_MODES_LIST . get ( self . _current_fan ) [EOL] return None [EOL] [EOL] @ property def fan_list ( self ) : [EOL] [docstring] [EOL] if self . ac_mode : [EOL] return list ( FAN_MODES_LIST . values ( ) ) [EOL] return None [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return self . _unit [EOL] [EOL] @ property def is_away_mode_on ( self ) : [EOL] [docstring] [EOL] return self . _is_away [EOL] [EOL] @ property def target_temperature_step ( self ) : [EOL] [docstring] [EOL] return PRECISION_TENTHS [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _target_temp [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if temperature is None : [EOL] return [EOL] [EOL] self . _current_operation = CONST_OVERLAY_TADO_MODE [EOL] self . _overlay_mode = None [EOL] self . _target_temp = temperature [EOL] self . _control_heating ( ) [EOL] [EOL] [comment] [EOL] def set_operation_mode ( self , readable_operation_mode ) : [EOL] [docstring] [EOL] operation_mode = CONST_MODE_SMART_SCHEDULE [EOL] [EOL] for mode , readable in OPERATION_LIST . items ( ) : [EOL] if readable == readable_operation_mode : [EOL] operation_mode = mode [EOL] break [EOL] [EOL] self . _current_operation = operation_mode [EOL] self . _overlay_mode = None [EOL] self . _control_heating ( ) [EOL] [EOL] @ property def min_temp ( self ) : [EOL] [docstring] [EOL] return convert_temperature ( self . _min_temp , self . _unit , self . hass . config . units . temperature_unit ) [EOL] [EOL] @ property def max_temp ( self ) : [EOL] [docstring] [EOL] return convert_temperature ( self . _max_temp , self . _unit , self . hass . config . units . temperature_unit ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _store . update ( ) [EOL] [EOL] data = self . _store . get_data ( self . _data_id ) [EOL] [EOL] if data is None : [EOL] _LOGGER . debug ( [string] , self . zone_name ) [EOL] return [EOL] [EOL] if [string] in data : [EOL] sensor_data = data [ [string] ] [EOL] [EOL] unit = TEMP_CELSIUS [EOL] [EOL] if [string] in sensor_data : [EOL] temperature = float ( sensor_data [ [string] ] [ [string] ] ) [EOL] self . _cur_temp = self . hass . config . units . temperature ( temperature , unit ) [EOL] [EOL] if [string] in sensor_data : [EOL] humidity = float ( sensor_data [ [string] ] [ [string] ] ) [EOL] self . _cur_humidity = humidity [EOL] [EOL] [comment] [EOL] if [string] in data [ [string] ] and data [ [string] ] [ [string] ] is not None : [EOL] setting = float ( data [ [string] ] [ [string] ] [ [string] ] ) [EOL] self . _target_temp = self . hass . config . units . temperature ( setting , unit ) [EOL] [EOL] if [string] in data : [EOL] mode = data [ [string] ] [EOL] self . _is_away = mode == [string] [EOL] [EOL] if [string] in data : [EOL] power = data [ [string] ] [ [string] ] [EOL] if power == [string] : [EOL] self . _current_operation = CONST_MODE_OFF [EOL] self . _current_fan = CONST_MODE_OFF [EOL] [comment] [EOL] [comment] [EOL] self . _overlay_mode = CONST_MODE_SMART_SCHEDULE [EOL] self . _device_is_active = False [EOL] else : [EOL] self . _device_is_active = True [EOL] [EOL] overlay = False [EOL] overlay_data = None [EOL] termination = CONST_MODE_SMART_SCHEDULE [EOL] cooling = False [EOL] fan_speed = CONST_MODE_OFF [EOL] [EOL] if [string] in data : [EOL] overlay_data = data [ [string] ] [EOL] overlay = overlay_data is not None [EOL] [EOL] if overlay : [EOL] termination = overlay_data [ [string] ] [ [string] ] [EOL] [EOL] if [string] in overlay_data : [EOL] setting_data = overlay_data [ [string] ] [EOL] setting = setting_data is not None [EOL] [EOL] if setting : [EOL] if [string] in setting_data : [EOL] cooling = setting_data [ [string] ] == [string] [EOL] [EOL] if [string] in setting_data : [EOL] fan_speed = setting_data [ [string] ] [EOL] [EOL] if self . _device_is_active : [EOL] [comment] [EOL] [comment] [EOL] self . _overlay_mode = termination [EOL] self . _current_operation = termination [EOL] [EOL] self . _cooling = cooling [EOL] self . _current_fan = fan_speed [EOL] [EOL] def _control_heating ( self ) : [EOL] [docstring] [EOL] if not self . _active and None not in ( self . _cur_temp , self . _target_temp ) : [EOL] self . _active = True [EOL] _LOGGER . info ( [string] [string] ) [EOL] [EOL] if not self . _active or self . _current_operation == self . _overlay_mode : [EOL] return [EOL] [EOL] if self . _current_operation == CONST_MODE_SMART_SCHEDULE : [EOL] _LOGGER . info ( [string] [string] , self . zone_name ) [EOL] self . _store . reset_zone_overlay ( self . zone_id ) [EOL] self . _overlay_mode = self . _current_operation [EOL] return [EOL] [EOL] if self . _current_operation == CONST_MODE_OFF : [EOL] _LOGGER . info ( [string] , self . zone_name ) [EOL] self . _store . set_zone_overlay ( self . zone_id , CONST_OVERLAY_MANUAL ) [EOL] self . _overlay_mode = self . _current_operation [EOL] return [EOL] [EOL] _LOGGER . info ( [string] , self . _current_operation , self . zone_name ) [EOL] self . _store . set_zone_overlay ( self . zone_id , self . _current_operation , self . _target_temp ) [EOL] [EOL] self . _overlay_mode = self . _current_operation [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Type , Union [EOL] import typing [EOL] import homeassistant [EOL] [docstring] [EOL] [EOL] [EOL] class CloudError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Unauthenticated ( CloudError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UserNotFound ( CloudError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UserNotConfirmed ( CloudError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class PasswordChangeRequired ( CloudError ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def __init__ ( self , message = [string] ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class UnknownError ( CloudError ) : [EOL] [docstring] [EOL] [EOL] [EOL] AWS_EXCEPTIONS = { [string] : UserNotFound , [string] : Unauthenticated , [string] : UserNotConfirmed , [string] : PasswordChangeRequired , } [EOL] [EOL] [EOL] def _map_aws_exception ( err ) : [EOL] [docstring] [EOL] ex = AWS_EXCEPTIONS . get ( err . response [ [string] ] [ [string] ] , UnknownError ) [EOL] return ex ( err . response [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] def register ( cloud , email , password ) : [EOL] [docstring] [EOL] from botocore . exceptions import ClientError [EOL] [EOL] cognito = _cognito ( cloud ) [EOL] [comment] [EOL] [comment] [EOL] cognito . add_base_attributes ( ) [EOL] try : [EOL] cognito . register ( email , password ) [EOL] except ClientError as err : [EOL] raise _map_aws_exception ( err ) [EOL] [EOL] [EOL] def resend_email_confirm ( cloud , email ) : [EOL] [docstring] [EOL] from botocore . exceptions import ClientError [EOL] [EOL] cognito = _cognito ( cloud , username = email ) [EOL] [EOL] try : [EOL] cognito . client . resend_confirmation_code ( Username = email , ClientId = cognito . client_id ) [EOL] except ClientError as err : [EOL] raise _map_aws_exception ( err ) [EOL] [EOL] [EOL] def forgot_password ( cloud , email ) : [EOL] [docstring] [EOL] from botocore . exceptions import ClientError [EOL] [EOL] cognito = _cognito ( cloud , username = email ) [EOL] [EOL] try : [EOL] cognito . initiate_forgot_password ( ) [EOL] except ClientError as err : [EOL] raise _map_aws_exception ( err ) [EOL] [EOL] [EOL] def login ( cloud , email , password ) : [EOL] [docstring] [EOL] cognito = _authenticate ( cloud , email , password ) [EOL] cloud . id_token = cognito . id_token [EOL] cloud . access_token = cognito . access_token [EOL] cloud . refresh_token = cognito . refresh_token [EOL] cloud . write_user_info ( ) [EOL] [EOL] [EOL] def check_token ( cloud ) : [EOL] [docstring] [EOL] from botocore . exceptions import ClientError [EOL] [EOL] cognito = _cognito ( cloud , access_token = cloud . access_token , refresh_token = cloud . refresh_token ) [EOL] [EOL] try : [EOL] if cognito . check_token ( ) : [EOL] cloud . id_token = cognito . id_token [EOL] cloud . access_token = cognito . access_token [EOL] cloud . write_user_info ( ) [EOL] except ClientError as err : [EOL] raise _map_aws_exception ( err ) [EOL] [EOL] [EOL] def _authenticate ( cloud , email , password ) : [EOL] [docstring] [EOL] from botocore . exceptions import ClientError [EOL] from warrant . exceptions import ForceChangePasswordException [EOL] [EOL] assert not cloud . is_logged_in , [string] [EOL] [EOL] cognito = _cognito ( cloud , username = email ) [EOL] [EOL] try : [EOL] cognito . authenticate ( password = password ) [EOL] return cognito [EOL] [EOL] except ForceChangePasswordException as err : [EOL] raise PasswordChangeRequired [EOL] [EOL] except ClientError as err : [EOL] raise _map_aws_exception ( err ) [EOL] [EOL] [EOL] def _cognito ( cloud , ** kwargs ) : [EOL] [docstring] [EOL] import botocore [EOL] import boto3 [EOL] from warrant import Cognito [EOL] [EOL] cognito = Cognito ( user_pool_id = cloud . user_pool_id , client_id = cloud . cognito_client_id , user_pool_region = cloud . region , ** kwargs ) [EOL] cognito . client = boto3 . client ( [string] , region_name = cloud . region , config = botocore . config . Config ( signature_version = botocore . UNSIGNED ) ) [EOL] return cognito [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[typing.Union[homeassistant.components.cloud.auth_api.PasswordChangeRequired,homeassistant.components.cloud.auth_api.Unauthenticated,homeassistant.components.cloud.auth_api.UserNotConfirmed,homeassistant.components.cloud.auth_api.UserNotFound]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[typing.Union[homeassistant.components.cloud.auth_api.PasswordChangeRequired,homeassistant.components.cloud.auth_api.Unauthenticated,homeassistant.components.cloud.auth_api.UserNotConfirmed,homeassistant.components.cloud.auth_api.UserNotFound]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from requests . exceptions import ConnectionError as RequestsConnectionError [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . notify import ( ATTR_TARGET , ATTR_DATA , PLATFORM_SCHEMA , BaseNotificationService ) [EOL] from homeassistant . const import CONF_ICON [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] from homeassistant . components . lametric import DOMAIN as LAMETRIC_DOMAIN [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_LIFETIME = [string] [EOL] CONF_CYCLES = [string] [EOL] CONF_PRIORITY = [string] [EOL] [EOL] AVAILABLE_PRIORITIES = [ [string] , [string] , [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_ICON , default = [string] ) : cv . string , vol . Optional ( CONF_LIFETIME , default = [number] ) : cv . positive_int , vol . Optional ( CONF_CYCLES , default = [number] ) : cv . positive_int , vol . Optional ( CONF_PRIORITY , default = [string] ) : vol . In ( AVAILABLE_PRIORITIES ) } ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] hlmn = hass . data . get ( LAMETRIC_DOMAIN ) [EOL] return LaMetricNotificationService ( hlmn , config [ CONF_ICON ] , config [ CONF_LIFETIME ] * [number] , config [ CONF_CYCLES ] , config [ CONF_PRIORITY ] ) [EOL] [EOL] [EOL] class LaMetricNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hasslametricmanager , icon , lifetime , cycles , priority ) : [EOL] [docstring] [EOL] self . hasslametricmanager = hasslametricmanager [EOL] self . _icon = icon [EOL] self . _lifetime = lifetime [EOL] self . _cycles = cycles [EOL] self . _priority = priority [EOL] self . _devices = [ ] [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] from lmnotify import SimpleFrame , Sound , Model [EOL] from oauthlib . oauth2 import TokenExpiredError [EOL] [EOL] targets = kwargs . get ( ATTR_TARGET ) [EOL] data = kwargs . get ( ATTR_DATA ) [EOL] _LOGGER . debug ( [string] , targets , data ) [EOL] icon = self . _icon [EOL] cycles = self . _cycles [EOL] sound = None [EOL] priority = self . _priority [EOL] [EOL] [comment] [EOL] if data is not None : [EOL] if [string] in data : [EOL] icon = data [ [string] ] [EOL] if [string] in data : [EOL] try : [EOL] sound = Sound ( category = [string] , sound_id = data [ [string] ] ) [EOL] _LOGGER . debug ( [string] , data [ [string] ] ) [EOL] except AssertionError : [EOL] _LOGGER . error ( [string] , data [ [string] ] ) [EOL] if [string] in data : [EOL] cycles = data [ [string] ] [EOL] if [string] in data : [EOL] if data [ [string] ] in AVAILABLE_PRIORITIES : [EOL] priority = data [ [string] ] [EOL] else : [EOL] _LOGGER . warning ( [string] , data [ [string] ] , priority ) [EOL] [EOL] text_frame = SimpleFrame ( icon , message ) [EOL] _LOGGER . debug ( [string] , icon , message , self . _cycles , self . _lifetime ) [EOL] [EOL] frames = [ text_frame ] [EOL] [EOL] model = Model ( frames = frames , cycles = cycles , sound = sound ) [EOL] lmn = self . hasslametricmanager . manager [EOL] try : [EOL] self . _devices = lmn . get_devices ( ) [EOL] except TokenExpiredError : [EOL] _LOGGER . debug ( [string] ) [EOL] lmn . get_token ( ) [EOL] self . _devices = lmn . get_devices ( ) [EOL] except RequestsConnectionError : [EOL] _LOGGER . warning ( [string] [string] ) [EOL] for dev in self . _devices : [EOL] if targets is None or dev [ [string] ] in targets : [EOL] try : [EOL] lmn . set_device ( dev ) [EOL] lmn . send_notification ( model , lifetime = self . _lifetime , priority = priority ) [EOL] _LOGGER . debug ( [string] , dev [ [string] ] ) [EOL] except OSError : [EOL] _LOGGER . warning ( [string] , dev [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] import requests [EOL] [docstring] [EOL] import base64 [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_NAME ) [EOL] from homeassistant . core import split_entity_id [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . image_processing import ( PLATFORM_SCHEMA , ImageProcessingFaceEntity , ATTR_CONFIDENCE , CONF_SOURCE , CONF_ENTITY_ID , CONF_NAME , DOMAIN ) [EOL] from homeassistant . const import ( CONF_IP_ADDRESS , CONF_PORT ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_BOUNDING_BOX = [string] [EOL] ATTR_CLASSIFIER = [string] [EOL] ATTR_IMAGE_ID = [string] [EOL] ATTR_MATCHED = [string] [EOL] CLASSIFIER = [string] [EOL] DATA_FACEBOX = [string] [EOL] EVENT_CLASSIFIER_TEACH = [string] [EOL] FILE_PATH = [string] [EOL] SERVICE_TEACH_FACE = [string] [EOL] TIMEOUT = [number] [EOL] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_IP_ADDRESS ) : cv . string , vol . Required ( CONF_PORT ) : cv . port , } ) [EOL] [EOL] SERVICE_TEACH_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_NAME ) : cv . string , vol . Required ( FILE_PATH ) : cv . string , } ) [EOL] [EOL] [EOL] def encode_image ( image ) : [EOL] [docstring] [EOL] base64_img = base64 . b64encode ( image ) . decode ( [string] ) [EOL] return base64_img [EOL] [EOL] [EOL] def get_matched_faces ( faces ) : [EOL] [docstring] [EOL] return { face [ [string] ] : round ( face [ [string] ] , [number] ) for face in faces if face [ [string] ] } [EOL] [EOL] [EOL] def parse_faces ( api_faces ) : [EOL] [docstring] [EOL] known_faces = [ ] [EOL] for entry in api_faces : [EOL] face = { } [EOL] if entry [ [string] ] : [comment] [EOL] face [ ATTR_NAME ] = entry [ [string] ] [EOL] face [ ATTR_IMAGE_ID ] = entry [ [string] ] [EOL] else : [comment] [EOL] face [ ATTR_NAME ] = None [EOL] face [ ATTR_IMAGE_ID ] = None [EOL] face [ ATTR_CONFIDENCE ] = round ( [number] * entry [ [string] ] , [number] ) [EOL] face [ ATTR_MATCHED ] = entry [ [string] ] [EOL] face [ ATTR_BOUNDING_BOX ] = entry [ [string] ] [EOL] known_faces . append ( face ) [EOL] return known_faces [EOL] [EOL] [EOL] def post_image ( url , image ) : [EOL] [docstring] [EOL] try : [EOL] response = requests . post ( url , json = { [string] : encode_image ( image ) } , timeout = TIMEOUT ) [EOL] return response [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] , CLASSIFIER ) [EOL] [EOL] [EOL] def valid_file_path ( file_path ) : [EOL] [docstring] [EOL] try : [EOL] cv . isfile ( file_path ) [EOL] return True [EOL] except vol . Invalid : [EOL] _LOGGER . error ( [string] , CLASSIFIER , file_path ) [EOL] return False [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if DATA_FACEBOX not in hass . data : [EOL] hass . data [ DATA_FACEBOX ] = [ ] [EOL] [EOL] entities = [ ] [EOL] for camera in config [ CONF_SOURCE ] : [EOL] facebox = FaceClassifyEntity ( config [ CONF_IP_ADDRESS ] , config [ CONF_PORT ] , camera [ CONF_ENTITY_ID ] , camera . get ( CONF_NAME ) ) [EOL] entities . append ( facebox ) [EOL] hass . data [ DATA_FACEBOX ] . append ( facebox ) [EOL] add_devices ( entities ) [EOL] [EOL] def service_handle ( service ) : [EOL] [docstring] [EOL] entity_ids = service . data . get ( [string] ) [EOL] [EOL] classifiers = hass . data [ DATA_FACEBOX ] [EOL] if entity_ids : [EOL] classifiers = [ c for c in classifiers if c . entity_id in entity_ids ] [EOL] [EOL] for classifier in classifiers : [EOL] name = service . data . get ( ATTR_NAME ) [EOL] file_path = service . data . get ( FILE_PATH ) [EOL] classifier . teach ( name , file_path ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_TEACH_FACE , service_handle , schema = SERVICE_TEACH_SCHEMA ) [EOL] [EOL] [EOL] class FaceClassifyEntity ( ImageProcessingFaceEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ip , port , camera_entity , name = None ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _url_check = [string] . format ( ip , port , CLASSIFIER ) [EOL] self . _url_teach = [string] . format ( ip , port , CLASSIFIER ) [EOL] self . _camera = camera_entity [EOL] if name : [EOL] self . _name = name [EOL] else : [EOL] camera_name = split_entity_id ( camera_entity ) [ [number] ] [EOL] self . _name = [string] . format ( CLASSIFIER , camera_name ) [EOL] self . _matched = { } [EOL] [EOL] def process_image ( self , image ) : [EOL] [docstring] [EOL] response = post_image ( self . _url_check , image ) [EOL] if response is not None : [EOL] response_json = response . json ( ) [EOL] if response_json [ [string] ] : [EOL] total_faces = response_json [ [string] ] [EOL] faces = parse_faces ( response_json [ [string] ] ) [EOL] self . _matched = get_matched_faces ( faces ) [EOL] self . process_faces ( faces , total_faces ) [EOL] [EOL] else : [EOL] self . total_faces = None [EOL] self . faces = [ ] [EOL] self . _matched = { } [EOL] [EOL] def teach ( self , name , file_path ) : [EOL] [docstring] [EOL] if ( not self . hass . config . is_allowed_path ( file_path ) or not valid_file_path ( file_path ) ) : [EOL] return [EOL] with open ( file_path , [string] ) as open_file : [EOL] response = requests . post ( self . _url_teach , data = { ATTR_NAME : name , [string] : file_path } , files = { [string] : open_file } ) [EOL] [EOL] if response . status_code == [number] : [EOL] self . hass . bus . fire ( EVENT_CLASSIFIER_TEACH , { ATTR_CLASSIFIER : CLASSIFIER , ATTR_NAME : name , FILE_PATH : file_path , [string] : True , [string] : None } ) [EOL] [EOL] elif response . status_code == [number] : [EOL] _LOGGER . warning ( [string] , CLASSIFIER , file_path , response . text ) [EOL] self . hass . bus . fire ( EVENT_CLASSIFIER_TEACH , { ATTR_CLASSIFIER : CLASSIFIER , ATTR_NAME : name , FILE_PATH : file_path , [string] : False , [string] : response . text } ) [EOL] [EOL] @ property def camera_entity ( self ) : [EOL] [docstring] [EOL] return self . _camera [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _matched , [string] : len ( self . _matched ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . components . zigbee import ( ZigBeeDigitalOut , ZigBeeDigitalOutConfig , PLATFORM_SCHEMA ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_ON_STATE = [string] [EOL] [EOL] DEFAULT_ON_STATE = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] STATES = [ [string] , [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_ON_STATE ) : vol . In ( STATES ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] add_devices ( [ ZigBeeSwitch ( hass , ZigBeeDigitalOutConfig ( config ) ) ] ) [EOL] [EOL] [EOL] class ZigBeeSwitch ( ZigBeeDigitalOut , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . components . hive import DATA_HIVE [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] session = hass . data . get ( DATA_HIVE ) [EOL] [EOL] add_devices ( [ HiveDevicePlug ( session , discovery_info ) ] ) [EOL] [EOL] [EOL] class HiveDevicePlug ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hivesession , hivedevice ) : [EOL] [docstring] [EOL] self . node_id = hivedevice [ [string] ] [EOL] self . node_name = hivedevice [ [string] ] [EOL] self . device_type = hivedevice [ [string] ] [EOL] self . session = hivesession [EOL] self . attributes = { } [EOL] self . data_updatesource = [string] . format ( self . device_type , self . node_id ) [EOL] self . session . entities . append ( self ) [EOL] [EOL] def handle_update ( self , updatesource ) : [EOL] [docstring] [EOL] if [string] . format ( self . device_type , self . node_id ) not in updatesource : [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . node_name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . attributes [EOL] [EOL] @ property def current_power_w ( self ) : [EOL] [docstring] [EOL] return self . session . switch . get_power_usage ( self . node_id ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . session . switch . get_state ( self . node_id ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . session . switch . turn_on ( self . node_id ) [EOL] for entity in self . session . entities : [EOL] entity . handle_update ( self . data_updatesource ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . session . switch . turn_off ( self . node_id ) [EOL] for entity in self . session . entities : [EOL] entity . handle_update ( self . data_updatesource ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . session . core . update_data ( self . node_id ) [EOL] self . attributes = self . session . attributes . state_attributes ( self . node_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . linode import ( CONF_NODES , ATTR_CREATED , ATTR_NODE_ID , ATTR_NODE_NAME , ATTR_IPV4_ADDRESS , ATTR_IPV6_ADDRESS , ATTR_MEMORY , ATTR_REGION , ATTR_VCPUS , DATA_LINODE ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_NODES ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] linode = hass . data . get ( DATA_LINODE ) [EOL] nodes = config . get ( CONF_NODES ) [EOL] [EOL] dev = [ ] [EOL] for node in nodes : [EOL] node_id = linode . get_node_id ( node ) [EOL] if node_id is None : [EOL] _LOGGER . error ( [string] , node ) [EOL] return [EOL] dev . append ( LinodeSwitch ( linode , node_id ) ) [EOL] [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class LinodeSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , li , node_id ) : [EOL] [docstring] [EOL] self . _linode = li [EOL] self . _node_id = node_id [EOL] self . data = None [EOL] self . _state = None [EOL] self . _attrs = { } [EOL] self . _name = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attrs [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . data . status != [string] : [EOL] self . data . boot ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . data . status == [string] : [EOL] self . data . shutdown ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _linode . update ( ) [EOL] if self . _linode . data is not None : [EOL] for node in self . _linode . data : [EOL] if node . id == self . _node_id : [EOL] self . data = node [EOL] if self . data is not None : [EOL] self . _state = self . data . status == [string] [EOL] self . _attrs = { ATTR_CREATED : self . data . created , ATTR_NODE_ID : self . data . id , ATTR_NODE_NAME : self . data . label , ATTR_IPV4_ADDRESS : self . data . ipv4 , ATTR_IPV6_ADDRESS : self . data . ipv6 , ATTR_MEMORY : self . data . specs . memory , ATTR_REGION : self . data . region . country , ATTR_VCPUS : self . data . specs . vcpus , } [EOL] self . _name = self . data . label [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . digital_ocean import ( CONF_DROPLETS , ATTR_CREATED_AT , ATTR_DROPLET_ID , ATTR_DROPLET_NAME , ATTR_FEATURES , ATTR_IPV4_ADDRESS , ATTR_IPV6_ADDRESS , ATTR_MEMORY , ATTR_REGION , ATTR_VCPUS , CONF_ATTRIBUTION , DATA_DIGITAL_OCEAN ) [EOL] from homeassistant . const import ATTR_ATTRIBUTION [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DROPLETS ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] digital = hass . data . get ( DATA_DIGITAL_OCEAN ) [EOL] if not digital : [EOL] return False [EOL] [EOL] droplets = config . get ( CONF_DROPLETS ) [EOL] [EOL] dev = [ ] [EOL] for droplet in droplets : [EOL] droplet_id = digital . get_droplet_id ( droplet ) [EOL] if droplet_id is None : [EOL] _LOGGER . error ( [string] , droplet ) [EOL] return False [EOL] dev . append ( DigitalOceanSwitch ( digital , droplet_id ) ) [EOL] [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class DigitalOceanSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , do , droplet_id ) : [EOL] [docstring] [EOL] self . _digital_ocean = do [EOL] self . _droplet_id = droplet_id [EOL] self . data = None [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . data . name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . data . status == [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , ATTR_CREATED_AT : self . data . created_at , ATTR_DROPLET_ID : self . data . id , ATTR_DROPLET_NAME : self . data . name , ATTR_FEATURES : self . data . features , ATTR_IPV4_ADDRESS : self . data . ip_address , ATTR_IPV6_ADDRESS : self . data . ip_v6_address , ATTR_MEMORY : self . data . memory , ATTR_REGION : self . data . region [ [string] ] , ATTR_VCPUS : self . data . vcpus , } [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . data . status != [string] : [EOL] self . data . power_on ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . data . status == [string] : [EOL] self . data . power_off ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _digital_ocean . update ( ) [EOL] [EOL] for droplet in self . _digital_ocean . data : [EOL] if droplet . id == self . _droplet_id : [EOL] self . data = droplet [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Optional , Any [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import time [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] from homeassistant import util [EOL] from homeassistant . const import ( STATE_ON , STATE_OFF ) [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( milliseconds = [number] ) [EOL] [EOL] MIN_TIME_TO_WAIT = timedelta ( seconds = [number] ) [EOL] MIN_TIME_TO_LOCK_UPDATE = [number] [EOL] [EOL] SWITCH_TYPES = { [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from pythinkingcleaner import Discovery [EOL] [EOL] discovery = Discovery ( ) [EOL] devices = discovery . discover ( ) [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update_devices ( ) : [EOL] [docstring] [EOL] for device_object in devices : [EOL] device_object . update ( ) [EOL] [EOL] dev = [ ] [EOL] for device in devices : [EOL] for type_name in SWITCH_TYPES : [EOL] dev . append ( ThinkingCleanerSwitch ( device , type_name , update_devices ) ) [EOL] [EOL] add_devices ( dev ) [EOL] [EOL] [EOL] class ThinkingCleanerSwitch ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tc_object , switch_type , update_devices ) : [EOL] [docstring] [EOL] self . type = switch_type [EOL] [EOL] self . _update_devices = update_devices [EOL] self . _tc_object = tc_object [EOL] self . _state = self . _tc_object . is_cleaning if switch_type == [string] else False [EOL] self . lock = False [EOL] self . last_lock_time = None [EOL] self . graceful_state = False [EOL] [EOL] def lock_update ( self ) : [EOL] [docstring] [EOL] if self . is_update_locked ( ) : [EOL] return [EOL] self . lock = True [EOL] self . last_lock_time = time . time ( ) [EOL] [EOL] def reset_update_lock ( self ) : [EOL] [docstring] [EOL] self . lock = False [EOL] self . last_lock_time = None [EOL] [EOL] def set_graceful_lock ( self , state ) : [EOL] [docstring] [EOL] self . graceful_state = state [EOL] self . reset_update_lock ( ) [EOL] self . lock_update ( ) [EOL] [EOL] def is_update_locked ( self ) : [EOL] [docstring] [EOL] if self . last_lock_time is None : [EOL] return False [EOL] [EOL] if time . time ( ) - self . last_lock_time >= MIN_TIME_TO_LOCK_UPDATE : [EOL] self . last_lock_time = None [EOL] return False [EOL] [EOL] return True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _tc_object . name + [string] + SWITCH_TYPES [ self . type ] [ [number] ] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] if self . type == [string] : [EOL] return self . graceful_state \ [EOL] if self . is_update_locked ( ) else self . _tc_object . is_cleaning [EOL] [EOL] return False [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . type == [string] : [EOL] self . set_graceful_lock ( True ) [EOL] self . _tc_object . start_cleaning ( ) [EOL] elif self . type == [string] : [EOL] self . _tc_object . dock ( ) [EOL] elif self . type == [string] : [EOL] self . _tc_object . find_me ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . type == [string] : [EOL] self . set_graceful_lock ( False ) [EOL] self . _tc_object . stop_cleaning ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . type == [string] and not self . is_update_locked ( ) : [EOL] self . _tc_object . update ( ) [EOL] self . _state = STATE_ON \ [EOL] if self . _tc_object . is_cleaning else STATE_OFF [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , CONF_PAYLOAD_ON , CONF_PAYLOAD_OFF ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_BASEOID = [string] [EOL] CONF_COMMAND_OID = [string] [EOL] CONF_COMMAND_PAYLOAD_ON = [string] [EOL] CONF_COMMAND_PAYLOAD_OFF = [string] [EOL] CONF_COMMUNITY = [string] [EOL] CONF_VERSION = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_PORT = [string] [EOL] DEFAULT_COMMUNITY = [string] [EOL] DEFAULT_VERSION = [string] [EOL] DEFAULT_PAYLOAD_ON = [number] [EOL] DEFAULT_PAYLOAD_OFF = [number] [EOL] [EOL] SNMP_VERSIONS = { [string] : [number] , [string] : [number] } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_BASEOID ) : cv . string , vol . Optional ( CONF_COMMAND_OID ) : cv . string , vol . Optional ( CONF_COMMAND_PAYLOAD_ON ) : cv . string , vol . Optional ( CONF_COMMAND_PAYLOAD_OFF ) : cv . string , vol . Optional ( CONF_COMMUNITY , default = DEFAULT_COMMUNITY ) : cv . string , vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PAYLOAD_OFF , default = DEFAULT_PAYLOAD_OFF ) : cv . string , vol . Optional ( CONF_PAYLOAD_ON , default = DEFAULT_PAYLOAD_ON ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_VERSION , default = DEFAULT_VERSION ) : vol . In ( SNMP_VERSIONS ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] community = config . get ( CONF_COMMUNITY ) [EOL] baseoid = config . get ( CONF_BASEOID ) [EOL] command_oid = config . get ( CONF_COMMAND_OID ) [EOL] command_payload_on = config . get ( CONF_COMMAND_PAYLOAD_ON ) [EOL] command_payload_off = config . get ( CONF_COMMAND_PAYLOAD_OFF ) [EOL] version = config . get ( CONF_VERSION ) [EOL] payload_on = config . get ( CONF_PAYLOAD_ON ) [EOL] payload_off = config . get ( CONF_PAYLOAD_OFF ) [EOL] [EOL] add_devices ( [ SnmpSwitch ( name , host , port , community , baseoid , command_oid , version , payload_on , payload_off , command_payload_on , command_payload_off ) ] , True ) [EOL] [EOL] [EOL] class SnmpSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , host , port , community , baseoid , commandoid , version , payload_on , payload_off , command_payload_on , command_payload_off ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _community = community [EOL] self . _baseoid = baseoid [EOL] [EOL] [docstring] [EOL] self . _commandoid = commandoid or baseoid [EOL] self . _command_payload_on = command_payload_on or payload_on [EOL] self . _command_payload_off = command_payload_off or payload_off [EOL] [EOL] self . _version = SNMP_VERSIONS [ version ] [EOL] self . _state = None [EOL] self . _payload_on = payload_on [EOL] self . _payload_off = payload_off [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] from pyasn1 . type . univ import ( Integer ) [EOL] [EOL] self . _set ( Integer ( self . _command_payload_on ) ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] from pyasn1 . type . univ import ( Integer ) [EOL] [EOL] self . _set ( Integer ( self . _command_payload_off ) ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from pysnmp . hlapi import ( getCmd , CommunityData , SnmpEngine , UdpTransportTarget , ContextData , ObjectType , ObjectIdentity ) [EOL] [EOL] from pyasn1 . type . univ import ( Integer ) [EOL] [EOL] request = getCmd ( SnmpEngine ( ) , CommunityData ( self . _community , mpModel = self . _version ) , UdpTransportTarget ( ( self . _host , self . _port ) ) , ContextData ( ) , ObjectType ( ObjectIdentity ( self . _baseoid ) ) ) [EOL] [EOL] errindication , errstatus , errindex , restable = next ( request ) [EOL] [EOL] if errindication : [EOL] _LOGGER . error ( [string] , errindication ) [EOL] elif errstatus : [EOL] _LOGGER . error ( [string] , errstatus . prettyPrint ( ) , errindex and restable [ - [number] ] [ int ( errindex ) - [number] ] or [string] ) [EOL] else : [EOL] for resrow in restable : [EOL] if resrow [ - [number] ] == Integer ( self . _payload_on ) : [EOL] self . _state = True [EOL] elif resrow [ - [number] ] == Integer ( self . _payload_off ) : [EOL] self . _state = False [EOL] else : [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def _set ( self , value ) : [EOL] from pysnmp . hlapi import ( setCmd , CommunityData , SnmpEngine , UdpTransportTarget , ContextData , ObjectType , ObjectIdentity ) [EOL] [EOL] request = setCmd ( SnmpEngine ( ) , CommunityData ( self . _community , mpModel = self . _version ) , UdpTransportTarget ( ( self . _host , self . _port ) ) , ContextData ( ) , ObjectType ( ObjectIdentity ( self . _commandoid ) , value ) ) [EOL] [EOL] next ( request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
import builtins [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_NAME , CONF_DEVICES [EOL] from homeassistant . components . switch import SwitchDevice , PLATFORM_SCHEMA [EOL] from homeassistant . components . velbus import DOMAIN [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SWITCH_SCHEMA = { vol . Required ( [string] ) : cv . positive_int , vol . Required ( [string] ) : cv . positive_int , vol . Required ( CONF_NAME ) : cv . string } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICES ) : vol . All ( cv . ensure_list , [ SWITCH_SCHEMA ] ) } ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] velbus = hass . data [ DOMAIN ] [EOL] devices = [ ] [EOL] [EOL] for switch in config [ CONF_DEVICES ] : [EOL] devices . append ( VelbusSwitch ( switch , velbus ) ) [EOL] add_devices ( devices ) [EOL] return True [EOL] [EOL] [EOL] class VelbusSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , switch , velbus ) : [EOL] [docstring] [EOL] self . _velbus = velbus [EOL] self . _name = switch [ CONF_NAME ] [EOL] self . _module = switch [ [string] ] [EOL] self . _channel = switch [ [string] ] [EOL] self . _state = False [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] def _init_velbus ( ) : [EOL] [docstring] [EOL] self . _velbus . subscribe ( self . _on_message ) [EOL] self . get_status ( ) [EOL] [EOL] yield from self . hass . async_add_job ( _init_velbus ) [EOL] [EOL] def _on_message ( self , message ) : [EOL] import velbus [EOL] if isinstance ( message , velbus . RelayStatusMessage ) and message . address == self . _module and message . channel == self . _channel : [EOL] self . _state = message . is_on ( ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] import velbus [EOL] message = velbus . SwitchRelayOnMessage ( ) [EOL] message . set_defaults ( self . _module ) [EOL] message . relay_channels = [ self . _channel ] [EOL] self . _velbus . send ( message ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] import velbus [EOL] message = velbus . SwitchRelayOffMessage ( ) [EOL] message . set_defaults ( self . _module ) [EOL] message . relay_channels = [ self . _channel ] [EOL] self . _velbus . send ( message ) [EOL] [EOL] def get_status ( self ) : [EOL] [docstring] [EOL] import velbus [EOL] message = velbus . ModuleStatusRequestMessage ( ) [EOL] message . set_defaults ( self . _module ) [EOL] message . channels = [ self . _channel ] [EOL] self . _velbus . send ( message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[docstring] [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . const import DEVICE_DEFAULT_NAME [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices_callback , discovery_info = None ) : [EOL] [docstring] [EOL] add_devices_callback ( [ DemoSwitch ( [string] , True , None , True ) , DemoSwitch ( [string] , False , [string] , False ) ] ) [EOL] [EOL] [EOL] class DemoSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , state , icon , assumed ) : [EOL] [docstring] [EOL] self . _name = name or DEVICE_DEFAULT_NAME [EOL] self . _state = state [EOL] self . _icon = icon [EOL] self . _assumed = assumed [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return self . _assumed [EOL] [EOL] @ property def current_power_w ( self ) : [EOL] [docstring] [EOL] if self . _state : [EOL] return [number] [EOL] [EOL] @ property def today_energy_kwh ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _state = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _state = False [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import voluptuous as vol [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from pyvesync . vesync import VeSync [EOL] [EOL] switches = [ ] [EOL] [EOL] manager = VeSync ( config . get ( CONF_USERNAME ) , config . get ( CONF_PASSWORD ) ) [EOL] [EOL] if not manager . login ( ) : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] manager . update ( ) [EOL] [EOL] if manager . devices is not None and manager . devices : [EOL] if len ( manager . devices ) == [number] : [EOL] count_string = [string] [EOL] else : [EOL] count_string = [string] [EOL] [EOL] _LOGGER . info ( [string] , len ( manager . devices ) , count_string ) [EOL] [EOL] for switch in manager . devices : [EOL] switches . append ( VeSyncSwitchHA ( switch ) ) [EOL] _LOGGER . info ( [string] , switch . device_name ) [EOL] else : [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] add_devices ( switches ) [EOL] [EOL] [EOL] class VeSyncSwitchHA ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , plug ) : [EOL] [docstring] [EOL] self . smartplug = plug [EOL] self . _current_power_w = None [EOL] self . _today_energy_kwh = None [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . smartplug . cid [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . smartplug . device_name [EOL] [EOL] @ property def current_power_w ( self ) : [EOL] [docstring] [EOL] return self . _current_power_w [EOL] [EOL] @ property def today_energy_kwh ( self ) : [EOL] [docstring] [EOL] return self . _today_energy_kwh [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . smartplug . connection_status == [string] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . smartplug . device_status == [string] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . smartplug . turn_on ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . smartplug . turn_off ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . smartplug . update ( ) [EOL] self . _current_power_w = self . smartplug . get_power ( ) [EOL] self . _today_energy_kwh = self . smartplug . get_kwh_today ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] DEVICE_CLASS = { } [EOL] SINGLE_INPUT_CLUSTER_DEVICE_CLASS = { } [EOL] SINGLE_OUTPUT_CLUSTER_DEVICE_CLASS = { } [EOL] COMPONENT_CLUSTERS = { } [EOL] [EOL] [EOL] def populate_data ( ) : [EOL] [docstring] [EOL] from zigpy import zcl [EOL] from zigpy . profiles import PROFILES , zha , zll [EOL] [EOL] DEVICE_CLASS [ zha . PROFILE_ID ] = { zha . DeviceType . ON_OFF_SWITCH : [string] , zha . DeviceType . LEVEL_CONTROL_SWITCH : [string] , zha . DeviceType . REMOTE_CONTROL : [string] , zha . DeviceType . SMART_PLUG : [string] , zha . DeviceType . ON_OFF_LIGHT : [string] , zha . DeviceType . DIMMABLE_LIGHT : [string] , zha . DeviceType . COLOR_DIMMABLE_LIGHT : [string] , zha . DeviceType . ON_OFF_LIGHT_SWITCH : [string] , zha . DeviceType . DIMMER_SWITCH : [string] , zha . DeviceType . COLOR_DIMMER_SWITCH : [string] , } [EOL] DEVICE_CLASS [ zll . PROFILE_ID ] = { zll . DeviceType . ON_OFF_LIGHT : [string] , zll . DeviceType . ON_OFF_PLUGIN_UNIT : [string] , zll . DeviceType . DIMMABLE_LIGHT : [string] , zll . DeviceType . DIMMABLE_PLUGIN_UNIT : [string] , zll . DeviceType . COLOR_LIGHT : [string] , zll . DeviceType . EXTENDED_COLOR_LIGHT : [string] , zll . DeviceType . COLOR_TEMPERATURE_LIGHT : [string] , zll . DeviceType . COLOR_CONTROLLER : [string] , zll . DeviceType . COLOR_SCENE_CONTROLLER : [string] , zll . DeviceType . CONTROLLER : [string] , zll . DeviceType . SCENE_CONTROLLER : [string] , zll . DeviceType . ON_OFF_SENSOR : [string] , } [EOL] [EOL] SINGLE_INPUT_CLUSTER_DEVICE_CLASS . update ( { zcl . clusters . general . OnOff : [string] , zcl . clusters . measurement . RelativeHumidity : [string] , zcl . clusters . measurement . TemperatureMeasurement : [string] , zcl . clusters . measurement . PressureMeasurement : [string] , zcl . clusters . measurement . IlluminanceMeasurement : [string] , zcl . clusters . smartenergy . Metering : [string] , zcl . clusters . homeautomation . ElectricalMeasurement : [string] , zcl . clusters . security . IasZone : [string] , zcl . clusters . hvac . Fan : [string] , } ) [EOL] SINGLE_OUTPUT_CLUSTER_DEVICE_CLASS . update ( { zcl . clusters . general . OnOff : [string] , } ) [EOL] [EOL] [comment] [EOL] for profile_id , classes in DEVICE_CLASS . items ( ) : [EOL] profile = PROFILES [ profile_id ] [EOL] for device_type , component in classes . items ( ) : [EOL] if component not in COMPONENT_CLUSTERS : [EOL] COMPONENT_CLUSTERS [ component ] = ( set ( ) , set ( ) ) [EOL] clusters = profile . CLUSTERS [ device_type ] [EOL] COMPONENT_CLUSTERS [ component ] [ [number] ] . update ( clusters [ [number] ] ) [EOL] COMPONENT_CLUSTERS [ component ] [ [number] ] . update ( clusters [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from datetime import timedelta [EOL] import requests [EOL] [EOL] from homeassistant . components . abode import AbodeDevice , DOMAIN as ABODE_DOMAIN [EOL] from homeassistant . components . camera import Camera [EOL] from homeassistant . util import Throttle [EOL] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import abodepy . helpers . constants as CONST [EOL] import abodepy . helpers . timeline as TIMELINE [EOL] [EOL] data = hass . data [ ABODE_DOMAIN ] [EOL] [EOL] devices = [ ] [EOL] for device in data . abode . get_devices ( generic_type = CONST . TYPE_CAMERA ) : [EOL] if data . is_excluded ( device ) : [EOL] continue [EOL] [EOL] devices . append ( AbodeCamera ( data , device , TIMELINE . CAPTURE_IMAGE ) ) [EOL] [EOL] data . devices . extend ( devices ) [EOL] [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class AbodeCamera ( AbodeDevice , Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , device , event ) : [EOL] [docstring] [EOL] AbodeDevice . __init__ ( self , data , device ) [EOL] Camera . __init__ ( self ) [EOL] self . _event = event [EOL] self . _response = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] yield from super ( ) . async_added_to_hass ( ) [EOL] [EOL] self . hass . async_add_job ( self . _data . abode . events . add_timeline_callback , self . _event , self . _capture_callback ) [EOL] [EOL] def capture ( self ) : [EOL] [docstring] [EOL] return self . _device . capture ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def refresh_image ( self ) : [EOL] [docstring] [EOL] if self . _device . refresh_image ( ) : [EOL] self . get_image ( ) [EOL] [EOL] def get_image ( self ) : [EOL] [docstring] [EOL] if self . _device . image_url : [EOL] try : [EOL] self . _response = requests . get ( self . _device . image_url , stream = True ) [EOL] [EOL] self . _response . raise_for_status ( ) [EOL] except requests . HTTPError as err : [EOL] _LOGGER . warning ( [string] , err ) [EOL] self . _response = None [EOL] else : [EOL] self . _response = None [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] self . refresh_image ( ) [EOL] [EOL] if self . _response : [EOL] return self . _response . content [EOL] [EOL] return None [EOL] [EOL] def _capture_callback ( self , capture ) : [EOL] [docstring] [EOL] self . _device . update_image_location ( capture ) [EOL] self . get_image ( ) [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Union , Dict , Literal , Any , Optional , List , IO [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import tempfile [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import EVENT_HOMEASSISTANT_STOP [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [comment] [EOL] HBMQTT_CONFIG_SCHEMA = vol . Any ( None , vol . Schema ( { vol . Optional ( [string] ) : vol . Schema ( { vol . Optional ( [string] ) : cv . isfile , } , extra = vol . ALLOW_EXTRA ) , vol . Optional ( [string] ) : vol . Schema ( { vol . Required ( [string] ) : vol . Schema ( dict ) , str : vol . Schema ( dict ) } ) } , extra = vol . ALLOW_EXTRA ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_start ( hass , server_config ) : [EOL] [docstring] [EOL] from hbmqtt . broker import Broker , BrokerException [EOL] [EOL] try : [EOL] passwd = tempfile . NamedTemporaryFile ( ) [EOL] [EOL] if server_config is None : [EOL] server_config , client_config = generate_config ( hass , passwd ) [EOL] else : [EOL] client_config = None [EOL] [EOL] broker = Broker ( server_config , hass . loop ) [EOL] yield from broker . start ( ) [EOL] except BrokerException : [EOL] logging . getLogger ( __name__ ) . exception ( [string] ) [EOL] return False , None [EOL] finally : [EOL] passwd . close ( ) [EOL] [EOL] @ asyncio . coroutine def async_shutdown_mqtt_server ( event ) : [EOL] [docstring] [EOL] yield from broker . shutdown ( ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , async_shutdown_mqtt_server ) [EOL] [EOL] return True , client_config [EOL] [EOL] [EOL] def generate_config ( hass , passwd ) : [EOL] [docstring] [EOL] from homeassistant . components . mqtt import PROTOCOL_311 [EOL] config = { [string] : { [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , } , [string] : { [string] : hass . config . api . api_password is None } , [string] : [ [string] ] , } [EOL] [EOL] if hass . config . api . api_password : [EOL] username = [string] [EOL] password = hass . config . api . api_password [EOL] [EOL] [comment] [EOL] from passlib . apps import custom_app_context [EOL] [EOL] passwd . write ( [string] . format ( custom_app_context . encrypt ( hass . config . api . api_password ) ) . encode ( [string] ) ) [EOL] passwd . flush ( ) [EOL] [EOL] config [ [string] ] [ [string] ] = passwd . name [EOL] config [ [string] ] . append ( [string] ) [EOL] else : [EOL] username = None [EOL] password = None [EOL] [EOL] client_config = ( [string] , [number] , username , password , None , PROTOCOL_311 ) [EOL] [EOL] return config , client_config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , List , Any [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] from aiohttp . hdrs import USER_AGENT [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import ( PLATFORM_SCHEMA , BinarySensorDevice ) [EOL] from homeassistant . const import CONF_NAME , ATTR_ATTRIBUTION [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ATTRIBUTION = [string] [string] [EOL] CONF_THRESHOLD = [string] [EOL] [EOL] DEFAULT_DEVICE_CLASS = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_THRESHOLD = [number] [EOL] [EOL] HA_USER_AGENT = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] URL = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_THRESHOLD , default = DEFAULT_THRESHOLD ) : cv . positive_int , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if None in ( hass . config . latitude , hass . config . longitude ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] threshold = config . get ( CONF_THRESHOLD ) [EOL] [EOL] try : [EOL] aurora_data = AuroraData ( hass . config . latitude , hass . config . longitude , threshold ) [EOL] aurora_data . update ( ) [EOL] except requests . exceptions . HTTPError as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] return False [EOL] [EOL] add_devices ( [ AuroraSensor ( aurora_data , name ) ] , True ) [EOL] [EOL] [EOL] class AuroraSensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , aurora_data , name ) : [EOL] [docstring] [EOL] self . aurora_data = aurora_data [EOL] self . _name = name [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . aurora_data . is_visible if self . aurora_data else False [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEFAULT_DEVICE_CLASS [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { } [EOL] [EOL] if self . aurora_data : [EOL] attrs [ [string] ] = self . aurora_data . visibility_level [EOL] attrs [ [string] ] = self . aurora_data . is_visible_text [EOL] attrs [ ATTR_ATTRIBUTION ] = CONF_ATTRIBUTION [EOL] return attrs [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . aurora_data . update ( ) [EOL] [EOL] [EOL] class AuroraData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , latitude , longitude , threshold ) : [EOL] [docstring] [EOL] self . latitude = latitude [EOL] self . longitude = longitude [EOL] self . number_of_latitude_intervals = [number] [EOL] self . number_of_longitude_intervals = [number] [EOL] self . headers = { USER_AGENT : HA_USER_AGENT } [EOL] self . threshold = int ( threshold ) [EOL] self . is_visible = None [EOL] self . is_visible_text = None [EOL] self . visibility_level = None [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . visibility_level = self . get_aurora_forecast ( ) [EOL] if int ( self . visibility_level ) > self . threshold : [EOL] self . is_visible = True [EOL] self . is_visible_text = [string] [EOL] else : [EOL] self . is_visible = False [EOL] self . is_visible_text = [string] [EOL] [EOL] except requests . exceptions . HTTPError as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] return False [EOL] [EOL] def get_aurora_forecast ( self ) : [EOL] [docstring] [EOL] raw_data = requests . get ( URL , headers = self . headers , timeout = [number] ) . text [EOL] forecast_table = [ row . strip ( [string] ) . split ( [string] ) for row in raw_data . split ( [string] ) if not row . startswith ( [string] ) ] [EOL] [EOL] [comment] [EOL] converted_latitude = round ( ( self . latitude / [number] ) * self . number_of_latitude_intervals ) [EOL] converted_longitude = round ( ( self . longitude / [number] ) * self . number_of_longitude_intervals ) [EOL] [EOL] return forecast_table [ converted_latitude ] [ converted_longitude ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . ads import CONF_ADS_VAR , DATA_ADS [EOL] from homeassistant . components . binary_sensor import ( DEVICE_CLASSES_SCHEMA , PLATFORM_SCHEMA , BinarySensorDevice ) [EOL] from homeassistant . const import CONF_DEVICE_CLASS , CONF_NAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ADS_VAR ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_DEVICE_CLASS ) : DEVICE_CLASSES_SCHEMA , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] ads_hub = hass . data . get ( DATA_ADS ) [EOL] [EOL] ads_var = config . get ( CONF_ADS_VAR ) [EOL] name = config . get ( CONF_NAME ) [EOL] device_class = config . get ( CONF_DEVICE_CLASS ) [EOL] [EOL] ads_sensor = AdsBinarySensor ( ads_hub , name , ads_var , device_class ) [EOL] add_devices ( [ ads_sensor ] ) [EOL] [EOL] [EOL] class AdsBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ads_hub , name , ads_var , device_class ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _state = False [EOL] self . _device_class = device_class or [string] [EOL] self . _ads_hub = ads_hub [EOL] self . ads_var = ads_var [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] def update ( name , value ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , name , value ) [EOL] self . _state = value [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] self . hass . async_add_job ( self . _ads_hub . add_device_notification , self . ads_var , self . _ads_hub . PLCTYPE_BOOL , update ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , Type , List [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import DOMAIN , BinarySensorDevice [EOL] from homeassistant . components import zha [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [comment] [EOL] CLASS_MAPPING = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , } [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] discovery_info = zha . get_discovery_info ( hass , discovery_info ) [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] from zigpy . zcl . clusters . general import OnOff [EOL] from zigpy . zcl . clusters . security import IasZone [EOL] if IasZone . cluster_id in discovery_info [ [string] ] : [EOL] await _async_setup_iaszone ( hass , config , async_add_devices , discovery_info ) [EOL] elif OnOff . cluster_id in discovery_info [ [string] ] : [EOL] await _async_setup_remote ( hass , config , async_add_devices , discovery_info ) [EOL] [EOL] [EOL] async def _async_setup_iaszone ( hass , config , async_add_devices , discovery_info ) : [EOL] device_class = None [EOL] from zigpy . zcl . clusters . security import IasZone [EOL] cluster = discovery_info [ [string] ] [ IasZone . cluster_id ] [EOL] if discovery_info [ [string] ] : [EOL] await cluster . bind ( ) [EOL] ieee = cluster . endpoint . device . application . ieee [EOL] await cluster . write_attributes ( { [string] : ieee } ) [EOL] [EOL] try : [EOL] zone_type = await cluster [ [string] ] [EOL] device_class = CLASS_MAPPING . get ( zone_type , None ) [EOL] except Exception : [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] sensor = BinarySensor ( device_class , ** discovery_info ) [EOL] async_add_devices ( [ sensor ] , update_before_add = True ) [EOL] [EOL] [EOL] async def _async_setup_remote ( hass , config , async_add_devices , discovery_info ) : [EOL] [EOL] async def safe ( coro ) : [EOL] [docstring] [EOL] import zigpy . exceptions [EOL] try : [EOL] await coro [EOL] except zigpy . exceptions . DeliveryError as exc : [EOL] _LOGGER . warning ( [string] , exc ) [EOL] [EOL] if discovery_info [ [string] ] : [EOL] from zigpy . zcl . clusters . general import OnOff , LevelControl [EOL] out_clusters = discovery_info [ [string] ] [EOL] if OnOff . cluster_id in out_clusters : [EOL] cluster = out_clusters [ OnOff . cluster_id ] [EOL] await safe ( cluster . bind ( ) ) [EOL] await safe ( cluster . configure_reporting ( [number] , [number] , [number] , [number] ) ) [EOL] if LevelControl . cluster_id in out_clusters : [EOL] cluster = out_clusters [ LevelControl . cluster_id ] [EOL] await safe ( cluster . bind ( ) ) [EOL] await safe ( cluster . configure_reporting ( [number] , [number] , [number] , [number] ) ) [EOL] [EOL] sensor = Switch ( ** discovery_info ) [EOL] async_add_devices ( [ sensor ] , update_before_add = True ) [EOL] [EOL] [EOL] class BinarySensor ( zha . Entity , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] _domain = DOMAIN [EOL] [EOL] def __init__ ( self , device_class , ** kwargs ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] self . _device_class = device_class [EOL] from zigpy . zcl . clusters . security import IasZone [EOL] self . _ias_zone_cluster = self . _in_clusters [ IasZone . cluster_id ] [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] if self . _state is None : [EOL] return False [EOL] return bool ( self . _state ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] def cluster_command ( self , tsn , command_id , args ) : [EOL] [docstring] [EOL] if command_id == [number] : [EOL] self . _state = args [ [number] ] & [number] [EOL] _LOGGER . debug ( [string] , self . _state ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] elif command_id == [number] : [EOL] _LOGGER . debug ( [string] ) [EOL] res = self . _ias_zone_cluster . enroll_response ( [number] , [number] ) [EOL] self . hass . async_add_job ( res ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] from bellows . types . basic import uint16_t [EOL] [EOL] result = await zha . safe_read ( self . _endpoint . ias_zone , [ [string] ] , allow_cache = False ) [EOL] state = result . get ( [string] , self . _state ) [EOL] if isinstance ( state , ( int , uint16_t ) ) : [EOL] self . _state = result . get ( [string] , self . _state ) & [number] [EOL] [EOL] [EOL] class Switch ( zha . Entity , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] _domain = DOMAIN [EOL] [EOL] class OnOffListener : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , entity ) : [EOL] [docstring] [EOL] self . _entity = entity [EOL] [EOL] def cluster_command ( self , tsn , command_id , args ) : [EOL] [docstring] [EOL] if command_id in ( [number] , [number] ) : [EOL] self . _entity . set_state ( False ) [EOL] elif command_id in ( [number] , [number] , [number] ) : [EOL] self . _entity . set_state ( True ) [EOL] elif command_id == [number] : [EOL] self . _entity . set_state ( not self . _entity . is_on ) [EOL] [EOL] def attribute_updated ( self , attrid , value ) : [EOL] [docstring] [EOL] if attrid == [number] : [EOL] self . _entity . set_state ( value ) [EOL] [EOL] def zdo_command ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] class LevelListener : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , entity ) : [EOL] [docstring] [EOL] self . _entity = entity [EOL] [EOL] def cluster_command ( self , tsn , command_id , args ) : [EOL] [docstring] [EOL] if command_id in ( [number] , [number] ) : [comment] [EOL] self . _entity . set_level ( args [ [number] ] ) [EOL] elif command_id in ( [number] , [number] ) : [comment] [EOL] [comment] [EOL] rate = args [ [number] ] [EOL] if args [ [number] ] == [number] : [EOL] rate = [number] [comment] [EOL] self . _entity . move_level ( - rate if args [ [number] ] else rate ) [EOL] elif command_id in ( [number] , [number] ) : [comment] [EOL] [comment] [EOL] self . _entity . move_level ( - args [ [number] ] if args [ [number] ] else args [ [number] ] ) [EOL] [EOL] def attribute_update ( self , attrid , value ) : [EOL] [docstring] [EOL] if attrid == [number] : [EOL] self . _entity . set_level ( value ) [EOL] [EOL] def zdo_command ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def __init__ ( self , ** kwargs ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] self . _state = False [EOL] self . _level = [number] [EOL] from zigpy . zcl . clusters import general [EOL] self . _out_listeners = { general . OnOff . cluster_id : self . OnOffListener ( self ) , general . LevelControl . cluster_id : self . LevelListener ( self ) , } [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] self . _device_state_attributes . update ( { [string] : self . _state and self . _level or [number] } ) [EOL] return self . _device_state_attributes [EOL] [EOL] def move_level ( self , change ) : [EOL] [docstring] [EOL] if not self . _state and change > [number] : [EOL] self . _level = [number] [EOL] self . _level = min ( [number] , max ( [number] , self . _level + change ) ) [EOL] self . _state = bool ( self . _level ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] def set_level ( self , level ) : [EOL] [docstring] [EOL] self . _level = level [EOL] self . _state = bool ( self . _level ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] def set_state ( self , state ) : [EOL] [docstring] [EOL] self . _state = state [EOL] if self . _level == [number] : [EOL] self . _level = [number] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] from zigpy . zcl . clusters . general import OnOff [EOL] result = await zha . safe_read ( self . _endpoint . out_clusters [ OnOff . cluster_id ] , [ [string] ] ) [EOL] self . _state = result . get ( [string] , self . _state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.binary_sensor.zha.BinarySensor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.binary_sensor.zha.Switch]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0
from typing import Generator , List , Any , Type [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . sensor import DOMAIN [EOL] from homeassistant . components import zha [EOL] from homeassistant . const import TEMP_CELSIUS [EOL] from homeassistant . util . temperature import convert as convert_temperature [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] discovery_info = zha . get_discovery_info ( hass , discovery_info ) [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] sensor = yield from make_sensor ( discovery_info ) [EOL] async_add_devices ( [ sensor ] , update_before_add = True ) [EOL] [EOL] [EOL] @ asyncio . coroutine def make_sensor ( discovery_info ) : [EOL] [docstring] [EOL] from zigpy . zcl . clusters . measurement import ( RelativeHumidity , TemperatureMeasurement , PressureMeasurement , IlluminanceMeasurement ) [EOL] from zigpy . zcl . clusters . smartenergy import Metering [EOL] from zigpy . zcl . clusters . homeautomation import ElectricalMeasurement [EOL] in_clusters = discovery_info [ [string] ] [EOL] if RelativeHumidity . cluster_id in in_clusters : [EOL] sensor = RelativeHumiditySensor ( ** discovery_info ) [EOL] elif TemperatureMeasurement . cluster_id in in_clusters : [EOL] sensor = TemperatureSensor ( ** discovery_info ) [EOL] elif PressureMeasurement . cluster_id in in_clusters : [EOL] sensor = PressureSensor ( ** discovery_info ) [EOL] elif IlluminanceMeasurement . cluster_id in in_clusters : [EOL] sensor = IlluminanceMeasurementSensor ( ** discovery_info ) [EOL] elif Metering . cluster_id in in_clusters : [EOL] sensor = MeteringSensor ( ** discovery_info ) [EOL] elif ElectricalMeasurement . cluster_id in in_clusters : [EOL] sensor = ElectricalMeasurementSensor ( ** discovery_info ) [EOL] return sensor [EOL] else : [EOL] sensor = Sensor ( ** discovery_info ) [EOL] [EOL] if discovery_info [ [string] ] : [EOL] cluster = list ( in_clusters . values ( ) ) [ [number] ] [EOL] yield from cluster . bind ( ) [EOL] yield from cluster . configure_reporting ( sensor . value_attribute , [number] , [number] , sensor . min_reportable_change , ) [EOL] [EOL] return sensor [EOL] [EOL] [EOL] class Sensor ( zha . Entity ) : [EOL] [docstring] [EOL] [EOL] _domain = DOMAIN [EOL] value_attribute = [number] [EOL] min_reportable_change = [number] [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if isinstance ( self . _state , float ) : [EOL] return str ( round ( self . _state , [number] ) ) [EOL] return self . _state [EOL] [EOL] def attribute_updated ( self , attribute , value ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self , attribute , value ) [EOL] if attribute == self . value_attribute : [EOL] self . _state = value [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] result = await zha . safe_read ( list ( self . _in_clusters . values ( ) ) [ [number] ] , [ self . value_attribute ] ) [EOL] self . _state = result . get ( self . value_attribute , self . _state ) [EOL] [EOL] [EOL] class TemperatureSensor ( Sensor ) : [EOL] [docstring] [EOL] [EOL] min_reportable_change = [number] [comment] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . hass . config . units . temperature_unit [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _state is None : [EOL] return None [EOL] celsius = self . _state / [number] [EOL] return round ( convert_temperature ( celsius , TEMP_CELSIUS , self . unit_of_measurement ) , [number] ) [EOL] [EOL] [EOL] class RelativeHumiditySensor ( Sensor ) : [EOL] [docstring] [EOL] [EOL] min_reportable_change = [number] [comment] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _state is None : [EOL] return None [EOL] [EOL] return round ( float ( self . _state ) / [number] , [number] ) [EOL] [EOL] [EOL] class PressureSensor ( Sensor ) : [EOL] [docstring] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _state is None : [EOL] return None [EOL] [EOL] return round ( float ( self . _state ) ) [EOL] [EOL] [EOL] class IlluminanceMeasurementSensor ( Sensor ) : [EOL] [docstring] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] [EOL] class MeteringSensor ( Sensor ) : [EOL] [docstring] [EOL] [EOL] value_attribute = [number] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _state is None : [EOL] return None [EOL] [EOL] return round ( float ( self . _state ) ) [EOL] [EOL] [EOL] class ElectricalMeasurementSensor ( Sensor ) : [EOL] [docstring] [EOL] [EOL] value_attribute = [number] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def force_update ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _state is None : [EOL] return None [EOL] [EOL] return round ( float ( self . _state ) / [number] , [number] ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . entity_id ) [EOL] [EOL] result = await zha . safe_read ( self . _endpoint . electrical_measurement , [ [string] ] , allow_cache = False ) [EOL] self . _state = result . get ( [string] , self . _state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.sensor.zha.Sensor]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components import ads [EOL] from homeassistant . components . ads import ( CONF_ADS_FACTOR , CONF_ADS_TYPE , CONF_ADS_VAR ) [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME , CONF_UNIT_OF_MEASUREMENT [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ADS_VAR ) : cv . string , vol . Optional ( CONF_ADS_FACTOR ) : cv . positive_int , vol . Optional ( CONF_ADS_TYPE , default = ads . ADSTYPE_INT ) : vol . In ( [ ads . ADSTYPE_INT , ads . ADSTYPE_UINT , ads . ADSTYPE_BYTE ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_UNIT_OF_MEASUREMENT , default = [string] ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] ads_hub = hass . data . get ( ads . DATA_ADS ) [EOL] [EOL] ads_var = config . get ( CONF_ADS_VAR ) [EOL] ads_type = config . get ( CONF_ADS_TYPE ) [EOL] name = config . get ( CONF_NAME ) [EOL] unit_of_measurement = config . get ( CONF_UNIT_OF_MEASUREMENT ) [EOL] factor = config . get ( CONF_ADS_FACTOR ) [EOL] [EOL] entity = AdsSensor ( ads_hub , ads_var , ads_type , name , unit_of_measurement , factor ) [EOL] [EOL] add_devices ( [ entity ] ) [EOL] [EOL] [EOL] class AdsSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ads_hub , ads_var , ads_type , name , unit_of_measurement , factor ) : [EOL] [docstring] [EOL] self . _ads_hub = ads_hub [EOL] self . _name = name [EOL] self . _value = None [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . ads_var = ads_var [EOL] self . ads_type = ads_type [EOL] self . factor = factor [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] def update ( name , value ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , name , value ) [EOL] [EOL] [comment] [EOL] if self . factor is None : [EOL] self . _value = value [EOL] else : [EOL] self . _value = value / self . factor [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] self . hass . async_add_job ( self . _ads_hub . add_device_notification , self . ads_var , self . _ads_hub . ADS_TYPEMAP [ self . ads_type ] , update ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _value [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_STATION = [string] [EOL] ATTR_ORIGIN = [string] [EOL] ATTR_DESTINATION = [string] [EOL] ATTR_DIRECTION = [string] [EOL] ATTR_STOPS_AT = [string] [EOL] ATTR_DUE_IN = [string] [EOL] ATTR_DUE_AT = [string] [EOL] ATTR_EXPECT_AT = [string] [EOL] ATTR_NEXT_UP = [string] [EOL] ATTR_TRAIN_TYPE = [string] [EOL] [EOL] CONF_STATION = [string] [EOL] CONF_DESTINATION = [string] [EOL] CONF_DIRECTION = [string] [EOL] CONF_STOPS_AT = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] ICON = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] TIME_STR_FORMAT = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_STATION ) : cv . string , vol . Optional ( CONF_DIRECTION ) : cv . string , vol . Optional ( CONF_DESTINATION ) : cv . string , vol . Optional ( CONF_STOPS_AT ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from pyirishrail . pyirishrail import IrishRailRTPI [EOL] station = config . get ( CONF_STATION ) [EOL] direction = config . get ( CONF_DIRECTION ) [EOL] destination = config . get ( CONF_DESTINATION ) [EOL] stops_at = config . get ( CONF_STOPS_AT ) [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] irish_rail = IrishRailRTPI ( ) [EOL] data = IrishRailTransportData ( irish_rail , station , direction , destination , stops_at ) [EOL] add_devices ( [ IrishRailTransportSensor ( data , station , direction , destination , stops_at , name ) ] , True ) [EOL] [EOL] [EOL] class IrishRailTransportSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , station , direction , destination , stops_at , name ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _station = station [EOL] self . _direction = direction [EOL] self . _direction = direction [EOL] self . _stops_at = stops_at [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _times = [ ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _times : [EOL] next_up = [string] [EOL] if len ( self . _times ) > [number] : [EOL] next_up = self . _times [ [number] ] [ ATTR_ORIGIN ] + [string] [EOL] next_up += self . _times [ [number] ] [ ATTR_DESTINATION ] + [string] [EOL] next_up += self . _times [ [number] ] [ ATTR_DUE_IN ] [EOL] [EOL] return { ATTR_STATION : self . _station , ATTR_ORIGIN : self . _times [ [number] ] [ ATTR_ORIGIN ] , ATTR_DESTINATION : self . _times [ [number] ] [ ATTR_DESTINATION ] , ATTR_DUE_IN : self . _times [ [number] ] [ ATTR_DUE_IN ] , ATTR_DUE_AT : self . _times [ [number] ] [ ATTR_DUE_AT ] , ATTR_EXPECT_AT : self . _times [ [number] ] [ ATTR_EXPECT_AT ] , ATTR_DIRECTION : self . _times [ [number] ] [ ATTR_DIRECTION ] , ATTR_STOPS_AT : self . _times [ [number] ] [ ATTR_STOPS_AT ] , ATTR_NEXT_UP : next_up , ATTR_TRAIN_TYPE : self . _times [ [number] ] [ ATTR_TRAIN_TYPE ] } [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] self . _times = self . data . info [EOL] if self . _times : [EOL] self . _state = self . _times [ [number] ] [ ATTR_DUE_IN ] [EOL] else : [EOL] self . _state = None [EOL] [EOL] [EOL] class IrishRailTransportData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , irish_rail , station , direction , destination , stops_at ) : [EOL] [docstring] [EOL] self . _ir_api = irish_rail [EOL] self . station = station [EOL] self . direction = direction [EOL] self . destination = destination [EOL] self . stops_at = stops_at [EOL] self . info = self . _empty_train_data ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] trains = self . _ir_api . get_station_by_name ( self . station , direction = self . direction , destination = self . destination , stops_at = self . stops_at ) [EOL] stops_at = self . stops_at if self . stops_at else [string] [EOL] self . info = [ ] [EOL] for train in trains : [EOL] train_data = { ATTR_STATION : self . station , ATTR_ORIGIN : train . get ( [string] ) , ATTR_DESTINATION : train . get ( [string] ) , ATTR_DUE_IN : train . get ( [string] ) , ATTR_DUE_AT : train . get ( [string] ) , ATTR_EXPECT_AT : train . get ( [string] ) , ATTR_DIRECTION : train . get ( [string] ) , ATTR_STOPS_AT : stops_at , ATTR_TRAIN_TYPE : train . get ( [string] ) } [EOL] self . info . append ( train_data ) [EOL] [EOL] if not self . info or not self . info : [EOL] self . info = self . _empty_train_data ( ) [EOL] [EOL] def _empty_train_data ( self ) : [EOL] [docstring] [EOL] dest = self . destination if self . destination else [string] [EOL] direction = self . direction if self . direction else [string] [EOL] stops_at = self . stops_at if self . stops_at else [string] [EOL] return [ { ATTR_STATION : self . station , ATTR_ORIGIN : [string] , ATTR_DESTINATION : dest , ATTR_DUE_IN : [string] , ATTR_DUE_AT : [string] , ATTR_EXPECT_AT : [string] , ATTR_DIRECTION : direction , ATTR_STOPS_AT : stops_at , ATTR_TRAIN_TYPE : [string] } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0
import builtins [EOL] from typing import Dict , List , Any [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import aiohttp [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] from homeassistant . const import ( ATTR_TIME , ATTR_TEMPERATURE , CONF_TOKEN , CONF_USERNAME , TEMP_CELSIUS ) [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] from homeassistant . helpers . config_validation import PLATFORM_SCHEMA [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_HUMIDITY = [string] [EOL] ATTR_PM2_5 = [string] [EOL] ATTR_CARBON_DIOXIDE = [string] [EOL] ATTR_VOLATILE_ORGANIC_COMPOUNDS = [string] [EOL] ATTR_FOOBOT_INDEX = [string] [EOL] [EOL] SENSOR_TYPES = { [string] : [ ATTR_TIME , [string] ] , [string] : [ ATTR_PM2_5 , [string] , [string] ] , [string] : [ ATTR_TEMPERATURE , TEMP_CELSIUS , [string] ] , [string] : [ ATTR_HUMIDITY , [string] , [string] ] , [string] : [ ATTR_CARBON_DIOXIDE , [string] , [string] ] , [string] : [ ATTR_VOLATILE_ORGANIC_COMPOUNDS , [string] , [string] ] , [string] : [ ATTR_FOOBOT_INDEX , [string] , [string] ] } [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] PARALLEL_UPDATES = [number] [EOL] [EOL] TIMEOUT = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_TOKEN ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from foobot_async import FoobotClient [EOL] [EOL] token = config . get ( CONF_TOKEN ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] [EOL] client = FoobotClient ( token , username , async_get_clientsession ( hass ) , timeout = TIMEOUT ) [EOL] dev = [ ] [EOL] try : [EOL] devices = await client . get_devices ( ) [EOL] _LOGGER . debug ( [string] , devices ) [EOL] for device in devices : [EOL] foobot_data = FoobotData ( client , device [ [string] ] ) [EOL] for sensor_type in SENSOR_TYPES : [EOL] if sensor_type == [string] : [EOL] continue [EOL] foobot_sensor = FoobotSensor ( foobot_data , device , sensor_type ) [EOL] dev . append ( foobot_sensor ) [EOL] except ( aiohttp . client_exceptions . ClientConnectorError , asyncio . TimeoutError , FoobotClient . TooManyRequests , FoobotClient . InternalError ) : [EOL] _LOGGER . exception ( [string] ) [EOL] raise PlatformNotReady [EOL] except FoobotClient . ClientError : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] async_add_devices ( dev , True ) [EOL] [EOL] [EOL] class FoobotSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , device , sensor_type ) : [EOL] [docstring] [EOL] self . _uuid = device [ [string] ] [EOL] self . foobot_data = data [EOL] self . _name = [string] . format ( device [ [string] ] , SENSOR_TYPES [ sensor_type ] [ [number] ] ) [EOL] self . type = sensor_type [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES [ self . type ] [ [number] ] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] try : [EOL] data = self . foobot_data . data [ self . type ] [EOL] except ( KeyError , TypeError ) : [EOL] data = None [EOL] return data [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _uuid , self . type ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] await self . foobot_data . async_update ( ) [EOL] [EOL] [EOL] class FoobotData ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , uuid ) : [EOL] [docstring] [EOL] self . _client = client [EOL] self . _uuid = uuid [EOL] self . data = { } [EOL] [EOL] @ Throttle ( SCAN_INTERVAL ) async def async_update ( self ) : [EOL] [docstring] [EOL] interval = SCAN_INTERVAL . total_seconds ( ) [EOL] try : [EOL] response = await self . _client . get_last_data ( self . _uuid , interval , interval + [number] ) [EOL] except ( aiohttp . client_exceptions . ClientConnectorError , asyncio . TimeoutError , self . _client . TooManyRequests , self . _client . InternalError ) : [EOL] _LOGGER . debug ( [string] ) [EOL] return False [EOL] _LOGGER . debug ( [string] , response ) [EOL] self . data = { k : round ( v , [number] ) for k , v in response [ [number] ] . items ( ) } [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . hydrawise import ( DATA_HYDRAWISE , HydrawiseEntity , DEVICE_MAP , DEVICE_MAP_INDEX , SENSORS ) [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_MONITORED_CONDITIONS [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = SENSORS ) : vol . All ( cv . ensure_list , [ vol . In ( SENSORS ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] hydrawise = hass . data [ DATA_HYDRAWISE ] . data [EOL] [EOL] sensors = [ ] [EOL] for sensor_type in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] for zone in hydrawise . relays : [EOL] sensors . append ( HydrawiseSensor ( zone , sensor_type ) ) [EOL] [EOL] add_devices ( sensors , True ) [EOL] [EOL] [EOL] class HydrawiseSensor ( HydrawiseEntity ) : [EOL] [docstring] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] mydata = self . hass . data [ DATA_HYDRAWISE ] . data [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] if self . _sensor_type == [string] : [EOL] if not mydata . running : [EOL] self . _state = [number] [EOL] else : [EOL] if int ( mydata . running [ [number] ] [ [string] ] ) == self . data [ [string] ] : [EOL] self . _state = int ( mydata . running [ [number] ] [ [string] ] / [number] ) [EOL] else : [EOL] self . _state = [number] [EOL] else : [comment] [EOL] for relay in mydata . relays : [EOL] if relay [ [string] ] == self . data [ [string] ] : [EOL] if relay [ [string] ] == [string] : [EOL] self . _state = [string] [EOL] else : [EOL] self . _state = relay [ [string] ] . split ( [string] ) [ [number] ] + [string] + relay [ [string] ] . split ( [string] ) [ [number] ] [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return DEVICE_MAP [ self . _sensor_type ] [ DEVICE_MAP_INDEX . index ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from math import floor [EOL] [EOL] from homeassistant . components . volvooncall import ( VolvoEntity , RESOURCES , CONF_SCANDINAVIAN_MILES ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] add_devices ( [ VolvoSensor ( hass , * discovery_info ) ] ) [EOL] [EOL] [EOL] class VolvoSensor ( VolvoEntity ) : [EOL] [docstring] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] val = getattr ( self . vehicle , self . _attribute ) [EOL] [EOL] if val is None : [EOL] return val [EOL] [EOL] if self . _attribute == [string] : [EOL] val /= [number] [comment] [EOL] [EOL] if [string] in self . unit_of_measurement : [EOL] val /= [number] [comment] [EOL] [EOL] if self . _attribute == [string] : [EOL] val /= [number] [comment] [EOL] if [string] in self . unit_of_measurement : [EOL] return round ( val , [number] ) [EOL] return round ( val , [number] ) [EOL] if self . _attribute == [string] : [EOL] return int ( floor ( val ) ) [EOL] return int ( round ( val ) ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] unit = RESOURCES [ self . _attribute ] [ [number] ] [EOL] if self . _state . config [ CONF_SCANDINAVIAN_MILES ] and [string] in unit : [EOL] if self . _attribute == [string] : [EOL] return [string] [EOL] return unit . replace ( [string] , [string] ) [EOL] return unit [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return RESOURCES [ self . _attribute ] [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . knx import ATTR_DISCOVER_DEVICES , DATA_KNX [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] CONF_ADDRESS = [string] [EOL] CONF_TYPE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ADDRESS ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_TYPE ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] async_add_devices_discovery ( hass , discovery_info , async_add_devices ) [EOL] else : [EOL] async_add_devices_config ( hass , config , async_add_devices ) [EOL] [EOL] [EOL] @ callback def async_add_devices_discovery ( hass , discovery_info , async_add_devices ) : [EOL] [docstring] [EOL] entities = [ ] [EOL] for device_name in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] device = hass . data [ DATA_KNX ] . xknx . devices [ device_name ] [EOL] entities . append ( KNXSensor ( hass , device ) ) [EOL] async_add_devices ( entities ) [EOL] [EOL] [EOL] @ callback def async_add_devices_config ( hass , config , async_add_devices ) : [EOL] [docstring] [EOL] import xknx [EOL] sensor = xknx . devices . Sensor ( hass . data [ DATA_KNX ] . xknx , name = config . get ( CONF_NAME ) , group_address = config . get ( CONF_ADDRESS ) , value_type = config . get ( CONF_TYPE ) ) [EOL] hass . data [ DATA_KNX ] . xknx . devices . add ( sensor ) [EOL] async_add_devices ( [ KNXSensor ( hass , sensor ) ] ) [EOL] [EOL] [EOL] class KNXSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device ) : [EOL] [docstring] [EOL] self . device = device [EOL] self . hass = hass [EOL] self . async_register_callbacks ( ) [EOL] [EOL] @ callback def async_register_callbacks ( self ) : [EOL] [docstring] [EOL] async def after_update_callback ( device ) : [EOL] [docstring] [EOL] await self . async_update_ha_state ( ) [EOL] self . device . register_device_updated_cb ( after_update_callback ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . device . name [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . hass . data [ DATA_KNX ] . connected [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . device . resolve_state ( ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . device . unit_of_measurement ( ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import socket [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_LATITUDE , ATTR_LONGITUDE , STATE_UNKNOWN , CONF_HOST , CONF_PORT , CONF_NAME ) [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_CLIMB = [string] [EOL] ATTR_ELEVATION = [string] [EOL] ATTR_GPS_TIME = [string] [EOL] ATTR_MODE = [string] [EOL] ATTR_SPEED = [string] [EOL] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import socket [EOL] [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] try : [EOL] sock . connect ( ( host , port ) ) [EOL] sock . shutdown ( [number] ) [EOL] _LOGGER . debug ( [string] ) [EOL] except socket . error : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] add_devices ( [ GpsdSensor ( hass , name , host , port ) ] ) [EOL] [EOL] [EOL] class GpsdSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , host , port ) : [EOL] [docstring] [EOL] from gps3 . agps3threaded import AGPS3mechanism [EOL] [EOL] self . hass = hass [EOL] self . _name = name [EOL] self . _host = host [EOL] self . _port = port [EOL] [EOL] self . agps_thread = AGPS3mechanism ( ) [EOL] self . agps_thread . stream_data ( host = self . _host , port = self . _port ) [EOL] self . agps_thread . run_thread ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . agps_thread . data_stream . mode == [number] : [EOL] return [string] [EOL] if self . agps_thread . data_stream . mode == [number] : [EOL] return [string] [EOL] return STATE_UNKNOWN [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_LATITUDE : self . agps_thread . data_stream . lat , ATTR_LONGITUDE : self . agps_thread . data_stream . lon , ATTR_ELEVATION : self . agps_thread . data_stream . alt , ATTR_GPS_TIME : self . agps_thread . data_stream . time , ATTR_SPEED : self . agps_thread . data_stream . speed , ATTR_CLIMB : self . agps_thread . data_stream . climb , ATTR_MODE : self . agps_thread . data_stream . mode , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . scene import Scene , DOMAIN [EOL] from homeassistant . components . tuya import DATA_TUYA , TuyaDevice [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] tuya = hass . data [ DATA_TUYA ] [EOL] dev_ids = discovery_info . get ( [string] ) [EOL] devices = [ ] [EOL] for dev_id in dev_ids : [EOL] device = tuya . get_device_by_id ( dev_id ) [EOL] if device is None : [EOL] continue [EOL] devices . append ( TuyaScene ( device ) ) [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class TuyaScene ( TuyaDevice , Scene ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tuya ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( tuya ) [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( tuya . object_id ( ) ) [EOL] [EOL] def activate ( self ) : [EOL] [docstring] [EOL] self . tuya . activate ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] from homeassistant . const import ( STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_ALARM_TRIGGERED ) [EOL] from homeassistant . components . alarm_control_panel import AlarmControlPanel [EOL] from homeassistant . components . homematicip_cloud import ( HomematicipGenericDevice , DOMAIN as HMIPC_DOMAIN , HMIPC_HAPID ) [EOL] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] HMIP_ZONE_AWAY = [string] [EOL] HMIP_ZONE_HOME = [string] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_devices ) : [EOL] [docstring] [EOL] from homematicip . aio . group import AsyncSecurityZoneGroup [EOL] [EOL] home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home [EOL] devices = [ ] [EOL] for group in home . groups : [EOL] if isinstance ( group , AsyncSecurityZoneGroup ) : [EOL] devices . append ( HomematicipSecurityZone ( home , group ) ) [EOL] [EOL] if devices : [EOL] async_add_devices ( devices ) [EOL] [EOL] [EOL] class HomematicipSecurityZone ( HomematicipGenericDevice , AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] device . modelType = [string] [EOL] device . windowState = [string] [EOL] super ( ) . __init__ ( home , device ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] from homematicip . base . enums import WindowState [EOL] [EOL] if self . _device . active : [EOL] if ( self . _device . sabotage or self . _device . motionDetected or self . _device . windowState == WindowState . OPEN ) : [EOL] return STATE_ALARM_TRIGGERED [EOL] [EOL] active = self . _home . get_security_zones_activation ( ) [EOL] if active == ( True , True ) : [EOL] return STATE_ALARM_ARMED_AWAY [EOL] if active == ( False , True ) : [EOL] return STATE_ALARM_ARMED_HOME [EOL] [EOL] return STATE_ALARM_DISARMED [EOL] [EOL] async def async_alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] await self . _home . set_security_zones_activation ( False , False ) [EOL] [EOL] async def async_alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] await self . _home . set_security_zones_activation ( True , False ) [EOL] [EOL] async def async_alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] await self . _home . set_security_zones_activation ( True , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . cover import ( CoverDevice , PLATFORM_SCHEMA , SUPPORT_OPEN , SUPPORT_CLOSE ) [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD , STATE_CLOSED , STATE_OPENING , STATE_CLOSING , STATE_OPEN ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] STATES_MAP = { [string] : STATE_OPEN , [string] : STATE_OPENING , [string] : STATE_CLOSED , [string] : STATE_CLOSING } [EOL] [EOL] SUPPORTED_FEATURES = SUPPORT_OPEN | SUPPORT_CLOSE [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from aladdin_connect import AladdinConnectClient [EOL] [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] acc = AladdinConnectClient ( username , password ) [EOL] [EOL] try : [EOL] if not acc . login ( ) : [EOL] raise ValueError ( [string] ) [EOL] add_devices ( AladdinDevice ( acc , door ) for door in acc . get_doors ( ) ) [EOL] except ( TypeError , KeyError , NameError , ValueError ) as ex : [EOL] _LOGGER . error ( [string] , ex ) [EOL] hass . components . persistent_notification . create ( [string] [string] [string] . format ( ex ) , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] [EOL] [EOL] class AladdinDevice ( CoverDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , acc , device ) : [EOL] [docstring] [EOL] self . _acc = acc [EOL] self . _device_id = device [ [string] ] [EOL] self . _number = device [ [string] ] [EOL] self . _name = device [ [string] ] [EOL] self . _status = STATES_MAP . get ( device [ [string] ] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORTED_FEATURES [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_opening ( self ) : [EOL] [docstring] [EOL] return self . _status == STATE_OPENING [EOL] [EOL] @ property def is_closing ( self ) : [EOL] [docstring] [EOL] return self . _status == STATE_CLOSING [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] if self . _status is None : [EOL] return None [EOL] return self . _status == STATE_CLOSED [EOL] [EOL] def close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _acc . close_door ( self . _device_id , self . _number ) [EOL] [EOL] def open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _acc . open_door ( self . _device_id , self . _number ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] acc_status = self . _acc . get_door_status ( self . _device_id , self . _number ) [EOL] self . _status = STATES_MAP . get ( acc_status ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . cover import ( CoverDevice , ENTITY_ID_FORMAT , SUPPORT_OPEN , SUPPORT_CLOSE , SUPPORT_STOP ) [EOL] from homeassistant . components . tuya import DATA_TUYA , TuyaDevice [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] tuya = hass . data [ DATA_TUYA ] [EOL] dev_ids = discovery_info . get ( [string] ) [EOL] devices = [ ] [EOL] for dev_id in dev_ids : [EOL] device = tuya . get_device_by_id ( dev_id ) [EOL] if device is None : [EOL] continue [EOL] devices . append ( TuyaCover ( device ) ) [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class TuyaCover ( TuyaDevice , CoverDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tuya ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( tuya ) [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( tuya . object_id ( ) ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] supported_features = SUPPORT_OPEN | SUPPORT_CLOSE [EOL] if self . tuya . support_stop ( ) : [EOL] supported_features |= SUPPORT_STOP [EOL] return supported_features [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . tuya . open_cover ( ) [EOL] [EOL] def close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . tuya . close_cover ( ) [EOL] [EOL] def stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . tuya . stop_cover ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0