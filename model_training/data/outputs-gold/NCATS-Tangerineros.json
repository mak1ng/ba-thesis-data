from typing import Dict , Any [EOL] import requests [EOL] import caus [EOL] import typing [EOL] import argparse [EOL] import requests [EOL] import json [EOL] import argparse [EOL] requests . packages . urllib3 . disable_warnings ( ) [EOL] [EOL] tabular_headers = { [string] : [string] , [string] : [string] } [EOL] json_headers = { [string] : [string] , [string] : [string] } [EOL] [EOL] class DefineCohort ( ) : [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def make_cohort_definition ( self , feature , value , operator ) : [EOL] feature_variables = [string] . format ( feature , value , operator ) [EOL] return feature_variables [EOL] [EOL] def define_cohort_query ( self , feature_variables , year = [number] , table = [string] , version = [string] ) : [comment] [EOL] define_cohort_response = requests . post ( [string] . format ( version , table , year ) , data = feature_variables , headers = json_headers , verify = False ) [EOL] return define_cohort_response [EOL] [EOL] def run_define_cohort ( self , feature , value , operator ) : [EOL] feature_variables = self . make_cohort_definition ( feature , value , operator ) [EOL] define_cohort_query = self . define_cohort_query ( feature_variables ) [EOL] define_cohort_query_json = define_cohort_query . json ( ) [EOL] return define_cohort_query_json [EOL] [EOL] class GetCohortDefinition ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def get_cohort_definition_query ( self , cohort_id , year = [number] , table = [string] , version = [string] ) : [EOL] cohort_definition_response = requests . get ( [string] . format ( version , table , year , cohort_id ) , headers = json_headers , verify = False ) [EOL] return cohort_definition_response [EOL] [EOL] def run_get_cohort_definition ( self , cohort_id ) : [EOL] cohort_definition_query = self . get_cohort_definition_query ( cohort_id ) [EOL] cohort_definition_query_json = cohort_definition_query . json ( ) [EOL] return cohort_definition_query_json [EOL] [EOL] class GetFeatures ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] class FeatureAssociation ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] [EOL] [EOL] [EOL] class AssociationToAllFeatures ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def make_association_to_all_features ( self , feature , value , operator , maximum_p_value ) : [EOL] feature_variable_and_p_value = [string] . format ( feature , value , operator , maximum_p_value ) [EOL] [comment] [EOL] return feature_variable_and_p_value [EOL] [EOL] def assocation_to_all_features_query ( self , feature_variable_and_p_value , cohort_id , year = [number] , table = [string] , version = [string] ) : [EOL] assoc_to_all_features_response = requests . post ( [string] . format ( version , table , year , cohort_id ) , data = feature_variable_and_p_value , headers = json_headers , verify = False ) [EOL] return assoc_to_all_features_response [EOL] [EOL] def run_make_association_to_all_features ( self , feature , value , operator , maximum_p_value , cohort_id ) : [EOL] feature_variable_and_p_value = self . make_association_to_all_features ( feature , value , operator , maximum_p_value ) [EOL] assoc_to_all_features_query = self . assocation_to_all_features_query ( feature_variable_and_p_value , cohort_id ) [EOL] assoc_to_all_features_query_json = assoc_to_all_features_query . json ( ) [EOL] return assoc_to_all_features_query_json [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] class GetDictionary ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] if __name__ == [string] : [EOL] import sys [EOL] if len ( sys . argv ) > [number] : [EOL] icees_define_cohort = DefineCohort ( ) [EOL] output = icees_define_cohort . run_define_cohort ( args . feature , args . value , args . operator ) [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( output [ [string] ] ) [EOL] print ( ) [EOL] else : [EOL] print ( [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $caus.iceeshelper.DefineCohort$ 0 0 0 0 0 $typing.Any$ 0 $caus.iceeshelper.DefineCohort$ 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import ros [EOL] import logging [EOL] import typing [EOL] import copy [EOL] import json [EOL] import logging [EOL] from ros . util import Concept [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] class Statement : [EOL] [docstring] [EOL] def execute ( self , interpreter ) : [EOL] pass [EOL] [EOL] class SetStatement ( Statement ) : [EOL] [docstring] [EOL] def __init__ ( self , variable , value , jsonpath_query = None ) : [EOL] self . variable = variable [EOL] self . value = value [EOL] self . jsonpath_query = jsonpath_query [EOL] def execute ( self , interpreter ) : [EOL] interpreter . context . set ( self . variable , self . value ) [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . variable } [string] { self . value }" [EOL] [EOL] class SelectStatement : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . concept_order = [ ] [EOL] self . concepts = { } [EOL] self . service = None [EOL] self . where = [ ] [EOL] self . set_statements = [ ] [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . concepts } [string] { self . service } [string] { self . where } [string] { self . set_statements }" [EOL] [EOL] def question ( self , nodes , edges ) : [EOL] [docstring] [EOL] return { [string] : { [string] : edges , [string] : nodes } } [EOL] def edge ( self , source , target , type_name = None ) : [EOL] [docstring] [EOL] e = { [string] : source , [string] : target } [EOL] if type_name : [EOL] e [ [string] ] = type_name [EOL] return e [EOL] def node ( self , identifier , type_name , value = None ) : [EOL] [docstring] [EOL] logger . debug ( f" [string] { value }" ) [EOL] n = { [string] : identifier , [string] : type_name } [EOL] if value : [EOL] n [ [string] ] = value [EOL] return n [EOL] [EOL] def val ( self , value , field = [string] ) : [EOL] [docstring] [EOL] result = value [EOL] if isinstance ( value , dict ) and field in value : [EOL] result = value [ field ] [EOL] return result [EOL] [EOL] def execute ( self , interpreter ) : [EOL] [docstring] [EOL] questions = self . generate_questions ( ) [EOL] for q in questions : [EOL] print ( f" [string] { q }" ) [EOL] [EOL] def generate_questions ( self ) : [EOL] [docstring] [EOL] for index , type_name in enumerate ( self . concept_order ) : [EOL] for value in self . concepts [ type_name ] . nodes : [EOL] if isinstance ( value , list ) : [EOL] [docstring] [EOL] self . concepts [ name ] . nodes = [ self . node ( identifier = index , type_name = type_name , value = self . val ( v ) ) for v in value ] [EOL] elif isinstance ( value , str ) : [EOL] self . concepts [ type_name ] . nodes = [ self . node ( identifier = index , type_name = type_name , value = self . val ( value ) ) ] [EOL] else : [EOL] self . concepts [ type_name ] . nodes = [ self . node ( identifier = index , type_name = type_name ) ] [EOL] [EOL] edges = [ ] [EOL] questions = [ ] [EOL] for index , type_name in enumerate ( self . concept_order ) : [EOL] concept = self . concepts [ type_name ] [EOL] logger . debug ( f" [string] { concept }" ) [EOL] previous = self . concept_order [ index - [number] ] if index > [number] else None [EOL] if index == [number] : [EOL] for node in concept . nodes : [EOL] [docstring] [EOL] questions . append ( self . question ( nodes = [ node ] , edges = [ ] ) ) [EOL] else : [EOL] new_questions = [ ] [EOL] for question in questions : [EOL] logger . debug ( f" [string] { question }" ) [EOL] for node in concept . nodes : [EOL] [docstring] [EOL] nodes = copy . deepcopy ( question [ [string] ] [ [string] ] ) [EOL] lastnode = nodes [ - [number] ] [EOL] nodes . append ( node ) [EOL] edges = copy . deepcopy ( question [ [string] ] [ [string] ] ) [EOL] edges . append ( self . edge ( source = lastnode [ [string] ] , target = node [ [string] ] ) ) [EOL] new_questions . append ( self . question ( nodes = nodes , edges = edges ) ) [EOL] questions = new_questions [EOL] return questions [EOL] [EOL] class TranQL_AST : [EOL] [docstring] [EOL] def __init__ ( self , parse_tree ) : [EOL] [docstring] [EOL] self . statements = [ ] [EOL] self . parse_tree = parse_tree [EOL] for index , element in enumerate ( self . parse_tree ) : [EOL] if isinstance ( element , list ) : [EOL] statement = self . remove_whitespace ( element , also = [ [string] ] ) [EOL] if element [ [number] ] == [string] : [EOL] if len ( element ) == [number] : [EOL] self . statements . append ( SetStatement ( variable = element [ [number] ] , value = element [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] elif isinstance ( element [ [number] ] , list ) : [EOL] statement = self . remove_whitespace ( element [ [number] ] , also = [ [string] ] ) [EOL] if statement [ [number] ] == [string] : [EOL] self . parse_select ( element ) [EOL] [EOL] def remove_whitespace ( self , group , also = [ ] ) : [EOL] [docstring] [EOL] return [ x for x in group if not str ( x ) . isspace ( ) and not x in also ] [EOL] [EOL] def parse_select ( self , statement ) : [EOL] [docstring] [EOL] select = SelectStatement ( ) [EOL] for e in statement : [EOL] if self . is_command ( e ) : [EOL] e = self . remove_whitespace ( e , also = [ [string] ] ) [EOL] command = e [ [number] ] [EOL] if command == [string] : [EOL] for token in e [ [number] : ] : [EOL] select . concept_order . append ( token ) [EOL] select . concepts [ token ] = Concept ( token ) [EOL] if command == [string] : [EOL] select . service = e [ [number] ] [ [number] ] [EOL] elif command == [string] : [EOL] for condition in e [ [number] : ] : [EOL] if isinstance ( condition , list ) and len ( condition ) == [number] : [EOL] var , op , val = condition [EOL] if var in select . concepts and op == [string] : [EOL] select . concepts [ var ] . nodes . append ( val ) [EOL] else : [EOL] select . where . append ( [ var , op , val ] ) [EOL] elif command == [string] : [EOL] if len ( e [ [number] ] ) == [number] or len ( e [ [number] ] ) == [number] : [EOL] select . set_statements . append ( e [ [number] ] ) [EOL] self . statements . append ( select ) [EOL] [EOL] def is_command ( self , e ) : [EOL] [docstring] [EOL] return isinstance ( e , list ) and len ( e ) > [number] [EOL] [EOL] def __repr__ ( self ) : [EOL] return json . dumps ( self . parse_tree , indent = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.tranqlast.SelectStatement$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $ros.tranqlast.SelectStatement$ 0 0 0 0 0 0 0 0 $ros.tranqlast.SelectStatement$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $ros.tranqlast.SelectStatement$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.tranqlast.SelectStatement$ 0 0 0 0 0 0 0 0 $ros.tranqlast.SelectStatement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.tranqlast.SelectStatement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $ros.tranqlast.SelectStatement$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $ros.tranqlast.SelectStatement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Optional [EOL] import ros [EOL] import logging [EOL] import _csv [EOL] import typing [EOL] import csv [EOL] import logging [EOL] import json [EOL] import traceback [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] class CSVArgs : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , csv_file , delimiter = [string] ) : [EOL] [docstring] [EOL] self . vals = [ ] [EOL] with open ( csv_file , [string] , encoding = [string] ) as stream : [EOL] print ( f" [string] { delimiter } [string] " ) [EOL] reader = csv . reader ( stream , delimiter = delimiter ) [EOL] headers = next ( reader , None ) [EOL] [EOL] for row in reader : [EOL] values = { a : row [ i ] for i , a in enumerate ( headers ) } [EOL] try : [EOL] if len ( headers ) == len ( values ) : [EOL] self . vals . append ( values ) [EOL] else : [EOL] print ( f" [string] { len ( values ) } [string] { len ( headers ) } [string] " ) [EOL] except : [EOL] traceback . print_exc ( ) [EOL] [EOL] if __name__ == [string] : [EOL] c = CSVArgs ( [string] ) [EOL] print ( json . dumps ( c . vals , indent = [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 0 $_csv._reader$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $_csv._reader$ 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 $typing.Dict[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 $typing.Dict[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.str]$ 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.csvargs.CSVArgs$ 0 0 0 0 0 0 0 0 0 0 0 0 $ros.csvargs.CSVArgs$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import ros [EOL] import logging [EOL] import typing [EOL] from __future__ import absolute_import [EOL] import json [EOL] import logging [EOL] import time [EOL] [comment] [EOL] from ros . workflow import Workflow [EOL] from ros . router import Router [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] def json2workflow ( json ) : [EOL] model = Workflow ( spec = { [string] : [string] } ) [EOL] model . uuid = json [ [string] ] [EOL] model . spec = json [ [string] ] [EOL] model . inputs = json [ [string] ] [EOL] model . dependencies = json [ [string] ] [EOL] model . topsort = json [ [string] ] [EOL] model . running = json [ [string] ] [EOL] model . failed = json [ [string] ] [EOL] model . done = json [ [string] ] [EOL] return model [EOL] [EOL] def exec_operator ( model , job_name ) : [EOL] result = None [EOL] wf = json2workflow ( model ) [EOL] op_node = wf . spec . get ( [string] , { } ) . get ( job_name , { } ) [EOL] if op_node : [EOL] router = Router ( wf ) [EOL] result = router . route ( wf , job_name , op_node , op_node [ [string] ] , op_node [ [string] ] ) [EOL] wf . set_result ( job_name , result ) [EOL] return result [EOL] [EOL] async def exec_async ( workflow , job_name ) : [EOL] result = None [EOL] logger . debug ( f" [string] { job_name }" ) [EOL] op_node = workflow . get_step ( job_name ) [EOL] if op_node : [EOL] router = Router ( workflow ) [EOL] result = await router . route ( workflow , job_name , op_node , op_node [ [string] ] , op_node [ [string] ] ) [EOL] logger . debug ( f" [string] { job_name }" ) [EOL] workflow . set_result ( job_name , result ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import ros [EOL] import logging [EOL] import typing [EOL] import json [EOL] import os [EOL] import requests [EOL] import logging [EOL] import logging . config [EOL] import networkx as nx [EOL] from node2vec import Node2Vec [EOL] from jsonpath_rw import jsonpath , parse [EOL] from ros . router import Router [EOL] from ros . workflow import Workflow [EOL] from ros . csvargs import CSVArgs [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] class WorkflowResult : [EOL] [docstring] [EOL] def __init__ ( self , workflow , result ) : [EOL] self . workflow = workflow [EOL] self . result = result [EOL] def to_nx ( self ) : [EOL] [docstring] [EOL] return self . workflow . tools . answer_set_to_nx ( self . result ) [EOL] [EOL] class Client : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , url ) : [EOL] [docstring] [EOL] self . url = url [EOL] [EOL] def run ( self , workflow , args = { } , library_path = [ [string] ] ) : [EOL] [docstring] [EOL] logger . debug ( f" [string] { workflow } [string] { library_path } [string] { args } [string] { self . url }" ) [EOL] [EOL] [docstring] [EOL] workflow = Workflow ( spec = workflow , inputs = args , libpath = library_path , local_db_connection = False ) [EOL] [EOL] [docstring] [EOL] return WorkflowResult ( workflow = workflow , result = requests . post ( url = f"{ self . url } [string] " , json = { [string] : workflow . spec , [string] : args } ) . json ( ) ) [EOL] [EOL] def main ( ) : [EOL] [EOL] workflow = [string] [EOL] args = { [string] : [string] , } [EOL] libpath = [ [string] ] [EOL] [EOL] [docstring] [EOL] ros = Client ( url = [string] ) [EOL] response = ros . run ( workflow = workflow , args = args , library_path = libpath ) [EOL] [EOL] print ( json . dumps ( response . result , indent = [number] ) ) [EOL] [EOL] graph = response . to_nx ( ) [EOL] for n in graph . nodes ( data = True ) : [EOL] print ( n ) [EOL] [EOL] [EOL] [EOL] n2v = Node2Vec ( graph , dimensions = [number] , walk_length = [number] , num_walks = [number] , p = [number] , q = [number] , weight_key = [string] , workers = [number] , sampling_strategy = None , quiet = False ) [EOL] model = n2v . fit ( ) [EOL] [EOL] def main2 ( ) : [EOL] [EOL] args_list = CSVArgs ( [string] ) [EOL] workflow = [string] [EOL] libpath = [ [string] ] [EOL] [EOL] [docstring] [EOL] g = nx . MultiDiGraph ( ) [EOL] for args in args_list . vals : [EOL] ros = Client ( url = [string] ) [EOL] response = ros . run ( workflow = workflow , args = args , library_path = libpath ) [EOL] [EOL] print ( json . dumps ( response . result , indent = [number] ) ) [EOL] response_nx = response . to_nx ( ) [EOL] print ( f" [string] { len ( response_nx . nodes ( ) ) } [string] { len ( response_nx . edges ( ) ) } [string] " ) [EOL] g = nx . compose ( g , response . to_nx ( ) ) [EOL] [EOL] [docstring] [EOL] n2v = Node2Vec ( g , dimensions = [number] , walk_length = [number] , num_walks = [number] , p = [number] , q = [number] , weight_key = [string] , workers = [number] , sampling_strategy = None , quiet = False ) [EOL] model = n2v . fit ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main2 ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.workflow.Workflow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $ros.workflow.Workflow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.workflow.Workflow$ 0 0 0 0 0 $ros.workflow.Workflow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.workflow.Workflow$ 0 $ros.workflow.Workflow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.workflow.Workflow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Tuple [EOL] import ros [EOL] import logging [EOL] import typing [EOL] import json [EOL] import logging [EOL] import redis [EOL] [comment] [EOL] from neo4j . v1 import GraphDatabase [EOL] from neo4j . v1 . types . graph import Node [EOL] from neo4j . v1 . types . graph import Relationship [EOL] from ros . config import Config [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] class KnowledgeGraph : [EOL] [docstring] [EOL] def __init__ ( self , graph , graph_name , host = [string] , port = [number] ) : [EOL] [docstring] [EOL] self . redis = redis . Redis ( host = host , port = port ) [EOL] self . graph = Graph ( graph_name , self . redis ) [EOL] def add_node ( self , label , props ) : [EOL] [docstring] [EOL] n = Node ( label = label , properties = props ) [EOL] self . graph . add_node ( n ) [EOL] return n [EOL] def add_edge ( self , subj , pred , obj , props ) : [EOL] [docstring] [EOL] e = Edge ( subj , pred , obj , properties = props ) [EOL] self . graph . add_edge ( e ) [EOL] return e [EOL] def commit ( self ) : [EOL] [docstring] [EOL] self . graph . commit ( ) [EOL] def query ( self , query ) : [EOL] [docstring] [EOL] return self . graph . query ( query ) [EOL] def delete ( self ) : [EOL] [docstring] [EOL] logger . debug ( [string] ) [EOL] self . graph . delete ( ) [EOL] [EOL] class Neo4JKnowledgeGraph : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host = [string] , port = [number] ) : [EOL] [EOL] [docstring] [EOL] self . config = Config ( ) [EOL] [EOL] [docstring] [EOL] host = self . config [ [string] ] [ [string] ] [EOL] username = self . config [ [string] ] [ [string] ] [EOL] password = self . config [ [string] ] [ [string] ] [EOL] uri = f" [string] { host } [string] { port }" [EOL] logger . debug ( f" [string] { uri }" ) [EOL] auth = None [EOL] if isinstance ( username , str ) and isinstance ( password , str ) : [EOL] auth = ( username , password ) [EOL] self . _driver = GraphDatabase . driver ( uri , auth = auth ) [EOL] else : [EOL] self . _driver = GraphDatabase . driver ( uri ) [EOL] self . session = self . _driver . session ( ) [EOL] [EOL] def add_node ( self , label , props ) : [EOL] [docstring] [EOL] return self . create_node ( props , node_type = label ) [EOL] [EOL] def add_edge ( self , subj , pred , obj , props ) : [EOL] [docstring] [EOL] props [ [string] ] = pred [EOL] logger . debug ( f" [string] { subj } [string] { props } [string] { obj } [string] " ) [EOL] return self . create_relationship ( subj , props , obj ) [EOL] [EOL] def commit ( self ) : [EOL] [docstring] [EOL] pass [comment] [EOL] [EOL] def query ( self , query ) : [EOL] [docstring] [EOL] result = self . graph . query ( query ) [EOL] return [ node . properties for node in result ] [EOL] [EOL] def delete ( self ) : [EOL] [docstring] [EOL] self . exec ( [string] ) [EOL] [EOL] def __del__ ( self ) : [EOL] [docstring] [EOL] if self . _driver : [EOL] logger . debug ( [string] ) [EOL] self . _driver . close ( ) [EOL] [EOL] def exec ( self , command ) : [EOL] [docstring] [EOL] return self . session . run ( command ) [EOL] [EOL] def node2json ( self , rec ) : [EOL] return { [string] : rec . get ( [string] , None ) , [string] : rec . get ( [string] , None ) , [string] : rec . get ( [string] , None ) , [string] : rec . get ( [string] , None ) } [EOL] [EOL] def edge2json ( self , rec ) : [EOL] return { [string] : rec . get ( [string] , None ) } [EOL] [EOL] def query ( self , query , nodes = [ ] , edges = [ ] ) : [EOL] [docstring] [EOL] response = [ ] [EOL] result = self . exec ( query ) [EOL] for row in result : [EOL] for k , v in row . items ( ) : [EOL] if isinstance ( v , Node ) : [EOL] response . append ( self . node2json ( v ) ) [EOL] elif isinstance ( v , Relationship ) : [EOL] response . append ( self . edge2json ( v ) ) [EOL] elif isinstance ( v , str ) : [EOL] response . append ( v ) [EOL] logger . debug ( f" [string] { response }" ) [EOL] return response [EOL] [EOL] def get_node ( self , properties , node_type = None ) : [EOL] [docstring] [EOL] ntype = f" [string] { node_type }" if node_type else [string] [EOL] properties = [string] . join ( [ f""" [string] { k } [string] { v } [string] """ for k , v in properties . items ( ) ] ) [EOL] return self . exec ( f""" [string] { ntype } [string] { properties } [string] """ ) [EOL] [EOL] def create_node ( self , properties , node_type = None ) : [EOL] [docstring] [EOL] id = properties [ [string] ] [EOL] ntype = f" [string] { node_type }" if node_type else [string] [EOL] props = [string] . join ( [ f""" [string] { k } [string] { v } [string] """ for k , v in properties . items ( ) if not k == [string] ] ) [EOL] statement = f""" [string] { ntype } [string] { id } [string] { props }""" [EOL] logger . debug ( f" [string] { statement }" ) [EOL] self . exec ( statement ) [EOL] return properties [EOL] [EOL] def create_relationship ( self , id_a , properties , id_b ) : [EOL] [docstring] [EOL] relname = properties [ [string] ] . replace ( [string] , [string] ) [EOL] rprops = [string] . join ( [ f""" [string] { k } [string] { v } [string] """ for k , v in properties . items ( ) if not k == [string] ] ) [EOL] result = self . exec ( f""" [string] { id_a } [string] { relname } [string] { rprops } [string] { id_b } [string] """ ) [EOL] if not result . peek ( ) : [EOL] statement = f""" [string] { id_a } [string] { id_b } [string] { relname } [string] { rprops } [string] """ [EOL] result = self . exec ( statement ) [EOL] return result [EOL] [EOL] def update ( self , nodes = [ ] , edges = [ ] ) : [EOL] [docstring] [EOL] for n in nodes : [EOL] props = [string] . join ( [ f""" [string] { k } [string] { v } [string] """ for k , v in n . items ( ) if not k == [string] ] ) [EOL] statement = f""" [string] { n [ [string] ] } [string] { props } [string] """ [EOL] self . exec ( statement ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.config.Config$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $ros.config.Config$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $ros.config.Config$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $ros.config.Config$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from greent . flow . graph import TranslatorGraphTools [EOL] import json [EOL] gt = TranslatorGraphTools ( ) [EOL] g = gt . file_to_d3_json ( [string] ) [EOL] with open ( [string] , [string] ) as s : [EOL] json . dump ( g , s , indent = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
import argparse [EOL] import importlib [EOL] import json [EOL] import logging [EOL] import requests [EOL] import os [EOL] import re [EOL] import sys [EOL] import yaml [EOL] import time [EOL] import traceback [EOL] from jsonpath_rw import jsonpath , parse [EOL] import networkx as nx [EOL] import uuid [EOL] from networkx . algorithms import lexicographical_topological_sort [EOL] from ros . router import Router [EOL] from ros . util import Resource [EOL] from ros . config import Config [EOL] from ros . graph import TranslatorGraphTools [EOL] from ros . kgraph import Neo4JKnowledgeGraph [EOL] from ros . util import JSONKit [EOL] from ros . cache import Cache [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] class Execution : [EOL] def __init__ ( self ) : [EOL] self . done = { } [EOL] self . running = { } [EOL] self . failed = { } [EOL] [EOL] class Workflow : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , spec , inputs = { } , config = None , libpath = [ [string] ] , local_db_connection = True , enable_cache = True ) : [EOL] [EOL] [docstring] [EOL] [EOL] assert spec , [string] [EOL] [EOL] [docstring] [EOL] self . libpath = libpath [EOL] if isinstance ( spec , str ) : [EOL] if os . path . exists ( spec ) : [EOL] logger . info ( f" [string] { spec }" ) [EOL] with open ( spec , [string] ) as stream : [EOL] spec = yaml . load ( stream . read ( ) ) [EOL] else : [EOL] raise ValueError ( f" [string] { spec }" ) [EOL] [EOL] [docstring] [EOL] self . enable_cache = enable_cache [EOL] self . inputs = inputs [EOL] self . spec = spec [EOL] self . uuid = uuid . uuid4 ( ) [EOL] self . config = Config ( config ) [EOL] self . tools = TranslatorGraphTools ( ) [EOL] if local_db_connection : [EOL] if self . enable_cache : [EOL] self . cache = Cache ( redis_host = self . config [ [string] ] , redis_port = self . config [ [string] ] ) [EOL] else : [EOL] self . mem_cache = { } [EOL] db_host = self . config . get ( [string] , [string] ) [EOL] self . graph = Neo4JKnowledgeGraph ( host = db_host ) [EOL] self . errors = [ ] [EOL] self . json = JSONKit ( ) [EOL] [EOL] [docstring] [EOL] self . execution = Execution ( ) [EOL] [EOL] [docstring] [EOL] self . plugins = [ ] [EOL] plugin_config = self . config [ [string] ] [EOL] for plugin_def in plugin_config : [EOL] name = plugin_def [ [string] ] [EOL] driver = self . instantiate ( plugin_def [ [string] ] ) [EOL] self . plugins . append ( driver ) [EOL] workflows = driver . workflows ( ) [EOL] logger . debug ( f" [string] { name } [string] { driver }" ) [EOL] logger . debug ( f" [string] { workflows }" ) [EOL] [EOL] [docstring] [EOL] self . resolve_imports ( ) [EOL] [EOL] [docstring] [EOL] self . resolve_templates ( ) [EOL] [EOL] [docstring] [EOL] self . validate ( ) [EOL] [EOL] [docstring] [EOL] self . create_dag ( ) [EOL] [EOL] [docstring] [EOL] self . enforce_specification ( ) [EOL] [EOL] def instantiate ( self , class_name ) : [EOL] [docstring] [EOL] module_name = [string] . join ( class_name . split ( [string] ) [ : - [number] ] ) [EOL] class_name = class_name . split ( [string] ) [ - [number] ] [EOL] module = importlib . import_module ( module_name ) [EOL] the_class = getattr ( module , class_name ) [EOL] return the_class ( ) [EOL] [EOL] def enforce_specification ( self ) : [EOL] [docstring] [EOL] [EOL] [docstring] [EOL] assert self . spec . get ( [string] ) == [number] [EOL] [EOL] [docstring] [EOL] workflow = self . spec . get ( [string] , { } ) [EOL] assert len ( workflow ) > [number] , [string] [EOL] [EOL] [docstring] [EOL] info = self . spec . get ( [string] , { } ) [EOL] assert info , [string] [EOL] version = info . get ( [string] ) [EOL] assert version , [string] [EOL] assert re . match ( [string] , version ) , [string] [EOL] [EOL] title = info . get ( [string] ) [EOL] assert isinstance ( title , str ) , [string] [EOL] [EOL] description = info . get ( [string] ) [EOL] assert isinstance ( description , str ) , [string] [EOL] [EOL] def create_dag ( self ) : [EOL] [docstring] [EOL] logger . debug ( [string] ) [EOL] self . dag = nx . DiGraph ( ) [EOL] operators = self . spec . get ( [string] , { } ) [EOL] self . dependencies = { } [EOL] jobs = { } [EOL] job_index = [number] [EOL] for operator in operators : [EOL] job_index = job_index + [number] [EOL] op_node = operators [ operator ] [EOL] op_code = op_node [ [string] ] [EOL] args = op_node [ [string] ] [EOL] self . dag . add_node ( operator , attr_dict = { [string] : op_node } ) [EOL] dependencies = self . get_dependent_job_names ( op_node ) [EOL] for d in dependencies : [EOL] self . dag . add_edge ( operator , d , attr_dict = { } ) [EOL] for job_name , op_node in self . spec . get ( [string] , { } ) . items ( ) : [EOL] self . dependencies [ job_name ] = self . generate_dependent_jobs ( self . spec , job_name , self . dag ) [EOL] self . topsort = [ t for t in reversed ( [ t for t in lexicographical_topological_sort ( self . dag ) ] ) ] [EOL] [EOL] def resolve_imports ( self ) : [EOL] [docstring] [EOL] if [string] in self . spec : [EOL] imports = self . spec . get ( [string] , [ ] ) [EOL] logger . debug ( [string] ) [EOL] for i in imports : [EOL] imported = False [EOL] for path in self . libpath : [EOL] file_name = os . path . join ( path , f"{ i } [string] " ) [EOL] if os . path . exists ( file_name ) : [EOL] with open ( file_name , [string] ) as stream : [EOL] obj = yaml . load ( stream . read ( ) ) [EOL] logger . debug ( f" [string] { i } [string] { file_name }" ) [EOL] Resource . deepupdate ( self . spec , obj , skip = [ [string] ] ) [EOL] imported = True [EOL] if not imported : [EOL] raise ValueError ( f" [string] { i }" ) [EOL] del self . spec [ [string] ] [EOL] [EOL] def resolve_templates ( self ) : [EOL] [docstring] [EOL] templates = self . spec . get ( [string] , { } ) [EOL] workflow = self . spec . get ( [string] , { } ) [EOL] for name , job in workflow . items ( ) : [EOL] extends = job . get ( [string] , None ) [EOL] if extends in templates : [EOL] Resource . deepupdate ( workflow [ name ] , templates [ extends ] , skip = [ [string] ] ) [EOL] [EOL] def validate ( self ) : [EOL] [docstring] [EOL] logger . debug ( [string] ) [EOL] types_config = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] with open ( types_config , [string] ) as stream : [EOL] self . types = yaml . load ( stream ) [ [string] ] [EOL] self . spec [ [string] ] = self . types [EOL] [EOL] for job , node in self . spec . get ( [string] , { } ) . items ( ) : [EOL] actuals = node . get ( [string] , { } ) [EOL] op = actuals . get ( [string] , [string] ) [EOL] signature = node . get ( [string] , { } ) . get ( op , { } ) . get ( [string] , { } ) [EOL] logger . debug ( f" [string] { job }" ) [EOL] for arg , arg_spec in signature . items ( ) : [EOL] arg_type = arg_spec . get ( [string] ) [EOL] arg_required = arg_spec . get ( [string] ) [EOL] logger . debug ( f" [string] { arg_type } [string] { arg_required }" ) [EOL] [docstring] [EOL] if not arg_type in self . types : [EOL] self . errors . append ( f" [string] { arg_type } [string] { job } [string] " ) [EOL] else : [EOL] [docstring] [EOL] if arg_required and not arg in actuals : [EOL] self . errors . append ( f" [string] { arg } [string] { job } [string] " ) [EOL] if len ( self . errors ) > [number] : [EOL] for error in self . errors : [EOL] logger . debug ( error ) [EOL] raise ValueError ( [string] ) [EOL] logger . debug ( [string] ) [EOL] [EOL] @ staticmethod def get_workflow ( workflow = [string] , inputs = { } , library_path = [ [string] ] ) : [EOL] workflow_spec = None [EOL] with open ( workflow , [string] ) as stream : [EOL] workflow_spec = yaml . load ( stream . read ( ) ) [EOL] return Workflow ( workflow_spec , inputs = inputs , libpath = library_path ) [EOL] [EOL] [docstring] [EOL] [EOL] def get_step ( self , name ) : [EOL] return self . spec . get ( [string] , { } ) . get ( name ) [EOL] [EOL] def get_variable_name ( self , name ) : [EOL] result = None [EOL] if isinstance ( name , list ) : [EOL] result = [ n . replace ( [string] , [string] ) for n in name if isinstance ( n , str ) and n . startswith ( [string] ) ] [EOL] elif isinstance ( name , str ) : [EOL] result = name . replace ( [string] , [string] ) if isinstance ( name , str ) and name . startswith ( [string] ) else None [EOL] return result [EOL] [EOL] def resolve_arg ( self , name ) : [EOL] return [ self . resolve_arg_inner ( v ) for v in name ] if isinstance ( name , list ) else self . resolve_arg_inner ( name ) [EOL] [EOL] def resolve_arg_inner ( self , name ) : [EOL] [docstring] [EOL] value = name [EOL] if isinstance ( name , str ) and name . startswith ( [string] ) : [EOL] var = name . replace ( [string] , [string] ) [EOL] [docstring] [EOL] job_result = self . get_result ( var ) [EOL] if var in self . inputs : [EOL] value = self . inputs [ var ] [EOL] if [string] in value : [EOL] value = value . split ( [string] ) [EOL] elif job_result or isinstance ( job_result , dict ) : [EOL] value = job_result [EOL] else : [EOL] raise ValueError ( f" [string] { var }" ) [EOL] return value [EOL] [EOL] def to_camel_case ( self , snake_str ) : [EOL] components = snake_str . split ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] return components [ [number] ] + [string] . join ( x . title ( ) for x in components [ [number] : ] ) [EOL] [EOL] def add_step_dependency ( self , arg_val , dependencies ) : [EOL] name = self . get_variable_name ( arg_val ) [EOL] if name and self . get_step ( name ) : [EOL] dependencies . append ( name ) [EOL] [EOL] def get_dependent_job_names ( self , op_node ) : [EOL] dependencies = [ ] [EOL] try : [EOL] arg_list = op_node . get ( [string] , { } ) [EOL] for arg_name , arg_val in arg_list . items ( ) : [EOL] if isinstance ( arg_val , list ) : [EOL] for i in arg_val : [EOL] self . add_step_dependency ( i , dependencies ) [EOL] else : [EOL] self . add_step_dependency ( arg_val , dependencies ) [EOL] inputs = op_node . get ( [string] , { } ) . get ( [string] , { } ) [EOL] if isinstance ( inputs , dict ) : [EOL] from_job = inputs . get ( [string] , None ) [EOL] if from_job : [EOL] dependencies . append ( from_job ) [EOL] except : [EOL] traceback . print_exc ( ) [EOL] elements = op_node . get ( [string] , { } ) . get ( [string] , None ) [EOL] if elements : [EOL] dependencies = elements [EOL] for d in dependencies : [EOL] op = op_node [ [string] ] . get ( [string] , [string] ) [EOL] op = f" [string] { op }" if len ( op ) > [number] else [string] [EOL] logger . debug ( f" [string] { op_node [ [string] ] }{ op } [string] { d }" ) [EOL] return dependencies [EOL] [EOL] def generate_dependent_jobs ( self , workflow_model , operator , dag ) : [EOL] dependencies = [ ] [EOL] adjacency_list = { ident : deps for ident , deps in dag . adjacency ( ) } [EOL] op_node = self . spec [ [string] ] [ operator ] [EOL] dependency_tasks = adjacency_list [ operator ] . keys ( ) [EOL] return [ d for d in dependency_tasks ] [EOL] [EOL] [docstring] [EOL] def form_key ( self , job_name ) : [EOL] [docstring] [EOL] return f"{ self . uuid } [string] { job_name } [string] " [EOL] [EOL] def set_result ( self , job_name , value ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] self . spec . get ( [string] , { } ) . get ( job_name , { } ) [ [string] ] = value [EOL] [EOL] [docstring] [EOL] if value : [EOL] self . tools . to_knowledge_graph ( in_graph = self . tools . to_nx ( value ) , out_graph = self . graph ) [EOL] [EOL] [docstring] [EOL] if self . enable_cache : [EOL] key = self . form_key ( job_name ) [EOL] self . cache . set ( key , json . dumps ( value , indent = [number] ) ) [EOL] else : [EOL] self . mem_cache [ key ] = json . dumps ( value , indent = [number] ) [EOL] [EOL] def get_result ( self , job_name ) : [EOL] [docstring] [EOL] result = None [EOL] [EOL] [docstring] [EOL] if self . enable_cache : [EOL] key = self . form_key ( job_name ) [EOL] val = self . cache . get ( key ) [EOL] else : [EOL] val = self . mem_cache [ key ] [EOL] return json . loads ( val ) if val else None [EOL] [EOL] [docstring] [EOL] [EOL] def resolve ( self , d , event , loop , index ) : [EOL] result = d [EOL] if isinstance ( d , list ) : [EOL] result = [ self . resolve ( e , event , loop , index ) for e in d ] [EOL] elif isinstance ( d , dict ) : [EOL] for k , v in d . items ( ) : [EOL] result [ k ] = self . resolve ( v , event , loop , index ) [EOL] elif isinstance ( d , str ) : [EOL] if d . startswith ( [string] ) : [EOL] key = d [ [number] : ] [EOL] obj = loop [ key ] [ index ] if key in loop and len ( loop [ key ] ) > index else None [EOL] if not obj : [EOL] obj = event . context . resolve_arg ( d ) [EOL] result = obj [EOL] elif d . startswith ( [string] ) : [EOL] result = self . resolve_query ( d , event ) [EOL] return result [EOL] [EOL] def resolve_query ( self , value , event ) : [EOL] [docstring] [EOL] [docstring] [EOL] response = value [EOL] if isinstance ( value , str ) : [EOL] syntax_valid = False [EOL] tokens = value . split ( [string] ) [EOL] [docstring] [EOL] query_field_count = [number] [EOL] if len ( tokens ) == query_field_count : [EOL] select_keyword , pattern , from_keyword , source = tokens [EOL] if select_keyword == [string] and from_keyword == [string] : [EOL] pattern = pattern . strip ( [string] ) [EOL] if source . startswith ( [string] ) : [EOL] syntax_valid = True [EOL] resolved_source = event . context . resolve_arg ( source ) [EOL] logger . debug ( f" [string] { resolved_source } [string] { pattern } [string] " ) [EOL] response = event . context . json . select ( query = pattern , graph = resolved_source ) [EOL] logger . debug ( f" [string] { response }" ) [EOL] if not syntax_valid : [EOL] logger . error ( f" [string] { value } [string] " ) [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import ros [EOL] import logging [EOL] import typing [EOL] import json [EOL] import logging [EOL] import os [EOL] import sys [EOL] from ros . util import Context [EOL] from ros . util import JSONKit [EOL] from ros . util import Concept [EOL] from ros . util import LoggingUtil [EOL] from ros . tranqlast import TranQL_AST [EOL] from pyparsing import ( Word , White , Literal , delimitedList , Optional , Group , alphas , alphanums , printables , Forward , oneOf , quotedString , ZeroOrMore , restOfLine , CaselessKeyword , ParserElement , LineEnd , pyparsing_common as ppc ) [EOL] [EOL] LoggingUtil . setup_logging ( default_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] class TranQLParser : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] statement = Forward ( ) [EOL] SELECT , FROM , WHERE , SET , AS = map ( CaselessKeyword , [string] . split ( ) ) [EOL] [EOL] ident = Word ( [string] + alphas , alphanums + [string] ) . setName ( [string] ) [EOL] columnName = delimitedList ( ident , [string] , combine = True ) . setName ( [string] ) [EOL] columnNameList = Group ( delimitedList ( columnName ) ) [EOL] tableName = delimitedList ( ident , [string] , combine = True ) . setName ( [string] ) [EOL] tableNameList = Group ( delimitedList ( tableName ) ) [EOL] [EOL] SEMI , COLON , LPAR , RPAR , LBRACE , RBRACE , LBRACK , RBRACK , DOT , COMMA , EQ = map ( Literal , [string] ) [EOL] arrow = Literal ( [string] ) [EOL] t_expr = Group ( ident + LPAR + Word ( [string] + alphas , alphanums + [string] ) + RPAR + ZeroOrMore ( LineEnd ( ) ) ) . setName ( [string] ) | Word ( alphas , alphanums + [string] ) + ZeroOrMore ( LineEnd ( ) ) [EOL] t_expr_chain = t_expr + ZeroOrMore ( arrow + t_expr ) [EOL] [EOL] whereExpression = Forward ( ) [EOL] and_ , or_ , in_ = map ( CaselessKeyword , [string] . split ( ) ) [EOL] [EOL] binop = oneOf ( [string] , caseless = True ) [EOL] realNum = ppc . real ( ) [EOL] intNum = ppc . signed_integer ( ) [EOL] [EOL] columnRval = realNum | intNum | quotedString | columnName [comment] [EOL] whereCondition = Group ( ( columnName + binop + ( columnRval | Word ( printables ) ) ) | ( columnName + in_ + [string] + delimitedList ( columnRval ) + [string] ) | ( columnName + in_ + [string] + statement + [string] ) | ( [string] + whereExpression + [string] ) ) [EOL] whereExpression << whereCondition + ZeroOrMore ( ( and_ | or_ ) + whereExpression ) [EOL] [EOL] [docstring] [EOL] setExpression = Forward ( ) [EOL] setStatement = Group ( ( ident ) | ( quotedString ( [string] ) + AS + ident ( [string] ) ) | ( [string] + setExpression + [string] ) ) [EOL] setExpression << setStatement + ZeroOrMore ( ( and_ | or_ ) + setExpression ) [EOL] [EOL] optWhite = ZeroOrMore ( LineEnd ( ) | White ( ) ) [EOL] [EOL] [docstring] [EOL] statement <<= ( Group ( Group ( SELECT + t_expr_chain ) ( [string] ) + optWhite + Group ( FROM + tableNameList ) + optWhite + Group ( Optional ( WHERE + whereExpression ( [string] ) , [string] ) ) + optWhite + Group ( Optional ( SET + setExpression ( [string] ) , [string] ) ) ( [string] ) ) | Group ( SET + ( columnName + EQ + ( quotedString | intNum | realNum ) ) ) ( [string] ) ) ( [string] ) [EOL] [EOL] [docstring] [EOL] self . program = statement + ZeroOrMore ( statement ) [EOL] [EOL] [docstring] [EOL] comment = [string] + restOfLine [EOL] self . program . ignore ( comment ) [EOL] [EOL] def parse ( self , line ) : [EOL] [docstring] [EOL] result = self . program . parseString ( line ) [EOL] return TranQL_AST ( result . asList ( ) ) [EOL] [EOL] class TranQL : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . parser = TranQLParser ( ) [EOL] self . context = Context ( ) [EOL] [EOL] def execute ( self , program ) : [EOL] [docstring] [EOL] ast = None [EOL] if isinstance ( program , str ) : [EOL] ast = self . parser . parse ( program ) [EOL] if not ast : [EOL] raise ValueError ( f" [string] { type ( program ) }" ) [EOL] for statement in ast . statements : [EOL] logger . info ( f"{ statement }" ) [EOL] statement . execute ( interpreter = self ) [EOL] [EOL] if __name__ == [string] : [EOL] tranql = TranQL ( ) [EOL] tranql . execute ( [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.tranql.TranQLParser$ 0 0 0 0 0 0 0 $ros.util.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.tranql.TranQL$ 0 0 0 0 0 $ros.tranql.TranQL$ 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import typing [EOL] import json [EOL] import logging [EOL] import random [EOL] import networkx as nx [EOL] import yaml [EOL] from flatdict import FlatDict [EOL] from jsonpath_rw import jsonpath , parse [EOL] from networkx . readwrite import json_graph [EOL] [comment] [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] class TranslatorGraphTools : [EOL] [docstring] [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name = None ) : [EOL] self . name = name [EOL] [EOL] def from_file ( self , file_name ) : [EOL] [docstring] [EOL] result = None [EOL] with open ( file_name , [string] ) as stream : [EOL] result = json . load ( stream ) [EOL] return result [EOL] [EOL] def coalesce_node ( self , node , all_nodes , seen ) : [EOL] [docstring] [EOL] result = None [EOL] logger . debug ( node ) [EOL] n_id = node [ [string] ] [EOL] if not n_id in seen : [EOL] seen [ n_id ] = n_id [EOL] for n in all_nodes : [EOL] if n [ [string] ] == node [ [string] ] : [EOL] node . update ( n ) [EOL] result = node [EOL] return result [EOL] [EOL] def dedup_nodes ( self , nodes ) : [EOL] [docstring] [EOL] seen = { } [EOL] return [ nn for nn in [ self . coalesce_node ( n , nodes , seen ) for n in nodes ] if nn is not None ] [EOL] [EOL] def answer_set_to_nx ( self , answers ) : [EOL] [docstring] [EOL] result = nx . MultiDiGraph ( ) [EOL] for answer in answers : [EOL] g = self . to_nx ( answer ) [EOL] result = nx . compose ( result , g ) [EOL] return result [EOL] [EOL] def to_nx ( self , graph ) : [EOL] [docstring] [EOL] [EOL] [docstring] [EOL] g = nx . MultiDiGraph ( ) [EOL] [comment] [EOL] jsonpath_query = parse ( [string] ) [comment] [EOL] nodes = [ match . value for match in jsonpath_query . find ( graph ) ] [EOL] nodes = self . dedup_nodes ( nodes ) [EOL] [EOL] jsonpath_query = parse ( [string] ) [EOL] edges = [ match . value for match in jsonpath_query . find ( graph ) ] [EOL] for n in nodes : [EOL] logger . debug ( f" [string] { n }" ) [EOL] g . add_node ( n [ [string] ] , attr_dict = n ) [EOL] for e in edges : [EOL] logger . debug ( f" [string] { e }" ) [EOL] g . add_edge ( e [ [string] ] , e [ [string] ] , attr_dict = e ) [EOL] return g [EOL] [EOL] def to_knowledge_graph ( self , in_graph , out_graph , graph_label = None ) : [EOL] [docstring] [EOL] id2node = { } [EOL] for j , n in enumerate ( in_graph . nodes ( data = True ) ) : [EOL] logger . debug ( f" [string] { j } [string] { n }" ) [EOL] i , obj = n [EOL] if not [string] in obj : [EOL] continue [EOL] attr = n [ [number] ] [ [string] ] [EOL] [EOL] [docstring] [EOL] if isinstance ( attr [ [string] ] , int ) : [EOL] [docstring] [EOL] if isinstance ( attr [ [string] ] , int ) : [EOL] continue [EOL] if attr [ [string] ] . find ( [string] ) > [number] : [EOL] attr [ [string] ] = attr [ [string] ] [EOL] [EOL] id2node [ i ] = out_graph . add_node ( label = attr [ [string] ] , props = attr ) [EOL] for i , e in enumerate ( in_graph . edges ( data = True ) ) : [EOL] subj_id , obj_id , eprops = e [EOL] attr = eprops [ [string] ] [EOL] subj = id2node . get ( subj_id , { } ) . get ( [string] , None ) [EOL] pred = attr [ [string] ] [EOL] obj = id2node . get ( obj_id , { } ) . get ( [string] , None ) [EOL] [EOL] if subj == None or obj == None : [EOL] [comment] [EOL] continue [EOL] if graph_label : [EOL] attr [ [string] ] = graph_label [EOL] logger . debug ( f" [string] { subj } [string] { pred } [string] { attr } [string] { obj } [string] " ) [EOL] if subj and pred and obj : [EOL] out_graph . add_edge ( subj = subj , pred = pred , obj = obj , props = attr ) [EOL] [EOL] def to_knowledge_graph_kgx ( self , in_graph , out_graph , graph_label = None ) : [EOL] [docstring] [EOL] id2node = { } [EOL] for n in in_graph . nodes ( data = True ) : [EOL] node_id = n [ [number] ] [EOL] id2node [ node_id ] = n [ [number] ] [EOL] print ( f" [string] { n }" ) [EOL] root = n [ [number] ] [EOL] properties = root [ [string] ] [EOL] properties [ [string] ] = f" [string] { properties [ [string] ] }" [EOL] if [string] in properties : [EOL] print ( properties ) [EOL] flat = flattenDict ( properties , delim = [string] ) [EOL] properties . update ( flat ) [EOL] del properties [ [string] ] [EOL] root . update ( properties ) [EOL] del root [ [string] ] [EOL] print ( properties ) [EOL] for e in in_graph . edges ( data = True ) : [EOL] print ( f" [string] { e }" ) [EOL] attr = e [ [number] ] [ [string] ] [EOL] attr [ [string] ] = attr [ [string] ] [EOL] attr [ [string] ] = attr [ [string] ] [EOL] attr [ [string] ] = attr [ [string] ] [EOL] del attr [ [string] ] [EOL] del attr [ [string] ] [EOL] del attr [ [string] ] [EOL] with open ( [string] , [string] ) as ymlfile : [EOL] cfg = yaml . load ( ymlfile ) [EOL] kgx = NeoTransformer ( graph = in_graph , host = [string] , ports = { [string] : [number] } , username = cfg [ [string] ] [ [string] ] , password = cfg [ [string] ] [ [string] ] ) [EOL] kgx . save ( ) [EOL] [EOL] def file_to_nx ( self , file_name ) : [EOL] [docstring] [EOL] return self . to_nx ( self . from_file ( file_name ) ) [EOL] [EOL] def nx_to_d3_json ( self , g ) : [EOL] return json_graph . node_link_data ( g ) [EOL] [EOL] def file_to_d3_json ( self , file_name ) : [EOL] [docstring] [EOL] g = self . nx_to_d3_json ( self . file_to_nx ( file_name ) ) [EOL] del g [ [string] ] [EOL] del g [ [string] ] [EOL] del g [ [string] ] [EOL] node_count = [number] [EOL] for n in g [ [string] ] : [EOL] node_count = node_count + [number] [EOL] if [string] in n : [EOL] n [ [string] ] = n [ [string] ] [ [string] ] [EOL] new_edges = [ ] [EOL] for e in g [ [string] ] : [EOL] e [ [string] ] = round ( random . uniform ( [number] , [number] ) , [number] ) [EOL] del e [ [string] ] [EOL] new_edges . append ( e ) [EOL] return g [EOL] [EOL] def kgs ( self , nodes = [ ] , edges = [ ] ) : [EOL] [docstring] [EOL] return [ { [string] : [ { [string] : { [string] : nodes , [string] : edges } } ] } ] [EOL] [EOL] def flattenDict ( d , result = None , delim = [string] ) : [EOL] if result is None : [EOL] result = { } [EOL] for key in d : [EOL] value = d [ key ] [EOL] if isinstance ( value , dict ) : [EOL] value1 = { } [EOL] for keyIn in value : [EOL] value1 [ delim . join ( [ key , keyIn ] ) ] = value [ keyIn ] [EOL] flattenDict ( value1 , result , delim ) [EOL] elif isinstance ( value , ( list , tuple ) ) : [EOL] for indexB , element in enumerate ( value ) : [EOL] if isinstance ( element , dict ) : [EOL] value1 = { } [EOL] index = [number] [EOL] for keyIn in element : [EOL] newkey = delim . join ( [ key , keyIn , str ( indexB ) ] ) [EOL] value1 [ newkey ] = value [ indexB ] [ keyIn ] [EOL] index += [number] [EOL] for keyA in value1 : [EOL] flattenDict ( value1 , result , delim ) [EOL] elif isinstance ( element , ( list , tuple ) ) : [EOL] for i , value in enumerate ( element ) : [EOL] list_key = delim . join ( key , i ) [EOL] if isinstance ( value , dict ) : [EOL] value1 = { } [EOL] for keyIn in value : [EOL] k = delim . join ( [ key , i , keyIn ] ) [EOL] value1 [ k ] = value [ keyIn ] [EOL] flattenDict ( value1 , result , delim ) [EOL] else : [EOL] result [ key ] = value [EOL] return result [EOL] [EOL] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import json [EOL] import logging [EOL] import operator [EOL] import os [EOL] import pickle [EOL] import requests [EOL] import redis [EOL] import traceback [EOL] from ros . util import LoggingUtil [EOL] from lru import LRU [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] class CacheSerializer : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] class PickleCacheSerializer ( CacheSerializer ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] pass [EOL] def dumps ( self , obj ) : [EOL] return pickle . dumps ( obj ) [EOL] def loads ( self , str ) : [EOL] return pickle . loads ( str ) [EOL] [EOL] class JSONCacheSerializer ( CacheSerializer ) : [EOL] pass [comment] [EOL] [EOL] class Cache : [EOL] [docstring] [EOL] def __init__ ( self , cache_path = [string] , serializer = PickleCacheSerializer , redis_host = [string] , redis_port = [number] , redis_db = [number] , enabled = True , prefix = [string] ) : [EOL] [EOL] [docstring] [EOL] self . enabled = enabled [EOL] self . prefix = prefix [EOL] try : [EOL] self . redis = redis . StrictRedis ( host = redis_host , port = redis_port , db = redis_db ) [EOL] self . redis . get ( [string] ) [EOL] logger . info ( f" [string] { redis_host } [string] { redis_port } [string] { redis_db }" ) [EOL] except : [EOL] self . redis = None [EOL] [comment] [EOL] logger . error ( f" [string] { redis_host } [string] { redis_port } [string] { redis_db } [string] " ) [EOL] print ( f" [string] { redis_host } [string] { redis_port } [string] { redis_db } [string] " ) [EOL] self . cache_path = cache_path [EOL] if not os . path . exists ( self . cache_path ) : [EOL] os . makedirs ( self . cache_path ) [EOL] self . cache = LRU ( [number] ) [EOL] self . serializer = serializer ( ) [EOL] [EOL] def get ( self , key ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] key = self . prefix + key [EOL] result = None [EOL] if self . enabled : [EOL] if key in self . cache : [EOL] result = self . cache [ key ] [EOL] elif self . redis : [EOL] rec = self . redis . get ( key ) [EOL] result = self . serializer . loads ( rec ) if rec is not None else None [EOL] self . cache [ key ] = result [EOL] else : [EOL] path = os . path . join ( self . cache_path , key ) [EOL] if os . path . exists ( path ) : [EOL] with open ( path , [string] ) as stream : [EOL] result = self . serializer . loads ( stream . read ( ) ) [EOL] self . cache [ key ] = result [EOL] return result [EOL] [EOL] def set ( self , key , value ) : [EOL] [docstring] [EOL] key = self . prefix + key [EOL] if self . enabled : [EOL] if self . redis : [EOL] if value is not None : [EOL] self . redis . set ( key , self . serializer . dumps ( value ) ) [EOL] self . cache [ key ] = value [EOL] else : [EOL] path = os . path . join ( self . cache_path , key ) [EOL] with open ( path , [string] ) as stream : [EOL] stream . write ( self . serializer . dumps ( value ) ) [EOL] self . cache [ key ] = value [EOL] [EOL] def flush ( self ) : [EOL] if self . prefix : [EOL] keys = self . redis . keys ( f'{ self . prefix } [string] ' ) [EOL] if keys : [EOL] self . redis . delete ( * keys ) [EOL] else : [EOL] self . redis . flushdb ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import ros [EOL] from kgx import Transformer , NeoTransformer , PandasTransformer , NeoTransformer [EOL] [EOL] class KGraph : [EOL] [EOL] def __init__ ( self ) : [EOL] self . ports = ports = { [string] : [number] } [EOL] self . xform = NeoTransformer ( self . ports ) [EOL] [EOL] def transform ( self ) : [EOL] self . xform . save_node ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] if __name__ == [string] : [EOL] k = KGraph ( ) [EOL] k . transform ( ) [EOL] [EOL] [comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.kgxlib.KGraph$ 0 0 0 0 0 $ros.kgxlib.KGraph$ 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] import traceback [EOL] from greent . util import LoggingUtil [EOL] from pprint import pprint [EOL] from SPARQLWrapper import SPARQLWrapper2 , JSON , POSTDIRECTLY , POST [EOL] from string import Template [EOL] [EOL] logger = LoggingUtil . init_logging ( __name__ ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class TripleStore ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hostname ) : [EOL] self . service = SPARQLWrapper2 ( hostname ) [EOL] [EOL] def get_template ( self , query_name ) : [EOL] [docstring] [EOL] return Template ( self . get_template_text ( query_name ) ) [EOL] [EOL] def get_template_text ( self , query_name ) : [EOL] [docstring] [EOL] query = None [EOL] fn = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] . format ( query_name ) ) [EOL] with open ( fn , [string] ) as stream : [EOL] query = stream . read ( ) [EOL] return query [EOL] [EOL] def execute_query ( self , query , post = False ) : [EOL] [docstring] [EOL] if post : [EOL] self . service . setRequestMethod ( POSTDIRECTLY ) [EOL] self . service . setMethod ( POST ) [EOL] self . service . setQuery ( query ) [EOL] self . service . setReturnFormat ( JSON ) [EOL] return self . service . query ( ) . convert ( ) [EOL] [EOL] def query ( self , query_text , outputs , flat = False , post = False ) : [EOL] [docstring] [EOL] response = self . execute_query ( query_text , post ) [EOL] result = None [EOL] if flat : [EOL] result = list ( map ( lambda b : [ b [ val ] . value for val in outputs ] , response . bindings ) ) [EOL] else : [EOL] result = list ( map ( lambda b : { val : b [ val ] . value for val in outputs } , response . bindings ) ) [EOL] logger . debug ( [string] , result ) [EOL] return result [EOL] [EOL] def query_template ( self , template_text , outputs , inputs = [ ] , post = False ) : [EOL] [docstring] [EOL] return self . query ( Template ( template_text ) . safe_substitute ( ** inputs ) , outputs , post = post ) [EOL] [EOL] def query_template_file ( self , template_file , outputs , inputs = [ ] ) : [EOL] [docstring] [EOL] return self . query ( self . get_template_text ( template_file ) , inputs , outputs ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import logging [EOL] import typing [EOL] import json [EOL] import logging [EOL] from jsonpath_rw import jsonpath , parse [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] class Event : [EOL] [docstring] [EOL] def __init__ ( self , context , node ) : [EOL] self . context = context [EOL] self . node = node [EOL] logger . debug ( f" [string] { json . dumps ( self . node , indent = [number] ) }" ) [EOL] def __getattr__ ( self , k ) : [EOL] return self . __dict__ [ k ] if k in self . __dict__ else self . node . get ( [string] , { } ) . get ( k , None ) [EOL] def select ( self , query , graph , field = [string] , target = None ) : [EOL] [docstring] [EOL] return self . context . json . select ( query = query , graph = graph , field = field , target = target ) [EOL] [EOL] class Operator : [EOL] [EOL] [docstring] [EOL] def __init__ ( self , name = [string] ) : [EOL] self . name = name [EOL] [EOL] def invoke ( self , event ) : [EOL] [docstring] [EOL] result = None [EOL] operator = getattr ( self , event . op ) [EOL] if operator : [EOL] result = operator ( event ) [EOL] else : [EOL] raise ValueError ( f" [string] { args . op }" ) [EOL] return result [EOL] [EOL] @ staticmethod def create_event ( context , node , op , graph ) : [EOL] [docstring] [EOL] return namedtupled . map ( { [string] : context , [string] : node , [string] : op , [string] : namedtupled . ignore ( graph ) } ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import ros [EOL] import typing [EOL] from __future__ import absolute_import , unicode_literals [EOL] from __future__ import absolute_import [EOL] from celery import Celery [EOL] from kombu import Queue [EOL] from ros . config import Config [EOL] import json [EOL] [EOL] config = Config ( [string] ) [EOL] app = Celery ( config [ [string] ] ) [EOL] app . conf . update ( broker_url = config [ [string] ] , result_backend = config [ [string] ] , include = [ f"{ config [ [string] ] } [string] " ] ) [EOL] app . conf . task_queues = ( Queue ( [string] , routing_key = [string] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.config.Config$ 0 0 0 0 0 0 0 $ros.config.Config$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $ros.config.Config$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $ros.config.Config$ 0 0 0 0 0 0 $ros.config.Config$ 0 0 0 0 0 0 0 0 $ros.config.Config$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import argparse [EOL] import typing [EOL] import ros [EOL] import asyncio [EOL] import logging [EOL] import argparse [EOL] import contextlib [EOL] import json [EOL] import os [EOL] import requests [EOL] import logging [EOL] import logging . config [EOL] import sys [EOL] import time [EOL] import yaml [EOL] from types import SimpleNamespace [EOL] from ros . client import Client [EOL] from ros . router import Router [EOL] from ros . workflow import Workflow [EOL] from ros . lib . ndex import NDEx [EOL] from ros . tasks import exec_operator [EOL] from ros . util import JSONKit [EOL] from ros . util import LoggingUtil [EOL] import asyncio [EOL] import uvloop [EOL] asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ( ) ) [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] def run_job ( j , wf_model , asynchronous = False ) : [EOL] wf_model . topsort . remove ( j ) [EOL] logger . debug ( f" [string] { j }" ) [EOL] logger . debug ( f" [string] { wf_model . topsort }" ) [EOL] logger . debug ( f" [string] { wf_model . done . keys ( ) }" ) [EOL] if asynchronous : [EOL] wf_model . running [ j ] = exec_operator . delay ( model2json ( wf_model ) , j ) [EOL] else : [EOL] wf_model . done [ j ] = exec_operator ( model2json ( wf_model ) , j ) [EOL] [EOL] def json2model ( json ) : [EOL] return SimpleNamespace ( ** json ) [EOL] def model2json ( model ) : [EOL] return { [string] : model . uuid , [string] : model . spec , [string] : model . inputs , [string] : model . dependencies , [string] : model . topsort , [string] : { } , [string] : { } , [string] : { } } [EOL] [EOL] async def call_op ( workflow , router , job_name , op_node ) : [EOL] logger . debug ( f" [string] { job_name }" ) [EOL] return workflow . set_result ( job_name , router . route ( workflow , job_name , op_node , op_node [ [string] ] , op_node [ [string] ] ) ) [EOL] [EOL] async def exec_async ( workflow , job_name ) : [EOL] result = None [EOL] op_node = workflow . get_step ( job_name ) [EOL] if op_node : [EOL] logger . debug ( f" [string] { job_name }" ) [EOL] router = Router ( workflow ) [EOL] [docstring] [EOL] result = await call_op ( workflow , router , job_name , op_node ) [EOL] return result [EOL] [EOL] class AsyncioExecutor : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , workflow ) : [EOL] [docstring] [EOL] self . workflow = workflow [EOL] [EOL] async def execute ( self ) : [EOL] [docstring] [EOL] while len ( self . workflow . topsort ) > len ( self . workflow . execution . done ) : [EOL] logger . debug ( [string] ) [EOL] topsort = self . workflow . topsort . copy ( ) [EOL] pending = topsort . copy ( ) [EOL] for j in topsort : [EOL] [EOL] if j in self . workflow . execution . done or j in self . workflow . execution . running : [EOL] [docstring] [EOL] continue [EOL] [EOL] dependencies = self . workflow . dependencies [ j ] [EOL] logger . debug ( f" [string] { j } [string] { [ d for d in self . workflow . execution . done . keys ( ) ] } [string] { dependencies }" ) [EOL] if len ( dependencies ) == [number] or all ( [ d in self . workflow . execution . done for d in dependencies ] ) : [EOL] [docstring] [EOL] task = asyncio . ensure_future ( exec_async ( self . workflow , j ) ) [EOL] self . workflow . execution . running [ j ] = task [EOL] pending . remove ( j ) [EOL] await task [EOL] [EOL] completed = [ ] [EOL] for job_name , promise in self . workflow . execution . running . items ( ) : [EOL] logger . debug ( f" [string] { job_name } [string] { promise . done ( ) }" ) [EOL] if promise . done ( ) : [EOL] completed . append ( job_name ) [EOL] if promise . exception ( ) : [EOL] completed . append ( job_name ) [EOL] self . workflow . execution . failed [ job_name ] = promise . get ( ) [EOL] raise promise . exception ( ) [EOL] else : [EOL] self . workflow . execution . done [ job_name ] = self . workflow . get_result ( job_name ) [EOL] for c in completed : [EOL] logger . debug ( f" [string] { job_name } [string] " ) [EOL] del self . workflow . execution . running [ c ] [EOL] time . sleep ( [number] ) [EOL] return self . workflow . execution . done [ [string] ] [EOL] [EOL] class CeleryDAGExecutor : [EOL] def __init__ ( self , spec ) : [EOL] self . spec = spec [EOL] def execute ( self ) : [EOL] [docstring] [EOL] model_dict = self . spec . json ( ) [comment] [EOL] model = json2model ( model_dict ) [EOL] total_jobs = len ( model . topsort ) [EOL] [docstring] [EOL] while len ( model . topsort ) > [number] : [EOL] for j in model . topsort : [EOL] if j in model . done : [EOL] break [EOL] dependencies = model . dependencies [ j ] [EOL] if len ( dependencies ) == [number] : [EOL] [docstring] [EOL] run_job ( j , model , asynchronous = False ) [EOL] else : [EOL] [docstring] [EOL] if all ( [ d in model . done for d in dependencies ] ) : [EOL] run_job ( j , model , asynchronous = False ) [EOL] completed = [ ] [EOL] [docstring] [EOL] for job_name , promise in model . running . items ( ) : [EOL] logger . debug ( f" [string] { job_name } [string] { promise . ready ( ) } [string] { promise . failed ( ) }" ) [EOL] if promise . ready ( ) : [EOL] completed . append ( job_name ) [EOL] model . done [ job_name ] = promise . get ( ) [EOL] sink = model . get ( [string] , { } ) . get ( c , { } ) [EOL] sink [ [string] ] = model . done [ c ] [EOL] elif promise . failed ( ) : [EOL] completed . append ( job_name ) [EOL] model . failed [ job_name ] = promise . get ( ) [EOL] for c in completed : [EOL] logger . debug ( f" [string] { job_name } [string] " ) [EOL] del model . running [ c ] [EOL] return model . done [ [string] ] [EOL] [EOL] def start_task_queue ( ) : [EOL] [docstring] [EOL] code_path = os . path . join ( os . path . dirname ( __file__ ) ) [EOL] celery_manager = CeleryManager ( code_dir_to_monitor = code_path , celery_working_dir = code_path , celery_cmdline = [string] . split ( [string] ) ) [EOL] celery_manager . start ( ) [EOL] [EOL] def main ( ) : [EOL] arg_parser = argparse . ArgumentParser ( description = [string] , formatter_class = lambda prog : argparse . ArgumentDefaultsHelpFormatter ( prog , max_help_position = [number] ) ) [EOL] arg_parser . add_argument ( [string] , [string] , help = [string] , action = [string] ) [EOL] arg_parser . add_argument ( [string] , [string] , help = [string] , default = [string] ) [EOL] arg_parser . add_argument ( [string] , [string] , help = [string] , default = [string] ) [EOL] arg_parser . add_argument ( [string] , [string] , help = [string] , action = [string] , default = [ ] ) [EOL] arg_parser . add_argument ( [string] , [string] , help = [string] ) [EOL] arg_parser . add_argument ( [string] , [string] , help = [string] , action = [string] , default = [ [string] ] ) [EOL] arg_parser . add_argument ( [string] , [string] , help = [string] ) [EOL] arg_parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] args = arg_parser . parse_args ( ) [EOL] [EOL] LoggingUtil . setup_logging ( ) [EOL] [EOL] [docstring] [EOL] wf_args = { k : v for k , v in [ arg . split ( [string] ) for arg in args . arg ] } [EOL] response = None [EOL] if args . api : [EOL] [EOL] [docstring] [EOL] client = Client ( url = args . server ) [EOL] ros_result = client . run ( workflow = args . workflow , args = wf_args , library_path = args . libpath ) [EOL] response = ros_result . result [EOL] [EOL] else : [EOL] [EOL] [docstring] [EOL] executor = AsyncioExecutor ( workflow = Workflow . get_workflow ( workflow = args . workflow , inputs = wf_args , library_path = args . libpath ) ) [EOL] tasks = [ asyncio . ensure_future ( executor . execute ( ) ) ] [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( asyncio . wait ( tasks ) ) [EOL] [EOL] response = tasks [ [number] ] . result ( ) [EOL] [EOL] if args . ndex : [EOL] [docstring] [EOL] jsonkit = JSONKit ( ) [EOL] graph = jsonkit . select ( [string] , response ) [EOL] logger . debug ( f" [string] { args . ndex } [string] { json . dumps ( graph , indent = [number] ) }" ) [EOL] NDEx ( ) . _publish ( args . ndex , graph ) [EOL] [EOL] if args . out : [EOL] [docstring] [EOL] if args . out == [string] : [EOL] print ( f"{ json . dumps ( response , indent = [number] ) }" ) [EOL] else : [EOL] with open ( args . out , [string] ) as stream : [EOL] json . dump ( response , stream , indent = [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import copy [EOL] import logging [EOL] import json [EOL] import os [EOL] import yaml [EOL] import traceback [EOL] import re [EOL] from ros . util import Resource [EOL] from numbers import Number [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] class Config ( dict ) : [EOL] def __init__ ( self , config = None , prefix = [string] ) : [EOL] if config == None : [EOL] local_config = os . path . expanduser ( [string] ) [EOL] default_config = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] config = local_config if os . path . exists ( local_config ) else default_config [EOL] if isinstance ( config , str ) : [EOL] config_path = Resource . get_resource_path ( config ) [EOL] with open ( config_path , [string] ) as f : [EOL] self . conf = yaml . safe_load ( f ) [EOL] elif isinstance ( config , dict ) : [EOL] self . conf = config [EOL] else : [EOL] raise ValueError [EOL] [EOL] self . prefix = prefix [EOL] [EOL] new_conf = copy . deepcopy ( self . conf ) [EOL] self . key_dig ( base_k = None , k = None , d = self . conf , root_d = new_conf ) [EOL] [comment] [EOL] self . conf . update ( new_conf ) [EOL] [EOL] def key_dig ( self , base_k , k , d , root_d ) : [EOL] if base_k : [EOL] if k : [EOL] this_key = f"{ base_k } [string] { k }" [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] else : [EOL] if k : [EOL] this_key = k [EOL] else : [EOL] this_key = [string] [EOL] [EOL] if isinstance ( d , dict ) : [EOL] for nk , nv in d . items ( ) : [EOL] logger . debug ( f"{ base_k } [string] { k } [string] { nk } [string] { nv }" ) [EOL] v = self . key_dig ( base_k = this_key , k = nk , d = nv , root_d = root_d ) [EOL] elif isinstance ( d , str ) or isinstance ( d , Number ) : [EOL] root_d [ this_key ] = str ( d ) [EOL] root_d [ this_key . upper ( ) ] = str ( d ) [EOL] [EOL] def get_service ( self , service ) : [EOL] result = { } [EOL] try : [EOL] result = self [ [string] ] [ [string] ] [ service ] [EOL] except : [EOL] traceback . print_exc ( ) [EOL] return result [EOL] def __setitem__ ( self , key , val ) : [EOL] raise TypeError ( [string] ) [EOL] def __str__ ( self ) : [EOL] return [string] + [string] . join ( list ( self . conf . keys ( ) ) ) [EOL] def get ( self , key , default = None ) : [EOL] try : [EOL] return self . __getitem__ ( key ) [EOL] except KeyError : [EOL] return default [EOL] def __getitem__ ( self , key ) : [EOL] [docstring] [EOL] key_var = re . sub ( [string] , [string] , key ) [EOL] name = self . prefix + [string] + key_var if self . prefix else key_var [EOL] try : [EOL] env_name = name . upper ( ) [EOL] return os . environ [ env_name ] [EOL] except KeyError : [EOL] value = self . conf [ key ] [EOL] if isinstance ( value , dict ) : [EOL] return Config ( value , prefix = name ) [EOL] else : [EOL] return value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0
import argparse [EOL] import copy [EOL] import json [EOL] import logging [EOL] import namedtupled [EOL] import os [EOL] import requests [EOL] import sys [EOL] import yaml [EOL] import time [EOL] import traceback [EOL] from jsonpath_rw import jsonpath , parse [EOL] from ros . config import Config [EOL] from ros . framework import Event [EOL] from ros . framework import Operator [EOL] from ros . lib . ndex import NDEx [EOL] from ros . lib . validate import Validate [EOL] from ros . util import MaQ [EOL] from ros . cache import Cache [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] [docstring] [EOL] [EOL] [docstring] [EOL] first_router = True [EOL] [EOL] class Router : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , workflow ) : [EOL] self . workflow = workflow [EOL] self . r = { [string] : self . requests , [string] : self . validate , [string] : self . union , [string] : self . http_get } [EOL] [EOL] global first_router [EOL] if first_router : [EOL] logger . debug ( f" [string] " ) [EOL] for plugin in self . workflow . plugins : [EOL] libraries = plugin . libraries ( ) [EOL] for libname in libraries : [EOL] lib = self . workflow . instantiate ( libname ) [EOL] invoker = self . create_plugin_invoker ( libname ) [EOL] self . r [ lib . name ] = invoker [EOL] if first_router : [EOL] logger . debug ( f" [string] { libname } [string] { plugin . name } [string] " ) [EOL] first_router = False [EOL] [EOL] self . create_template_adapters ( ) [EOL] self . config = Config ( ) [EOL] self . cache = Cache ( redis_host = self . config [ [string] ] , redis_port = self . config [ [string] ] ) [EOL] [EOL] def create_plugin_invoker ( self , libname ) : [comment] [EOL] def invoker ( context , job_name , node , op , args ) : [EOL] lib = self . workflow . instantiate ( libname ) [EOL] return lib . invoke ( Event ( context = context , node = node ) ) [EOL] return invoker [EOL] [EOL] def create_template_adapters ( self ) : [EOL] [docstring] [EOL] for name , template in self . workflow . spec . get ( [string] , { } ) . items ( ) : [EOL] op = template . get ( [string] , None ) [EOL] method = self . r . get ( op , None ) [EOL] if method : [EOL] def invoke_template ( context , job_name , node , op , args ) : [EOL] node [ [string] ] . update ( template [ [string] ] ) [EOL] return method ( context , job_name , node , op , args ) [EOL] self . r [ name ] = invoke_template [EOL] [EOL] def short_text ( self , text , max_len = [number] ) : [EOL] [docstring] [EOL] return ( text [ : max_len ] + [string] ) if len ( text ) > max_len else text [EOL] [EOL] def route ( self , context , job_name , op_node , op , args ) : [EOL] [docstring] [EOL] result = None [EOL] if op in self . r : [EOL] [docstring] [EOL] node_copy = copy . deepcopy ( op_node ) [EOL] [EOL] [docstring] [EOL] node_copy [ [string] ] = { k : context . resolve_arg ( v ) for k , v in args . items ( ) } [EOL] [EOL] [docstring] [EOL] arg_list = { [string] : context , [string] : job_name , [string] : node_copy , [string] : args . get ( [string] , None ) , [string] : node_copy [ [string] ] } [EOL] [docstring] [EOL] op_name = op_node [ [string] ] . get ( [string] , [string] ) [EOL] key = f"{ job_name } [string] { op_node [ [string] ] }" [EOL] if op_name and len ( op_name ) > [number] : [EOL] key = f"{ key } [string] { op_name }" [EOL] [EOL] result = self . cache . get ( key ) [EOL] print ( self . cache . cache . keys ( ) ) [EOL] if result : [EOL] result = json . loads ( result ) [EOL] else : [EOL] logger . debug ( f" [string] { op } [string] { self . r [ op ] }" ) [EOL] result = self . r [ op ] ( ** arg_list ) [EOL] self . cache . set ( key , json . dumps ( result , indent = [number] ) ) [EOL] [EOL] text = self . short_text ( str ( result ) ) [EOL] [EOL] logger . debug ( f" [string] { job_name } [string] { op_node [ [string] ] } [string] { op_node [ [string] ] . get ( [string] , [string] ) } [string] { text }" ) [EOL] else : [EOL] raise ValueError ( f" [string] { op }" ) [EOL] return result [EOL] [EOL] def union ( self , context , job_name , node , op , args ) : [EOL] [docstring] [EOL] return [ context . get_step ( e ) [ [string] ] for e in args . get ( [string] , [ ] ) ] [EOL] [EOL] def http_get ( self , context , job_name , node , op , args ) : [EOL] [docstring] [EOL] event = Event ( context , node ) [EOL] url = event . pattern . format ( ** event . node [ [string] ] ) [EOL] logger . debug ( [string] ) [EOL] response = nodes = requests . get ( url = url , headers = { [string] : [string] } ) . json ( ) [EOL] [EOL] [docstring] [EOL] for v in event . rename : [EOL] foreach = v [ [string] ] [EOL] old = v [ [string] ] [EOL] new = v [ [string] ] [EOL] [comment] [EOL] for r in response : [EOL] logger . debug ( f" [string] { old } [string] { new } [string] { r }" ) [EOL] if not new in r and old in r : [EOL] r [ new ] = r [ old ] [EOL] del r [ old ] [EOL] logger . debug ( f" [string] { response }" ) [EOL] return context . tools . kgs ( response ) [EOL] [EOL] def requests ( self , context , job_name , node , op , args ) : [EOL] [docstring] [EOL] result = None [EOL] event = Event ( context , node ) [EOL] url = event . url . format ( ** event . node [ [string] ] ) [EOL] if event . MaQ : [EOL] responses = [ ] [EOL] maq = MaQ ( ) [EOL] questions = maq . parse ( event . MaQ , self . workflow ) [EOL] for question in questions : [EOL] logger . debug ( f" [string] { json . dumps ( question , indent = [number] ) }" ) [EOL] response = requests . post ( url = url , json = question , headers = { [string] : [string] } ) [EOL] [docstring] [EOL] if response . status_code == [number] or response . status_code == [number] : [EOL] responses . append ( response . json ( ) ) [EOL] else : [EOL] logger . warning ( f" [string] { response . status_code } [string] { question }" ) [EOL] print ( response . text ) [EOL] [comment] [EOL] [EOL] edges = [ ] [EOL] nodes = [ ] [EOL] for r in responses : [EOL] [comment] [EOL] if [string] in r : [EOL] for answer in r [ [string] ] : [EOL] nodes = nodes + answer [ [string] ] [EOL] edges = edges + answer [ [string] ] [EOL] [comment] [EOL] if not [string] in r : [EOL] continue [EOL] for g in r [ [string] ] : [EOL] print ( json . dumps ( g , indent = [number] ) ) [EOL] edges = edges + g [ [string] ] [ [string] ] [EOL] nodes = nodes + g [ [string] ] [ [string] ] [EOL] result = self . workflow . tools . kgs ( nodes = nodes , edges = edges ) [EOL] [EOL] elif event . body : [EOL] [docstring] [EOL] response = requests . post ( url = url , json = event . body , headers = { [string] : [string] } ) [EOL] if response . status_code == [number] or response . status_code == [number] : [EOL] result = response . json ( ) [EOL] else : [EOL] raise ValueError ( response . text ) [EOL] else : [EOL] [EOL] [docstring] [EOL] response = requests . get ( url = url , headers = { [string] : [string] } ) [EOL] if response . status_code == [number] or response . status_code == [number] : [EOL] result = response . json ( ) [EOL] if [string] in url : [EOL] for n in result : [EOL] n [ [string] ] = n [ [string] ] [EOL] del n [ [string] ] [EOL] print ( f"{ json . dumps ( result , indent = [number] ) }" ) [EOL] else : [EOL] raise ValueError ( response . text ) [EOL] [EOL] logger . debug ( f" [string] { json . dumps ( result , indent = [number] ) }" ) [EOL] return result [EOL] [EOL] def validate ( self , context , job_name , node , op , args ) : [EOL] return Validate ( ) . invoke ( Event ( context = context , node = node ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import jinja2 [EOL] import argparse [EOL] import requests [EOL] import typing [EOL] import ros [EOL] import logging [EOL] import argparse [EOL] import json [EOL] import requests [EOL] import logging [EOL] from jinja2 import Template [EOL] import sys [EOL] from io import IOBase [EOL] from io import TextIOWrapper [EOL] from jsonpath_rw import parse [EOL] from ros . util import JSONKit [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] class GraphOp : [EOL] [EOL] def __init__ ( self , url ) : [EOL] self . url = url [EOL] [EOL] def call ( self , message ) : [EOL] result = None [EOL] [EOL] [docstring] [EOL] response = requests . post ( url = self . url , json = message , headers = { [string] : [string] } ) [EOL] if response . status_code == [number] : [EOL] logger . debug ( f" [string] { self . url } [string] " ) [EOL] result = response . json ( ) [EOL] else : [EOL] text = response . text [ - [number] : ] if len ( response . text ) > [number] else response . text [EOL] logger . error ( f" [string] { self . url } [string] { text }" ) [EOL] logger . error ( f" [string] { self . url } [string] { response . status_code } [string] { text }" ) [EOL] return result [EOL] [EOL] class LifeCycle : [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def from_file ( self , path , required = False ) : [EOL] value = None [EOL] try : [EOL] if isinstance ( path , str ) : [EOL] with open ( path , [string] ) as stream : [EOL] value = json . load ( stream ) [EOL] print ( f" [string] { path }" ) [EOL] elif isinstance ( path , IOBase ) : [EOL] value = json . load ( path ) [EOL] else : [EOL] raise ValueError ( f" [string] { type ( path ) }" ) [EOL] except : [EOL] if required : [EOL] raise ValueError ( f" [string] { path }" ) [EOL] else : [EOL] print ( f" [string] { json . dumps ( value , indent = [number] ) }" ) [EOL] logger . info ( f" [string] { path }" ) [EOL] return value [EOL] [EOL] def generate_questions ( self , source , query , filter_val , question_template_path ) : [EOL] questions = [ ] [EOL] with open ( question_template_path , [string] ) as stream : [EOL] template = Template ( stream . read ( ) ) [EOL] [EOL] if query : [EOL] jsonkit = JSONKit ( ) [EOL] print ( f" [string] { query } [string] { json . dumps ( source , indent = [number] ) } [string] { filter_val }" ) [EOL] print ( f" [string] { query } [string] { type ( source ) } [string] { filter_val }" ) [EOL] selected = jsonkit . select ( query = query , graph = source , target = filter_val ) [EOL] print ( f" [string] { json . dumps ( selected , indent = [number] ) }" ) [EOL] for n in selected : [EOL] print ( f" [string] { template . render ( n ) }" ) [EOL] questions . append ( json . loads ( template . render ( n ) ) ) [EOL] [EOL] print ( f" [string] { json . dumps ( questions , indent = [number] ) }" ) [EOL] return questions [EOL] [EOL] def execute ( self , question_path , source_path , query , filter_val , service , output ) : [EOL] [docstring] [EOL] question = self . from_file ( question_path ) [EOL] source = self . from_file ( source_path ) [EOL] [EOL] questions = [ ] [EOL] if question and source : [EOL] questions = self . generate_questions ( source = source , query = query , filter_val = filter_val , question_template_path = question_path ) [EOL] else : [EOL] questions = [ question ] [EOL] [EOL] op = GraphOp ( url = service ) [EOL] [EOL] response = { } [EOL] [EOL] for q in questions : [EOL] print ( f" [string] { json . dumps ( q , indent = [number] ) }" ) [EOL] response0 = op . call ( q ) [EOL] print ( f" [string] { json . dumps ( response0 , indent = [number] ) }" ) [EOL] response . update ( response0 ) [EOL] [EOL] [docstring] [EOL] [EOL] print ( f" [string] { output }" ) [EOL] if isinstance ( output , TextIOWrapper ) : [EOL] with open ( output . name , [string] ) as stream : [EOL] print ( f" [string] { response } [string] " ) [EOL] if response : [EOL] [EOL] json . dump ( response , stream , indent = [number] ) [EOL] else : [EOL] if response : [EOL] json . dump ( response , output , indent = [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] arg_parser = argparse . ArgumentParser ( description = [string] , formatter_class = lambda prog : argparse . ArgumentDefaultsHelpFormatter ( prog , max_help_position = [number] ) ) [EOL] arg_parser . add_argument ( [string] , help = [string] ) [EOL] arg_parser . add_argument ( [string] , help = [string] ) [EOL] arg_parser . add_argument ( [string] , help = [string] ) [EOL] arg_parser . add_argument ( [string] , help = [string] ) [EOL] arg_parser . add_argument ( [string] , help = [string] ) [EOL] arg_parser . add_argument ( [string] , help = [string] , type = argparse . FileType ( [string] ) ) [EOL] [EOL] args = arg_parser . parse_args ( ) [EOL] [EOL] lifecycle = LifeCycle ( ) [EOL] lifecycle . execute ( service = args . service , question_path = args . question , source_path = args . source , query = args . select , filter_val = args . type , output = args . output ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $requests.models.Response$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 $builtins.str$ 0 0 0 0 $requests.models.Response$ 0 $builtins.str$ 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Template$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.util.JSONKit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $ros.util.JSONKit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $jinja2.environment.Template$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $jinja2.environment.Template$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $ros.roscwlapi.GraphOp$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $ros.roscwlapi.GraphOp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $ros.roscwlapi.LifeCycle$ 0 0 0 0 0 $ros.roscwlapi.LifeCycle$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0
from typing import Any [EOL] import ros [EOL] import logging [EOL] import typing [EOL] import json [EOL] import logging [EOL] import networkx as nx [EOL] import os [EOL] import sys [EOL] from jsonpath_rw import jsonpath , parse [EOL] from ndex2 import create_nice_cx_from_networkx [EOL] from ndex2 . client import Ndex2 [EOL] from ros . util import JSONKit [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] class NDEx : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , uri = [string] ) : [EOL] [EOL] self . jsonkit = JSONKit ( ) [EOL] [EOL] [docstring] [EOL] ndex_creds = os . path . expanduser ( [string] ) [EOL] if os . path . exists ( ndex_creds ) : [EOL] with open ( ndex_creds , [string] ) as stream : [EOL] ndex_creds_obj = json . loads ( stream . read ( ) ) [EOL] logger . debug ( f" [string] { ndex_creds_obj [ [string] ] }" ) [EOL] account = ndex_creds_obj [ [string] ] [EOL] password = ndex_creds_obj [ [string] ] [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . uri = uri [EOL] self . session = None [EOL] self . account = account [EOL] self . password = password [EOL] try : [EOL] self . session = Ndex2 ( uri , account , password ) [EOL] self . session . update_status ( ) [EOL] networks = self . session . status . get ( [string] ) [EOL] users = self . session . status . get ( [string] ) [EOL] groups = self . session . status . get ( [string] ) [EOL] logger . debug ( f" [string] { networks } [string] { users } [string] { groups }" ) [EOL] except Exception as inst : [EOL] logger . error ( f" [string] { account }" ) [EOL] raise inst [EOL] [EOL] def publish ( self , event ) : [EOL] return self . _publish ( name = event . name , graph = event . graph ) [EOL] [EOL] def _publish ( self , name , graph ) : [EOL] [EOL] [docstring] [EOL] assert name , [string] [EOL] assert graph , [string] [EOL] assert len ( graph ) > [number] , [string] [EOL] [EOL] [docstring] [EOL] [docstring] [EOL] [docstring] [EOL] [docstring] [EOL] nodes = self . jsonkit . select ( query = [string] , graph = graph ) [EOL] edges = self . jsonkit . select ( query = [string] , graph = graph ) [EOL] [EOL] [docstring] [EOL] g = nx . MultiDiGraph ( ) [EOL] for n in nodes : [EOL] g . add_node ( n [ [string] ] , attr_dict = n ) [EOL] for e in edges : [EOL] g . add_edge ( e [ [string] ] , e [ [string] ] , attr_dict = e ) [EOL] [EOL] assert len ( g . nodes ( ) ) > [number] , [string] [EOL] logger . debug ( f" [string] { len ( g . edges ( ) ) } [string] { len ( g . nodes ( ) ) }" ) [EOL] [EOL] [docstring] [EOL] nice_cx = create_nice_cx_from_networkx ( g ) [EOL] nice_cx . set_name ( name ) [EOL] [EOL] [docstring] [EOL] upload_message = nice_cx . upload_to ( self . uri , self . account , self . password ) [EOL] logger . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.util.JSONKit$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
[EOL] from typing import Dict , Any [EOL] import typing [EOL] import pandas as pd [EOL] import numpy as np [EOL] from causality . inference . search import IC [EOL] from causality . inference . independence_tests import RobustRegressionTest [EOL] [EOL] SIZE = [number] [EOL] x1 = np . random . normal ( size = SIZE ) [EOL] x2 = x1 + np . random . normal ( size = SIZE ) [EOL] x3 = x1 + np . random . normal ( size = SIZE ) [EOL] x4 = x2 + x3 + np . random . normal ( size = SIZE ) [EOL] x5 = x4 + np . random . normal ( size = SIZE ) [EOL] [EOL] [comment] [EOL] X = pd . DataFrame ( { [string] : x1 , [string] : x2 , [string] : x3 , [string] : x4 , [string] : x5 } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] variable_types = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] ic_algorithm = IC ( RobustRegressionTest ) [EOL] graph = ic_algorithm . search ( X , variable_types ) [EOL] [EOL] e = graph . edges ( data = True ) [EOL] print ( f"{ e }" ) [EOL] [EOL] SIZE = [number] [EOL] x1 = np . random . normal ( size = SIZE ) [EOL] x2 = x1 + np . random . normal ( size = SIZE ) [EOL] x3 = x1 + np . random . normal ( size = SIZE ) [EOL] x6 = np . random . normal ( size = SIZE ) [EOL] x4 = x2 + x3 + x6 + np . random . normal ( size = SIZE ) [EOL] x5 = x6 + np . random . normal ( size = SIZE ) [EOL] [EOL] [comment] [EOL] X = pd . DataFrame ( { [string] : x1 , [string] : x2 , [string] : x3 , [string] : x4 , [string] : x5 } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] variable_types = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] ic_algorithm = IC ( RobustRegressionTest ) [EOL] graph = ic_algorithm . search ( X , variable_types ) [EOL] [EOL] e = graph . edges ( data = True ) [EOL] [EOL] print ( f"{ e }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Dict , Any , Pattern , Match , Optional [EOL] import ros [EOL] import logging [EOL] import typing [EOL] import json [EOL] import logging [EOL] import re [EOL] import requests [EOL] from ros . framework import Operator [EOL] from ros . util import Syfur [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . WARNING ) [EOL] [EOL] class Validate ( Operator ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . syfur = Syfur ( ) [EOL] [EOL] def invoke ( self , event ) : [EOL] [docstring] [EOL] [EOL] result = { } [EOL] [EOL] [docstring] [EOL] var = event . context . resolve_arg ( event . when [ [string] ] ) [EOL] val = event . when [ [string] ] [EOL] if not var == val : [EOL] logger . info ( f" [string] { var } [string] { val } [string] " ) [EOL] return result [EOL] [EOL] [docstring] [EOL] for name , assertion in event . then . items ( ) : [EOL] logger . info ( f" [string] { name } [string] { assertion [ [string] ] }" ) [EOL] items = event . context . graph . query ( self . syfur . parse ( assertion [ [string] ] ) ) [EOL] [EOL] all_op = assertion . get ( [string] , None ) [EOL] match_op = assertion . get ( [string] , None ) [EOL] none_op = assertion . get ( [string] , None ) [EOL] [EOL] if all_op : [EOL] for a in all_op : [EOL] assert a in items , f" [string] { a } [string] { items } [string] " [EOL] result [ [string] ] = [string] [EOL] if match_op : [EOL] for m in match_op : [EOL] pat = re . compile ( m ) [EOL] for i in items : [EOL] match = pat . match ( i ) [EOL] assert match . group ( ) , f" [string] { m } [string] { items } [string] " [EOL] result [ [string] ] = [string] [EOL] if none_op : [EOL] for n in none_op : [EOL] assert n not in items , f" [string] { n } [string] { items } [string] " [EOL] result [ [string] ] = [string] [EOL] return event . context . tools . kgs ( nodes = [ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.util.Syfur$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 $typing.Pattern[typing.Any]$ 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import flask [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging . config [EOL] import os [EOL] import sys [EOL] [EOL] from flask import Flask , Blueprint [EOL] from flask_restful import Api [EOL] from flasgger import Swagger [EOL] from flask_cors import CORS [EOL] [EOL] app = Flask ( __name__ , static_folder = [string] , template_folder = [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] api_blueprint = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] api = Api ( api_blueprint ) [EOL] CORS ( app ) [EOL] app . register_blueprint ( api_blueprint ) [EOL] [EOL] template = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [string] , [string] : [string] } , [string] : [ [string] , [string] ] } [EOL] app . config [ [string] ] = { [string] : [string] , [string] : [number] } [EOL] swagger = Swagger ( app , template = template ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 $flask.app.Flask$ 0 0 $flask.app.Flask$ 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0
from typing import Dict , Any [EOL] import ros [EOL] import logging [EOL] import typing [EOL] import argparse [EOL] import argparse [EOL] import logging [EOL] from json import loads as json_loads [EOL] from json import dumps as json_dumps [EOL] from ros . app import AsyncioExecutor [EOL] from ros . workflow import Workflow [EOL] from ros . util import LoggingUtil [EOL] from sanic import Sanic [EOL] from sanic . response import html , json [EOL] from tornado . platform . asyncio import BaseAsyncIOLoop , to_asyncio_future [EOL] from sanic_openapi import swagger_blueprint , openapi_blueprint [EOL] from sanic_openapi import doc [EOL] [EOL] [docstring] [EOL] [EOL] LoggingUtil . setup_logging ( default_path = [string] ) [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] app = Sanic ( __name__ ) [EOL] app . blueprint ( openapi_blueprint ) [EOL] app . blueprint ( swagger_blueprint ) [EOL] [EOL] [docstring] [EOL] app . config . API_VERSION = [string] [EOL] app . config . API_TITLE = [string] [EOL] app . config . API_DESCRIPTION = [string] [EOL] app . config . API_TERMS_OF_SERVICE = [string] [EOL] app . config . API_PRODUCES_CONTENT_TYPES = [ [string] ] [EOL] app . config . API_CONTACT_EMAIL = [string] [EOL] [EOL] @ app . post ( [string] ) @ doc . summary ( [string] ) async def executeWorkflow ( request ) : [EOL] [EOL] [docstring] [EOL] workflow_spec = request . json [ [string] ] [EOL] logger . debug ( f" [string] " ) [EOL] [EOL] [docstring] [EOL] executor = AsyncioExecutor ( workflow = Workflow ( spec = workflow_spec , inputs = request . json [ [string] ] ) ) [EOL] [EOL] [docstring] [EOL] return json ( await executor . execute ( ) ) [EOL] [EOL] def workaround_sanic_openapi_naming_issue ( ) : [EOL] [docstring] [EOL] n = { } [EOL] for k , v in app . router . routes_all . items ( ) : [EOL] if k [ : - [number] ] in n or f"{ k } [string] " in n : [EOL] continue [EOL] n [ k ] = v [EOL] app . router . routes_all = n [EOL] workaround_sanic_openapi_naming_issue ( ) [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] LoggingUtil . setup_logging ( ) [EOL] [EOL] [docstring] [EOL] arg_parser = argparse . ArgumentParser ( description = [string] , formatter_class = lambda prog : argparse . HelpFormatter ( prog , max_help_position = [number] ) ) [EOL] arg_parser . add_argument ( [string] , [string] , help = [string] , action = [string] ) [EOL] arg_parser . add_argument ( [string] , [string] , help = [string] , default = [string] ) [EOL] arg_parser . add_argument ( [string] , help = [string] , default = [string] ) [EOL] arg_parser . add_argument ( [string] , help = [string] , type = int , default = [number] ) [EOL] args = arg_parser . parse_args ( ) [EOL] [EOL] [docstring] [EOL] app . run ( host = args . host , port = args . port , debug = args . debug , workers = args . workers ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0
from typing import Any [EOL] import ros [EOL] import typing [EOL] import json [EOL] import pytest [EOL] from ros . kgraph import Neo4JKnowledgeGraph [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def graph ( ) : [EOL] [docstring] [EOL] g = Neo4JKnowledgeGraph ( ) [EOL] g . delete ( ) [EOL] return g [EOL] [EOL] def test_add_node ( graph ) : [EOL] [docstring] [EOL] graph . add_node ( label = [string] , props = { [string] : [string] , [string] : [string] } ) [EOL] graph . add_node ( label = [string] , props = { [string] : [string] , [string] : [string] } ) [EOL] [EOL] result = graph . query ( [string] ) [EOL] print ( result ) [EOL] assert len ( result ) == [number] [EOL] assert result [ [number] ] [ [string] ] == [string] [EOL] [EOL] result = graph . query ( [string] ) [EOL] assert len ( result ) == [number] [EOL] assert result [ [number] ] [ [string] ] == [string] [EOL] [EOL] def test_add_edge ( graph ) : [EOL] [docstring] [EOL] n0 = graph . add_node ( label = [string] , props = { [string] : [string] , [string] : [string] } ) [EOL] n1 = graph . add_node ( label = [string] , props = { [string] : [string] , [string] : [string] } ) [EOL] for x in range ( [number] , [number] ) : [EOL] n = graph . add_node ( label = [string] , props = { [string] : str ( x ) , [string] : [string] } ) [EOL] [EOL] [docstring] [EOL] graph . add_edge ( n0 [ [string] ] , [string] , n1 [ [string] ] , props = { [string] : [string] , [string] : [number] , [string] : [number] } ) [EOL] graph . commit ( ) [EOL] [EOL] result = graph . query ( [string] ) [EOL] print ( result ) [EOL] assert len ( result ) == [number] [EOL] assert result [ [number] ] [ [string] ] == [string] [EOL] [EOL] graph . delete ( ) [EOL] [EOL] def test_delete ( graph ) : [EOL] graph . delete ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import ros [EOL] import typing [EOL] import json [EOL] import os [EOL] import pytest [EOL] from ros . util import Context [EOL] from ros . util import MaQ [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def maq ( ) : [EOL] return MaQ ( ) [EOL] [EOL] def test_gen_query_many_to_one ( maq ) : [EOL] context = Context ( ) [EOL] questions = maq . parse ( [string] , context ) [EOL] drugs = context . resolve_arg ( [string] ) [EOL] disease = context . resolve_arg ( [string] ) [EOL] [EOL] for d in drugs : [EOL] found = False [EOL] for q in questions : [EOL] for node in q [ [string] ] [ [string] ] : [EOL] found = node [ [string] ] == d [EOL] if found : [EOL] assert node [ [string] ] == [string] , [string] [EOL] break [EOL] if found : [EOL] break [EOL] if found : [EOL] break [EOL] [EOL] def test_gen_query_many_to_many ( maq ) : [EOL] context = Context ( ) [EOL] questions = maq . parse ( [string] , context ) [EOL] drugs = context . resolve_arg ( [string] ) [EOL] diseases = context . resolve_arg ( [string] ) [EOL] [EOL] for drug in drugs : [EOL] for disease in diseases : [EOL] drug_found = False [EOL] disease_found = False [EOL] for q in questions : [EOL] nodes = q [ [string] ] [ [string] ] [EOL] drug_found = any ( map ( lambda n : n [ [string] ] == drug if [string] in n else False , nodes ) ) [EOL] disease_found = any ( map ( lambda n : n [ [string] ] == disease if [string] in n else False , nodes ) ) [EOL] if drug_found and disease_found : [EOL] break [EOL] if not ( drug_found and disease_found ) : [EOL] raise ValueError ( f" [string] { drug } [string] { disease }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import ros [EOL] import typing [EOL] import json [EOL] import pytest [EOL] from networkx . readwrite import json_graph [EOL] from jsonpath_rw import jsonpath , parse [EOL] from ros . graph import TranslatorGraphTools [EOL] from ros . kgraph import KnowledgeGraph [EOL] from ros . kgraph import Neo4JKnowledgeGraph [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def graph_tools ( ) : [EOL] return TranslatorGraphTools ( ) [EOL] [EOL] def test_from_file ( graph_tools ) : [EOL] graph = graph_tools . from_file ( [string] ) [EOL] [EOL] jsonpath_query = parse ( [string] ) [EOL] nodes = [ match . value for match in jsonpath_query . find ( graph ) ] [EOL] print ( f" [string] { nodes [ [number] ] }" ) [EOL] assert nodes [ [number] ] [ [string] ] == [string] [EOL] assert len ( nodes ) == [number] [EOL] [EOL] jsonpath_query = parse ( [string] ) [EOL] edges = [ match . value for match in jsonpath_query . find ( graph ) ] [EOL] edge = edges [ [number] ] [EOL] assert edge [ [string] ] == [string] [EOL] assert edge [ [string] ] == [string] [EOL] assert edge [ [string] ] == [string] [EOL] assert edge [ [string] ] == [string] [EOL] assert edge [ [string] ] == [string] [EOL] assert len ( edges ) == [number] [EOL] [EOL] def test_file_to_nx ( graph_tools ) : [EOL] g = graph_tools . file_to_nx ( [string] ) [EOL] data = json_graph . node_link_data ( g ) [EOL] print ( f" [string] { data [ [string] ] [ [number] ] [ [string] ] }" ) [EOL] assert data [ [string] ] [ [number] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] def test_file_to_d3_json ( graph_tools ) : [EOL] g = graph_tools . file_to_d3_json ( [string] ) [EOL] print ( f" [string] { len ( g [ [string] ] ) }" ) [EOL] assert g [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] def test_create_node ( graph_tools ) : [EOL] knowledge = Neo4JKnowledgeGraph ( ) [EOL] result = knowledge . add_node ( label = [string] , props = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] response = knowledge . query ( [string] , nodes = [ [string] ] ) [EOL] print ( response [ [number] ] ) [EOL] assert response [ [number] ] [ [string] ] == [string] [EOL] assert response [ [number] ] [ [string] ] == [string] [EOL] assert response [ [number] ] [ [string] ] == [string] [EOL] [EOL] def test_create_edge ( graph_tools ) : [EOL] knowledge = Neo4JKnowledgeGraph ( ) [EOL] node1 = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] node2 = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] result = knowledge . add_node ( label = [string] , props = node1 ) [EOL] result = knowledge . add_node ( label = [string] , props = node2 ) [EOL] knowledge . add_edge ( subj = [string] , pred = [string] , obj = [string] , props = { [string] : [string] } ) [EOL] response = knowledge . query ( [string] ) [EOL] [EOL] print ( response ) [EOL] assert response [ [number] ] [ [string] ] == [string] [EOL] assert response [ [number] ] [ [string] ] == [string] [EOL] assert response [ [number] ] [ [string] ] == [string] [EOL] [EOL] def test_to_knowledge_graph ( graph_tools ) : [EOL] knowledge = Neo4JKnowledgeGraph ( ) [EOL] graph_tools . to_knowledge_graph ( in_graph = graph_tools . file_to_nx ( [string] ) , out_graph = knowledge ) [EOL] result = knowledge . query ( [string] , nodes = [ [string] ] ) [EOL] assert any ( [ r [ [string] ] == [string] for r in result ] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import ros [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] import json [EOL] import os [EOL] import pytest [EOL] from ros . workflow import Workflow [EOL] from ros . app import AsyncioExecutor [EOL] [EOL] def execute_workflow ( workflow ) : [EOL] executor = AsyncioExecutor ( workflow = workflow ) [EOL] tasks = [ asyncio . ensure_future ( executor . execute ( ) ) ] [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( asyncio . wait ( tasks ) ) [EOL] return tasks [ [number] ] . result ( ) [EOL] [EOL] def run_local_flow ( path , inputs ) : [EOL] workflow_path = os . path . join ( os . path . dirname ( __file__ ) , path ) [EOL] workflow = Workflow ( spec = workflow_path , inputs = inputs ) [EOL] execute_workflow ( workflow ) [EOL] [EOL] def test_http ( ) : [EOL] run_local_flow ( path = [string] , inputs = { [string] : [ [string] ] , [string] : [ [string] ] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import json [EOL] import os [EOL] import pytest [EOL] from ros . util import Syfur [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def syfur ( ) : [EOL] return Syfur ( ) [EOL] [EOL] def test_no_parameters ( syfur ) : [EOL] query = [string] [EOL] expect = [string] [EOL] assert syfur . parse ( query ) == expect , f" [string] { query }" [EOL] [EOL] def test_multiple_parameters ( syfur ) : [EOL] query = [string] [EOL] expect = [string] [EOL] assert syfur . parse ( query ) == expect , f" [string] { query }" [EOL] [EOL] def test_one_parameter ( syfur ) : [EOL] query = [string] [EOL] expect = [string] [EOL] assert syfur . parse ( query ) == expect , f" [string] { query }" [EOL] [EOL] def test_catch_delete ( syfur ) : [EOL] query = [string] [EOL] success = False [EOL] try : [EOL] syfur . parse ( query ) [EOL] except : [EOL] success = True [EOL] assert success , [string] [EOL] [EOL] def test_catch_delete ( syfur ) : [EOL] query = [string] [EOL] success = False [EOL] try : [EOL] syfur . parse ( query ) [EOL] except : [EOL] success = True [EOL] assert success , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import ros [EOL] import typing [EOL] import json [EOL] import pytest [EOL] from ros . tranql import TranQL [EOL] [EOL] def test_set ( ) : [EOL] tranql = TranQL ( ) [EOL] tranql . execute ( [string] ) [EOL] [EOL] variables = [ [string] , [string] , [string] , [string] , [string] ] [EOL] output = { k : tranql . context . resolve_arg ( f" [string] { k }" ) for k in variables } [EOL] print ( f" [string] { json . dumps ( output , indent = [number] ) }" ) [EOL] assert output [ [string] ] == [string] [EOL] assert output [ [string] ] == [string] [EOL] [EOL] [EOL] def test_tranql ( ) : [EOL] tranql = TranQL ( ) [EOL] tranql . execute ( [string] ) [EOL] expos = tranql . context . resolve_arg ( [string] ) [EOL] print ( f" [string] { json . dumps ( expos ) }" ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import json [EOL] import os [EOL] import pytest [EOL] from ros . config import Config [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def config ( ) : [EOL] return Config ( [string] ) [EOL] [EOL] def test_config ( config ) : [EOL] assert config [ [string] ] == os . environ [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Union , Any , List [EOL] import typing [EOL] import json [EOL] import requests [EOL] [EOL] questions = { [string] : { [string] : [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } ] } , [string] : { [string] : { [string] : [ { [string] : [number] , [string] : [number] } ] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } ] } } , [string] : { [string] : [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } ] } , [string] : { [string] : { [string] : [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } ] } } , [string] : { [string] : { [string] : [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } ] } } } [EOL] [EOL] url = [string] [EOL] [EOL] def answer ( url , question ) : [EOL] return requests . post ( url = url , headers = { [string] : [string] , [string] : [string] } , json = question ) . json ( ) [EOL] [EOL] def answer_all ( url ) : [EOL] for name , question in questions . items ( ) : [EOL] obj = answer ( url , question ) [EOL] print ( f"{ name } [string] { len ( obj ) }" ) [EOL] with open ( f"{ name } [string] " , [string] ) as stream : [EOL] stream . write ( json . dumps ( obj , indent = [number] ) ) [EOL] [EOL] def answer_named ( url , name ) : [EOL] obj = answer ( url , questions [ name ] ) [EOL] print ( f"{ name } [string] { len ( obj ) }" ) [EOL] [EOL] answer_named ( url , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Any [EOL] import ros [EOL] import typing [EOL] from __future__ import absolute_import [EOL] import json [EOL] import time [EOL] [comment] [EOL] from ros . workflow import Workflow [EOL] from ros . router import Router [EOL] [EOL] def json2workflow ( json ) : [EOL] model = Workflow ( spec = { [string] : [string] } ) [EOL] model . uuid = json [ [string] ] [EOL] model . spec = json [ [string] ] [EOL] model . inputs = json [ [string] ] [EOL] model . dependencies = json [ [string] ] [EOL] model . topsort = json [ [string] ] [EOL] model . running = json [ [string] ] [EOL] model . failed = json [ [string] ] [EOL] model . done = json [ [string] ] [EOL] return model [EOL] [EOL] [docstring] [EOL] [EOL] def exec_operator ( model , job_name ) : [EOL] result = None [EOL] wf = json2workflow ( model ) [EOL] op_node = wf . spec . get ( [string] , { } ) . get ( job_name , { } ) [EOL] if op_node : [EOL] router = Router ( wf ) [EOL] result = router . route ( wf , job_name , op_node , op_node [ [string] ] , op_node [ [string] ] ) [EOL] wf . set_result ( job_name , result ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] app_name = os . environ [ [string] ] [EOL] celery_app_package = os . environ [ [string] ] [EOL] celery_broker_url = os . environ [ [string] ] [EOL] celery_result_backend = os . environ [ [string] ] [EOL] [EOL] results_host = os . environ [ [string] ] [EOL] results_port = os . environ [ [string] ] [EOL] [EOL] robokop_builder_build_url = os . environ [ [string] ] [EOL] robokop_builder_task_status_url = os . environ [ [string] ] [EOL] [EOL] robokop_ranker_result_url = os . environ [ [string] ] [EOL] robokop_ranker_now_url = os . environ [ [string] ] [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import flask [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import yaml [EOL] import jsonschema [EOL] from flask import Flask , request , abort , Response [EOL] from flask_restful import Api , Resource [EOL] from flasgger import Swagger [EOL] from flask_cors import CORS [EOL] [EOL] app = Flask ( __name__ ) [EOL] [EOL] api = Api ( app ) [EOL] CORS ( app ) [EOL] [EOL] filename = [string] [EOL] with open ( filename , [string] ) as file_obj : [EOL] template = yaml . load ( file_obj ) [EOL] app . config [ [string] ] = { [string] : [string] , [string] : [number] } [EOL] swagger = Swagger ( app , template = template ) [EOL] [EOL] [EOL] class Validate ( Resource ) : [EOL] [docstring] [EOL] [EOL] def post ( self ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as file_obj : [EOL] specs = yaml . load ( file_obj ) [EOL] to_validate = specs [ [string] ] [ [string] ] [EOL] to_validate [ [string] ] = specs [ [string] ] [EOL] to_validate [ [string] ] . pop ( [string] , None ) [EOL] try : [EOL] jsonschema . validate ( request . json , to_validate ) [EOL] except jsonschema . exceptions . ValidationError as error : [EOL] abort ( Response ( str ( error ) , [number] ) ) [EOL] return [string] , [number] [EOL] [EOL] api . add_resource ( Validate , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , default = [number] , type = int ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] server_host = [string] [EOL] server_port = args . port [EOL] [EOL] app . run ( host = server_host , port = server_port , debug = False , use_reloader = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 0 0 0 $flask.app.Flask$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import requests [EOL] import flask [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import json [EOL] import yaml [EOL] import jsonschema [EOL] import requests [EOL] from flask import Flask , request , abort , Response [EOL] from flask_restful import Api , Resource [EOL] from flasgger import Swagger [EOL] from flask_cors import CORS [EOL] [EOL] app = Flask ( __name__ ) [EOL] [EOL] api = Api ( app ) [EOL] CORS ( app ) [EOL] [EOL] filename = [string] [EOL] with open ( filename , [string] ) as file_obj : [EOL] template = yaml . load ( file_obj ) [EOL] app . config [ [string] ] = { [string] : [string] , [string] : [number] } [EOL] swagger = Swagger ( app , template = template ) [EOL] [EOL] obj = None [EOL] [EOL] class WF1Mod2And3 ( Resource ) : [EOL] [docstring] [EOL] [EOL] def workflow_1_modules_1_and_2 ( self , diseases ) : [EOL] url_str = [string] [EOL] [EOL] doids = { } [EOL] for d in diseases : [EOL] syns = requests . get ( f" [string] { d [ [string] ] } [string] " ) . json ( ) [EOL] for syn in syns : [EOL] for s in syn [ [string] ] : [EOL] if s . startswith ( [string] ) : [EOL] doids [ s ] = s [EOL] disease_id = [ d for d in doids . keys ( ) ] [ [number] ] [EOL] [EOL] [docstring] [EOL] if disease_id is not None : [EOL] response = requests . post ( url = url_str , json = { [string] : [string] , [string] : { [string] : disease_id } } , headers = { [string] : [string] } ) [EOL] status_code = response . status_code [EOL] assert status_code == [number] [EOL] [EOL] return response . json ( ) if response else None [EOL] [EOL] def post ( self ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as file_obj : [EOL] specs = yaml . load ( file_obj ) [EOL] to_validate = specs [ [string] ] [ [string] ] [EOL] to_validate [ [string] ] = specs [ [string] ] [EOL] to_validate [ [string] ] . pop ( [string] , None ) [EOL] try : [EOL] jsonschema . validate ( request . json , to_validate ) [EOL] except jsonschema . exceptions . ValidationError as error : [EOL] abort ( Response ( str ( error ) , [number] ) ) [EOL] [EOL] print ( f"{ json . dumps ( request . json , indent = [number] ) }" ) [EOL] [docstring] [EOL] inputs = request . json [ [string] ] [ [string] ] [EOL] print ( f" [string] { inputs }" ) [EOL] knowledge_graph = self . workflow_1_modules_1_and_2 ( inputs ) [EOL] print ( f" [string] { json . dumps ( knowledge_graph , indent = [number] ) }" ) [EOL] return knowledge_graph , [number] [EOL] [EOL] api . add_resource ( WF1Mod2And3 , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , default = [number] , type = int ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] server_host = [string] [EOL] server_port = args . port [EOL] [EOL] app . run ( host = server_host , port = server_port , debug = False , use_reloader = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 0 0 0 $flask.app.Flask$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $requests.models.Response$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Set , Any [EOL] import flask [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import json [EOL] import yaml [EOL] import jsonschema [EOL] import requests [EOL] from flask import Flask , request , abort , Response [EOL] from flask_restful import Api , Resource [EOL] from flasgger import Swagger [EOL] from flask_cors import CORS [EOL] from jsonpath_rw import parse [EOL] [EOL] app = Flask ( __name__ ) [EOL] [EOL] api = Api ( app ) [EOL] CORS ( app ) [EOL] [EOL] filename = [string] [EOL] with open ( filename , [string] ) as file_obj : [EOL] template = yaml . load ( file_obj ) [EOL] app . config [ [string] ] = { [string] : [string] , [string] : [number] } [EOL] swagger = Swagger ( app , template = template ) [EOL] [EOL] obj = None [EOL] [EOL] [EOL] class JSONKit : [EOL] [EOL] [docstring] [EOL] @ staticmethod def select ( query , obj ) : [EOL] [docstring] [EOL] jsonpath_query = parse ( query ) [EOL] return [ match . value for match in jsonpath_query . find ( obj ) ] [EOL] [EOL] class WF1Mod3 ( Resource ) : [EOL] [docstring] [EOL] [EOL] def kgs ( self , nodes = [ ] , edges = [ ] ) : [EOL] [docstring] [EOL] return [ { [string] : [ { [string] : { [string] : nodes , [string] : edges } } ] } ] [EOL] [EOL] def workflow_1_module_3 ( self , diseases ) : [EOL] return [ { [string] : a [ [number] ] , [string] : a [ [number] ] , [string] : [string] , [string] : [string] } for disease in diseases for s in self . get_genetic_versions ( disease [ [string] ] ) ] [EOL] [EOL] [docstring] [EOL] def get_genetic_versions ( disease ) : [EOL] [EOL] [comment] [EOL] GENETIC_DISEASE = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] durl = f' [string] { disease }' [EOL] response = requests . get ( durl ) . json ( ) [EOL] genetic_set = set ( ) [EOL] for newmondo in response [ [string] ] : [EOL] for gd in GENETIC_DISEASE : [EOL] gurl = f' [string] { newmondo } [string] { gd } [string] ' [EOL] gresponse = requests . get ( gurl ) . json ( ) [EOL] if gresponse [ [string] ] : [EOL] lurl = f' [string] { newmondo } [string] ' [EOL] lresponse = requests . get ( lurl ) . json ( ) [EOL] label = lresponse [ [string] ] [EOL] genetic_set . add ( ( newmondo , label ) ) [EOL] return genetic_set [EOL] [EOL] def post ( self ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as file_obj : [EOL] specs = yaml . load ( file_obj ) [EOL] to_validate = specs [ [string] ] [ [string] ] [EOL] to_validate [ [string] ] = specs [ [string] ] [EOL] to_validate [ [string] ] . pop ( [string] , None ) [EOL] try : [EOL] jsonschema . validate ( request . json , to_validate ) [EOL] except jsonschema . exceptions . ValidationError as error : [EOL] abort ( Response ( str ( error ) , [number] ) ) [EOL] [EOL] inputs = request . json [ [string] ] [ [string] ] [EOL] print ( f" [string] { inputs }" ) [EOL] knowledge_graph = self . kgs ( nodes = self . workflow_1_module_3 ( inputs ) ) [EOL] print ( f" [string] { json . dumps ( knowledge_graph , indent = [number] ) }" ) [EOL] return knowledge_graph , [number] [EOL] [EOL] api . add_resource ( WF1Mod3 , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , default = [number] , type = int ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] server_host = [string] [EOL] server_port = args . port [EOL] [EOL] app . run ( host = server_host , port = server_port , debug = False , use_reloader = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 0 0 0 $flask.app.Flask$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Set , Any [EOL] import flask [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import json [EOL] import yaml [EOL] import jsonschema [EOL] import requests [EOL] from flask import Flask , request , abort , Response [EOL] from flask_restful import Api , Resource [EOL] from flasgger import Swagger [EOL] from flask_cors import CORS [EOL] [EOL] app = Flask ( __name__ ) [EOL] [EOL] api = Api ( app ) [EOL] CORS ( app ) [EOL] [EOL] filename = [string] [EOL] with open ( filename , [string] ) as file_obj : [EOL] template = yaml . load ( file_obj ) [EOL] app . config [ [string] ] = { [string] : [string] , [string] : [number] } [EOL] swagger = Swagger ( app , template = template ) [EOL] [EOL] response = None [EOL] [EOL] class WF1Mod1 ( Resource ) : [EOL] [docstring] [EOL] [EOL] def get_genetic_versions ( self , disease ) : [EOL] [comment] [EOL] GENETIC_DISEASE = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] durl = f' [string] { disease }' [EOL] print ( f" [string] { durl }" ) [EOL] response = requests . get ( durl ) . json ( ) [EOL] genetic_set = set ( ) [EOL] for newmondo in response [ [string] ] : [EOL] for gd in GENETIC_DISEASE : [EOL] gurl = f' [string] { newmondo } [string] { gd } [string] ' [EOL] print ( gurl ) [EOL] gresponse = requests . get ( gurl ) . json ( ) [EOL] if gresponse [ [string] ] : [EOL] lurl = f' [string] { newmondo } [string] ' [EOL] lresponse = requests . get ( lurl ) . json ( ) [EOL] label = lresponse [ [string] ] [EOL] genetic_set . add ( ( newmondo , label ) ) [EOL] return genetic_set [EOL] [EOL] def workflow_1_module_1 ( self , diseases ) : [EOL] result = [ ] [EOL] s = [ ] [EOL] for disease in diseases : [EOL] s = s + list ( self . get_genetic_versions ( disease [ [string] ] ) ) [EOL] return [ { [string] : d [ [number] ] , [string] : d [ [number] ] , [string] : [string] } for d in s ] [EOL] [EOL] def post ( self ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as file_obj : [EOL] specs = yaml . load ( file_obj ) [EOL] to_validate = specs [ [string] ] [ [string] ] [EOL] to_validate [ [string] ] = specs [ [string] ] [EOL] to_validate [ [string] ] . pop ( [string] , None ) [EOL] try : [EOL] jsonschema . validate ( request . json , to_validate ) [EOL] except jsonschema . exceptions . ValidationError as error : [EOL] abort ( Response ( str ( error ) , [number] ) ) [EOL] [EOL] print ( f"{ json . dumps ( request . json , indent = [number] ) }" ) [EOL] [EOL] inputs = request . json [ [string] ] [ [string] ] [EOL] print ( f" [string] { inputs }" ) [EOL] global response [EOL] if response : [EOL] knowledge_graph = response [EOL] else : [EOL] knowledge_graph = self . workflow_1_module_1 ( inputs ) [EOL] response = knowledge_graph [EOL] [EOL] print ( f" [string] { json . dumps ( knowledge_graph , indent = [number] ) }" ) [EOL] return { [string] : { } , [string] : knowledge_graph , [string] : { } } , [number] [EOL] [EOL] api . add_resource ( WF1Mod1 , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , default = [number] , type = int ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] server_host = [string] [EOL] server_port = args . port [EOL] [EOL] app . run ( host = server_host , port = server_port , debug = False , use_reloader = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 0 0 0 $flask.app.Flask$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import flask [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import json [EOL] import os [EOL] import yaml [EOL] import jsonschema [EOL] import requests [EOL] from flask import Flask , request , abort , Response [EOL] from flask_restful import Api , Resource [EOL] from flasgger import Swagger [EOL] from flask_cors import CORS [EOL] from iceesclient import ICEES [EOL] [EOL] app = Flask ( __name__ ) [EOL] [EOL] api = Api ( app ) [EOL] CORS ( app ) [EOL] [EOL] filename = [string] [EOL] with open ( filename , [string] ) as file_obj : [EOL] template = yaml . load ( file_obj ) [EOL] app . config [ [string] ] = { [string] : [string] , [string] : [number] } [EOL] swagger = Swagger ( app , template = template ) [EOL] [EOL] class ICEES_EstResidentialDensity_Query ( Resource ) : [EOL] [docstring] [EOL] [EOL] def post ( self ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as file_obj : [EOL] specs = yaml . load ( file_obj ) [EOL] to_validate = specs [ [string] ] [ [string] ] [EOL] to_validate [ [string] ] = specs [ [string] ] [EOL] to_validate [ [string] ] . pop ( [string] , None ) [EOL] [comment] [EOL] try : [EOL] jsonschema . validate ( request . json , to_validate ) [EOL] except jsonschema . exceptions . ValidationError as error : [EOL] print ( f" [string] { str ( error ) }" ) [EOL] abort ( Response ( str ( error ) , [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] cohort_id = [string] [EOL] feature_id = [string] [EOL] value = [string] [EOL] operator = [string] [EOL] max_p_val = [string] [EOL] [EOL] icees = ICEES ( ) [EOL] correlation = None [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] correlation = icees . feature_to_all_features ( feature = feature_id , value = value , operator = operator , max_p_val = max_p_val , cohort_id = cohort_id ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] with open ( [string] , [string] ) as stream : [EOL] json . dump ( correlation , stream , indent = [number] ) [EOL] [EOL] graph = icees . parse_1_x_N ( correlation ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] knowledge_graph = graph [EOL] [comment] [EOL] return knowledge_graph [EOL] [docstring] [EOL] [EOL] api . add_resource ( ICEES_EstResidentialDensity_Query , [string] ) [EOL] [EOL] class ICEES_TotalEDInpatientVisits_Query ( Resource ) : [EOL] [docstring] [EOL] [EOL] def post ( self ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as file_obj : [EOL] specs = yaml . load ( file_obj ) [EOL] to_validate = specs [ [string] ] [ [string] ] [EOL] to_validate [ [string] ] = specs [ [string] ] [EOL] to_validate [ [string] ] . pop ( [string] , None ) [EOL] [comment] [EOL] try : [EOL] jsonschema . validate ( request . json , to_validate ) [EOL] except jsonschema . exceptions . ValidationError as error : [EOL] print ( f" [string] { str ( error ) }" ) [EOL] abort ( Response ( str ( error ) , [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] cohort_id = [string] [EOL] feature_id = [string] [EOL] value = [string] [EOL] operator = [string] [EOL] max_p_val = [string] [EOL] [EOL] icees = ICEES ( ) [EOL] correlation = None [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] correlation = icees . feature_to_all_features ( feature = feature_id , value = value , operator = operator , max_p_val = max_p_val , cohort_id = cohort_id ) [EOL] [EOL] [EOL] with open ( [string] , [string] ) as stream : [EOL] json . dump ( correlation , stream , indent = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] graph = icees . parse_1_x_N ( correlation ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] knowledge_graph = graph [EOL] [comment] [EOL] return knowledge_graph [EOL] [docstring] [EOL] [EOL] api . add_resource ( ICEES_TotalEDInpatientVisits_Query , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , default = [number] , type = int ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] server_host = [string] [EOL] server_port = args . port [EOL] [EOL] app . run ( host = server_host , port = server_port , debug = False , use_reloader = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 0 0 0 $flask.app.Flask$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import argparse [EOL] import requests [EOL] import typing [EOL] import ros [EOL] import logging [EOL] import requests [EOL] import json [EOL] import argparse [EOL] import logging [EOL] requests . packages . urllib3 . disable_warnings ( ) [EOL] [EOL] tabular_headers = { [string] : [string] , [string] : [string] } [EOL] json_headers = { [string] : [string] , [string] : [string] } [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] class FeatureFilter : [EOL] [EOL] def __init__ ( self , feature , value , operator ) : [EOL] self . feature = feature [EOL] self . value = value [EOL] self . operator = operator [EOL] [EOL] class Bionames : [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . url = [string] [EOL] [EOL] def get_ids ( self , name , type_name ) : [EOL] url = self . url . format ( ** { [string] : name , [string] : type_name } ) [EOL] logger . debug ( f" [string] { url }" ) [EOL] result = None [EOL] response = requests . get ( url = url , headers = { [string] : [string] } ) [EOL] if response . status_code == [number] or response . status_code == [number] : [EOL] result = response . json ( ) [EOL] else : [EOL] raise ValueError ( response . text ) [EOL] logger . debug ( f" [string] { result }" ) [EOL] return result [EOL] [EOL] class ICEES : [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . bionames = Bionames ( ) [EOL] self . drug_suffix = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . drug_names = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [comment] [EOL] self . def_cohort = DefineCohort ( ) [EOL] self . all_features = AssociationToAllFeatures ( ) [EOL] [EOL] def get_cohort ( self , feature , value , operator ) : [EOL] [docstring] [EOL] return self . run_define_cohort ( feature , value , operator ) [EOL] [EOL] def feature_to_all_features ( self , feature , value , operator , max_p_val , cohort_id ) : [EOL] [docstring] [EOL] return self . all_features . run_association_to_all_features ( feature = feature , value = value , operator = operator , maximum_p_value = max_p_val , cohort_id = cohort_id ) [EOL] [EOL] def parse_1_x_N ( self , response ) : [EOL] asthma_id = [string] [EOL] nodes = [ { [string] : asthma_id , [string] : [string] } ] [EOL] edges = [ ] [EOL] if [string] in response : [EOL] for value in response [ [string] ] : [EOL] logger . debug ( f" [string] { value }" ) [EOL] if [string] in value : [EOL] feature_name = value [ [string] ] . get ( [string] , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] logger . debug ( f" [string] { feature_name }" ) [EOL] if feature_name and any ( [ v for v in self . drug_suffix if feature_name . endswith ( v ) ] ) : [EOL] chem_type = [string] [EOL] ids = self . bionames . get_ids ( feature_name , type_name = chem_type ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] if len ( ids ) > [number] : [EOL] logger . debug ( f" [string] { feature_name } [string] { ids }" ) [EOL] for v in ids : [EOL] v [ [string] ] = v [ [string] ] [EOL] del v [ [string] ] [EOL] v [ [string] ] = chem_type [EOL] edges . append ( { [string] : [string] , [string] : v [ [string] ] , [string] : asthma_id , [string] : { [string] : value [ [string] ] } } ) [EOL] nodes = nodes + ids [EOL] return { [string] : nodes , [string] : edges } [EOL] [EOL] class DefineCohort ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def make_cohort_definition ( self , feature , value , operator ) : [EOL] feature_variables = [string] . format ( feature , value , operator ) [EOL] return feature_variables [EOL] [EOL] def define_cohort_query ( self , feature_variables , year = [number] , table = [string] , version = [string] ) : [comment] [EOL] define_cohort_response = requests . post ( [string] . format ( version , table , year ) , data = feature_variables , headers = json_headers , verify = False ) [EOL] return define_cohort_response [EOL] [EOL] def run_define_cohort ( self , feature , value , operator ) : [EOL] feature_variables = self . make_cohort_definition ( feature , value , operator ) [EOL] define_cohort_query = self . define_cohort_query ( feature_variables ) [EOL] define_cohort_query_json = define_cohort_query . json ( ) [EOL] return define_cohort_query_json [EOL] [EOL] class GetCohortDefinition ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def get_cohort_definition_query ( self , cohort_id , year = [number] , table = [string] , version = [string] ) : [EOL] cohort_definition_response = requests . get ( [string] . format ( version , table , year , cohort_id ) , headers = json_headers , verify = False ) [EOL] return cohort_definition_response [EOL] [EOL] def run_get_cohort_definition ( self , cohort_id ) : [EOL] cohort_definition_query = self . get_cohort_definition_query ( cohort_id ) [EOL] cohort_definition_query_json = cohort_definition_query . json ( ) [EOL] return cohort_definition_query_json [EOL] [EOL] class GetFeatures ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def get_features_query ( self , cohort_id , year = [number] , table = [string] , version = [string] ) : [EOL] features_response = requests . get ( [string] . format ( version , table , year , cohort_id ) , headers = json_headers , verify = False ) [EOL] return features_response [EOL] [EOL] def run_get_features ( self , cohort_id ) : [EOL] features_query = self . get_features_query ( cohort_id ) [EOL] features_query_json = features_query . json ( ) [EOL] return features_query_json [EOL] [EOL] class FeatureAssociation ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] class AssociationToAllFeatures ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def make_association_to_all_features ( self , feature , value , operator , maximum_p_value ) : [EOL] feature_variable_and_p_value = [string] . format ( feature , value , operator , maximum_p_value ) [EOL] return feature_variable_and_p_value [EOL] [EOL] def assocation_to_all_features_query ( self , feature_variable_and_p_value , cohort_id , year = [number] , table = [string] , version = [string] ) : [EOL] assoc_to_all_features_response = requests . post ( [string] . format ( version , table , year , cohort_id ) , data = feature_variable_and_p_value , headers = json_headers , verify = False ) [EOL] return assoc_to_all_features_response [EOL] [EOL] def run_association_to_all_features ( self , feature , value , operator , maximum_p_value , cohort_id ) : [EOL] feature_variable_and_p_value = self . make_association_to_all_features ( feature , value , operator , maximum_p_value ) [EOL] print ( json . dumps ( feature_variable_and_p_value , indent = [number] ) ) [EOL] print ( json . dumps ( json . loads ( feature_variable_and_p_value ) , indent = [number] ) ) [EOL] assoc_to_all_features_query = self . assocation_to_all_features_query ( feature_variable_and_p_value , cohort_id ) [EOL] assoc_to_all_features_query_json = assoc_to_all_features_query . json ( ) [EOL] return assoc_to_all_features_query_json [EOL] [EOL] class GetDictionary ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def get_dictionary_query ( self , year = [number] , table = [string] , version = [string] ) : [EOL] dictionary_response = requests . get ( [string] . format ( version , table , year ) , headers = json_headers , verify = False ) [EOL] return dictionary_response [EOL] [EOL] def run_get_dictionary ( self ) : [EOL] dictionary_query = self . get_dictionary_query ( ) [EOL] dictionary_query_json = dictionary_query . json ( ) [EOL] return dictionary_query_json [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] if __name__ == [string] : [EOL] import sys [EOL] if len ( sys . argv ) > [number] : [EOL] icees_define_cohort = DefineCohort ( ) [EOL] output = icees_define_cohort . run_define_cohort ( args . feature , args . value , args . operator ) [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( output [ [string] ] ) [EOL] print ( ) [EOL] else : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.wf5.ks_apis.icees.iceesclient.Bionames$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.wf5.ks_apis.icees.iceesclient.DefineCohort$ 0 0 0 0 0 0 0 $ros.wf5.ks_apis.icees.iceesclient.AssociationToAllFeatures$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ros.wf5.ks_apis.icees.iceesclient.DefineCohort$ 0 0 0 0 0 $typing.Any$ 0 $ros.wf5.ks_apis.icees.iceesclient.DefineCohort$ 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any , Tuple , Set [EOL] import logging [EOL] import typing [EOL] import os [EOL] import logging [EOL] import logging . handlers [EOL] import math [EOL] import json [EOL] import sys [EOL] import pickle [EOL] import base64 [EOL] import binascii [EOL] import numpy as np [EOL] from ndex2cx . nice_cx_builder import NiceCXBuilder [EOL] [EOL] root = os . path . dirname ( os . path . dirname ( os . path . realpath ( __file__ ) ) ) [EOL] log_path = os . path . join ( root , [string] ) [EOL] if not os . path . exists ( log_path ) : [EOL] try : [EOL] os . makedirs ( log_path ) [EOL] except : [EOL] print ( [string] ) [EOL] [EOL] [EOL] node_id_lookup = { } [EOL] edge_id_counter = [number] [EOL] [EOL] [EOL] def get_logger ( name , level = logging . DEBUG ) : [EOL] logger = logging . getLogger ( name ) [EOL] logger . setLevel ( level ) [EOL] [EOL] logger . handlers = [ ] [EOL] [EOL] formatter = logging . Formatter ( [string] + name + [string] , [string] ) [EOL] [EOL] handler = logging . handlers . TimedRotatingFileHandler ( os . path . join ( log_path , [string] ) , when = [string] , backupCount = [number] ) [EOL] handler . setFormatter ( formatter ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] handler = logging . StreamHandler ( ) [EOL] handler . setFormatter ( formatter ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] return logger [EOL] [EOL] [EOL] def load_matrix_to_ndex ( x , x_cols , x_rows , server , username , password , name ) : [EOL] [docstring] [EOL] if not isinstance ( x , np . ndarray ) : [EOL] raise Exception ( [string] ) [EOL] if not isinstance ( x_cols , list ) : [EOL] raise Exception ( [string] ) [EOL] if not isinstance ( x_rows , list ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] if not x . flags [ [string] ] : [EOL] x = np . ascontiguousarray ( x ) [EOL] [EOL] serialized = base64 . b64encode ( x . tobytes ( ) ) [EOL] [EOL] nice_cx_builder = NiceCXBuilder ( ) [EOL] nice_cx_builder . set_name ( name ) [EOL] nice_cx_builder . add_node ( name = [string] , represents = [string] ) [EOL] [EOL] nice_cx_builder . add_opaque_aspect ( [string] , [ { [string] : serialized } ] ) [EOL] nice_cx_builder . add_opaque_aspect ( [string] , [ { [string] : x_cols } ] ) [EOL] nice_cx_builder . add_opaque_aspect ( [string] , [ { [string] : x_rows } ] ) [EOL] nice_cx_builder . add_opaque_aspect ( [string] , [ { [string] : x . dtype . name } ] ) [EOL] [EOL] nice_cx = nice_cx_builder . get_nice_cx ( ) [EOL] [EOL] [comment] [EOL] ont_url = nice_cx . upload_to ( server , username , password ) [EOL] [EOL] return ont_url [EOL] [EOL] [EOL] def get_matrix_from_ndex ( server , username , password , uuid ) : [EOL] nice_cx = create_nice_cx_from_server ( server = server , uuid = uuid , username = username , password = password ) [EOL] [EOL] matrix = __get_v_from_aspect ( nice_cx , [string] ) [EOL] [EOL] matrix_cols = __get_v_from_aspect ( nice_cx , [string] ) [EOL] matrix_rows = __get_v_from_aspect ( nice_cx , [string] ) [EOL] matrix_dtype = __get_v_from_aspect ( nice_cx , [string] ) [EOL] [EOL] binary_data = base64 . b64decode ( matrix ) [EOL] [EOL] dtype = np . dtype ( matrix_dtype ) [EOL] dim = ( len ( matrix_rows ) , len ( matrix_cols ) ) [EOL] [EOL] [comment] [EOL] x = np . frombuffer ( binary_data , dtype = dtype ) . reshape ( dim ) [EOL] [EOL] return x , matrix_cols , matrix_rows [EOL] [EOL] [EOL] def __get_v_from_aspect ( niceCx , aspect ) : [EOL] aspect_tmp = niceCx . get_opaque_aspect ( aspect ) [EOL] if len ( aspect_tmp ) > [number] : [EOL] return aspect_tmp [ [number] ] . get ( [string] ) [EOL] [EOL] def __string2bits ( s = [string] ) : [EOL] return [ bin ( ord ( x ) ) [ [number] : ] . zfill ( [number] ) for x in s ] [EOL] [EOL] from enum import Enum [EOL] [EOL] known_aspects = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] known_aspects_min = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] [EOL] [EOL] def __add_node ( nice_cx , name = None , represents = None ) : [EOL] if node_id_lookup . get ( name ) is None : [EOL] source_id = nice_cx . get_next_node_id ( ) [EOL] node_id_lookup [ name ] = source_id [EOL] [EOL] nice_cx . add_node ( id = node_id_lookup . get ( name ) , name = name , represents = represents ) [EOL] [EOL] return node_id_lookup . get ( name ) [EOL] [EOL] [EOL] def create_empty_nice_cx ( ) : [EOL] my_nicecx = NiceCXNetwork ( ) [EOL] return my_nicecx [EOL] [EOL] [EOL] def _create_cartesian_coordinates_aspect_from_networkx ( G ) : [EOL] return [ { [string] : n , [string] : float ( G . pos [ n ] [ [number] ] ) , [string] : float ( G . pos [ n ] [ [number] ] ) } for n in G . pos ] [EOL] [EOL] [EOL] def create_nice_cx_from_networkx ( G ) : [EOL] [docstring] [EOL] [EOL] niceCxBuilder = NiceCXBuilder ( ) [EOL] if G is None : [EOL] raise Exception ( [string] ) [EOL] [EOL] my_nicecx = NiceCXNetwork ( ) [EOL] [EOL] if G . graph . get ( [string] ) : [EOL] my_nicecx . set_name ( G . graph . get ( [string] ) ) [EOL] else : [EOL] my_nicecx . set_name ( [string] ) [EOL] [EOL] my_nicecx . add_metadata_stub ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] for n , d in G . nodes ( data = True ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( n , int ) : [EOL] node_id = niceCxBuilder . add_node ( name = n , represents = d . get ( [string] ) , id = n , map_node_ids = True ) [EOL] else : [EOL] node_id = niceCxBuilder . add_node ( name = n , represents = d . get ( [string] ) , map_node_ids = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for k , v in d . items ( ) : [EOL] use_this_value , attr_type = _infer_data_type ( v , split_string = True ) [EOL] [EOL] if k == [string] and not isinstance ( use_this_value , list ) : [EOL] use_this_value = [ use_this_value ] [EOL] attr_type = [string] [EOL] if use_this_value is not None : [EOL] niceCxBuilder . add_node_attribute ( node_id , k , use_this_value , type = attr_type ) [EOL] [EOL] index = [number] [EOL] for u , v , d in G . edges ( data = True ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if d . get ( [string] ) is None or d . get ( [string] ) == [string] : [EOL] interaction = [string] [EOL] else : [EOL] interaction = d . get ( [string] ) [EOL] [EOL] if isinstance ( u , int ) : [EOL] niceCxBuilder . add_edge ( source = u , target = v , interaction = interaction , id = index ) [EOL] else : [EOL] niceCxBuilder . add_edge ( source = niceCxBuilder . node_id_lookup . get ( u ) , target = niceCxBuilder . node_id_lookup . get ( v ) , interaction = interaction , id = index ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for k , val in d . items ( ) : [EOL] if k != [string] : [EOL] use_this_value , attr_type = _infer_data_type ( val , split_string = True ) [EOL] [EOL] if k == [string] and not isinstance ( use_this_value , list ) : [EOL] use_this_value = [ use_this_value ] [EOL] attr_type = [string] [EOL] [EOL] if use_this_value is not None : [EOL] niceCxBuilder . add_edge_attribute ( property_of = index , name = k , values = use_this_value , type = attr_type ) [EOL] [EOL] index += [number] [EOL] [EOL] if hasattr ( G , [string] ) : [EOL] aspect = _create_cartesian_coordinates_aspect_from_networkx ( G ) [EOL] niceCxBuilder . add_opaque_aspect ( [string] , aspect ) [EOL] [EOL] return niceCxBuilder . get_nice_cx ( ) [EOL] [EOL] [EOL] def create_nice_cx_from_raw_cx ( cx ) : [EOL] [docstring] [EOL] [EOL] niceCxBuilder = NiceCXBuilder ( ) [EOL] [EOL] [comment] [EOL] [EOL] if cx : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] available_aspects = [ ] [EOL] for ae in ( o for o in niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) ) : [EOL] available_aspects . append ( ae . get ( [string] ) ) [EOL] [EOL] opaque_aspects = set ( available_aspects ) . difference ( known_aspects_min ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for network_item in objects : [EOL] niceCxBuilder . _add_network_attributes_from_fragment ( network_item ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for node_item in objects : [EOL] niceCxBuilder . _add_node_from_fragment ( node_item ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for edge_item in objects : [EOL] niceCxBuilder . _add_edge_from_fragment ( edge_item ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for att in objects : [EOL] niceCxBuilder . _add_node_attribute_from_fragment ( att ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for att in objects : [EOL] niceCxBuilder . _add_edge_attribute_from_fragment ( att ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for cit in objects : [EOL] niceCxBuilder . _add_citation_from_fragment ( cit ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for sup in objects : [EOL] niceCxBuilder . _add_supports_from_fragment ( sup ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for add_this_edge_sup in objects : [EOL] niceCxBuilder . _add_edge_supports_from_fragment ( add_this_edge_sup ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for node_cit in objects : [EOL] niceCxBuilder . _add_node_citations_from_fragment ( node_cit ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , [string] ) [EOL] for edge_cit in objects : [EOL] niceCxBuilder . _add_edge_citations_from_fragment ( edge_cit ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for oa in opaque_aspects : [EOL] [comment] [EOL] if oa == [string] : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , oa ) [EOL] niceCxBuilder . set_context ( objects ) [comment] [EOL] else : [EOL] objects = niceCxBuilder . get_frag_from_list_by_key ( cx , oa ) [EOL] niceCxBuilder . add_opaque_aspect ( oa , objects ) [EOL] [EOL] return niceCxBuilder . get_nice_cx ( ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def create_nice_cx_from_pandas ( df , source_field = None , target_field = None , source_node_attr = [ ] , target_node_attr = [ ] , edge_attr = [ ] , edge_interaction = None , source_represents = None , target_represents = None ) : [EOL] [docstring] [EOL] [EOL] my_nicecx = NiceCXNetwork ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] my_nicecx . set_name ( [string] ) [EOL] [comment] [EOL] count = [number] [EOL] source_predicate = [string] [EOL] target_predicate = [string] [EOL] [EOL] niceCxBuilder = NiceCXBuilder ( ) [EOL] [EOL] if source_field and target_field : [EOL] for index , row in df . iterrows ( ) : [EOL] if count % [number] == [number] : [EOL] print ( count ) [EOL] count += [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if source_represents is not None : [EOL] source_node_id = niceCxBuilder . add_node ( name = source_predicate + str ( row [ source_field ] ) , represents = source_predicate + str ( row [ source_represents ] ) ) [EOL] else : [EOL] source_node_id = niceCxBuilder . add_node ( name = source_predicate + str ( row [ source_field ] ) , represents = source_predicate + str ( row [ source_field ] ) ) [EOL] [EOL] if target_represents is not None : [EOL] target_node_id = niceCxBuilder . add_node ( name = target_predicate + str ( row [ target_field ] ) , represents = target_predicate + str ( row [ target_represents ] ) ) [EOL] else : [EOL] target_node_id = niceCxBuilder . add_node ( name = target_predicate + str ( row [ target_field ] ) , represents = target_predicate + str ( row [ target_field ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if edge_interaction : [EOL] if row . get ( edge_interaction ) : [EOL] use_this_interaction = row [ edge_interaction ] [EOL] else : [EOL] use_this_interaction = edge_interaction [EOL] else : [EOL] use_this_interaction = [string] [EOL] [EOL] niceCxBuilder . add_edge ( id = index , source = source_node_id , target = target_node_id , interaction = use_this_interaction ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for sp in source_node_attr : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] attr_type = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if sp == [string] and not isinstance ( row [ sp ] , list ) : [EOL] row [ sp ] = [ row [ sp ] ] [EOL] attr_type = [string] [EOL] niceCxBuilder . add_node_attribute ( source_node_id , sp , str ( row [ sp ] ) , type = attr_type ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for tp in target_node_attr : [EOL] [comment] [EOL] [comment] [EOL] [EOL] attr_type = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if tp == [string] and not isinstance ( row [ tp ] , list ) : [EOL] row [ tp ] = [ row [ tp ] ] [EOL] attr_type = [string] [EOL] niceCxBuilder . add_node_attribute ( target_node_id , tp , str ( row [ tp ] ) , type = attr_type ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for ep in edge_attr : [EOL] [comment] [EOL] [comment] [EOL] [EOL] attr_type = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if ep == [string] and not isinstance ( row [ ep ] , list ) : [EOL] row [ ep ] = [ row [ ep ] ] [EOL] attr_type = [string] [EOL] [EOL] niceCxBuilder . add_edge_attribute ( property_of = index , name = ep , values = row [ ep ] , type = attr_type ) [EOL] [EOL] else : [EOL] for index , row in df . iterrows ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_node_id = niceCxBuilder . add_node ( name = str ( row [ [number] ] ) , represents = str ( row [ [number] ] ) ) [EOL] [EOL] target_node_id = niceCxBuilder . add_node ( name = str ( row [ [number] ] ) , represents = str ( row [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( row ) > [number] : [EOL] niceCxBuilder . add_edge ( id = index , source = source_node_id , target = target_node_id , interaction = row [ [number] ] ) [EOL] else : [EOL] niceCxBuilder . add_edge ( id = index , source = source_node_id , target = target_node_id , interaction = [string] ) [EOL] [EOL] return niceCxBuilder . get_nice_cx ( ) [comment] [EOL] [EOL] [EOL] def create_nice_cx_from_server ( server , username = None , password = None , uuid = None ) : [EOL] [docstring] [EOL] [EOL] niceCxBuilder = NiceCXBuilder ( ) [EOL] [EOL] if server and uuid : [EOL] my_nicecx = NiceCXNetwork ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] available_aspects = [ ] [EOL] md_aspect_iter = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] if md_aspect_iter : [EOL] for ae in ( o for o in md_aspect_iter ) : [EOL] available_aspects . append ( ae . get ( [string] ) ) [EOL] else : [EOL] if not username or not password : [EOL] raise Exception ( [string] ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] opaque_aspects = set ( available_aspects ) . difference ( known_aspects_min ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for network_item in objects : [EOL] niceCxBuilder . _add_network_attributes_from_fragment ( network_item ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] [EOL] niceCxBuilder . set_context ( objects ) [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for node_item in objects : [EOL] niceCxBuilder . _add_node_from_fragment ( node_item ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for edge_item in objects : [EOL] niceCxBuilder . _add_edge_from_fragment ( edge_item ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for att in objects : [EOL] niceCxBuilder . _add_node_attribute_from_fragment ( att ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for att in objects : [EOL] niceCxBuilder . _add_edge_attribute_from_fragment ( att ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for cit in objects : [EOL] niceCxBuilder . _add_citation_from_fragment ( cit ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for sup in objects : [EOL] niceCxBuilder . _add_supports_from_fragment ( sup ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for add_this_edge_sup in objects : [EOL] niceCxBuilder . _add_edge_supports_from_fragment ( add_this_edge_sup ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for node_cit in objects : [EOL] niceCxBuilder . _add_node_citations_from_fragment ( node_cit ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in available_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , [string] , server , username , password ) [EOL] for edge_cit in objects : [EOL] niceCxBuilder . _add_edge_citations_from_fragment ( edge_cit ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for oa in opaque_aspects : [EOL] objects = my_nicecx . get_aspect ( uuid , oa , server , username , password ) [EOL] niceCxBuilder . add_opaque_aspect ( oa , objects ) [EOL] [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] return niceCxBuilder . get_nice_cx ( ) [EOL] [EOL] [EOL] def create_nice_cx_from_file ( path ) : [EOL] [docstring] [EOL] if os . path . isfile ( path ) : [EOL] with open ( path , [string] ) as file_cx : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] my_nicecx = create_nice_cx_from_raw_cx ( json . load ( file_cx ) ) [EOL] [EOL] return my_nicecx [EOL] else : [EOL] raise Exception ( [string] + path + [string] ) [EOL] [EOL] [EOL] def _infer_data_type ( val , split_string = False ) : [EOL] if val is None : [EOL] return None , None [EOL] [EOL] attr_type = [string] [EOL] [EOL] if split_string : [EOL] if isinstance ( val , str ) : [EOL] val = val . replace ( [string] , [string] ) [EOL] if [string] in val : [EOL] val = val . split ( [string] ) [EOL] elif [string] in val : [EOL] val = val . split ( [string] ) [EOL] [EOL] processed_value = val [EOL] [EOL] if isinstance ( val , float ) or isinstance ( val , np . float ) or isinstance ( val , np . double ) : [EOL] if math . isnan ( val ) : [EOL] [comment] [EOL] processed_value = None [EOL] elif math . isinf ( val ) : [EOL] processed_value = [string] [EOL] attr_type = [string] [comment] [EOL] elif isinstance ( val , int ) or isinstance ( val , np . int ) : [EOL] attr_type = [string] [EOL] elif isinstance ( val , list ) : [EOL] if len ( val ) > [number] : [EOL] if isinstance ( val [ [number] ] , float ) or isinstance ( val [ [number] ] , np . float ) or isinstance ( val [ [number] ] , np . double ) : [EOL] attr_type = [string] [EOL] elif isinstance ( val [ [number] ] , int ) or isinstance ( val [ [number] ] , np . int ) : [EOL] attr_type = [string] [EOL] else : [EOL] attr_type = [string] [EOL] [EOL] return processed_value , attr_type [EOL] [EOL] [EOL] from ndex2 . nice_cx_network import NiceCXNetwork [EOL] from ndex2 . client import Ndex2 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0