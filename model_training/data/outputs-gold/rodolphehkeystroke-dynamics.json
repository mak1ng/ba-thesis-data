[comment] [EOL] [EOL] [comment] [EOL] from typing import Dict , Any [EOL] import numpy [EOL] import builtins [EOL] import typing [EOL] import sklearn [EOL] from typing import Dict [EOL] [EOL] [comment] [EOL] import numpy as np [EOL] [EOL] [comment] [EOL] from sklearn . svm import OneClassSVM [EOL] from sklearn . preprocessing import MinMaxScaler [EOL] from sklearn . pipeline import Pipeline [EOL] from sklearn . metrics import make_scorer [EOL] from sklearn . base import BaseEstimator , clone [EOL] from sklearn . utils . validation import check_array , check_is_fitted [EOL] from sklearn . model_selection import GridSearchCV [EOL] from copy import deepcopy [EOL] [EOL] [EOL] class Model ( BaseEstimator ) : [EOL] [EOL] def __init__ ( self , nu = [number] , gamma = [number] ) : [EOL] self . nu = nu [EOL] self . gamma = gamma [EOL] [EOL] def makePipeline ( self ) : [EOL] [comment] [EOL] self . _scaler = MinMaxScaler ( ( [number] , [number] ) ) [EOL] self . _classifier = OneClassSVM ( kernel = [string] , nu = self . nu , gamma = self . gamma ) [EOL] [EOL] [comment] [EOL] self . _pipeline = Pipeline ( [ ( [string] , self . scaler ) , ( [string] , self . classifier ) ] ) [EOL] [EOL] [comment] [EOL] self . _scorer = make_scorer ( self . score , greater_is_better = True ) [EOL] [EOL] @ property def scaler ( self ) : [EOL] return self . _scaler [EOL] [EOL] @ property def classifier ( self ) : [EOL] return self . _classifier [EOL] [EOL] @ property def pipeline ( self ) : [EOL] try : [EOL] return self . _pipeline [EOL] except AttributeError : [EOL] self . makePipeline ( ) [EOL] return self . _pipeline [EOL] [EOL] def fit ( self , X , y = None ) : [EOL] [comment] [EOL] self . pipeline . fit ( X ) [EOL] [EOL] [comment] [EOL] self . is_fitted_ = True [EOL] self . X_ = X [EOL] self . y_ = y [EOL] [EOL] return self [EOL] [EOL] def predict ( self , X ) : [EOL] [comment] [EOL] check_is_fitted ( self , [ [string] , [string] ] ) [EOL] [comment] [EOL] X = check_array ( X ) [EOL] [EOL] return self . pipeline . predict ( X ) [EOL] [EOL] def score ( self , X , y = None ) : [EOL] y = self . predict ( X ) [EOL] TP = y [ y == [number] ] . size [EOL] FN = y [ y == - [number] ] . size [EOL] return TP / ( TP + FN ) [EOL] [EOL] @ staticmethod def evaluate ( pipeline , train , test ) : [EOL] [comment] [EOL] y_pred_train = pipeline . predict ( train ) [EOL] y_pred_test = pipeline . predict ( test ) [EOL] [EOL] TP = y_pred_test [ y_pred_test == [number] ] . size + y_pred_train [ y_pred_train == [number] ] . size [EOL] FN = y_pred_test [ y_pred_test == - [number] ] . size + y_pred_train [ y_pred_train == - [number] ] . size [EOL] [EOL] return { [string] : TP , [string] : FN , [string] : y_pred_train [ y_pred_train == - [number] ] . size , [string] : TP / ( TP + FN ) , [string] : pipeline } [EOL] [EOL] @ staticmethod def report ( pipeline , train , test , outliers ) : [EOL] [EOL] [comment] [EOL] y_pred_train = pipeline . predict ( train ) [EOL] y_pred_test = pipeline . predict ( test ) [EOL] y_pred_outliers = pipeline . predict ( outliers ) [EOL] [EOL] TP = y_pred_test [ y_pred_test == [number] ] . size + y_pred_train [ y_pred_train == [number] ] . size [EOL] TN = y_pred_outliers [ y_pred_outliers == - [number] ] . size [EOL] FP = y_pred_outliers [ y_pred_outliers == [number] ] . size [EOL] FN = y_pred_test [ y_pred_test == - [number] ] . size + y_pred_train [ y_pred_train == - [number] ] . size [EOL] [EOL] return { [string] : TP , [string] : TN , [string] : FP , [string] : FN , [string] : y_pred_train [ y_pred_train == - [number] ] . size , [string] : TP / ( TP + FP + [number] ) , [string] : TP / ( TP + FN ) , [string] : ( TP + TN ) / ( TP + TN + FP + FN ) , [string] : ( [number] * TP ) / ( [number] * TP + FP + FN ) , [string] : pipeline } [EOL] [EOL] @ staticmethod def findParameters ( pipeline , X , y = None , returnModel = True ) : [EOL] returned = { } [EOL] gs = GridSearchCV ( estimator = pipeline , param_grid = { [string] : np . linspace ( [number] , [number] , [number] ) , [string] : np . logspace ( - [number] , [number] , [number] ) } , cv = [number] , iid = False ) [EOL] gs . fit ( X , y ) [EOL] returned [ [string] ] = gs . best_params_ [ [string] ] [EOL] returned [ [string] ] = gs . best_params_ [ [string] ] [EOL] if returnModel : [EOL] returned [ [string] ] = gs . best_estimator_ [EOL] return returned [EOL] [EOL] @ staticmethod def copyParameters ( params ) : [EOL] returned = { } [EOL] returned [ [string] ] = params [ [string] ] [EOL] returned [ [string] ] = params [ [string] ] [EOL] [comment] [EOL] returned [ [string] ] = deepcopy ( params [ [string] ] ) [EOL] return returned [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] from sklearn . utils . estimator_checks import check_estimator [EOL] check_estimator ( Model ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] class SampleParser : [EOL] [EOL] def __init__ ( self , sample , * args , ** kwargs ) : [EOL] self . sample = sample [EOL] self . pp = [ ] [EOL] self . rr = [ ] [EOL] self . pr = [ ] [EOL] self . rp = [ ] [EOL] [EOL] for index in range ( [number] , len ( self . sample ) , [number] ) : [EOL] first = self . sample . kb_evts [ index ] [EOL] prSecond = self . sample . kb_evts [ index + [number] ] [EOL] ppSecond = self . sample . kb_evts [ index + [number] ] [EOL] [EOL] firstTmg = first . seconds * [number] + first . nsec [EOL] prSecondTmg = prSecond . seconds * [number] + prSecond . nsec [EOL] ppSecondTmg = ppSecond . seconds * [number] + ppSecond . nsec [EOL] [EOL] prTmg = prSecondTmg - firstTmg [EOL] ppTmg = ppSecondTmg - firstTmg [EOL] [EOL] self . pr . append ( prTmg ) [EOL] self . pp . append ( ppTmg ) [EOL] for index in range ( [number] , len ( self . sample ) , [number] ) : [EOL] first = self . sample . kb_evts [ index ] [EOL] rpSecond = self . sample . kb_evts [ index + [number] ] [EOL] rrSecond = self . sample . kb_evts [ index + [number] ] [EOL] [EOL] firstTmg = first . seconds * [number] + first . nsec [EOL] rpSecondTmg = rpSecond . seconds * [number] + rpSecond . nsec [EOL] rrSecondTmg = rrSecond . seconds * [number] + rrSecond . nsec [EOL] [EOL] rpTmg = rpSecondTmg - firstTmg [EOL] rrTmg = rrSecondTmg - firstTmg [EOL] [EOL] self . rp . append ( rpTmg ) [EOL] self . rr . append ( rrTmg ) [EOL] [EOL] self . rp = self . rp [ : - [number] ] [EOL] self . pp = self . pp [ : - [number] ] [EOL] self . rr = self . rr [ : - [number] ] [EOL] [EOL] @ property def timings ( self ) : [EOL] return self . pr + self . rp + self . pp + self . rr + ( [ [number] ] if self . sample . impostor else [ [number] ] ) + [ len ( self . pr ) + len ( self . rp ) + len ( self . pp ) + len ( self . rr ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import SampleParser [EOL] import pickle [EOL] [EOL] from common import get_binary_validation [EOL] from common import get_file_list [EOL] from common import get_existing_filename [EOL] from common import get_sequence_from_file [EOL] from common import print_report [EOL] from SampleParser import SampleParser [EOL] from Model import Model [EOL] [EOL] from sklearn . model_selection import train_test_split [EOL] [EOL] [EOL] def evaluator ( ) : [EOL] existing_files = get_file_list ( [string] , [string] ) [EOL] [EOL] if not existing_files : [EOL] print ( [string] ) [EOL] exit ( ) [EOL] [EOL] target_filename = get_existing_filename ( existing_files ) [EOL] if len ( target_filename ) == [number] : [EOL] print ( [string] ) [EOL] exit ( ) [EOL] [EOL] model = None [EOL] print ( target_filename ) [EOL] with open ( [string] + target_filename , [string] ) as file : [EOL] model = pickle . load ( file ) [EOL] [EOL] if model is None : [EOL] return [EOL] [EOL] existing_files = get_file_list ( [string] , [string] ) [EOL] [EOL] if not existing_files : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] target_filenames = get_existing_filename ( existing_files , True ) [EOL] if len ( target_filenames ) == [number] : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] sequence = [ ] [EOL] for target_filename in target_filenames : [EOL] samples = get_sequence_from_file ( target_filename ) [EOL] sequence . extend ( samples ) [EOL] [EOL] timings_sequences = [ ] [EOL] compared_size = None [EOL] print ( [string] ) [EOL] [EOL] for raw_sample in sequence : [EOL] parser = SampleParser ( raw_sample ) [EOL] timings_sequences . append ( parser . timings ) [EOL] if compared_size is None : [EOL] compared_size = parser . timings [ - [number] ] [EOL] else : [EOL] if parser . timings [ - [number] ] != compared_size : [EOL] print ( [string] . format ( parser . timings [ - [number] ] ) ) [EOL] del timings_sequences [ - [number] ] [EOL] [EOL] print ( [string] . format ( len ( timings_sequences ) ) ) [EOL] [EOL] [comment] [EOL] trueData = [ smp [ : smp [ - [number] ] ] for smp in timings_sequences if smp [ - [number] ] == [number] ] [EOL] fakeData = [ smp [ : smp [ - [number] ] ] for smp in timings_sequences if smp [ - [number] ] == [number] ] [EOL] [EOL] [comment] [EOL] train , test = train_test_split ( trueData , train_size = [number] , test_size = None ) [EOL] [EOL] print ( [string] . format ( len ( trueData ) ) ) [EOL] print ( [string] . format ( len ( fakeData ) ) ) [EOL] [EOL] [comment] [EOL] report = Model . report ( model , train , test , fakeData ) [EOL] [EOL] print_report ( report ) [EOL] [EOL] [EOL] def main ( ) : [EOL] is_running = True [EOL] while is_running : [EOL] evaluator ( ) [EOL] again = get_binary_validation ( [string] , False ) [EOL] if not again : [EOL] is_running = False [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Dict , Literal [EOL] import typing_extensions [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import glob [EOL] import pickle [EOL] [EOL] [comment] [EOL] from PyInquirer import prompt [EOL] from examples import custom_style_2 [EOL] [EOL] from termgraph . termgraph import chart , AVAILABLE_COLORS as colors [EOL] [EOL] [EOL] def get_file_list ( folder , extension ) : [EOL] [docstring] [EOL] filenames = [ ] [EOL] os . makedirs ( folder , exist_ok = True ) [EOL] for file in glob . glob ( folder + [string] + extension ) : [EOL] filenames . append ( { [string] : file . replace ( folder + [string] , [string] ) } ) [EOL] return filenames [EOL] [EOL] [EOL] def get_path ( ) : [EOL] [docstring] [EOL] return os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] [EOL] [EOL] def get_binary_validation ( message , default = True ) : [EOL] [docstring] [EOL] questions = [ { [string] : [string] , [string] : message , [string] : [string] , [string] : default , } ] [EOL] return prompt ( questions , style = custom_style_2 ) [ [string] ] [EOL] [EOL] [EOL] def get_existing_filename ( existing_files , multiple = False ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] if len ( existing_files ) == [number] : [EOL] return [ existing_files [ [number] ] [ [string] ] ] [EOL] [EOL] plural = [string] if multiple else [string] [EOL] [EOL] questions = [ { [string] : [string] if multiple else [string] , [string] : [string] , [string] : [string] + plural + [string] , [string] : existing_files } ] [EOL] return prompt ( questions , style = custom_style_2 ) [ [string] ] [EOL] [EOL] [EOL] def print_report ( report ) : [EOL] print ( [string] ) [EOL] labels = [ [string] , [string] ] [EOL] data = [ [ report [ [string] ] , report [ [string] ] ] , [ report [ [string] ] , report [ [string] ] ] ] [EOL] args = { [string] : True , [string] : [number] , [string] : False , [string] : [string] , [string] : [string] , [string] : False } [EOL] chart ( colors = [ colors [ [string] ] , colors [ [string] ] ] , data = data , args = args , labels = labels ) [EOL] [EOL] print ( [string] ) [EOL] labels = [ [string] , [string] , [string] , [string] ] [EOL] data = [ [ report [ [string] ] * [number] ] , [ report [ [string] ] * [number] ] , [ report [ [string] ] * [number] ] , [ report [ [string] ] * [number] ] ] [EOL] args = { [string] : False , [string] : [number] , [string] : False , [string] : [string] , [string] : [string] , [string] : False } [EOL] chart ( colors = [ ] , data = data , args = args , labels = labels ) [EOL] [EOL] [EOL] def get_sequence_from_file ( filename ) : [EOL] [docstring] [EOL] samples = [ ] [EOL] [EOL] with open ( get_path ( ) + [string] + filename , [string] ) as file : [EOL] while True : [EOL] try : [EOL] samples . append ( pickle . load ( file ) ) [EOL] except EOFError : [EOL] break [EOL] return samples [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import Sample [EOL] import ctypes [EOL] from ctypes import byref , cdll [EOL] from Sample import Sample [EOL] [EOL] [comment] [EOL] keylogger = cdll . LoadLibrary ( [string] ) [EOL] [EOL] [EOL] def keylog_session ( ) : [EOL] [docstring] [EOL] [comment] [EOL] empty_sample = Sample ( ) [EOL] [EOL] [comment] [EOL] keylogger . keylogSession ( byref ( empty_sample ) ) [EOL] [comment] [EOL] collected_sample = empty_sample [EOL] del empty_sample [EOL] [EOL] return collected_sample [EOL] [EOL] [EOL] def replay_sample ( sample ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] keylogger . replaySample ( byref ( sample ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import argparse [EOL] import pickle [EOL] import os [EOL] import sys [EOL] import argparse [EOL] [EOL] def sanitize_encoding ( filename ) : [EOL] print ( filename ) [EOL] orig_filename = filename [EOL] new_filename = filename . split ( [string] ) [EOL] new_filename . insert ( [number] , [string] ) [EOL] [EOL] new_filename = [string] . join ( new_filename ) [EOL] [EOL] [comment] [EOL] samples = [ ] [EOL] [EOL] with open ( orig_filename , [string] ) as file : [EOL] while True : [EOL] try : [EOL] samples . append ( pickle . load ( file ) ) [EOL] except EOFError : [EOL] break [EOL] [EOL] for sample in samples : [EOL] sample . string = sample . string . encode ( [string] , [string] ) . decode ( [string] ) [EOL] [EOL] with open ( new_filename , [string] ) as file : [EOL] for sample in samples : [EOL] pickle . dump ( sample , file , pickle . HIGHEST_PROTOCOL ) [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] args = vars ( parser . parse_args ( ) ) [EOL] [EOL] if len ( args [ [string] ] ) > [number] and args [ [string] ] : [EOL] parser . error ( [string] ) [EOL] elif args [ [string] ] : [EOL] print ( [string] . format ( args [ [string] ] ) ) [EOL] else : [EOL] print ( [string] . format ( args [ [string] ] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import Any , TextIO [EOL] import Sample [EOL] import typing [EOL] import keylogger [EOL] import SampleParser [EOL] import sys [EOL] import pickle [EOL] [EOL] from keylogger import Sample , keylog_session [EOL] from io import StringIO [EOL] [EOL] from SampleParser import SampleParser [EOL] [EOL] from common import get_binary_validation , get_file_list , get_existing_filename [EOL] [EOL] [EOL] def get_single_sample ( ) : [EOL] [docstring] [EOL] print ( [string] , end = [string] ) [EOL] sys . stdout . flush ( ) [EOL] [EOL] [comment] [EOL] orig_out = sys . stdout [EOL] sys . stdout = StringIO ( ) [EOL] [EOL] [comment] [EOL] sample = keylog_session ( ) [EOL] [EOL] [comment] [EOL] sys . stdout = orig_out [EOL] [EOL] str_pw = input ( ) [EOL] sample . string = str_pw [EOL] [EOL] return sample [EOL] [EOL] [EOL] def tester ( ) : [EOL] existing_files = get_file_list ( [string] , [string] ) [EOL] [EOL] if not existing_files : [EOL] print ( [string] ) [EOL] exit ( ) [EOL] [EOL] target_filename = get_existing_filename ( existing_files ) [EOL] if len ( target_filename ) == [number] : [EOL] print ( [string] ) [EOL] exit ( ) [EOL] [EOL] model = None [EOL] print ( target_filename ) [EOL] with open ( [string] + target_filename , [string] ) as file : [EOL] model = pickle . load ( file ) [EOL] [EOL] is_running = True [EOL] [EOL] while is_running : [EOL] raw_sample = get_single_sample ( ) [EOL] raw_sample . impostor = True [EOL] parser = SampleParser ( raw_sample ) [EOL] timings = parser . timings [EOL] timings = timings [ : timings [ - [number] ] ] [EOL] try : [EOL] results = model . pipeline . predict ( [ timings ] ) [EOL] if results [ [number] ] == - [number] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] again = get_binary_validation ( [string] , False ) [EOL] if not again : [EOL] is_running = False [EOL] except ValueError : [EOL] print ( [string] ) [EOL] continue [EOL] [EOL] [EOL] def main ( ) : [EOL] is_running = True [EOL] while is_running : [EOL] tester ( ) [EOL] again = get_binary_validation ( [string] , False ) [EOL] if not again : [EOL] is_running = False [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Union , Tuple [EOL] import builtins [EOL] import typing [EOL] import Sample [EOL] import ctypes [EOL] from ctypes import Structure , c_int , c_long , c_uint [EOL] [EOL] MAX_KBEVTS = [number] [EOL] [EOL] [EOL] class KbEvt ( Structure ) : [EOL] [docstring] [EOL] _fields_ = [ ( [string] , c_int ) , ( [string] , c_long ) , ( [string] , c_uint ) , ( [string] , c_int ) ] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . seconds , self . nsec , self . code , [string] if ( self . state == [number] ) else [string] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] + str ( self ) [EOL] [EOL] [EOL] class Sample ( Structure ) : [EOL] [docstring] [EOL] _fields_ = [ ( [string] , c_int ) , ( [string] , ( KbEvt * MAX_KBEVTS ) ) ] [EOL] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . current_pos = [number] [EOL] [EOL] def __str__ ( self ) : [EOL] str_repr = [string] [EOL] for i in range ( len ( self ) ) : [EOL] str_repr += [string] . format ( self . kb_evts [ i ] ) [EOL] [EOL] str_repr = str_repr [ : - [number] ] + [string] [EOL] return str_repr [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] + str ( self ) [EOL] [EOL] def __len__ ( self ) : [EOL] return self . size [EOL] [EOL] def __iter__ ( self ) : [EOL] for i in range ( len ( self ) ) : [EOL] yield self . kb_evts [ i ] [EOL] [EOL] @ property def string ( self ) : [EOL] return self . _string [EOL] [EOL] @ string . setter def string ( self , value ) : [EOL] self . _string = value [EOL] [EOL] @ property def impostor ( self ) : [EOL] return self . _impostor [EOL] [EOL] @ impostor . setter def impostor ( self , is_impostor ) : [EOL] self . _impostor = is_impostor [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import Crypto [EOL] import pickle [EOL] import random [EOL] import string [EOL] from typing import List [EOL] from Crypto . Cipher import AES [EOL] import binascii [EOL] [EOL] [EOL] def string_gen ( ) : [EOL] [docstring] [EOL] key = [string] . join ( random . SystemRandom ( ) . choice ( string . ascii_uppercase + string . digits ) for _ in range ( [number] ) ) [EOL] return key [EOL] [EOL] [EOL] def encrypt_parameters ( ) : [EOL] [docstring] [EOL] key = string_gen ( ) [EOL] init_vector = string_gen ( ) [EOL] aes = [ init_vector , key ] [EOL] return aes [EOL] [EOL] [EOL] def file_dump ( encrypted , file_name = [string] ) : [EOL] [docstring] [EOL] with open ( file_name , [string] ) as dump_file : [EOL] dump_file . write ( encrypted ) [EOL] return file_name [EOL] [EOL] [EOL] def file_read ( file_name ) : [EOL] [docstring] [EOL] with open ( file_name , [string] ) as saved_dump : [EOL] binary_lines = saved_dump . read ( ) [EOL] [EOL] return binary_lines [EOL] [EOL] [EOL] def aes_gen ( init_vector , key ) : [EOL] [docstring] [EOL] return AES . new ( key , AES . MODE_CBC , init_vector ) [EOL] [EOL] [EOL] def encrypt ( message , aes ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] message = pickle . dumps ( message ) [EOL] [comment] [EOL] message = binascii . hexlify ( message ) [EOL] [EOL] [comment] [EOL] message_str = message . decode ( [string] ) [EOL] [EOL] [comment] [EOL] length = len ( message_str ) [EOL] [comment] [EOL] length += [number] [EOL] [EOL] [comment] [EOL] if ( length % [number] ) != [number] : [EOL] complement_size = [number] - ( length % [number] ) [EOL] else : [EOL] complement_size = [number] [EOL] [EOL] [comment] [EOL] header = hex ( complement_size ) [EOL] [comment] [EOL] header = header [ - [number] ] [EOL] [EOL] [comment] [EOL] complement = [string] * complement_size [EOL] [EOL] [comment] [EOL] message_str = [string] . join ( [ header , message_str , complement ] ) [EOL] [EOL] [comment] [EOL] return aes . encrypt ( message_str ) [EOL] [EOL] [EOL] def decrypt ( message , aes ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] encrypted = aes . decrypt ( message ) . decode ( ) [EOL] [EOL] [comment] [EOL] header = int ( encrypted [ [number] ] , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] decrypted = encrypted [ [number] : ( len ( encrypted ) - header ) ] [EOL] [EOL] [comment] [EOL] decrypted_bytes = binascii . unhexlify ( decrypted ) [EOL] [EOL] [comment] [EOL] return pickle . loads ( decrypted_bytes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Crypto.Cipher.AES.AESCipher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] class Sample ( ) : [EOL] i = [number] [EOL] j = [number] [EOL] y = [number] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . i , self . j , self . y )	0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import pandas as pd [EOL] import numpy as np [EOL] [EOL] [EOL] class ResultTable : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . table = pd . DataFrame ( columns = self . columns ) [EOL] [EOL] def append ( self , user , TP , TN , FP , FN , f1 , accuracy , precision , recall , gamma , nu ) : [EOL] self . table . loc [ self . table . size ] = [ user , TP , TN , FP , FN , f1 , accuracy , precision , recall , gamma , nu , ( f1 + recall ) / [number] ] [EOL] self . format ( ) [EOL] [EOL] def appendResults ( self , user , results , parameters ) : [EOL] self . append ( user , results [ [string] ] , results [ [string] ] , results [ [string] ] , results [ [string] ] , results [ [string] ] , results [ [string] ] , results [ [string] ] , results [ [string] ] , parameters [ [string] ] , parameters [ [string] ] ) [EOL] [EOL] def format ( self ) : [EOL] self . table [ [string] ] = self . table [ [string] ] . astype ( np . int32 ) [EOL] self . table [ [string] ] = self . table [ [string] ] . astype ( np . int32 ) [EOL] self . table [ [string] ] = self . table [ [string] ] . astype ( np . int32 ) [EOL] self . table [ [string] ] = self . table [ [string] ] . astype ( np . int32 ) [EOL] self . table [ [string] ] = self . table [ [string] ] . astype ( np . int32 ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . table . __repr__ ( ) [EOL] [EOL] def _repr_html_ ( self ) : [EOL] return self . table . _repr_html_ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import Model [EOL] import typing [EOL] import csv [EOL] import sys [EOL] from Data import Data [EOL] import numpy as np [EOL] from sklearn . model_selection import train_test_split [EOL] from sklearn . base import clone [EOL] import csv [EOL] import copy [EOL] sys . path . append ( [string] ) [EOL] from Model import Model [EOL] [EOL] def getUserData ( userId , data , columns ) : [EOL] [comment] [EOL] studiedUserData = data . table . loc [ ( data . table [ [string] ] == userId ) , columns ] . astype ( [string] ) [EOL] [comment] [EOL] otherUsersData = data . table . loc [ ( data . table [ [string] ] != userId ) , columns ] . astype ( [string] ) [EOL] [EOL] return [ studiedUserData , otherUsersData ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] data = Data ( ) [EOL] samples = data . getSamples ( ) [EOL] targets = data . getTargets ( ) [EOL] [EOL] minimum = np . array ( samples , dtype = np . float64 ) . min ( axis = [number] ) . min ( axis = [number] ) [EOL] maximum = np . array ( samples , dtype = np . float64 ) . max ( axis = [number] ) . max ( axis = [number] ) [EOL] [EOL] print ( [string] + str ( maximum ) ) [EOL] print ( [string] + str ( minimum ) ) [EOL] [EOL] uniques = np . array ( data . usersCounts ) [EOL] users = uniques [ uniques [ : , [number] ] >= [number] ] [EOL] [EOL] columns = [ [string] + str ( index ) for index in range ( [number] ) ] [EOL] columns . extend ( [ [string] + str ( index ) for index in range ( [number] ) ] ) [EOL] columns . extend ( [ [string] + str ( index ) for index in range ( [number] ) ] ) [EOL] columns . extend ( [ [string] + str ( index ) for index in range ( [number] ) ] ) [EOL] [EOL] reports = [ ] [EOL] [EOL] for user in users : [EOL] studiedUserData , otherUsersData = getUserData ( user [ [number] ] , data , columns ) [EOL] print ( [string] . format ( user [ [number] ] , studiedUserData . shape ) ) [EOL] [EOL] temp_params = None [EOL] temp_evaluate = { [string] : [number] } [EOL] for i in range ( [number] ) : [EOL] model = Model ( ) [EOL] [EOL] [comment] [EOL] train , test = train_test_split ( studiedUserData , train_size = [number] , test_size = None ) [EOL] [EOL] [comment] [EOL] params = Model . findParameters ( model , train ) [EOL] [EOL] [comment] [EOL] evaluate = Model . evaluate ( params [ [string] ] , train , test ) [EOL] print ( evaluate ) [EOL] [EOL] if evaluate [ [string] ] > temp_evaluate [ [string] ] : [EOL] print ( [string] ) [EOL] temp_params = Model . copyParameters ( params ) [EOL] temp_evaluate = copy . deepcopy ( evaluate ) [EOL] [EOL] params = Model . copyParameters ( temp_params ) [EOL] evaluate = copy . deepcopy ( temp_evaluate ) [EOL] [EOL] [comment] [EOL] report = Model . report ( params [ [string] ] , train , test , otherUsersData ) [EOL] [EOL] report [ [string] ] = user [ [number] ] [EOL] report [ [string] ] = len ( studiedUserData ) [EOL] report [ [string] ] = len ( otherUsersData ) [EOL] report [ [string] ] = evaluate [ [string] ] [EOL] report [ [string] ] = evaluate [ [string] ] [EOL] report [ [string] ] = evaluate [ [string] ] [EOL] report [ [string] ] = evaluate [ [string] ] [EOL] report [ [string] ] = params [ [string] ] [EOL] report [ [string] ] = params [ [string] ] [EOL] del report [ [string] ] [EOL] print ( report ) [EOL] reports . append ( report ) [EOL] [EOL] with open ( [string] , [string] ) as file : [EOL] dump = csv . DictWriter ( file , delimiter = [string] , fieldnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] dump . writeheader ( ) [EOL] for report in reports : [EOL] dump . writerow ( report ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Model.Model.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $Model.Model.Model$ 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $csv.DictWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $csv.DictWriter$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $csv.DictWriter$ 0 0 0 $typing.Any$ 0 0
from typing import Any , List [EOL] import typing [EOL] import sqlite3 [EOL] import sqlite3 [EOL] import numpy as np [EOL] import pandas as pd [EOL] [EOL] class Data : [EOL] [docstring] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] self . samples = [ ] [EOL] self . targets = [ ] [EOL] self . description = [string] [EOL] self . headers = [ ] [EOL] self . headersMask = [ ] [EOL] self . table = None [EOL] self . rrTime = True [EOL] self . ppTime = False [EOL] self . rpTime = False [EOL] self . prTime = False [EOL] [EOL] self . computeHeadersMask ( ) [EOL] self . retrieveData ( ) [EOL] [EOL] def retrieveData ( self ) : [EOL] conn = sqlite3 . connect ( [string] ) [EOL] c = conn . cursor ( ) [EOL] [EOL] query = [string] [EOL] [EOL] c . execute ( query ) [EOL] [EOL] self . table = pd . read_sql_query ( query , conn ) [EOL] toDivide = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] for name in toDivide : [EOL] column = self . table [ name ] [EOL] columns = column . str . split ( [string] , expand = True ) [EOL] columns = columns . drop ( columns = [ [number] , [number] ] ) . astype ( [string] ) [EOL] columns . columns = [ [string] . format ( name , i ) for i in range ( [number] ) ] [EOL] self . table . drop ( columns = [ name ] , inplace = True ) [EOL] self . table = pd . concat ( [ self . table , columns ] , axis = [number] ) [EOL] [EOL] self . table . drop ( columns = [ [string] ] , inplace = True ) [EOL] self . table [ [ [string] , [string] ] ] = self . table [ [ [string] , [string] ] ] . astype ( [string] ) [EOL] [EOL] self . headers = [ ] [EOL] self . headers . extend ( [ ( [string] + str ( index ) ) for index in range ( [number] ) ] ) [EOL] self . headers . extend ( [ ( [string] + str ( index ) ) for index in range ( [number] ) ] ) [EOL] self . headers . extend ( [ ( [string] + str ( index ) ) for index in range ( [number] ) ] ) [EOL] self . headers . extend ( [ ( [string] + str ( index ) ) for index in range ( [number] ) ] ) [EOL] self . headers = np . array ( self . headers ) [EOL] [EOL] for row in c : [EOL] features = [ ] [EOL] features . extend ( row [ [number] ] . split ( [string] ) [ [number] : [number] ] ) [EOL] self . samples . append ( features ) [EOL] self . targets . append ( row [ [number] ] ) [EOL] [EOL] self . samples = np . array ( self . samples , dtype = np . float64 ) [EOL] self . targets = np . array ( self . targets ) [EOL] [EOL] def computeHeadersMask ( self ) : [EOL] self . headersMask = [ ] [EOL] self . headersMask . extend ( [ True if self . rrTime else False for index in range ( [number] ) ] ) [EOL] self . headersMask . extend ( [ True if self . ppTime else False for index in range ( [number] ) ] ) [EOL] self . headersMask . extend ( [ True if self . rpTime else False for index in range ( [number] ) ] ) [EOL] self . headersMask . extend ( [ True if self . prTime else False for index in range ( [number] ) ] ) [EOL] self . headersMask = np . array ( self . headersMask ) [EOL] [EOL] def getTargets ( self ) : [EOL] return self . targets [EOL] [EOL] def getSamples ( self ) : [EOL] return self . samples [ : , self . headersMask ] [EOL] [EOL] def getHeaders ( self ) : [EOL] return self . headers [ self . headersMask ] [EOL] [EOL] @ property def usersCounts ( self ) : [EOL] unique , counts = np . unique ( self . table [ [string] ] , return_counts = True ) [EOL] return sorted ( list ( zip ( unique , counts ) ) , key = lambda el : el [ [number] ] ) [ : : - [number] ] [EOL] [EOL] @ property def users ( self ) : [EOL] return np . unique ( self . table [ [string] ] ) [EOL] [EOL] def printUsersCounts ( self ) : [EOL] for count in self . usersCounts : [EOL] print ( [string] . format ( count [ [number] ] , count [ [number] ] ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Connection$ 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 $sqlite3.dbapi2.Connection$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $sqlite3.dbapi2.Connection$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import Model [EOL] import typing [EOL] import builtins [EOL] from Model import Model [EOL] from Data import Data [EOL] [EOL] import numpy as np [EOL] [EOL] from sklearn . model_selection import ShuffleSplit [EOL] from sklearn . model_selection import ParameterGrid [EOL] from sklearn . model_selection import GridSearchCV [EOL] [EOL] [EOL] def getUserData ( user , data , columns ) : [EOL] [comment] [EOL] studiedUserData = data . table . loc [ ( data . table [ [string] ] == user ) , columns ] . astype ( [string] ) [EOL] [comment] [EOL] otherUsersData = data . table . loc [ ( data . table [ [string] ] != user ) , columns ] . astype ( [string] ) [EOL] [EOL] return [ studiedUserData , otherUsersData ] [EOL] [EOL] [EOL] def customGridSearch ( user , data , columns ) : [EOL] studiedUserData , otherUsersData = getUserData ( user , data , columns ) [EOL] [EOL] [comment] [EOL] splitter = ShuffleSplit ( n_splits = [number] , train_size = [number] , test_size = None ) [EOL] dataOneIndices , dataTwoIndices = list ( splitter . split ( studiedUserData ) ) [ [number] ] [EOL] [EOL] dataOne = studiedUserData . iloc [ dataOneIndices ] [EOL] dataTwoPositive = studiedUserData . iloc [ dataTwoIndices ] [EOL] [EOL] splitter = ShuffleSplit ( n_splits = [number] , train_size = [number] , test_size = None ) [EOL] trainIndices , testIndices = list ( splitter . split ( dataOne ) ) [ [number] ] [EOL] [EOL] train = dataOne . iloc [ trainIndices ] [EOL] test = dataOne . iloc [ testIndices ] [EOL] [EOL] grid = { [string] : np . logspace ( - [number] , [number] , [number] ) , [string] : np . linspace ( [number] , [number] , [number] ) } [EOL] [EOL] bestRecall = [number] [EOL] bestRecallParameters = None [EOL] [EOL] for hyperparams in ParameterGrid ( grid ) : [EOL] model = Model ( nu = hyperparams [ [string] ] , gamma = hyperparams [ [string] ] ) [EOL] model . fit ( train ) [EOL] report = Model . evaluate ( model , train , test ) [EOL] [EOL] if report [ [string] ] > bestRecall : [EOL] print ( [string] . format ( report [ [string] ] , report [ [string] ] , report [ [string] ] , report [ [string] ] ) ) [EOL] bestRecall = report [ [string] ] [EOL] bestRecallParameters = { [string] : hyperparams [ [string] ] , [string] : hyperparams [ [string] ] } [EOL] [EOL] if bestRecallParameters is not None : [EOL] print ( [string] . format ( bestRecallParameters [ [string] ] , bestRecallParameters [ [string] ] ) ) [EOL] [EOL] [EOL] def gridSearchCV ( user , data , columns ) : [EOL] studiedUserData , otherUsersData = getUserData ( user , data , columns ) [EOL] [EOL] [comment] [EOL] splitter = ShuffleSplit ( n_splits = [number] , train_size = [number] , test_size = None ) [EOL] dataOneIndices , dataTwoIndices = list ( splitter . split ( studiedUserData ) ) [ [number] ] [EOL] [EOL] dataOne = studiedUserData . iloc [ dataOneIndices ] [EOL] dataTwoPositive = studiedUserData . iloc [ dataTwoIndices ] [EOL] [EOL] model = Model ( ) [EOL] gs = GridSearchCV ( estimator = model , param_grid = { [string] : np . linspace ( [number] , [number] , [number] ) , [string] : np . logspace ( - [number] , [number] , [number] ) } , cv = [number] , iid = False ) [EOL] [EOL] gs . fit ( dataOne , list ( [ [number] for i in range ( len ( dataOne . index ) ) ] ) ) [EOL] shortParams = { [string] : gs . best_params_ [ [string] ] , [string] : gs . best_params_ [ [string] ] } [EOL] [EOL] print ( [string] . format ( shortParams [ [string] ] , shortParams [ [string] ] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] data = Data ( ) [EOL] [EOL] columns = [ [string] + str ( index ) for index in range ( [number] ) ] [EOL] columns . extend ( [ [string] + str ( index ) for index in range ( [number] ) ] ) [EOL] columns . extend ( [ [string] + str ( index ) for index in range ( [number] ) ] ) [EOL] columns . extend ( [ [string] + str ( index ) for index in range ( [number] ) ] ) [EOL] [EOL] studiedUserData , otherUsersData = getUserData ( [number] , data , columns ) [EOL] [EOL] [comment] [EOL] splitter = ShuffleSplit ( n_splits = [number] , train_size = [number] , test_size = None ) [EOL] dataOneIndices , dataTwoIndices = list ( splitter . split ( studiedUserData ) ) [ [number] ] [EOL] [EOL] dataOne = studiedUserData . iloc [ dataOneIndices ] [EOL] dataTwoPositive = studiedUserData . iloc [ dataTwoIndices ] [EOL] [EOL] model = Model ( ) [EOL] params = Model . findParameters ( model , dataOne ) [EOL] results = Model . report ( params [ [string] ] , dataOne , dataTwoPositive , otherUsersData ) [EOL] print ( results )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Model.Model.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Model.Model.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 $Model.Model.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $Model.Model.Model$ 0 0 0 0 0 0 0 0 0 0 0 $Model.Model.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $Model.Model.Model$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $Model.Model.Model$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0