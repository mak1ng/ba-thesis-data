from typing import List [EOL] import typing [EOL] import nox [EOL] [EOL] [EOL] py_versions = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ nox . session ( python = py_versions , reuse_venv = True ) def blacken ( session ) : [EOL] session . install ( [string] ) [EOL] session . run ( [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ nox . session ( python = py_versions , reuse_venv = True ) def lint ( session ) : [EOL] session . install ( [string] ) [EOL] session . run ( [string] , [string] ) [EOL] session . run ( [string] , [string] ) [EOL] [EOL] [EOL] @ nox . session ( python = py_versions , reuse_venv = True ) def type_check ( session ) : [EOL] session . install ( [string] ) [EOL] session . run ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ nox . session ( python = py_versions , reuse_venv = True ) @ nox . parametrize ( [string] , [ [string] , [string] ] ) def test ( session , pandas ) : [EOL] session . install ( [string] , [string] ) [EOL] session . install ( [string] , [string] ) [EOL] session . run ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import fables [EOL] import fables [EOL] [EOL] [EOL] tree = fables . detect ( io = [string] ) [EOL] print ( tree ) [EOL] [EOL] for parse_result in fables . parse ( tree = tree ) : [EOL] errors = parse_result . errors [EOL] tables = parse_result . tables [EOL] [EOL] if errors : [EOL] for error in errors : [EOL] print ( error ) [EOL] if tables : [EOL] for table in tables : [EOL] print ( table ) [EOL]	0 0 0 0 0 0 0 0 $fables.tree.FileNode$ 0 0 0 0 0 0 0 0 0 0 0 0 $fables.tree.FileNode$ 0 0 0 0 0 0 0 0 0 0 $fables.tree.FileNode$ 0 $fables.tree.FileNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from fables . api import detect , parse [EOL] from fables . tree import ( StreamManager , FileNode , MimeTypeFileNode , Directory , Zip , Csv , Xls , Xlsx , Xlsb , Skip , mimetype_from_stream , mimetype_and_extension , ) [EOL] from fables . table import Table [EOL] from fables . errors import ParseError , ExtractError [EOL] from fables . constants import OS_PATTERNS_TO_SKIP , MAX_FILE_SIZE [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from dataclasses import dataclass [EOL] from typing import Optional , Type [EOL] [EOL] [EOL] @ dataclass class Error : [EOL] message = ... [EOL] exception_type = ... [EOL] name = None [EOL] sheet = None [EOL] [EOL] [EOL] @ dataclass class ParseError ( Error ) : [EOL] pass [EOL] [EOL] [EOL] @ dataclass class ExtractError ( Error ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[builtins.Exception]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from dataclasses import dataclass [EOL] from typing import List , Optional [EOL] [EOL] from fables . table import Table [EOL] from fables . errors import ParseError [EOL] [EOL] [EOL] @ dataclass class ParseResult : [EOL] name = ... [EOL] tables = ... [EOL] errors = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.List[fables.table.Table]$ 0 0 0 $typing.List[fables.errors.ParseError]$ 0 0 0
from typing import Optional , Any , Tuple , IO , Union , Dict , Iterable [EOL] import fables [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] from io import BufferedIOBase [EOL] from typing import Any , Dict , IO , Iterable , Optional , Tuple , Union [EOL] [EOL] from fables . constants import MAX_FILE_SIZE [EOL] from fables . parse import ParseVisitor [EOL] from fables . results import ParseResult [EOL] from fables . tree import FileNode , node_from_file [EOL] [EOL] [EOL] def _check_file_size ( name ) : [EOL] file_size = os . stat ( name ) . st_size [EOL] return file_size > MAX_FILE_SIZE , file_size [EOL] [EOL] [EOL] def _check_stream_size ( stream ) : [EOL] stream . seek ( [number] , [number] ) [EOL] stream_size = stream . tell ( ) [EOL] stream . seek ( [number] ) [EOL] return stream_size > MAX_FILE_SIZE , stream_size [EOL] [EOL] [EOL] def _parse_user_input ( io , calling_func_name , password = None , passwords = { } , stream_file_name = None , ) : [EOL] if isinstance ( io , str ) : [EOL] stream = None [EOL] name = io [EOL] if not os . path . exists ( io ) : [EOL] raise ValueError ( f" [string] { calling_func_name } [string] " ) [EOL] size_is_too_big , size = _check_file_size ( name ) [EOL] else : [EOL] if not isinstance ( io , BufferedIOBase ) : [EOL] raise TypeError ( f" [string] { calling_func_name } [string] " + [string] ) [EOL] stream = io [EOL] name = getattr ( stream , [string] , stream_file_name ) [EOL] size_is_too_big , size = _check_stream_size ( stream ) [EOL] [EOL] if size_is_too_big : [EOL] raise ValueError ( f" [string] { calling_func_name } [string] { name } [string] " + f" [string] { size } [string] " + f"{ MAX_FILE_SIZE } [string] " ) [EOL] [EOL] if passwords is not None and not isinstance ( passwords , dict ) : [EOL] raise ValueError ( f" [string] { calling_func_name } [string] " ) [EOL] [EOL] if password is not None and not isinstance ( password , str ) : [EOL] raise ValueError ( f" [string] { calling_func_name } [string] " ) [EOL] [EOL] if passwords is None : [EOL] passwords = { } [EOL] [EOL] if name is not None and password is not None : [EOL] passwords [ name ] = password [EOL] [EOL] return name , stream , passwords [EOL] [EOL] [EOL] def detect ( io , * , calling_func_name = None , password = None , passwords = None , stream_file_name = None , ) : [EOL] if calling_func_name is None : [EOL] calling_func_name = [string] [EOL] name , stream , passwords = _parse_user_input ( io = io , calling_func_name = calling_func_name , password = password , passwords = passwords , stream_file_name = stream_file_name , ) [EOL] return node_from_file ( name = name , stream = stream , passwords = passwords ) [EOL] [EOL] [EOL] def parse ( io = None , * , tree = None , password = None , passwords = None , stream_file_name = None , force_numeric = True , pandas_kwargs = { } , ) : [EOL] if tree is None : [EOL] if io is None : [EOL] raise ValueError ( [string] + [string] ) [EOL] tree = detect ( io = io , calling_func_name = [string] , password = password , passwords = passwords , stream_file_name = stream_file_name , ) [EOL] [EOL] visitor = ParseVisitor ( force_numeric = force_numeric , pandas_kwargs = pandas_kwargs ) [EOL] yield from visitor . visit ( tree ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[fables.results.ParseResult]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Iterator , Any , Tuple , List , IO , Dict [EOL] import typing [EOL] import zipfile [EOL] import fables [EOL] import io [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import io [EOL] import os [EOL] import zipfile [EOL] from fnmatch import fnmatch [EOL] from typing import Dict , IO , Iterator , List , Optional , Tuple [EOL] [EOL] import magic [EOL] from msoffcrypto import OfficeFile [comment] [EOL] from msoffcrypto . __main__ import is_encrypted [EOL] [EOL] from fables . constants import OS_PATTERNS_TO_SKIP [EOL] from fables . errors import ExtractError [EOL] [EOL] [EOL] UNEXPECTED_DECRYPTION_EXCEPTION_MESSAGE = ( [string] ) [EOL] [EOL] [EOL] class IncorrectPassword ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class StreamManager : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , stream ) : [EOL] self . name = name [EOL] self . stream = stream [EOL] if self . stream is not None : [EOL] self . stream . seek ( [number] ) [EOL] self . opened_stream = None [EOL] [EOL] def __enter__ ( self ) : [EOL] if self . stream is not None : [EOL] self . stream . seek ( [number] ) [EOL] return self . stream [EOL] [EOL] if self . name is None : [EOL] raise RuntimeError ( [string] + [string] ) [EOL] [EOL] self . opened_stream = open ( self . name , [string] ) [EOL] return self . opened_stream [EOL] [EOL] def __exit__ ( self , * exc ) : [comment] [EOL] if self . opened_stream is not None and hasattr ( self . opened_stream , [string] ) : [EOL] self . opened_stream . close ( ) [EOL] [EOL] [EOL] class FileNode : [EOL] def __init__ ( self , * , name = None , stream = None , mimetype = None , extension = None , passwords = { } , ) : [EOL] self . name = name or getattr ( stream , [string] , None ) [EOL] self . _stream = stream [EOL] self . mimetype = mimetype [EOL] self . extension = extension [EOL] self . passwords = passwords [EOL] [EOL] self . extract_errors = [ ] [EOL] [EOL] self . _decrypted_stream = None [EOL] [EOL] @ property def empty ( self ) : [EOL] return self . mimetype == [string] [EOL] [EOL] @ property def stream ( self ) : [EOL] [docstring] [EOL] return StreamManager ( name = self . name , stream = self . _stream ) [EOL] [EOL] @ property def children ( self ) : [EOL] yield from [ ] [EOL] [EOL] @ property def encrypted ( self ) : [EOL] return False [EOL] [EOL] def add_password ( self , name , password ) : [EOL] self . passwords [ name ] = password [EOL] [EOL] @ property def password ( self ) : [EOL] [docstring] [EOL] if self . name is None : [EOL] return None [EOL] [EOL] match_metrics = [ ] [EOL] for path , password in self . passwords . items ( ) : [EOL] is_match = fnmatch ( self . name , f" [string] { path }" ) [EOL] match_metrics . append ( ( is_match , len ( path ) , password ) ) [EOL] [EOL] if not match_metrics : [EOL] return None [EOL] [EOL] [comment] [EOL] return sorted ( match_metrics , reverse = True ) [ [number] ] [ - [number] ] [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . __class__ . __name__ } [string] { self . name } [string] { self . mimetype } [string] " [EOL] [EOL] [EOL] class MimeTypeFileNode ( FileNode ) : [EOL] MIMETYPES = [ ] [EOL] EXTENSIONS = [ ] [EOL] EXTENSIONS_TO_EXCLUDE = [ ] [EOL] [EOL] @ classmethod def is_my_mimetype_or_extension ( cls , mimetype , extension ) : [EOL] mimetype = mimetype or [string] [EOL] extension = ( extension or [string] ) . lower ( ) [EOL] if mimetype in cls . MIMETYPES : [EOL] [comment] [EOL] if ( mimetype == cls . MIMETYPES [ [number] ] [EOL] and extension not in cls . EXTENSIONS_TO_EXCLUDE ) : [EOL] return True [EOL] [comment] [EOL] elif extension in cls . EXTENSIONS : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] class Zip ( MimeTypeFileNode ) : [EOL] MIMETYPES = [ [string] ] [EOL] EXTENSIONS = [ [string] ] [EOL] EXTENSIONS_TO_EXCLUDE = [ [string] , [string] ] [EOL] [EOL] @ property def _bytes_password ( self ) : [EOL] str_password = self . password [EOL] if str_password is not None : [EOL] return str_password . encode ( [string] ) [EOL] return None [EOL] [EOL] @ staticmethod def _encrypted_from_bit_signature ( zf ) : [EOL] [docstring] [EOL] return bool ( zf . infolist ( ) [ [number] ] . flag_bits & [number] ) [EOL] [EOL] def _password_decrypts ( self ) : [EOL] if self . password is None : [EOL] return False [EOL] [EOL] with self . stream as node_stream : [EOL] with zipfile . ZipFile ( node_stream ) as zf : [EOL] first_child_file = zf . namelist ( ) [ [number] ] [EOL] try : [EOL] zf . open ( first_child_file , pwd = self . _bytes_password ) [EOL] return True [EOL] except RuntimeError as e : [EOL] if [string] in str ( e ) : [EOL] return False [EOL] else : [EOL] raise RuntimeError ( UNEXPECTED_DECRYPTION_EXCEPTION_MESSAGE . format ( self . name , str ( e ) ) ) [EOL] [EOL] @ property def encrypted ( self ) : [EOL] with self . stream as node_stream : [EOL] with zipfile . ZipFile ( node_stream ) as zf : [EOL] if self . _encrypted_from_bit_signature ( zf ) : [EOL] return not self . _password_decrypts ( ) [EOL] return False [EOL] [EOL] @ property def children ( self ) : [EOL] try : [EOL] with self . stream as node_stream : [EOL] with zipfile . ZipFile ( node_stream ) as zf : [EOL] for child_file in zf . namelist ( ) : [EOL] with zf . open ( child_file , pwd = self . _bytes_password ) as child_stream : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] bytes_stream = io . BytesIO ( child_stream . read ( ) ) [EOL] if self . name is not None : [EOL] child_file_path = os . path . join ( os . path . basename ( self . name ) , child_file ) [EOL] yield node_from_file ( name = child_file_path , stream = bytes_stream , passwords = self . passwords , ) [EOL] else : [EOL] yield node_from_file ( name = child_file , stream = bytes_stream , passwords = self . passwords , ) [EOL] except RuntimeError as e : [EOL] extract_error = ExtractError ( message = str ( e ) , exception_type = type ( e ) , name = self . name ) [EOL] self . extract_errors . append ( extract_error ) [EOL] [EOL] [EOL] class ExcelEncryptionMixin ( FileNode ) : [EOL] def __init__ ( self , ** kwargs ) : [comment] [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] self . _raw_stream_mgr = super ( ) . stream [EOL] self . _decrypted_stream = None [EOL] [EOL] @ staticmethod def decrypt ( encrypted_stream , password ) : [EOL] try : [EOL] office_file = OfficeFile ( encrypted_stream ) [EOL] decrypted_stream = io . BytesIO ( ) [EOL] office_file . load_key ( password = password ) [EOL] office_file . decrypt ( decrypted_stream ) [EOL] decrypted_stream . seek ( [number] ) [EOL] return decrypted_stream [EOL] except Exception as e : [EOL] [comment] [EOL] [comment] [EOL] if [string] in str ( e ) : [EOL] raise IncorrectPassword ( ) [EOL] else : [EOL] raise RuntimeError ( UNEXPECTED_DECRYPTION_EXCEPTION_MESSAGE . format ( getattr ( encrypted_stream , [string] , None ) , str ( e ) ) ) [EOL] [EOL] @ property def encrypted ( self ) : [EOL] with self . _raw_stream_mgr as raw_stream : [EOL] if is_encrypted ( raw_stream ) : [EOL] if self . password is not None : [EOL] try : [comment] [EOL] self . _decrypted_stream = self . decrypt ( raw_stream , self . password ) [EOL] return False [EOL] except IncorrectPassword : [EOL] pass [EOL] return True [EOL] return False [EOL] [EOL] @ property def stream ( self ) : [EOL] if not self . encrypted and self . _decrypted_stream is not None : [EOL] return StreamManager ( self . name , self . _decrypted_stream ) [EOL] else : [EOL] return self . _raw_stream_mgr [EOL] [EOL] [EOL] class Xlsx ( MimeTypeFileNode , ExcelEncryptionMixin ) : [EOL] MIMETYPES = [ [string] , [string] , [string] , ] [EOL] EXTENSIONS = [ [string] ] [EOL] EXTENSIONS_TO_EXCLUDE = [ [string] ] [EOL] [EOL] [EOL] class Xlsb ( MimeTypeFileNode , ExcelEncryptionMixin ) : [EOL] MIMETYPES = [ [string] , [string] , [string] , [string] , ] [EOL] EXTENSIONS = [ [string] ] [EOL] EXTENSIONS_TO_EXCLUDE = [ [string] ] [EOL] [EOL] [EOL] class Xls ( MimeTypeFileNode , ExcelEncryptionMixin ) : [EOL] MIMETYPES = [ [string] , [string] ] [EOL] EXTENSIONS = [ [string] ] [EOL] [EOL] [EOL] class Csv ( MimeTypeFileNode ) : [EOL] MIMETYPES = [ [string] , [string] ] [EOL] EXTENSIONS = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] class Directory ( FileNode ) : [EOL] @ property def children ( self ) : [EOL] for child_name in os . listdir ( self . name ) : [EOL] child_path = os . path . join ( self . name , child_name ) [EOL] node = node_from_file ( name = child_path , passwords = self . passwords ) [EOL] yield node [EOL] [EOL] [EOL] class Skip ( FileNode ) : [EOL] pass [EOL] [EOL] [EOL] def mimetype_from_stream ( stream ) : [EOL] if stream is None : [EOL] return None [EOL] [EOL] mimebytes = stream . read ( ) [EOL] mimetype = magic . from_buffer ( mimebytes , mime = True ) [EOL] stream . seek ( [number] ) [EOL] [EOL] return mimetype [EOL] [EOL] [EOL] def extension_from_name ( name ) : [EOL] _ , ext = os . path . splitext ( name ) [EOL] if ext : [EOL] return ext . lstrip ( [string] ) [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def mimetype_and_extension ( * , name = None , stream = None ) : [EOL] if name is not None and stream is None : [EOL] with open ( name , [string] ) as byte_stream : [EOL] mimetype = mimetype_from_stream ( byte_stream ) [EOL] else : [EOL] mimetype = mimetype_from_stream ( stream ) [EOL] [EOL] if name is None : [EOL] extension = None [EOL] else : [EOL] extension = extension_from_name ( name ) [EOL] [EOL] return mimetype , extension [EOL] [EOL] [EOL] def node_from_file ( * , name = None , stream = None , passwords = { } , ) : [EOL] if name is not None and any ( pattern in name for pattern in OS_PATTERNS_TO_SKIP ) : [EOL] return Skip ( name = name , stream = stream ) [EOL] [EOL] if name is not None and os . path . isdir ( name ) : [EOL] return Directory ( name = name , stream = stream , passwords = passwords ) [EOL] [EOL] mimetype , extension = mimetype_and_extension ( name = name , stream = stream ) [EOL] [EOL] for node_type in MimeTypeFileNode . __subclasses__ ( ) : [EOL] if node_type . is_my_mimetype_or_extension ( mimetype , extension ) : [EOL] node = node_type ( name = name , stream = stream , mimetype = mimetype , extension = extension , passwords = passwords , ) [EOL] return node [EOL] [EOL] return Skip ( name = name , stream = stream , mimetype = mimetype , extension = extension ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.List[fables.errors.ExtractError]$ 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $StreamManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator["FileNode"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bool,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bool,builtins.int,builtins.str]]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bool,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bool,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 $zipfile.ZipFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[FileNode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fables.errors.ExtractError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fables.errors.ExtractError$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $StreamManager$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 $typing.IO[builtins.bytes]$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.IO[builtins.bytes]$ 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $io.BytesIO$ 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $StreamManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[FileNode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fables.tree.FileNode$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $fables.tree.FileNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FileNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from dataclasses import dataclass [EOL] from typing import Optional [EOL] [EOL] import pandas as pd [comment] [EOL] [EOL] [EOL] @ dataclass class Table : [EOL] df = ... [EOL] name = None [EOL] sheet = None [EOL] [EOL] def __str__ ( self ) : [EOL] s = ( f"{ self . __class__ . __name__ } [string] " + f" [string] { len ( self . df ) } [string] { len ( self . df . columns ) } [string] " + f" [string] { self . name } [string] " + f" [string] { self . sheet } [string] " ) [EOL] return s . replace ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] OS_PATTERNS_TO_SKIP = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] MAX_FILE_SIZE = [number] ** [number] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
	0
import sys [EOL] import os [EOL] [EOL] sys . path . insert ( [number] , os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) ) [EOL] [EOL] import fables [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import fables [EOL] import typing [EOL] import io [EOL] import os [EOL] [EOL] import pytest [EOL] [EOL] from tests . context import fables [EOL] from tests . integration . constants import DATA_DIR [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , fables . Csv , [string] , [string] , [number] ) , ( [string] , fables . Xlsx , [string] , [string] , [number] , ) , ( [string] , fables . Xlsx , [string] , [string] , [number] ) , ( [string] , fables . Xlsx , [string] , [string] , [number] ) , ( [string] , fables . Xls , [string] , [string] , [number] ) , ( [string] , fables . Xls , [string] , [string] , [number] ) , ( [string] , fables . Zip , [string] , [string] , [number] ) , ( [string] , fables . Zip , [string] , [string] , [number] ) , ( [string] , fables . Directory , None , None , [number] ) , ( [string] , fables . Csv , [string] , [string] , [number] ) , ( [string] , fables . Csv , [string] , [string] , [number] ) , ( [string] , fables . Skip , [string] , [string] , [number] ) , ( os . path . join ( [string] , [string] ) , fables . Skip , None , None , [number] ) , ] , ) def test_it_detects_file_metadata ( name , node_type , mimetype , extension , num_children ) : [EOL] path = os . path . join ( DATA_DIR , name ) [EOL] node = fables . detect ( io = path ) [EOL] [EOL] assert isinstance ( node , node_type ) [EOL] assert node . mimetype == mimetype [EOL] assert node . extension == extension [EOL] assert len ( list ( node . children ) ) == num_children [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , False ) , ( [string] , True ) , ( [string] , False ) , ( [string] , True ) , ( [string] , False ) , ( [string] , True ) , ( [string] , False ) , ] , ) def test_it_detects_when_a_file_is_encrypted ( name , expected_to_be_encrypted ) : [EOL] path = os . path . join ( DATA_DIR , name ) [EOL] node = fables . detect ( io = path ) [EOL] assert node . encrypted is expected_to_be_encrypted [EOL] [EOL] [EOL] def test_it_raises_a_value_error_for_a_file_name_that_does_not_exist_on_disk ( ) : [EOL] missing_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as e : [EOL] fables . detect ( io = missing_name ) [EOL] [EOL] exception_msg = str ( e . value ) [EOL] assert [string] in exception_msg [EOL] [EOL] [EOL] def test_it_raises_a_type_error_for_stream_not_read_in_bytes_mode ( ) : [EOL] csv_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] with open ( csv_name , [string] ) as textio : [EOL] with pytest . raises ( TypeError ) as e : [EOL] fables . detect ( io = textio ) [EOL] [EOL] exception_msg = str ( e . value ) [EOL] assert [string] in exception_msg [EOL] assert [string] in exception_msg [EOL] [EOL] [EOL] def test_it_detects_when_a_file_is_empty ( ) : [EOL] node = fables . detect ( io . BytesIO ( [string] ) ) [EOL] assert node . mimetype == [string] [EOL] assert node . empty [EOL] [EOL] node = fables . detect ( io . BytesIO ( [string] ) ) [EOL] assert node . mimetype != [string] [EOL] assert not node . empty [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import fables [EOL] import typing [EOL] import io [EOL] import io [EOL] import os [EOL] [EOL] from tests . context import fables [EOL] from tests . integration . constants import DATA_DIR [EOL] [EOL] [EOL] def test_zip_children_nodes_have_file_name_for_named_stream ( ) : [EOL] [docstring] [EOL] zip_file = [string] [EOL] zip_path = os . path . join ( DATA_DIR , zip_file ) [EOL] expected_children_names = { os . path . join ( zip_file , [string] ) , os . path . join ( zip_file , [string] ) , } [EOL] [EOL] with open ( zip_path , [string] ) as zip_stream : [EOL] tree = fables . detect ( zip_stream ) [EOL] [EOL] children_names = set ( ) [EOL] for child in tree . children : [EOL] children_names . add ( child . name ) [EOL] assert children_names == expected_children_names [EOL] [EOL] [EOL] def test_zip_children_nodes_have_file_name_for_nameless_stream ( ) : [EOL] [docstring] [EOL] zip_path = os . path . join ( DATA_DIR , [string] ) [EOL] expected_children_names = { [string] , [string] } [EOL] [EOL] with open ( zip_path , [string] ) as zip_stream : [EOL] nameless_stream = io . BytesIO ( zip_stream . read ( ) ) [EOL] nameless_stream . seek ( [number] ) [EOL] [EOL] tree = fables . detect ( nameless_stream ) [EOL] [EOL] children_names = set ( ) [EOL] for child in tree . children : [EOL] children_names . add ( child . name ) [EOL] assert children_names == expected_children_names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] [EOL] DATA_DIR = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] HRIS_DATA_DIR = os . path . join ( DATA_DIR , [string] ) [EOL]	0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Any [EOL] import fables [EOL] import typing [EOL] import os [EOL] import pytest [EOL] [EOL] from tests . context import fables [EOL] from tests . integration . constants import DATA_DIR [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ] , ) def test_it_unlocks_files_when_the_password_is_correct ( name , password , expected_to_be_encrypted ) : [EOL] path = os . path . join ( DATA_DIR , name ) [EOL] [EOL] [comment] [EOL] node = fables . detect ( path , passwords = { path : password } ) [EOL] assert node . password == password [EOL] assert node . passwords == { path : password } [EOL] assert node . encrypted is expected_to_be_encrypted [EOL] [EOL] [comment] [EOL] node = fables . detect ( path , password = password ) [EOL] assert node . password == password [EOL] assert node . passwords == { path : password } [EOL] assert node . encrypted is expected_to_be_encrypted [EOL] [EOL] [EOL] def test_it_raises_an_exception_when_decrypting_a_corrupt_file ( ) : [EOL] corrupt_xlsx_path = os . path . join ( DATA_DIR , [string] ) [EOL] with pytest . raises ( RuntimeError ) as e : [EOL] with open ( corrupt_xlsx_path , [string] ) as corrupt_xlsx_stream : [EOL] node = fables . detect ( io = corrupt_xlsx_stream ) [EOL] with node . stream as node_stream : [EOL] node . decrypt ( node_stream , [string] ) [EOL] [EOL] exception_msg = str ( e . value ) [EOL] assert corrupt_xlsx_path in exception_msg [EOL] assert [string] in exception_msg [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import os [EOL] import xml [EOL] [EOL] import numpy as np [EOL] import pytest [EOL] import pandas as pd [EOL] [EOL] from tests . context import fables [EOL] from tests . integration . constants import DATA_DIR [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] AB_DF = pd . DataFrame ( columns = [ [string] , [string] ] , data = [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ABC_DF = pd . DataFrame ( columns = [ [string] , [string] , [string] ] , data = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [EOL] [EOL] def _it_parses_a_csv ( csv_name , expected_df ) : [EOL] parse_results = list ( fables . parse ( io = csv_name ) ) [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert parse_result . name == csv_name [EOL] assert len ( parse_result . errors ) == [number] [EOL] assert len ( parse_result . tables ) == [number] [EOL] [EOL] table = parse_result . tables [ [number] ] [EOL] assert table . name == csv_name [EOL] assert table . sheet is None [EOL] [EOL] pd . testing . assert_frame_equal ( table . df , expected_df , check_dtype = False ) [EOL] [EOL] assert not parse_results [ [number] ] . errors [EOL] [EOL] [EOL] def test_it_parses_a_csv ( ) : [EOL] csv_name = os . path . join ( DATA_DIR , [string] ) [EOL] _it_parses_a_csv ( csv_name , AB_DF ) [EOL] [EOL] [EOL] def test_it_parses_a_csv_with_only_a_header ( ) : [EOL] csv_name = os . path . join ( DATA_DIR , [string] ) [EOL] expected_df = pd . DataFrame ( columns = [ [string] , [string] ] , data = [ ] ) [EOL] _it_parses_a_csv ( csv_name , expected_df ) [EOL] [EOL] [EOL] def test_stream_parse_is_the_same_as_disk_parse ( ) : [EOL] csv_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] with open ( csv_name , [string] ) as buffered_io : [EOL] stream_results = list ( fables . parse ( io = buffered_io ) ) [EOL] [EOL] disk_results = list ( fables . parse ( io = csv_name ) ) [EOL] [EOL] assert len ( stream_results ) == len ( disk_results ) [EOL] assert len ( stream_results [ [number] ] . tables ) == len ( disk_results [ [number] ] . tables ) [EOL] [EOL] stream_result = stream_results [ [number] ] [EOL] disk_result = disk_results [ [number] ] [EOL] assert stream_result . name == csv_name [EOL] assert disk_result . name == csv_name [EOL] [EOL] stream_table = stream_result . tables [ [number] ] [EOL] disk_table = disk_result . tables [ [number] ] [EOL] [EOL] assert stream_table . name == disk_table . name [EOL] pd . testing . assert_frame_equal ( stream_table . df , disk_table . df , check_dtype = False ) [EOL] [EOL] [EOL] def _it_parses_an_excel_file_with_one_sheet ( excel_name , expected_df , passwords = { } ) : [EOL] parse_results = list ( fables . parse ( io = excel_name , passwords = passwords ) ) [EOL] [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert parse_result . name == excel_name [EOL] tables = parse_result . tables [EOL] errors = parse_result . errors [EOL] assert len ( tables ) == [number] [EOL] assert len ( errors ) == [number] [EOL] [EOL] table = tables [ [number] ] [EOL] assert table . name == excel_name [EOL] assert table . sheet == [string] [EOL] [EOL] pd . testing . assert_frame_equal ( table . df , expected_df , check_dtype = False ) [EOL] [EOL] [EOL] def test_it_parses_a_xlsx_with_one_sheet ( ) : [EOL] xlsx_name = os . path . join ( DATA_DIR , [string] ) [EOL] _it_parses_an_excel_file_with_one_sheet ( xlsx_name , AB_DF ) [EOL] [EOL] [EOL] def test_it_parses_a_xlsb_with_one_sheet ( ) : [EOL] xlsb_name = os . path . join ( DATA_DIR , [string] ) [EOL] _it_parses_an_excel_file_with_one_sheet ( xlsb_name , AB_DF ) [EOL] [EOL] [EOL] def test_it_parses_a_xlsb_with_only_a_header ( ) : [EOL] only_xlsb_name = os . path . join ( DATA_DIR , [string] ) [EOL] expected_df = pd . DataFrame ( columns = [ [string] , [string] ] , data = [ ] ) [EOL] _it_parses_an_excel_file_with_one_sheet ( only_xlsb_name , expected_df ) [EOL] [EOL] [EOL] def test_it_parses_a_xlsb_with_many_sheets ( ) : [EOL] xlsb_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] parse_results = list ( fables . parse ( io = xlsb_name ) ) [EOL] [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert parse_result . name == xlsb_name [EOL] tables = parse_result . tables [EOL] errors = parse_result . errors [EOL] assert len ( tables ) == [number] [EOL] assert len ( errors ) == [number] [EOL] [EOL] table1 , table2 = tables [EOL] assert table1 . name == xlsb_name [EOL] assert table1 . sheet == [string] [EOL] assert table2 . name == xlsb_name [EOL] assert table2 . sheet == [string] [EOL] [EOL] expected_sheet1_df = AB_DF [EOL] pd . testing . assert_frame_equal ( table1 . df , expected_sheet1_df , check_dtype = False ) [EOL] [EOL] expected_sheet2_df = pd . DataFrame ( columns = [ [string] , [string] ] , data = [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] pd . testing . assert_frame_equal ( table2 . df , expected_sheet2_df , check_dtype = False ) [EOL] [EOL] [EOL] def test_it_parses_a_xlsx_with_many_sheets ( ) : [EOL] xlsx_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] parse_results = list ( fables . parse ( io = xlsx_name ) ) [EOL] [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert parse_result . name == xlsx_name [EOL] tables = parse_result . tables [EOL] errors = parse_result . errors [EOL] assert len ( tables ) == [number] [EOL] assert len ( errors ) == [number] [EOL] [EOL] table1 , table2 = tables [EOL] assert table1 . name == xlsx_name [EOL] assert table1 . sheet == [string] [EOL] assert table2 . name == xlsx_name [EOL] assert table2 . sheet == [string] [EOL] [EOL] expected_sheet1_df = AB_DF [EOL] pd . testing . assert_frame_equal ( table1 . df , expected_sheet1_df , check_dtype = False ) [EOL] [EOL] expected_sheet2_df = pd . DataFrame ( columns = [ [string] , [string] ] , data = [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] pd . testing . assert_frame_equal ( table2 . df , expected_sheet2_df , check_dtype = False ) [EOL] [EOL] [EOL] def test_it_parses_a_xlsx_with_only_a_header ( ) : [EOL] xlsx_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] parse_results = list ( fables . parse ( io = xlsx_name ) ) [EOL] [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert parse_result . name == xlsx_name [EOL] tables = parse_result . tables [EOL] errors = parse_result . errors [EOL] assert len ( tables ) == [number] [EOL] assert len ( errors ) == [number] [EOL] [EOL] table = tables [ [number] ] [EOL] assert table . sheet == [string] [EOL] assert table . name == xlsx_name [EOL] [EOL] expected_df = pd . DataFrame ( columns = [ [string] , [string] ] , data = [ ] ) [EOL] pd . testing . assert_frame_equal ( table . df , expected_df , check_dtype = False ) [EOL] [EOL] [EOL] def test_it_parses_a_xlsx_with_only_one_cell_filled ( ) : [EOL] xlsx_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] parse_results = list ( fables . parse ( io = xlsx_name ) ) [EOL] [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert parse_result . name == xlsx_name [EOL] tables = parse_result . tables [EOL] errors = parse_result . errors [EOL] assert len ( tables ) == [number] [EOL] assert len ( errors ) == [number] [EOL] [EOL] table = tables [ [number] ] [EOL] assert table . sheet == [string] [EOL] assert table . name == xlsx_name [EOL] [EOL] expected_df = pd . DataFrame ( columns = [ [string] ] , data = [ ] ) [EOL] pd . testing . assert_frame_equal ( table . df , expected_df , check_dtype = False ) [EOL] [EOL] [EOL] def test_it_parses_a_xls_with_one_sheet ( ) : [EOL] xls_name = os . path . join ( DATA_DIR , [string] ) [EOL] _it_parses_an_excel_file_with_one_sheet ( xls_name , AB_DF ) [EOL] [EOL] [EOL] def test_it_parses_a_xls_with_many_sheets ( ) : [EOL] xls_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] parse_results = list ( fables . parse ( io = xls_name ) ) [EOL] [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert parse_result . name == xls_name [EOL] tables = parse_result . tables [EOL] errors = parse_result . errors [EOL] assert len ( tables ) == [number] [EOL] assert len ( errors ) == [number] [EOL] [EOL] table1 , table2 = tables [EOL] assert table1 . name == xls_name [EOL] assert table1 . sheet == [string] [EOL] assert table2 . name == xls_name [EOL] assert table2 . sheet == [string] [EOL] [EOL] expected_sheet1_df = AB_DF [EOL] pd . testing . assert_frame_equal ( table1 . df , expected_sheet1_df , check_dtype = False ) [EOL] [EOL] expected_sheet2_df = pd . DataFrame ( columns = [ [string] , [string] ] , data = [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] pd . testing . assert_frame_equal ( table2 . df , expected_sheet2_df , check_dtype = False ) [EOL] [EOL] [EOL] def _validate_basic_csv_and_basic_xlsx_together ( parse_results , child_names ) : [EOL] assert len ( parse_results ) == [number] [EOL] csv_name = [ cn for cn in child_names if cn . endswith ( [string] ) ] [ [number] ] [EOL] xlsx_name = [ cn for cn in child_names if cn . endswith ( [string] ) ] [ [number] ] [EOL] [EOL] csv_results = [ pr for pr in parse_results if pr . name == csv_name ] [EOL] xlsx_results = [ pr for pr in parse_results if pr . name == xlsx_name ] [EOL] [EOL] assert len ( csv_results ) == [number] [EOL] assert len ( xlsx_results ) == [number] [EOL] [EOL] csv_result = csv_results [ [number] ] [EOL] xlsx_result = xlsx_results [ [number] ] [EOL] [EOL] assert len ( csv_result . tables ) == [number] [EOL] assert len ( csv_result . errors ) == [number] [EOL] assert len ( xlsx_result . tables ) == [number] [EOL] assert len ( xlsx_result . errors ) == [number] [EOL] [EOL] csv_table = csv_result . tables [ [number] ] [EOL] pd . testing . assert_frame_equal ( csv_table . df , AB_DF , check_dtype = False ) [EOL] assert csv_table . name == csv_name [EOL] [EOL] xlsx_table = xlsx_result . tables [ [number] ] [EOL] pd . testing . assert_frame_equal ( xlsx_table . df , AB_DF , check_dtype = False ) [EOL] assert xlsx_table . name == xlsx_name [EOL] [EOL] [EOL] def test_it_parses_all_files_in_a_directory ( ) : [EOL] [docstring] [EOL] sub_dir = os . path . join ( DATA_DIR , [string] ) [EOL] parse_results = list ( fables . parse ( io = sub_dir ) ) [EOL] child_names = [ os . path . join ( sub_dir , [string] ) , os . path . join ( sub_dir , [string] ) , ] [EOL] _validate_basic_csv_and_basic_xlsx_together ( parse_results , child_names ) [EOL] [EOL] [EOL] def _it_parses_flat_files_in_a_basic_zip ( zip_file , zip_path ) : [EOL] parse_results = list ( fables . parse ( io = zip_path ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] child_names = [ os . path . join ( zip_file , child_file ) for child_file in [ [string] , [string] ] ] [EOL] _validate_basic_csv_and_basic_xlsx_together ( parse_results , child_names ) [EOL] [EOL] [EOL] def test_it_parses_flat_files_in_a_basic_zip ( ) : [EOL] [docstring] [EOL] zip_file = [string] [EOL] zip_path = os . path . join ( DATA_DIR , zip_file ) [EOL] _it_parses_flat_files_in_a_basic_zip ( zip_file , zip_path ) [EOL] [EOL] [EOL] def _validate_side_xls_file ( xls_result , expected_name ) : [EOL] [comment] [EOL] assert xls_result . name == expected_name [EOL] assert len ( xls_result . errors ) == [number] [EOL] assert len ( xls_result . tables ) == [number] [EOL] [EOL] table = xls_result . tables [ [number] ] [EOL] assert table . name == expected_name [EOL] assert table . sheet == [string] [EOL] [EOL] pd . testing . assert_frame_equal ( table . df , AB_DF , check_dtype = False ) [EOL] [EOL] [EOL] def test_it_parses_files_in_a_directory_inside_a_zip ( ) : [EOL] [docstring] [EOL] zip_file = [string] [EOL] zip_path = os . path . join ( DATA_DIR , zip_file ) [EOL] [EOL] parse_results = list ( fables . parse ( io = zip_path ) ) [EOL] [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] xls_name = os . path . join ( zip_file , [string] ) [EOL] xls_result = [ pr for pr in parse_results if pr . name == xls_name ] [ [number] ] [EOL] [EOL] [comment] [EOL] csv_name = os . path . join ( zip_file , [string] ) [EOL] csv_result = [ pr for pr in parse_results if pr . name == csv_name ] [ [number] ] [EOL] [EOL] xlsx_name = os . path . join ( zip_file , [string] ) [EOL] xlsx_result = [ pr for pr in parse_results if pr . name == xlsx_name ] [ [number] ] [EOL] [EOL] _validate_side_xls_file ( xls_result , xls_name ) [EOL] _validate_basic_csv_and_basic_xlsx_together ( [ csv_result , xlsx_result ] , [ csv_name , xlsx_name ] ) [EOL] [EOL] [EOL] def test_it_parses_files_in_a_zip_in_a_zip ( ) : [EOL] [docstring] [EOL] zip_file = [string] [EOL] zip_path = os . path . join ( DATA_DIR , zip_file ) [EOL] inner_zip_file = [string] [EOL] [EOL] parse_results = list ( fables . parse ( io = zip_path ) ) [EOL] [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] xls_name = os . path . join ( zip_file , [string] ) [EOL] xls_result = [ pr for pr in parse_results if pr . name == xls_name ] [ [number] ] [EOL] [EOL] [comment] [EOL] csv_name = os . path . join ( inner_zip_file , [string] ) [EOL] csv_result = [ pr for pr in parse_results if pr . name == csv_name ] [ [number] ] [EOL] [EOL] xlsx_name = os . path . join ( inner_zip_file , [string] ) [EOL] xlsx_result = [ pr for pr in parse_results if pr . name == xlsx_name ] [ [number] ] [EOL] [EOL] _validate_side_xls_file ( xls_result , xls_name ) [EOL] _validate_basic_csv_and_basic_xlsx_together ( [ csv_result , xlsx_result ] , [ csv_name , xlsx_name ] ) [EOL] [EOL] [EOL] def test_it_parses_files_in_an_encrypted_zip_with_password ( ) : [EOL] [docstring] [EOL] zip_file = [string] [EOL] zip_path = os . path . join ( DATA_DIR , zip_file ) [EOL] [EOL] parse_results = list ( fables . parse ( io = zip_path , passwords = { zip_file : [string] } ) ) [EOL] child_names = [ os . path . join ( zip_file , child_file ) for child_file in [ [string] , [string] ] ] [EOL] _validate_basic_csv_and_basic_xlsx_together ( parse_results , child_names ) [EOL] [EOL] [EOL] def test_it_parses_files_in_an_encrypted_xlsx ( ) : [EOL] xlsx_name = os . path . join ( DATA_DIR , [string] ) [EOL] _it_parses_an_excel_file_with_one_sheet ( xlsx_name , AB_DF , passwords = { xlsx_name : [string] } ) [EOL] [EOL] [EOL] def test_it_parses_files_in_an_encrypted_xls ( ) : [EOL] xls_name = os . path . join ( DATA_DIR , [string] ) [EOL] _it_parses_an_excel_file_with_one_sheet ( xls_name , AB_DF , passwords = { xls_name : [string] } ) [EOL] [EOL] [EOL] def test_it_parses_nested_encrypted_files ( ) : [EOL] [docstring] [EOL] nested_encrypted_name = os . path . join ( DATA_DIR , [string] ) [EOL] parse_results = list ( fables . parse ( io = nested_encrypted_name , passwords = { nested_encrypted_name : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ) ) [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] for filename in [ [string] , [string] , [string] ] : [EOL] result = [ pr for pr in parse_results if pr . name . endswith ( filename ) ] [ [number] ] [EOL] [EOL] assert len ( result . errors ) == [number] [EOL] assert len ( result . tables ) == [number] [EOL] [EOL] table = result . tables [ [number] ] [EOL] assert table . name . endswith ( filename ) [EOL] if not table . name . endswith ( [string] ) : [EOL] assert table . sheet == [string] [EOL] else : [EOL] assert table . sheet is None [EOL] pd . testing . assert_frame_equal ( table . df , AB_DF , check_dtype = False ) [EOL] [EOL] [EOL] def test_it_finds_no_tables_in_an_invalid_csv_plain_text_file ( ) : [EOL] [docstring] [EOL] txt_file_name = os . path . join ( DATA_DIR , [string] ) [EOL] parse_results = list ( fables . parse ( io = txt_file_name ) ) [EOL] assert len ( parse_results ) == [number] [EOL] parse_result = parse_results [ [number] ] [EOL] assert len ( parse_result . tables ) == [number] [EOL] assert len ( parse_result . errors ) == [number] [EOL] error = parse_result . errors [ [number] ] [EOL] assert error . name == txt_file_name [EOL] assert error . exception_type is pd . errors . ParserError [EOL] assert [string] in error . message [EOL] [EOL] [EOL] def test_it_finds_tables_in_a_valid_csv_plain_text_file ( ) : [EOL] [docstring] [EOL] txt_file_name = os . path . join ( DATA_DIR , [string] ) [EOL] parse_results = list ( fables . parse ( io = txt_file_name ) ) [EOL] assert len ( parse_results ) == [number] [EOL] parse_result = parse_results [ [number] ] [EOL] assert len ( parse_result . tables ) == [number] [EOL] assert len ( parse_result . errors ) == [number] [EOL] table = parse_result . tables [ [number] ] [EOL] assert table . name == txt_file_name [EOL] assert table . sheet is None [EOL] expected_df = pd . DataFrame ( columns = [ [string] ] , data = [ [ [string] ] ] ) [EOL] pd . testing . assert_frame_equal ( table . df , expected_df , check_dtype = False ) [EOL] [EOL] [EOL] def test_it_finds_no_tables_in_a_png_file ( ) : [EOL] png_name = os . path . join ( DATA_DIR , [string] ) [EOL] parse_results = list ( fables . parse ( io = png_name ) ) [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] [EOL] def test_it_raises_a_value_error_for_a_file_name_that_does_not_exist_on_disk ( ) : [EOL] missing_name = os . path . join ( DATA_DIR , [string] ) [EOL] with pytest . raises ( ValueError ) as e : [EOL] for _ in fables . parse ( io = missing_name ) : [EOL] pass [EOL] [EOL] assert [string] in str ( e . value ) [EOL] [EOL] [EOL] def test_it_raises_a_type_error_for_stream_not_read_in_bytes_mode ( ) : [EOL] csv_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] with open ( csv_name , [string] ) as textio : [EOL] with pytest . raises ( TypeError ) as e : [EOL] for _ in fables . parse ( io = textio ) : [EOL] pass [EOL] [EOL] assert [string] in str ( e . value ) [EOL] assert [string] in str ( e . value ) [EOL] [EOL] [EOL] def test_it_creates_a_parse_error_for_malformed_csv ( ) : [EOL] csv_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] parse_results = list ( fables . parse ( io = csv_name ) ) [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert len ( parse_result . tables ) == [number] [EOL] assert len ( parse_result . errors ) == [number] [EOL] [EOL] error = parse_result . errors [ [number] ] [EOL] assert ( error . message == [string] ) [EOL] assert error . exception_type is pd . errors . ParserError [EOL] assert error . name == csv_name [EOL] [EOL] [EOL] def test_it_creates_a_parse_error_for_corrupt_file ( ) : [EOL] [docstring] [EOL] corrupt_xlsx_name = os . path . join ( DATA_DIR , [string] ) [EOL] [EOL] parse_results = list ( fables . parse ( io = corrupt_xlsx_name ) ) [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert parse_result . name == corrupt_xlsx_name [EOL] [EOL] tables = parse_result . tables [EOL] errors = parse_result . errors [EOL] assert len ( tables ) == [number] [EOL] assert len ( errors ) == [number] [EOL] [EOL] error = errors [ [number] ] [EOL] assert error . name == corrupt_xlsx_name [EOL] [EOL] assert error . exception_type is xml . etree . ElementTree . ParseError [EOL] assert [string] in error . message [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , ] , ) def test_it_creates_a_parse_error_for_no_valid_headers ( file_name ) : [EOL] file_path = os . path . join ( DATA_DIR , file_name ) [EOL] [EOL] parse_results = list ( fables . parse ( io = file_path ) ) [EOL] assert len ( parse_results ) == [number] [EOL] [EOL] parse_result = parse_results [ [number] ] [EOL] assert parse_result . name == file_path [EOL] [EOL] tables = parse_result . tables [EOL] assert len ( tables ) == [number] [EOL] [EOL] errors = parse_result . errors [EOL] assert len ( errors ) == [number] [EOL] [EOL] error = errors [ [number] ] [EOL] assert error . name == file_path [EOL] [EOL] assert error . exception_type is ValueError [EOL] assert [string] in error . message [EOL] [EOL] [EOL] def test_it_parses_a_xls_with_no_extension ( ) : [EOL] xls_name = os . path . join ( DATA_DIR , [string] ) [EOL] _it_parses_an_excel_file_with_one_sheet ( xls_name , AB_DF ) [EOL] [EOL] [EOL] def test_it_parses_a_xlsx_with_no_extension ( ) : [EOL] xlsx_name = os . path . join ( DATA_DIR , [string] ) [EOL] _it_parses_an_excel_file_with_one_sheet ( xlsx_name , AB_DF ) [EOL] [EOL] [EOL] def test_it_parses_files_in_a_zip_with_no_extension ( ) : [EOL] zip_name = [string] [EOL] zip_path = os . path . join ( DATA_DIR , zip_name ) [EOL] _it_parses_flat_files_in_a_basic_zip ( zip_name , zip_path ) [EOL] [EOL] [EOL] def test_it_parses_a_csv_with_missing_opening_rows ( ) : [EOL] [docstring] [EOL] csv_name = [string] [EOL] csv_path = os . path . join ( DATA_DIR , csv_name ) [EOL] _it_parses_a_csv ( csv_path , AB_DF ) [EOL] [EOL] [EOL] def test_it_parses_a_semicolon_seperated_csv ( ) : [EOL] [docstring] [EOL] csv_name = [string] [EOL] csv_path = os . path . join ( DATA_DIR , csv_name ) [EOL] _it_parses_a_csv ( csv_path , AB_DF ) [EOL] [EOL] [EOL] def test_it_parses_a_tab_seperated_csv ( ) : [EOL] [docstring] [EOL] csv_name = [string] [EOL] csv_path = os . path . join ( DATA_DIR , csv_name ) [EOL] _it_parses_a_csv ( csv_path , AB_DF ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , _it_parses_a_csv , AB_DF ) , ( [string] , _it_parses_an_excel_file_with_one_sheet , AB_DF ) , ] , ) def test_it_parses_files_with_null_opening_rows ( file_name , test_callable , expected_df ) : [EOL] [docstring] [EOL] path = os . path . join ( DATA_DIR , file_name ) [EOL] test_callable ( path , expected_df ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , _it_parses_a_csv , AB_DF ) , ( [string] , _it_parses_an_excel_file_with_one_sheet , AB_DF , ) , ( [string] , _it_parses_an_excel_file_with_one_sheet , ABC_DF , ) , ( [string] , _it_parses_an_excel_file_with_one_sheet , ABC_DF , ) , ] , ) def test_it_parses_files_with_null_leading_and_trailing_cols ( file_name , test_callable , expected_df ) : [EOL] [docstring] [EOL] path = os . path . join ( DATA_DIR , file_name ) [EOL] test_callable ( path , expected_df ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , _it_parses_a_csv , AB_DF ) , ( [string] , _it_parses_an_excel_file_with_one_sheet , AB_DF ) , ] , ) def test_it_parses_files_with_null_middle_cols ( file_name , test_callable , expected_df ) : [EOL] [docstring] [EOL] path = os . path . join ( DATA_DIR , file_name ) [EOL] test_callable ( path , expected_df ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , _it_parses_a_csv , AB_DF ) , ( [string] , _it_parses_an_excel_file_with_one_sheet , AB_DF ) , ] , ) def test_it_parses_files_with_null_middle_rows ( file_name , test_callable , expected_df ) : [EOL] [docstring] [EOL] path = os . path . join ( DATA_DIR , file_name ) [EOL] test_callable ( path , expected_df ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , _it_parses_a_csv , ABC_DF ) , ( [string] , _it_parses_an_excel_file_with_one_sheet , ABC_DF ) , ] , ) def test_it_parses_files_with_noisy_opening_rows ( file_name , test_callable , expected_df ) : [EOL] [docstring] [EOL] path = os . path . join ( DATA_DIR , file_name ) [EOL] test_callable ( path , expected_df ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , { [string] : False } ) , ( [string] , { [string] : False } ) , ( [string] , { } ) , ( [string] , { } ) , ] , ) def test_it_parses_files_using_pandas_kwargs ( file_name , pandas_kwargs ) : [EOL] [docstring] [EOL] path = os . path . join ( DATA_DIR , file_name ) [EOL] parse_results = list ( fables . parse ( path , pandas_kwargs = pandas_kwargs ) ) [EOL] assert len ( parse_results ) == [number] [EOL] parse_result = parse_results [ [number] ] [EOL] assert len ( parse_result . errors ) == [number] [EOL] tables = parse_result . tables [EOL] assert len ( tables ) == [number] [EOL] [EOL] df = tables [ [number] ] . df [EOL] [EOL] if pandas_kwargs == { } : [EOL] expected_df = pd . DataFrame ( columns = [ [string] , [string] , [string] ] , data = [ [ [number] , [number] , np . nan ] , [ [number] , [number] , np . nan ] ] ) [EOL] pd . testing . assert_frame_equal ( df , expected_df , check_dtype = False ) [EOL] else : [EOL] assert pandas_kwargs == { [string] : False } [EOL] expected_df = pd . DataFrame ( columns = [ [string] , [string] , [string] ] , data = [ [ [number] , [number] , [string] ] , [ [number] , [number] , [string] ] ] ) [EOL] pd . testing . assert_frame_equal ( df , expected_df , check_dtype = False ) [EOL] [EOL] [EOL] string_df = pd . DataFrame ( columns = [ [string] , [string] , [string] ] , data = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] , ) [EOL] numeric_df = pd . DataFrame ( columns = [ [string] , [string] , [string] ] , data = [ [ [number] , [string] , [string] ] , [ [number] , [string] , [string] ] , [ [number] , [string] , [string] ] ] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , False , { } , numeric_df ) , ( [string] , False , { [string] : str } , string_df ) , ( [string] , True , { } , numeric_df ) , ( [string] , True , { [string] : str } , string_df ) , ( [string] , False , { } , string_df ) , ( [string] , False , { [string] : str } , string_df ) , ( [string] , True , { } , numeric_df ) , ( [string] , True , { [string] : str } , numeric_df ) , ( [string] , False , { } , numeric_df ) , ( [string] , False , { [string] : str } , string_df ) , ( [string] , True , { } , numeric_df ) , ( [string] , True , { [string] : str } , string_df ) , ( [string] , False , { } , string_df ) , ( [string] , False , { [string] : str } , string_df , ) , ( [string] , True , { } , numeric_df ) , ( [string] , True , { [string] : str } , numeric_df , ) , ] , ) def test_force_numeric ( file_name , force_numeric , pandas_kwargs , expected_df ) : [EOL] [docstring] [EOL] path = os . path . join ( DATA_DIR , file_name ) [EOL] parse_results = list ( fables . parse ( path , force_numeric = force_numeric , pandas_kwargs = pandas_kwargs ) ) [EOL] assert len ( parse_results ) == [number] [EOL] parse_result = parse_results [ [number] ] [EOL] assert len ( parse_result . errors ) == [number] [EOL] tables = parse_result . tables [EOL] assert len ( tables ) == [number] [EOL] [EOL] df = tables [ [number] ] . df [EOL] [EOL] pd . testing . assert_frame_equal ( df , expected_df , check_dtype = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Optional , Any [EOL] import fables [EOL] import typing [EOL] import pytest [EOL] [EOL] from tests . context import fables [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , None ) , ( [string] , None ) , ( [string] , [string] ) , ] , ) def test_extension_from_name ( name , expected_extension ) : [EOL] assert fables . tree . extension_from_name ( name ) == expected_extension [EOL] [EOL] [EOL] def test_stream_manager_raises_runtime_error_for_only_none_args ( ) : [EOL] with pytest . raises ( RuntimeError ) as e : [EOL] with fables . StreamManager ( name = None , stream = None ) : [EOL] pass [EOL] [EOL] exception_message = str ( e . value ) [EOL] assert [string] in exception_message [EOL] assert [string] in exception_message [EOL] assert [string] in exception_message [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , { [string] : [string] } , None , ) , ( [string] , { } , None , ) , ( [string] , { [string] : [string] } , [string] , ) , ( [string] , { [string] : [string] , [string] : [string] } , [string] , ) , ( [string] , { [string] : [string] } , [string] , ) , ( [string] , { [string] : [string] , [string] : [string] } , [string] , ) , ( [string] , { [string] : [string] , [string] : [string] } , [string] , ) , ( [string] , { [string] : [string] , [string] : [string] } , [string] , ) , ( [string] , { [string] : [string] , [string] : [string] } , [string] , ) , ] , ) def test_it_assigns_the_right_password ( name , passwords , expected_password ) : [EOL] node = fables . FileNode ( name = name , passwords = passwords ) [EOL] assert node . password == expected_password [EOL] [EOL] [EOL] def test_add_password_to_node ( ) : [EOL] node = fables . FileNode ( name = [string] , passwords = { [string] : [string] } ) [EOL] node . add_password ( name = [string] , password = [string] ) [EOL] assert node . passwords == { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def test_node_str ( ) : [EOL] node = fables . Xls ( name = [string] , mimetype = [string] ) [EOL] assert str ( node ) == [string] [EOL] [EOL] node = fables . Directory ( name = [string] , mimetype = None ) [EOL] assert str ( node ) == [string] [EOL] [EOL] [EOL] def test_mimetype_from_stream_for_empty_stream ( ) : [EOL] mimetype = fables . mimetype_from_stream ( None ) [EOL] assert mimetype is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import fables [EOL] import typing [EOL] import pandas as pd [EOL] [EOL] from tests . context import fables [EOL] [EOL] [EOL] def test_table_str ( ) : [EOL] df = pd . DataFrame ( columns = [ [string] , [string] ] , data = [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] table = fables . Table ( df = df , name = [string] , sheet = None ) [EOL] assert ( str ( table ) == [string] ) [EOL] [EOL] df = pd . DataFrame ( columns = [ [string] , [string] , [string] ] , data = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] table = fables . Table ( df = df , name = [string] , sheet = [string] ) [EOL] assert ( str ( table ) == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import fables [EOL] import typing [EOL] import io [EOL] import io [EOL] import os [EOL] [EOL] import pytest [EOL] [EOL] from tests . context import fables [EOL] [EOL] [EOL] class MockOSStatResult : [EOL] def __init__ ( self , size ) : [EOL] self . st_size = size [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] * [number] ** [number] , True ) , ( [string] , [number] * [number] ** [number] , False ) ] , ) def test_check_file_size_detects_when_file_is_too_large ( name , size , expected_to_be_too_big , monkeypatch ) : [EOL] def mock_stat ( name ) : [EOL] [docstring] [EOL] return MockOSStatResult ( size ) [EOL] [EOL] monkeypatch . setattr ( os , [string] , mock_stat ) [EOL] [EOL] too_big , _ = fables . api . _check_file_size ( name ) [EOL] assert too_big is expected_to_be_too_big [EOL] [EOL] [EOL] def test_detect_raises_a_value_error_when_file_is_too_large ( monkeypatch ) : [EOL] def mock_exists ( * args ) : [EOL] return True [EOL] [EOL] monkeypatch . setattr ( os . path , [string] , mock_exists ) [EOL] [EOL] file_size = [number] * [number] ** [number] [EOL] [EOL] def mock_stat ( name ) : [EOL] return MockOSStatResult ( file_size ) [EOL] [EOL] monkeypatch . setattr ( os , [string] , mock_stat ) [EOL] [EOL] with pytest . raises ( ValueError ) as e : [EOL] fables . detect ( [string] ) [EOL] [EOL] exception_message = str ( e . value ) [EOL] assert [string] in exception_message [EOL] assert f" [string] { file_size } [string] " in exception_message [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] * [number] ** [number] , True ) , ( [number] * [number] ** [number] , False ) ] ) def test_detect_detects_when_stream_is_too_large ( size , expected_to_be_too_big , monkeypatch ) : [EOL] def mock_tell ( ) : [EOL] return size [EOL] [EOL] stream = io . BytesIO ( [string] ) [EOL] monkeypatch . setattr ( stream , [string] , mock_tell ) [EOL] [EOL] too_big , _ = fables . api . _check_stream_size ( stream ) [EOL] assert too_big is expected_to_be_too_big [EOL] [EOL] [EOL] def test_detect_raises_a_value_error_when_stream_is_too_large ( monkeypatch ) : [EOL] stream_size = [number] * [number] ** [number] [EOL] [EOL] def mock_tell ( ) : [EOL] return stream_size [EOL] [EOL] stream = io . BytesIO ( [string] ) [EOL] monkeypatch . setattr ( stream , [string] , mock_tell ) [EOL] [EOL] with pytest . raises ( ValueError ) as e : [EOL] fables . detect ( io = stream ) [EOL] [EOL] exception_message = str ( e . value ) [EOL] assert [string] in exception_message [EOL] assert f" [string] { stream_size } [string] " in exception_message [EOL] [EOL] [EOL] def _it_raises_a_value_error_when_passwords_is_not_a_dict ( callable ) : [EOL] with pytest . raises ( ValueError ) as e : [EOL] list ( callable ( io = io . BytesIO ( [string] ) , passwords = [string] ) ) [EOL] [EOL] exception_message = str ( e . value ) [EOL] assert f"{ callable . __name__ }" in exception_message [EOL] [EOL] [EOL] def test_detect_raises_a_value_error_when_passwords_is_not_a_dict ( ) : [EOL] _it_raises_a_value_error_when_passwords_is_not_a_dict ( fables . detect ) [EOL] [EOL] [EOL] def test_parse_raises_a_value_error_when_passwords_is_not_a_dict ( ) : [EOL] _it_raises_a_value_error_when_passwords_is_not_a_dict ( fables . parse ) [EOL] [EOL] [EOL] def _it_raises_a_value_error_when_password_is_not_a_str ( callable ) : [EOL] with pytest . raises ( ValueError ) as e : [EOL] list ( callable ( io = io . BytesIO ( [string] ) , password = { [string] : [string] } ) ) [EOL] [EOL] exception_message = str ( e . value ) [EOL] assert f"{ callable . __name__ }" in exception_message [EOL] [EOL] [EOL] def test_detect_raises_a_value_error_when_password_is_not_a_str ( ) : [EOL] _it_raises_a_value_error_when_password_is_not_a_str ( fables . detect ) [EOL] [EOL] [EOL] def test_parse_raises_a_value_error_when_password_is_not_a_str ( ) : [EOL] _it_raises_a_value_error_when_password_is_not_a_str ( fables . parse ) [EOL] [EOL] [EOL] def test_parse_raises_value_error_when_no_io_or_tree_is_given ( ) : [EOL] with pytest . raises ( ValueError ) as e : [EOL] list ( fables . parse ( io = None , tree = None ) ) [EOL] [EOL] exception_message = str ( e . value ) [EOL] assert [string] in exception_message [EOL] assert [string] in exception_message [EOL] assert [string] in exception_message [EOL] [EOL] [EOL] def test_detect_accepts_a_stream_file_name ( ) : [EOL] nameless_stream = io . BytesIO ( [string] ) [EOL] stream_file_name = [string] [EOL] node = fables . detect ( io = nameless_stream , stream_file_name = stream_file_name ) [EOL] assert node . stream . name == stream_file_name [EOL] [EOL] [EOL] def test_parse_accepts_a_stream_file_name ( ) : [EOL] nameless_stream = io . BytesIO ( [string] ) [EOL] stream_file_name = [string] [EOL] parse_results = list ( fables . parse ( io = nameless_stream , stream_file_name = stream_file_name ) ) [EOL] assert parse_results [ [number] ] . tables [ [number] ] . name == stream_file_name [EOL] [EOL] [EOL] def test_node_stream_property_returns_at_byte_0_after_detect ( ) : [EOL] stream = io . BytesIO ( [string] ) [EOL] node = fables . detect ( stream ) [EOL] assert node . _stream . tell ( ) == [number] [EOL] with node . stream as node_stream : [EOL] assert node_stream . tell ( ) == [number] [EOL] [EOL] [EOL] def test_node_stream_property_returns_at_byte_0_after_parse ( ) : [EOL] stream = io . BytesIO ( [string] ) [EOL] node = fables . detect ( stream ) [EOL] for _ in fables . parse ( tree = node ) : [EOL] pass [EOL] assert node . _stream . tell ( ) == [number] [EOL] with node . stream as node_stream : [EOL] assert node_stream . tell ( ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0