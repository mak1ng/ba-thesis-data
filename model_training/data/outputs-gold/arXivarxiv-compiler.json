from typing import Set , Any , Tuple , List [EOL] import datetime [EOL] import requests [EOL] import typing [EOL] import asyncio [EOL] import argparse [EOL] import asyncio [EOL] from datetime import datetime [EOL] from itertools import chain [EOL] import json [EOL] import logging [EOL] import random [EOL] import requests [EOL] [EOL] def generate_arxiv_id ( ) : [EOL] year = random . randint ( [number] , [number] ) [EOL] month = random . randint ( [number] , [number] ) [EOL] id = random . randint ( [number] , [number] ) [EOL] [EOL] return f"{ year : [string] }{ month : [string] } [string] { id : [string] }" [EOL] [EOL] def payload ( id ) : [EOL] year = int ( id [ [number] : [number] ] ) [EOL] year += [number] if year > [number] else [number] [EOL] month = int ( id [ [number] : [number] ] ) [EOL] date = datetime ( year , month , [number] , [number] , [number] , [number] ) [EOL] return { [string] : id , [string] : date . timestamp ( ) , [string] : [string] , [string] : True } [EOL] [EOL] def check_status ( task_url ) : [EOL] r = requests . get ( task_url ) [EOL] try : [EOL] data = r . json ( ) [EOL] return data [ [string] ] [ [string] ] [EOL] except : [EOL] if r . status_code == [number] : [EOL] return [string] [EOL] [EOL] async def test_compilation ( arxiv_id = None ) : [EOL] [docstring] [EOL] if arxiv_id is None : [EOL] arxiv_id = generate_arxiv_id ( ) [EOL] data = json . dumps ( payload ( arxiv_id ) ) [EOL] logging . debug ( f" [string] { arxiv_id }" ) [EOL] r = requests . post ( [string] , data = data ) [EOL] task_url = r . headers [ [string] ] [EOL] [EOL] status = [string] [EOL] while status in [ [string] , [string] ] : [EOL] await asyncio . sleep ( [number] ) [EOL] status = check_status ( task_url ) [EOL] print ( arxiv_id , status ) [EOL] [EOL] if status == [string] : [EOL] return ( arxiv_id , False ) [EOL] elif status == [string] : [EOL] return ( arxiv_id , True ) [EOL] [EOL] def main ( N = [number] , ids = [ ] ) : [EOL] futures = [ ] [EOL] if ids : [EOL] for id in ids : [EOL] futures . append ( asyncio . ensure_future ( test_compilation ( id ) ) ) [EOL] else : [EOL] for i in range ( N ) : [EOL] futures . append ( asyncio . ensure_future ( test_compilation ( ) ) ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] result = loop . run_until_complete ( asyncio . wait ( futures ) ) [EOL] for future in futures : [EOL] arxiv_id , success = future . result ( ) [EOL] print ( arxiv_id , success ) [EOL] [EOL] if __name__ == [string] : [EOL] from argparse import ArgumentParser [EOL] [EOL] parser = ArgumentParser ( ) [EOL] group = parser . add_mutually_exclusive_group ( ) [EOL] group . add_argument ( [string] , type = int , default = [number] ) [EOL] group . add_argument ( [string] , nargs = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] main ( N = args . N , ids = args . ids ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import time [EOL] from compiler . factory import create_app [EOL] from compiler . services import store [EOL] [EOL] app = create_app ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . import celeryconfig [EOL] from celery import Celery [EOL] [EOL] celery_app = Celery ( [string] ) [EOL] [docstring] [EOL] celery_app . config_from_object ( [string] ) [EOL] celery_app . autodiscover_tasks ( [ [string] ] , related_name = [string] , force = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterator [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import Iterator [EOL] from io import BytesIO , SEEK_END [EOL] [EOL] [EOL] class ResponseStream ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , iterator ) : [EOL] [docstring] [EOL] self . read = iterator [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterator$ 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 $typing.Iterator$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] from typing import Any [EOL] from base64 import b64decode [EOL] [EOL] import docker [EOL] from celery . signals import task_prerun , celeryd_init , worker_init , celeryd_init [EOL] import boto3 [EOL] [EOL] from arxiv . vault . manager import ConfigManager [EOL] from . factory import create_app as create_flask_app [EOL] from . celery import celery_app [EOL] [EOL] app = create_flask_app ( ) [EOL] app . app_context ( ) . push ( ) [comment] [EOL] [EOL] if app . config [ [string] ] : [EOL] __secrets__ = app . middlewares [ [string] ] . secrets [EOL] else : [EOL] __secrets__ = None [EOL] [EOL] [EOL] @ celeryd_init . connect def get_secrets ( * args , ** kwargs ) : [EOL] [docstring] [EOL] if not app . config [ [string] ] : [EOL] print ( [string] ) [EOL] return [EOL] for key , value in __secrets__ . yield_secrets ( ) : [EOL] app . config [ key ] = value [EOL] print ( [string] ) [EOL] [EOL] [EOL] @ celeryd_init . connect def verify_converter_image_up_to_date ( * args , ** kwargs ) : [EOL] [docstring] [EOL] image = app . config [ [string] ] [EOL] ecr_registry , _ = image . split ( [string] , [number] ) [EOL] client = docker . from_env ( ) [EOL] [EOL] [comment] [EOL] ecr = boto3 . client ( [string] , region_name = app . config . get ( [string] , [string] ) ) [EOL] response = ecr . get_authorization_token ( ) [EOL] token = b64decode ( response [ [string] ] [ [number] ] [ [string] ] ) [EOL] username , password = token . decode ( [string] ) . split ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] client . login ( username , password , registry = ecr_registry ) [EOL] client . images . pull ( image ) [EOL] [EOL] [EOL] @ task_prerun . connect def verify_secrets_up_to_date ( * args , ** kwargs ) : [EOL] [docstring] [EOL] if not app . config [ [string] ] : [EOL] print ( [string] ) [EOL] return [EOL] for key , value in __secrets__ . yield_secrets ( ) : [EOL] app . config [ key ] = value [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] from urllib import parse [EOL] [EOL] broker_url = [string] % os . environ . get ( [string] ) [EOL] [docstring] [EOL] [EOL] result_backend = [string] % os . environ . get ( [string] ) [EOL] [docstring] [EOL] [EOL] backend = results = result_backend [EOL] [EOL] redis_socket_timeout = [number] [EOL] redis_socket_connect_timeout = [number] [EOL] [EOL] broker_transport_options = { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] worker_prefetch_multiplier = [number] [EOL] [docstring] [EOL] [EOL] task_default_queue = [string] [EOL] [EOL] task_acks_late = False [EOL] [docstring] [EOL] [EOL] task_publish_retry_policy = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] result_extended = True [EOL] [docstring]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0
from typing import BinaryIO , Union , Any , Type , Dict , Set , Tuple , Optional [EOL] import arxiv [EOL] import werkzeug [EOL] import compiler [EOL] import domain [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import string [EOL] from typing import Tuple , Optional , Callable , Any [EOL] from http import HTTPStatus as status [EOL] from base64 import urlsafe_b64encode [EOL] [EOL] from werkzeug . datastructures import MultiDict [EOL] from werkzeug . exceptions import BadRequest , NotFound , InternalServerError , Forbidden [EOL] [EOL] from flask import url_for [EOL] [EOL] from arxiv . users . domain import Session [EOL] from arxiv . base import logging [EOL] from arxiv . base . globals import get_application_config [EOL] [EOL] from . services import Store , filemanager [EOL] from . services . store import DoesNotExist [EOL] from . import compiler [EOL] from . domain import Task , Product , Status , Format [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] Response = Tuple [ dict , int , dict ] [EOL] [EOL] urlsafe_base64_alphabet = ( set ( range ( [number] , [number] ) ) | set ( range ( [number] , [number] ) ) | set ( range ( [number] , [number] ) ) | set ( ( [number] , [number] , [number] ) ) ) [comment] [EOL] [docstring] [EOL] [EOL] [EOL] def is_urlsafe_base64 ( val ) : [EOL] [docstring] [EOL] return bool ( len ( set ( ( ord ( c ) for c in val ) ) - urlsafe_base64_alphabet ) == [number] ) [EOL] [EOL] [EOL] def _redirect_to_status ( source_id , checksum , output_format , code = status . SEE_OTHER ) : [EOL] [docstring] [EOL] location = url_for ( [string] , source_id = source_id , checksum = checksum , output_format = output_format . value ) [EOL] return { } , code , { [string] : location } [EOL] [EOL] [EOL] def service_status ( * args , ** kwargs ) : [EOL] [docstring] [EOL] fm = filemanager . FileManager . current_session ( ) [EOL] store = Store . current_session ( ) [EOL] response_data = { } [EOL] response_data [ [string] ] = store . is_available ( ) [EOL] response_data [ [string] ] = compiler . is_available ( ) [EOL] response_data [ [string] ] = fm . is_available ( ) [EOL] if not all ( response_data . values ( ) ) : [EOL] return response_data , status . SERVICE_UNAVAILABLE , { } [EOL] return response_data , status . OK , { } [EOL] [EOL] [EOL] def compile ( request_data , token , session , is_authorized = lambda task : True ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] source_id = _validate_source_id ( str ( request_data . get ( [string] , [string] ) ) ) [EOL] checksum = _validate_checksum ( str ( request_data . get ( [string] , [string] ) ) ) [EOL] product_format = _validate_output_format ( request_data . get ( [string] , Format . PDF . value ) ) [EOL] [EOL] [comment] [EOL] force = request_data . get ( [string] , False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] stamp_label = request_data . get ( [string] , None ) [EOL] stamp_link = request_data . get ( [string] , None ) [EOL] [EOL] logger . debug ( [string] , __name__ , request_data ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not force : [EOL] try : [EOL] task_state = compiler . get_task ( source_id , checksum , product_format ) [EOL] if not is_authorized ( task_state ) : [EOL] raise Forbidden ( [string] ) [EOL] logger . debug ( [string] ) [EOL] return _redirect_to_status ( source_id , checksum , product_format ) [EOL] except compiler . NoSuchTask as e : [EOL] [comment] [EOL] pass [EOL] [EOL] owner = _get_owner ( source_id , checksum , token ) [EOL] try : [EOL] compiler . start_compilation ( source_id , checksum , stamp_label , stamp_link , product_format , token = token , owner = owner ) [EOL] except compiler . TaskCreationFailed as e : [EOL] logger . error ( [string] , e ) [EOL] raise InternalServerError ( [string] ) from e [EOL] return _redirect_to_status ( source_id , checksum , product_format , status . ACCEPTED ) [EOL] [EOL] [EOL] def get_status ( source_id , checksum , output_format , is_authorized = lambda task : True ) : [EOL] [docstring] [EOL] source_id = _validate_source_id ( source_id ) [EOL] checksum = _validate_checksum ( checksum ) [EOL] product_format = _validate_output_format ( output_format ) [EOL] [EOL] logger . debug ( [string] , source_id , checksum , output_format ) [EOL] try : [EOL] task_state = compiler . get_task ( source_id , checksum , product_format ) [EOL] except compiler . NoSuchTask as e : [EOL] raise NotFound ( [string] ) from e [EOL] [EOL] [comment] [EOL] if not is_authorized ( task_state ) : [EOL] raise Forbidden ( [string] ) [EOL] return task_state . to_dict ( ) , status . OK , { [string] : task_state . owner } [EOL] [EOL] [EOL] def get_product ( source_id , checksum , output_format , is_authorized = lambda task : True ) : [EOL] [docstring] [EOL] source_id = _validate_source_id ( source_id ) [EOL] checksum = _validate_checksum ( checksum ) [EOL] product_format = _validate_output_format ( output_format ) [EOL] [EOL] [comment] [EOL] try : [EOL] task_state = compiler . get_task ( source_id , checksum , product_format ) [EOL] except compiler . NoSuchTask as e : [EOL] raise NotFound ( [string] ) from e [EOL] if not is_authorized ( task_state ) : [EOL] raise Forbidden ( [string] ) [EOL] [EOL] if not task_state . is_completed : [EOL] return _redirect_to_status ( source_id , checksum , product_format ) [EOL] [EOL] store = Store . current_session ( ) [EOL] try : [EOL] product = store . retrieve ( source_id , checksum , product_format ) [EOL] except DoesNotExist as e : [EOL] raise NotFound ( [string] ) from e [EOL] data = { [string] : product . stream , [string] : product_format . content_type , [string] : f'{ source_id } [string] { product_format . ext }' , } [EOL] headers = { [string] : task_state . owner , [string] : product . checksum } [EOL] return data , status . OK , headers [EOL] [EOL] [EOL] def get_log ( source_id , checksum , output_format , is_authorized = lambda task : True ) : [EOL] [docstring] [EOL] source_id = _validate_source_id ( source_id ) [EOL] checksum = _validate_checksum ( checksum ) [EOL] product_format = _validate_output_format ( output_format ) [EOL] [EOL] [comment] [EOL] try : [EOL] task_state = compiler . get_task ( source_id , checksum , product_format ) [EOL] except compiler . NoSuchTask as e : [EOL] raise NotFound ( [string] ) from e [EOL] if not is_authorized ( task_state ) : [EOL] raise Forbidden ( [string] ) [EOL] if not task_state . is_completed : [EOL] return _redirect_to_status ( source_id , checksum , product_format ) [EOL] [EOL] store = Store . current_session ( ) [EOL] try : [EOL] product = store . retrieve_log ( source_id , checksum , product_format ) [EOL] except DoesNotExist as e : [EOL] raise NotFound ( [string] ) from e [EOL] data = { [string] : product . stream , [string] : [string] , [string] : f'{ source_id } [string] { product_format . ext }' } [EOL] headers = { [string] : task_state . owner , [string] : product . checksum } [EOL] return data , status . OK , headers [EOL] [EOL] [EOL] def _validate_source_id ( source_id ) : [EOL] if not source_id or not _is_valid_source_id ( source_id ) : [EOL] raise BadRequest ( f' [string] { source_id }' ) [EOL] return source_id [EOL] [EOL] [EOL] def _validate_checksum ( checksum ) : [EOL] verify = get_application_config ( ) . get ( [string] , True ) [EOL] if not checksum or not is_urlsafe_base64 ( checksum ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if checksum and not verify : [EOL] try : [EOL] checksum_bytes = urlsafe_b64encode ( checksum . encode ( [string] ) ) [EOL] return checksum_bytes . decode ( [string] ) [EOL] except UnicodeDecodeError : [EOL] pass [EOL] logger . debug ( [string] , checksum ) [EOL] raise BadRequest ( f' [string] { checksum }' ) [EOL] return checksum [EOL] [EOL] [EOL] def _validate_output_format ( output_format ) : [EOL] try : [EOL] return Format ( output_format ) [EOL] except ValueError as e : [EOL] raise BadRequest ( f' [string] { output_format }' ) from e [EOL] [EOL] [EOL] def _is_valid_source_id ( source_id ) : [EOL] allowed = set ( string . ascii_letters ) | set ( string . digits ) | set ( [string] ) [EOL] return bool ( len ( set ( source_id ) - allowed ) == [number] ) [EOL] [EOL] [EOL] def _get_owner ( source_id , checksum , token ) : [EOL] [docstring] [EOL] fm = filemanager . FileManager . current_session ( ) [EOL] try : [EOL] logger . debug ( [string] ) [EOL] try : [EOL] owner = fm . owner ( source_id , checksum , token ) [EOL] except Exception as e : [EOL] raise NotFound ( [string] ) from e [EOL] except ( filemanager . exceptions . RequestForbidden , filemanager . exceptions . RequestUnauthorized ) : [EOL] logger . debug ( [string] ) [EOL] raise Forbidden ( [string] ) [EOL] return owner [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $domain.Format$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Hashable , Mapping , Type , List , Dict , Tuple , Optional [EOL] import celery [EOL] import compiler [EOL] import domain [EOL] import builtins [EOL] import docker [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import binascii [EOL] import traceback [EOL] from typing import List , Dict , Optional , Tuple , Callable , Any , Mapping , Hashable [EOL] from functools import wraps [EOL] from itertools import chain [EOL] import subprocess [EOL] import tarfile [EOL] import shutil [EOL] import tempfile [EOL] from base64 import b64decode [EOL] from tempfile import TemporaryDirectory [EOL] [EOL] from flask import current_app [EOL] [EOL] from celery . result import AsyncResult [EOL] from celery . signals import after_task_publish [EOL] from celery import states [EOL] from celery import Task as CeleryTask [EOL] from celery . exceptions import Ignore [EOL] [EOL] import boto3 [EOL] from botocore . exceptions import ClientError [EOL] import docker [EOL] from docker import DockerClient [EOL] from docker . errors import ContainerError , APIError [EOL] from requests . exceptions import ConnectionError [EOL] [EOL] from arxiv . base import logging [EOL] from arxiv . integration . api import exceptions [EOL] [EOL] from celery . task . control import inspect [EOL] from . celery import celery_app [EOL] from . domain import Product , Task , Format , Status , SourcePackage , Reason [EOL] from . services import Store [EOL] from . services import FileManager [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] ProcessResult = Tuple [ int , str , str ] [EOL] [EOL] [EOL] class NoSuchTask ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TaskCreationFailed ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CorruptedSource ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthorizationFailed ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] [EOL] def is_available ( await_result = False ) : [EOL] [docstring] [EOL] logger . debug ( [string] ) [EOL] try : [EOL] task = do_nothing . apply_async ( ) [EOL] except Exception : [EOL] logger . debug ( [string] ) [EOL] return False [EOL] logger . debug ( [string] ) [EOL] if await_result : [EOL] try : [EOL] logger . debug ( [string] ) [EOL] task . get ( ) [comment] [EOL] except Exception as e : [EOL] logger . error ( [string] , e ) [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def start_compilation ( src_id , chk , stamp_label = None , stamp_link = None , output_format = Format . PDF , preferred_compiler = None , token = None , owner = None ) : [EOL] [docstring] [EOL] task_id = _get_task_id ( src_id , chk , output_format ) [EOL] try : [EOL] do_compile . apply_async ( ( src_id , chk ) , { [string] : output_format . value , [string] : stamp_label , [string] : stamp_link , [string] : preferred_compiler , [string] : token , [string] : owner } , task_id = task_id ) [EOL] logger . info ( [string] % task_id ) [EOL] except Exception as e : [EOL] logger . error ( [string] , e ) [EOL] raise TaskCreationFailed ( [string] , e ) from e [EOL] return task_id [EOL] [EOL] [EOL] def get_task ( src_id , chk , fmt = Format . PDF ) : [EOL] [docstring] [EOL] task_id = _get_task_id ( src_id , chk , fmt ) [EOL] result = do_compile . AsyncResult ( task_id ) [EOL] stat = Status . IN_PROGRESS [EOL] reason = Reason . NONE [EOL] owner = None [EOL] description = [string] [EOL] size_bytes = [number] [EOL] _info = ... [EOL] if result . status == [string] : [EOL] raise NoSuchTask ( f' [string] { task_id }' ) [EOL] if result . status in [ [string] , [string] , [string] ] : [EOL] stat = Status . IN_PROGRESS [EOL] _info = result . info [EOL] elif result . status == [string] : [EOL] stat = Status . FAILED [EOL] _info = result . info [EOL] elif result . status == [string] : [EOL] _info = result . result [EOL] if _info and [string] in _info : [EOL] stat = Status ( _info [ [string] ] ) [EOL] else : [EOL] stat = Status . COMPLETED [EOL] [EOL] if _info is not None : [comment] [EOL] reason = Reason ( _info . get ( [string] ) ) [EOL] owner = _info [ [string] ] [EOL] size_bytes = int ( _info . get ( [string] , [string] ) ) [EOL] description = _info . get ( [string] , [string] ) [EOL] [EOL] return Task ( source_id = src_id , checksum = chk , output_format = fmt , task_id = task_id , status = stat , reason = reason , owner = owner , size_bytes = size_bytes , description = description ) [EOL] [EOL] [EOL] @ after_task_publish . connect def _mark_sent ( sender = None , headers = None , body = None , ** kwargs ) : [EOL] [docstring] [EOL] task = celery_app . tasks . get ( sender ) [EOL] backend = task . backend if task else celery_app . backend [EOL] if headers is not None : [EOL] backend . store_result ( headers [ [string] ] , None , [string] ) [EOL] [EOL] [EOL] @ celery_app . task def do_nothing ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] [EOL] def does_checksum_match ( source , expected ) : [EOL] [docstring] [EOL] if source . etag == expected : [EOL] return True [EOL] try : [EOL] if source . etag == b64decode ( expected ) . decode ( [string] ) : [EOL] return True [EOL] except binascii . Error : [comment] [EOL] return False [EOL] except UnicodeDecodeError : [comment] [EOL] return False [EOL] return False [EOL] [EOL] [EOL] @ celery_app . task ( bind = True ) def do_compile ( self , src_id , chk , stamp_label , stamp_link , output_format = [string] , preferred_compiler = None , token = None , owner = None ) : [EOL] [docstring] [EOL] logger . debug ( [string] , src_id , chk , output_format ) [EOL] worker_source_root = current_app . config [ [string] ] [EOL] verbose = current_app . config [ [string] ] [EOL] src_dir = tempfile . mkdtemp ( dir = worker_source_root ) [EOL] [EOL] out = None [EOL] log = None [EOL] disposition = ( Status . FAILED , Reason . NONE , [string] ) [EOL] source = None [EOL] fmt = Format ( output_format ) [EOL] task_id = _get_task_id ( src_id , chk , fmt ) [EOL] size_bytes = [number] [EOL] try : [EOL] [comment] [EOL] fm = FileManager . current_session ( ) [EOL] try : [EOL] source = fm . get_source_content ( src_id , token , save_to = src_dir ) [EOL] except ( exceptions . RequestUnauthorized , exceptions . RequestForbidden ) : [EOL] description = [string] [EOL] disposition = ( Status . FAILED , Reason . AUTHORIZATION , description ) [EOL] raise [EOL] except exceptions . ConnectionFailed : [EOL] description = [string] [EOL] disposition = ( Status . FAILED , Reason . NETWORK , description ) [EOL] raise [EOL] except exceptions . NotFound : [EOL] description = ( [string] [string] ) [EOL] disposition = ( Status . FAILED , Reason . MISSING , description ) [EOL] raise [EOL] [EOL] if source is None or not does_checksum_match ( source , chk ) : [EOL] description = [string] [EOL] if source is not None : [EOL] description += f' [string] { chk } [string] { source . etag }' [EOL] disposition = ( Status . FAILED , Reason . MISSING , description ) [EOL] raise RuntimeError ( description ) [EOL] [EOL] [comment] [EOL] convert = Converter ( ) [EOL] try : [EOL] if not convert . is_available ( ) : [EOL] description = [string] [EOL] disposition = ( Status . FAILED , Reason . DOCKER , description ) [EOL] raise RuntimeError ( [string] ) [EOL] except ClientError : [EOL] description = [string] [EOL] disposition = ( Status . FAILED , Reason . DOCKER , description ) [EOL] try : [EOL] out , log = convert ( source , stamp_label = stamp_label , stamp_link = stamp_link , output_format = fmt , verbose = verbose ) [EOL] except CorruptedSource : [EOL] description = [string] [EOL] disposition = ( Status . FAILED , Reason . CORRUPTED , description ) [EOL] raise [EOL] except RuntimeError as e : [EOL] disposition = ( Status . FAILED , Reason . DOCKER , str ( e ) ) [EOL] raise [EOL] [EOL] [comment] [EOL] if out is None : [EOL] disposition = ( Status . FAILED , Reason . COMPILATION , [string] ) [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] size_bytes = _file_size ( out ) [EOL] disposition = ( Status . COMPLETED , Reason . NONE , [string] ) [EOL] except Exception as e : [EOL] logger . error ( [string] , traceback . format_exc ( ) ) [EOL] logger . error ( disposition [ [number] ] ) [EOL] finally : [EOL] status , reason , description = disposition [EOL] task = Task ( status = status , reason = reason , description = description , source_id = src_id , output_format = fmt , checksum = chk , task_id = task_id , owner = owner , size_bytes = size_bytes ) [EOL] [EOL] logger . debug ( [string] , out , log ) [EOL] try : [EOL] store = Store . current_session ( ) [EOL] if out is not None : [EOL] with open ( out , [string] ) as f : [EOL] store . store ( Product ( stream = f ) , task ) [EOL] if log is not None : [EOL] with open ( log , [string] ) as log_f : [EOL] store . store_log ( Product ( stream = log_f ) , task ) [EOL] logger . debug ( [string] ) [EOL] except Exception as e : [EOL] logger . error ( [string] , e ) [EOL] task = Task ( status = Status . FAILED , reason = Reason . STORAGE , description = [string] , source_id = src_id , output_format = fmt , checksum = chk , task_id = task_id , owner = owner , size_bytes = size_bytes ) [EOL] [EOL] [comment] [EOL] try : [EOL] shutil . rmtree ( src_dir ) [EOL] logger . debug ( [string] , src_dir ) [EOL] except Exception as e : [EOL] logger . error ( [string] , src_dir , e ) [EOL] if task . is_failed : [EOL] logger . error ( [string] , task ) [EOL] return task . to_dict ( ) [EOL] [EOL] [EOL] class Converter : [EOL] [docstring] [EOL] [EOL] def is_available ( self , ** kwargs ) : [EOL] [docstring] [EOL] try : [EOL] self . _new_client ( ) . info ( ) [EOL] logger . debug ( [string] ) [EOL] except ( APIError , ConnectionError ) as e : [EOL] logger . error ( [string] , e ) [EOL] return False [EOL] return True [EOL] [EOL] def _new_client ( self ) : [EOL] [docstring] [EOL] client = DockerClient ( base_url = current_app . config [ [string] ] ) [EOL] [comment] [EOL] [comment] [EOL] if current_app . config [ [string] ] : [EOL] username , password = self . _get_ecr_login ( ) [EOL] ecr_registry , _ = self . image [ [number] ] . split ( [string] , [number] ) [EOL] client . login ( username , password , registry = ecr_registry ) [EOL] return client [EOL] [EOL] @ property def image ( self ) : [EOL] [docstring] [EOL] image_name = current_app . config [ [string] ] [EOL] try : [EOL] image_name , image_tag = image_name . split ( [string] , [number] ) [EOL] except ValueError : [EOL] image_tag = [string] [EOL] return f'{ image_name } [string] { image_tag }' , image_name , image_tag [EOL] [EOL] def _get_ecr_login ( self ) : [EOL] [comment] [EOL] access_key_id = current_app . config [ [string] ] [EOL] secret_access_key = current_app . config [ [string] ] [EOL] region_name = current_app . config . get ( [string] , [string] ) [EOL] ecr = boto3 . client ( [string] , aws_access_key_id = access_key_id , aws_secret_access_key = secret_access_key , region_name = region_name ) [EOL] resp = ecr . get_authorization_token ( ) [EOL] token = b64decode ( resp [ [string] ] [ [number] ] [ [string] ] ) [EOL] username , password = token . decode ( [string] ) . split ( [string] , [number] ) [EOL] return username , password [EOL] [EOL] def _pull_image ( self , client = None ) : [EOL] [docstring] [EOL] logger . info ( [string] ) [EOL] if client is None : [EOL] client = self . _new_client ( ) [EOL] _ , name , tag = self . image [EOL] client . images . pull ( name , tag ) [EOL] logger . info ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def __call__ ( self , source , stamp_label , stamp_link , output_format = Format . PDF , add_stamp = True , timeout = [number] , add_psmapfile = False , P_dvips_flag = False , dvips_layout = [string] , D_dvips_flag = False , id_for_decryption = None , tex_tree_timestamp = None , verbose = True ) : [EOL] [docstring] [EOL] dind_source_root = current_app . config [ [string] ] [EOL] worker_source_root = current_app . config [ [string] ] [EOL] should_pull_image = current_app . config [ [string] ] [EOL] [EOL] src_dir , fname = os . path . split ( source . path ) [EOL] leaf_path = src_dir . split ( worker_source_root , [number] ) [ [number] ] . strip ( [string] ) [EOL] dind_src_dir = os . path . join ( dind_source_root , leaf_path ) [EOL] out = ... [EOL] [EOL] options = [ ( True , [string] ) , ( True , f' [string] { source . source_id }' ) , ( True , f' [string] { output_format . value }' ) , ( stamp_label is not None , f' [string] { stamp_label } [string] ' ) , ( stamp_link is not None , f' [string] { stamp_link } [string] ' ) , ( True , f' [string] { timeout }' ) , ( True , f' [string] { dvips_layout }' ) , ( True , [string] ) , ( verbose , [string] ) , ( not add_stamp , [string] ) , ( add_psmapfile , [string] ) , ( P_dvips_flag , [string] ) , ( id_for_decryption is not None , f' [string] { id_for_decryption }' ) , ( tex_tree_timestamp is not None , f' [string] { tex_tree_timestamp }' ) ] [EOL] [EOL] args = [ arg for opt , arg in options if opt ] [EOL] [EOL] client = self . _new_client ( ) [EOL] image , _ , _ = self . image [EOL] args . insert ( [number] , [string] ) [EOL] try : [EOL] if should_pull_image : [EOL] self . _pull_image ( client ) [EOL] volumes = { dind_src_dir : { [string] : [string] , [string] : [string] } } [EOL] log = client . containers . run ( image , [string] . join ( args ) , volumes = volumes , stderr = True ) [EOL] except APIError as e : [EOL] logger . error ( [string] , e ) [EOL] raise RuntimeError ( f' [string] { source . path }' ) from e [EOL] except ContainerError as e : [EOL] logger . error ( f' [string] { source . path }' ) [EOL] log = e . stderr [EOL] [EOL] [comment] [EOL] ext = Format ( output_format ) . ext [EOL] [EOL] cache = os . path . join ( src_dir , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] oname = None [EOL] logger . debug ( [string] , cache ) [EOL] for fname in os . listdir ( cache ) : [EOL] logger . debug ( [string] , fname ) [EOL] if fname . endswith ( f' [string] { ext }' ) : [EOL] oname = fname [EOL] break [EOL] if oname is None : [comment] [EOL] logger . error ( [string] ) [EOL] out = None [comment] [EOL] else : [EOL] out = os . path . join ( cache , oname ) [EOL] logger . error ( [string] , out ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] logger . debug ( [string] , os . listdir ( src_dir ) ) [EOL] tex_log = os . path . join ( src_dir , [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not os . path . exists ( tex_log ) or _file_size ( tex_log ) == [number] : [EOL] logger . debug ( [string] ) [EOL] log_dir = os . path . split ( tex_log ) [ [number] ] [EOL] if not os . path . exists ( log_dir ) : [EOL] os . makedirs ( log_dir ) [EOL] with open ( tex_log , [string] ) as f : [EOL] f . write ( log ) [EOL] [EOL] return out , tex_log [EOL] [EOL] [EOL] def _get_task_id ( src_id , chk , fmt ) : [EOL] [docstring] [EOL] return f"{ src_id } [string] { chk } [string] { fmt . value }" [EOL] [EOL] [EOL] def _file_size ( path ) : [EOL] return os . path . getsize ( path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docker.DockerClient$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]$ 0 0 0 $domain.SourcePackage$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $domain.Format$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $domain.SourcePackage$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.List[typing.Tuple[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 $domain.Format$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $domain.Format$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Callable [EOL] import arxiv [EOL] import domain [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] [docstring] [EOL] [EOL] from typing import Callable , Union [EOL] from http import HTTPStatus as status [EOL] from werkzeug . wrappers import Response as WkzResponse [EOL] from flask . json import jsonify [EOL] from flask import Blueprint , redirect , request , send_file [EOL] from flask import Response as FlaskResponse [EOL] [EOL] from arxiv . users . auth . decorators import scoped [EOL] from arxiv . users . auth import scopes [EOL] from arxiv . base import logging [EOL] from arxiv . users . domain import Scope [EOL] [EOL] from . import controllers [EOL] from . domain import Task [EOL] [EOL] Response = Union [ FlaskResponse , WkzResponse ] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] blueprint = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] base_url = [string] [EOL] [EOL] [EOL] def authorizer ( scope ) : [EOL] [docstring] [EOL] def inner ( task ) : [EOL] [docstring] [EOL] if not task . owner : [comment] [EOL] return True [EOL] return ( request . auth . is_authorized ( scope , task . task_id ) or ( request . auth . user [EOL] and str ( request . auth . user . user_id ) == str ( task . owner ) ) ) [EOL] return inner [EOL] [EOL] [EOL] def resource_id ( source_id , checksum , output_format ) : [EOL] [docstring] [EOL] return f"{ source_id } [string] { checksum } [string] { output_format }" [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def get_service_status ( ) : [EOL] [docstring] [EOL] data , code , headers = controllers . service_status ( ) [EOL] response = jsonify ( data ) [EOL] response . status_code = code [EOL] response . headers . extend ( headers . items ( ) ) [comment] [EOL] return response [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) @ scoped ( scopes . CREATE_COMPILE ) def compile ( ) : [EOL] [docstring] [EOL] request_data = request . get_json ( force = True ) [EOL] token = request . environ [ [string] ] [EOL] logger . debug ( [string] , request_data ) [EOL] logger . debug ( [string] , token ) [EOL] data , code , headers = controllers . compile ( request_data , token , request . auth , authorizer ( scopes . CREATE_COMPILE ) ) [EOL] response = jsonify ( data ) [EOL] response . status_code = code [EOL] response . headers . extend ( headers . items ( ) ) [comment] [EOL] return response [EOL] [EOL] [EOL] @ blueprint . route ( base_url , methods = [ [string] ] ) @ scoped ( scopes . READ_COMPILE , resource = resource_id ) def get_status ( source_id , checksum , output_format ) : [EOL] [docstring] [EOL] data , code , headers = controllers . get_status ( source_id , checksum , output_format , authorizer ( scopes . READ_COMPILE ) ) [EOL] if code in [ status . SEE_OTHER , status . FOUND ] : [EOL] return redirect ( headers [ [string] ] , code = code ) [EOL] response = jsonify ( data ) [EOL] response . status_code = code [EOL] response . headers . extend ( headers . items ( ) ) [comment] [EOL] return response [EOL] [EOL] [EOL] @ blueprint . route ( f'{ base_url } [string] ' , methods = [ [string] ] ) @ scoped ( scopes . READ_COMPILE , resource = resource_id ) def get_log ( source_id , checksum , output_format ) : [EOL] [docstring] [EOL] data , code , headers = controllers . get_log ( source_id , checksum , output_format , authorizer ( scopes . READ_COMPILE ) ) [EOL] if [number] < code < [number] : [EOL] return redirect ( headers [ [string] ] , code = code ) [EOL] response = send_file ( data [ [string] ] , mimetype = data [ [string] ] , attachment_filename = data [ [string] ] ) [EOL] response . status_code = code [EOL] return response [EOL] [EOL] [EOL] @ blueprint . route ( f'{ base_url } [string] ' , methods = [ [string] ] ) @ scoped ( scopes . READ_COMPILE , resource = resource_id ) def get_product ( source_id , checksum , output_format ) : [EOL] [docstring] [EOL] data , code , head = controllers . get_product ( source_id , checksum , output_format , authorizer ( scopes . READ_COMPILE ) ) [EOL] if [number] < code < [number] : [EOL] return redirect ( head [ [string] ] , code = code ) [EOL] response = send_file ( data [ [string] ] , mimetype = data [ [string] ] , attachment_filename = data [ [string] ] ) [EOL] response . set_etag ( head . get ( [string] ) ) [EOL] response . status_code = code [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from . filemanager import FileManager [EOL] from . store import Store [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Match , Optional [EOL] import builtins [EOL] import requests [EOL] import typing [EOL] import domain [EOL] [docstring] [EOL] [EOL] from typing import Optional , Any [EOL] import json [EOL] import re [EOL] import os [EOL] [EOL] import requests [EOL] from arxiv . integration . api import status , service , exceptions [EOL] from arxiv . base import logging [EOL] from arxiv . base . globals import get_application_config [EOL] [EOL] from . . . domain import SourcePackageInfo , SourcePackage [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Default ( dict ) : [EOL] [docstring] [EOL] [EOL] def __missing__ ( self , key ) : [EOL] [docstring] [EOL] return key [EOL] [EOL] [EOL] class FileManager ( service . HTTPIntegration ) : [EOL] [docstring] [EOL] [EOL] class Meta : [EOL] [docstring] [EOL] [EOL] service_name = [string] [EOL] [EOL] def is_available ( self , ** kwargs ) : [EOL] [docstring] [EOL] config = get_application_config ( ) [EOL] status_endpoint = config . get ( [string] , [string] ) [EOL] timeout = kwargs . get ( [string] , [number] ) [EOL] try : [EOL] response = self . request ( [string] , status_endpoint , timeout = timeout ) [EOL] return bool ( response . status_code == [number] ) [EOL] except Exception as e : [EOL] logger . error ( [string] , e ) [EOL] return False [EOL] return True [EOL] [EOL] @ property def _must_verify_checksum ( self ) : [EOL] config = get_application_config ( ) [EOL] return bool ( config . get ( [string] , True ) ) [EOL] [EOL] def owner ( self , source_id , checksum , token ) : [EOL] [docstring] [EOL] config = get_application_config ( ) [EOL] content_endpoint = config . get ( [string] , [string] ) [EOL] path = content_endpoint . format_map ( Default ( source_id = source_id ) ) [EOL] response = self . request ( [string] , path , token ) [EOL] if self . _must_verify_checksum and response . headers [ [string] ] != checksum : [EOL] logger . error ( [string] , response . headers [ [string] ] , checksum ) [EOL] raise RuntimeError ( [string] ) [EOL] owner = response . headers . get ( [string] ) [EOL] return owner [EOL] [EOL] def get_source_content ( self , source_id , token , save_to = [string] ) : [EOL] [docstring] [EOL] logger . debug ( [string] , source_id ) [EOL] config = get_application_config ( ) [EOL] content_endpoint = config . get ( [string] , [string] ) [EOL] path = content_endpoint . format_map ( Default ( source_id = source_id ) ) [EOL] response = self . request ( [string] , path , token ) [EOL] logger . debug ( [string] , response . status_code ) [EOL] source_file_path = self . _save_content ( path , source_id , response , save_to ) [EOL] logger . debug ( [string] , source_file_path ) [EOL] return SourcePackage ( source_id = source_id , path = source_file_path , etag = response . headers [ [string] ] ) [EOL] [EOL] def _save_content ( self , path , source_id , response , source_dir ) : [EOL] [comment] [EOL] match = re . search ( [string] , response . headers . get ( [string] , [string] ) ) [EOL] if match : [EOL] filename = match . group ( [number] ) . strip ( [string] ) [EOL] else : [comment] [EOL] filename = f'{ source_id } [string] ' [EOL] [EOL] [comment] [EOL] [comment] [EOL] if path . startswith ( [string] ) : [EOL] filename . rstrip ( [string] ) [EOL] [EOL] source_file_path = os . path . abspath ( os . path . join ( source_dir , filename ) ) [EOL] if not source_file_path . startswith ( source_dir ) : [EOL] logger . error ( [string] [string] , source_file_path ) [EOL] raise RuntimeError ( f' [string] { source_file_path }' ) [EOL] [EOL] with open ( source_file_path , [string] ) as f : [EOL] for chunk in response . iter_content ( [number] ) : [EOL] if chunk : [EOL] f . write ( chunk ) [EOL] return source_file_path [EOL] [EOL] def get_upload_info ( self , source_id , token ) : [EOL] [docstring] [EOL] logger . debug ( [string] , source_id ) [EOL] config = get_application_config ( ) [EOL] content_endpoint = config . get ( [string] , [string] ) [EOL] path = content_endpoint . format_map ( Default ( source_id = source_id ) ) [EOL] response , _ , headers = self . json ( [string] , path , token ) [EOL] logger . debug ( [string] , headers [ [string] ] ) [EOL] return SourcePackageInfo ( source_id = source_id , etag = headers [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $domain.SourcePackage$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $requests.Response$ 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $domain.SourcePackageInfo$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
from typing import Union , Dict [EOL] import typing [EOL] import unittest [EOL] import compiler [EOL] import flask [EOL] [docstring] [EOL] [EOL] from unittest import TestCase , mock [EOL] import json [EOL] import os [EOL] import requests [EOL] [EOL] from flask import Flask [EOL] from arxiv . integration . api import exceptions , status [EOL] [EOL] from . . import FileManager [EOL] from . . . . import domain , util [EOL] [EOL] CONFIG = { [string] : [string] , [string] : False } [EOL] mock_app = Flask ( [string] ) [EOL] mock_app . config . update ( CONFIG ) [EOL] [EOL] [EOL] class TestServiceStatus ( TestCase ) : [EOL] [docstring] [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_status ( self , mock_Session ) : [EOL] [docstring] [EOL] mock_Session . return_value = mock . MagicMock ( get = mock . MagicMock ( return_value = mock . MagicMock ( status_code = status . OK , json = mock . MagicMock ( return_value = { [string] : [string] } ) ) ) ) [EOL] self . assertEqual ( FileManager . get_status ( ) , { [string] : [string] } , [string] ) [EOL] [EOL] [EOL] class TestGetUploadInfo ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def session ( self , status_code = status . OK , method = [string] , json = { } , content = [string] , headers = { } ) : [EOL] [docstring] [EOL] return mock . MagicMock ( ** { method : mock . MagicMock ( return_value = mock . MagicMock ( status_code = status_code , json = mock . MagicMock ( return_value = json ) , content = content , headers = headers ) ) } ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_info ( self , mock_Session ) : [EOL] [docstring] [EOL] etag = [string] [EOL] source_id = [string] [EOL] mock_Session . return_value = self . session ( headers = { [string] : etag } ) [EOL] info = FileManager . get_upload_info ( source_id , [string] ) [EOL] self . assertIsInstance ( info , domain . SourcePackageInfo ) [EOL] self . assertEqual ( info . etag , etag ) [EOL] self . assertEqual ( info . source_id , source_id ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_info_nonexistant ( self , mock_Session ) : [EOL] [docstring] [EOL] source_id = [string] [EOL] mock_Session . return_value = self . session ( status . NOT_FOUND ) [EOL] [EOL] with self . assertRaises ( exceptions . NotFound ) : [EOL] FileManager . get_upload_info ( source_id , [string] ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_info_bad_request ( self , mock_Session ) : [EOL] [docstring] [EOL] source_id = [string] [EOL] mock_Session . return_value = self . session ( status . BAD_REQUEST ) [EOL] with self . assertRaises ( exceptions . BadRequest ) : [EOL] FileManager . get_upload_info ( source_id , [string] ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_info_unauthorized ( self , mock_Session ) : [EOL] [docstring] [EOL] source_id = [string] [EOL] mock_Session . return_value = self . session ( status . UNAUTHORIZED ) [EOL] with self . assertRaises ( exceptions . RequestUnauthorized ) : [EOL] FileManager . get_upload_info ( source_id , [string] ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_info_forbidden ( self , mock_Session ) : [EOL] [docstring] [EOL] source_id = [string] [EOL] mock_Session . return_value = self . session ( status . FORBIDDEN ) [EOL] [EOL] with self . assertRaises ( exceptions . RequestForbidden ) : [EOL] FileManager . get_upload_info ( source_id , [string] ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_info_error ( self , mock_Session ) : [EOL] [docstring] [EOL] source_id = [string] [EOL] mock_Session . return_value = self . session ( status . INTERNAL_SERVER_ERROR ) [EOL] [EOL] with self . assertRaises ( exceptions . RequestFailed ) : [EOL] FileManager . get_upload_info ( source_id , [string] ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_info_bad_json ( self , mock_Session ) : [EOL] [docstring] [EOL] source_id = [string] [EOL] [EOL] def raise_JSONDecodeError ( * a , ** k ) : [EOL] raise json . decoder . JSONDecodeError ( [string] , [string] , [number] ) [EOL] [EOL] mock_Session . return_value = mock . MagicMock ( get = mock . MagicMock ( return_value = mock . MagicMock ( status_code = status . OK , json = mock . MagicMock ( side_effect = raise_JSONDecodeError ) ) ) ) [EOL] with self . assertRaises ( exceptions . BadResponse ) : [EOL] FileManager . get_upload_info ( source_id , [string] ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_info_bad_ssl ( self , mock_Session ) : [EOL] [docstring] [EOL] source_id = [string] [EOL] [EOL] def raise_ssl_error ( * a , ** k ) : [EOL] raise requests . exceptions . SSLError ( [string] ) [EOL] [EOL] mock_Session . return_value = mock . MagicMock ( get = mock . MagicMock ( side_effect = raise_ssl_error ) ) [EOL] with self . assertRaises ( exceptions . SecurityException ) : [EOL] FileManager . get_upload_info ( source_id , [string] ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_info_no_connection ( self , mock_Session ) : [EOL] [docstring] [EOL] source_id = [string] [EOL] [EOL] def raise_connection_error ( * a , ** k ) : [EOL] raise requests . exceptions . ConnectionError ( [string] ) [EOL] [EOL] mock_Session . return_value = mock . MagicMock ( get = mock . MagicMock ( side_effect = raise_connection_error ) ) [EOL] with self . assertRaises ( exceptions . ConnectionFailed ) : [EOL] FileManager . get_upload_info ( source_id , [string] ) [EOL] [EOL] [EOL] class TestGetUpload ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def session ( self , status_code = status . OK , method = [string] , json = { } , content = [string] , headers = { } ) : [EOL] [docstring] [EOL] return mock . MagicMock ( ** { method : mock . MagicMock ( return_value = mock . MagicMock ( status_code = status_code , json = mock . MagicMock ( return_value = json ) , content = content , headers = headers ) ) } ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload ( self , mock_Session ) : [EOL] [docstring] [EOL] etag = [string] [EOL] source_id = [string] [EOL] content = [string] [EOL] mock_iter_content = mock . MagicMock ( return_value = [ content ] ) [EOL] mock_Session . return_value = mock . MagicMock ( get = mock . MagicMock ( return_value = mock . MagicMock ( status_code = status . OK , iter_content = mock_iter_content , headers = { [string] : etag } ) ) ) [EOL] info = FileManager . get_source_content ( source_id , [string] ) [EOL] self . assertIsInstance ( info , domain . SourcePackage ) [EOL] self . assertEqual ( info . etag , etag ) [EOL] self . assertEqual ( info . source_id , source_id ) [EOL] self . assertIsInstance ( info . path , str ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_with_filename ( self , mock_Session ) : [EOL] [docstring] [EOL] etag = [string] [EOL] source_id = [string] [EOL] content = [string] [EOL] mock_iter_content = mock . MagicMock ( return_value = [ content ] ) [EOL] mock_Session . return_value = mock . MagicMock ( get = mock . MagicMock ( return_value = mock . MagicMock ( status_code = status . OK , iter_content = mock_iter_content , headers = { [string] : etag , [string] : [string] } ) ) ) [EOL] info = FileManager . get_source_content ( source_id , [string] ) [EOL] self . assertIsInstance ( info , domain . SourcePackage ) [EOL] self . assertEqual ( info . etag , etag ) [EOL] self . assertEqual ( info . source_id , source_id ) [EOL] self . assertIsInstance ( info . path , str ) [EOL] self . assertEqual ( info . path , [string] ) [EOL] self . assertTrue ( os . path . exists ( info . path ) ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_with_suspicious_filename ( self , mock_Session ) : [EOL] [docstring] [EOL] etag = [string] [EOL] source_id = [string] [EOL] content = [string] [EOL] mock_iter_content = mock . MagicMock ( return_value = [ content ] ) [EOL] filename = [string] [EOL] mock_Session . return_value = mock . MagicMock ( get = mock . MagicMock ( return_value = mock . MagicMock ( status_code = status . OK , iter_content = mock_iter_content , headers = { [string] : etag , [string] : f' [string] { filename }' } ) ) ) [EOL] with self . assertRaises ( RuntimeError ) : [EOL] FileManager . get_source_content ( source_id , [string] ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_with_malicious_filename ( self , mock_Session ) : [EOL] [docstring] [EOL] etag = [string] [EOL] source_id = [string] [EOL] content = [string] [EOL] mock_iter_content = mock . MagicMock ( return_value = [ content ] ) [EOL] filename = [string] [EOL] mock_Session . return_value = mock . MagicMock ( get = mock . MagicMock ( return_value = mock . MagicMock ( status_code = status . OK , iter_content = mock_iter_content , headers = { [string] : etag , [string] : f' [string] { filename }' } ) ) ) [EOL] with self . assertRaises ( RuntimeError ) : [EOL] FileManager . get_source_content ( source_id , [string] ) [EOL] [EOL] @ mock . patch ( [string] , mock_app ) @ mock . patch ( [string] ) def test_get_upload_nonexistant ( self , mock_Session ) : [EOL] [docstring] [EOL] source_id = [string] [EOL] mock_Session . return_value = self . session ( status . NOT_FOUND ) [EOL] with self . assertRaises ( exceptions . NotFound ) : [EOL] FileManager . get_source_content ( source_id , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $compiler.domain.SourcePackageInfo$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackageInfo$ 0 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackageInfo$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $compiler.domain.SourcePackageInfo$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
[docstring] [EOL]	0 0
import io [EOL] import compiler [EOL] import unittest [EOL] [docstring] [EOL] [EOL] from unittest import TestCase , mock [EOL] from moto import mock_s3 [EOL] import io [EOL] from datetime import datetime [EOL] [EOL] from . . import Store [EOL] from . . import store as store_ [EOL] from . . . import domain [EOL] [EOL] mock_app_config = mock . MagicMock ( return_value = { [string] : None , [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] [EOL] class TestStore ( TestCase ) : [EOL] [docstring] [EOL] [EOL] @ mock_s3 @ mock . patch ( f'{ store_ . __name__ } [string] ' , mock_app_config ) def test_store_retrieve ( self ) : [EOL] [docstring] [EOL] store = Store . current_session ( ) [EOL] content = io . BytesIO ( [string] ) [EOL] store . _create_bucket ( ) [EOL] status_pdf = domain . Task ( source_id = [string] , output_format = domain . Format . PDF , checksum = [string] , task_id = [string] , size_bytes = [number] , status = domain . Status . COMPLETED ) [EOL] product = domain . Product ( stream = content ) [EOL] store . store ( product , status_pdf ) [EOL] returned = store . retrieve ( [string] , [string] , domain . Format . PDF ) [EOL] self . assertEqual ( returned . stream . read ( ) , [string] ) [EOL] [EOL] with self . assertRaises ( store_ . DoesNotExist ) : [EOL] store . retrieve ( [string] , [string] , domain . Format . PS ) [EOL] [EOL] @ mock_s3 @ mock . patch ( f'{ store_ . __name__ } [string] ' , mock_app_config ) def test_store_retrieve_log ( self ) : [EOL] [docstring] [EOL] store = Store . current_session ( ) [EOL] content = io . BytesIO ( [string] ) [EOL] store . _create_bucket ( ) [EOL] status_pdf = domain . Task ( source_id = [string] , output_format = domain . Format . PDF , checksum = [string] , task_id = [string] , size_bytes = [number] , status = domain . Status . COMPLETED ) [EOL] product = domain . Product ( stream = content ) [EOL] store . store_log ( product , status_pdf ) [EOL] [EOL] returned = store . retrieve_log ( [string] , [string] , domain . Format . PDF ) [EOL] self . assertEqual ( returned . stream . read ( ) , [string] ) [EOL] [EOL] with self . assertRaises ( store_ . DoesNotExist ) : [EOL] store . retrieve ( [string] , [string] , domain . Format . PS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $compiler.services.store.Store$ 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 $compiler.services.store.Store$ 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Product$ 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 $compiler.services.store.Store$ 0 $compiler.services.store.Store$ 0 $compiler.domain.Product$ 0 $compiler.domain.Task$ 0 0 $compiler.domain.Product$ 0 $compiler.services.store.Store$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Product$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.services.store.Store$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $compiler.services.store.Store$ 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 $compiler.services.store.Store$ 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Product$ 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 $compiler.services.store.Store$ 0 0 0 $compiler.domain.Product$ 0 $compiler.domain.Task$ 0 0 0 $compiler.domain.Product$ 0 $compiler.services.store.Store$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Product$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.services.store.Store$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Dict [EOL] import botocore [EOL] import boto3 [EOL] import domain [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] [docstring] [EOL] [EOL] import json [EOL] from typing import Tuple , Optional , Dict , Union , List , Any , Mapping [EOL] from functools import wraps [EOL] from hashlib import md5 [EOL] from base64 import b64encode [EOL] from collections import defaultdict [EOL] import boto3 [EOL] import botocore [EOL] from botocore . config import Config [EOL] from botocore . exceptions import ClientError [EOL] from flask import Flask [EOL] [EOL] from arxiv . base import logging [EOL] from arxiv . base . globals import get_application_global , get_application_config [EOL] [EOL] from . . . domain import Task , Product , Format [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class DoesNotExist ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class NoSuchBucket ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] def hash_content ( body ) : [EOL] [docstring] [EOL] return b64encode ( md5 ( body ) . digest ( ) ) . decode ( [string] ) [EOL] [EOL] [EOL] class Store : [EOL] [docstring] [EOL] [EOL] LOG_KEY = [string] [EOL] KEY = [string] [EOL] [EOL] def __init__ ( self , bucket , verify = False , region_name = None , endpoint_url = None , aws_access_key_id = None , aws_secret_access_key = None ) : [EOL] [docstring] [EOL] self . _bucket = bucket [EOL] self . _region_name = region_name [EOL] self . _endpoint_url = endpoint_url [EOL] self . _verify = verify [EOL] self . _aws_access_key_id = aws_access_key_id [EOL] self . _aws_secret_access_key = aws_secret_access_key [EOL] self . client = self . _new_client ( ) [EOL] [EOL] def _new_client ( self , config = None ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] params = { [string] : self . _region_name } [EOL] if self . _aws_access_key_id and self . _aws_secret_access_key : [EOL] params [ [string] ] = self . _aws_access_key_id [EOL] params [ [string] ] = self . _aws_secret_access_key [EOL] if self . _endpoint_url : [EOL] params [ [string] ] = self . _endpoint_url [EOL] params [ [string] ] = self . _verify [EOL] logger . debug ( [string] , params ) [EOL] return boto3 . client ( [string] , ** params ) [EOL] [EOL] def _handle_client_error ( self , exc ) : [EOL] logger . error ( [string] , str ( exc . response ) ) [EOL] if exc . response [ [string] ] [ [string] ] == [string] : [EOL] logger . error ( [string] ) [EOL] raise NoSuchBucket ( f'{ self . _bucket } [string] ' ) from exc [EOL] if exc . response [ [string] ] [ [string] ] == [string] : [EOL] raise DoesNotExist ( f' [string] { self . _bucket }' ) from exc [EOL] logger . error ( [string] , exc ) [EOL] raise RuntimeError ( [string] ) from exc [EOL] [EOL] def __hash__ ( self ) : [EOL] [docstring] [EOL] return hash ( ( self . _bucket , self . _region_name , self . _endpoint_url , self . _verify , self . _aws_access_key_id , self . _aws_secret_access_key ) ) [EOL] [EOL] def is_available ( self , retries = [number] , read_timeout = [number] , connect_timeout = [number] ) : [EOL] [docstring] [EOL] try : [EOL] self . _test_put ( retries = retries , read_timeout = read_timeout , connect_timeout = connect_timeout ) [EOL] logger . debug ( [string] ) [EOL] return True [EOL] except RuntimeError : [EOL] logger . debug ( [string] ) [EOL] return False [EOL] [EOL] def _test_put ( self , retries = [number] , read_timeout = [number] , connect_timeout = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] config = Config ( retries = { [string] : retries } , read_timeout = read_timeout , connect_timeout = connect_timeout ) [EOL] client = self . _new_client ( config = config ) [EOL] try : [EOL] logger . info ( [string] , self . _bucket ) [EOL] client . put_object ( Body = [string] , Bucket = self . _bucket , Key = [string] ) [EOL] except ClientError as e : [EOL] logger . error ( [string] , e ) [EOL] self . _handle_client_error ( e ) [EOL] [EOL] def _wait_for_bucket ( self , retries = [number] , delay = [number] ) : [EOL] [docstring] [EOL] try : [EOL] waiter = self . client . get_waiter ( [string] ) [EOL] waiter . wait ( Bucket = self . _bucket , WaiterConfig = { [string] : delay , [string] : retries } ) [EOL] except ClientError as exc : [EOL] self . _handle_client_error ( exc ) [EOL] [EOL] def initialize ( self ) : [EOL] [docstring] [EOL] logger . info ( [string] ) [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] if self . is_available ( retries = [number] , connect_timeout = [number] , read_timeout = [number] ) : [EOL] logger . info ( [string] ) [EOL] return [EOL] except NoSuchBucket : [EOL] logger . info ( [string] ) [EOL] self . _create_bucket ( retries = [number] , read_timeout = [number] , connect_timeout = [number] ) [EOL] logger . info ( [string] ) [EOL] self . _wait_for_bucket ( retries = [number] , delay = [number] ) [EOL] return [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] def store ( self , product , task ) : [EOL] [docstring] [EOL] if task . output_format is None : [EOL] raise TypeError ( [string] ) [EOL] [EOL] k = self . KEY . format ( src_id = task . source_id , chk = task . checksum , out_fmt = task . output_format . value , ext = task . output_format . ext ) [EOL] self . _put ( k , product . stream . read ( ) , task . content_type ) [EOL] [EOL] def retrieve ( self , src_id , chk , out_fmt ) : [EOL] [docstring] [EOL] key = self . KEY . format ( src_id = src_id , chk = chk , out_fmt = out_fmt . value , ext = out_fmt . ext ) [EOL] resp = self . _get ( key ) [EOL] return Product ( stream = resp [ [string] ] , checksum = resp [ [string] ] [ [number] : - [number] ] ) [EOL] [EOL] def store_log ( self , product , task ) : [EOL] [docstring] [EOL] if task . output_format is None : [EOL] raise TypeError ( [string] ) [EOL] key = self . LOG_KEY . format ( src_id = task . source_id , chk = task . checksum , out_fmt = task . output_format . value , ext = task . output_format . ext ) [EOL] log_bytes = product . stream . read ( ) [EOL] logger . debug ( [string] , len ( log_bytes ) ) [EOL] self . _put ( key , log_bytes , [string] ) [EOL] [EOL] def retrieve_log ( self , src_id , chk , out_fmt ) : [EOL] [docstring] [EOL] key = self . LOG_KEY . format ( src_id = src_id , chk = chk , out_fmt = out_fmt . value , ext = out_fmt . ext ) [EOL] resp = self . _get ( key ) [EOL] return Product ( stream = resp [ [string] ] , checksum = resp [ [string] ] [ [number] : - [number] ] ) [EOL] [EOL] def _create_bucket ( self , retries = [number] , read_timeout = [number] , connect_timeout = [number] ) : [EOL] [docstring] [EOL] config = Config ( retries = { [string] : retries } , read_timeout = read_timeout , connect_timeout = connect_timeout ) [EOL] client = self . _new_client ( config = config ) [EOL] client . create_bucket ( Bucket = self . _bucket ) [EOL] [EOL] def _get ( self , key ) : [EOL] resp = ... [EOL] try : [EOL] resp = self . client . get_object ( Bucket = self . _bucket , Key = key ) [EOL] except ClientError as e : [EOL] self . _handle_client_error ( e ) [EOL] return resp [EOL] [EOL] def _put ( self , key , body , content_type ) : [EOL] try : [EOL] self . client . put_object ( Body = body , Bucket = self . _bucket , ContentMD5 = hash_content ( body ) , ContentType = content_type , Key = key ) [EOL] except ClientError as exc : [EOL] self . _handle_client_error ( exc ) [EOL] [EOL] @ classmethod def init_app ( cls , app ) : [EOL] [docstring] [EOL] app . config . setdefault ( [string] , [string] ) [EOL] app . config . setdefault ( [string] , None ) [EOL] app . config . setdefault ( [string] , None ) [EOL] app . config . setdefault ( [string] , None ) [EOL] app . config . setdefault ( [string] , True ) [EOL] app . config . setdefault ( [string] , [string] ) [EOL] [EOL] @ classmethod def get_session ( cls ) : [EOL] [docstring] [EOL] config = get_application_config ( ) [EOL] return cls ( config [ [string] ] , config [ [string] ] , config [ [string] ] , config [ [string] ] , config [ [string] ] , config [ [string] ] ) [EOL] [EOL] @ classmethod def current_session ( cls ) : [EOL] [docstring] [EOL] g = get_application_global ( ) [EOL] if g is None : [EOL] return cls . get_session ( ) [EOL] if [string] not in g : [EOL] g . store = cls . get_session ( ) [EOL] store = g . store [EOL] return store [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $boto3.client$ 0 0 0 $typing.Optional[botocore.config.Config]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $None$ 0 0 0 $botocore.exceptions.ClientError$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $botocore.exceptions.ClientError$ 0 0 0 0 0 0 $botocore.exceptions.ClientError$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $botocore.exceptions.ClientError$ 0 0 $botocore.exceptions.ClientError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $botocore.exceptions.ClientError$ 0 $typing.Any$ 0 0 0 0 0 $botocore.exceptions.ClientError$ 0 0 0 0 0 0 0 0 $botocore.exceptions.ClientError$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $domain.Product$ 0 $domain.Task$ 0 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $domain.Product$ 0 0 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 0 $domain.Product$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $domain.Format$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $domain.Format$ 0 $domain.Format$ 0 0 0 0 0 $domain.Format$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $domain.Product$ 0 $domain.Task$ 0 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 0 0 $domain.Task$ 0 0 0 0 0 0 $builtins.bytes$ 0 $domain.Product$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 $domain.Product$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $domain.Format$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $domain.Format$ 0 $domain.Format$ 0 0 0 0 0 $domain.Format$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $flask.Flask$ 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Store'$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $'Store'$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $Store$ 0 0 0 0 0 0 0 $Store$ 0 $typing.Any$ 0 $Store$ 0 0 $Store$ 0
from typing import Any , Tuple , Dict [EOL] import werkzeug [EOL] import typing [EOL] import unittest [EOL] import flask [EOL] [docstring] [EOL] [EOL] from unittest import TestCase , mock [EOL] import io [EOL] from http import HTTPStatus as status [EOL] [EOL] from flask import Flask [EOL] from werkzeug . datastructures import MultiDict [EOL] from werkzeug . exceptions import NotFound , BadRequest [EOL] [EOL] from . . domain import Task , Product , Format , Status [EOL] from . . import controllers , compiler [EOL] from . . services import store , filemanager [EOL] [EOL] [EOL] def mock_url_for ( endpoint , ** kwargs ) : [EOL] [docstring] [EOL] params = [string] . join ( map ( str , kwargs . values ( ) ) ) [EOL] return f' [string] { endpoint } [string] { params }' [EOL] [EOL] [EOL] def raise_store_does_not_exist ( * args , ** kwargs ) : [EOL] raise store . DoesNotExist ( [string] ) [EOL] [EOL] [EOL] def raise_no_such_task ( * args , ** kwargs ) : [EOL] raise compiler . NoSuchTask ( [string] ) [EOL] [EOL] [EOL] class TestRequestCompilation ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . app = Flask ( __name__ ) [EOL] filemanager . FileManager . init_app ( self . app ) [EOL] [EOL] def test_request_missing_parameter ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . compile ( MultiDict ( { [string] : [string] } ) , [string] , mock . MagicMock ( ) ) [EOL] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . compile ( MultiDict ( { [string] : [string] } ) , [string] , mock . MagicMock ( ) ) [EOL] [EOL] def test_bad_checksum ( self ) : [EOL] [docstring] [EOL] request_params = MultiDict ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . compile ( request_params , [string] , mock . MagicMock ( ) ) [EOL] [EOL] def test_bad_source_id ( self ) : [EOL] [docstring] [EOL] request_params = MultiDict ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . compile ( request_params , [string] , mock . MagicMock ( ) ) [EOL] [EOL] def test_bad_format ( self ) : [EOL] [docstring] [EOL] request_params = MultiDict ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . compile ( request_params , [string] , mock . MagicMock ( ) ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_compile_de_novo ( self , mock_fm , mock_store , mock_compiler ) : [EOL] [docstring] [EOL] mock_fm . current_session . return_value . owner . return_value = None [EOL] mock_compiler . NoSuchTask = compiler . NoSuchTask [EOL] mock_compiler . get_task . side_effect = compiler . NoSuchTask [EOL] task_id = [string] [EOL] token = [string] [EOL] mock_compiler . start_compilation . return_value = task_id [EOL] [EOL] request_data = MultiDict ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] with self . app . app_context ( ) : [EOL] response_data = controllers . compile ( request_data , token , mock . MagicMock ( ) ) [EOL] data , code , headers = response_data [EOL] self . assertEqual ( code , status . ACCEPTED ) [EOL] self . assertIn ( [string] , headers ) [EOL] self . assertIn ( str ( request_data [ [string] ] ) , headers [ [string] ] ) [EOL] self . assertIn ( request_data [ [string] ] , headers [ [string] ] ) [EOL] self . assertIn ( request_data [ [string] ] , headers [ [string] ] ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_compile_exists ( self , mock_store , mock_compiler ) : [EOL] [docstring] [EOL] task_id = [string] [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = [string] [EOL] token = [string] [EOL] mock_compiler . get_task . return_value = Task ( source_id = source_id , output_format = Format . PDF , status = Status . COMPLETED , task_id = task_id , checksum = checksum ) [EOL] request_data = MultiDict ( { [string] : source_id , [string] : checksum , [string] : output_format } ) [EOL] mock_session = mock . MagicMock ( ) [EOL] response_data = controllers . compile ( request_data , token , mock_session ) [EOL] data , code , headers = response_data [EOL] self . assertEqual ( code , status . SEE_OTHER ) [EOL] self . assertIn ( [string] , headers ) [EOL] self . assertIn ( str ( request_data [ [string] ] ) , headers [ [string] ] ) [EOL] self . assertIn ( request_data [ [string] ] , headers [ [string] ] ) [EOL] self . assertIn ( request_data [ [string] ] , headers [ [string] ] ) [EOL] [EOL] [EOL] class TestGetTask ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_bad_checksum ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . get_status ( [string] , [string] , [string] ) [EOL] [EOL] def test_bad_source_id ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . get_status ( [string] , [string] , [string] ) [EOL] [EOL] def test_bad_format ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . get_status ( [string] , [string] , [string] ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_get_info_completed ( self , mock_compiler ) : [EOL] [docstring] [EOL] task_id = [string] [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = [string] [EOL] mock_compiler . get_task . return_value = Task ( source_id = source_id , output_format = Format . PDF , status = Status . COMPLETED , task_id = task_id , checksum = checksum ) [EOL] response_data = controllers . get_status ( source_id , checksum , output_format ) [EOL] data , code , headers = response_data [EOL] self . assertEqual ( code , status . OK ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_get_info_in_progress ( self , mock_compiler ) : [EOL] [docstring] [EOL] task_id = [string] [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = [string] [EOL] mock_compiler . get_task . return_value = Task ( source_id = source_id , output_format = Format . PDF , status = Status . IN_PROGRESS , task_id = task_id , checksum = checksum ) [EOL] response_data = controllers . get_status ( source_id , checksum , output_format ) [EOL] data , code , headers = response_data [EOL] self . assertEqual ( code , status . OK ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_get_info_nonexistant ( self , mock_compiler ) : [EOL] [docstring] [EOL] mock_compiler . NoSuchTask = compiler . NoSuchTask [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = [string] [EOL] mock_compiler . get_task . side_effect = compiler . NoSuchTask [EOL] [EOL] with self . assertRaises ( NotFound ) : [EOL] controllers . get_status ( source_id , checksum , output_format ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_get_status_completed ( self , mock_compiler ) : [EOL] [docstring] [EOL] task_id = [string] [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = [string] [EOL] mock_compiler . get_task . return_value = Task ( source_id = source_id , output_format = Format . PDF , status = Status . COMPLETED , task_id = task_id , checksum = checksum ) [EOL] response_data = controllers . get_status ( source_id , checksum , output_format ) [EOL] data , code , headers = response_data [EOL] self . assertEqual ( code , status . OK ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_get_status_in_progress ( self , mock_compiler ) : [EOL] [docstring] [EOL] task_id = [string] [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = Format . PDF [EOL] mock_compiler . get_task . return_value = Task ( source_id = source_id , output_format = Format . PDF , status = Status . IN_PROGRESS , task_id = task_id , checksum = checksum ) [EOL] response_data = controllers . get_status ( source_id , checksum , output_format . value ) [EOL] data , code , headers = response_data [EOL] self . assertEqual ( code , status . OK ) [EOL] [EOL] [EOL] class TestGetProduct ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_bad_checksum ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . get_product ( [string] , [string] , [string] ) [EOL] [EOL] def test_bad_source_id ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . get_product ( [string] , [string] , [string] ) [EOL] [EOL] def test_bad_format ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . get_product ( [string] , [string] , [string] ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock . MagicMock ( ) ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_get_product_completed ( self , mock_store ) : [EOL] [docstring] [EOL] task_id = [string] [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = [string] [EOL] product_checksum = [string] [EOL] mock_store . current_session . return_value . retrieve . return_value = Product ( stream = io . BytesIO ( [string] ) , checksum = product_checksum ) [EOL] response_data = controllers . get_product ( source_id , checksum , output_format ) [EOL] data , code , headers = response_data [EOL] self . assertEqual ( code , status . OK ) [EOL] self . assertEqual ( headers [ [string] ] , product_checksum ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_get_product_nonexistant ( self , mock_store , mock_compiler ) : [EOL] [docstring] [EOL] mock_compiler . NoSuchTask = compiler . NoSuchTask [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = [string] [EOL] mock_compiler . get_task . side_effect = compiler . NoSuchTask [EOL] [EOL] with self . assertRaises ( NotFound ) : [EOL] controllers . get_product ( source_id , checksum , output_format ) [EOL] [EOL] [EOL] class TestGetCompilationLog ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_bad_checksum ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . get_log ( [string] , [string] , [string] ) [EOL] [EOL] def test_bad_source_id ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . get_log ( [string] , [string] , [string] ) [EOL] [EOL] def test_bad_format ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( BadRequest ) : [EOL] controllers . get_log ( [string] , [string] , [string] ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock . MagicMock ( ) ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_get_log_completed ( self , mock_store ) : [EOL] [docstring] [EOL] task_id = [string] [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = [string] [EOL] product_checksum = [string] [EOL] mock_store . current_session . return_value . retrieve_log . return_value = Product ( stream = io . BytesIO ( [string] ) , checksum = product_checksum ) [EOL] response_data = controllers . get_log ( source_id , checksum , output_format ) [EOL] data , code , headers = response_data [EOL] self . assertEqual ( code , status . OK ) [EOL] self . assertEqual ( headers [ [string] ] , product_checksum ) [EOL] [EOL] @ mock . patch ( f'{ controllers . __name__ } [string] ' , mock_url_for ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) @ mock . patch ( f'{ controllers . __name__ } [string] ' ) def test_get_log_nonexistant ( self , mock_store , mock_compiler ) : [EOL] [docstring] [EOL] mock_compiler . NoSuchTask = compiler . NoSuchTask [EOL] source_id = [string] [EOL] checksum = [string] [EOL] output_format = [string] [EOL] mock_compiler . get_task . side_effect = compiler . NoSuchTask [EOL] [EOL] with self . assertRaises ( NotFound ) : [EOL] controllers . get_log ( source_id , checksum , output_format ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.MultiDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],builtins.int,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0
import unittest [EOL] import compiler [EOL] import flask [EOL] [docstring] [EOL] [EOL] import io [EOL] from tempfile import TemporaryDirectory , mkstemp , mkdtemp [EOL] from unittest import TestCase , mock [EOL] import shutil [EOL] import tempfile [EOL] from operator import itemgetter [EOL] [EOL] import os . path [EOL] import subprocess [EOL] import docker [EOL] [EOL] from importlib_resources import read_binary [EOL] [EOL] from flask import Flask [EOL] from arxiv . integration . api import exceptions , status [EOL] [EOL] from . . factory import create_app [EOL] from . . import compiler [EOL] from . . import domain , util [EOL] from . . services import filemanager [EOL] [EOL] data_dir = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] [EOL] class TestStartCompilation ( TestCase ) : [EOL] [docstring] [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' , mock . MagicMock ( ) ) @ mock . patch ( f'{ compiler . __name__ } [string] ' , mock . MagicMock ( ) ) @ mock . patch ( f'{ compiler . __name__ } [string] ' , mock . MagicMock ( ) ) def test_start_compilation_ok ( self ) : [EOL] [docstring] [EOL] task_id = compiler . start_compilation ( [string] , [string] , [string] , [string] , output_format = domain . Format . PDF , token = [string] ) [EOL] self . assertEqual ( task_id , [string] , [string] ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' , mock . MagicMock ( ) ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_start_compilation_errs ( self , mock_do_compile ) : [EOL] [docstring] [EOL] def raise_runtimeerror ( * args , ** kwargs ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] mock_do_compile . apply_async . side_effect = raise_runtimeerror [EOL] with self . assertRaises ( compiler . TaskCreationFailed ) : [EOL] compiler . start_compilation ( [string] , [string] , [string] , [string] , output_format = domain . Format . PDF , token = [string] ) [EOL] [EOL] [EOL] class TestGetTask ( TestCase ) : [EOL] [docstring] [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_get_nonexistant_task ( self , mock_do ) : [EOL] [docstring] [EOL] [comment] [EOL] mock_do . AsyncResult . return_value = mock . MagicMock ( status = [string] ) [EOL] [EOL] with self . assertRaises ( compiler . NoSuchTask ) : [EOL] compiler . get_task ( [string] , [string] , domain . Format . PDF ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_get_unstarted_task ( self , mock_do ) : [EOL] [docstring] [EOL] [comment] [EOL] mock_do . AsyncResult . return_value = mock . MagicMock ( status = [string] , info = { [string] : [string] } ) [EOL] task = compiler . get_task ( [string] , [string] , domain . Format . PDF ) [EOL] self . assertEqual ( task . status , domain . Status . IN_PROGRESS ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_get_started_task ( self , mock_do ) : [EOL] [docstring] [EOL] [comment] [EOL] mock_do . AsyncResult . return_value = mock . MagicMock ( status = [string] , info = { [string] : [string] } ) [EOL] task = compiler . get_task ( [string] , [string] , domain . Format . PDF ) [EOL] self . assertEqual ( task . status , domain . Status . IN_PROGRESS ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_get_retry_task ( self , mock_do ) : [EOL] [docstring] [EOL] [comment] [EOL] mock_do . AsyncResult . return_value = mock . MagicMock ( status = [string] , info = { [string] : [string] } ) [EOL] task = compiler . get_task ( [string] , [string] , domain . Format . PDF ) [EOL] self . assertEqual ( task . status , domain . Status . IN_PROGRESS ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_get_failed ( self , mock_do ) : [EOL] [docstring] [EOL] [comment] [EOL] mock_do . AsyncResult . return_value = mock . MagicMock ( status = [string] , info = { [string] : [string] } ) [EOL] task = compiler . get_task ( [string] , [string] , domain . Format . PDF ) [EOL] self . assertEqual ( task . status , domain . Status . FAILED ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_get_succeeded ( self , mock_do ) : [EOL] [docstring] [EOL] [comment] [EOL] mock_do . AsyncResult . return_value = mock . MagicMock ( status = [string] , result = { [string] : [string] } , info = { [string] : [string] } ) [EOL] task = compiler . get_task ( [string] , [string] , domain . Format . PDF ) [EOL] self . assertEqual ( task . status , domain . Status . COMPLETED ) [EOL] self . assertEqual ( task . reason , domain . Reason . NONE ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_get_failed_gracefully ( self , mock_do ) : [EOL] [docstring] [EOL] for reason in domain . Reason : [EOL] mock_do . AsyncResult . return_value = mock . MagicMock ( status = [string] , result = { [string] : [string] , [string] : reason . value , [string] : [string] } , info = { [string] : [string] } ) [EOL] task = compiler . get_task ( [string] , [string] , domain . Format . PDF ) [EOL] self . assertEqual ( task . status , domain . Status . FAILED ) [EOL] self . assertEqual ( task . reason , reason ) [EOL] [EOL] [EOL] class TestDoCompile ( TestCase ) : [EOL] [docstring] [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_do_compile_success ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] with open ( out_path , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] mock_Compiler . return_value . return_value = ( out_path , log_path ) [EOL] mock_Compiler . return_value . is_available . return_value = True [EOL] mock_source = mock . MagicMock ( etag = [string] ) [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( return_value = mock_source ) ) [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_cannot_store_log ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] with open ( out_path , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] mock_Compiler . return_value . return_value = ( out_path , log_path ) [EOL] mock_Compiler . return_value . is_available . return_value = True [EOL] mock_source = mock . MagicMock ( etag = [string] ) [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( return_value = mock_source ) ) [EOL] [EOL] mock_store . current_session . return_value . store_log . side_effect = RuntimeError [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_docker_fails ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] with open ( out_path , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] mock_Compiler . return_value . side_effect = RuntimeError [EOL] mock_Compiler . return_value . is_available . return_value = True [EOL] mock_source = mock . MagicMock ( etag = [string] ) [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( return_value = mock_source ) ) [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_unauthorized ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] [EOL] def raise_unauthorized ( * args , ** kwargs ) : [EOL] raise exceptions . RequestUnauthorized ( [string] , mock . MagicMock ( ) ) [EOL] [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( side_effect = raise_unauthorized ) ) [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_forbidden ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] [EOL] def raise_forbidden ( * args , ** kwargs ) : [EOL] raise exceptions . RequestForbidden ( [string] , mock . MagicMock ( ) ) [EOL] [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( side_effect = raise_forbidden ) ) [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_connection_failed ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] [EOL] def raise_conn_failed ( * args , ** kwargs ) : [EOL] raise exceptions . ConnectionFailed ( [string] , mock . MagicMock ( ) ) [EOL] [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( side_effect = raise_conn_failed ) ) [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_not_found ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] [EOL] def raise_not_found ( * args , ** kwargs ) : [EOL] raise exceptions . NotFound ( [string] , mock . MagicMock ( ) ) [EOL] [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( side_effect = raise_not_found ) ) [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_bad_checksum ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] [EOL] mock_Compiler . return_value . return_value = ( out_path , log_path ) [EOL] mock_Compiler . return_value . is_available . return_value = True [EOL] [EOL] mock_source = mock . MagicMock ( etag = [string] ) [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( return_value = mock_source ) ) [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True , [string] : [string] , [string] : [string] } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_source_corrupted ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] [EOL] def raise_corrupted ( * args , ** kwargs ) : [EOL] raise compiler . CorruptedSource ( [string] , mock . MagicMock ( ) ) [EOL] [EOL] mock_Compiler . return_value . side_effect = raise_corrupted [EOL] mock_Compiler . return_value . is_available . return_value = True [EOL] mock_source = mock . MagicMock ( etag = [string] ) [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( return_value = mock_source ) ) [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True , [string] : [string] , [string] : [string] } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_no_output ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] [EOL] mock_Compiler . return_value . return_value = ( None , log_path ) [EOL] mock_Compiler . return_value . is_available . return_value = True [EOL] mock_source = mock . MagicMock ( etag = [string] ) [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( return_value = mock_source ) ) [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True , [string] : [string] , [string] : [string] } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_cannot_save ( self , mock_store , mock_Compiler , mock_filemanager ) : [EOL] [docstring] [EOL] container_source_root = mkdtemp ( ) [EOL] _ , out_path = mkstemp ( ) [EOL] _ , log_path = mkstemp ( ) [EOL] [EOL] mock_Compiler . return_value . return_value = ( out_path , log_path ) [EOL] mock_Compiler . return_value . is_available . return_value = True [EOL] mock_source = mock . MagicMock ( etag = [string] ) [EOL] mock_filemanager . current_session . return_value = mock . MagicMock ( get_source_content = mock . MagicMock ( return_value = mock_source ) ) [EOL] [EOL] def raise_runtimeerror ( * args , ** kwargs ) : [EOL] raise RuntimeError ( [string] , mock . MagicMock ( ) ) [EOL] [EOL] mock_store . current_session . return_value . store . side_effect = raise_runtimeerror [EOL] [EOL] app = Flask ( [string] ) [EOL] app . config . update ( { [string] : container_source_root , [string] : True , [string] : [string] , [string] : [string] } ) [EOL] with app . app_context ( ) : [EOL] self . assertDictEqual ( compiler . do_compile ( [string] , [string] , [string] , [string] , [string] , token = [string] ) , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] [EOL] [EOL] class TestCompiler ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . source_dir = tempfile . mkdtemp ( ) [EOL] self . root , _ = os . path . split ( self . source_dir ) [EOL] self . source_path = os . path . join ( self . source_dir , [string] ) [EOL] open ( self . source_path , [string] ) . close ( ) [EOL] self . cache_dir = os . path . join ( self . source_dir , [string] ) [EOL] self . log_dir = os . path . join ( self . source_dir , [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] shutil . rmtree ( self . source_dir ) [comment] [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_is_available ( self , mock_current_app , mock_DockerClient , mock_boto3_client ) : [EOL] [docstring] [EOL] mock_current_app . config = { [string] : [string] , [string] : False , [string] : [string] , [string] : self . root , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] mock_boto3_client . return_value . get_authorization_token . return_value = { [string] : [ { [string] : [string] } ] } [EOL] [EOL] compile = compiler . Converter ( ) [EOL] [EOL] self . assertTrue ( compile . is_available ( ) ) [EOL] self . assertEqual ( mock_DockerClient . return_value . info . call_count , [number] , [string] ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_is_not_available ( self , mock_current_app , mock_DockerClient , mock_boto3_client ) : [EOL] [docstring] [EOL] mock_current_app . config = { [string] : [string] , [string] : False , [string] : [string] , [string] : self . root , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] mock_boto3_client . return_value . get_authorization_token . return_value = { [string] : [ { [string] : [string] } ] } [EOL] [EOL] def raise_APIError ( * args , ** kwargs ) : [EOL] raise docker . errors . APIError ( [string] ) [EOL] [EOL] mock_DockerClient . return_value . info . side_effect = raise_APIError [EOL] [EOL] compile = compiler . Converter ( ) [EOL] [EOL] self . assertFalse ( compile . is_available ( ) , [string] ) [EOL] self . assertEqual ( mock_DockerClient . return_value . info . call_count , [number] , [string] ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_run ( self , mock_current_app , mock_DockerClient , mock_boto3_client ) : [EOL] [docstring] [EOL] os . makedirs ( self . cache_dir ) [EOL] os . makedirs ( self . log_dir ) [EOL] [EOL] open ( os . path . join ( self . cache_dir , [string] ) , [string] ) . close ( ) [EOL] open ( os . path . join ( self . log_dir , [string] ) , [string] ) . close ( ) [EOL] [EOL] mock_current_app . config = { [string] : [string] , [string] : False , [string] : [string] , [string] : self . root , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] mock_boto3_client . return_value . get_authorization_token . return_value = { [string] : [ { [string] : [string] } ] } [EOL] [EOL] [EOL] mock_DockerClient . return_value . containers . run . return_value = [string] [EOL] pkg = domain . SourcePackage ( [string] , self . source_path , [string] ) [EOL] compile = compiler . Converter ( ) [EOL] out_path , log_path = compile ( pkg , [string] , [string] ) [EOL] self . assertTrue ( out_path . endswith ( [string] ) ) [EOL] self . assertTrue ( log_path . endswith ( [string] ) ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_run_logfile_fails ( self , mock_current_app , mock_DockerClient , mock_boto3_client ) : [EOL] [docstring] [EOL] os . makedirs ( self . cache_dir ) [EOL] [EOL] open ( os . path . join ( self . cache_dir , [string] ) , [string] ) . close ( ) [EOL] [EOL] mock_current_app . config = { [string] : [string] , [string] : False , [string] : [string] , [string] : self . root , [string] : [string] , [string] : [string] , [string] : [string] , [string] : False } [EOL] mock_boto3_client . return_value . get_authorization_token . return_value = { [string] : [ { [string] : [string] } ] } [EOL] [comment] [EOL] mock_DockerClient . return_value . containers . run . return_value = [string] [EOL] pkg = domain . SourcePackage ( [string] , self . source_path , [string] ) [EOL] compile = compiler . Converter ( ) [EOL] out_path , log_path = compile ( pkg , [string] , [string] ) [EOL] [EOL] self . assertTrue ( out_path . endswith ( [string] ) ) [EOL] self . assertTrue ( log_path . endswith ( [string] ) ) [EOL] [EOL] with open ( log_path , [string] ) as f : [EOL] self . assertEqual ( f . read ( ) , [string] ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_docker_api_fails ( self , mock_current_app , mock_DockerClient , mock_boto3_client ) : [EOL] [docstring] [EOL] mock_current_app . config = { [string] : [string] , [string] : False , [string] : [string] , [string] : self . root , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] mock_boto3_client . return_value . get_authorization_token . return_value = { [string] : [ { [string] : [string] } ] } [EOL] [EOL] def raise_APIError ( * args , ** kwargs ) : [EOL] raise docker . errors . APIError ( [string] ) [EOL] [EOL] mock_DockerClient . return_value . containers . run . side_effect = raise_APIError [EOL] pkg = domain . SourcePackage ( [string] , self . source_path , [string] ) [EOL] compile = compiler . Converter ( ) [EOL] with self . assertRaises ( RuntimeError ) : [EOL] compile ( pkg , [string] , [string] ) [EOL] [EOL] @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) @ mock . patch ( f'{ compiler . __name__ } [string] ' ) def test_run_fails ( self , mock_current_app , mock_DockerClient , mock_boto3_client ) : [EOL] [docstring] [EOL] os . makedirs ( self . cache_dir ) [EOL] os . makedirs ( self . log_dir ) [EOL] open ( os . path . join ( self . log_dir , [string] ) , [string] ) . close ( ) [EOL] [EOL] mock_current_app . config = { [string] : [string] , [string] : False , [string] : [string] , [string] : self . root , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] mock_boto3_client . return_value . get_authorization_token . return_value = { [string] : [ { [string] : [string] } ] } [EOL] [EOL] [comment] [EOL] mock_DockerClient . return_value . containers . run . return_value = [string] [EOL] pkg = domain . SourcePackage ( [string] , self . source_path , [string] ) [EOL] compile = compiler . Converter ( ) [EOL] out_path , log_path = compile ( pkg , [string] , [string] ) [EOL] self . assertIsNone ( out_path ) [EOL] self . assertTrue ( log_path . endswith ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.Task$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 0 0 0 0 0 0 0 0 0 0 $compiler.compiler.Converter$ 0 $compiler.domain.SourcePackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Tuple , List , Dict [EOL] import typing [EOL] import os [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] sys . path . append ( os . path . abspath ( [string] ) ) [EOL] sys . path . append ( os . path . abspath ( [string] ) ) [EOL] [EOL] from compiler . factory import create_app [EOL] app = create_app ( ) [EOL] app . app_context ( ) . push ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] version = [string] [EOL] [comment] [EOL] release = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] pygments_style = None [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_title = project [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_exclude_files = [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] intersphinx_mapping = { [string] : ( [string] , None ) , [string] : ( [string] , None ) , [string] : ( [string] , None ) , [string] : ( [string] , None ) , [string] : ( [string] , None ) , [string] : ( [string] , None ) , [string] : ( [string] , None ) , [string] : ( [string] , None ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0