from setuptools import setup , find_packages [EOL] [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , url = [string] , author = [string] , author_email = [string] , packages = find_packages ( include = [ [string] ] ) , test_suite = [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import List , Any , Dict [EOL] import typing [EOL] import waifunet [EOL] [docstring] [EOL] [EOL] import os [EOL] from os import path [EOL] import pytest [EOL] import json [EOL] from waifunet . clusterspec import ClusterSpecParser [EOL] [EOL] [EOL] this_directory_path = path . abspath ( path . dirname ( __file__ ) ) [EOL] sane_input_file = [string] [EOL] [EOL] [EOL] class TestParseTextfile : [EOL] @ staticmethod def initialize_parser ( ) : [EOL] parser = ClusterSpecParser ( ) [EOL] parser . parse_textfile ( path . join ( this_directory_path , sane_input_file ) ) [EOL] return parser [EOL] [EOL] def test_to_dict ( self ) : [EOL] parser = self . initialize_parser ( ) [EOL] result = parser . to_dict ( ) [EOL] self . check_parsed_textfile ( result ) [EOL] [EOL] def test_to_json ( self ) : [EOL] parser = self . initialize_parser ( ) [EOL] result = parser . to_json ( ) [EOL] result_as_dict = json . loads ( result ) [EOL] self . check_parsed_textfile ( result_as_dict ) [EOL] [EOL] def test_write_json_to_file ( self ) : [EOL] filename = [string] [EOL] filepath = path . join ( this_directory_path , filename ) [EOL] parser = self . initialize_parser ( ) [EOL] parser . save_json ( filepath ) [EOL] with open ( filepath , [string] ) as fd : [EOL] result = json . load ( fd ) [EOL] os . remove ( filepath ) [EOL] self . check_parsed_textfile ( result ) [EOL] [EOL] @ staticmethod def check_parsed_textfile ( result ) : [EOL] assert len ( result ) == [number] [EOL] assert [string] in result [EOL] assert [string] in result [EOL] ps = result [ [string] ] [EOL] workers = result [ [string] ] [EOL] assert len ( ps ) == [number] [EOL] TestParseTextfile . check_for_tfpool_in_names ( ps ) [EOL] assert len ( workers ) == [number] [EOL] TestParseTextfile . check_for_tfpool_in_names ( workers ) [EOL] [EOL] @ staticmethod def check_for_tfpool_in_names ( hostnames ) : [EOL] for name in hostnames : [EOL] assert name [ : [number] ] == [string] [EOL] [EOL] [EOL] class TestConstructor : [EOL] def test_sane_input ( self ) : [EOL] parser = ClusterSpecParser ( max_ps = [number] , max_workers = [number] ) [EOL] assert parser . max_ps == [number] [EOL] assert parser . max_workers == [number] [EOL] [EOL] def test_not_enough_ps ( self ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] ClusterSpecParser ( max_ps = [number] ) [EOL] [EOL] def test_not_enough_workers ( self ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] ClusterSpecParser ( max_workers = [number] ) [EOL] [EOL] [EOL] class TestParseExternalCommand : [EOL] def test_parse_list_hostnames_mock_sh ( self ) : [EOL] command = [ path . join ( this_directory_path , [string] ) ] [EOL] parser = ClusterSpecParser ( ) [EOL] parser . parse_external ( command ) [EOL] result = parser . to_dict ( ) [EOL] TestParseTextfile . check_parsed_textfile ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $waifunet.clusterspec.ClusterSpecParser$ 0 0 0 0 0 $waifunet.clusterspec.ClusterSpecParser$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $waifunet.clusterspec.ClusterSpecParser$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $waifunet.clusterspec.ClusterSpecParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $waifunet.clusterspec.ClusterSpecParser$ 0 0 0 0 0 0 $waifunet.clusterspec.ClusterSpecParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $waifunet.clusterspec.ClusterSpecParser$ 0 0 0 0 0 $waifunet.clusterspec.ClusterSpecParser$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 $waifunet.clusterspec.ClusterSpecParser$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0
[docstring] [EOL]	0 0
from typing import Type , List , Pattern , Dict [EOL] import os [EOL] import subprocess [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import random [EOL] import os [EOL] import re [EOL] import json [EOL] import subprocess [EOL] from typing import List , Dict [EOL] from os import PathLike [EOL] ClusterSpec = Dict [ str , List [ str ] ] [EOL] [EOL] [EOL] class ClusterSpecParser : [EOL] TIMEOUT_EXTERNAL = [number] [comment] [EOL] [EOL] [docstring] [EOL] def __init__ ( self , max_ps = [number] , max_workers = [number] ) : [EOL] [docstring] [EOL] assert max_ps > [number] [EOL] self . max_ps = max_ps [EOL] assert max_workers > [number] [EOL] self . max_workers = max_workers [EOL] self . spec = dict ( ) [EOL] [EOL] def to_dict ( self ) : [EOL] return self . spec [EOL] [EOL] def to_json ( self ) : [EOL] return json . dumps ( self . spec ) [EOL] [EOL] def save_json ( self , path ) : [EOL] with open ( path , [string] ) as fd : [EOL] json . dump ( self . spec , fd ) [EOL] [EOL] def parse_textfile ( self , path ) : [EOL] [docstring] [EOL] with open ( path ) as fd : [EOL] hostnames = [ line for line in fd if line ] [EOL] self . parse_list ( hostnames ) [EOL] [EOL] def parse_list ( self , hostnames ) : [EOL] match_nonascii = re . compile ( [string] , flags = re . ASCII ) [EOL] sanitized = [ match_nonascii . sub ( [string] , name ) for name in hostnames ] [EOL] sampled = random . sample ( sanitized , self . max_ps + self . max_workers ) [EOL] ps = sampled [ : self . max_ps ] [EOL] workers = sampled [ self . max_ps : ] [EOL] self . spec = { [string] : ps , [string] : workers } [EOL] [EOL] def parse_external ( self , args ) : [EOL] [docstring] [EOL] completed = subprocess . run ( args , timeout = self . TIMEOUT_EXTERNAL , stdout = subprocess . PIPE ) [EOL] hostnames = completed . stdout . decode ( ) . splitlines ( ) [EOL] self . parse_list ( hostnames ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ClusterSpec$ 0 0 0 0 0 0 0 $ClusterSpec$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.PathLike$ 0 0 0 0 0 0 $os.PathLike$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.PathLike$ 0 0 0 0 0 0 0 0 $os.PathLike$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0