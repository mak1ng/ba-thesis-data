from typing import List , Optional [EOL] import typing [EOL] import builtins [EOL] import src [EOL] from random import SystemRandom [EOL] from src . camera import Camera [EOL] from src . hittable import HitRecord , Hittable , HittableList [EOL] from src . material import Lambertian , Metal , ReflectionRecord [EOL] from src . ppm import PPM [EOL] from src . ray import Ray [EOL] from src . sphere import Sphere [EOL] from src . utils import _derive_ppm_filename [EOL] from src . vec3 import Vec3 [EOL] from typing import List , Optional [EOL] [EOL] import math [EOL] import sys [EOL] [EOL] UNIT_VEC3 = Vec3 ( [number] , [number] , [number] ) [EOL] random = SystemRandom ( ) [EOL] [EOL] def color ( ray , world , depth ) : [EOL] [comment] [EOL] [comment] [EOL] hit_attempt = world . hit ( ray , [number] , sys . float_info . max ) [EOL] if hit_attempt is not None : [EOL] reflection = hit_attempt . material . scatter ( ray , hit_attempt ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if depth < [number] and reflection is not None : [EOL] [comment] [EOL] return reflection . attenuation * color ( reflection . scattering , world , depth + [number] ) [EOL] else : [EOL] return Vec3 ( [number] , [number] , [number] ) [EOL] else : [EOL] unit_direction = ray . direction . unit_vector ( ) [EOL] t = [number] * ( unit_direction . y + [number] ) [EOL] return ( ( [number] - t ) * UNIT_VEC3 ) + ( t * Vec3 ( [number] , [number] , [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] width = [number] [EOL] height = [number] [EOL] sampling_size = [number] [EOL] ppm = PPM ( width , height ) [EOL] lower_left_corner = Vec3 ( - [number] , - [number] , - [number] ) [EOL] h_movement = Vec3 ( [number] , [number] , [number] ) [EOL] v_movement = Vec3 ( [number] , [number] , [number] ) [EOL] origin = Vec3 ( [number] , [number] , [number] ) [EOL] cam = Camera ( lower_left_corner , h_movement , v_movement , origin ) [EOL] [EOL] hittables = [ Sphere ( Vec3 ( [number] , [number] , - [number] ) , [number] , Lambertian ( Vec3 ( [number] , [number] , [number] ) ) ) , Sphere ( Vec3 ( [number] , - [number] , - [number] ) , [number] , Lambertian ( Vec3 ( [number] , [number] , [number] ) ) ) , Sphere ( Vec3 ( [number] , [number] , - [number] ) , [number] , Metal ( Vec3 ( [number] , [number] , [number] ) , [number] ) ) , Sphere ( Vec3 ( - [number] , [number] , - [number] ) , [number] , Metal ( Vec3 ( [number] , [number] , [number] ) , [number] ) ) ] [EOL] world = HittableList ( hittables ) [EOL] [EOL] for j in range ( height - [number] , - [number] , - [number] ) : [EOL] for i in range ( width ) : [EOL] print ( [string] % ( j , i ) ) [EOL] print ( [string] , end = [string] ) [EOL] accumulator = Vec3 ( [number] , [number] , [number] ) [EOL] for sample in range ( sampling_size ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] u = float ( i + random . random ( ) ) / float ( width ) [EOL] v = float ( j + random . random ( ) ) / float ( height ) [EOL] r = cam . get_ray ( u , v ) [EOL] accumulator += color ( r , world , [number] ) [EOL] [EOL] accumulator /= float ( sampling_size ) [EOL] print ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] accumulator . map ( math . sqrt ) [EOL] accumulator *= [number] [EOL] accumulator . map ( int ) [EOL] [EOL] ppm . set_pixel ( ( height - [number] ) - j , i , accumulator ) [EOL] [EOL] ppm . write ( _derive_ppm_filename ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.hittable.HittableList$ 0 0 0 0 0 0 0 0 0 0 0 $src.hittable.HittableList$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.hittable.HittableList$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $typing.List[src.hittable.Hittable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.hittable.HittableList$ 0 0 0 $typing.List[src.hittable.Hittable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.ray.Ray$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $src.vec3.Vec3$ 0 0 0 $src.ray.Ray$ 0 $src.hittable.HittableList$ 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0
from typing import List , Optional [EOL] import typing [EOL] import builtins [EOL] import src [EOL] import random [EOL] [docstring] [EOL] from random import SystemRandom [EOL] from src . camera import Camera [EOL] from src . hittable import HitRecord , Hittable , HittableList [EOL] from src . ppm import PPM [EOL] from src . ray import Ray [EOL] from src . sphere import Sphere [EOL] from src . utils import _derive_ppm_filename [EOL] from src . vec3 import Vec3 [EOL] from typing import List , Optional [EOL] [EOL] import math [EOL] import sys [EOL] [EOL] UNIT_VEC3 = Vec3 ( [number] , [number] , [number] ) [EOL] random = SystemRandom ( ) [EOL] [EOL] def color ( ray , world ) : [EOL] [comment] [EOL] [comment] [EOL] hit_attempt = world . hit ( ray , [number] , sys . float_info . max ) [EOL] if hit_attempt is not None : [EOL] target = hit_attempt . p + hit_attempt . normal + random_unit_sphere_point ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [number] * color ( Ray ( hit_attempt . p , target - hit_attempt . p ) , world ) [EOL] else : [EOL] unit_direction = ray . direction . unit_vector ( ) [EOL] t = [number] * ( unit_direction . y + [number] ) [EOL] return ( ( [number] - t ) * UNIT_VEC3 ) + ( t * Vec3 ( [number] , [number] , [number] ) ) [EOL] [EOL] def random_unit_sphere_point ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] rand_point = Vec3 ( random . uniform ( - [number] , [number] ) , random . uniform ( - [number] , [number] ) , random . uniform ( - [number] , [number] ) ) [EOL] [EOL] while rand_point . squared_length ( ) >= [number] : [EOL] rand_point = Vec3 ( random . uniform ( - [number] , [number] ) , random . uniform ( - [number] , [number] ) , random . uniform ( - [number] , [number] ) ) [EOL] [EOL] return rand_point [EOL] [EOL] if __name__ == [string] : [EOL] width = [number] [EOL] height = [number] [EOL] sampling_size = [number] [EOL] ppm = PPM ( width , height ) [EOL] lower_left_corner = Vec3 ( - [number] , - [number] , - [number] ) [EOL] h_movement = Vec3 ( [number] , [number] , [number] ) [EOL] v_movement = Vec3 ( [number] , [number] , [number] ) [EOL] origin = Vec3 ( [number] , [number] , [number] ) [EOL] cam = Camera ( lower_left_corner , h_movement , v_movement , origin ) [EOL] [EOL] hittables = [ Sphere ( Vec3 ( [number] , [number] , - [number] ) , [number] ) , Sphere ( Vec3 ( [number] , - [number] , - [number] ) , [number] ) ] [EOL] world = HittableList ( hittables ) [EOL] [EOL] for j in range ( height - [number] , - [number] , - [number] ) : [EOL] for i in range ( width ) : [EOL] print ( [string] % ( j , i ) ) [EOL] print ( [string] , end = [string] ) [EOL] accumulator = Vec3 ( [number] , [number] , [number] ) [EOL] for sample in range ( sampling_size ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] u = float ( i + random . random ( ) ) / float ( width ) [EOL] v = float ( j + random . random ( ) ) / float ( height ) [EOL] r = cam . get_ray ( u , v ) [EOL] accumulator += color ( r , world ) [EOL] [EOL] accumulator /= float ( sampling_size ) [EOL] print ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] accumulator . map ( math . sqrt ) [EOL] accumulator *= [number] [EOL] accumulator . map ( int ) [EOL] [EOL] ppm . set_pixel ( ( height - [number] ) - j , i , accumulator ) [EOL] [EOL] ppm . write ( _derive_ppm_filename ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $random.SystemRandom$ 0 0 0 0 $random.SystemRandom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $random.SystemRandom$ 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.hittable.HittableList$ 0 0 0 0 0 0 0 0 0 $src.hittable.HittableList$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.hittable.HittableList$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $random.SystemRandom$ 0 0 0 0 0 0 0 0 0 $random.SystemRandom$ 0 0 0 0 0 0 0 0 0 $random.SystemRandom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $random.SystemRandom$ 0 0 0 0 0 0 0 0 0 $random.SystemRandom$ 0 0 0 0 0 0 0 0 0 $random.SystemRandom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $src.ppm.PPM$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.camera.Camera$ 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $typing.List[src.hittable.Hittable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.hittable.HittableList$ 0 0 0 $typing.List[src.hittable.Hittable]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $random.SystemRandom$ 0 $random.SystemRandom$ 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.float$ 0 0 0 0 0 $random.SystemRandom$ 0 $random.SystemRandom$ 0 0 0 0 0 0 $builtins.int$ 0 0 $src.ray.Ray$ 0 $src.camera.Camera$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $src.vec3.Vec3$ 0 0 0 $src.ray.Ray$ 0 $src.hittable.HittableList$ 0 0 0 $src.vec3.Vec3$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] import src [EOL] from src . vec3 import Vec3 [EOL] from typing import Optional [EOL] [EOL] class PPM ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , width , height , default_color = None ) : [EOL] self . width = width [EOL] self . height = height [EOL] if default_color is None : [EOL] default_color = Vec3 ( [number] , [number] , [number] ) [EOL] self . grid = [ [ default_color for _ in range ( width ) ] for __ in range ( height ) ] [EOL] [EOL] def set_pixel ( self , row , col , color ) : [EOL] self . grid [ row ] [ col ] = color [EOL] [EOL] def write ( self , filename ) : [EOL] if not filename . endswith ( [string] ) : [EOL] filename = [string] % filename [EOL] [EOL] with open ( filename , [string] ) as ppm_file : [EOL] print ( [string] , file = ppm_file ) [EOL] print ( [string] % ( self . width , self . height ) , file = ppm_file ) [EOL] print ( [string] , file = ppm_file ) [EOL] [EOL] for row in self . grid : [EOL] print ( [string] . join ( [ [string] . join ( [ str ( p ) for p in pixel . make_tuple ( ) ] ) for pixel in row ] ) , file = ppm_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $src.vec3.Vec3$ 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import src [EOL] from src . vec3 import Vec3 [EOL] [EOL] class Ray ( object ) : [EOL] [EOL] def __init__ ( self , a , b ) : [EOL] self . a = a [EOL] self . b = b [EOL] [EOL] @ property def origin ( self ) : [EOL] return self . a [EOL] [EOL] @ property def direction ( self ) : [EOL] return self . b [EOL] [EOL] def point_at_parameter ( self , t ) : [EOL] [docstring] [EOL] return self . a + ( t * self . b ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0
from typing import List , Optional [EOL] import typing [EOL] import builtins [EOL] import src [EOL] from abc import ABC , abstractmethod [EOL] from src . material import Material , Vanta [EOL] from src . ray import Ray [EOL] from src . vec3 import Vec3 [EOL] from typing import List , Optional [EOL] [EOL] class HitRecord ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , t , p , normal , material = None , hit_object = None ) : [EOL] [docstring] [EOL] self . t = t [EOL] self . p = p [EOL] self . normal = normal [EOL] self . material = material or Vanta ( ) [EOL] self . hit_object = [string] [EOL] if hit_object is not None : [EOL] self . hit_object = hit_object [EOL] [EOL] class Hittable ( ABC ) : [EOL] [EOL] def __init__ ( self , material = None ) : [EOL] self . material = material or Vanta ( ) [EOL] [EOL] @ abstractmethod def hit ( self , ray , t_min , t_max ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] class HittableList ( Hittable ) : [EOL] [EOL] def __init__ ( self , hittables ) : [EOL] self . hittables = hittables [EOL] [EOL] def hit ( self , ray , t_min , t_max ) : [EOL] [docstring] [EOL] hit_attempt = None [EOL] [comment] [EOL] [comment] [EOL] closest_so_far = t_max [EOL] [EOL] for hittable in self . hittables : [EOL] hit_attempt = hittable . hit ( ray , t_min , closest_so_far ) or hit_attempt [EOL] if hit_attempt is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] closest_so_far = hit_attempt . t [EOL] [EOL] return hit_attempt [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 $src.material.Material$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.material.Material$ 0 $src.material.Material$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.material.Material$ 0 0 0 0 0 0 0 $src.material.Material$ 0 $src.material.Material$ 0 0 0 0 0 0 0 0 0 $typing.Optional[HitRecord]$ 0 0 0 $src.ray.Ray$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Hittable]$ 0 0 0 0 0 $typing.List[Hittable]$ 0 $typing.List[Hittable]$ 0 0 0 $typing.Optional[HitRecord]$ 0 0 0 $src.ray.Ray$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $typing.Optional[src.hittable.HitRecord]$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[src.hittable.HitRecord]$ 0 0 0 0 0 $src.ray.Ray$ 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Optional[src.hittable.HitRecord]$ 0 0 $typing.Optional[src.hittable.HitRecord]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Optional[src.hittable.HitRecord]$ 0 0 0 0 0 $typing.Optional[src.hittable.HitRecord]$ 0
	0
import builtins [EOL] import sys [EOL] [EOL] def _derive_ppm_filename ( ) : [EOL] my_filename = sys . argv [ [number] ] . split ( [string] ) [ - [number] ] [EOL] sans_extension = my_filename . rsplit ( [string] , [number] ) [ [number] ] [EOL] return [string] % sans_extension [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import src [EOL] [docstring] [EOL] from src . ray import Ray [EOL] from src . vec3 import Vec3 [EOL] [EOL] import math [EOL] import random [EOL] [EOL] class Camera ( object ) : [EOL] [EOL] def __init__ ( self , lower_left_corner , h_movement , v_movement , origin ) : [EOL] [docstring] [EOL] self . lower_left_corner = lower_left_corner [EOL] self . h_movement = h_movement [EOL] self . v_movement = v_movement [EOL] self . origin = origin [EOL] [EOL] def get_ray ( self , u , v ) : [EOL] return Ray ( self . origin , self . lower_left_corner + ( self . h_movement * u ) + ( self . v_movement * v ) - self . origin ) [EOL] [EOL] class PositionableCamera ( Camera ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def __init__ ( self , camera_posn , camera_aim , up_vector , vfov , aspect_ratio , aperture = [number] , focus_dist = [number] ) : [EOL] [docstring] [EOL] self . lens_radius = aperture / [number] [EOL] vfov_rad = vfov * math . pi / [number] [EOL] half_height = math . tan ( vfov_rad / [number] ) [EOL] half_width = aspect_ratio * half_height [EOL] [comment] [EOL] self . __w = ( camera_posn - camera_aim ) . unit_vector ( ) [EOL] self . __u = up_vector . cross ( self . __w ) . unit_vector ( ) [EOL] self . __v = self . __w . cross ( self . __u ) [EOL] super ( ) . __init__ ( camera_posn - focus_dist * ( ( half_width * self . __u ) + ( half_height * self . __v ) + self . __w ) , [number] * half_width * focus_dist * self . __u , [number] * half_height * focus_dist * self . __v , camera_posn ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def get_ray ( self , s , t ) : [EOL] random_point_in_disc = random_in_unit_disk ( ) * self . lens_radius [EOL] offset = ( self . __u * random_point_in_disc . x + self . __v * random_point_in_disc . y ) [EOL] return Ray ( self . origin + offset , self . lower_left_corner + ( self . h_movement * s ) + ( self . v_movement * t ) - self . origin - offset ) [EOL] [EOL] def irandom_in_unit_disk ( ) : [EOL] point = Vec3 ( random . uniform ( - [number] , [number] ) , random . uniform ( - [number] , [number] ) , [number] ) [EOL] [EOL] while point . dot ( point ) >= [number] : [EOL] point = Vec3 ( random . uniform ( - [number] , [number] ) , random . uniform ( - [number] , [number] ) , [number] ) [EOL] [EOL] return point [EOL] [EOL] def random_in_unit_disk ( ) : [EOL] point = [number] * Vec3 ( random . random ( ) , random . random ( ) , [number] ) - Vec3 ( [number] , [number] , [number] ) [EOL] [EOL] while point . dot ( point ) >= [number] : [EOL] point = [number] * Vec3 ( random . random ( ) , random . random ( ) , [number] ) - Vec3 ( [number] , [number] , [number] ) [EOL] [EOL] return point [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.ray.Ray$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 $src.ray.Ray$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import src [EOL] from src . vec3 import Vec3 [EOL] [EOL] import unittest [EOL] [EOL] class Vec3Test ( unittest . TestCase ) : [EOL] [EOL] def test_cross ( self ) : [EOL] a = Vec3 ( [number] , [number] , - [number] ) [EOL] b = Vec3 ( - [number] , [number] , [number] ) [EOL] [EOL] axb = a . cross ( b ) [EOL] self . assertEqual ( Vec3 ( [number] , [number] , [number] ) , axb ) [EOL] [EOL] bxa = b . cross ( a ) [EOL] self . assertEqual ( Vec3 ( - [number] , - [number] , - [number] ) , bxa ) [EOL] [EOL] def test_dot ( self ) : [EOL] a = Vec3 ( [number] , [number] , - [number] ) [EOL] b = Vec3 ( - [number] , [number] , [number] ) [EOL] [EOL] adb = a . dot ( b ) [EOL] expected = sum ( ( a . x * b . x , a . y * b . y , a . z * b . z ) ) [EOL] self . assertEqual ( expected , adb ) [EOL] [EOL] def test_itruediv ( self ) : [EOL] a = Vec3 ( [number] , [number] , [number] ) [EOL] lowest_terms_a = Vec3 ( [number] , [number] , [number] ) [EOL] a /= [number] [EOL] self . assertEqual ( lowest_terms_a , a ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 $typing.Any$ 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import math [EOL] [EOL] class Vec3 ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , r = [number] , g = [number] , b = [number] ) : [EOL] self . r = r [EOL] self . g = g [EOL] self . b = b [EOL] [EOL] @ property def x ( self ) : [EOL] return self . r [EOL] [EOL] @ property def y ( self ) : [EOL] return self . g [EOL] [EOL] @ property def z ( self ) : [EOL] return self . b [EOL] [EOL] def length ( self ) : [EOL] [docstring] [EOL] return math . sqrt ( self . r ** [number] + self . g ** [number] + self . b ** [number] ) [EOL] [EOL] def squared_length ( self ) : [EOL] return self . r ** [number] + self . g ** [number] + self . b ** [number] [EOL] [EOL] def __add__ ( self , other ) : [EOL] return Vec3 ( self . r + other . r , self . g + other . g , self . b + other . b ) [EOL] [EOL] def __sub__ ( self , other ) : [EOL] return Vec3 ( self . r - other . r , self . g - other . g , self . b - other . b ) [EOL] [EOL] def __mul__ ( self , other ) : [EOL] if isinstance ( other , Vec3 ) : [EOL] return Vec3 ( self . r * other . r , self . g * other . g , self . b * other . b ) [EOL] else : [EOL] return Vec3 ( self . r * other , self . g * other , self . b * other ) [EOL] [EOL] def __rmul__ ( self , other ) : [EOL] return self . __mul__ ( other ) [EOL] [EOL] def __truediv__ ( self , other ) : [EOL] if isinstance ( other , Vec3 ) : [EOL] return Vec3 ( self . r / other . r , self . g - other . g , self . b - other . b ) [EOL] else : [EOL] return Vec3 ( self . r / other , self . g / other , self . b / other ) [EOL] [EOL] def make_tuple ( self ) : [EOL] return ( self . r , self . g , self . b ) [EOL] [EOL] def dot ( self , other ) : [EOL] return sum ( ( self * other ) . make_tuple ( ) ) [EOL] [EOL] def cross ( self , other ) : [EOL] return Vec3 ( self . g * other . b - self . b * other . g , - ( self . r * other . b - self . b * other . r ) , self . r * other . g - self . g * other . r ) [EOL] [EOL] def __iadd__ ( self , other ) : [EOL] self . r += other . r [EOL] self . g += other . g [EOL] self . b += other . b [EOL] return self [EOL] [EOL] def __isub__ ( self , other ) : [EOL] self . r -= other . r [EOL] self . g -= other . g [EOL] self . b -= other . b [EOL] return self [EOL] [EOL] def __imul__ ( self , other ) : [EOL] if isinstance ( other , Vec3 ) : [EOL] self . r *= other . r [EOL] self . g *= other . g [EOL] self . b *= other . b [EOL] else : [EOL] self . r *= other [EOL] self . g *= other [EOL] self . b *= other [EOL] [EOL] return self [EOL] [EOL] def __itruediv__ ( self , other ) : [EOL] if isinstance ( other , Vec3 ) : [EOL] self . r /= other . r [EOL] self . g /= other . g [EOL] self . b /= other . b [EOL] else : [EOL] self . r /= other [EOL] self . g /= other [EOL] self . b /= other [EOL] [EOL] return self [EOL] [EOL] def unit_vector ( self ) : [EOL] return self / self . length ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . r == other . r and self . g == other . g and self . b == other . b ) [EOL] [EOL] def map ( self , fn ) : [EOL] self . r = fn ( self . r ) [EOL] self . g = fn ( self . g ) [EOL] self . b = fn ( self . b ) [EOL] return self [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . r , self . g , self . b ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Vec3"$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import src [EOL] from src . ppm import PPM [EOL] from src . ray import Ray [EOL] from src . utils import _derive_ppm_filename [EOL] from src . vec3 import Vec3 [EOL] [EOL] [docstring] [EOL] [EOL] UNIT_VEC3 = Vec3 ( [number] , [number] , [number] ) [EOL] [EOL] def color ( ray ) : [EOL] [docstring] [EOL] unit_direction = ray . direction . unit_vector ( ) [EOL] [comment] [EOL] t = [number] * ( unit_direction . y + [number] ) [EOL] return ( UNIT_VEC3 * ( [number] - t ) ) + ( Vec3 ( [number] , [number] , [number] ) * t ) [EOL] [EOL] if __name__ == [string] : [EOL] width = [number] [EOL] height = [number] [EOL] ppm = PPM ( width , height ) [EOL] lower_left_corner = Vec3 ( - [number] , - [number] , - [number] ) [EOL] h_movement = Vec3 ( [number] , [number] , [number] ) [EOL] v_movement = Vec3 ( [number] , [number] , [number] ) [EOL] origin = Vec3 ( [number] , [number] , [number] ) [EOL] [EOL] for j in range ( height - [number] , - [number] , - [number] ) : [EOL] for i in range ( width ) : [EOL] [comment] [EOL] u = i / width [EOL] v = j / height [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] r = Ray ( origin , lower_left_corner + ( h_movement * u ) + ( v_movement * v ) ) [EOL] _color = color ( r ) [EOL] _color *= [number] [EOL] _color . map ( int ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] ppm . set_pixel ( ( height - [number] ) - j , i , _color ) [EOL] [EOL] ppm . write ( _derive_ppm_filename ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $src.ppm.PPM$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $src.ray.Ray$ 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 $src.vec3.Vec3$ 0 $builtins.float$ 0 0 0 $src.vec3.Vec3$ 0 $builtins.float$ 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.ray.Ray$ 0 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0
import src [EOL] from src . ppm import PPM [EOL] from src . utils import _derive_ppm_filename [EOL] from src . vec3 import Vec3 [EOL] [EOL] if __name__ == [string] : [EOL] hello_world = PPM ( [number] , [number] ) [EOL] for ri in range ( hello_world . height ) : [EOL] for ci in range ( hello_world . width ) : [EOL] v = Vec3 ( ri / hello_world . width , ci / hello_world . height , [number] ) [EOL] color = v * [number] [EOL] color . map ( int ) [EOL] hello_world . set_pixel ( ri , ci , color ) [EOL] hello_world . write ( _derive_ppm_filename ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 0 $src.ppm.PPM$ 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] import src [EOL] from src . hittable import HitRecord , Hittable [EOL] from src . material import Material , Vanta [EOL] from src . ray import Ray [EOL] from src . vec3 import Vec3 [EOL] from typing import Optional [EOL] [EOL] import math [EOL] [EOL] class Sphere ( Hittable ) : [EOL] [EOL] def __init__ ( self , center , radius , material = None , name = None ) : [EOL] super ( ) . __init__ ( material ) [EOL] self . center = center [EOL] self . radius = radius [EOL] self . name = [string] [EOL] if name is not None : [EOL] self . name = name [EOL] [EOL] def __decide_conjugate ( self , t_min , t_max , neg_conjugate , pos_conjugate ) : [EOL] [comment] [EOL] if t_min < neg_conjugate < t_max : [EOL] return neg_conjugate [EOL] elif t_min < pos_conjugate < t_max : [EOL] return pos_conjugate [EOL] else : [EOL] return None [EOL] [EOL] def hit ( self , ray , t_min , t_max ) : [EOL] origin_to_center = ray . origin - self . center [EOL] [comment] [EOL] [comment] [EOL] a = ray . direction . dot ( ray . direction ) [EOL] b = origin_to_center . dot ( ray . direction ) [EOL] c = origin_to_center . dot ( origin_to_center ) - ( self . radius ** [number] ) [EOL] discriminant = ( b ** [number] ) - ( a * c ) [EOL] [EOL] if discriminant > [number] : [EOL] neg_conjugate = ( - b - math . sqrt ( discriminant ) ) / a [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pos_conjugate = ( - b + math . sqrt ( discriminant ) ) / a [EOL] [EOL] [comment] [EOL] [comment] [EOL] chosen_conjugate = self . __decide_conjugate ( t_min , t_max , neg_conjugate , pos_conjugate ) [EOL] if chosen_conjugate is not None : [EOL] t = chosen_conjugate [EOL] p = ray . point_at_parameter ( t ) [EOL] normal = ( p - self . center ) / self . radius [EOL] return HitRecord ( t , p , normal , self . material ) [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.vec3.Vec3$ 0 $builtins.float$ 0 $typing.Optional[src.material.Material]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[src.material.Material]$ 0 0 0 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Optional[src.hittable.HitRecord]$ 0 0 0 $src.ray.Ray$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $src.vec3.Vec3$ 0 $src.ray.Ray$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $src.ray.Ray$ 0 0 0 0 0 $src.ray.Ray$ 0 0 0 0 $builtins.float$ 0 $src.vec3.Vec3$ 0 0 0 $src.ray.Ray$ 0 0 0 0 $builtins.float$ 0 $src.vec3.Vec3$ 0 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $builtins.float$ 0 $typing.Optional[builtins.float]$ 0 $src.vec3.Vec3$ 0 $src.ray.Ray$ 0 0 0 $builtins.float$ 0 0 $src.vec3.Vec3$ 0 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $src.vec3.Vec3$ 0 $src.vec3.Vec3$ 0 0 0 0 0 0 0 0 0 0