from typing import List , Dict , Any [EOL] import typing [EOL] from collections . abc import Callable [EOL] import numpy as np [EOL] from keras import backend as K [EOL] from keras import initializers [EOL] from keras import activations [EOL] from keras . engine . topology import Layer [EOL] from . mixins import MergfuncMixin [EOL] [EOL] [EOL] class KeyValueAttention1DLayer ( Layer , MergfuncMixin ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , similarity = [string] , * , mergfunc = None , dropout_rate = None , kernel_initializer = [string] , wk_kernel_initializer = [string] , wq_kernel_initializer = [string] , ** kwargs ) : [EOL] if isinstance ( similarity , Callable ) : [EOL] self . similarity = similarity [EOL] elif isinstance ( similarity , str ) and similarity in ( [string] , [string] , [string] ) : [EOL] self . similarity = similarity [EOL] else : [EOL] raise ValueError ( [string] [string] [string] ) [EOL] self . mergfunc = mergfunc , [EOL] self . dropout_rate = dropout_rate [EOL] self . kernel_initializer = initializers . get ( kernel_initializer ) [EOL] self . wk_kernel_initializer = initializers . get ( wk_kernel_initializer ) [EOL] self . wq_kernel_initializer = initializers . get ( wq_kernel_initializer ) [EOL] self . dim = None [EOL] if self . similarity == [string] : [EOL] self . kernel = None [EOL] self . wk_kernel = None [EOL] self . wq_kernel = None [EOL] elif self . similarity == [string] : [EOL] self . kernel = None [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] [EOL] def _build_w ( self , s_time , q_time , dim ) : [EOL] self . dim = dim [EOL] if self . similarity == [string] : [EOL] self . kernel = self . add_weight ( name = [string] , shape = ( dim , s_time ) , initializer = self . kernel_initializer , trainable = True ) [EOL] self . wk_kernel = self . add_weight ( name = [string] , shape = ( q_time , s_time ) , initializer = self . wk_kernel_initializer , trainable = True ) [EOL] self . wq_kernel = self . add_weight ( name = [string] , shape = ( q_time , q_time ) , initializer = self . wk_kernel_initializer , trainable = True ) [EOL] elif self . similarity == [string] : [EOL] self . kernel = self . add_weight ( name = [string] , shape = ( dim , dim ) , initializer = self . kernel_initializer , trainable = True ) [EOL] [EOL] def build ( self , input_shape ) : [EOL] if not isinstance ( input_shape , list ) or len ( input_shape ) != [number] : [EOL] raise ValueError ( [string] [string] ) [EOL] if len ( input_shape [ [number] ] ) != [number] or len ( input_shape [ [number] ] ) != [number] or len ( input_shape [ [number] ] ) != [number] : [EOL] raise ValueError ( [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] if input_shape [ [number] ] [ - [number] ] != input_shape [ [number] ] [ - [number] ] : [EOL] raise ValueError ( [string] [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] [EOL] if input_shape [ [number] ] [ - [number] ] != input_shape [ [number] ] [ - [number] ] : [EOL] raise ValueError ( [string] [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] dim = input_shape [ [number] ] [ - [number] ] [EOL] s_time = input_shape [ [number] ] [ [number] ] [EOL] q_time = input_shape [ [number] ] [ [number] ] [EOL] self . _build_w ( s_time , q_time , dim ) [EOL] [comment] [EOL] super ( ) . build ( input_shape ) [EOL] [EOL] def multiplicative ( self , Key , Query ) : [EOL] [docstring] [EOL] Key_t = K . permute_dimensions ( Key , ( [number] , [number] , [number] ) ) [EOL] s = K . dot ( Query , self . kernel ) [EOL] sim = K . batch_dot ( s , Key_t ) [EOL] return sim [EOL] [EOL] def dot_product ( self , Key , Query ) : [EOL] [docstring] [EOL] sim = K . batch_dot ( Key , Query ) [EOL] return sim [EOL] [EOL] def additive ( self , Key , Query ) : [EOL] [docstring] [EOL] key_att = K . dot ( self . wk_kernel , Key ) [EOL] key_att = K . permute_dimensions ( key_att , ( [number] , [number] , [number] ) ) [EOL] que_att = K . dot ( self . wq_kernel , Query ) [EOL] que_att = K . permute_dimensions ( que_att , ( [number] , [number] , [number] ) ) [EOL] f_att = key_att + que_att [EOL] sim = K . dot ( K . tanh ( f_att ) , self . kernel ) [EOL] return sim [EOL] [EOL] def _call_attention ( self , Key , Value , Query ) : [EOL] [docstring] [EOL] if isinstance ( self . similarity , Callable ) : [EOL] sim = self . similarity ( Key , Query ) [EOL] else : [EOL] sim = getattr ( self , self . similarity ) ( Key , Query ) [EOL] sm = activations . softmax ( sim ) [EOL] if self . dropout_rate : [EOL] sm = K . dropout ( sm , self . dropout_rate ) [EOL] if isinstance ( self . mergfunc , Callable ) : [EOL] result = self . mergfunc ( sm , Value ) [EOL] elif isinstance ( self . mergfunc , str ) : [EOL] result = getattr ( self , self . mergfunc , [string] ) ( sm , Value ) [EOL] else : [EOL] result = getattr ( self , [string] ) ( sm , Value ) [EOL] return result [EOL] [EOL] def call ( self , inputs ) : [EOL] Key = inputs [ [number] ] [EOL] Value = inputs [ [number] ] [EOL] Query = inputs [ [number] ] [EOL] result = self . _call_attention ( Key , Value , Query ) [EOL] return result [EOL] [EOL] def compute_output_shape ( self , input_shape ) : [EOL] return ( input_shape [ - [number] ] [ [number] ] , input_shape [ - [number] ] [ [number] ] , input_shape [ [number] ] [ - [number] ] ) [EOL] [EOL] def get_config ( self ) : [EOL] config = { [string] : self . similarity , [string] : self . mergfunc , [string] : self . dropout_rate , [string] : self . kernel_initializer , [string] : self . wk_kernel_initializer , [string] : self . wq_kernel_initializer } [EOL] base_config = super ( ) . get_config ( ) [EOL] return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) ) [EOL] [EOL] [EOL] class KeyValueAttention2DLayer ( KeyValueAttention1DLayer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , output_size = None , similarity = [string] , * , mergfunc = None , dropout_rate = None , kernel_initializer = [string] , wk_kernel_initializer = [string] , wq_kernel_initializer = [string] , ** kwargs ) : [EOL] self . output_size = output_size [EOL] super ( ) . __init__ ( similarity = similarity , mergfunc = mergfunc , dropout_rate = dropout_rate , kernel_initializer = kernel_initializer , wk_kernel_initializer = wk_kernel_initializer , wq_kernel_initializer = wq_kernel_initializer , ** kwargs ) [EOL] [EOL] def build ( self , input_shape ) : [EOL] if not isinstance ( input_shape , list ) or len ( input_shape ) != [number] : [EOL] raise ValueError ( [string] [string] ) [EOL] if len ( input_shape [ [number] ] ) != [number] or len ( input_shape [ [number] ] ) != [number] or len ( input_shape [ [number] ] ) != [number] : [EOL] raise ValueError ( [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] if input_shape [ [number] ] [ - [number] ] != input_shape [ [number] ] [ - [number] ] : [EOL] raise ValueError ( [string] [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] [EOL] if ( input_shape [ [number] ] [ [number] ] != input_shape [ [number] ] [ [number] ] ) or ( input_shape [ [number] ] [ [number] ] != input_shape [ [number] ] [ [number] ] ) : [EOL] raise ValueError ( [string] [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] dim = input_shape [ [number] ] [ - [number] ] [EOL] self . dim = input_shape [ [number] ] [ - [number] ] [EOL] s_time = input_shape [ [number] ] [ [number] ] * input_shape [ [number] ] [ [number] ] [EOL] q_time = input_shape [ [number] ] [ [number] ] * input_shape [ [number] ] [ [number] ] [EOL] if ( self . output_size is not None ) and ( q_time != self . output_size [ [number] ] * self . output_size [ [number] ] ) : [EOL] raise ValueError ( [string] ) [EOL] if self . output_size is None : [EOL] self . output_size = ( input_shape [ [number] ] [ [number] ] , input_shape [ [number] ] [ [number] ] ) [EOL] self . _build_w ( s_time , q_time , dim ) [EOL] super ( KeyValueAttention1DLayer , self ) . build ( input_shape ) [EOL] [EOL] def call ( self , inputs ) : [EOL] [docstring] [EOL] Key_ = inputs [ [number] ] [EOL] Value_ = inputs [ [number] ] [EOL] Query_ = inputs [ [number] ] [EOL] Key_shape = Key_ . shape [EOL] Value_shape = Value_ . shape [EOL] Query_shape = Query_ . shape [EOL] Key = K . reshape ( Key_ , shape = np . asarray ( [ - [number] , ( Key_shape [ [number] ] * Key_shape [ [number] ] ) . value , Key_shape [ [number] ] . value ] ) ) [EOL] Value = K . reshape ( Value_ , shape = np . asarray ( [ - [number] , ( Value_shape [ [number] ] * Value_shape [ [number] ] ) . value , Value_shape [ [number] ] . value ] ) ) [EOL] Query = K . reshape ( Query_ , shape = np . asarray ( [ - [number] , ( Query_shape [ [number] ] * Query_shape [ [number] ] ) . value , Query_shape [ [number] ] . value ] ) ) [EOL] _result = self . _call_attention ( Key , Value , Query ) [EOL] result = K . reshape ( _result , np . asarray ( [ - [number] , self . output_size [ [number] ] , self . output_size [ [number] ] , self . dim ] ) ) [EOL] return result [EOL] [EOL] def compute_output_shape ( self , input_shape ) : [EOL] return ( input_shape [ [number] ] [ [number] ] , self . output_size [ [number] ] , self . output_size [ [number] ] , self . dim ) [EOL] [EOL] def get_config ( self ) : [EOL] config = { [string] : self . output_size } [EOL] base_config = super ( ) . get_config ( ) [EOL] return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] from collections . abc import Callable [EOL] import numpy as np [EOL] from keras import backend as K [EOL] from keras import initializers [EOL] from keras import activations [EOL] from keras . engine . topology import Layer [EOL] from . mixins import MergfuncMixin [EOL] [EOL] [EOL] class Attention1DLayer ( Layer , MergfuncMixin ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , similarity = [string] , * , mergfunc = None , dropout_rate = None , kernel_initializer = [string] , wk_kernel_initializer = [string] , wq_kernel_initializer = [string] , ** kwargs ) : [EOL] if isinstance ( similarity , Callable ) : [EOL] self . similarity = similarity [EOL] elif isinstance ( similarity , str ) and similarity in ( [string] , [string] , [string] ) : [EOL] self . similarity = similarity [EOL] else : [EOL] raise ValueError ( [string] [string] [string] ) [EOL] self . mergfunc = mergfunc [EOL] self . dropout_rate = dropout_rate [EOL] self . kernel_initializer = initializers . get ( kernel_initializer ) [EOL] self . wk_kernel_initializer = initializers . get ( wk_kernel_initializer ) [EOL] self . wq_kernel_initializer = initializers . get ( wq_kernel_initializer ) [EOL] self . dim = None [EOL] if self . similarity == [string] : [EOL] self . kernel = None [EOL] self . wk_kernel = None [EOL] self . wq_kernel = None [EOL] elif self . similarity == [string] : [EOL] self . kernel = None [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] [EOL] def _build_w ( self , s_time , q_time , dim ) : [EOL] self . dim = dim [EOL] if self . similarity == [string] : [EOL] self . kernel = self . add_weight ( name = [string] , shape = ( dim , s_time ) , initializer = self . kernel_initializer , trainable = True ) [EOL] self . wk_kernel = self . add_weight ( name = [string] , shape = ( q_time , s_time ) , initializer = self . wk_kernel_initializer , trainable = True ) [EOL] self . wq_kernel = self . add_weight ( name = [string] , shape = ( q_time , q_time ) , initializer = self . wk_kernel_initializer , trainable = True ) [EOL] elif self . similarity == [string] : [EOL] self . kernel = self . add_weight ( name = [string] , shape = ( dim , dim ) , initializer = self . kernel_initializer , trainable = True ) [EOL] [EOL] def build ( self , input_shape ) : [EOL] if not isinstance ( input_shape , list ) or len ( input_shape ) != [number] : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] if len ( input_shape [ [number] ] ) != [number] or len ( input_shape [ [number] ] ) != [number] : [EOL] raise ValueError ( [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] if input_shape [ [number] ] [ - [number] ] != input_shape [ [number] ] [ - [number] ] : [EOL] raise ValueError ( [string] [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] dim = input_shape [ [number] ] [ - [number] ] [EOL] s_time = input_shape [ [number] ] [ - [number] ] [EOL] q_time = input_shape [ [number] ] [ - [number] ] [EOL] self . _build_w ( s_time , q_time , dim ) [EOL] [comment] [EOL] super ( ) . build ( input_shape ) [EOL] [EOL] def multiplicative ( self , Source , Query ) : [EOL] [docstring] [EOL] Source_t = K . permute_dimensions ( Source , ( [number] , [number] , [number] ) ) [EOL] s = K . dot ( Query , self . kernel ) [EOL] sim = K . batch_dot ( s , Source_t ) [EOL] return sim [EOL] [EOL] def dot_product ( self , Source , Query ) : [EOL] [docstring] [EOL] sim = K . batch_dot ( Source , Query ) [EOL] return sim [EOL] [EOL] def additive ( self , Source , Query ) : [EOL] [docstring] [EOL] key_att = K . dot ( self . wk_kernel , Source ) [EOL] key_att = K . permute_dimensions ( key_att , ( [number] , [number] , [number] ) ) [EOL] que_att = K . dot ( self . wq_kernel , Query ) [EOL] que_att = K . permute_dimensions ( que_att , ( [number] , [number] , [number] ) ) [EOL] f_att = key_att + que_att [EOL] sim = K . dot ( K . tanh ( f_att ) , self . kernel ) [EOL] return sim [EOL] [EOL] def _call_attention ( self , Source , Query ) : [EOL] [docstring] [EOL] if isinstance ( self . similarity , Callable ) : [EOL] sim = self . similarity ( Source , Query ) [EOL] else : [EOL] sim = getattr ( self , self . similarity ) ( Source , Query ) [EOL] sm = activations . softmax ( sim ) [EOL] if self . dropout_rate : [EOL] sm = K . dropout ( sm , self . dropout_rate ) [EOL] if isinstance ( self . mergfunc , Callable ) : [EOL] result = self . mergfunc ( sm , Source ) [EOL] elif isinstance ( self . mergfunc , str ) : [EOL] result = getattr ( self , self . mergfunc , [string] ) ( sm , Source ) [EOL] else : [EOL] result = getattr ( self , [string] ) ( sm , Source ) [EOL] return result [EOL] [EOL] def call ( self , inputs ) : [EOL] Source = inputs [ [number] ] [EOL] Query = inputs [ [number] ] [EOL] result = self . _call_attention ( Source , Query ) [EOL] return result [EOL] [EOL] def compute_output_shape ( self , input_shape ) : [EOL] return input_shape [ - [number] ] [EOL] [EOL] def get_config ( self ) : [EOL] config = { [string] : self . similarity , [string] : self . mergfunc , [string] : self . dropout_rate , [string] : self . kernel_initializer , [string] : self . wk_kernel_initializer , [string] : self . wq_kernel_initializer } [EOL] base_config = super ( ) . get_config ( ) [EOL] return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) ) [EOL] [EOL] [EOL] class Attention2DLayer ( Attention1DLayer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , output_size = None , similarity = [string] , * , mergfunc = None , dropout_rate = None , kernel_initializer = [string] , wk_kernel_initializer = [string] , wq_kernel_initializer = [string] , ** kwargs ) : [EOL] self . output_size = output_size [EOL] super ( ) . __init__ ( similarity = similarity , dropout_rate = dropout_rate , mergfunc = mergfunc , kernel_initializer = kernel_initializer , wk_kernel_initializer = wk_kernel_initializer , wq_kernel_initializer = wq_kernel_initializer , ** kwargs ) [EOL] [EOL] def build ( self , input_shape ) : [EOL] if not isinstance ( input_shape , list ) or len ( input_shape ) != [number] : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] if len ( input_shape [ [number] ] ) != [number] or len ( input_shape [ [number] ] ) != [number] : [EOL] raise ValueError ( [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] if input_shape [ [number] ] [ - [number] ] != input_shape [ [number] ] [ - [number] ] : [EOL] raise ValueError ( [string] [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] dim = input_shape [ [number] ] [ - [number] ] [EOL] s_time = input_shape [ [number] ] [ [number] ] * input_shape [ [number] ] [ [number] ] [EOL] q_time = input_shape [ [number] ] [ [number] ] * input_shape [ [number] ] [ [number] ] [EOL] [EOL] if ( self . output_size is not None ) and ( q_time != self . output_size [ [number] ] * self . output_size [ [number] ] ) : [EOL] raise ValueError ( [string] ) [EOL] if self . output_size is None : [EOL] self . output_size = ( input_shape [ [number] ] [ [number] ] , input_shape [ [number] ] [ [number] ] ) [EOL] self . _build_w ( s_time , q_time , dim ) [EOL] super ( Attention1DLayer , self ) . build ( input_shape ) [EOL] [EOL] def call ( self , inputs ) : [EOL] [docstring] [EOL] Source_ = inputs [ [number] ] [EOL] Query_ = inputs [ [number] ] [EOL] Source_shape = Source_ . shape [EOL] Query_shape = Query_ . shape [EOL] [EOL] Source = K . reshape ( Source_ , shape = np . asarray ( [ - [number] , ( Source_shape [ [number] ] * Source_shape [ [number] ] ) . value , Source_shape [ [number] ] . value ] ) ) [EOL] Query = K . reshape ( Query_ , shape = np . asarray ( [ - [number] , ( Query_shape [ [number] ] * Query_shape [ [number] ] ) . value , Query_shape [ [number] ] . value ] ) ) [EOL] _result = self . _call_attention ( Source , Query ) [EOL] result = K . reshape ( _result , np . asarray ( [ - [number] , self . output_size [ [number] ] , self . output_size [ [number] ] , self . dim ] ) ) [EOL] return result [EOL] [EOL] def compute_output_shape ( self , input_shape ) : [EOL] return ( input_shape [ [number] ] [ [number] ] , self . output_size [ [number] ] , self . output_size [ [number] ] , self . dim ) [EOL] [EOL] def get_config ( self ) : [EOL] config = { [string] : self . output_size } [EOL] base_config = super ( ) . get_config ( ) [EOL] return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from . attention import * [EOL] from . self_attention import * [EOL] from . key_value_attention import * [EOL] from . mulithead_attention import *	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from keras import backend as K [EOL] [EOL] [EOL] class MergfuncMixin : [EOL] def batch_dot_merg ( self , x , y ) : [EOL] return K . batch_dot ( x , y ) [EOL] [EOL] def batch_mul_merg ( self , x , y ) : [EOL] x_t = K . permute_dimensions ( x , ( [number] , [number] , [number] ) ) [EOL] result = x_t * y [EOL] return result [EOL] [EOL] def batch_add_merg ( self , x , y ) : [EOL] x_t = K . permute_dimensions ( x , ( [number] , [number] , [number] ) ) [EOL] return x_t + y [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import List , Any [EOL] import typing [EOL] import math [EOL] import keras . backend as K [EOL] from keras . layers import Dense , Lambda [EOL] from keras . layers . normalization import BatchNormalization [EOL] from . self_attention import SelfAttention1DLayer [EOL] [EOL] [EOL] class MulitheadAttention : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , heads = [number] , input_linear_kwargs = { [string] : [number] , [string] : [string] } , output_linear_kwargs = { [string] : [string] } , attention = SelfAttention1DLayer , attention_kwargs = { [string] : [string] } ) : [EOL] [docstring] [EOL] if input_linear_kwargs . get ( [string] ) is None : [EOL] raise ValueError ( [string] ) [EOL] if output_linear_kwargs . get ( [string] ) is not None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . heads = heads [EOL] self . input_linear_kwargs = input_linear_kwargs [EOL] self . output_linear_kwargs = output_linear_kwargs [EOL] self . attention = attention [EOL] self . attention_kwargs = attention_kwargs [EOL] self . step = math . ceil ( input_linear_kwargs . get ( [string] ) / heads ) [EOL] [EOL] def __call__ ( self , inputs ) : [EOL] datas = [ Dense ( name = [string] + self . attention . __name__ + [string] , ** self . input_linear_kwargs ) ( inpu ) for inpu in inputs ] [EOL] [EOL] mulithead_datas = [ Lambda ( lambda x : [ x [ : , : , i * self . step : ( i + [number] ) * self . step ] for i in range ( self . heads ) ] , name = [string] + self . attention . __name__ + [string] ) ( j ) for j in datas ] [EOL] att_res = [ ] [EOL] for data in zip ( * mulithead_datas ) : [EOL] if len ( data ) > [number] : [EOL] res = self . attention ( ** self . attention_kwargs ) ( list ( data ) ) [EOL] else : [EOL] res = self . attention ( ** self . attention_kwargs ) ( data [ [number] ] ) [EOL] att_res . append ( res ) [EOL] [EOL] datas = Lambda ( lambda x : K . concatenate ( x , axis = - [number] ) , name = [string] + self . attention . __name__ + [string] ) ( att_res ) [EOL] if len ( inputs ) == [number] : [EOL] value = inputs [ [number] ] [EOL] else : [EOL] value = inputs [ [number] ] [EOL] self . output_linear_kwargs [ [string] ] = int ( value . shape [ - [number] ] ) [EOL] datas = Dense ( name = ( [string] + self . attention . __name__ + [string] ) , ** self . output_linear_kwargs ) ( datas ) [EOL] outputs = BatchNormalization ( ) ( datas ) [EOL] print ( outputs ) [EOL] return datas [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] from collections . abc import Callable , Sequence [EOL] import numpy as np [EOL] from keras import backend as K [EOL] from keras import initializers [EOL] from keras import activations [EOL] from keras . engine . topology import Layer [EOL] from . mixins import MergfuncMixin [EOL] [EOL] [EOL] class SelfAttention1DLayer ( Layer , MergfuncMixin ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , similarity = [string] , * , mergfunc = None , kernel_size = None , dropout_rate = None , kernel_initializer = [string] , wk_kernel_initializer = [string] , ** kwargs ) : [EOL] if isinstance ( similarity , Callable ) : [EOL] self . similarity = similarity [EOL] elif isinstance ( similarity , str ) and similarity in ( [string] , [string] , [string] , [string] ) : [EOL] self . similarity = similarity [EOL] else : [EOL] raise ValueError ( [string] [string] [string] ) [EOL] if similarity == [string] and kernel_size is None : [EOL] raise ValueError ( [string] [string] ) [EOL] if similarity != [string] and kernel_size : [EOL] print ( kernel_size ) [EOL] print ( [string] [string] ) [EOL] kernel_size = None [EOL] [EOL] if ( isinstance ( kernel_size , Sequence ) and len ( kernel_size ) == [number] ) or kernel_size is None : [EOL] self . kernel_size = kernel_size [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] self . dropout_rate = dropout_rate [EOL] self . mergfunc = mergfunc [EOL] self . kernel_initializer = initializers . get ( kernel_initializer ) [EOL] self . wk_kernel_initializer = initializers . get ( wk_kernel_initializer ) [EOL] self . dim = None [EOL] if self . similarity == [string] : [EOL] self . kernel = None [EOL] self . wk_kernel = None [EOL] self . wq_kernel = None [EOL] elif self . similarity == [string] : [EOL] self . kernel = None [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] [EOL] def _build_w ( self , time , dim ) : [EOL] self . dim = dim [EOL] if self . similarity == [string] : [EOL] r , d_a = self . kernel_size [EOL] self . kernel = self . add_weight ( name = [string] , shape = ( r , d_a ) , initializer = self . kernel_initializer ) [EOL] [EOL] self . wk_kernel = self . add_weight ( name = [string] , shape = ( d_a , dim ) , initializer = self . wk_kernel_initializer ) [EOL] elif self . similarity == [string] : [EOL] self . kernel_size = ( time , dim ) [EOL] self . kernel = self . add_weight ( name = [string] , shape = ( dim , dim ) , initializer = self . kernel_initializer ) [EOL] else : [EOL] self . kernel_size = ( time , dim ) [EOL] [EOL] def build ( self , input_shape ) : [EOL] if len ( input_shape ) != [number] : [EOL] raise ValueError ( [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] [EOL] time = input_shape [ - [number] ] [EOL] dim = input_shape [ - [number] ] [EOL] self . _build_w ( time , dim ) [EOL] [comment] [EOL] super ( ) . build ( input_shape ) [EOL] [EOL] def multiplicative ( self , Source ) : [EOL] [docstring] [EOL] Source_t = K . permute_dimensions ( Source , ( [number] , [number] , [number] ) ) [EOL] s = K . dot ( Source , self . kernel ) [EOL] sim = K . batch_dot ( s , Source_t ) [EOL] return sim [EOL] [EOL] def dot_product ( self , Source ) : [EOL] [docstring] [EOL] Source_t = K . permute_dimensions ( Source , ( [number] , [number] , [number] ) ) [EOL] sim = K . batch_dot ( Source , Source_t ) [EOL] return sim [EOL] [EOL] def additive ( self , Source ) : [EOL] [docstring] [EOL] Source_t = K . permute_dimensions ( Source , ( [number] , [number] , [number] ) ) [EOL] f_att = K . dot ( self . wk_kernel , Source_t ) [EOL] f_att = K . permute_dimensions ( f_att , ( [number] , [number] , [number] ) ) [EOL] sim = K . dot ( self . kernel , K . tanh ( f_att ) ) [EOL] sim = K . permute_dimensions ( sim , ( [number] , [number] , [number] ) ) [EOL] return sim [EOL] [EOL] def linear ( self , Source ) : [EOL] self . mergfunc = [string] [EOL] Source_t = K . permute_dimensions ( Source , ( [number] , [number] , [number] ) ) [EOL] return Source_t [EOL] [EOL] def _call_attention ( self , Source ) : [EOL] [docstring] [EOL] if isinstance ( self . similarity , Callable ) : [EOL] sim = self . similarity ( Source ) [EOL] else : [EOL] sim = getattr ( self , self . similarity ) ( Source ) [EOL] [EOL] sm = activations . softmax ( sim ) [EOL] if self . dropout_rate : [EOL] sm = K . dropout ( sm , self . dropout_rate ) [EOL] if isinstance ( self . mergfunc , Callable ) : [EOL] result = self . mergfunc ( sm , Source ) [EOL] elif isinstance ( self . mergfunc , str ) : [EOL] result = getattr ( self , self . mergfunc , [string] ) ( sm , Source ) [EOL] else : [EOL] result = getattr ( self , [string] ) ( sm , Source ) [EOL] return result [EOL] [EOL] def call ( self , inputs ) : [EOL] Source = inputs [EOL] result = self . _call_attention ( Source ) [EOL] return result [EOL] [EOL] def compute_output_shape ( self , input_shape ) : [EOL] return ( input_shape [ [number] ] , self . kernel_size [ [number] ] , self . dim ) [EOL] [EOL] def get_config ( self ) : [EOL] config = { [string] : self . similarity , [string] : self . mergfunc , [string] : self . kernel_size , [string] : self . dropout_rate , [string] : self . kernel_initializer , [string] : self . wk_kernel_initializer } [EOL] base_config = super ( ) . get_config ( ) [EOL] return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) ) [EOL] [EOL] [EOL] class SelfAttention2DLayer ( SelfAttention1DLayer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , output_size = None , similarity = [string] , * , mergfunc = None , d_a = None , dropout_rate = None , kernel_initializer = [string] , wk_kernel_initializer = [string] , ** kwargs ) : [EOL] self . output_size = output_size [EOL] self . d_a = d_a [EOL] if similarity == [string] : [EOL] if d_a is not None and output_size is not None and len ( output_size ) == [number] : [EOL] kernel_size = ( output_size [ [number] ] * output_size [ [number] ] , d_a ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] else : [EOL] kernel_size = None [EOL] super ( ) . __init__ ( similarity = similarity , mergfunc = mergfunc , dropout_rate = dropout_rate , kernel_size = kernel_size , kernel_initializer = kernel_initializer , wk_kernel_initializer = wk_kernel_initializer , ** kwargs ) [EOL] [EOL] def build ( self , input_shape ) : [EOL] if len ( input_shape ) != [number] : [EOL] raise ValueError ( [string] [string] [string] + str ( input_shape ) + [string] ) [EOL] if self . similarity != [string] and ( self . output_size is not None ) and ( ( input_shape [ [number] ] * input_shape [ [number] ] ) != ( self . output_size [ [number] ] * self . output_size [ [number] ] ) ) : [EOL] raise ValueError ( [string] ) [EOL] X = input_shape [ - [number] ] [EOL] Y = input_shape [ - [number] ] [EOL] if self . output_size is None : [EOL] self . output_size = ( X , Y ) [EOL] time = X * Y [EOL] dim = input_shape [ - [number] ] [EOL] self . dim = dim [EOL] self . _build_w ( time , dim ) [EOL] super ( SelfAttention1DLayer , self ) . build ( input_shape ) [EOL] [EOL] def call ( self , inputs ) : [EOL] [docstring] [EOL] input_shape = inputs . shape [EOL] Source = K . reshape ( inputs , shape = np . asarray ( [ - [number] , ( input_shape [ [number] ] * input_shape [ [number] ] ) . value , input_shape [ [number] ] . value ] ) ) [EOL] _result = self . _call_attention ( Source ) [EOL] result = K . reshape ( _result , np . asarray ( [ - [number] , self . output_size [ [number] ] , self . output_size [ [number] ] , self . dim ] ) ) [EOL] return result [EOL] [EOL] def compute_output_shape ( self , input_shape ) : [EOL] return ( input_shape [ [number] ] , self . output_size [ [number] ] , self . output_size [ [number] ] , self . dim ) [EOL] [EOL] def get_config ( self ) : [EOL] config = { [string] : self . output_size , [string] : self . d_a } [EOL] base_config = super ( ) . get_config ( ) [EOL] return dict ( list ( base_config . items ( ) ) + list ( config . items ( ) ) ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0