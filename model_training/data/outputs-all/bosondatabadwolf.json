[comment] [EOL] [comment] [EOL] from typing import Any , Tuple , List [EOL] import typing [EOL] import os [EOL] import sys [EOL] [EOL] from setuptools import setup , find_packages [EOL] from setuptools . command . test import test as TestCommand [EOL] [EOL] [EOL] class PyTest ( TestCommand ) : [EOL] user_options = [ ( [string] , [string] , [string] ) ] [EOL] [EOL] def initialize_options ( self ) : [EOL] TestCommand . initialize_options ( self ) [EOL] self . pytest_args = [ ] [EOL] [EOL] def finalize_options ( self ) : [EOL] TestCommand . finalize_options ( self ) [EOL] self . test_args = [ ] [EOL] self . test_suite = True [EOL] [EOL] def run_tests ( self ) : [EOL] import pytest [EOL] errno = pytest . main ( self . pytest_args ) [EOL] sys . exit ( errno ) [EOL] [EOL] [EOL] readme = [string] [EOL] if os . path . exists ( [string] ) : [EOL] readme = [string] [EOL] with open ( readme ) as f : [EOL] long_description = f . read ( ) [EOL] [EOL] with open ( [string] ) as f : [EOL] requirements = [ l for l in f . read ( ) . splitlines ( ) if l ] [EOL] [EOL] [EOL] setup ( name = [string] , version = [string] , author = [string] , author_email = [string] , packages = find_packages ( exclude = ( [string] , [string] ) ) , keywords = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , install_requires = requirements , include_package_data = True , tests_require = [ [string] ] , cmdclass = { [string] : PyTest } , entry_points = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] import unittest . mock as mock [EOL] [EOL] from flask import url_for [EOL] [EOL] import badwolf . bitbucket as bitbucket [EOL] [EOL] [EOL] def test_auto_merge_not_enabled ( app , test_client ) : [EOL] app . config [ [string] ] = False [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get : [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] pr_get . assert_not_called ( ) [EOL] app . config [ [string] ] = True [EOL] [EOL] [EOL] def test_auto_merge_failure_pr_get_error ( app , test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get : [EOL] pr_get . side_effect = bitbucket . BitbucketAPIError ( [number] , [string] , [string] ) [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] with mock . patch . object ( bitbucket . BuildStatus , [string] ) as status_get : [EOL] status_get . assert_not_called ( ) [EOL] [EOL] [EOL] def test_auto_merge_skip_merge_skip_in_title ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get : [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] pr_get . assert_not_called ( ) [EOL] [EOL] [EOL] def test_auto_merge_skip_merge_skip_in_description ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get : [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] pr_get . assert_not_called ( ) [EOL] [EOL] [EOL] def test_auto_merge_skip_wip_in_title ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get : [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] pr_get . assert_not_called ( ) [EOL] [EOL] [EOL] def test_auto_merge_skip_wip_in_description ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get : [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] pr_get . assert_not_called ( ) [EOL] [EOL] [EOL] def test_auto_merge_skip_pr_not_in_open_state ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get : [EOL] pr_get . return_value = { [string] : [string] , } [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] with mock . patch . object ( bitbucket . BuildStatus , [string] ) as status_get : [EOL] status_get . assert_not_called ( ) [EOL] [EOL] [EOL] def test_auto_merge_skip_not_enough_approval ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get : [EOL] pr_get . return_value = { [string] : [string] , [string] : [ { [string] : False } , { [string] : True } , { [string] : False } , ] } [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] with mock . patch . object ( bitbucket . BuildStatus , [string] ) as status_get : [EOL] status_get . assert_not_called ( ) [EOL] [EOL] [EOL] def test_auto_merge_success ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get , mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_merge , mock . patch . object ( bitbucket . BuildStatus , [string] ) as status_get : [EOL] pr_get . return_value = { [string] : [string] , [string] : [ { [string] : True } , { [string] : True } , { [string] : True } , ] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , } [EOL] status_get . return_value = { [string] : [string] , } [EOL] pr_merge . return_value = None [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert status_get . called [EOL] assert pr_merge . called [EOL] [EOL] [EOL] def test_auto_merge_call_error ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , } , } ) [EOL] with mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_get , mock . patch . object ( bitbucket . PullRequest , [string] ) as pr_merge , mock . patch . object ( bitbucket . BuildStatus , [string] ) as status_get : [EOL] pr_get . return_value = { [string] : [string] , [string] : [ { [string] : True } , { [string] : True } , { [string] : True } , ] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , } [EOL] status_get . return_value = { [string] : [string] , } [EOL] pr_merge . side_effect = bitbucket . BitbucketAPIError ( [number] , [string] , [string] ) [EOL] test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert status_get . called [EOL] assert pr_merge . called [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def app ( request ) : [EOL] from badwolf . wsgi import app [EOL] [EOL] app . config [ [string] ] = True [EOL] app . config [ [string] ] = [string] [EOL] ctx = app . app_context ( ) [EOL] ctx . push ( ) [EOL] [EOL] def teardown ( ) : [EOL] ctx . pop ( ) [EOL] [EOL] request . addfinalizer ( teardown ) [EOL] return app [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def test_client ( app ) : [EOL] return app . test_client ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import badwolf [EOL] import typing [EOL] import os [EOL] import unittest . mock as mock [EOL] [EOL] import pytest [EOL] from unidiff import PatchSet [EOL] [EOL] from badwolf . spec import Specification [EOL] from badwolf . context import Context [EOL] from badwolf . lint . processor import LintProcessor [EOL] from badwolf . utils import ObjectDict [EOL] [EOL] [EOL] CURR_PATH = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] FIXTURES_PATH = os . path . join ( CURR_PATH , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def pr_context ( ) : [EOL] return Context ( [string] , None , [string] , [string] , { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , { [string] : { [string] : [string] } } , pr_id = [number] ) [EOL] [EOL] [EOL] def test_no_linters_ignore ( app , pr_context ) : [EOL] spec = Specification ( ) [EOL] lint = LintProcessor ( pr_context , spec , [string] ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes : [EOL] lint . process ( ) [EOL] load_changes . assert_not_called ( ) [EOL] [EOL] [EOL] def test_load_changes_failed_ignore ( app , pr_context , caplog ) : [EOL] spec = Specification ( ) [EOL] spec . linters . append ( [string] ) [EOL] lint = LintProcessor ( pr_context , spec , [string] ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes : [EOL] load_changes . return_value = None [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_no_changed_files_ignore ( app , pr_context , caplog ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , [string] ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes : [EOL] load_changes . return_value = patch [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert [string] in caplog . text [EOL] [EOL] [EOL] def test_flake8_lint_a_py ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] @ pytest . mark . xfail ( reason = [string] ) def test_eslint_lint_a_js ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_pycodestyle_lint_a_py ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_jsonlint_a_json ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_jsonlint_a_json_changes_in_range ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_jsonlint_a_json_changes_out_of_range ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] [EOL] [EOL] def test_shellcheck_a_sh ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) > [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_csslint_a_css ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_flake8_lint_a_py_with_custom_glob_pattern ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = [string] ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_flake8_lint_a_py_with_custom_regex_pattern ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = [string] ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_yamllint_a_yml ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_flake8_lint_a_py_with_multi_custom_glob_patterns ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = [string] ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_bandit_lint_a_py ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] assert not problem . is_error [EOL] [EOL] [EOL] def test_rstlint_a_rst ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] assert problem . line == [number] [EOL] [EOL] [EOL] def test_pylint_lint_a_py ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] [EOL] [EOL] def test_sasslint_lint_a_scss ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] [EOL] [EOL] @ pytest . mark . xfail ( reason = [string] ) def test_stylelint_lint_a_scss ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . filename == [string] [EOL] [EOL] [EOL] def test_mypy_lint_a_py ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . line == [number] [EOL] assert problem . filename == [string] [EOL] [EOL] [EOL] def test_hadolint_lint_a_dockerfile ( app , pr_context ) : [EOL] diff = [string] [EOL] [EOL] spec = Specification ( ) [EOL] spec . linters . append ( ObjectDict ( name = [string] , pattern = None ) ) [EOL] lint = LintProcessor ( pr_context , spec , os . path . join ( FIXTURES_PATH , [string] ) ) [EOL] patch = PatchSet ( diff . split ( [string] ) ) [EOL] with mock . patch . object ( lint , [string] ) as load_changes , mock . patch . object ( lint , [string] ) as build_status , mock . patch . object ( lint , [string] ) as report : [EOL] load_changes . return_value = patch [EOL] build_status . return_value = None [EOL] report . return_value = ( [number] , [number] ) [EOL] lint . problems . set_changes ( patch ) [EOL] lint . process ( ) [EOL] [EOL] assert load_changes . called [EOL] [EOL] assert len ( lint . problems ) == [number] [EOL] problem = lint . problems [ [number] ] [EOL] assert problem . line == [number] [EOL] assert problem . filename == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] import unittest . mock as mock [EOL] from concurrent . futures import Future [EOL] [EOL] from flask import url_for [EOL] [EOL] from badwolf . utils import to_text [EOL] [EOL] [EOL] def test_pr_created_unsupported_scm ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] assert to_text ( res . data ) == [string] [EOL] [EOL] [EOL] def test_pr_updated_ci_skip_found ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] assert to_text ( res . data ) == [string] [EOL] [EOL] [EOL] def test_pr_updated_state_not_open ( test_client ) : [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] assert to_text ( res . data ) == [string] [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_pr_created_trigger_start_pipeline ( mock_start_pipeline , mock_cancel_pipelines , test_client ) : [EOL] mock_start_pipeline . delay . return_value = Future ( ) [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] assert mock_start_pipeline . delay . called [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import unittest . mock as mock [EOL] [EOL] import git [EOL] import pytest [EOL] [EOL] from badwolf . context import Context [EOL] from badwolf . bitbucket import PullRequest , Changesets [EOL] from badwolf . pipeline import Pipeline [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def push_context ( ) : [EOL] return Context ( [string] , { } , [string] , [string] , { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def pipeline ( push_context ) : [EOL] return Pipeline ( push_context ) [EOL] [EOL] [EOL] def test_clone_repo_failed ( app , pipeline ) : [EOL] with mock . patch . object ( pipeline , [string] ) as mock_clone , mock . patch . object ( pipeline , [string] ) as report_git_error , mock . patch . object ( pipeline , [string] ) as mock_spec , mock . patch . object ( PullRequest , [string] ) as pr_comment , mock . patch . object ( Changesets , [string] ) as cs_comment : [EOL] mock_clone . side_effect = git . GitCommandError ( [string] , [number] ) [EOL] report_git_error . return_value = None [EOL] pr_comment . return_value = None [EOL] cs_comment . return_value = None [EOL] pipeline . start ( ) [EOL] assert report_git_error . called [EOL] mock_spec . assert_not_called ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] import unittest . mock as mock [EOL] from concurrent . futures import Future [EOL] [EOL] from flask import url_for [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_repo_commit_comment_created_ci_retry ( mock_start_pipeline , test_client ) : [EOL] mock_start_pipeline . delay . return_value = Future ( ) [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , } } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { } , } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] assert mock_start_pipeline . delay . called [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_repo_commit_comment_created_ci_rebuild ( mock_start_pipeline , test_client ) : [EOL] mock_start_pipeline . delay . return_value = Future ( ) [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , } } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { } , } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] assert mock_start_pipeline . delay . called [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_repo_commit_comment_created_do_nothing ( mock_start_pipeline , test_client ) : [EOL] mock_start_pipeline . delay . return_value = Future ( ) [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , } } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { } , } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] mock_start_pipeline . delay . assert_not_called ( ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_pr_commit_comment_created_do_nothing ( mock_start_pipeline , mock_cancel_pipelines , test_client ) : [EOL] mock_start_pipeline . delay . return_value = Future ( ) [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , } } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : { } , [string] : { } , } , [string] : { } , } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] mock_start_pipeline . delay . assert_not_called ( ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_pr_commit_comment_created_ci_retry ( mock_start_pipeline , mock_cancel_pipelines , test_client ) : [EOL] mock_start_pipeline . delay . return_value = Future ( ) [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , } } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } , [string] : { } , } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] assert mock_start_pipeline . delay . called [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_pr_commit_comment_created_ci_rebuild ( mock_start_pipeline , mock_cancel_pipelines , test_client ) : [EOL] mock_start_pipeline . delay . return_value = Future ( ) [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , } } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } , [string] : { } } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] assert mock_start_pipeline . delay . called [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_pr_commit_comment_created_ci_retry_state_not_open ( mock_start_pipeline , mock_cancel_pipelines , test_client ) : [EOL] mock_start_pipeline . delay . return_value = Future ( ) [EOL] payload = json . dumps ( { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , } } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } , [string] : { } } ) [EOL] res = test_client . post ( url_for ( [string] ) , data = payload , headers = { [string] : [string] , [string] : [string] , } ) [EOL] assert res . status_code == [number] [EOL] mock_start_pipeline . delay . assert_not_called ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List [EOL] import tests [EOL] import typing [EOL] import io [EOL] import io [EOL] [EOL] import pytest [EOL] from marshmallow import Schema , fields [EOL] [EOL] from badwolf . spec import Specification [EOL] from badwolf . spec import SecureField , ListField [EOL] from badwolf . security import SecureToken [EOL] from badwolf . utils import to_text [EOL] from badwolf . exceptions import InvalidSpecification [EOL] [EOL] [EOL] def test_parse_empty_conf ( app ) : [EOL] spec = Specification . parse ( { } ) [EOL] assert len ( spec . scripts ) == [number] [EOL] assert len ( spec . services ) == [number] [EOL] assert len ( spec . after_success ) == [number] [EOL] assert len ( spec . after_failure ) == [number] [EOL] assert len ( spec . branch ) == [number] [EOL] assert spec . dockerfile == [string] [EOL] assert not spec . notification . email [EOL] assert not spec . notification . slack_webhook [EOL] [EOL] [EOL] def test_parse_single_string_conf ( app ) : [EOL] spec = Specification . parse ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [ [string] , [string] ] , [string] : [string] , } } } ) [EOL] assert spec . services == [ [string] ] [EOL] assert spec . scripts == [ [string] ] [EOL] assert spec . after_success == [ [string] ] [EOL] assert spec . after_failure == [ [string] ] [EOL] assert spec . notification . email . recipients == [ [string] ] [EOL] assert spec . notification . email . on_success == [string] [EOL] assert spec . notification . email . on_failure == [string] [EOL] assert len ( spec . notification . slack_webhook . webhooks ) == [number] [EOL] assert spec . notification . slack_webhook . on_success == [string] [EOL] assert spec . notification . slack_webhook . on_failure == [string] [EOL] [EOL] [EOL] def test_parse_file_single_string ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . dockerfile == [string] [EOL] assert spec . services == [ [string] ] [EOL] assert spec . scripts == [ [string] ] [EOL] assert spec . after_success == [ [string] ] [EOL] assert spec . after_failure == [ [string] ] [EOL] assert spec . notification . email . recipients == [ [string] ] [EOL] assert spec . notification . email . on_success == [string] [EOL] assert spec . notification . email . on_failure == [string] [EOL] assert spec . notification . slack_webhook . webhooks == [ [string] ] [EOL] assert spec . notification . slack_webhook . on_success == [string] [EOL] assert spec . notification . slack_webhook . on_failure == [string] [EOL] [EOL] [EOL] def test_parse_file_single_list ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . dockerfile == [string] [EOL] assert spec . services == [ [string] ] [EOL] assert spec . scripts == [ [string] ] [EOL] assert spec . after_success == [ [string] ] [EOL] assert spec . after_failure == [ [string] ] [EOL] assert spec . notification . email . recipients == [ [string] ] [EOL] assert spec . notification . email . on_success == [string] [EOL] assert spec . notification . email . on_failure == [string] [EOL] assert spec . notification . slack_webhook . webhooks == [ [string] ] [EOL] assert spec . notification . slack_webhook . on_success == [string] [EOL] assert spec . notification . slack_webhook . on_failure == [string] [EOL] [EOL] [EOL] def test_parse_file_multi_list ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . dockerfile == [string] [EOL] assert spec . services == [ [string] , [string] ] [EOL] assert spec . scripts == [ [string] , [string] ] [EOL] assert spec . after_success == [ [string] , [string] ] [EOL] assert spec . after_failure == [ [string] , [string] ] [EOL] assert spec . notification . email . recipients == [ [string] , [string] ] [EOL] assert spec . notification . email . on_success == [string] [EOL] assert spec . notification . email . on_failure == [string] [EOL] assert len ( spec . notification . slack_webhook . webhooks ) == [number] [EOL] assert spec . notification . slack_webhook . on_success == [string] [EOL] assert spec . notification . slack_webhook . on_failure == [string] [EOL] [EOL] [EOL] def test_parse_notification_object_no_option ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . notification . email . recipients == [ [string] , [string] ] [EOL] assert spec . notification . email . on_success == [string] [EOL] assert spec . notification . email . on_failure == [string] [EOL] assert len ( spec . notification . slack_webhook . webhooks ) == [number] [EOL] assert spec . notification . slack_webhook . on_success == [string] [EOL] assert spec . notification . slack_webhook . on_failure == [string] [EOL] [EOL] [EOL] def test_parse_notification_object_with_option ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . notification . email . recipients == [ [string] , [string] ] [EOL] assert spec . notification . email . on_success == [string] [EOL] assert spec . notification . email . on_failure == [string] [EOL] assert len ( spec . notification . slack_webhook . webhooks ) == [number] [EOL] assert spec . notification . slack_webhook . on_success == [string] [EOL] assert spec . notification . slack_webhook . on_failure == [string] [EOL] [EOL] [EOL] def test_parse_env_single_string ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . environments ) == [number] [EOL] env0 = spec . environments [ [number] ] [EOL] assert env0 [ [string] ] == [string] [EOL] assert env0 [ [string] ] == [string] [EOL] assert env0 [ [string] ] == [string] [EOL] [EOL] [EOL] def test_parse_env_single_list ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . environments ) == [number] [EOL] env0 = spec . environments [ [number] ] [EOL] assert env0 [ [string] ] == [string] [EOL] assert env0 [ [string] ] == [string] [EOL] assert env0 [ [string] ] == [string] [EOL] [EOL] [EOL] def test_parse_secure_env ( app ) : [EOL] s = [string] . format ( to_text ( SecureToken . encrypt ( [string] ) ) ) [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . environments ) == [number] [EOL] env0 = spec . environments [ [number] ] [EOL] assert env0 [ [string] ] == [string] [EOL] assert env0 [ [string] ] == [string] [EOL] assert env0 [ [string] ] == [string] [EOL] [EOL] [EOL] def test_parse_env_multi_list ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . environments ) == [number] [EOL] env0 = spec . environments [ [number] ] [EOL] assert env0 [ [string] ] == [string] [EOL] assert env0 [ [string] ] == [string] [EOL] assert env0 [ [string] ] == [string] [EOL] env1 = spec . environments [ [number] ] [EOL] assert env1 [ [string] ] == [string] [EOL] assert env1 [ [string] ] == [string] [EOL] assert env1 [ [string] ] == [string] [EOL] [EOL] [EOL] def test_parse_simple_linter ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . linters ) == [number] [EOL] linter0 = spec . linters [ [number] ] [EOL] assert linter0 . name == [string] [EOL] assert linter0 . pattern is None [EOL] [EOL] [EOL] def test_parse_linter_with_pattern ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . linters ) == [number] [EOL] linter0 = spec . linters [ [number] ] [EOL] assert linter0 . name == [string] [EOL] assert linter0 . pattern == [string] [EOL] assert linter0 . whatever == [number] [EOL] [EOL] [EOL] def test_parse_multi_linters_with_pattern ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . linters ) == [number] [EOL] linter0 = spec . linters [ [number] ] [EOL] assert linter0 . name == [string] [EOL] assert linter0 . pattern == [string] [EOL] linter1 = spec . linters [ [number] ] [EOL] assert linter1 . name == [string] [EOL] assert linter1 . pattern is None [EOL] [EOL] [EOL] def test_parse_linter_with_regex_pattern ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . linters ) == [number] [EOL] linter0 = spec . linters [ [number] ] [EOL] assert linter0 . name == [string] [EOL] assert linter0 . pattern == [string] [EOL] [EOL] [EOL] def test_parse_privileged ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . privileged [EOL] [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert not spec . privileged [EOL] [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert not spec . privileged [EOL] [EOL] [EOL] def test_parse_docker ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . docker [EOL] [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert not spec . docker [EOL] [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert not spec . docker [EOL] [EOL] [EOL] def test_parse_image ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert not spec . image [EOL] [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . image == [string] [EOL] [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . image == [string] [EOL] [EOL] [EOL] def test_generate_script_full_feature ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] script = spec . shell_script [EOL] assert [string] in script [EOL] assert [string] in script [EOL] [EOL] [EOL] def test_generate_script_after_success ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] script = spec . shell_script [EOL] assert [string] in script [EOL] assert [string] in script [EOL] assert [string] not in script [EOL] [EOL] [EOL] def test_generate_script_after_failure ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] script = spec . shell_script [EOL] assert [string] in script [EOL] assert [string] not in script [EOL] assert [string] in script [EOL] [EOL] [EOL] def test_secure_field ( app ) : [EOL] class SecureSchema ( Schema ) : [EOL] token = SecureField ( ) [EOL] [EOL] schema = SecureSchema ( ) [EOL] [EOL] [comment] [EOL] data = { [string] : [string] } [EOL] result = schema . load ( data ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [comment] [EOL] data = { [string] : { [string] : SecureToken . encrypt ( [string] ) } } [EOL] result = schema . load ( data ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [comment] [EOL] data = { [string] : { [string] : [string] } } [comment] [EOL] result = schema . load ( data ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] def test_list_field ( app ) : [EOL] class ListSchema ( Schema ) : [EOL] services = ListField ( fields . String ( ) ) [EOL] [EOL] schema = ListSchema ( ) [EOL] [EOL] [comment] [EOL] data = { [string] : [string] } [EOL] result = schema . load ( data ) [EOL] assert result [ [string] ] == [ [string] ] [EOL] [EOL] [comment] [EOL] data = { [string] : [ [string] ] } [EOL] result = schema . load ( data ) [EOL] assert result [ [string] ] == [ [string] ] [EOL] [EOL] [EOL] def test_deploy_single_provider_object ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . deploy ) == [number] [EOL] deploy = spec . deploy [ [number] ] [EOL] assert deploy . tag [EOL] assert not deploy . branch [EOL] assert deploy . provider == [string] [EOL] assert deploy . script == [ [string] ] [EOL] [EOL] [EOL] def test_deploy_single_provider_list ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . deploy ) == [number] [EOL] deploy = spec . deploy [ [number] ] [EOL] assert not deploy . tag [EOL] assert not deploy . branch [EOL] assert deploy . provider == [string] [EOL] assert deploy . script == [ [string] ] [EOL] [EOL] [EOL] def test_deploy_multiple_provider ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . deploy ) == [number] [EOL] [EOL] script = spec . deploy [ [number] ] [EOL] assert not script . tag [EOL] assert not script . branch [EOL] assert script . provider == [string] [EOL] assert script . script == [ [string] ] [EOL] [EOL] pypi = spec . deploy [ [number] ] [EOL] assert pypi . tag [EOL] assert not pypi . branch [EOL] assert pypi . provider == [string] [EOL] assert pypi . username == [string] [EOL] assert pypi . password == [string] [EOL] [EOL] [EOL] def test_deploy_pypi_provider_no_auth ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert len ( spec . deploy ) == [number] [EOL] [EOL] pypi = spec . deploy [ [number] ] [EOL] assert pypi . tag [EOL] assert not pypi . branch [EOL] assert pypi . provider == [string] [EOL] assert not pypi . username [EOL] assert not pypi . password [EOL] assert pypi . repository [EOL] [EOL] [EOL] def test_deploy_single_provider_object_should_fail ( app ) : [EOL] from badwolf . exceptions import InvalidSpecification [EOL] [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] with pytest . raises ( InvalidSpecification ) : [EOL] Specification . parse_file ( f ) [EOL] [EOL] [EOL] def test_parse_simple_artifacts ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . artifacts . paths == [ [string] ] [EOL] assert spec . artifacts . excludes == [ ] [EOL] [EOL] [EOL] def test_parse_artifacts_paths ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . artifacts . paths == [ [string] ] [EOL] assert spec . artifacts . excludes == [ [string] ] [EOL] [EOL] [EOL] def test_parse_vault_no_env ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . vault . url == [string] [EOL] assert spec . vault . token == [string] [EOL] assert not spec . vault . env [EOL] [EOL] [EOL] def test_parse_vault_with_single_env ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . vault . url == [string] [EOL] assert spec . vault . token == [string] [EOL] env = spec . vault . env [ [string] ] [EOL] assert env == ( [string] , [string] ) [EOL] [EOL] [EOL] def test_parse_vault_with_multi_env ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . vault . url == [string] [EOL] assert spec . vault . token == [string] [EOL] env = spec . vault . env [ [string] ] [EOL] assert env == ( [string] , [string] ) [EOL] env = spec . vault . env [ [string] ] [EOL] assert env == ( [string] , [string] ) [EOL] [EOL] [EOL] def test_parse_vault_with_env_error ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] with pytest . raises ( InvalidSpecification ) : [EOL] Specification . parse_file ( f ) [EOL] [EOL] [EOL] def test_parse_vault_with_secretfile ( app ) : [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec = Specification . parse_file ( f ) [EOL] assert spec . vault . url == [string] [EOL] assert spec . vault . token == [string] [EOL] env = spec . vault . env [ [string] ] [EOL] assert env == ( [string] , [string] ) [EOL] [EOL] s = [string] [EOL] f = io . StringIO ( s ) [EOL] spec . parse_secretfile ( f ) [EOL] env = spec . vault . env [ [string] ] [EOL] assert env == ( [string] , [string] ) [EOL] env = spec . vault . env [ [string] ] [EOL] assert env == ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from badwolf . security import SecureToken [EOL] [EOL] [EOL] def test_secure_token ( app ) : [EOL] plaintext = [string] [EOL] token = SecureToken . encrypt ( plaintext ) [EOL] decrypted = SecureToken . decrypt ( token ) [EOL] assert plaintext == decrypted [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from flask import url_for [EOL] [EOL] [EOL] def test_view_build_log ( test_client ) : [EOL] test_client . get ( url_for ( [string] , sha = [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] from badwolf . utils import sanitize_sensitive_data [EOL] [EOL] [EOL] def test_sanitize_basic_auth_urls ( ) : [EOL] text = [string] [EOL] sanitized = sanitize_sensitive_data ( text ) [EOL] assert [string] not in sanitized [EOL] assert [string] not in sanitized [EOL] assert [string] in sanitized [EOL] [EOL] text = [string] [EOL] sanitized = sanitize_sensitive_data ( text ) [EOL] assert [string] not in sanitized [EOL] assert [string] not in sanitized [EOL] assert [string] in sanitized [EOL] [EOL] text = [string] [EOL] sanitized = sanitize_sensitive_data ( text ) [EOL] assert [string] not in sanitized [EOL] assert [string] not in sanitized [EOL] assert [string] in sanitized [EOL] assert [string] in sanitized [EOL] [EOL] lots_of_urls = [ [string] ] * [number] [EOL] lots_of_urls . extend ( [ [string] ] * [number] ) [EOL] text = [string] . join ( lots_of_urls ) [EOL] sanitized = sanitize_sensitive_data ( text ) [EOL] assert [string] not in sanitized [EOL] assert [string] not in sanitized [EOL] assert [string] in sanitized [EOL] assert [string] in sanitized [EOL] [EOL] [EOL] def test_sanitize_basic_auth_urls_same_line ( ) : [EOL] text = [string] [EOL] sanitized = sanitize_sensitive_data ( text ) [EOL] assert [string] not in sanitized [EOL] assert [string] not in sanitized [EOL] assert [string] in sanitized [EOL] assert [string] in sanitized [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from __future__ import absolute_import , unicode_literals [EOL] [EOL] [EOL] def add ( a , b ) : [EOL] return a + b [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from __future__ import absolute_import , unicode_literals [EOL] [EOL] [EOL] def add ( a , b ) : [EOL] return a + b [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from __future__ import absolute_import , unicode_literals [EOL] [EOL] [EOL] def add ( a , b ) : [EOL] return a + b [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def p ( ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] a = p ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
try : [EOL] a = [number] [EOL] except Exception : [EOL] pass [EOL]	0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] import flask [EOL] import os [EOL] [EOL] from flask import Blueprint , current_app , send_from_directory , abort [EOL] [EOL] [EOL] blueprint = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] ) def download_artifacts ( user , repo , sha , filename ) : [EOL] artifacts_path = os . path . join ( current_app . config [ [string] ] , user , repo , sha , ) [EOL] if os . path . exists ( os . path . join ( artifacts_path , filename ) ) : [EOL] return send_from_directory ( artifacts_path , filename ) [EOL] abort ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] class BadwolfException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class SpecificationNotFound ( BadwolfException ) : [EOL] pass [EOL] [EOL] [EOL] class BuildDisabled ( BadwolfException ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidSpecification ( BadwolfException ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import badwolf [EOL] import concurrent [EOL] import typing [EOL] import logging [EOL] import time [EOL] import logging [EOL] import multiprocessing [EOL] from concurrent . futures import ThreadPoolExecutor [EOL] try : [EOL] import re2 as re [EOL] except ImportError : [EOL] import re [EOL] [EOL] from badwolf . extensions import sentry , bitbucket [EOL] from badwolf . bitbucket import PullRequest , BuildStatus , BitbucketAPIError [EOL] from badwolf . pipeline import Pipeline [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] executor = ThreadPoolExecutor ( max_workers = [number] * multiprocessing . cpu_count ( ) ) [EOL] _MERGE_COMMIT_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] def _run_task ( _task_func , * args , ** kwargs ) : [EOL] from badwolf . wsgi import app [EOL] [EOL] logger . debug ( [string] , _task_func . __name__ ) [EOL] try : [EOL] with app . app_context ( ) : [EOL] _task_func ( * args , ** kwargs ) [EOL] except Exception : [EOL] logger . exception ( [string] , _task_func ) [EOL] sentry . captureException ( ) [EOL] [EOL] [EOL] def async_task ( f ) : [EOL] def delay ( * args , ** kwargs ) : [EOL] [comment] [EOL] return executor . submit ( _run_task , f , * args , ** kwargs ) [EOL] f . delay = delay [EOL] return f [EOL] [EOL] [EOL] @ async_task def start_pipeline ( context ) : [EOL] Pipeline ( context ) . start ( ) [EOL] [EOL] [EOL] @ async_task def check_pr_mergeable ( context ) : [EOL] repo = bitbucket . get ( [string] . format ( context . repository ) ) [EOL] main_branch = repo [ [string] ] [ [string] ] [EOL] current_branch = context . source [ [string] ] [ [string] ] [EOL] if current_branch != [string] and current_branch != main_branch : [EOL] logger . info ( [string] , current_branch , main_branch ) [EOL] return [EOL] [EOL] time . sleep ( [number] ) [comment] [EOL] pr = PullRequest ( bitbucket , context . repository ) [EOL] open_prs = pr . list ( state = [string] ) [ [string] ] [EOL] if not open_prs : [EOL] logger . debug ( [string] ) [EOL] return [EOL] [EOL] for open_pr in open_prs : [EOL] check_mergeable ( context , pr , open_pr ) [EOL] [EOL] [EOL] def check_mergeable ( context , pr_api , pr_info ) : [EOL] pr_id = pr_info [ [string] ] [EOL] merge_status = BuildStatus ( bitbucket , pr_info [ [string] ] [ [string] ] [ [string] ] , pr_info [ [string] ] [ [string] ] [ [string] ] , [string] , [string] . format ( context . repository , pr_id ) ) [EOL] notify = False [EOL] status = { [string] : None } [EOL] try : [EOL] status = merge_status . get ( ) [EOL] except BitbucketAPIError as e : [EOL] if e . code != [number] : [EOL] raise [EOL] notify = True [EOL] else : [EOL] if status [ [string] ] == [string] : [EOL] notify = True [EOL] [EOL] diff = pr_api . diff ( pr_id , raw = True ) [EOL] if [string] not in diff : [EOL] [comment] [EOL] logger . info ( [string] , pr_id ) [EOL] if status [ [string] ] != [string] : [EOL] merge_status . update ( [string] , [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] if not notify : [EOL] return [EOL] [EOL] logger . info ( [string] , pr_id ) [EOL] merge_status . update ( [string] , [string] ) [EOL] comment = ( [string] [string] ) [EOL] matches = _MERGE_COMMIT_RE . search ( context . message ) [EOL] if matches : [EOL] comment = comment . format ( [string] . format ( matches . group ( [number] ) ) ) [EOL] else : [EOL] comment = comment . format ( [string] . format ( context . source [ [string] ] [ [string] ] ) ) [EOL] pr_api . comment ( pr_id , comment ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import logging [EOL] import logging [EOL] import smtplib [EOL] [EOL] from badwolf . extensions import mail , sentry [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def send_mail ( recipients , subject , html ) : [EOL] logger . info ( [string] , recipients ) [EOL] try : [EOL] mail . send_message ( subject = subject , recipients = recipients , html = html , ) [EOL] except smtplib . SMTPException : [EOL] logger . exception ( [string] , recipients ) [EOL] sentry . captureException ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import signal [EOL] [EOL] import click [EOL] [EOL] import badwolf [EOL] [EOL] [EOL] @ click . group ( ) @ click . version_option ( version = badwolf . __version__ ) def manage ( ) : [EOL] [docstring] [EOL] try : [EOL] import faulthandler [EOL] faulthandler . register ( signal . SIGUSR1 ) [EOL] except ImportError : [EOL] pass [EOL] [EOL] [EOL] @ manage . command ( ) @ click . option ( [string] , [string] , type = str , default = [string] , help = [string] ) @ click . option ( [string] , [string] , type = int , default = [number] , help = [string] ) @ click . option ( [string] , is_flag = True , default = False , help = [string] ) @ click . option ( [string] , is_flag = True , default = False , help = [string] ) def runserver ( host , port , reload , debug ) : [EOL] [docstring] [EOL] from werkzeug . serving import run_simple [EOL] from badwolf . wsgi import app [EOL] [EOL] app . debug = debug [EOL] [EOL] run_simple ( host , port , app , use_reloader = reload , use_debugger = debug , threaded = True , ) [EOL] [EOL] [EOL] @ manage . command ( ) def shell ( ) : [EOL] [docstring] [EOL] from badwolf . wsgi import app [EOL] [EOL] app . debug = True [EOL] context = { [string] : app , } [EOL] [EOL] with app . app_context ( ) : [EOL] [comment] [EOL] try : [EOL] from ptpython . ipython import embed [EOL] embed ( user_ns = context , vi_mode = True ) [EOL] return [EOL] except ImportError : [EOL] pass [EOL] [EOL] [comment] [EOL] try : [EOL] from bpython import embed [EOL] embed ( locals_ = context ) [EOL] return [EOL] except ImportError : [EOL] pass [EOL] [EOL] [comment] [EOL] try : [EOL] try : [EOL] [comment] [EOL] from IPython . Shell import IPShellEmbed [EOL] ipshell = IPShellEmbed ( banner = [string] ) [EOL] ipshell ( global_ns = dict ( ) , local_ns = context ) [EOL] except ImportError : [EOL] [comment] [EOL] from IPython import embed [EOL] embed ( banner1 = [string] , user_ns = context ) [EOL] return [EOL] except ImportError : [EOL] pass [EOL] [EOL] [comment] [EOL] import code [EOL] [EOL] code . interact ( local = context ) [EOL] [EOL] [EOL] @ manage . command ( ) @ click . argument ( [string] , required = True ) def encrypt ( text ) : [EOL] [docstring] [EOL] from badwolf . wsgi import app [EOL] from badwolf . security import SecureToken [EOL] [EOL] with app . app_context ( ) : [EOL] token = SecureToken . encrypt ( text ) [EOL] [EOL] click . echo ( token ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] __version__ = [string] [EOL] [EOL] [EOL] def create_app ( config = None ) : [EOL] from . app import create_app as _create_app [EOL] [EOL] app = _create_app ( config ) [EOL] [EOL] register_extensions ( app ) [EOL] register_blueprints ( app ) [EOL] register_error_handlers ( app ) [EOL] return app [EOL] [EOL] [EOL] def register_blueprints ( app ) : [EOL] def register ( bp ) : [EOL] prefix = [string] . format ( bp . name ) [EOL] app . register_blueprint ( bp , url_prefix = prefix ) [EOL] [EOL] import badwolf . webhook . views [EOL] import badwolf . oauth . views [EOL] import badwolf . log . views [EOL] import badwolf . security [EOL] import badwolf . artifacts [EOL] [EOL] register ( badwolf . webhook . views . blueprint ) [EOL] register ( badwolf . oauth . views . blueprint ) [EOL] register ( badwolf . log . views . blueprint ) [EOL] register ( badwolf . security . blueprint ) [EOL] register ( badwolf . artifacts . blueprint ) [EOL] [EOL] [EOL] def register_error_handlers ( app ) : [EOL] pass [EOL] [EOL] [EOL] def register_extensions ( app ) : [EOL] from . extensions import sentry , mail , bitbucket [EOL] [EOL] sentry . init_app ( app ) [EOL] mail . init_app ( app ) [EOL] bitbucket . init_app ( app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import flask [EOL] import os [EOL] import logging . config [EOL] [EOL] from flask import Flask [EOL] [EOL] [EOL] def create_app ( config = None ) : [EOL] app = Flask ( __name__ ) [EOL] [EOL] [comment] [EOL] app . config . from_object ( [string] ) [EOL] [EOL] [comment] [EOL] user_conf = os . path . expanduser ( [string] ) [EOL] if os . path . isfile ( user_conf ) : [EOL] app . config . from_pyfile ( user_conf ) [EOL] [EOL] [comment] [EOL] if [string] in os . environ : [EOL] app . config . from_envvar ( [string] ) [EOL] [EOL] [comment] [EOL] if config is not None : [EOL] if isinstance ( config , dict ) : [EOL] app . config . update ( config ) [EOL] else : [EOL] app . config . from_pyfile ( config ) [EOL] [EOL] [comment] [EOL] logging . config . dictConfig ( app . config [ [string] ] ) [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List [EOL] import subprocess [EOL] import typing [EOL] import logging [EOL] import os [EOL] import logging [EOL] import subprocess [EOL] try : [EOL] import re2 as re [EOL] except ImportError : [EOL] import re [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] BASIC_AUTH_URL_RE = re . compile ( [string] , re . I | re . U ) [EOL] [EOL] [EOL] class ObjectDict ( dict ) : [EOL] [docstring] [EOL] def __getattr__ ( self , key ) : [EOL] if key in self : [EOL] return self [ key ] [EOL] return None [EOL] [EOL] def __setattr__ ( self , key , value ) : [EOL] self [ key ] = value [EOL] [EOL] [EOL] def to_text ( value , encoding = [string] , errors = [string] ) : [EOL] [docstring] [EOL] if not value : [EOL] return [string] [EOL] if isinstance ( value , str ) : [EOL] return value [EOL] if isinstance ( value , bytes ) : [EOL] return value . decode ( encoding , errors ) [EOL] return str ( value ) [EOL] [EOL] [EOL] def to_binary ( value , encoding = [string] ) : [EOL] [docstring] [EOL] if not value : [EOL] return [string] [EOL] if isinstance ( value , bytes ) : [EOL] return value [EOL] if isinstance ( value , str ) : [EOL] return value . encode ( encoding ) [EOL] return bytes ( value ) [EOL] [EOL] [EOL] def yesish ( value ) : [EOL] [docstring] [EOL] if isinstance ( value , bool ) : [EOL] return value [EOL] return value . lower ( ) in ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] def sanitize_sensitive_data ( s ) : [EOL] return _sanitize_urls ( s ) [EOL] [EOL] [EOL] def _sanitize_urls ( s ) : [EOL] def remove_basic_auth ( match ) : [EOL] return [string] . format ( match . group ( [string] ) , match . group ( [string] ) , ) [EOL] ret = [ ] [EOL] for line in s . split ( [string] ) : [EOL] ret . append ( BASIC_AUTH_URL_RE . sub ( remove_basic_auth , line ) ) [EOL] return [string] . join ( ret ) [EOL] [EOL] [EOL] def run_command ( command , split = False , include_errors = False , cwd = None , shell = False , env = None ) : [EOL] [docstring] [EOL] sub_env = os . environ . copy ( ) [EOL] if env is not None : [EOL] sub_env . update ( env ) [EOL] if include_errors : [EOL] error_pipe = subprocess . STDOUT [EOL] else : [EOL] error_pipe = subprocess . PIPE [EOL] [EOL] process = subprocess . Popen ( command , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = error_pipe , shell = shell , universal_newlines = True , cwd = cwd , env = sub_env ) [EOL] if split : [EOL] output = process . stdout . readlines ( ) [EOL] else : [EOL] output = process . stdout . read ( ) [EOL] [EOL] return_code = process . wait ( ) [EOL] logger . debug ( [string] , command , return_code , output ) [EOL] return return_code , output [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] from badwolf import create_app [EOL] [EOL] [EOL] app = create_app ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import flask [EOL] import cryptography [EOL] import typing [EOL] from flask import current_app , Blueprint , request [EOL] from cryptography . fernet import Fernet [EOL] [EOL] from badwolf . utils import to_binary , to_text [EOL] [EOL] [EOL] blueprint = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] class SecureToken ( object ) : [EOL] [EOL] @ staticmethod def encrypt ( text ) : [EOL] fernet = Fernet ( to_binary ( current_app . config [ [string] ] ) ) [EOL] return fernet . encrypt ( to_binary ( text ) ) [EOL] [EOL] @ staticmethod def decrypt ( encrypted ) : [EOL] fernet = Fernet ( to_binary ( current_app . config [ [string] ] ) ) [EOL] text = fernet . decrypt ( to_binary ( encrypted ) ) [EOL] return to_text ( text ) [EOL] [EOL] [EOL] def parse_secretfile ( fd ) : [EOL] env = [ ] [EOL] for line in fd : [EOL] line = line . strip ( ) [EOL] if not line : [EOL] continue [EOL] if line . startswith ( [string] ) : [EOL] continue [EOL] elif line . startswith ( [string] ) : [EOL] [comment] [EOL] continue [EOL] else : [EOL] env . append ( line ) [EOL] return env [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def generate_secure_token ( ) : [EOL] payload = request . get_data ( ) [EOL] token = SecureToken . encrypt ( payload ) [EOL] return token + [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cryptography.fernet.Fernet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cryptography.fernet.Fernet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cryptography.fernet.Fernet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $cryptography.fernet.Fernet$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import requests [EOL] import logging [EOL] import logging [EOL] from urllib . parse import quote [EOL] [EOL] import git [EOL] import requests [EOL] from requests . auth import HTTPBasicAuth [EOL] from optionaldict import optionaldict [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class BitbucketAPIError ( requests . RequestException ) : [EOL] [docstring] [EOL] def __init__ ( self , code , error , description , * args , ** kwargs ) : [EOL] super ( BitbucketAPIError , self ) . __init__ ( * args , ** kwargs ) [EOL] self . code = code [EOL] self . error = error [EOL] self . description = description [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . code , self . error , self . description ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . code , self . error , self . description ) [EOL] [EOL] [EOL] class APIDispatcher ( object ) : [EOL] def __init__ ( self ) : [EOL] self . _session = requests . Session ( ) [EOL] [EOL] def dispatch ( self , method , url , ** kwargs ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def clone_repository ( self , full_name , path ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ property def session ( self ) : [EOL] return self . _session [EOL] [EOL] [EOL] class BasicAuthDispatcher ( APIDispatcher ) : [EOL] def __init__ ( self , username , password ) : [EOL] super ( BasicAuthDispatcher , self ) . __init__ ( ) [EOL] self . _username = username [EOL] self . _password = password [EOL] [EOL] def dispatch ( self , method , url , ** kwargs ) : [EOL] kwargs [ [string] ] = HTTPBasicAuth ( self . _username , self . _password ) [EOL] return self . _session . request ( method , url , ** kwargs ) [EOL] [EOL] def get_git_url ( self , full_name ) : [EOL] return [string] . format ( username = quote ( self . _username ) , password = quote ( self . _password ) , name = full_name ) [EOL] [EOL] def clone_repository ( self , full_name , path , ** kwargs ) : [EOL] clone_url = self . get_git_url ( full_name ) [EOL] return git . Git ( ) . clone ( clone_url , path , ** kwargs ) [EOL] [EOL] [EOL] class OAuth2Dispatcher ( APIDispatcher ) : [EOL] def __init__ ( self , oauth_key , oauth_secret ) : [EOL] super ( OAuth2Dispatcher , self ) . __init__ ( ) [EOL] self . _oauth_key = oauth_key [EOL] self . _oauth_secret = oauth_secret [EOL] self . _access_token = None [EOL] self . _refresh_token = None [EOL] [EOL] def get_authorization_url ( self , grant_type = [string] ) : [EOL] return [string] . format ( key = self . _oauth_key , type_ = grant_type ) [EOL] [EOL] def grant_access_token ( self , code ) : [EOL] res = self . _session . post ( [string] , data = { [string] : [string] , [string] : code , } , auth = HTTPBasicAuth ( self . _oauth_key , self . _oauth_secret ) ) [EOL] try : [EOL] res . raise_for_status ( ) [EOL] except requests . RequestException as reqe : [EOL] error_info = res . json ( ) [EOL] raise BitbucketAPIError ( res . status_code , error_info . get ( [string] , [string] ) , error_info . get ( [string] , [string] ) , request = reqe . request , response = reqe . response ) [EOL] data = res . json ( ) [EOL] self . _access_token = data [ [string] ] [EOL] self . _refresh_token = data [ [string] ] [EOL] self . _token_type = data [ [string] ] [EOL] return data [EOL] [EOL] def refresh_access_token ( self , token = None ) : [EOL] token = token or self . _refresh_token [EOL] res = self . _session . post ( [string] , data = { [string] : [string] , [string] : token } , auth = HTTPBasicAuth ( self . _oauth_key , self . _oauth_secret ) ) [EOL] try : [EOL] res . raise_for_status ( ) [EOL] except requests . RequestException as reqe : [EOL] error_info = res . json ( ) [EOL] raise BitbucketAPIError ( res . status_code , error_info . get ( [string] , [string] ) , error_info . get ( [string] , [string] ) , request = reqe . request , response = reqe . response ) [EOL] data = res . json ( ) [EOL] self . _access_token = data [ [string] ] [EOL] self . _refresh_token = data [ [string] ] [EOL] self . _token_type = data [ [string] ] [EOL] return data [EOL] [EOL] def dispatch ( self , method , url , ** kwargs ) : [EOL] headers = { [string] : [string] . format ( self . _access_token ) , } [EOL] kwargs [ [string] ] = headers [EOL] return self . _session . request ( method , url , ** kwargs ) [EOL] [EOL] def get_git_url ( self , full_name ) : [EOL] return [string] . format ( access_token = quote ( self . _access_token ) , name = full_name ) [EOL] [EOL] def clone_repository ( self , full_name , path , ** kwargs ) : [EOL] clone_url = self . get_git_url ( full_name ) [EOL] return git . Git ( ) . clone ( clone_url , path , ** kwargs ) [EOL] [EOL] [EOL] class Bitbucket ( object ) : [EOL] def __init__ ( self , dispatcher ) : [EOL] self . _dispatcher = dispatcher [EOL] [EOL] def request ( self , method , url , ** kwargs ) : [EOL] if not url . startswith ( [string] ) : [EOL] url = [string] . format ( url ) [EOL] [EOL] raw = kwargs . pop ( [string] , False ) [EOL] res = self . _dispatcher . dispatch ( method , url , ** kwargs ) [EOL] res . encoding = [string] [EOL] try : [EOL] res . raise_for_status ( ) [EOL] except requests . RequestException as reqe : [EOL] if res . status_code == [number] and isinstance ( self . _dispatcher , OAuth2Dispatcher ) : [EOL] [comment] [EOL] self . refresh_access_token ( ) [EOL] return self . request ( method , url , ** kwargs ) [EOL] else : [EOL] try : [EOL] error_info = res . json ( ) [EOL] except ( TypeError , ValueError ) : [EOL] error_info = { } [EOL] logger . exception ( [string] , res . text ) [EOL] [EOL] raise BitbucketAPIError ( res . status_code , error_info . get ( [string] , [string] ) , error_info . get ( [string] , [string] ) , request = reqe . request , response = reqe . response ) [EOL] [EOL] if raw : [EOL] return res [EOL] return res . json ( ) [EOL] [EOL] def get ( self , url , ** kwargs ) : [EOL] return self . request ( [string] , url , ** kwargs ) [EOL] [EOL] def post ( self , url , ** kwargs ) : [EOL] return self . request ( [string] , url , ** kwargs ) [EOL] [EOL] def put ( self , url , ** kwargs ) : [EOL] return self . request ( [string] , url , ** kwargs ) [EOL] [EOL] def delete ( self , url , ** kwargs ) : [EOL] return self . request ( [string] , url , ** kwargs ) [EOL] [EOL] def clone ( self , repo_full_name , clone_path , ** kwargs ) : [EOL] return self . _dispatcher . clone_repository ( repo_full_name , clone_path , ** kwargs ) [EOL] [EOL] def get_git_url ( self , repo_full_name ) : [EOL] return self . _dispatcher . get_git_url ( repo_full_name ) [EOL] [EOL] [EOL] class BuildStatus ( object ) : [EOL] def __init__ ( self , client , repo , revision , key , url ) : [EOL] self . client = client [EOL] self . repo = repo [EOL] self . revision = revision [EOL] self . key = key [EOL] self . url = url [EOL] [EOL] def get ( self ) : [EOL] endpoint = [string] . format ( repo = self . repo , revision = self . revision , key = self . key ) [EOL] return self . client . get ( endpoint ) [EOL] [EOL] def update ( self , state , name = None , description = None ) : [EOL] endpoint = [string] . format ( repo = self . repo , revision = self . revision ) [EOL] return self . client . post ( endpoint , data = { [string] : self . key , [string] : state , [string] : self . url , [string] : name , [string] : description , } ) [EOL] [EOL] [EOL] class PullRequest ( object ) : [EOL] def __init__ ( self , client , repo ) : [EOL] self . client = client [EOL] self . repo = repo [EOL] [EOL] def get ( self , id ) : [EOL] endpoint = [string] . format ( repo = self . repo , id = id ) [EOL] return self . client . get ( endpoint ) [EOL] [EOL] def list ( self , state = None , page = [number] , size = [number] ) : [EOL] endpoint = [string] . format ( repo = self . repo , id = id ) [EOL] params = { [string] : page , [string] : size , } [EOL] if state : [EOL] params [ [string] ] = state [EOL] return self . client . get ( endpoint , params = params ) [EOL] [EOL] def merge ( self , id , message ) : [EOL] endpoint = [string] . format ( repo = self . repo , id = id ) [EOL] return self . client . post ( endpoint , data = { [string] : message , } ) [EOL] [EOL] def comment ( self , id , content , line_from = None , line_to = None , parent_id = None , filename = None ) : [EOL] endpoint = [string] . format ( repo = self . repo , id = id ) [EOL] data = { [string] : { [string] : content } } [EOL] inline = optionaldict ( { [string] : line_from , [string] : line_to , [string] : filename } ) [EOL] if inline : [EOL] data [ [string] ] = inline [EOL] if parent_id : [EOL] data [ [string] ] = { [string] : parent_id } [EOL] return self . client . post ( endpoint , json = data ) [EOL] [EOL] def comments ( self , id , page = [number] , size = [number] ) : [EOL] endpoint = [string] . format ( repo = self . repo , id = id ) [EOL] params = { [string] : page , [string] : size , } [EOL] return self . client . get ( endpoint , params = params ) [EOL] [EOL] def all_comments ( self , id ) : [EOL] rs = [ ] [EOL] res = self . comments ( id ) [EOL] rs . extend ( res [ [string] ] ) [EOL] while res . get ( [string] ) : [EOL] res = self . comments ( id , page = res [ [string] ] + [number] ) [EOL] rs . extend ( res [ [string] ] ) [EOL] return rs [EOL] [EOL] def delete_comment ( self , id , comment_id ) : [EOL] endpoint = [string] . format ( repo = self . repo , id = id , cid = comment_id , ) [EOL] return self . client . delete ( endpoint ) [EOL] [EOL] def diff ( self , id , raw = False ) : [EOL] from unidiff import PatchSet [EOL] [EOL] endpoint = [string] . format ( repo = self . repo , id = id ) [EOL] res = self . client . get ( endpoint , raw = True ) [EOL] res . encoding = [string] [EOL] if raw : [EOL] return res . text [EOL] patch = PatchSet ( res . text . split ( [string] ) ) [EOL] return patch [EOL] [EOL] [EOL] class Changesets ( object ) : [EOL] def __init__ ( self , client , repo ) : [EOL] self . client = client [EOL] self . repo = repo [EOL] [EOL] def comment ( self , node , content , line_from = None , line_to = None , parent_id = None , filename = None ) : [EOL] endpoint = [string] . format ( repo = self . repo , node = node , ) [EOL] data = { [string] : { [string] : content } } [EOL] inline = optionaldict ( { [string] : line_from , [string] : line_to , [string] : filename } ) [EOL] if inline : [EOL] data [ [string] ] = inline [EOL] if parent_id : [EOL] data [ [string] ] = { [string] : parent_id } [EOL] return self . client . post ( endpoint , json = data ) [EOL] [EOL] [EOL] class Hooks ( object ) : [EOL] def __init__ ( self , client , repo ) : [EOL] self . client = client [EOL] self . repo = repo [EOL] [EOL] def add ( self , name , url , events = None ) : [EOL] endpoint = [string] . format ( repo = self . repo , ) [EOL] data = optionaldict ( url = url , description = name , events = events , active = True ) [EOL] return self . client . post ( endpoint , data = data ) [EOL] [EOL] def list ( self ) : [EOL] endpoint = [string] . format ( repo = self . repo , ) [EOL] return self . client . get ( endpoint ) [EOL] [EOL] [EOL] class FlaskBitbucket ( object ) : [EOL] def __init__ ( self , app = None ) : [EOL] self . app = app [EOL] if app is not None : [EOL] self . init_app ( app ) [EOL] [EOL] def init_app ( self , app ) : [EOL] self . client = Bitbucket ( BasicAuthDispatcher ( app . config [ [string] ] , app . config [ [string] ] ) ) [EOL] [EOL] def request ( self , method , url , ** kwargs ) : [EOL] return self . client . request ( method , url , ** kwargs ) [EOL] [EOL] def get ( self , url , ** kwargs ) : [EOL] return self . client . get ( url , ** kwargs ) [EOL] [EOL] def post ( self , url , ** kwargs ) : [EOL] return self . client . post ( url , ** kwargs ) [EOL] [EOL] def put ( self , url , ** kwargs ) : [EOL] return self . client . put ( url , ** kwargs ) [EOL] [EOL] def delete ( self , url , ** kwargs ) : [EOL] return self . client . delete ( url , ** kwargs ) [EOL] [EOL] def clone ( self , repo_full_name , clone_path , ** kwargs ) : [EOL] return self . client . clone ( repo_full_name , clone_path , ** kwargs ) [EOL] [EOL] def get_git_url ( self , repo_full_name ) : [EOL] return self . client . get_git_url ( repo_full_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.sessions.Session$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import os [EOL] import uuid [EOL] [EOL] from flask import current_app [EOL] [EOL] from badwolf . utils import to_text [EOL] [EOL] [EOL] class Context ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , repository , actor , type , message , source , target = None , rebuild = False , pr_id = None , nocache = False , clone_depth = [number] , skip_lint = False ) : [EOL] self . task_id = to_text ( uuid . uuid4 ( ) ) [EOL] self . repository = repository [EOL] self . repo_owner , self . repo_name = repository . split ( [string] ) [EOL] self . actor = actor [EOL] self . type = type [EOL] self . message = message [EOL] self . source = source [EOL] self . target = target [EOL] self . rebuild = rebuild [EOL] self . pr_id = pr_id [EOL] [comment] [EOL] self . nocache = nocache [EOL] self . clone_depth = clone_depth [EOL] self . skip_lint = skip_lint [EOL] [EOL] if [string] not in self . source : [EOL] self . source [ [string] ] = { [string] : repository } [EOL] [EOL] self . clone_path = os . path . join ( current_app . config [ [string] ] , self . repo_name , self . task_id , ) [EOL] self . environment = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . clone_path , [string] : repository , [string] : source [ [string] ] [ [string] ] , } [EOL] if type == [string] : [EOL] self . environment [ [string] ] = source [ [string] ] [ [string] ] [EOL] else : [EOL] self . environment [ [string] ] = source [ [string] ] [ [string] ] [EOL] if pr_id : [EOL] self . environment [ [string] ] = str ( pr_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] import os [EOL] import logging [EOL] [EOL] import git [EOL] [EOL] from badwolf . extensions import bitbucket [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class RepositoryCloner ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , context ) : [EOL] self . context = context [EOL] self . commit_hash = context . source [ [string] ] [ [string] ] [EOL] [EOL] def clone ( self ) : [EOL] clone_path = self . context . clone_path [EOL] source_repo = self . context . source [ [string] ] [ [string] ] [EOL] if self . context . clone_depth > [number] : [EOL] if self . context . target : [EOL] [comment] [EOL] branch = self . context . target [ [string] ] [ [string] ] [EOL] else : [EOL] branch = self . context . source [ [string] ] [ [string] ] [EOL] [comment] [EOL] clone_kwargs = { [string] : self . context . clone_depth , [string] : branch , } [EOL] if self . context . type == [string] : [EOL] [comment] [EOL] clone_kwargs [ [string] ] = True [EOL] bitbucket . clone ( source_repo , clone_path , ** clone_kwargs ) [EOL] else : [EOL] [comment] [EOL] bitbucket . clone ( source_repo , clone_path ) [EOL] [EOL] gitcmd = git . Git ( clone_path ) [EOL] if self . context . target : [EOL] self . _merge_pull_request ( gitcmd ) [EOL] else : [EOL] [comment] [EOL] if not self . is_commit_exists ( gitcmd , self . commit_hash ) : [EOL] logger . info ( [string] ) [EOL] output = gitcmd . fetch ( [string] ) [EOL] logger . info ( [string] , output ) [EOL] logger . info ( [string] , self . commit_hash ) [EOL] gitcmd . checkout ( self . commit_hash ) [EOL] [EOL] gitmodules = os . path . join ( clone_path , [string] ) [EOL] if os . path . exists ( gitmodules ) : [EOL] output = gitcmd . submodule ( [string] , [string] , [string] , [string] , [string] ) [EOL] logger . info ( [string] , output ) [EOL] [EOL] def _merge_pull_request ( self , gitcmd ) : [EOL] [comment] [EOL] source_repo = self . context . source [ [string] ] [ [string] ] [EOL] source_branch = self . context . source [ [string] ] [ [string] ] [EOL] target_repo = self . context . target [ [string] ] [ [string] ] [EOL] if source_repo == target_repo : [EOL] source_remote = [string] [EOL] else : [EOL] [comment] [EOL] source_remote = source_repo . split ( [string] , [number] ) [ [number] ] [EOL] gitcmd . remote ( [string] , source_remote , bitbucket . get_git_url ( source_repo ) ) [EOL] gitcmd . fetch ( source_remote , source_branch ) [EOL] gitcmd . merge ( [string] ) [EOL] [EOL] @ staticmethod def is_commit_exists ( gitcmd , sha ) : [EOL] output = gitcmd . rev_parse ( [string] , [string] , [string] % sha , with_exceptions = False ) [EOL] return bool ( output . strip ( ) ) [EOL] [EOL] @ staticmethod def get_conflicted_files ( repo_path ) : [EOL] gitcmd = git . Git ( repo_path ) [EOL] try : [EOL] return gitcmd . diff ( [string] , [string] ) [EOL] except git . GitCommandError : [EOL] logger . exception ( [string] ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import badwolf [EOL] import typing [EOL] from raven . contrib . flask import Sentry [EOL] from flask_mail import Mail [EOL] [EOL] from badwolf . bitbucket import FlaskBitbucket [EOL] [EOL] [EOL] [comment] [EOL] sentry = Sentry ( ) [EOL] [EOL] [comment] [EOL] mail = Mail ( ) [EOL] [EOL] [comment] [EOL] bitbucket = FlaskBitbucket ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $badwolf.bitbucket.FlaskBitbucket$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $badwolf.bitbucket.FlaskBitbucket$ 0 0 0 0 0
[comment] [EOL] from typing import Union , List , Dict , Any , Literal [EOL] import typing [EOL] import logging [EOL] import typing_extensions [EOL] import requests [EOL] import io [EOL] import os [EOL] import io [EOL] import time [EOL] import base64 [EOL] import logging [EOL] import shlex [EOL] from html import escape as html_escape [EOL] [EOL] import deansi [EOL] import requests [EOL] from flask import current_app , render_template , url_for [EOL] from requests . exceptions import ReadTimeout [EOL] from docker import DockerClient [EOL] from docker . errors import APIError , DockerException , ImageNotFound , NotFound [EOL] from markupsafe import Markup [EOL] [EOL] from badwolf . utils import to_text , to_binary , sanitize_sensitive_data [EOL] from badwolf . extensions import bitbucket , sentry [EOL] from badwolf . bitbucket import BuildStatus , BitbucketAPIError [EOL] from badwolf . notification import send_mail [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Builder ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , context , spec , build_status = None , docker_version = [string] ) : [EOL] self . context = context [EOL] self . spec = spec [EOL] self . repo_name = context . repository . split ( [string] ) [ - [number] ] [EOL] self . commit_hash = context . source [ [string] ] [ [string] ] [EOL] self . build_status = build_status or BuildStatus ( bitbucket , context . source [ [string] ] [ [string] ] , self . commit_hash , [string] , url_for ( [string] , sha = self . commit_hash , _external = True ) ) [EOL] [EOL] self . docker = DockerClient ( base_url = current_app . config [ [string] ] , timeout = current_app . config [ [string] ] , version = docker_version , ) [EOL] [EOL] def run ( self ) : [EOL] start_time = time . time ( ) [EOL] branch = self . context . source [ [string] ] [EOL] context = { [string] : self . context , [string] : self . build_status . url , [string] : branch [ [string] ] , [string] : self . spec . scripts , [string] : deansi . styleSheet ( ) , } [EOL] [EOL] self . update_build_status ( [string] , [string] ) [EOL] docker_image_name , build_output = self . get_docker_image ( ) [EOL] context . update ( { [string] : Markup ( build_output ) , [string] : int ( time . time ( ) - start_time ) , } ) [EOL] if not docker_image_name : [EOL] self . update_build_status ( [string] , [string] ) [EOL] context [ [string] ] = - [number] [EOL] self . send_notifications ( context ) [EOL] return [EOL] [EOL] exit_code , output = self . run_in_container ( docker_image_name ) [EOL] logger . debug ( [string] , output ) [EOL] if exit_code == [number] : [EOL] [comment] [EOL] logger . info ( [string] , self . context . repository ) [EOL] self . update_build_status ( [string] , [string] ) [EOL] else : [EOL] [comment] [EOL] logger . info ( [string] , self . context . repository , exit_code ) [EOL] if exit_code == [number] : [EOL] self . update_build_status ( [string] , [string] ) [EOL] else : [EOL] self . update_build_status ( [string] , [string] ) [EOL] [EOL] context . update ( { [string] : Markup ( deansi . deansi ( output ) ) , [string] : exit_code , [string] : int ( time . time ( ) - start_time ) , } ) [EOL] self . send_notifications ( context ) [EOL] return exit_code [EOL] [EOL] def get_docker_image ( self ) : [EOL] docker_image_name = self . context . repository . replace ( [string] , [string] ) [EOL] output = [ ] [EOL] try : [EOL] docker_image = self . docker . images . get ( docker_image_name ) [EOL] except ImageNotFound : [EOL] docker_image = None [EOL] if not docker_image or self . context . rebuild : [EOL] build_options = { [string] : docker_image_name , [string] : True , [string] : True , [string] : True , [string] : self . context . nocache } [EOL] build_args = self . context . environment . copy ( ) [EOL] if self . spec . environments : [EOL] [comment] [EOL] build_args . update ( self . spec . environments [ [number] ] ) [EOL] if build_args : [EOL] build_options [ [string] ] = build_args [EOL] if self . spec . image : [EOL] from_image_name , from_image_tag = self . spec . image . split ( [string] , [number] ) [EOL] logger . info ( [string] , self . spec . image ) [EOL] self . docker . images . pull ( from_image_name , tag = from_image_tag ) [EOL] logger . info ( [string] , self . spec . image ) [EOL] dockerfile_content = [string] . format ( self . spec . image ) [EOL] fileobj = io . BytesIO ( dockerfile_content . encode ( [string] ) ) [EOL] build_options [ [string] ] = fileobj [EOL] else : [EOL] dockerfile = os . path . join ( self . context . clone_path , self . spec . dockerfile ) [EOL] if os . path . exists ( dockerfile ) : [EOL] build_options [ [string] ] = self . spec . dockerfile [EOL] else : [EOL] logger . warning ( [string] , dockerfile , self . context . repository ) [EOL] dockerfile_content = [string] [EOL] fileobj = io . BytesIO ( dockerfile_content . encode ( [string] ) ) [EOL] build_options [ [string] ] = fileobj [EOL] [EOL] build_success = False [EOL] logger . info ( [string] , docker_image_name ) [EOL] self . update_build_status ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] res = self . docker . api . build ( self . context . clone_path , ** build_options ) [EOL] for log in res : [EOL] if [string] in log : [EOL] msg = log [ [string] ] [ [string] ] [EOL] elif [string] in log : [EOL] [comment] [EOL] [comment] [EOL] msg = log [ [string] ] [EOL] elif [string] in log : [EOL] msg = log [ [string] ] [EOL] else : [EOL] msg = log . get ( [string] ) [EOL] if not msg : [EOL] continue [EOL] if [string] in msg : [EOL] build_success = True [EOL] [EOL] output . append ( deansi . deansi ( msg ) ) [EOL] logger . info ( [string] , msg . strip ( ) ) [EOL] if not build_success : [EOL] return None , [string] . join ( output ) [EOL] [EOL] return docker_image_name , [string] . join ( output ) [EOL] [EOL] def run_in_container ( self , docker_image_name ) : [EOL] environment = self . context . environment . copy ( ) [EOL] if self . spec . environments : [EOL] [comment] [EOL] environment . update ( self . spec . environments [ [number] ] ) [EOL] [EOL] [comment] [EOL] script = shlex . quote ( to_text ( base64 . b64encode ( to_binary ( self . spec . shell_script ) ) ) ) [EOL] environment . update ( { [string] : [string] , [string] : [string] . format ( self . spec . shell ) , [string] : script , } ) [EOL] environment . setdefault ( [string] , [string] ) [EOL] branch = self . context . source [ [string] ] [EOL] labels = { [string] : self . context . repository , [string] : self . commit_hash , [string] : self . context . task_id , } [EOL] if self . context . type == [string] : [EOL] labels [ [string] ] = branch [ [string] ] [EOL] else : [EOL] labels [ [string] ] = branch [ [string] ] [EOL] if self . context . pr_id : [EOL] labels [ [string] ] = str ( self . context . pr_id ) [EOL] [EOL] volumes = { self . context . clone_path : { [string] : self . context . clone_path , [string] : [string] , } , } [EOL] if self . spec . docker : [EOL] volumes [ [string] ] = { [string] : [string] , [string] : [string] , } [EOL] environment . setdefault ( [string] , [string] ) [EOL] logger . debug ( [string] , environment ) [EOL] container = self . docker . containers . create ( docker_image_name , entrypoint = [ [string] . format ( self . spec . shell ) , [string] ] , command = [ [string] . format ( self . spec . shell ) ] , environment = environment , working_dir = self . context . clone_path , volumes = volumes , privileged = self . spec . privileged , stdin_open = False , tty = True , labels = labels , ) [EOL] container_id = container . id [EOL] logger . info ( [string] , container_id , docker_image_name ) [EOL] [EOL] output = [ ] [EOL] try : [EOL] container . start ( ) [EOL] self . update_build_status ( [string] , [string] ) [EOL] exit_code = container . wait ( timeout = current_app . config [ [string] ] ) [EOL] if isinstance ( exit_code , dict ) : [EOL] exit_code = exit_code [ [string] ] [EOL] except ( APIError , DockerException , ReadTimeout ) as e : [EOL] exit_code = - [number] [EOL] output . append ( str ( e ) + [string] ) [EOL] logger . exception ( [string] ) [EOL] finally : [EOL] try : [EOL] output . append ( to_text ( container . logs ( ) ) ) [EOL] container . remove ( force = True ) [EOL] except NotFound : [EOL] pass [EOL] except APIError as api_e : [EOL] if [string] in str ( api_e ) : [EOL] output . append ( [string] ) [EOL] else : [EOL] logger . exception ( [string] ) [EOL] except ( DockerException , ReadTimeout ) : [EOL] logger . exception ( [string] ) [EOL] [EOL] return exit_code , [string] . join ( output ) [EOL] [EOL] def update_build_status ( self , state , description = None ) : [EOL] try : [EOL] self . build_status . update ( state , description = description ) [EOL] except BitbucketAPIError : [EOL] logger . exception ( [string] ) [EOL] sentry . captureException ( ) [EOL] [EOL] def send_notifications ( self , context ) : [EOL] exit_code = context [ [string] ] [EOL] template = [string] if exit_code == [number] else [string] [EOL] html = render_template ( [string] + template + [string] , ** context ) [EOL] html = sanitize_sensitive_data ( html ) [EOL] [EOL] [comment] [EOL] log_dir = os . path . join ( current_app . config [ [string] ] , self . commit_hash , self . context . task_id ) [EOL] os . makedirs ( log_dir , exist_ok = True ) [EOL] log_file = os . path . join ( log_dir , [string] ) [EOL] with open ( log_file , [string] ) as f : [EOL] f . write ( to_binary ( html ) ) [EOL] [EOL] if exit_code == [number] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] test_status = [string] if exit_code == [number] else [string] [EOL] subject = [string] . format ( test_status , self . context . repository ) [EOL] notification = self . spec . notification [EOL] email = notification . email [EOL] should_send_mail = email and email . recipients and ( ( exit_code == [number] and email . on_success == [string] ) or ( exit_code != [number] and email . on_failure == [string] ) ) [EOL] if should_send_mail : [EOL] send_mail ( email . recipients , subject , html ) [EOL] [EOL] slack_webhook = notification . slack_webhook [EOL] if slack_webhook and slack_webhook . webhooks : [EOL] if exit_code == [number] and slack_webhook . on_success == [string] : [EOL] trigger_slack_webhook ( slack_webhook . webhooks , context ) [EOL] if exit_code != [number] and slack_webhook . on_failure == [string] : [EOL] trigger_slack_webhook ( slack_webhook . webhooks , context ) [EOL] [EOL] [EOL] def trigger_slack_webhook ( webhooks , context ) : [EOL] if context [ [string] ] == [number] : [EOL] color = [string] [EOL] title = [string] . format ( context [ [string] ] , context [ [string] ] . repository , ) [EOL] else : [EOL] color = [string] [EOL] title = [string] . format ( context [ [string] ] , context [ [string] ] . repository , ) [EOL] fields = [ ] [EOL] fields . append ( { [string] : [string] , [string] : [string] . format ( repo = context [ [string] ] . repository ) , [string] : True , } ) [EOL] if context [ [string] ] . type == [string] : [EOL] fields . append ( { [string] : [string] , [string] : [string] . format ( repo = context [ [string] ] . repository , tag = context [ [string] ] ) , [string] : True , } ) [EOL] elif context [ [string] ] . type != [string] : [EOL] fields . append ( { [string] : [string] , [string] : [string] . format ( repo = context [ [string] ] . repository , branch = context [ [string] ] , ) , [string] : True , } ) [EOL] if context [ [string] ] . type in { [string] , [string] , [string] } : [EOL] fields . append ( { [string] : [string] , [string] : [string] . format ( repo = context [ [string] ] . repository , sha = context [ [string] ] . source [ [string] ] [ [string] ] , ) , [string] : False } ) [EOL] elif context [ [string] ] . type == [string] : [EOL] fields . append ( { [string] : [string] , [string] : [string] . format ( repo = context [ [string] ] . repository , pr_id = context [ [string] ] . pr_id , title = html_escape ( context [ [string] ] . message , quote = False ) , ) , [string] : False } ) [EOL] [EOL] actor = context [ [string] ] . actor [EOL] attachment = { [string] : title , [string] : title , [string] : color , [string] : context [ [string] ] , [string] : fields , [string] : context [ [string] ] . repo_name , [string] : int ( time . time ( ) ) , [string] : actor [ [string] ] , [string] : actor [ [string] ] [ [string] ] [ [string] ] , [string] : actor [ [string] ] [ [string] ] [ [string] ] , } [EOL] if context [ [string] ] . type in { [string] , [string] } : [EOL] attachment [ [string] ] = context [ [string] ] . message [EOL] payload = { [string] : [ attachment ] } [EOL] session = requests . Session ( ) [EOL] for webhook in webhooks : [EOL] logger . info ( [string] , webhook ) [EOL] res = session . post ( webhook , json = payload , timeout = [number] ) [EOL] try : [EOL] res . raise_for_status ( ) [EOL] except requests . RequestException : [EOL] logger . exception ( [string] , webhook ) [EOL] sentry . captureException ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $io.BytesIO$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $io.BytesIO$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $io.BytesIO$ 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[builtins.str,unknown]]$ 0 $typing.Dict[unknown,typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List [EOL] import badwolf [EOL] import typing [EOL] import logging [EOL] import os [EOL] import shutil [EOL] import logging [EOL] import fnmatch [EOL] import tarfile [EOL] [EOL] import git [EOL] import hvac [EOL] from flask import current_app , url_for [EOL] from docker . errors import APIError as DockerAPIError [EOL] from hvac . exceptions import VaultError [EOL] [EOL] from badwolf . spec import Specification [EOL] from badwolf . extensions import bitbucket , sentry [EOL] from badwolf . bitbucket import BuildStatus , BitbucketAPIError , PullRequest , Changesets [EOL] from badwolf . utils import sanitize_sensitive_data , run_command [EOL] from badwolf . cloner import RepositoryCloner [EOL] from badwolf . builder import Builder [EOL] from badwolf . lint . processor import LintProcessor [EOL] from badwolf . deploy import Deployer [EOL] from badwolf . exceptions import ( BadwolfException , SpecificationNotFound , BuildDisabled , InvalidSpecification , ) [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Pipeline ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , context ) : [EOL] self . context = context [EOL] self . commit_hash = context . source [ [string] ] [ [string] ] [EOL] self . build_status = BuildStatus ( bitbucket , context . repository , self . commit_hash , [string] , url_for ( [string] , sha = self . commit_hash , task_id = context . task_id , _external = True ) ) [EOL] self . vault = None [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] logger . info ( [string] , self . context . repository ) [EOL] try : [EOL] self . clone ( ) [EOL] self . parse_spec ( ) [EOL] exit_code = self . build ( ) [EOL] build_success = exit_code == [number] [EOL] self . save_artifacts ( build_success ) [EOL] if exit_code != [number] : [EOL] [comment] [EOL] self . lint ( ) [EOL] if build_success : [EOL] self . deploy ( ) [EOL] except git . GitCommandError as git_err : [EOL] logger . exception ( [string] ) [EOL] self . _report_git_error ( git_err ) [EOL] except BitbucketAPIError : [EOL] logger . exception ( [string] ) [EOL] sentry . captureException ( ) [EOL] except InvalidSpecification as err : [EOL] self . _report_error ( [string] + str ( err ) ) [EOL] except BadwolfException : [EOL] pass [EOL] finally : [EOL] self . clean ( ) [EOL] [EOL] def _report_error ( self , content ) : [EOL] content = sanitize_sensitive_data ( content ) [EOL] if self . context . pr_id : [EOL] pr = PullRequest ( bitbucket , self . context . repository ) [EOL] pr . comment ( self . context . pr_id , content ) [EOL] else : [EOL] cs = Changesets ( bitbucket , self . context . repository ) [EOL] cs . comment ( self . commit_hash , content ) [EOL] [EOL] def _report_git_error ( self , exc ) : [EOL] def _linkify_file ( name ) : [EOL] return [string] . format ( name = name ) [EOL] [EOL] self . build_status . update ( [string] , description = [string] ) [EOL] git_error_msg = str ( exc ) [EOL] content = [string] . format ( git_error_msg ) [EOL] if [string] in git_error_msg : [EOL] [comment] [EOL] conflicted_files = RepositoryCloner . get_conflicted_files ( self . context . clone_path ) [EOL] if conflicted_files : [EOL] conflicted_files = [string] . join ( ( [string] + _linkify_file ( name ) for name in conflicted_files . split ( [string] ) ) ) [EOL] content = [string] [EOL] content += [string] . format ( conflicted_files ) [EOL] [EOL] self . _report_error ( content ) [EOL] [EOL] def _report_docker_error ( self , exc ) : [EOL] self . build_status . update ( [string] , description = [string] ) [EOL] content = [string] . format ( exc . explanation ) [EOL] self . _report_error ( content ) [EOL] [EOL] def clone ( self ) : [EOL] [docstring] [EOL] logger . info ( [string] , self . context . repository ) [EOL] RepositoryCloner ( self . context ) . clone ( ) [EOL] [EOL] def parse_spec ( self ) : [EOL] [docstring] [EOL] logger . info ( [string] , self . context . repository ) [EOL] conf_file = os . path . join ( self . context . clone_path , current_app . config [ [string] ] ) [EOL] try : [EOL] spec = Specification . parse_file ( conf_file ) [EOL] except OSError : [EOL] logger . warning ( [string] , self . context . repository ) [EOL] raise SpecificationNotFound ( ) [EOL] secretfile = os . path . join ( self . context . clone_path , [string] ) [EOL] if spec . vault . secretfile and os . path . exists ( secretfile ) : [EOL] spec . parse_secretfile ( secretfile ) [EOL] [EOL] branch = self . context . source [ [string] ] [ [string] ] [EOL] if self . context . type == [string] and not spec . is_branch_enabled ( branch ) : [EOL] logger . info ( [string] , branch , spec . branch ) [EOL] raise BuildDisabled ( ) [EOL] if not spec . scripts and not spec . linters : [EOL] logger . warning ( [string] ) [EOL] raise InvalidSpecification ( [string] ) [EOL] self . spec = spec [EOL] [EOL] [comment] [EOL] vault_url = spec . vault . url or current_app . config [ [string] ] [EOL] vault_token = spec . vault . token or current_app . config [ [string] ] [EOL] if vault_url and vault_token : [EOL] self . vault = hvac . Client ( url = vault_url , token = vault_token ) [EOL] self . _populate_envvars_from_vault ( ) [EOL] [EOL] def _populate_envvars_from_vault ( self ) : [EOL] if self . vault is None or not self . spec . vault . env : [EOL] return [EOL] [EOL] paths = [ v [ [number] ] for v in self . spec . vault . env . values ( ) ] [EOL] secrets = { } [EOL] for path in paths : [EOL] try : [EOL] res = self . vault . read ( path ) [EOL] except VaultError as exc : [EOL] raise InvalidSpecification ( [string] . format ( path , str ( exc ) ) ) [EOL] if not res : [EOL] raise InvalidSpecification ( [string] . format ( path ) ) [EOL] secrets [ path ] = res [ [string] ] [EOL] [EOL] for name , ( path , key ) in self . spec . vault . env . items ( ) : [EOL] val = secrets . get ( path , { } ) . get ( key ) [EOL] if val is not None : [EOL] self . context . environment . setdefault ( name , val ) [EOL] [EOL] def build ( self ) : [EOL] [docstring] [EOL] if self . spec . scripts : [EOL] logger . info ( [string] , self . context . repository ) [EOL] try : [EOL] return Builder ( self . context , self . spec , build_status = self . build_status ) . run ( ) [EOL] except DockerAPIError as e : [EOL] logger . exception ( [string] ) [EOL] self . _report_docker_error ( e ) [EOL] return False [EOL] [EOL] def save_artifacts ( self , build_success ) : [EOL] [docstring] [EOL] if not self . spec . artifacts . paths : [EOL] return [EOL] try : [EOL] self . _save_artifacts ( build_success ) [EOL] except Exception : [EOL] logger . exception ( [string] , self . context . repository ) [EOL] sentry . captureException ( ) [EOL] [EOL] def _save_artifacts ( self , build_success ) : [EOL] def _should_exclude ( path ) : [EOL] excluded = self . spec . artifacts . excludes [EOL] if not excluded : [EOL] return False [EOL] [EOL] for pattern in excluded : [EOL] if fnmatch . fnmatch ( path , pattern ) : [EOL] return True [EOL] return False [EOL] [EOL] logger . info ( [string] , self . context . repository ) [EOL] paths = [ ] [EOL] for path in self . spec . artifacts . paths : [EOL] if [string] not in path : [EOL] paths . append ( path ) [EOL] else : [EOL] cmd = [string] . format ( path ) [EOL] exit_code , output = run_command ( cmd , cwd = self . context . clone_path , shell = True ) [EOL] if exit_code == [number] : [EOL] paths . extend ( x for x in output . strip ( ) . split ( [string] ) if x and not _should_exclude ( x ) ) [EOL] if not paths : [EOL] logger . info ( [string] , self . context . repository ) [EOL] return [EOL] [EOL] artifacts_repo_path = os . path . join ( current_app . config [ [string] ] , self . context . repository , ) [EOL] artifacts_commit_path = os . path . join ( artifacts_repo_path , self . commit_hash ) [EOL] os . makedirs ( artifacts_commit_path , exist_ok = True ) [EOL] artifacts_file = os . path . join ( artifacts_commit_path , [string] ) [EOL] file_added = False [EOL] with tarfile . open ( artifacts_file , [string] ) as tar : [EOL] for path in paths : [EOL] file_path = os . path . join ( self . context . clone_path , path ) [EOL] try : [EOL] tar . add ( file_path , path ) [EOL] except FileNotFoundError as exc : [EOL] logger . error ( str ( exc ) ) [EOL] else : [EOL] file_added = True [EOL] if not file_added : [EOL] try : [EOL] shutil . rmtree ( artifacts_commit_path , ignore_errors = True ) [EOL] except OSError : [EOL] logger . exception ( [string] ) [EOL] return [EOL] [EOL] run_command ( [string] , cwd = artifacts_commit_path , shell = True ) [EOL] logger . info ( [string] , artifacts_commit_path ) [EOL] [EOL] if build_success and self . context . type in ( [string] , [string] ) : [EOL] artifacts_branch_path = os . path . join ( artifacts_repo_path , self . context . source [ [string] ] [ [string] ] ) [EOL] os . makedirs ( artifacts_branch_path , exist_ok = True ) [EOL] for name in ( [string] , [string] ) : [EOL] commit_path = os . path . join ( artifacts_commit_path , name ) [EOL] branch_path = os . path . join ( artifacts_branch_path , name ) [EOL] try : [EOL] os . remove ( branch_path ) [EOL] except OSError : [EOL] pass [EOL] os . symlink ( commit_path , branch_path ) [EOL] logger . info ( [string] , artifacts_branch_path ) [EOL] [EOL] build_status = BuildStatus ( bitbucket , self . context . repository , self . commit_hash , [string] , url_for ( [string] , user = self . context . repo_owner , repo = self . context . repo_name , sha = self . commit_hash , filename = [string] , _external = True ) ) [EOL] build_status . update ( [string] , description = [string] ) [EOL] [EOL] def lint ( self ) : [EOL] [docstring] [EOL] if not self . context . skip_lint and self . context . pr_id and self . spec . linters : [EOL] logger . info ( [string] , self . context . repository ) [EOL] LintProcessor ( self . context , self . spec ) . process ( ) [EOL] [EOL] def deploy ( self ) : [EOL] [docstring] [EOL] if not self . spec . deploy or self . context . type not in { [string] , [string] } : [EOL] return [EOL] [EOL] providers = [ ] [EOL] branch = self . context . source [ [string] ] [ [string] ] [EOL] for provider in self . spec . deploy : [EOL] if ( self . context . type == [string] and branch in provider . branch ) or ( self . context . type == [string] and provider . tag ) : [EOL] providers . append ( provider ) [EOL] if not providers : [EOL] return [EOL] logger . info ( [string] , len ( providers ) , self . context . repository ) [EOL] Deployer ( self . context , self . spec , providers ) . deploy ( ) [EOL] [EOL] def clean ( self ) : [EOL] [docstring] [EOL] logger . info ( [string] , self . context . clone_path , self . context . repository ) [EOL] try : [EOL] shutil . rmtree ( self . context . clone_path , ignore_errors = True ) [EOL] except OSError : [EOL] logger . exception ( [string] ) [EOL] sentry . captureException ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $badwolf.bitbucket.BuildStatus$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $badwolf.bitbucket.PullRequest$ 0 0 0 0 0 0 0 0 0 0 0 0 $badwolf.bitbucket.PullRequest$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $badwolf.bitbucket.Changesets$ 0 0 0 0 0 0 0 0 0 0 0 0 $badwolf.bitbucket.Changesets$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $badwolf.bitbucket.BuildStatus$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $badwolf.bitbucket.BuildStatus$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Union , List , Dict , Optional , Tuple , Literal , Any , TextIO [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] import sys [EOL] import base64 [EOL] import tempfile [EOL] import platform [EOL] [EOL] import raven [EOL] import deansi [EOL] [EOL] from badwolf . utils import yesish [EOL] [EOL] [comment] [EOL] DEBUG = yesish ( os . getenv ( [string] , False ) ) [EOL] [EOL] JSON_AS_ASCII = yesish ( os . getenv ( [string] , False ) ) [EOL] SERVER_NAME = os . getenv ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] SECRET_KEY = os . getenv ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] SECURE_TOKEN_KEY = os . getenv ( [string] , base64 . urlsafe_b64encode ( os . urandom ( [number] ) ) ) [EOL] [EOL] [comment] [EOL] SENTRY_DSN = os . getenv ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] DOCKER_HOST = os . getenv ( [string] , [string] ) [EOL] DOCKER_API_TIMEOUT = int ( os . getenv ( [string] , [number] ) ) [EOL] DOCKER_RUN_TIMEOUT = int ( os . getenv ( [string] , [number] ) ) [EOL] [EOL] [comment] [EOL] MAIL_SERVER = os . getenv ( [string] , [string] ) [EOL] MAIL_PORT = int ( os . getenv ( [string] , [number] ) ) [EOL] MAIL_USE_TLS = yesish ( os . getenv ( [string] , True ) ) [EOL] MAIL_USE_SSL = yesish ( os . getenv ( [string] , False ) ) [EOL] MAIL_USERNAME = os . getenv ( [string] , [string] ) [EOL] MAIL_PASSWORD = os . getenv ( [string] , [string] ) [EOL] MAIL_MAX_EMAILS = None [EOL] MAIL_DEFAULT_SENDER = ( os . getenv ( [string] , [string] ) , os . getenv ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] LOGGING = { [string] : [number] , [string] : False , [string] : { [string] : [ [string] ] , [string] : [string] if not DEBUG else [string] , } , [string] : { [string] : { [string] : [string] if not DEBUG else [string] , [string] : [string] , [string] : [string] , [string] : sys . stderr , } } , [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , } , } , [string] : { [string] : { [string] : [string] , } , } , } [EOL] [EOL] BADWOLF_PROJECT_CONF = [string] [EOL] AUTO_MERGE_ENABLED = yesish ( os . getenv ( [string] , True ) ) [EOL] AUTO_MERGE_APPROVAL_COUNT = int ( os . getenv ( [string] , [number] ) ) [EOL] [EOL] BITBUCKET_OAUTH_KEY = os . getenv ( [string] , [string] ) [EOL] BITBUCKET_OAUTH_SECRET = os . getenv ( [string] , [string] ) [EOL] [EOL] BITBUCKET_USERNAME = os . getenv ( [string] , [string] ) [EOL] BITBUCKET_PASSWORD = os . getenv ( [string] , [string] ) [EOL] [EOL] BADWOLF_DATA_DIR = os . getenv ( [string] , [string] ) [EOL] if DEBUG : [EOL] if platform . system ( ) == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] BADWOLF_DATA_DIR = [string] [comment] [EOL] else : [EOL] BADWOLF_DATA_DIR = os . path . join ( tempfile . gettempdir ( ) , [string] ) [EOL] BADWOLF_LOG_DIR = os . getenv ( [string] , os . path . join ( BADWOLF_DATA_DIR , [string] ) ) [EOL] BADWOLF_REPO_DIR = os . getenv ( [string] , os . path . join ( BADWOLF_DATA_DIR , [string] ) ) [EOL] BADWOLF_ARTIFACTS_DIR = os . getenv ( [string] , os . path . join ( BADWOLF_DATA_DIR , [string] ) ) [EOL] [EOL] [comment] [EOL] VAULT_URL = os . getenv ( [string] , os . getenv ( [string] ) ) [EOL] VAULT_TOKEN = os . getenv ( [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] SENTRY_RELEASE = raven . fetch_package_version ( [string] ) [EOL] except Exception : [comment] [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] deansi . variations [ [number] ] = ( [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Type , List , Dict , Optional , Any , Literal [EOL] import typing [EOL] import badwolf [EOL] import logging [EOL] import typing_extensions [EOL] import requests [EOL] import time [EOL] import logging [EOL] [EOL] import requests [EOL] from flask import url_for [EOL] [EOL] from badwolf . extensions import bitbucket , sentry [EOL] from badwolf . utils import run_command [EOL] from badwolf . bitbucket import BitbucketAPIError , BuildStatus [EOL] from badwolf . deploy . providers . script import ScriptProvider [EOL] from badwolf . deploy . providers . pypi import PypiProvider [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Deployer ( object ) : [EOL] PROVIDERS = { [string] : ScriptProvider , [string] : PypiProvider , } [EOL] [EOL] def __init__ ( self , context , spec , providers , working_dir = None ) : [EOL] self . context = context [EOL] self . spec = spec [EOL] self . working_dir = working_dir or context . clone_path [EOL] self . providers = providers [EOL] [EOL] def deploy ( self ) : [EOL] if not self . providers : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] commit_hash = self . context . source [ [string] ] [ [string] ] [EOL] run_after_deploy = False [EOL] notification = self . spec . notification [EOL] slack_webhook = notification . slack_webhook [EOL] [EOL] for provider_config in self . providers : [EOL] provider_name = provider_config . provider [EOL] provider_class = self . PROVIDERS . get ( provider_name ) [EOL] if not provider_class : [EOL] logger . warning ( [string] , provider_name ) [EOL] continue [EOL] [EOL] provider = provider_class ( self . working_dir , provider_config , self . context ) [EOL] if not provider . is_usable ( ) : [EOL] logger . warning ( [string] , provider_name ) [EOL] continue [EOL] [EOL] status_url = provider . url ( ) or url_for ( [string] , sha = commit_hash , task_id = self . context . task_id , _external = True ) [EOL] build_status = BuildStatus ( bitbucket , self . context . source [ [string] ] [ [string] ] , commit_hash , [string] . format ( provider_name ) , status_url ) [EOL] self . _update_build_status ( build_status , [string] , [string] . format ( provider_name ) ) [EOL] succeed , output = provider . deploy ( ) [EOL] logger . info ( [string] , provider_name , [string] if succeed else [string] , output ) [EOL] [EOL] state = [string] if succeed else [string] [EOL] self . _update_build_status ( build_status , state , [string] . format ( provider_name , state . lower ( ) ) ) [EOL] if succeed : [EOL] run_after_deploy = True [EOL] if slack_webhook and slack_webhook . on_success == [string] : [EOL] trigger_slack_webhook ( slack_webhook . webhooks , self . context , provider , True ) [EOL] else : [EOL] if slack_webhook and slack_webhook . on_failure == [string] : [EOL] trigger_slack_webhook ( slack_webhook . webhooks , self . context , provider , False ) [EOL] [EOL] [comment] [EOL] if not run_after_deploy or not self . spec . after_deploy : [EOL] return [EOL] [EOL] for script in self . spec . after_deploy : [EOL] exit_code , output = run_command ( script , shell = True ) [EOL] logger . info ( [string] , script , exit_code , output ) [EOL] [EOL] def _update_build_status ( self , build_status , state , description = None ) : [EOL] try : [EOL] build_status . update ( state , description = description ) [EOL] except BitbucketAPIError : [EOL] logger . exception ( [string] ) [EOL] sentry . captureException ( ) [EOL] [EOL] [EOL] def trigger_slack_webhook ( webhooks , context , provider , succeed ) : [EOL] actor = context . actor [EOL] if succeed : [EOL] title = [string] . format ( provider . name ) [EOL] color = [string] [EOL] else : [EOL] title = [string] . format ( provider . name ) [EOL] color = [string] [EOL] fields = [ ] [EOL] fields . append ( { [string] : [string] , [string] : [string] . format ( repo = context . repository ) , [string] : True , } ) [EOL] if context . type == [string] : [EOL] fields . append ( { [string] : [string] , [string] : [string] . format ( repo = context . repository , tag = context . source [ [string] ] [ [string] ] ) , [string] : True , } ) [EOL] else : [EOL] fields . append ( { [string] : [string] , [string] : [string] . format ( repo = context . repository , branch = context . source [ [string] ] [ [string] ] ) , [string] : True , } ) [EOL] if context . type in { [string] , [string] } : [EOL] fields . append ( { [string] : [string] , [string] : [string] . format ( repo = context . repository , sha = context . source [ [string] ] [ [string] ] , ) , [string] : False } ) [EOL] attachment = { [string] : title , [string] : title , [string] : color , [string] : fields , [string] : context . repo_name , [string] : int ( time . time ( ) ) , [string] : actor [ [string] ] , [string] : actor [ [string] ] [ [string] ] [ [string] ] , [string] : actor [ [string] ] [ [string] ] [ [string] ] , } [EOL] if context . type in { [string] , [string] } : [EOL] attachment [ [string] ] = context . message [EOL] payload = { [string] : [ attachment ] } [EOL] session = requests . Session ( ) [EOL] for webhook in webhooks : [EOL] logger . info ( [string] , webhook ) [EOL] res = session . post ( webhook , json = payload , timeout = [number] ) [EOL] try : [EOL] res . raise_for_status ( ) [EOL] except requests . RequestException : [EOL] logger . exception ( [string] , webhook ) [EOL] sentry . captureException ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]$ 0 $typing.Optional[typing.Type[typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Type[typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]]]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]$ 0 $typing.Optional[typing.Type[typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $badwolf.bitbucket.BuildStatus$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $badwolf.bitbucket.BuildStatus$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $badwolf.bitbucket.BuildStatus$ 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[badwolf.deploy.providers.pypi.PypiProvider,badwolf.deploy.providers.script.ScriptProvider]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] class Provider ( object ) : [EOL] name = [string] [EOL] [EOL] def __init__ ( self , working_dir , config , context ) : [EOL] self . working_dir = working_dir [EOL] self . config = config [EOL] self . context = context [EOL] [EOL] def is_usable ( self ) : [EOL] return True [EOL] [EOL] def deploy ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def url ( self ) : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . deploy . providers import Provider [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PypiProvider ( Provider ) : [EOL] name = [string] [EOL] [EOL] def deploy ( self ) : [EOL] username = self . config . get ( [string] ) [EOL] password = self . config . get ( [string] ) [EOL] repository = self . config . get ( [string] ) [EOL] command = [ [string] , [string] , ] [EOL] if repository : [EOL] command . extend ( [ [string] , repository , [string] , repository ] ) [EOL] if username : [EOL] command . extend ( [ [string] , username ] ) [EOL] if password : [EOL] command . extend ( [ [string] , password , ] ) [EOL] command . extend ( [ [string] , self . config [ [string] ] ] ) [EOL] exit_code , output = run_command ( command , include_errors = True , cwd = self . working_dir , env = self . context . environment ) [EOL] return exit_code == [number] , output [EOL] [EOL] def url ( self ) : [EOL] pkg_name = self . config . get ( [string] , self . context . repo_name ) [EOL] return [string] . format ( self . config [ [string] ] , pkg_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . deploy . providers import Provider [EOL] [EOL] [EOL] class ScriptProvider ( Provider ) : [EOL] name = [string] [EOL] [EOL] def deploy ( self ) : [EOL] exit_codes , outputs = [ ] , [ ] [EOL] for script in self . config . script : [EOL] exit_code , output = run_command ( script , include_errors = True , cwd = self . working_dir , shell = True , env = self . context . environment ) [EOL] exit_codes . append ( exit_code ) [EOL] outputs . append ( output ) [EOL] return all ( code == [number] for code in exit_codes ) , [string] . join ( outputs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Optional , List [EOL] import xml [EOL] import typing [EOL] import os [EOL] from xml . etree import ElementTree [EOL] [EOL] [EOL] def in_path ( name ) : [EOL] [docstring] [EOL] for dirname in os . environ [ [string] ] . split ( os . pathsep ) : [EOL] if os . path . exists ( os . path . join ( dirname , name ) ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def npm_exists ( name , cwd = None ) : [EOL] [docstring] [EOL] cwd = cwd or os . getcwd ( ) [EOL] path = os . path . join ( cwd , [string] , [string] , name ) [EOL] return os . path . exists ( path ) [EOL] [EOL] [EOL] def parse_checkstyle ( xml ) : [EOL] tree = ElementTree . fromstring ( xml ) [EOL] for f in tree . iterfind ( [string] ) : [EOL] filename = f . get ( [string] ) [EOL] for err in f . iterfind ( [string] ) : [EOL] severity = err . get ( [string] ) [EOL] if severity == [string] : [EOL] continue [EOL] [EOL] line = err . get ( [string] ) [EOL] message = err . get ( [string] ) [EOL] if [string] in line : [EOL] lines = [ int ( x ) for x in line . split ( [string] ) if x != [string] ] [EOL] else : [EOL] if line == [string] : [EOL] continue [EOL] lines = [ int ( line ) ] [EOL] [EOL] for line in lines : [EOL] yield ( filename , line , message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] class Problem ( object ) : [EOL] def __init__ ( self , filename , line , message , linter , is_error = True , has_line_change = False ) : [EOL] self . filename = filename [EOL] self . line = line [EOL] self . message = message [EOL] self . linter = linter [EOL] self . is_error = is_error [EOL] self . has_line_change = has_line_change [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . __str__ ( ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . filename , self . line , self . message ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . filename , self . line , self . message ) [EOL] [EOL] [EOL] class Problems ( object ) : [EOL] [docstring] [EOL] REPORT_CHANGES_RANGE = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _items = set ( ) [EOL] self . _changes = None [EOL] [EOL] def add ( self , problem ) : [EOL] self . _items . add ( problem ) [EOL] [EOL] def set_changes ( self , changes ) : [EOL] self . _changes = changes [EOL] [EOL] def limit_to_changes ( self ) : [EOL] changes = self . _changes [EOL] if not changes : [EOL] return [EOL] [EOL] def should_keep ( item ) : [EOL] keep = False [EOL] for patched_file in changes : [EOL] if patched_file . path != item . filename : [EOL] continue [EOL] [EOL] for hunk in patched_file : [EOL] if not hunk . is_valid ( ) : [EOL] continue [EOL] [EOL] for line in hunk . target_lines ( ) : [EOL] if abs ( item . line - line . target_line_no ) <= self . REPORT_CHANGES_RANGE : [EOL] if item . line == line . target_line_no : [EOL] item . has_line_change = line . is_added [EOL] if line . is_context : [EOL] item . line = line . source_line_no [EOL] keep = True [EOL] if keep : [EOL] break [EOL] if keep : [EOL] break [EOL] if keep : [EOL] break [EOL] return keep [EOL] [EOL] self . _items = [ item for item in self . _items if should_keep ( item ) ] [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _items ) [EOL] [EOL] def __iter__ ( self ) : [EOL] for item in self . _items : [EOL] yield item [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return self . _items [ key ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Type , List , Set , Dict , Any , Tuple [EOL] import badwolf [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] from unidiff import UnidiffParseError [EOL] [EOL] from badwolf . extensions import bitbucket , sentry [EOL] from badwolf . bitbucket import PullRequest , BitbucketAPIError , BuildStatus [EOL] from badwolf . lint import Problems [EOL] from badwolf . lint . linters . eslint import ESLinter [EOL] from badwolf . lint . linters . flake8 import Flake8Linter [EOL] from badwolf . lint . linters . pycodestyle import PyCodeStyleLinter [EOL] from badwolf . lint . linters . csslint import CSSLinter [EOL] from badwolf . lint . linters . shellcheck import ShellCheckLinter [EOL] from badwolf . lint . linters . jsonlint import JSONLinter [EOL] from badwolf . lint . linters . yamllint import YAMLLinter [EOL] from badwolf . lint . linters . bandit import BanditLinter [EOL] from badwolf . lint . linters . rstlint import RestructuredTextLinter [EOL] from badwolf . lint . linters . pylint import PylintLinter [EOL] from badwolf . lint . linters . sasslint import SassLinter [EOL] from badwolf . lint . linters . stylelint import StyleLinter [EOL] from badwolf . lint . linters . mypy import MypyLinter [EOL] from badwolf . lint . linters . hadolint import HadoLinter [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class LintProcessor ( object ) : [EOL] LINTERS = { [string] : ESLinter , [string] : Flake8Linter , [string] : PyCodeStyleLinter , [string] : PyCodeStyleLinter , [string] : CSSLinter , [string] : ShellCheckLinter , [string] : JSONLinter , [string] : YAMLLinter , [string] : BanditLinter , [string] : RestructuredTextLinter , [string] : PylintLinter , [string] : SassLinter , [string] : StyleLinter , [string] : MypyLinter , [string] : HadoLinter , } [EOL] [EOL] def __init__ ( self , context , spec , working_dir = None ) : [EOL] self . context = context [EOL] self . spec = spec [EOL] self . working_dir = working_dir or context . clone_path [EOL] self . problems = Problems ( ) [EOL] self . pr = PullRequest ( bitbucket , context . repository ) [EOL] commit_hash = context . source [ [string] ] [ [string] ] [EOL] self . build_status = BuildStatus ( bitbucket , context . source [ [string] ] [ [string] ] , commit_hash , [string] , [string] . format ( context . repository , context . pr_id ) ) [EOL] [EOL] def load_changes ( self ) : [EOL] try : [EOL] changes = self . pr . diff ( self . context . pr_id ) [EOL] except ( BitbucketAPIError , UnidiffParseError ) : [EOL] logger . exception ( [string] ) [EOL] sentry . captureException ( ) [EOL] return [EOL] [EOL] self . problems . set_changes ( changes ) [EOL] return changes [EOL] [EOL] def process ( self ) : [EOL] if not self . spec . linters : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] logger . info ( [string] ) [EOL] patch = self . load_changes ( ) [EOL] if not patch : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] lint_files = patch . added_files + patch . modified_files [EOL] if not lint_files : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] self . update_build_status ( [string] , [string] ) [EOL] files = [ f . path for f in lint_files ] [EOL] self . _execute_linters ( files ) [EOL] [EOL] total_problems = len ( self . problems ) [EOL] self . problems . limit_to_changes ( ) [EOL] in_diff_problems = len ( self . problems ) [EOL] [EOL] [comment] [EOL] submitted_problems , fixed_problems = self . _report ( ) [EOL] if total_problems > [number] : [EOL] if in_diff_problems == total_problems : [EOL] description = [string] . format ( total_problems ) [EOL] else : [EOL] description = [string] . format ( total_problems ) [EOL] description += [string] . format ( in_diff_problems ) [EOL] if submitted_problems > [number] : [EOL] description += [string] . format ( submitted_problems ) [EOL] if fixed_problems > [number] : [EOL] description += [string] . format ( fixed_problems ) [EOL] else : [EOL] description = [string] [EOL] [EOL] has_error = any ( p for p in self . problems if p . is_error ) [EOL] if has_error : [EOL] logger . info ( [string] , description ) [EOL] self . update_build_status ( [string] , description ) [EOL] else : [EOL] logger . info ( [string] , description ) [EOL] self . update_build_status ( [string] , description ) [EOL] [EOL] def _execute_linters ( self , files ) : [EOL] for linter_option in self . spec . linters : [EOL] name = linter_option . name [EOL] linter_cls = self . LINTERS . get ( name ) [EOL] if not linter_cls : [EOL] logger . info ( [string] , name ) [EOL] continue [EOL] [EOL] linter = linter_cls ( self . working_dir , self . problems , linter_option ) [EOL] if not linter . is_usable ( ) : [EOL] logger . info ( [string] , name ) [EOL] continue [EOL] [EOL] logger . info ( [string] , name ) [EOL] linter . execute ( files ) [EOL] [EOL] def _report ( self ) : [EOL] try : [EOL] comments = self . pr . all_comments ( self . context . pr_id ) [EOL] except BitbucketAPIError : [EOL] logger . exception ( [string] ) [EOL] sentry . captureException ( ) [EOL] comments = [ ] [EOL] [EOL] existing_comments_ids = { } [EOL] for comment in comments : [EOL] inline = comment . get ( [string] ) [EOL] if not inline : [EOL] continue [EOL] [EOL] raw = comment [ [string] ] [ [string] ] [EOL] if not raw . startswith ( [string] ) : [EOL] continue [EOL] filename = inline [ [string] ] [EOL] line = inline [ [string] ] or inline [ [string] ] [EOL] if line is None : [EOL] continue [EOL] existing_comments_ids [ ( filename , line , raw ) ] = comment [ [string] ] [EOL] [EOL] if len ( self . problems ) == [number] : [EOL] return [number] , [number] [EOL] [EOL] lint_comments = set ( ) [EOL] problem_count = [number] [EOL] for problem in self . problems : [EOL] content = [string] . format ( problem . linter , problem . message ) [EOL] comment_tuple = ( problem . filename , problem . line , content ) [EOL] lint_comments . add ( comment_tuple ) [EOL] if comment_tuple in existing_comments_ids : [EOL] continue [EOL] [EOL] if problem_count >= [number] : [EOL] [comment] [EOL] break [EOL] comment_kwargs = { [string] : problem . filename , } [EOL] if problem . has_line_change : [EOL] comment_kwargs [ [string] ] = problem . line [EOL] else : [EOL] comment_kwargs [ [string] ] = problem . line [EOL] try : [EOL] self . pr . comment ( self . context . pr_id , content , ** comment_kwargs ) [EOL] except BitbucketAPIError : [EOL] logger . exception ( [string] ) [EOL] sentry . captureException ( ) [EOL] else : [EOL] problem_count += [number] [EOL] [EOL] logger . info ( [string] , len ( self . problems ) , problem_count ) [EOL] [EOL] outdated_cleaned = [number] [EOL] outdated_comments = set ( existing_comments_ids . keys ( ) ) - lint_comments [EOL] logger . info ( [string] , len ( outdated_comments ) ) [EOL] for comment in outdated_comments : [EOL] [comment] [EOL] try : [EOL] self . pr . delete_comment ( self . context . pr_id , existing_comments_ids [ comment ] ) [EOL] outdated_cleaned += [number] [EOL] except BitbucketAPIError : [EOL] logger . exception ( [string] ) [EOL] sentry . captureException ( ) [EOL] return problem_count , outdated_cleaned [EOL] [EOL] def update_build_status ( self , state , description = None ) : [EOL] try : [EOL] self . build_status . update ( state , description = description ) [EOL] except BitbucketAPIError : [EOL] logger . exception ( [string] ) [EOL] sentry . captureException ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $badwolf.lint.Problems$ 0 0 0 0 0 0 0 $badwolf.bitbucket.PullRequest$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $badwolf.bitbucket.BuildStatus$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.list$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Tuple[unknown,unknown,builtins.str]$ 0 0 0 $typing.Tuple[unknown,unknown,builtins.str]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import os [EOL] import re [EOL] import sys [EOL] import logging [EOL] import fnmatch [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Linter ( object ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def __init__ ( self , working_dir , problems , options = None ) : [EOL] self . working_dir = working_dir [EOL] self . problems = problems [EOL] self . options = options or { } [EOL] [EOL] def is_usable ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def match_file ( self , filename ) : [EOL] [docstring] [EOL] pattern = self . options . get ( [string] ) or self . default_pattern [EOL] if not pattern : [EOL] return True [EOL] [EOL] globs = pattern . split ( ) [EOL] for glob in globs : [EOL] if fnmatch . fnmatch ( filename , glob ) : [EOL] [comment] [EOL] return True [EOL] try : [EOL] if re . match ( pattern , filename , re . I ) : [EOL] [comment] [EOL] return True [EOL] except re . error : [EOL] pass [EOL] return False [EOL] [EOL] def lint_files ( self , files ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def execute ( self , files ) : [EOL] [docstring] [EOL] matched_files = [ f for f in files if self . match_file ( f ) ] [EOL] if not matched_files : [EOL] logger . info ( [string] , self . name ) [EOL] return [EOL] [EOL] logger . info ( [string] , self . name , len ( matched_files ) ) [EOL] for problem in self . lint_files ( matched_files ) : [EOL] self . problems . add ( problem ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . name ) [EOL] [EOL] def _relativize_filename ( self , filename ) : [EOL] if not os . path . isabs ( filename ) : [EOL] return filename [EOL] [EOL] old = self . working_dir [EOL] if not old . endswith ( os . path . sep ) : [EOL] old = [string] . format ( old , os . path . sep ) [EOL] return filename . replace ( old , [string] ) [EOL] [EOL] [EOL] class PythonLinter ( Linter ) : [EOL] default_pattern = [string] [EOL] [EOL] @ property def python_name ( self ) : [EOL] current_python = [string] . format ( sys . version_info . major , sys . version_info . minor ) [EOL] python_version = self . options . get ( [string] , current_python ) [EOL] return [string] . format ( python_version ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import os [EOL] import logging [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import PythonLinter [EOL] from badwolf . lint . utils import in_path [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class MypyLinter ( PythonLinter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] if not in_path ( [string] ) : [EOL] return False [EOL] [EOL] [comment] [EOL] python_version = self . python_name [ [number] : ] [EOL] major , * _ = python_version . split ( [string] , [number] ) [EOL] if int ( major ) < [number] : [EOL] return False [EOL] return True [EOL] [EOL] def lint_files ( self , files ) : [EOL] command = [ self . python_name , [string] , [string] , [string] , [string] , ] [EOL] if not self . _is_ignore_missing_imports_configured ( ) : [EOL] command . append ( [string] ) [EOL] command += files [EOL] _ , output = run_command ( command , split = True , include_errors = True , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] for line in output : [EOL] try : [EOL] filename , line , level , message = self . _parse_line ( line ) [EOL] except ValueError : [EOL] continue [EOL] if level == [string] : [EOL] continue [EOL] is_error = level == [string] [EOL] yield Problem ( filename , line , message , self . name , is_error = is_error ) [EOL] [EOL] def _parse_line ( self , line ) : [EOL] [docstring] [EOL] parts = line . split ( [string] , [number] ) [EOL] return parts [ [number] ] , int ( parts [ [number] ] ) , parts [ [number] ] . strip ( ) , parts [ [number] ] . strip ( ) [EOL] [EOL] def _is_ignore_missing_imports_configured ( self ) : [EOL] files = [ os . path . join ( self . working_dir , [string] ) , os . path . join ( self . working_dir , [string] ) , ] [EOL] for path in files : [EOL] try : [EOL] with open ( path , [string] , encoding = [string] ) as f : [EOL] config = f . read ( ) [EOL] except OSError : [EOL] continue [EOL] if [string] in config : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Pattern , Any , List [EOL] import typing [EOL] import os [EOL] import re [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import Linter [EOL] from badwolf . lint . utils import in_path , npm_exists [EOL] [EOL] [EOL] _LINE_RE = re . compile ( [string] , re . I ) [EOL] [EOL] [EOL] class JSONLinter ( Linter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) or npm_exists ( [string] , self . working_dir ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] for file in files : [EOL] command = self . create_command ( file ) [EOL] _ , output = run_command ( command , split = True , include_errors = True , cwd = self . working_dir ) [EOL] if not output : [EOL] continue [EOL] [EOL] for line in output : [EOL] parsed = self . _parse_line ( line ) [EOL] if not parsed : [EOL] continue [EOL] [EOL] filename , line , message = parsed [EOL] yield Problem ( filename , line , message , self . name ) [EOL] [EOL] def create_command ( self , file ) : [EOL] cmd = [string] [EOL] if npm_exists ( [string] , self . working_dir ) : [EOL] cmd = os . path . join ( self . working_dir , [string] , [string] , [string] ) [EOL] command = [ cmd , [string] , [string] , file ] [EOL] return command [EOL] [EOL] def _parse_line ( self , line ) : [EOL] match = _LINE_RE . match ( line ) [EOL] if not match : [EOL] return [EOL] [EOL] return match . group ( [number] ) , int ( match . group ( [number] ) ) , match . group ( [number] ) . strip ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] from badwolf . utils import to_text , run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import PythonLinter [EOL] from badwolf . lint . utils import in_path [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PylintLinter ( PythonLinter ) : [EOL] name = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] command = [ self . python_name , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] command += files [EOL] _ , output = run_command ( command , split = True , include_errors = True , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] for line in output : [EOL] parsed = self . _parse_line ( to_text ( line ) ) [EOL] if parsed is None : [EOL] continue [EOL] [EOL] filename , line , message = parsed [EOL] yield Problem ( filename , line , message , self . name ) [EOL] [EOL] def _parse_line ( self , line ) : [EOL] parts = line . split ( [string] , [number] ) [EOL] if len ( parts ) != [number] : [EOL] return [EOL] [EOL] message = parts [ [number] ] . strip ( ) [EOL] try : [EOL] return parts [ [number] ] , int ( parts [ [number] ] ) , message [EOL] except ValueError : [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import logging [EOL] import os [EOL] import logging [EOL] [EOL] import restructuredtext_lint as rstlinter [EOL] [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import Linter [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class RestructuredTextLinter ( Linter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def lint_files ( self , files ) : [EOL] cwd = os . getcwd ( ) [EOL] os . chdir ( self . working_dir ) [EOL] for path in files : [EOL] errors = rstlinter . lint_file ( path , [string] ) [EOL] for error in errors : [EOL] msg = [string] . format ( error . type , error . message ) [EOL] yield Problem ( error . source , error . line , msg , self . name ) [EOL] os . chdir ( cwd ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] from typing import List [EOL] import csv [EOL] import typing [EOL] import logging [EOL] import os [EOL] import io [EOL] import csv [EOL] import logging [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import Linter [EOL] from badwolf . lint . utils import in_path [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class BanditLinter ( Linter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] command = [ [string] , [string] , [string] ] [EOL] ini_conf = os . path . join ( self . working_dir , [string] ) [EOL] if os . path . exists ( ini_conf ) : [EOL] command . extend ( [ [string] , [string] ] ) [EOL] command += files [EOL] _ , output = run_command ( command , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] reader = csv . DictReader ( io . StringIO ( output ) ) [EOL] for row in reader : [EOL] msg = [string] . format ( row [ [string] ] , row [ [string] ] ) [EOL] is_error = row [ [string] ] != [string] [EOL] yield Problem ( row [ [string] ] , int ( row [ [string] ] ) , msg , self . name , is_error ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $csv.DictReader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $csv.DictReader$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import Linter [EOL] from badwolf . lint . utils import in_path , parse_checkstyle [EOL] [EOL] [EOL] class ShellCheckLinter ( Linter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] command = self . create_command ( files ) [EOL] _ , output = run_command ( command , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] problems = parse_checkstyle ( output ) [EOL] for filename , line , message in problems : [EOL] yield Problem ( self . _relativize_filename ( filename ) , line , message , self . name ) [EOL] [EOL] def create_command ( self , files ) : [EOL] command = [ [string] , [string] , [string] ] [EOL] command += files [EOL] return command [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import Linter [EOL] from badwolf . lint . utils import in_path , npm_exists , parse_checkstyle [EOL] [EOL] [EOL] class CSSLinter ( Linter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) or npm_exists ( [string] , self . working_dir ) [EOL] [EOL] def match_file ( self , filename ) : [EOL] [comment] [EOL] if filename . lower ( ) . endswith ( [string] ) : [EOL] return False [EOL] return super ( CSSLinter , self ) . match_file ( filename ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] command = self . create_command ( files ) [EOL] _ , output = run_command ( command , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] problems = parse_checkstyle ( output ) [EOL] for filename , line , message in problems : [EOL] yield Problem ( self . _relativize_filename ( filename ) , line , message , self . name ) [EOL] [EOL] def create_command ( self , files ) : [EOL] cmd = [string] [EOL] if npm_exists ( [string] , self . working_dir ) : [EOL] cmd = os . path . join ( self . working_dir , [string] , [string] , [string] ) [EOL] command = [ cmd , [string] ] [EOL] command += files [EOL] return command [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import PythonLinter [EOL] from badwolf . lint . utils import in_path [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PyCodeStyleLinter ( PythonLinter ) : [EOL] name = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] command = [ self . python_name , [string] , [string] ] [EOL] command += files [EOL] _ , output = run_command ( command , split = True , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] for line in output : [EOL] filename , line , message = self . _parse_line ( line ) [EOL] yield Problem ( filename , line , message , self . name ) [EOL] [EOL] def _parse_line ( self , line ) : [EOL] [docstring] [EOL] parts = line . split ( [string] , [number] ) [EOL] message = parts [ [number] ] . strip ( ) [EOL] return parts [ [number] ] , int ( parts [ [number] ] ) , message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import Linter [EOL] from badwolf . lint . utils import in_path , npm_exists , parse_checkstyle [EOL] [EOL] [EOL] class SassLinter ( Linter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) or npm_exists ( [string] , self . working_dir ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] command = self . create_command ( files ) [EOL] _ , output = run_command ( command , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] problems = parse_checkstyle ( output ) [EOL] for filename , line , message in problems : [EOL] yield Problem ( self . _relativize_filename ( filename ) , line , message , self . name ) [EOL] [EOL] def create_command ( self , files ) : [EOL] cmd = [string] [EOL] if npm_exists ( [string] , self . working_dir ) : [EOL] cmd = os . path . join ( self . working_dir , [string] , [string] , [string] ) [EOL] command = [ cmd , [string] , [string] , [string] ] [EOL] command += files [EOL] return command [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] import json [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import Linter [EOL] from badwolf . lint . utils import in_path , npm_exists [EOL] [EOL] [EOL] class StyleLinter ( Linter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) or npm_exists ( [string] , self . working_dir ) [EOL] [EOL] def match_file ( self , filename ) : [EOL] [comment] [EOL] if filename . lower ( ) . endswith ( [string] ) : [EOL] return False [EOL] return super ( StyleLinter , self ) . match_file ( filename ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] command = self . create_command ( files ) [EOL] _ , output = run_command ( command , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] try : [EOL] problems = json . loads ( output ) [EOL] except ValueError : [EOL] raise StopIteration ( ) [EOL] [EOL] for source in problems : [EOL] for problem in source [ [string] ] : [EOL] yield Problem ( self . _relativize_filename ( source [ [string] ] ) , problem [ [string] ] , problem [ [string] ] , self . name ) [EOL] [EOL] def create_command ( self , files ) : [EOL] cmd = [string] [EOL] if npm_exists ( [string] , self . working_dir ) : [EOL] cmd = os . path . join ( self . working_dir , [string] , [string] , [string] ) [EOL] command = [ cmd , [string] , [string] , [string] ] [EOL] command += files [EOL] return command [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import Linter [EOL] from badwolf . lint . utils import in_path [EOL] [EOL] [EOL] class HadoLinter ( Linter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] for file in files : [EOL] command = [ [string] , file ] [EOL] _ , output = run_command ( command , split = True , include_errors = True , cwd = self . working_dir , env = { [string] : os . getenv ( [string] , [string] ) , [string] : os . getenv ( [string] , [string] ) } ) [EOL] if not output : [EOL] continue [EOL] [EOL] for line in output : [EOL] parsed = self . _parse_line ( line ) [EOL] if not parsed : [EOL] continue [EOL] [EOL] filename , line , message = parsed [EOL] yield Problem ( filename , line , message , self . name ) [EOL] [EOL] def _parse_line ( self , line ) : [EOL] parts = line . split ( [string] , [number] ) [EOL] if len ( parts ) != [number] : [EOL] return [EOL] [EOL] location , message = parts [EOL] if [string] in location : [EOL] filename , line = location . split ( [string] , [number] ) [EOL] line = int ( line ) [EOL] else : [EOL] filename = location [EOL] line = [number] [EOL] return filename , line , message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import configparser [EOL] import typing [EOL] import logging [EOL] import os [EOL] import logging [EOL] import configparser [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import PythonLinter [EOL] from badwolf . lint . utils import in_path [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Flake8Linter ( PythonLinter ) : [EOL] name = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] config = self . _read_flake8_config ( ) [EOL] import_order_style = config . get ( [string] , [string] ) [EOL] command = [ self . python_name , [string] , [string] , [string] , import_order_style , [string] , [string] ] [EOL] command += files [EOL] _ , output = run_command ( command , split = True , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] for line in output : [EOL] filename , line , message = self . _parse_line ( line ) [EOL] yield Problem ( filename , line , message , self . name ) [EOL] [EOL] def _parse_line ( self , line ) : [EOL] [docstring] [EOL] parts = line . split ( [string] , [number] ) [EOL] if len ( parts ) == [number] : [EOL] message = parts [ [number] ] . strip ( ) [EOL] else : [EOL] message = parts [ [number] ] . strip ( ) [EOL] return parts [ [number] ] , int ( parts [ [number] ] ) , message [EOL] [EOL] def _read_flake8_config ( self ) : [EOL] files = [ os . path . join ( self . working_dir , [string] ) , os . path . join ( self . working_dir , [string] ) , ] [EOL] parser = configparser . RawConfigParser ( ) [EOL] try : [EOL] parser . read ( files ) [EOL] except configparser . ParsingError : [EOL] logger . exception ( [string] , files ) [EOL] [EOL] if parser . has_section ( [string] ) : [EOL] return dict ( parser . items ( [string] ) ) [EOL] return { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 0 0 $configparser.RawConfigParser$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 0 0 $configparser.RawConfigParser$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import logging [EOL] [EOL] from badwolf . utils import run_command [EOL] from badwolf . lint import Problem [EOL] from badwolf . lint . linters import Linter [EOL] from badwolf . lint . utils import in_path [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class YAMLLinter ( Linter ) : [EOL] name = [string] [EOL] default_pattern = [string] [EOL] [EOL] def is_usable ( self ) : [EOL] return in_path ( [string] ) [EOL] [EOL] def lint_files ( self , files ) : [EOL] command = [ [string] , [string] , [string] ] [EOL] command += files [EOL] _ , output = run_command ( command , split = True , cwd = self . working_dir ) [EOL] if not output : [EOL] raise StopIteration ( ) [EOL] [EOL] for line in output : [EOL] filename , line , message = self . _parse_line ( line ) [EOL] is_error = not message . startswith ( [string] ) [EOL] yield Problem ( filename , line , message , self . name , is_error ) [EOL] [EOL] def _parse_line ( self , line ) : [EOL] parts = line . split ( [string] , [number] ) [EOL] message = parts [ [number] ] . strip ( ) [EOL] return parts [ [number] ] , int ( parts [ [number] ] ) , message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0
	0
[comment] [EOL] from typing import Any [EOL] import flask [EOL] import badwolf [EOL] import logging [EOL] import typing [EOL] import logging [EOL] [EOL] from flask import Blueprint , request , current_app , redirect , jsonify [EOL] [EOL] from badwolf . bitbucket import Bitbucket , BitbucketAPIError , OAuth2Dispatcher [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] blueprint = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def redirect_to_bitbucket ( ) : [EOL] oauth = OAuth2Dispatcher ( current_app . config [ [string] ] , current_app . config [ [string] ] , ) [EOL] auth_url = oauth . get_authorization_url ( ) [EOL] return redirect ( auth_url ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def bitbucket_oauth_callback ( ) : [EOL] oauth = OAuth2Dispatcher ( current_app . config [ [string] ] , current_app . config [ [string] ] , ) [EOL] code = request . args . get ( [string] ) [EOL] try : [EOL] oauth . grant_access_token ( code ) [EOL] except BitbucketAPIError : [EOL] return [string] [EOL] [EOL] bitbucket = Bitbucket ( oauth ) [EOL] data = bitbucket . get ( [string] ) [EOL] return jsonify ( data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any , List [EOL] import flask [EOL] import logging [EOL] import typing [EOL] import os [EOL] import logging [EOL] [EOL] import deansi [EOL] from flask import Blueprint , current_app , send_from_directory , request , abort , Response [EOL] from docker import DockerClient [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] blueprint = Blueprint ( [string] , __name__ ) [EOL] [EOL] FOLLOW_LOG_JS = [string] [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def build_log ( sha ) : [EOL] task_id = request . args . get ( [string] ) [EOL] log_dir = os . path . join ( current_app . config [ [string] ] , sha ) [EOL] [comment] [EOL] if os . path . exists ( os . path . join ( log_dir , [string] ) ) : [EOL] return send_from_directory ( log_dir , [string] ) [EOL] [EOL] if not task_id : [EOL] abort ( [number] ) [EOL] [EOL] [comment] [EOL] log_dir = os . path . join ( log_dir , task_id ) [EOL] if os . path . exists ( os . path . join ( log_dir , [string] ) ) : [EOL] return send_from_directory ( log_dir , [string] ) [EOL] [EOL] [comment] [EOL] docker = DockerClient ( base_url = current_app . config [ [string] ] , timeout = current_app . config [ [string] ] , version = [string] , ) [EOL] containers = docker . containers . list ( filters = dict ( status = [string] , label = [string] . format ( task_id ) , ) ) [EOL] if not containers : [EOL] abort ( [number] ) [EOL] [EOL] [comment] [EOL] container = containers [ [number] ] [EOL] [EOL] def _streaming_gen ( ) : [EOL] yield [string] . format ( deansi . styleSheet ( ) ) [EOL] yield FOLLOW_LOG_JS [EOL] yield [string] [EOL] buffer = [ ] [EOL] for log in container . logs ( stdout = True , stderr = True , stream = True , follow = True ) : [EOL] char = str ( log ) [EOL] buffer . append ( char ) [EOL] if char == [string] : [EOL] yield deansi . deansi ( [string] . join ( buffer ) ) [EOL] buffer = [ ] [EOL] if buffer : [EOL] yield deansi . deansi ( [string] . join ( buffer ) ) [EOL] yield [string] [EOL] [EOL] return Response ( _streaming_gen ( ) , mimetype = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Union , List , Dict , Optional , Any , Literal [EOL] import typing [EOL] import logging [EOL] import badwolf [EOL] import flask [EOL] import typing_extensions [EOL] import json [EOL] import logging [EOL] [EOL] from docker import DockerClient [EOL] from flask import Blueprint , request , current_app , url_for , jsonify [EOL] [EOL] from badwolf . context import Context [EOL] from badwolf . tasks import start_pipeline , check_pr_mergeable [EOL] from badwolf . extensions import bitbucket , sentry [EOL] from badwolf . bitbucket import BitbucketAPIError , PullRequest , BuildStatus , Hooks [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] blueprint = Blueprint ( [string] , __name__ ) [EOL] [EOL] _EVENT_HANDLERS = { } [EOL] _RUNNING_PIPELINES = { } [EOL] [EOL] [EOL] def register_event_handler ( event_key ) : [EOL] def register ( func ) : [EOL] _EVENT_HANDLERS [ event_key ] = func [EOL] return func [EOL] return register [EOL] [EOL] [EOL] def _cancel_outdated_pipelines ( context ) : [EOL] from docker . errors import NotFound , APIError [EOL] docker = DockerClient ( base_url = current_app . config [ [string] ] , timeout = current_app . config [ [string] ] , version = [string] , ) [EOL] containers = docker . containers . list ( filters = dict ( status = [string] , label = [string] . format ( context . repository ) , ) ) [EOL] if not containers : [EOL] return [EOL] [EOL] for container in containers : [EOL] labels = container . labels [EOL] if context . type == [string] : [EOL] continue [EOL] if context . pr_id and labels . get ( [string] ) != str ( context . pr_id ) : [EOL] continue [EOL] if context . type == [string] and labels . get ( [string] ) != context . source [ [string] ] [ [string] ] : [EOL] continue [EOL] [EOL] task_id = labels . get ( [string] ) [EOL] if not task_id : [EOL] continue [EOL] [EOL] future = _RUNNING_PIPELINES . get ( task_id ) [EOL] if not future or future . cancelled ( ) : [EOL] continue [EOL] [EOL] commit = labels [ [string] ] [EOL] if context . pr_id : [EOL] logger . info ( [string] , context . repository , context . pr_id , commit ) [EOL] else : [EOL] logger . info ( [string] , context . repository , commit ) [EOL] [comment] [EOL] try : [EOL] container . remove ( force = True ) [EOL] except NotFound : [EOL] pass [EOL] except APIError as exc : [EOL] if [string] not in exc . explanation : [EOL] raise [EOL] future . cancel ( ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def register_webhook ( user , repo ) : [EOL] full_name = [string] . format ( user , repo ) [EOL] webhook_url = url_for ( [string] , _external = True ) [EOL] hooks = Hooks ( bitbucket , full_name ) [EOL] existing_hooks = hooks . list ( ) [EOL] existing_urls = [ hook [ [string] ] for hook in existing_hooks [ [string] ] ] [EOL] if webhook_url in existing_urls : [EOL] return jsonify ( { [string] : [string] } ) [EOL] [EOL] hooks . add ( [string] , webhook_url , events = ( [string] , [string] , [string] , [string] , [string] , [string] , ) ) [EOL] return jsonify ( { [string] : [string] } ) , [number] [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def webhook_push ( ) : [EOL] provider = None [comment] [EOL] user_agent = request . headers . get ( [string] , [string] ) [EOL] if user_agent . startswith ( [string] ) : [EOL] [comment] [EOL] event_key = request . headers . get ( [string] ) [EOL] provider = [string] [EOL] else : [EOL] [comment] [EOL] event_key = request . headers . get ( [string] ) [EOL] provider = [string] [EOL] if not event_key : [EOL] return [string] , [number] [EOL] [EOL] payload = request . get_json ( force = True ) [EOL] logger . debug ( [string] , provider , event_key , json . dumps ( payload , ensure_ascii = False ) ) [EOL] if not payload : [EOL] return [string] [EOL] [EOL] [comment] [EOL] handler = _EVENT_HANDLERS . get ( event_key ) [EOL] if handler : [EOL] return handler ( payload ) or [string] [EOL] return [string] [EOL] [EOL] [EOL] @ register_event_handler ( [string] ) def handle_repo_push ( payload ) : [EOL] changes = payload [ [string] ] [ [string] ] [EOL] if not changes : [EOL] return [EOL] [EOL] repo = payload [ [string] ] [EOL] scm = repo [ [string] ] [EOL] if scm . lower ( ) != [string] : [EOL] logger . info ( [string] , scm ) [EOL] return [EOL] [EOL] for change in changes : [EOL] if not change [ [string] ] : [EOL] logger . info ( [string] ) [EOL] continue [EOL] [EOL] repo_name = repo [ [string] ] [EOL] push_type = change [ [string] ] [ [string] ] [EOL] rebuild = False [EOL] nocache = False [EOL] if push_type == [string] : [EOL] commit_hash = change [ [string] ] [ [string] ] [ [string] ] [EOL] commit_message = change [ [string] ] [ [string] ] [ [string] ] [EOL] elif push_type == [string] : [EOL] if not change [ [string] ] : [EOL] logger . warning ( [string] ) [EOL] continue [EOL] commit_hash = change [ [string] ] [ [number] ] [ [string] ] [EOL] commit_message = change [ [string] ] [ [number] ] [ [string] ] [EOL] msg_lower = commit_message . lower ( ) [EOL] if [string] in msg_lower : [EOL] logger . info ( [string] ) [EOL] continue [EOL] rebuild = [string] in msg_lower [EOL] nocache = [string] in msg_lower [EOL] else : [EOL] logger . error ( [string] , push_type ) [EOL] continue [EOL] [EOL] source = { [string] : { [string] : repo_name } , [string] : { [string] : change [ [string] ] [ [string] ] } , [string] : { [string] : commit_hash } } [EOL] context = Context ( repo_name , payload [ [string] ] , push_type , commit_message , source , rebuild = rebuild , nocache = nocache ) [EOL] try : [EOL] _cancel_outdated_pipelines ( context ) [EOL] except Exception : [EOL] sentry . captureException ( ) [EOL] future = start_pipeline . delay ( context ) [EOL] future . add_done_callback ( lambda fut : _RUNNING_PIPELINES . pop ( context . task_id , None ) ) [EOL] _RUNNING_PIPELINES [ context . task_id ] = future [EOL] if push_type == [string] : [EOL] check_pr_mergeable . delay ( context ) [EOL] [EOL] [EOL] @ register_event_handler ( [string] ) @ register_event_handler ( [string] ) def handle_pull_request ( payload ) : [EOL] repo = payload [ [string] ] [EOL] scm = repo [ [string] ] [EOL] if scm . lower ( ) != [string] : [EOL] logger . info ( [string] , scm ) [EOL] return [EOL] [EOL] pr = payload [ [string] ] [EOL] title = pr [ [string] ] [EOL] description = pr [ [string] ] or [string] [EOL] if [string] in title or [string] in description : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] if pr [ [string] ] != [string] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] title_lower = title . lower ( ) [EOL] desc_lower = description . lower ( ) [EOL] rebuild = [string] in title_lower or [string] in desc_lower [EOL] skip_lint = [string] in title_lower or [string] in desc_lower [EOL] [EOL] source = pr [ [string] ] [EOL] target = pr [ [string] ] [EOL] [EOL] context = Context ( repo [ [string] ] , payload [ [string] ] , [string] , title , source , target , rebuild = rebuild , pr_id = pr [ [string] ] , skip_lint = skip_lint ) [EOL] try : [EOL] _cancel_outdated_pipelines ( context ) [EOL] except Exception : [EOL] sentry . captureException ( ) [EOL] future = start_pipeline . delay ( context ) [EOL] future . add_done_callback ( lambda fut : _RUNNING_PIPELINES . pop ( context . task_id , None ) ) [EOL] _RUNNING_PIPELINES [ context . task_id ] = future [EOL] [EOL] [EOL] @ register_event_handler ( [string] ) def handle_pull_request_approved ( payload ) : [EOL] if not current_app . config [ [string] ] : [EOL] return [EOL] [EOL] repo = payload [ [string] ] [EOL] pr = payload [ [string] ] [EOL] pr_id = pr [ [string] ] [EOL] title = pr [ [string] ] . lower ( ) [EOL] description = ( pr [ [string] ] or [string] ) . lower ( ) [EOL] [EOL] for keyword in ( [string] , [string] , [string] ) : [EOL] if keyword in title or keyword in description : [EOL] logger . info ( [string] , keyword ) [EOL] return [EOL] [EOL] pull_request = PullRequest ( bitbucket , repo [ [string] ] ) [EOL] try : [EOL] pr_info = pull_request . get ( pr_id ) [EOL] except BitbucketAPIError as exc : [EOL] logger . exception ( [string] ) [EOL] if exc . code != [number] : [EOL] sentry . captureException ( ) [EOL] return [EOL] [EOL] if pr_info [ [string] ] != [string] : [EOL] return [EOL] [EOL] participants = pr_info [ [string] ] [EOL] approved_users = [ u for u in participants if u [ [string] ] ] [EOL] if len ( approved_users ) < current_app . config [ [string] ] : [EOL] return [EOL] [EOL] commit_hash = pr_info [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] build_status = BuildStatus ( bitbucket , pr_info [ [string] ] [ [string] ] [ [string] ] , commit_hash , [string] , url_for ( [string] , sha = commit_hash , _external = True ) ) [EOL] message = [string] . format ( pr_id , pr [ [string] ] ) [EOL] if description : [EOL] message += [string] . format ( pr [ [string] ] ) [EOL] try : [EOL] status = build_status . get ( ) [EOL] if status [ [string] ] == [string] : [EOL] pull_request . merge ( pr_id , message ) [EOL] except BitbucketAPIError as exc : [EOL] logger . exception ( [string] ) [EOL] if exc . code != [number] : [EOL] sentry . captureException ( ) [EOL] [EOL] [EOL] @ register_event_handler ( [string] ) def handle_repo_commit_comment ( payload ) : [EOL] comment = payload [ [string] ] [EOL] comment_content = comment [ [string] ] [ [string] ] . lower ( ) [EOL] [EOL] retry = [string] in comment_content [EOL] rebuild = [string] in comment_content [EOL] nocache = [string] in comment_content [EOL] if not ( retry or rebuild ) : [EOL] return [EOL] [EOL] commit_hash = payload [ [string] ] [ [string] ] [EOL] repo = payload [ [string] ] [EOL] repo_name = repo [ [string] ] [EOL] [EOL] context = Context ( repo_name , payload [ [string] ] , [string] , payload [ [string] ] [ [string] ] , { [string] : { [string] : repo_name } , [string] : { [string] : [string] } , [string] : { [string] : commit_hash } , } , rebuild = rebuild , nocache = nocache , ) [EOL] start_pipeline . delay ( context ) [EOL] [EOL] [EOL] @ register_event_handler ( [string] ) def handle_pull_request_comment ( payload ) : [EOL] comment = payload [ [string] ] [EOL] comment_content = comment [ [string] ] [ [string] ] . lower ( ) [EOL] retry = [string] in comment_content [EOL] rebuild = [string] in comment_content [EOL] nocache = [string] in comment_content [EOL] if not ( retry or rebuild ) : [EOL] return [EOL] [EOL] repo = payload [ [string] ] [EOL] pr = payload [ [string] ] [EOL] title = pr [ [string] ] [EOL] [EOL] if pr [ [string] ] != [string] : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] title_lower = title . lower ( ) [EOL] description = pr [ [string] ] or [string] [EOL] desc_lower = description . lower ( ) [EOL] skip_lint = [string] in title_lower or [string] in desc_lower [EOL] source = pr [ [string] ] [EOL] target = pr [ [string] ] [EOL] [EOL] context = Context ( repo [ [string] ] , payload [ [string] ] , [string] , title , source , target , rebuild = rebuild , pr_id = pr [ [string] ] , nocache = nocache , skip_lint = skip_lint ) [EOL] try : [EOL] _cancel_outdated_pipelines ( context ) [EOL] except Exception : [EOL] sentry . captureException ( ) [EOL] future = start_pipeline . delay ( context ) [EOL] future . add_done_callback ( lambda fut : _RUNNING_PIPELINES . pop ( context . task_id , None ) ) [EOL] _RUNNING_PIPELINES [ context . task_id ] = future [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0