from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , url = [string] , author = [string] , author_email = [string] , license = [string] , packages = [ [string] ] , zip_safe = False , install_requires = [ [string] , [string] ] , include_package_data = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] import pathlib [EOL] import builtins [EOL] import golem_remote [EOL] from pathlib import Path [EOL] [EOL] import golem_remote . golem_remote as golem [EOL] from golem_remote . runf_helpers import SubtaskID , Host , Port [EOL] from golem_remote . golem_client import GolemClient [EOL] [EOL] from typing import Tuple [EOL] import time [EOL] [EOL] [comment] [EOL] [comment] [EOL] host = [string] [EOL] port = [number] [EOL] golem_dir = Path ( [string] ) [EOL] golemcli = Path ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] golem . init ( host = host , port = port , golem_dir = golem_dir , class_ = GolemClient , timeout = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] secret_sauce = [string] [EOL] [EOL] @ golem . remote def func ( arg1 , arg2 , kwarg1 = [string] , kwarg2 = [string] ) : [EOL] time . sleep ( [number] ) [comment] [EOL] print ( f" [string] { arg1 } [string] { arg2 } [string] { kwarg1 } [string] { kwarg2 }" ) [EOL] return ( arg1 + arg2 , kwarg1 + kwarg2 , secret_sauce ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] res_id1 = func . remote ( [number] , [number] , kwarg1 = [string] ) [EOL] [EOL] [comment] [EOL] res1 = golem . get ( res_id1 ) [EOL] print ( f" [string] { res1 }" ) [EOL] assert res1 == ( [number] + [number] , [string] + [string] , secret_sauce ) [EOL] print ( [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.runf_helpers.Host$ 0 0 0 $golem_remote.runf_helpers.Port$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.runf_helpers.Host$ 0 $golem_remote.runf_helpers.Host$ 0 $golem_remote.runf_helpers.Port$ 0 $golem_remote.runf_helpers.Port$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $golem_remote.runf_helpers.SubtaskID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $golem_remote.runf_helpers.SubtaskID$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import golem_remote [EOL] import os [EOL] import shutil [EOL] import time [EOL] from pathlib import Path [EOL] from typing import Tuple [EOL] [EOL] import golem_remote . golem_remote as golem [EOL] from golem_remote import GolemClient [EOL] from golem_remote . runf_helpers import SubtaskID [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] shutil . rmtree ( [string] , ignore_errors = True ) [EOL] os . mkdir ( [string] ) [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] [EOL] golem . init ( class_ = GolemClient , timeout = [number] , task_files = { Path ( [string] ) } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] secret_sauce = [string] [EOL] [EOL] [EOL] @ golem . remote def func ( arg1 , arg2 , kwarg1 = [string] , kwarg2 = [string] ) : [EOL] time . sleep ( [number] ) [comment] [EOL] with open ( [string] , [string] ) as f : [EOL] c = f . read ( ) [EOL] [EOL] print ( f" [string] { arg1 } [string] { arg2 } [string] { kwarg1 } [string] { kwarg2 } [string] { c }" ) [EOL] return ( arg1 + arg2 , kwarg1 + kwarg2 , secret_sauce , c ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] res_id1 = func . remote ( [number] , [number] , kwarg1 = [string] ) [EOL] [EOL] res1 = golem . get ( res_id1 ) [EOL] print ( f" [string] { res1 }" ) [EOL] [EOL] assert res1 == ( [number] + [number] , [string] + [string] , secret_sauce , [string] ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.runf_helpers.SubtaskID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $golem_remote.runf_helpers.SubtaskID$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] import threading [EOL] import subprocess [EOL] import os [EOL] import signal [EOL] import subprocess [EOL] from threading import Thread [EOL] from uuid import uuid4 [EOL] [EOL] import hyperopt [EOL] from hyperopt import fmin , hp [EOL] from hyperopt . mongoexp import MongoTrials [EOL] [EOL] trials = MongoTrials ( [string] , exp_key = str ( uuid4 ( ) ) ) [EOL] [EOL] N = [number] [EOL] NUM_WORKERS = [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] def fn ( x ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return ( x - [number] ) * ( x - [number] ) * ( x - [number] ) * x * ( x + [number] ) * ( x + [number] ) * ( x + [number] ) [EOL] [EOL] [EOL] RETURN_VALUE = [ ] [EOL] THREADS = [ ] [EOL] [EOL] [EOL] def spawn_head ( ) : [EOL] r = fmin ( fn = fn , space = hp . uniform ( [string] , - [number] , [number] ) , algo = hyperopt . rand . suggest , max_evals = N , verbose = [number] , max_queue_len = N , trials = trials ) [EOL] RETURN_VALUE . append ( r ) [EOL] [EOL] [EOL] def spawn_worker ( ) : [EOL] p = subprocess . Popen ( [ [string] , [string] , [string] ] ) [EOL] print ( [string] ) [EOL] THREADS . append ( p . pid ) [EOL] [EOL] [EOL] head_thread = Thread ( target = spawn_head ) [EOL] head_thread . start ( ) [EOL] print ( [string] ) [EOL] [EOL] os . setpgrp ( ) [EOL] [EOL] threads = [ ] [EOL] for e in range ( NUM_WORKERS ) : [EOL] spawn_worker ( ) [EOL] [EOL] print ( [string] ) [EOL] head_thread . join ( ) [EOL] [EOL] print ( f" [string] { THREADS }" ) [EOL] [EOL] for t in THREADS : [EOL] print ( f" [string] { t }" ) [EOL] os . kill ( t , signal . SIGKILL ) [EOL] [EOL] for t in threads : [EOL] t . terminate ( ) [EOL] [EOL] print ( f" [string] { RETURN_VALUE }" ) [EOL] [EOL] os . killpg ( [number] , signal . SIGKILL ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Type , Any , Union [EOL] import typing [EOL] import builtins [EOL] import threading [EOL] import golem_remote [EOL] import json [EOL] import os [EOL] import signal [EOL] import subprocess [EOL] from threading import Thread [EOL] [EOL] from uuid import uuid4 [EOL] [EOL] import hyperopt [EOL] from hyperopt import fmin , hp [EOL] from hyperopt . mongoexp import MongoTrials [EOL] import golem_remote as golem [EOL] [EOL] trials = MongoTrials ( [string] , exp_key = str ( uuid4 ( ) ) ) [EOL] [EOL] N = [number] [EOL] NUM_WORKERS = [number] [EOL] [EOL] params = dict ( class_ = golem . GolemClient , timeout = [number] , number_of_subtasks = N , clear_db = False ) [EOL] [EOL] TASK_ID = golem . init ( ** params ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( TASK_ID ) [EOL] [EOL] def fn ( x ) : [EOL] with open ( [string] , [string] ) as f : [EOL] TASK_ID = f . read ( ) [EOL] [EOL] golem . init ( ** { [string] : TASK_ID , ** params } ) [EOL] @ golem . remote def f ( x ) : [EOL] return ( x - [number] ) * ( x - [number] ) * ( x - [number] ) * x * ( x + [number] ) * ( x + [number] ) * ( x + [number] ) [EOL] [EOL] return golem . get ( f . remote ( x ) ) [EOL] [EOL] [EOL] def spawn_head ( ) : [EOL] r = fmin ( fn = fn , space = hp . uniform ( [string] , - [number] , [number] ) , algo = hyperopt . rand . suggest , max_evals = N , verbose = [number] , max_queue_len = N , trials = trials ) [EOL] with open ( [string] , [string] ) as f : [EOL] json . dump ( r , f ) [EOL] [EOL] [EOL] def spawn_worker ( ) : [EOL] subprocess . Popen ( [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] head_thread = Thread ( target = spawn_head ) [EOL] head_thread . start ( ) [EOL] print ( [string] ) [EOL] [EOL] os . setpgrp ( ) [EOL] [EOL] for e in range ( NUM_WORKERS ) : [EOL] spawn_worker ( ) [EOL] [EOL] print ( [string] ) [EOL] head_thread . join ( ) [EOL] [EOL] os . killpg ( [number] , signal . SIGKILL ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] import builtins [EOL] import golem_remote [EOL] from uuid import uuid4 as make_uuid [EOL] [EOL] import cloudpickle as pickle [EOL] [EOL] import golem_remote [EOL] from golem_remote . golem_client import GolemClientInterface [EOL] from golem_remote . runf_helpers import SubtaskData [EOL] from tests . helpers import _TestWithRedis [EOL] from tests . test_golem_client import GolemClientQueueMock , GolemClientQueue2Mock [EOL] [EOL] [EOL] class GolemClientAllMock ( GolemClientInterface ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _subtasks_results = { } [EOL] [EOL] def initialize_task ( self ) : [EOL] self . task_id = [string] [EOL] [EOL] def _run ( self , data ) : [EOL] subtask_id = str ( make_uuid ( ) ) [EOL] self . _subtasks_results [ subtask_id ] = data . function ( * data . args , ** data . kwargs ) [EOL] return subtask_id [EOL] [EOL] def get ( self , subtask_id , blocking = None , timeout = None ) : [EOL] return self . _subtasks_results [ subtask_id ] [EOL] [EOL] [EOL] class GolemClientMockPickle ( GolemClientAllMock ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _subtasks_results = { } [EOL] [EOL] def initialize_task ( self ) : [EOL] self . task_id = [string] [EOL] [EOL] def __run_pickled ( self , data ) : [EOL] data = pickle . loads ( data ) [EOL] return data . function ( * data . args , ** data . kwargs ) [EOL] [EOL] def _run ( self , data ) : [EOL] subtask_id = str ( make_uuid ( ) ) [EOL] data = pickle . dumps ( data ) [EOL] self . _subtasks_results [ subtask_id ] = self . __run_pickled ( data ) [EOL] return subtask_id [EOL] [EOL] def get ( self , subtask_id , blocking = None , timeout = None ) : [EOL] return self . _subtasks_results [ subtask_id ] [EOL] [EOL] [EOL] class TestGolemRemote ( _TestWithRedis ) : [EOL] [EOL] def test_workflow ( self ) : [EOL] def run_test ( class_ ) : [EOL] golem_remote . init ( class_ = class_ ) [EOL] secret_sauce = [string] [EOL] [EOL] @ golem_remote . remote def func ( arg1 , arg2 , kwarg1 = [string] , kwarg2 = [string] ) : [EOL] print ( f" [string] { arg1 } [string] { arg2 } [string] { kwarg1 } [string] { kwarg2 }" ) [EOL] return ( arg1 + arg2 , kwarg1 + kwarg2 , secret_sauce ) [EOL] [EOL] res_id1 = func . remote ( [number] , [number] , kwarg1 = [string] ) [EOL] res1 = golem_remote . get ( res_id1 ) [EOL] self . assertEqual ( res1 , ( [number] + [number] , [string] + [string] , secret_sauce ) ) [EOL] [EOL] run_test ( GolemClientMockPickle ) [EOL] run_test ( GolemClientQueueMock ) [EOL] run_test ( GolemClientQueue2Mock ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.runf_helpers.SubtaskData$ 0 0 0 $golem_remote.runf_helpers.SubtaskData$ 0 0 0 0 0 $golem_remote.runf_helpers.SubtaskData$ 0 0 0 $golem_remote.runf_helpers.SubtaskData$ 0 0 0 0 $golem_remote.runf_helpers.SubtaskData$ 0 0 0 0 $golem_remote.runf_helpers.SubtaskData$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Optional [EOL] import typing [EOL] import io [EOL] import tempfile [EOL] import os [EOL] import shutil [EOL] import unittest [EOL] from pathlib import Path [EOL] from tempfile import TemporaryDirectory [EOL] [EOL] import cloudpickle as pickle [EOL] [EOL] from golem_remote import open_file [EOL] from golem_remote . consts import HASH [EOL] [EOL] class TestOpenFile_1 ( unittest . TestCase ) : [EOL] [EOL] def test_open_file ( self ) : [EOL] original_dir = TemporaryDirectory ( ) [EOL] tempdir = TemporaryDirectory ( ) [EOL] [EOL] os . makedirs ( os . path . join ( tempdir . name , [string] ) ) [EOL] p = os . path . join ( original_dir . name , [string] ) [EOL] [EOL] with open ( os . path . join ( tempdir . name , [string] , HASH ( str ( p ) ) ) , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] def read_file ( x ) : [EOL] with open ( x , [string] ) as f : [EOL] return f . read ( ) [EOL] [EOL] with open ( os . path . join ( tempdir . name , [string] ) , [string] ) as f : [EOL] pickle . dump ( read_file , f ) [EOL] [EOL] with open ( os . path . join ( tempdir . name , [string] ) , [string] ) as f : [EOL] func = pickle . load ( f ) [EOL] [EOL] import builtins [comment] [EOL] open_file . orig_open = open [EOL] builtins . open = open_file . open_file ( Path ( original_dir . name ) , task_files_dir = os . path . join ( tempdir . name , [string] ) ) [EOL] [EOL] self . assertEqual ( func ( [string] ) , [string] ) [EOL] with self . assertRaises ( OSError ) : [EOL] func ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tempfile.TemporaryDirectory[typing.Any]$ 0 0 0 0 0 $tempfile.TemporaryDirectory[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tempfile.TemporaryDirectory[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $tempfile.TemporaryDirectory[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tempfile.TemporaryDirectory[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tempfile.TemporaryDirectory[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tempfile.TemporaryDirectory[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Callable[...,io.IOBase]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tempfile.TemporaryDirectory[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $tempfile.TemporaryDirectory[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Type , Any [EOL] import typing [EOL] import golem_remote [EOL] import tests [EOL] import subprocess [EOL] import os [EOL] import signal [EOL] import subprocess [EOL] from unittest import TestCase [EOL] [EOL] from golem_remote . queue_helpers import _RedisQueue , Queue [EOL] from golem_remote . runf_helpers import Port [EOL] [EOL] [EOL] def start_redis ( port ) : [EOL] p = subprocess . Popen ( [ [string] , [string] , str ( port ) ] , stdout = subprocess . PIPE , shell = True , preexec_fn = os . setsid ) [EOL] return p [EOL] [EOL] [EOL] class _TestWithRedis ( TestCase ) : [EOL] PORT = [number] [EOL] redis_process = None [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . redis_process = start_redis ( cls . PORT ) [EOL] [EOL] def setUp ( self ) : [EOL] redis = _RedisQueue ( [string] , port = self . PORT ) [EOL] redis . _db . flushall ( ) [EOL] [EOL] @ classmethod def tearDownClass ( cls ) : [EOL] os . killpg ( os . getpgid ( cls . redis_process . pid ) , signal . SIGTERM ) [EOL] if os . path . exists ( [string] ) : [EOL] os . remove ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type , Any , Optional [EOL] import typing [EOL] import golem_remote [EOL] from typing import Type [EOL] [EOL] import mock [EOL] [EOL] from golem_remote import decode_str_to_obj , encode_obj_to_str [EOL] from golem_remote . golem_client import GolemClientInterface , GolemClient [EOL] from golem_remote . golem_remote import RemoteFunction [EOL] from golem_remote . queue_helpers import Queue , get_result_key [EOL] from golem_remote . runf_helpers import SubtaskData [EOL] from tests . helpers import _TestWithRedis [EOL] [EOL] [EOL] class MockQueue ( Queue ) : [EOL] [docstring] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . subtasks = [ ] [EOL] self . d = { } [EOL] [EOL] def pop ( self , block = True , timeout = None ) : [EOL] return self . subtasks . pop ( ) [EOL] [EOL] def pop_nowait ( self ) : [EOL] return self . subtasks . pop ( ) [EOL] [EOL] def push ( self , key ) : [EOL] self . subtasks . append ( key ) [EOL] [EOL] def set ( self , key , value ) : [EOL] self . d [ key ] = value [EOL] p = decode_str_to_obj ( value ) [EOL] res = p . function ( * p . args , ** p . kwargs ) [EOL] out_key = get_result_key ( key ) [EOL] self . d [ out_key ] = encode_obj_to_str ( res ) [EOL] [EOL] def get ( self , key ) : [EOL] return self . d [ key ] [EOL] [EOL] [EOL] class MockQueue2 ( Queue ) : [EOL] [docstring] [EOL] [EOL] def set ( self , key , value ) : [EOL] super ( ) . set ( key , value ) [EOL] p = decode_str_to_obj ( value ) [EOL] res = p . function ( * p . args , ** p . kwargs ) [EOL] super ( ) . set ( get_result_key ( key ) , encode_obj_to_str ( res ) ) [EOL] [EOL] [EOL] class GolemClientQueueMock ( GolemClient ) : [EOL] [docstring] [EOL] [EOL] def initialize_task ( self ) : [EOL] if self . task_id : [EOL] raise Exception ( [string] ) [EOL] [EOL] self . task_id = [string] [EOL] self . queue = MockQueue ( self . task_id ) [EOL] [EOL] [EOL] class GolemClientQueue2Mock ( GolemClient ) : [EOL] [docstring] [EOL] [EOL] def initialize_task ( self ) : [EOL] if self . task_id : [EOL] raise Exception ( [string] ) [EOL] [EOL] self . task_id = [string] [EOL] self . queue = MockQueue2 ( self . task_id ) [EOL] [EOL] [EOL] class TestGolemClient ( _TestWithRedis ) : [EOL] [EOL] def test_workflow ( self ) : [EOL] def run_test ( class_ ) : [EOL] g = class_ ( ) [EOL] g . initialize_task ( ) [EOL] [EOL] secret_sauce = [string] [EOL] [EOL] def func ( arg1 , arg2 , kwarg1 = [string] , kwarg2 = [string] ) : [EOL] print ( f" [string] { arg1 } [string] { arg2 } [string] { kwarg1 } [string] { kwarg2 }" ) [EOL] return ( arg1 + arg2 , kwarg1 + kwarg2 , secret_sauce ) [EOL] [EOL] func = RemoteFunction ( func , g ) [EOL] res_id1 = func . remote ( [number] , [number] , kwarg1 = [string] ) [EOL] res1 = g . get ( res_id1 ) [EOL] self . assertEqual ( res1 , ( [number] + [number] , [string] + [string] , secret_sauce ) ) [EOL] [EOL] run_test ( GolemClientQueueMock ) [EOL] run_test ( GolemClientQueue2Mock ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.golem_client.GolemClientInterface$ 0 0 0 0 0 $golem_remote.golem_client.GolemClientInterface$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.golem_remote.RemoteFunction$ 0 0 0 $golem_remote.golem_remote.RemoteFunction$ 0 $golem_remote.golem_client.GolemClientInterface$ 0 0 $builtins.str$ 0 $golem_remote.golem_remote.RemoteFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $golem_remote.golem_client.GolemClientInterface$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any , Optional [EOL] import typing [EOL] import golem_remote [EOL] from golem_remote . queue_helpers import _RedisQueue , Queue [EOL] from tests . helpers import _TestWithRedis [EOL] [EOL] [EOL] class TestRedisQueue ( _TestWithRedis ) : [EOL] def test_init ( self ) : [EOL] key = [string] [EOL] r = _RedisQueue ( key , [string] , [number] ) [EOL] self . assertEqual ( r . key , key ) [EOL] [EOL] _ = _RedisQueue ( key , [string] ) [comment] [EOL] _ = _RedisQueue ( key , port = [number] ) [EOL] [EOL] with self . assertRaises ( TypeError ) : [EOL] _ = _RedisQueue ( ) [EOL] [EOL] def test_empty ( self ) : [EOL] r = _RedisQueue ( [string] ) [EOL] self . assertTrue ( r . is_empty ( ) ) [EOL] [EOL] r . push ( [string] ) [EOL] self . assertFalse ( r . is_empty ( ) ) [EOL] r . _pop ( False ) [EOL] self . assertTrue ( r . is_empty ( ) ) [EOL] [EOL] def test_push_pop_noblock ( self ) : [EOL] r = _RedisQueue ( [string] ) [EOL] [EOL] vals = [ [string] , [string] , [string] , [string] ] [EOL] for v in vals : [EOL] r . push ( v ) [EOL] [EOL] res = [ ] [EOL] for _ in range ( len ( vals ) ) : [EOL] res . append ( r . _pop ( False ) ) [EOL] [EOL] self . assertEqual ( list ( reversed ( res ) ) , vals ) [EOL] [EOL] val = r . _pop ( False ) [EOL] self . assertIsNone ( val ) [EOL] [EOL] def test_push_pop_block ( self ) : [EOL] r = _RedisQueue ( [string] ) [EOL] [EOL] vals = [ [string] , [string] , [string] , [string] ] [EOL] for v in vals : [EOL] r . push ( v ) [EOL] [EOL] res = [ ] [EOL] for _ in range ( len ( vals ) ) : [EOL] res . append ( r . _pop ( False ) ) [EOL] [EOL] self . assertEqual ( list ( reversed ( res ) ) , vals ) [EOL] [EOL] val = r . _pop ( False ) [EOL] self . assertIsNone ( val ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_get_set ( self ) : [EOL] r = _RedisQueue ( [string] ) [EOL] [EOL] val = r . get ( [string] ) [EOL] self . assertEqual ( val , None ) [EOL] [EOL] r . set ( [string] , [string] ) [EOL] val = r . get ( [string] ) [EOL] self . assertEqual ( val , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] r . set ( [string] , [string] ) [EOL] val = r . get ( [string] ) [EOL] self . assertEqual ( val , [string] ) [EOL] [EOL] [EOL] class TestQueue ( _TestWithRedis ) : [EOL] [EOL] def test_pop_noblock ( self ) : [EOL] r = Queue ( [string] , port = self . PORT ) [EOL] [EOL] r . push ( [string] ) [EOL] r . set ( [string] , [string] ) [EOL] self . assertEqual ( r . pop ( False ) , ( [string] , [string] ) ) [EOL] [EOL] r . push ( [string] ) [EOL] r . set ( [string] , [string] ) [EOL] self . assertEqual ( r . pop ( False ) , ( [string] , [string] ) ) [EOL] [EOL] r . push ( [string] ) [EOL] self . assertEqual ( r . pop ( False ) , ( [string] , None ) ) [EOL] [EOL] self . assertEqual ( r . pop ( False ) , ( None , None ) ) [EOL] [EOL] def pop_nowait ( self ) : [EOL] r = Queue ( [string] , port = self . PORT ) [EOL] [EOL] r . push ( [string] ) [EOL] r . set ( [string] , [string] ) [EOL] self . assertEqual ( r . pop ( False ) , ( [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 $builtins.str$ 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $golem_remote.queue_helpers._RedisQueue$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 $golem_remote.queue_helpers.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable [EOL] import typing [EOL] import pathlib [EOL] import builtins [EOL] from hashlib import md5 [EOL] from pathlib import Path [EOL] from typing import Callable , Any [EOL] [EOL] TASK_DEFINITION_TEMPLATE = Path ( [string] , [string] ) [EOL] LOGGER_NAME = [string] [EOL] [EOL] GOLEM_RESOURCES_DIR = [string] [EOL] GOLEM_TASK_FILES_DIR = [string] [EOL] [EOL] HASH = lambda x : md5 ( str ( x ) . encode ( [string] ) ) . hexdigest ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Callable[[typing.Any],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pathlib [EOL] import golem_remote [EOL] from pathlib import Path [EOL] [EOL] from golem_remote . runf_helpers import Host , Port [EOL] [EOL] PYTHON_PATH = Path ( [string] , [string] , [string] , [string] ) . expanduser ( ) [EOL] GOLEM_DIR = Path ( [string] , [string] , [string] ) . expanduser ( ) [EOL] GOLEMCLI = Path ( [string] , [string] , [string] ) . expanduser ( ) [EOL] [EOL] GOLEM_PORT = [number] [EOL] GOLEM_HOST = [string] [EOL] [EOL] QUEUE_PORT = [number] [EOL] QUEUE_HOST = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Iterable , Callable , Optional , Set , Any , Union [EOL] import pathlib [EOL] import golem_client [EOL] import golem_remote [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import logging [EOL] from functools import wraps [EOL] from pathlib import Path [EOL] from typing import Optional , Set , Union , Iterable , Any , Callable , List [EOL] [EOL] from golem_remote import config [EOL] from golem_remote . runf_helpers import Host , Port , TaskID , SubtaskParams , SubtaskData , SubtaskID [EOL] from . golem_client import GolemClientInterface , GolemClient [EOL] [EOL] [comment] [EOL] client = None [comment] [EOL] [EOL] [comment] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] class RemoteFunction ( ) : [EOL] [comment] [EOL] def __init__ ( self , function , client ) : [EOL] self . function = function [EOL] self . client = client [EOL] [EOL] [comment] [EOL] def remote ( self , * args , ** kwargs ) : [EOL] subtask_id = self . client . run_function ( SubtaskData ( function = self . function , args = args , kwargs = kwargs , params = SubtaskParams ( original_dir = Path ( [string] ) . absolute ( ) ) ) ) [EOL] return subtask_id [EOL] [EOL] [EOL] def golem_running ( f ) : [EOL] @ wraps ( f ) def checked ( * args , ** kwargs ) : [EOL] global client [comment] [EOL] if not client : [EOL] raise Exception ( [string] ) [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] return checked [EOL] [EOL] [EOL] @ golem_running def remote ( f ) : [EOL] return RemoteFunction ( f , client ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ golem_running def get ( item ) : [EOL] [docstring] [EOL] global client [comment] [EOL] [EOL] if isinstance ( item , SubtaskID ) : [EOL] return client . get ( item ) [EOL] [EOL] if isinstance ( item , Iterable ) : [EOL] [comment] [EOL] [comment] [EOL] return [ client . get ( x ) for x in item ] [EOL] [EOL] raise Exception ( f" [string] { type ( item ) } [string] " f" [string] { Union [ SubtaskID , Iterable [ SubtaskID ] ] }" ) [EOL] [EOL] [EOL] def init ( host = [string] , port = [number] , golem_dir = config . GOLEM_DIR , golemcli = config . GOLEMCLI , class_ = GolemClient , blocking = True , timeout = [number] , number_of_subtasks = [number] , clear_db = False , task_id = None , task_files = None ) : [EOL] global client [comment] [EOL] client = class_ ( golem_host = host , golem_port = port , golem_dir = golem_dir , golemcli = golemcli , blocking = blocking , timeout = timeout , number_of_subtasks = number_of_subtasks , clear_db = clear_db , task_id = task_id , task_files = task_files ) [EOL] client . initialize_task ( ) [EOL] return client . task_id [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 $golem_remote.golem_client.GolemClientInterface$ 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 $golem_remote.golem_client.GolemClientInterface$ 0 $golem_remote.golem_client.GolemClientInterface$ 0 0 0 0 0 $golem_remote.runf_helpers.SubtaskID$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . golem_remote import init , remote , get [EOL] from . encoding import decode_str_to_obj , encode_obj_to_str [EOL] from . golem_client import GolemClient [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import base64 [EOL] import codecs [EOL] import json [EOL] from typing import Any [EOL] [EOL] import cloudpickle as pickle [EOL] [EOL] [EOL] def encode_obj_to_str ( obj ) : [EOL] result = pickle . dumps ( obj ) [EOL] result = base64 . b64encode ( result ) [EOL] result = codecs . decode ( result , [string] ) [EOL] result = { [string] : result } [EOL] result = json . dumps ( result ) [EOL] return result [EOL] [EOL] [EOL] def decode_str_to_obj ( s ) : [EOL] result = json . loads ( s ) [EOL] result = result [ [string] ] [EOL] result = codecs . encode ( result , [string] ) [EOL] result = base64 . b64decode ( result ) [EOL] result = pickle . loads ( result ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Iterator , Callable , Optional , Any , Union [EOL] import typing [EOL] import io [EOL] import pathlib [EOL] import builtins [EOL] import os [EOL] import io [EOL] from pathlib import Path [EOL] from typing import Callable , Iterator , Optional [EOL] [EOL] from . consts import GOLEM_RESOURCES_DIR , GOLEM_TASK_FILES_DIR , HASH [EOL] [EOL] orig_open = None [EOL] [EOL] [EOL] def open_file ( original_dir , task_files_dir = os . path . join ( GOLEM_RESOURCES_DIR , GOLEM_TASK_FILES_DIR ) ) : [EOL] [docstring] [EOL] [EOL] def _open ( file , * args , ** kwargs ) : [EOL] file = Path ( file ) [EOL] if not file . is_absolute ( ) : [EOL] file = f"{ str ( original_dir ) } [string] { str ( file ) }" [EOL] available_files = list ( os . listdir ( task_files_dir ) ) if os . path . exists ( task_files_dir ) else [ ] [EOL] if HASH ( file ) in available_files : [EOL] [comment] [EOL] return orig_open ( os . path . join ( task_files_dir , HASH ( file ) ) , * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] return orig_open ( file , * args , ** kwargs ) [EOL] [EOL] return _open [EOL] [EOL] [EOL] def list_dir_recursive ( directory ) : [EOL] for dirpath , _ , filenames in os . walk ( str ( directory ) , followlinks = True ) : [EOL] for name in filenames : [EOL] yield Path ( dirpath , name ) . absolute ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Tuple [EOL] import typing [EOL] import builtins [EOL] import golem_remote [EOL] import logging [EOL] from typing import Tuple , Optional [EOL] [EOL] import redis [EOL] [EOL] from golem_remote . runf_helpers import Host , Port , QueueID , SubtaskID [EOL] [EOL] logger = logging [comment] [EOL] [EOL] [EOL] def get_result_key ( subtask_id ) : [EOL] return f"{ subtask_id } [string] " [EOL] [EOL] [EOL] class _RedisQueue : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , host = [string] , port = [number] ) : [EOL] logger . info ( f" [string] { name } [string] { host } [string] { port }" ) [EOL] self . _db = redis . Redis ( host = host , port = port , encoding = [string] ) [EOL] self . key = f"{ name }" [EOL] [EOL] def _queue_size ( self ) : [EOL] [docstring] [EOL] return self . _db . llen ( self . key ) [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return self . _queue_size ( ) == [number] [EOL] [EOL] def clear_queue ( self ) : [EOL] [docstring] [EOL] self . _db . delete ( [ self . key ] ) [EOL] [EOL] def clear_db ( self ) : [EOL] [docstring] [EOL] self . _db . flushdb ( ) [EOL] [EOL] def _pop ( self , block = True , timeout = [number] ) : [EOL] [docstring] [EOL] if block : [EOL] val = self . _db . blpop ( self . key , timeout = timeout ) [EOL] if val is None : [comment] [EOL] return None [EOL] val = val [ [number] ] [EOL] else : [EOL] val = self . _db . lpop ( self . key ) [EOL] [EOL] if val : [EOL] val = val . decode ( [string] ) [EOL] logger . info ( f" [string] { self . key } [string] { val }" ) [EOL] return val [EOL] [EOL] def push ( self , val ) : [EOL] [docstring] [EOL] logger . info ( f" [string] { self . key } [string] { val }" ) [EOL] self . _db . lpush ( self . key , val ) [EOL] [EOL] def set ( self , key , val ) : [EOL] [docstring] [EOL] logger . info ( f" [string] { key } [string] { val }" ) [EOL] self . _db . set ( key , val ) [EOL] [EOL] def get ( self , key ) : [EOL] [docstring] [EOL] [EOL] val = self . _db . get ( key ) [EOL] if val is not None : [EOL] val = val . decode ( [string] ) [EOL] [EOL] logger . info ( f" [string] { key } [string] { val }" ) [EOL] return val [EOL] [EOL] [EOL] class Queue ( _RedisQueue ) : [EOL] [EOL] def pop ( self , block = True , timeout = None ) : [EOL] key = super ( ) . _pop ( block , timeout ) [EOL] if key is None : [EOL] return None , None [EOL] return key , self . get ( key ) [EOL] [EOL] def pop_nowait ( self ) : [EOL] return self . pop ( False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[golem_remote.runf_helpers.QueueID],typing.Optional[builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Tuple[typing.Optional[golem_remote.runf_helpers.QueueID],typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type [EOL] import typing [EOL] from pathlib import Path [EOL] from typing import NamedTuple , Dict , Callable , Any , Tuple [EOL] [EOL] SubtaskID = str [EOL] QueueID = str [EOL] TaskID = str [EOL] [EOL] Host = str [EOL] Port = int [EOL] [EOL] [EOL] class SubtaskParams ( NamedTuple ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] original_dir = ... [EOL] [EOL] [EOL] [comment] [EOL] class SubtaskData ( NamedTuple ) : [EOL] args = ... [EOL] kwargs = ... [EOL] function = ... [EOL] params = ... [EOL] [EOL] [EOL] class SubtaskDefinition ( NamedTuple ) : [EOL] subtask_id = ... [EOL] queue_id = ... [EOL] data = ... [EOL] [EOL] [EOL] class FinishComputations ( NamedTuple ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.str]$ 0 0 0 0 $typing.Type[builtins.str]$ 0 0 0 $typing.Type[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 $SubtaskParams$ 0 0 0 0 0 0 0 0 0 0 0 0 $SubtaskID$ 0 0 0 $QueueID$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0