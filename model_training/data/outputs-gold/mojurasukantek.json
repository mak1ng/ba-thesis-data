from typing import List , Any , Tuple , Dict [EOL] import asyncio [EOL] import typing [EOL] import kantek [EOL] import asyncio [EOL] import json [EOL] import site [EOL] site . addsitedir ( [string] ) [EOL] from database . database import Database [EOL] from kantek . utils . config import Config [EOL] [EOL] [EOL] async def main ( ) : [EOL] a_config = Config ( ) [EOL] arango = Database ( ) [EOL] await arango . connect ( a_config ) [EOL] pg_config = Config ( ) [EOL] pg_config . db_type = [string] [EOL] pg_config . db_username = pg_config . pg_db_username [EOL] pg_config . db_name = pg_config . pg_db_name [EOL] pg_config . db_password = pg_config . pg_db_password [EOL] pg_config . db_host = pg_config . pg_db_host [EOL] pg_config . db_port = pg_config . pg_db_port [EOL] pg = Database ( ) [EOL] await pg . connect ( pg_config ) [EOL] print ( [string] ) [EOL] all_bans = await arango . banlist . get_all ( ) [EOL] all_bans = [ { [string] : b . id , [string] : b . reason } for b in all_bans ] [EOL] await pg . banlist . upsert_multiple ( all_bans ) [EOL] [EOL] print ( [string] ) [EOL] all_chats = arango . db . chats . fetchAll ( ) [EOL] all_chats = [ ( c [ [string] ] , json . dumps ( c [ [string] ] . getStore ( ) ) ) for c in all_chats ] [EOL] async with pg . db . chats . pool . acquire ( ) as conn : [EOL] async with conn . transaction ( ) : [EOL] await conn . execute ( [string] ) [EOL] await conn . copy_records_to_table ( [string] , records = all_chats ) [EOL] await conn . execute ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] blacklists = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] for b in blacklists : [EOL] print ( f' [string] { b } [string] ' ) [EOL] blacklisted_items = await getattr ( arango . blacklists , b ) . get_all ( ) [EOL] if blacklisted_items : [EOL] max_index = blacklisted_items [ - [number] ] . index [EOL] for i in range ( [number] , int ( max_index ) ) : [EOL] item = await getattr ( arango . blacklists , b ) . get_indices ( [ i ] ) [EOL] if not item : [EOL] await getattr ( pg . blacklists , b ) . add ( [string] ) [EOL] else : [EOL] item = item [ [number] ] [EOL] await getattr ( pg . blacklists , b ) . add ( item . value ) [EOL] await getattr ( pg . blacklists , b ) . retire ( [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import asyncio [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import logzero [EOL] from spamwatch . client import Client as SWClient [EOL] [EOL] from database . database import Database [EOL] from utils import helpers [EOL] from utils . client import Client [EOL] from utils . config import Config [EOL] from utils . loghandler import TGChannelLogHandler [EOL] from utils . pluginmgr import PluginManager [EOL] [EOL] logger = logzero . setup_logger ( [string] , level = logging . DEBUG ) [EOL] telethon_logger = logzero . setup_logger ( [string] , level = logging . INFO ) [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] tlog . setLevel ( logging . INFO ) [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] async def main ( ) : [EOL] [docstring] [EOL] config = Config ( ) [EOL] [EOL] handler = TGChannelLogHandler ( config . log_bot_token , config . log_channel_id ) [EOL] await handler . connect ( ) [EOL] tlog . addHandler ( handler ) [EOL] client = Client ( str ( config . session_name ) , config . api_id , config . api_hash ) [EOL] [comment] [EOL] await client . start ( config . phone ) [EOL] client . config = config [EOL] client . kantek_version = __version__ [EOL] [EOL] client . plugin_mgr = PluginManager ( client ) [EOL] client . plugin_mgr . register_all ( ) [EOL] [EOL] logger . info ( [string] ) [EOL] client . db = Database ( ) [EOL] await client . db . connect ( config ) [EOL] [EOL] tlog . info ( [string] , __version__ , helpers . link_commit ( helpers . get_commit ( ) ) ) [EOL] logger . info ( [string] , __version__ ) [EOL] [EOL] if config . spamwatch_host and config . spamwatch_token : [EOL] client . sw = SWClient ( config . spamwatch_token , host = config . spamwatch_host ) [EOL] client . sw_url = config . spamwatch_host [EOL] [EOL] await client . run_until_disconnected ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( main ( ) ) [EOL] except KeyboardInterrupt : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from aiohttp import ClientSession [EOL] [EOL] [EOL] class Bot : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , token ) : [EOL] self . url = f' [string] { token }' [EOL] self . aioclient = ClientSession ( ) [EOL] [EOL] def __getattr__ ( self , method_name ) : [EOL] [docstring] [EOL] [EOL] async def request ( ** kwargs ) : [EOL] [docstring] [EOL] method = self . snake_to_camel ( method_name ) [EOL] async with self . aioclient . post ( self . url + f' [string] { method }' , data = kwargs ) as req : [EOL] return await req . json ( ) [EOL] [EOL] return request [EOL] [EOL] @ staticmethod def snake_to_camel ( text ) : [EOL] [docstring] [EOL] _text = [ ] [EOL] last_char_was_underscore = False [EOL] c = ... [EOL] for c in text : [EOL] if c == [string] : [EOL] last_char_was_underscore = True [EOL] else : [EOL] if last_char_was_underscore : [EOL] _text . append ( c . upper ( ) ) [EOL] last_char_was_underscore = False [EOL] else : [EOL] _text . append ( c ) [EOL] return [string] . join ( _text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0
	0
from typing import Any , Optional [EOL] import typing [EOL] import database [EOL] import kantek [EOL] import telethon [EOL] from typing import Optional , Union [EOL] [EOL] from telethon . events import NewMessage [EOL] [EOL] from database . database import Database [EOL] [EOL] TagValue = Union [ bool , str , int ] [EOL] TagName = Union [ int , str ] [EOL] [EOL] [EOL] [EOL] class Tags : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , event ) : [EOL] self . db = event . client . db [EOL] self . chat_id = event . chat_id [EOL] self . _event = event [EOL] [EOL] @ classmethod async def create ( cls , event ) : [EOL] tags = Tags ( event ) [EOL] await tags . setup ( ) [EOL] return tags [EOL] [EOL] async def setup ( self ) : [EOL] if not self . _event . is_private : [EOL] self . named_tags = ( await self . db . chats . get ( self . chat_id ) ) . tags [EOL] else : [EOL] self . named_tags = { [string] : [string] } [EOL] [EOL] def get ( self , tag_name , default = None ) : [EOL] [docstring] [EOL] return self . named_tags . get ( tag_name , default ) [EOL] [EOL] async def set ( self , tag_name , value ) : [EOL] [docstring] [EOL] self . named_tags [ tag_name ] = value [EOL] await self . _save ( ) [EOL] [EOL] async def remove ( self , tag_name ) : [EOL] [docstring] [EOL] if tag_name in self . named_tags : [EOL] del self . named_tags [ tag_name ] [EOL] await self . _save ( ) [EOL] [EOL] async def clear ( self ) : [EOL] [docstring] [EOL] self . named_tags = { } [EOL] await self . _save ( ) [EOL] [EOL] async def _save ( self ) : [EOL] await self . db . chats . update_tags ( self . chat_id , self . named_tags ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telethon.events.NewMessage.Event$ 0 0 0 0 0 $database.database.Database$ 0 $telethon.events.NewMessage.Event$ 0 0 0 $database.database.Database$ 0 0 0 0 0 $telethon.events.NewMessage.Event$ 0 0 0 0 0 0 0 $telethon.events.NewMessage.Event$ 0 0 0 0 0 0 $'Tags'$ 0 0 0 0 0 0 0 $kantek.utils.tags.Tags$ 0 0 0 0 0 0 0 $kantek.utils.tags.Tags$ 0 0 0 0 0 0 $kantek.utils.tags.Tags$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[TagValue]$ 0 0 0 $TagName$ 0 $TagValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TagName$ 0 $TagValue$ 0 0 0 0 0 $None$ 0 0 0 $TagName$ 0 $typing.Optional[TagValue]$ 0 0 0 0 0 0 0 0 0 $TagName$ 0 0 $typing.Optional[TagValue]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $TagName$ 0 0 0 0 0 0 $TagName$ 0 0 0 0 0 0 0 0 0 0 0 $TagName$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Tuple , Type [EOL] import typing [EOL] from telethon . errors import ( UsernameInvalidError , UsernameNotOccupiedError , InviteHashInvalidError , AuthBytesInvalidError , FileIdInvalidError ) [EOL] [EOL] TELEGRAM_DOMAINS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] GET_ENTITY_ERRORS = ( UsernameNotOccupiedError , UsernameInvalidError , ValueError , InviteHashInvalidError ) [EOL] [EOL] DOWNLOAD_ERRORS = ( AuthBytesInvalidError , FileIdInvalidError ) [EOL] [EOL] SCHEDULE_DELETION_COMMAND = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import List , Iterable , TypeVar , Union , Tuple , Type [EOL] import kantek [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Union , Iterable , TypeVar , Tuple , Type [EOL] [EOL] K = TypeVar ( [string] ) [EOL] V = TypeVar ( [string] ) [EOL] [EOL] [EOL] class FormattedBase : [EOL] [docstring] [EOL] text = ... [EOL] [EOL] def __add__ ( self , other ) : [EOL] return str ( self ) + str ( other ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f'{ type ( self ) . __name__ } [string] { self . text } [string] ' [EOL] [EOL] def __str__ ( self ) : [EOL] return self . text [EOL] [EOL] [EOL] class Bold ( FormattedBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , text ) : [EOL] self . text = f' [string] { text } [string] ' [EOL] [EOL] [EOL] class Italic ( FormattedBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , text ) : [EOL] self . text = f' [string] { text } [string] ' [EOL] [EOL] [EOL] class Code ( FormattedBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , text ) : [EOL] self . text = f' [string] { text } [string] ' [EOL] [EOL] [EOL] class Pre ( FormattedBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , text ) : [EOL] self . text = f' [string] { text } [string] ' [EOL] [EOL] [EOL] class Link ( FormattedBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , label , url ) : [EOL] self . text = f' [string] { label } [string] { url } [string] ' [EOL] [EOL] [EOL] class Mention ( Link ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , label , uid ) : [EOL] super ( ) . __init__ ( label , f' [string] { uid }' ) [EOL] [EOL] [EOL] class KeyValueItem ( FormattedBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , key , value , colon_styles = None ) : [EOL] self . key = key [EOL] self . value = value [EOL] colon = [string] [EOL] if colon_styles is not None : [EOL] for style in colon_styles : [EOL] colon = style ( colon ) [EOL] [EOL] self . text = f'{ key }{ colon } [string] { value }' [EOL] [EOL] [EOL] class Item ( FormattedBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , text ) : [EOL] self . text = str ( text ) [EOL] [EOL] [EOL] class Section : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , indent = [number] ) : [EOL] self . header = Bold ( args [ [number] ] ) [EOL] self . items = [ i for i in args [ [number] : ] if i ] [EOL] self . indent = indent [EOL] [EOL] def __add__ ( self , other ) : [EOL] return MDTeXDocument ( self , * other ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . join ( [ str ( self . header ) ] + [ [string] * self . indent + str ( item ) for item in self . items if item is not None ] ) [EOL] [EOL] def append ( self , item ) : [EOL] [docstring] [EOL] self . items . append ( item ) [EOL] [EOL] def extend ( self , items ) : [EOL] [docstring] [EOL] self . items . extend ( items ) [EOL] [EOL] [EOL] class SubSection ( Section ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , indent = [number] ) : [EOL] super ( ) . __init__ ( * args , indent = indent ) [EOL] [EOL] [EOL] class SubSubSection ( SubSection ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , indent = [number] ) : [EOL] super ( ) . __init__ ( * args , indent = indent ) [EOL] [EOL] [EOL] class MDTeXDocument : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args ) : [EOL] self . sections = [ i for i in args if i ] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . join ( [ str ( section ) for section in self . sections ] ) [EOL] [EOL] def append ( self , item ) : [EOL] [docstring] [EOL] self . sections . append ( item ) [EOL] [EOL] def extend ( self , items ) : [EOL] [docstring] [EOL] self . sections . extend ( items ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[V,FormattedBase,'Section']$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[V,FormattedBase,'Section']$ 0 0 0 0 $None$ 0 0 0 $typing.Iterable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dataclasses import dataclass [EOL] from typing import Dict [EOL] [EOL] [EOL] @ dataclass class BlacklistItem : [EOL] index = ... [EOL] value = ... [EOL] retired = ... [EOL] [EOL] [EOL] @ dataclass class Chat : [EOL] id = ... [EOL] tags = ... [EOL] [EOL] [EOL] @ dataclass class BannedUser : [EOL] id = ... [EOL] reason = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0
	0
from typing import List , Dict , Any , Collection , Union , Optional , Type [EOL] import typing [EOL] import kantek [EOL] import builtins [EOL] import pyArango [EOL] import database [EOL] [docstring] [EOL] import time [EOL] from typing import Dict , Optional , Any , List [EOL] [EOL] from pyArango . collection import Collection , Field [EOL] from pyArango . connection import Connection [EOL] from pyArango . database import Database [EOL] from pyArango . document import Document [EOL] from pyArango . query import AQLQuery [EOL] from pyArango . theExceptions import CreationError , DocumentNotFoundError [EOL] from pyArango . validation import Int , NotNull [EOL] [EOL] from database . types import BlacklistItem , Chat , BannedUser [EOL] from utils . config import Config [EOL] [EOL] [EOL] class Chats ( Collection ) : [EOL] [docstring] [EOL] _fields = { [string] : Field ( [ NotNull ( ) , Int ( ) ] ) , [string] : Field ( [ NotNull ( ) ] ) , [string] : Field ( [ NotNull ( ) ] ) } [EOL] [EOL] _validation = { [string] : True , [string] : True } [EOL] [EOL] _properties = { [string] : { [string] : True } } [EOL] [EOL] async def add ( self , chat_id ) : [EOL] [docstring] [EOL] data = { [string] : str ( chat_id ) , [string] : chat_id , [string] : [ ] , [string] : { } } [EOL] try : [EOL] doc = self . createDocument ( data ) [EOL] doc . save ( ) [EOL] return Chat ( chat_id , { } ) [EOL] except CreationError : [EOL] return None [EOL] [EOL] async def get ( self , chat_id ) : [EOL] [docstring] [EOL] try : [EOL] doc = self [ chat_id ] [EOL] return Chat ( doc [ [string] ] , doc [ [string] ] . getStore ( ) ) [EOL] except DocumentNotFoundError : [EOL] return await self . add ( chat_id ) [EOL] [EOL] async def update_tags ( self , chat_id , new ) : [EOL] _document = self [ chat_id ] [EOL] _document [ [string] ] = new [EOL] _document . save ( ) [EOL] [EOL] [EOL] class AutobahnBlacklist ( Collection ) : [EOL] [docstring] [EOL] _fields = { [string] : Field ( [ NotNull ( ) ] ) , } [EOL] [EOL] _validation = { [string] : True , } [EOL] [EOL] _properties = { [string] : { [string] : False , [string] : [string] , [string] : [string] } } [EOL] [EOL] async def add ( self , item ) : [EOL] [docstring] [EOL] data = { [string] : item } [EOL] [EOL] try : [EOL] doc = self . createDocument ( data ) [EOL] doc . save ( ) [EOL] return BlacklistItem ( doc [ [string] ] , doc [ [string] ] , False ) [EOL] except CreationError : [EOL] return None [EOL] [EOL] async def get_by_value ( self , item ) : [EOL] doc = self . fetchByExample ( { [string] : item } , batchSize = [number] ) [EOL] if doc : [EOL] doc = doc [ [number] ] [EOL] return BlacklistItem ( doc [ [string] ] , doc [ [string] ] , False ) [EOL] else : [EOL] return None [EOL] [EOL] async def get ( self , index ) : [EOL] doc = self . fetchDocument ( index ) . getStore ( ) [EOL] return BlacklistItem ( doc [ [string] ] , doc [ [string] ] , False ) [EOL] [EOL] async def retire ( self , item ) : [EOL] existing_one = self . fetchFirstExample ( { [string] : item } ) [EOL] if existing_one : [EOL] existing_one [ [number] ] . delete ( ) [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] async def get_all ( self ) : [EOL] [docstring] [EOL] return [ BlacklistItem ( doc [ [string] ] , doc [ [string] ] , False ) for doc in self . fetchAll ( ) ] [EOL] [EOL] async def get_indices ( self , indices , db ) : [EOL] documents = db . query ( [string] [string] [string] , bind_vars = { [string] : self . __class__ . __name__ , [string] : list ( map ( str , indices ) ) } ) [EOL] return [ BlacklistItem ( doc [ [string] ] , doc [ [string] ] , False ) for doc in documents ] [EOL] [EOL] [EOL] class AutobahnBioBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] [EOL] [EOL] class AutobahnStringBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] [EOL] [EOL] class AutobahnFilenameBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] [EOL] [EOL] class AutobahnChannelBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] [EOL] [EOL] class AutobahnDomainBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] [EOL] [EOL] class AutobahnFileBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] [EOL] [EOL] class AutobahnMHashBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] [EOL] [EOL] class BanList ( Collection ) : [EOL] [docstring] [EOL] _fields = { [string] : Field ( [ NotNull ( ) ] ) , [string] : Field ( [ NotNull ( ) ] ) } [EOL] [EOL] _validation = { [string] : True , } [EOL] [EOL] _properties = { [string] : { [string] : True , } } [EOL] [EOL] async def add_user ( self , _id , reason ) : [EOL] [docstring] [EOL] data = { [string] : _id , [string] : _id , [string] : reason } [EOL] [EOL] try : [EOL] doc = self . createDocument ( data ) [EOL] doc . save ( ) [EOL] return BannedUser ( doc [ [string] ] , doc [ [string] ] ) [EOL] except CreationError : [EOL] return None [EOL] [EOL] async def get_user ( self , uid ) : [EOL] [docstring] [EOL] try : [EOL] doc = self . fetchDocument ( uid ) [EOL] return BannedUser ( doc [ [string] ] , doc [ [string] ] ) [EOL] except DocumentNotFoundError : [EOL] return None [EOL] [EOL] async def remove ( self , uid , db ) : [EOL] db . query ( [string] , bind_vars = { [string] : str ( uid ) } ) [EOL] [EOL] async def get_multiple ( self , uids , db ) : [EOL] docs = db . query ( [string] [string] [string] , bind_vars = { [string] : map ( str , uids ) } ) [EOL] return [ BannedUser ( doc [ [string] ] , doc [ [string] ] ) for doc in docs ] [EOL] [EOL] async def count_reason ( self , reason , db ) : [EOL] return db . query ( [string] [string] [string] [string] , bind_vars = { [string] : reason } ) . result [ [number] ] [EOL] [EOL] async def total_count ( self , db ) : [EOL] return db . query ( [string] [string] [string] ) . result [ [number] ] [EOL] [EOL] async def upsert_multiple ( self , bans , db ) : [EOL] bans = [ { [string] : ban [ [string] ] , ** ban } for ban in bans ] [EOL] db . query ( [string] [string] [string] [string] [string] , bind_vars = { [string] : bans } ) [EOL] [EOL] async def get_all ( self , db ) : [EOL] docs = db . query ( [string] ) [EOL] return [ BannedUser ( doc [ [string] ] , doc [ [string] ] ) for doc in docs ] [EOL] [EOL] async def get_all_not_in ( self , not_in , db ) : [EOL] docs = db . query ( [string] [string] [string] , bind_vars = { [string] : not_in } ) [EOL] [EOL] return [ BannedUser ( doc [ [string] ] , doc [ [string] ] ) for doc in docs ] [EOL] [EOL] [EOL] class Strafanzeigen ( Collection ) : [EOL] [docstring] [EOL] _fields = { [string] : Field ( [ NotNull ( ) ] ) , [string] : Field ( [ NotNull ( ) ] ) , [string] : Field ( [ NotNull ( ) ] ) } [EOL] [EOL] _validation = { [string] : True , } [EOL] [EOL] async def add ( self , content , key ) : [EOL] data = { [string] : time . time ( ) , [string] : content , [string] : key } [EOL] [EOL] try : [EOL] doc = self . createDocument ( data ) [EOL] doc . save ( ) [EOL] return key [EOL] except CreationError : [EOL] return None [EOL] [EOL] async def get ( self , key ) : [EOL] try : [EOL] return self . fetchByExample ( { [string] : key } , [number] ) [ [number] ] [ [string] ] [EOL] except IndexError : [EOL] return None [EOL] [EOL] [EOL] class ArangoDB : [comment] [EOL] [docstring] [EOL] [EOL] async def connect ( self , host , port , username , password , name ) : [EOL] if port is None : [EOL] port = [number] [EOL] url = f' [string] { host } [string] { port }' [EOL] self . conn = Connection ( arangoURL = url , username = username , password = password ) [EOL] self . db = self . _get_db ( name ) [EOL] self . chats = self . _get_collection ( [string] ) [EOL] self . ab_bio_blacklist = self . _get_collection ( [string] ) [EOL] self . ab_string_blacklist = self . _get_collection ( [string] ) [EOL] self . ab_channel_blacklist = self . _get_collection ( [string] ) [EOL] self . ab_domain_blacklist = self . _get_collection ( [string] ) [EOL] self . ab_file_blacklist = self . _get_collection ( [string] ) [EOL] self . ab_mhash_blacklist = self . _get_collection ( [string] ) [EOL] self . ab_collection_map = { [string] : self . ab_bio_blacklist , [string] : self . ab_string_blacklist , [string] : self . ab_channel_blacklist , [string] : self . ab_domain_blacklist , [string] : self . ab_file_blacklist , [string] : self . ab_mhash_blacklist , } [EOL] self . banlist = self . _get_collection ( [string] ) [EOL] self . strafanzeigen = self . _get_collection ( [string] ) [EOL] self . strafanzeigen . ensureTTLIndex ( [ [string] ] , [number] * [number] ) [EOL] [EOL] def query ( self , query , batch_size = [number] , raw_results = False , bind_vars = None , options = None , count = False , full_count = False , json_encoder = None , ** kwargs ) : [comment] [EOL] [docstring] [EOL] bind_vars = bind_vars or { } [EOL] options = options or { } [EOL] return self . db . AQLQuery ( query , rawResults = raw_results , batchSize = batch_size , bindVars = bind_vars , options = options , count = count , fullCount = full_count , json_encoder = json_encoder , ** kwargs ) [EOL] [EOL] def _get_db ( self , db ) : [EOL] [docstring] [EOL] if self . conn . hasDatabase ( db ) : [EOL] return self . conn [ db ] [EOL] else : [EOL] return self . conn . createDatabase ( db ) [EOL] [EOL] def _get_collection ( self , collection ) : [EOL] [docstring] [EOL] config = Config ( ) [EOL] if self . db . hasCollection ( collection ) : [EOL] return self . db [ collection ] [EOL] else : [EOL] if config . db_cluster_mode : [EOL] return self . db . createCollection ( collection , replication_factor = [number] ) [EOL] else : [EOL] return self . db . createCollection ( collection ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyArango.query.AQLQuery$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 $pyArango.database.Database$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pyArango.collection.Collection$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import List , Dict , Any , Tuple , Optional [EOL] import asyncpg [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import database [EOL] [docstring] [EOL] import datetime [EOL] import json [EOL] from typing import Dict , Optional , List [EOL] [EOL] import asyncpg as asyncpg [EOL] from asyncpg . pool import Pool [EOL] [EOL] from database . types import BlacklistItem , Chat , BannedUser [EOL] [EOL] [EOL] class TableWrapper : [EOL] def __init__ ( self , pool ) : [EOL] self . pool = pool [EOL] [EOL] [EOL] class Chats ( TableWrapper ) : [EOL] [EOL] async def add ( self , chat_id ) : [EOL] [docstring] [EOL] async with self . pool . acquire ( ) as conn : [EOL] await conn . execute ( [string] , chat_id ) [EOL] return Chat ( chat_id , { } ) [EOL] [EOL] async def get ( self , chat_id ) : [EOL] [docstring] [EOL] async with self . pool . acquire ( ) as conn : [EOL] row = await conn . fetchrow ( [string] , chat_id ) [EOL] if row : [EOL] return Chat ( row [ [string] ] , json . loads ( row [ [string] ] ) ) [EOL] else : [EOL] return await self . add ( chat_id ) [EOL] [EOL] async def update_tags ( self , chat_id , new ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] await conn . execute ( [string] , json . dumps ( new ) , chat_id ) [EOL] [EOL] [EOL] class AutobahnBlacklist ( TableWrapper ) : [EOL] async def add ( self , item ) : [EOL] [docstring] [EOL] async with self . pool . acquire ( ) as conn : [EOL] row = await conn . fetchrow ( f" [string] { self . name } [string] " , str ( item ) ) [EOL] return BlacklistItem ( row [ [string] ] , item , False ) [EOL] [EOL] async def get_by_value ( self , item ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] row = await conn . fetchrow ( f" [string] { self . name } [string] " , str ( item ) ) [EOL] if row : [EOL] if row [ [string] ] : [EOL] return None [EOL] else : [EOL] return BlacklistItem ( row [ [string] ] , row [ [string] ] , row [ [string] ] ) [EOL] else : [EOL] return None [EOL] [EOL] async def get ( self , index ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] row = await conn . fetchrow ( f" [string] { self . name } [string] " , index ) [EOL] if row : [EOL] return BlacklistItem ( row [ [string] ] , row [ [string] ] , row [ [string] ] ) [EOL] else : [EOL] return None [EOL] [EOL] async def retire ( self , item ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] result = await conn . fetchrow ( f" [string] { self . name } [string] " , str ( item ) ) [EOL] return result [EOL] [EOL] async def get_all ( self ) : [EOL] [docstring] [EOL] async with self . pool . acquire ( ) as conn : [EOL] rows = await conn . fetch ( f" [string] { self . name } [string] " ) [EOL] return [ BlacklistItem ( row [ [string] ] , row [ [string] ] , row [ [string] ] ) for row in rows ] [EOL] [EOL] async def get_indices ( self , indices , _ ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] rows = await conn . fetch ( f" [string] { self . name } [string] " , indices ) [EOL] return [ BlacklistItem ( row [ [string] ] , row [ [string] ] , row [ [string] ] ) for row in rows ] [EOL] [EOL] [EOL] class AutobahnBioBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] name = [string] [EOL] [EOL] [EOL] class AutobahnStringBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] name = [string] [EOL] [EOL] [EOL] class AutobahnChannelBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] name = [string] [EOL] [EOL] [EOL] class AutobahnDomainBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] name = [string] [EOL] [EOL] [EOL] class AutobahnFileBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] name = [string] [EOL] [EOL] [EOL] class AutobahnMHashBlacklist ( AutobahnBlacklist ) : [EOL] [docstring] [EOL] hex_type = [string] [EOL] name = [string] [EOL] [EOL] [EOL] class BanList ( TableWrapper ) : [EOL] async def add_user ( self , _id , reason ) : [EOL] [comment] [EOL] pass [EOL] [EOL] async def get_user ( self , uid ) : [EOL] [docstring] [EOL] async with self . pool . acquire ( ) as conn : [EOL] row = await conn . fetchrow ( [string] , uid ) [EOL] if row : [EOL] return BannedUser ( row [ [string] ] , row [ [string] ] ) [EOL] [EOL] async def remove ( self , uid , _ ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] await conn . execute ( [string] , uid ) [EOL] [EOL] async def get_multiple ( self , uids , _ ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] rows = await conn . fetch ( f" [string] " , uids ) [EOL] return [ BannedUser ( row [ [string] ] , row [ [string] ] ) for row in rows ] [EOL] [EOL] async def count_reason ( self , reason , _ ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] return ( await conn . fetchrow ( [string] , reason ) ) [ [string] ] [EOL] [EOL] async def total_count ( self , _ ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] return ( await conn . fetchrow ( [string] ) ) [ [string] ] [EOL] [EOL] async def upsert_multiple ( self , bans , _ ) : [EOL] bans = [ ( int ( u [ [string] ] ) , str ( u [ [string] ] ) , datetime . datetime . now ( ) , None ) for u in bans ] [EOL] async with self . pool . acquire ( ) as conn : [EOL] async with conn . transaction ( ) : [EOL] await conn . execute ( [string] [string] ) [EOL] await conn . copy_records_to_table ( [string] , records = bans ) [EOL] await conn . execute ( [string] ) [EOL] [EOL] async def get_all ( self , _ ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] rows = await conn . fetch ( [string] ) [EOL] return [ BannedUser ( row [ [string] ] , row [ [string] ] ) for row in rows ] [EOL] [EOL] async def get_all_not_in ( self , not_in , _ ) : [EOL] not_in = list ( map ( int , not_in ) ) [EOL] async with self . pool . acquire ( ) as conn : [EOL] rows = await conn . fetch ( f" [string] " , not_in ) [EOL] return [ BannedUser ( row [ [string] ] , row [ [string] ] ) for row in rows ] [EOL] [EOL] [EOL] class Strafanzeigen ( TableWrapper ) : [EOL] async def add ( self , data , key ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] await conn . execute ( [string] , key , data ) [EOL] return key [EOL] [EOL] async def get ( self , key ) : [EOL] async with self . pool . acquire ( ) as conn : [EOL] row = await conn . fetchrow ( [string] , key ) [EOL] if row : [EOL] return row [ [string] ] [EOL] else : [EOL] return None [EOL] [EOL] [EOL] class Postgres : [comment] [EOL] async def connect ( self , host , port , username , password , name ) : [EOL] if port is None : [EOL] port = [number] [EOL] self . pool = await asyncpg . create_pool ( user = username , password = password , database = name , host = host , port = port ) [EOL] self . chats = Chats ( self . pool ) [EOL] self . ab_bio_blacklist = AutobahnBioBlacklist ( self . pool ) [EOL] self . ab_string_blacklist = AutobahnStringBlacklist ( self . pool ) [EOL] self . ab_channel_blacklist = AutobahnChannelBlacklist ( self . pool ) [EOL] self . ab_domain_blacklist = AutobahnDomainBlacklist ( self . pool ) [EOL] self . ab_file_blacklist = AutobahnFileBlacklist ( self . pool ) [EOL] self . ab_mhash_blacklist = AutobahnMHashBlacklist ( self . pool ) [EOL] self . ab_collection_map = { [string] : self . ab_bio_blacklist , [string] : self . ab_string_blacklist , [string] : self . ab_channel_blacklist , [string] : self . ab_domain_blacklist , [string] : self . ab_file_blacklist , [string] : self . ab_mhash_blacklist , } [EOL] self . banlist = BanList ( self . pool ) [EOL] self . strafanzeigen = Strafanzeigen ( self . pool ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[database.types.BannedUser]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Tuple[builtins.int,typing.Any,datetime.datetime,None]]$ 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,typing.Any,datetime.datetime,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,typing.Any,datetime.datetime,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,typing.Any,datetime.datetime,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[database.types.BannedUser]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[database.types.BannedUser]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $Chats$ 0 0 0 0 0 0 0 0 0 0 $AutobahnBioBlacklist$ 0 0 0 0 0 0 0 0 0 0 $AutobahnStringBlacklist$ 0 0 0 0 0 0 0 0 0 0 $AutobahnChannelBlacklist$ 0 0 0 0 0 0 0 0 0 0 $AutobahnDomainBlacklist$ 0 0 0 0 0 0 0 0 0 0 $AutobahnFileBlacklist$ 0 0 0 0 0 0 0 0 0 0 $AutobahnMHashBlacklist$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AutobahnBioBlacklist$ 0 0 0 0 0 $AutobahnStringBlacklist$ 0 0 0 0 0 $AutobahnChannelBlacklist$ 0 0 0 0 0 $AutobahnDomainBlacklist$ 0 0 0 0 0 $AutobahnFileBlacklist$ 0 0 0 0 0 $AutobahnMHashBlacklist$ 0 0 0 0 0 $BanList$ 0 0 0 0 0 0 0 0 0 0 $Strafanzeigen$ 0 0 0 0 0 0 0 0
import logging [EOL] import utils [EOL] [docstring] [EOL] import logging [EOL] [EOL] from utils . client import Client [EOL] from utils . pluginmgr import k [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] ) async def kill ( client ) : [EOL] [docstring] [EOL] tlog . info ( [string] ) [EOL] await client . disconnect ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import telethon [EOL] import utils [EOL] [docstring] [EOL] import logging [EOL] import platform [EOL] [EOL] import telethon [EOL] from telethon . errors import ChatSendStickersForbiddenError [EOL] from telethon . tl . functions . messages import GetStickerSetRequest [EOL] from telethon . tl . types import InputStickerSetShortName , StickerSet , Channel [EOL] [EOL] from utils . client import Client [EOL] from utils . config import Config [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] ) async def kantek ( client , chat ) : [EOL] [docstring] [EOL] config = Config ( ) [EOL] stickerset = await client ( GetStickerSetRequest ( InputStickerSetShortName ( [string] ) ) ) [EOL] try : [EOL] await client . send_file ( chat , stickerset . documents [ [number] ] ) [EOL] except ChatSendStickersForbiddenError : [EOL] pass [EOL] return MDTeXDocument ( Section ( f"{ Bold ( [string] ) } [string] " , KeyValueItem ( Bold ( [string] ) , config . source_url ) , KeyValueItem ( Bold ( [string] ) , client . kantek_version ) , KeyValueItem ( Bold ( [string] ) , telethon . __version__ ) , KeyValueItem ( Bold ( [string] ) , platform . python_version ( ) ) , KeyValueItem ( Bold ( [string] ) , len ( client . plugin_mgr . commands ) + len ( client . plugin_mgr . events ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import telethon [EOL] import utils [EOL] import typing [EOL] import builtins [EOL] import database [EOL] from datetime import timedelta [EOL] from pprint import pformat [EOL] from typing import List , Dict [EOL] [EOL] from telethon . tl . custom import Message [EOL] [EOL] from database . database import Database [EOL] from utils import parsers [EOL] from utils . client import Client [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k , _Command , _Signature [EOL] [EOL] [EOL] @ k . command ( [string] , document = False ) async def dev ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] @ dev . subcommand ( ) async def requires ( client , args , kwargs ) : [EOL] [docstring] [EOL] plugins = client . plugin_mgr [EOL] _requires = args [ [number] ] [EOL] hide = kwargs . get ( [string] , False ) [EOL] supported_args = _Signature . __annotations__ . keys ( ) [EOL] if _requires not in supported_args : [EOL] return MDTeXDocument ( Section ( [string] , KeyValueItem ( [string] , Code ( _requires ) ) , KeyValueItem ( [string] , [string] . join ( map ( str , map ( Code , supported_args ) ) ) ) ) ) [EOL] result = Section ( [string] ) [EOL] cmd = ... [EOL] for name , cmd in plugins . commands . items ( ) : [EOL] req = cmd . signature . __dict__ [ _requires ] [EOL] _cmd = SubSection ( name ) [EOL] if req is not hide : [EOL] _cmd . append ( KeyValueItem ( _requires , req ) ) [EOL] if cmd . subcommands : [EOL] for scname , scmd in cmd . subcommands . items ( ) : [EOL] screq = scmd . signature . __dict__ [ _requires ] [EOL] if screq is not hide : [EOL] _scmd = SubSubSection ( scname , KeyValueItem ( _requires , screq ) ) [EOL] _cmd . append ( _scmd ) [EOL] if _cmd . items : [EOL] result . append ( _cmd ) [EOL] return MDTeXDocument ( result ) [EOL] [EOL] [EOL] @ dev . subcommand ( ) async def args ( args , kwargs ) : [EOL] [docstring] [EOL] _args = [ ] [EOL] for arg in args : [EOL] _args . append ( SubSection ( Code ( arg ) , KeyValueItem ( [string] , Code ( type ( arg ) . __name__ ) ) ) ) [EOL] keyword_args = [ ] [EOL] for key , value in kwargs . items ( ) : [EOL] keyword_args . append ( SubSection ( Code ( key ) , KeyValueItem ( [string] , Code ( value ) ) , KeyValueItem ( [string] , Code ( type ( value ) . __name__ ) ) ) ) [EOL] return MDTeXDocument ( Section ( [string] , * _args ) , Section ( [string] , * keyword_args ) , Section ( [string] , KeyValueItem ( [string] , Pre ( pformat ( args , width = [number] ) ) ) , KeyValueItem ( [string] , Pre ( pformat ( kwargs , width = [number] ) ) ) ) ) [EOL] [EOL] [EOL] @ dev . subcommand ( ) async def time ( args ) : [EOL] [docstring] [EOL] m = Section ( [string] ) [EOL] for arg in args : [EOL] seconds = parsers . time ( arg ) [EOL] m . append ( SubSection ( arg , KeyValueItem ( [string] , seconds ) , KeyValueItem ( [string] , str ( timedelta ( seconds = seconds ) ) ) ) ) [EOL] return MDTeXDocument ( m ) [EOL] [EOL] [EOL] @ dev . subcommand ( ) async def sa ( kwargs , db ) : [EOL] [docstring] [EOL] sa = kwargs . get ( [string] ) [EOL] if value := await db . strafanzeigen . get ( sa ) : [EOL] return MDTeXDocument ( Section ( [string] , KeyValueItem ( [string] , Code ( sa ) ) , KeyValueItem ( [string] , Code ( value ) ) ) ) [EOL] else : [EOL] return MDTeXDocument ( Section ( [string] , Italic ( [string] ) ) ) [EOL] [EOL] @ dev . subcommand ( ) async def cat ( msg , event , client ) : [EOL] [docstring] [EOL] if msg . is_reply : [comment] [EOL] reply_msg = await msg . get_reply_message ( ) [EOL] data = await reply_msg . download_media ( bytes ) [EOL] if data : [EOL] await client . respond ( event , data . decode ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] import logging [EOL] import telethon [EOL] import utils [EOL] [docstring] [EOL] import logging [EOL] from typing import Dict [EOL] [EOL] from telethon . tl . types import Channel [EOL] [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k [EOL] from utils . tags import Tags [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] ) async def tag ( chat , tags ) : [EOL] [docstring] [EOL] named_tags = tags . named_tags [EOL] data = [ ] [EOL] data += [ KeyValueItem ( key , Code ( value ) ) for key , value in named_tags . items ( ) ] [EOL] if not data : [EOL] data . append ( Code ( [string] ) ) [EOL] return MDTeXDocument ( Section ( Item ( f' [string] { chat . title } [string] { Code ( chat . id ) } [string] ' ) , * data ) ) [EOL] [EOL] [EOL] @ tag . subcommand ( ) async def add ( args , kwargs , tags , event ) : [EOL] [docstring] [EOL] for name , value in kwargs . items ( ) : [EOL] await tags . set ( name , value ) [EOL] await event . delete ( ) [EOL] [EOL] [EOL] @ tag . subcommand ( ) async def del_ ( args , tags , event ) : [EOL] [docstring] [EOL] for arg in args : [EOL] await tags . remove ( arg ) [EOL] await event . delete ( ) [EOL] [EOL] [EOL] @ tag . subcommand ( ) async def clear ( tags , event ) : [EOL] [docstring] [EOL] await tags . clear ( ) [EOL] await event . delete ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Callable , Pattern [EOL] import typing [EOL] import builtins [EOL] import utils [EOL] import inspect [EOL] import re [EOL] from typing import Callable [EOL] [EOL] from utils . client import Client [EOL] from utils . config import Config [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k , _Command , _Event [EOL] [EOL] SECTION_PATTERN = re . compile ( [string] , re . MULTILINE ) [EOL] [EOL] MISC_TOPICS = [ [string] ] [EOL] [EOL] [EOL] @ k . command ( [string] ) async def help_ ( client , args , kwargs ) : [EOL] [docstring] [EOL] cmds = client . plugin_mgr . commands [EOL] events = client . plugin_mgr . events [EOL] config = Config ( ) [EOL] if not args : [EOL] toc = MDTeXDocument ( ) [EOL] _cmds = [ ] [EOL] for name , cmd in cmds . items ( ) : [EOL] if cmd . document : [EOL] _cmds . append ( [string] . join ( cmd . commands ) ) [EOL] _events = [ ] [EOL] toc . append ( Section ( [string] , * sorted ( _cmds ) ) ) [EOL] for e in events : [EOL] if e . name : [EOL] _events . append ( e . name ) [EOL] toc . append ( Section ( [string] , * sorted ( _events ) ) ) [EOL] toc . append ( Section ( [string] , [string] ) ) [EOL] toc . append ( Italic ( [string] ) ) [EOL] return toc [EOL] if args : [EOL] topic , * subtopic = args [EOL] if topic in MISC_TOPICS : [EOL] return get_misc_topics ( topic , subtopic ) [EOL] cmd = cmds . get ( topic ) [EOL] if cmd is None : [EOL] for _cmd in cmds . values ( ) : [EOL] if topic in _cmd . commands : [EOL] cmd = _cmd [EOL] break [EOL] for _event in events : [EOL] if _event . name == topic : [EOL] cmd = _event [EOL] break [EOL] if cmd is None : [EOL] return MDTeXDocument ( Section ( [string] , f' [string] { Code ( topic ) }' ) ) [EOL] if isinstance ( cmd , _Command ) : [EOL] return get_command_info ( cmd , subtopic , config ) [EOL] elif isinstance ( cmd , _Event ) : [EOL] return get_event_info ( cmd , subtopic , config ) [EOL] [EOL] [EOL] def get_event_info ( event , subcommands , config ) : [EOL] description = get_description ( event . callback , [string] ) [EOL] help_msg = MDTeXDocument ( Section ( f' [string] { event . name }' ) , description ) [EOL] return help_msg [EOL] [EOL] [EOL] def get_command_info ( cmd , subcommands , config ) : [EOL] cmd_name = cmd . commands [ [number] ] [EOL] if not subcommands : [EOL] help_cmd = f'{ config . cmd_prefix [ [number] ] }{ cmd_name }' [EOL] description = get_description ( cmd . callback , help_cmd ) [EOL] help_msg = MDTeXDocument ( Section ( f' [string] { help_cmd }' ) , description ) [EOL] [EOL] if cmd . admins : [EOL] help_msg . append ( Italic ( [string] ) ) [EOL] [EOL] if not cmd . private : [EOL] help_msg . append ( Italic ( [string] ) ) [EOL] [EOL] if cmd . subcommands : [EOL] subcommands = Section ( [string] ) [EOL] for name , sc in cmd . subcommands . items ( ) : [EOL] sc_description = inspect . getdoc ( sc . callback ) [EOL] if sc_description : [EOL] sc_description = sc_description . split ( [string] ) [ [number] ] [EOL] else : [EOL] sc_description = Italic ( [string] ) [EOL] subcommands . append ( KeyValueItem ( Italic ( Bold ( name ) ) , sc_description , colon_styles = ( Bold , Italic ) ) ) [EOL] help_msg . append ( subcommands ) [EOL] return help_msg [EOL] elif subcommands : [EOL] subcommand = cmd . subcommands . get ( subcommands [ [number] ] ) [EOL] [EOL] if subcommand is None : [EOL] return MDTeXDocument ( Section ( [string] , f' [string] { Code ( subcommands [ [number] ] ) } [string] { Code ( cmd_name ) }' ) ) [EOL] help_cmd = f'{ config . cmd_prefix [ [number] ] }{ cmd_name } [string] { subcommand . command }' [EOL] description = get_description ( subcommand . callback , help_cmd ) [EOL] [EOL] help_msg = MDTeXDocument ( Section ( f' [string] { help_cmd }' ) , description ) [EOL] [EOL] return help_msg [EOL] [EOL] [EOL] def get_description ( callback , help_cmd ) : [EOL] config = Config ( ) [EOL] description = inspect . getdoc ( callback ) [EOL] if description is None : [EOL] return [string] [EOL] description = description . format ( cmd = help_cmd , prefix = config . cmd_prefix [ [number] ] ) [EOL] description = SECTION_PATTERN . sub ( str ( Bold ( [string] ) ) , description ) [EOL] return description [EOL] [EOL] [EOL] def get_misc_topics ( topic , subtopics ) : [EOL] config = Config ( ) [EOL] subtopic = None [EOL] if subtopics : [EOL] subtopic = subtopics [ [number] ] [EOL] if topic == [string] : [EOL] if not subtopic : [EOL] return MDTeXDocument ( Section ( f' [string] ' , KeyValueItem ( Italic ( Bold ( [string] ) ) , [string] , colon_styles = ( Bold , Italic ) ) , KeyValueItem ( Italic ( Bold ( [string] ) ) , [string] , colon_styles = ( Bold , Italic ) ) ) ) [EOL] elif subtopic == [string] : [EOL] return MDTeXDocument ( Section ( [string] ) , [string] [string] , Section ( [string] , KeyValueItem ( Code ( [string] ) , [string] ) , KeyValueItem ( Code ( [string] ) , [string] ) , KeyValueItem ( Code ( [string] ) , [string] ) , KeyValueItem ( Code ( [string] ) , [string] ) , KeyValueItem ( Code ( [string] ) , [string] ) , KeyValueItem ( Code ( [string] ) , [string] ) ) ) [EOL] elif subtopic == [string] : [EOL] return MDTeXDocument ( Section ( [string] ) , [string] [string] , f' [string] { Code ( f"{ config . cmd_prefix [ [number] ] } [string] " ) }' , Section ( [string] , SubSection ( [string] , Code ( [string] ) , Code ( [string] ) ) , SubSection ( [string] , Code ( [string] ) , Code ( [string] ) ) , SubSection ( [string] , Code ( [string] ) ) , SubSection ( [string] , Code ( [string] ) , Code ( [string] ) ) , SubSection ( [string] , Code ( [string] ) , Code ( [string] ) , Code ( [string] ) , Code ( [string] ) ) , SubSection ( [string] , Code ( [string] ) , Code ( [string] ) , Code ( [string] ) ) , ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import telethon [EOL] [docstring] [EOL] import logging [EOL] [EOL] from telethon import events [EOL] from telethon . events import NewMessage [EOL] from telethon . tl . patched import Message [EOL] [EOL] from utils . constants import SCHEDULE_DELETION_COMMAND [EOL] from utils . pluginmgr import k [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . event ( events . NewMessage ( outgoing = True , pattern = SCHEDULE_DELETION_COMMAND ) ) async def delete ( event ) : [EOL] [docstring] [EOL] msg = event . message [EOL] await msg . delete ( ) [EOL] if msg . is_reply : [EOL] reply_msg = await msg . get_reply_message ( ) [EOL] await reply_msg . delete ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any , Union , Optional [EOL] import telethon [EOL] import utils [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import database [EOL] [docstring] [EOL] import logging [EOL] from typing import Union , Dict , List , Optional [EOL] [EOL] from spamwatch . types import Permission [EOL] from telethon . tl . custom import Forward , Message [EOL] from telethon . tl . types import MessageEntityMention , MessageEntityMentionName , User , Channel [EOL] [EOL] from database . database import Database [EOL] from utils import helpers , constants [EOL] from utils . client import Client [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k [EOL] from utils . tags import Tags [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] , [string] ) async def user_info ( msg , tags , client , db , args , kwargs ) : [EOL] [docstring] [EOL] if not args and msg . is_reply : [EOL] return await _info_from_reply ( client , msg , db , kwargs , tags ) [EOL] elif args : [EOL] return await _info_from_arguments ( client , msg , db , args , kwargs ) [EOL] [EOL] [EOL] async def _info_from_arguments ( client , msg , db , args , kwargs ) : [EOL] gban_format = kwargs . get ( [string] , False ) [EOL] entities = [ ] [EOL] for entity in msg . get_entities_text ( ) : [EOL] obj , text = entity [EOL] if isinstance ( obj , MessageEntityMentionName ) : [EOL] entities . append ( obj . user_id ) [EOL] elif isinstance ( obj , MessageEntityMention ) : [EOL] entities . append ( text ) [EOL] [comment] [EOL] for uid in args : [EOL] if isinstance ( uid , int ) : [EOL] entities . append ( uid ) [EOL] [EOL] users = [ ] [EOL] errors = [ ] [EOL] for entity in entities : [EOL] try : [EOL] user = await client . get_entity ( entity ) [EOL] if isinstance ( user , Channel ) : [EOL] errors . append ( str ( entity ) ) [EOL] continue [EOL] users . append ( str ( await _collect_user_info ( client , user , db , ** kwargs ) ) ) [EOL] except constants . GET_ENTITY_ERRORS : [EOL] errors . append ( str ( entity ) ) [EOL] if users and gban_format : [EOL] users = [ Code ( [string] . join ( users ) ) ] [EOL] if users or errors : [EOL] return MDTeXDocument ( * users , ( Section ( [string] , Code ( [string] . join ( errors ) ) ) ) if errors else [string] ) [EOL] [EOL] [EOL] async def _info_from_reply ( client , msg , db , kwargs , tags ) : [EOL] get_forward = kwargs . get ( [string] , True ) [EOL] anzeige = tags . get ( [string] , False ) or kwargs . get ( [string] , False ) [EOL] [EOL] reply_msg = await msg . get_reply_message ( ) [EOL] [EOL] if get_forward and reply_msg . forward is not None : [EOL] forward = reply_msg . forward [EOL] if forward . sender_id is None : [EOL] return MDTeXDocument ( Section ( [string] , [string] ) ) [EOL] user = await client . get_entity ( forward . sender_id ) [EOL] else : [EOL] user = await client . get_entity ( reply_msg . sender_id ) [EOL] user_section = await _collect_user_info ( client , user , db , ** kwargs ) [EOL] if anzeige and isinstance ( user_section , Section ) : [EOL] data = await helpers . create_strafanzeige ( user . id , reply_msg ) [EOL] key = await db . strafanzeigen . add ( data ) [EOL] user_section . append ( SubSection ( [string] , KeyValueItem ( [string] , Code ( f' [string] { key }' ) ) ) ) [EOL] return MDTeXDocument ( user_section ) [EOL] [EOL] [EOL] async def _collect_user_info ( client , user , db , ** kwargs ) : [EOL] id_only = kwargs . get ( [string] , False ) [EOL] gban_format = kwargs . get ( [string] , False ) [EOL] show_general = kwargs . get ( [string] , True ) [EOL] show_bot = kwargs . get ( [string] , False ) [EOL] show_misc = kwargs . get ( [string] , False ) [EOL] show_all = kwargs . get ( [string] , False ) [EOL] full_ban_msg = kwargs . get ( [string] , False ) [EOL] show_spamwatch = kwargs . get ( [string] , False ) [EOL] [EOL] if show_all : [EOL] show_general = True [EOL] show_bot = True [EOL] show_misc = True [EOL] show_spamwatch = True [EOL] [EOL] mention_name = kwargs . get ( [string] , False ) [EOL] [EOL] full_name = await helpers . get_full_name ( user ) [EOL] if mention_name : [EOL] title = Link ( full_name , f' [string] { user . id }' ) [EOL] else : [EOL] title = Bold ( full_name ) [EOL] [EOL] sw_ban = None [EOL] ban_reason = await db . banlist . get ( user . id ) [EOL] if ban_reason : [EOL] ban_reason = ban_reason . reason [EOL] if client . sw and client . sw . permission . value <= Permission . User . value : [EOL] sw_ban = client . sw . get_ban ( int ( user . id ) ) [EOL] if sw_ban : [EOL] ban_message = sw_ban . message [EOL] if ban_message and not full_ban_msg : [EOL] ban_message = f'{ ban_message [ : [number] ] }{ [string] if len ( ban_message ) > [number] else [string] }' [EOL] [EOL] if id_only : [EOL] return KeyValueItem ( title , Code ( user . id ) ) [EOL] elif gban_format : [EOL] return str ( user . id ) [EOL] else : [EOL] general = SubSection ( Bold ( [string] ) , KeyValueItem ( [string] , Code ( user . id ) ) , KeyValueItem ( [string] , Code ( user . first_name ) ) ) [EOL] if user . last_name is not None or show_all : [EOL] general . append ( KeyValueItem ( [string] , Code ( user . last_name ) ) ) [EOL] if user . username is not None or show_all : [EOL] general . append ( KeyValueItem ( [string] , Code ( user . username ) ) ) [EOL] [EOL] if ban_reason : [EOL] general . append ( KeyValueItem ( [string] , Code ( ban_reason ) ) ) [EOL] elif not show_spamwatch : [EOL] general . append ( KeyValueItem ( [string] , Code ( [string] ) ) ) [EOL] if sw_ban and not show_spamwatch : [EOL] general . append ( KeyValueItem ( [string] , Code ( ban_message ) ) ) [EOL] [EOL] spamwatch = SubSection ( [string] ) [EOL] if sw_ban : [EOL] spamwatch . extend ( [ KeyValueItem ( [string] , Code ( sw_ban . reason ) ) , KeyValueItem ( [string] , Code ( sw_ban . date ) ) , KeyValueItem ( [string] , Code ( sw_ban . timestamp ) ) , KeyValueItem ( [string] , Code ( sw_ban . admin ) ) , KeyValueItem ( [string] , Code ( ban_message ) ) , ] ) [EOL] elif not client . sw : [EOL] spamwatch . append ( Italic ( [string] ) ) [EOL] else : [EOL] spamwatch . append ( KeyValueItem ( [string] , Code ( [string] ) ) ) [EOL] [EOL] bot = SubSection ( Bold ( [string] ) , KeyValueItem ( [string] , Code ( user . bot ) ) , KeyValueItem ( [string] , Code ( user . bot_chat_history ) ) , KeyValueItem ( [string] , Code ( user . bot_info_version ) ) , KeyValueItem ( [string] , Code ( user . bot_inline_geo ) ) , KeyValueItem ( [string] , Code ( user . bot_inline_placeholder ) ) , KeyValueItem ( [string] , Code ( user . bot_nochats ) ) ) [EOL] misc = SubSection ( Bold ( [string] ) , KeyValueItem ( [string] , Code ( user . mutual_contact ) ) , KeyValueItem ( [string] , Code ( user . restricted ) ) , KeyValueItem ( [string] , Code ( user . restriction_reason ) ) , KeyValueItem ( [string] , Code ( user . deleted ) ) , KeyValueItem ( [string] , Code ( user . verified ) ) , KeyValueItem ( [string] , Code ( user . min ) ) , KeyValueItem ( [string] , Code ( user . lang_code ) ) ) [EOL] [EOL] return Section ( title , general if show_general else None , spamwatch if show_spamwatch else None , misc if show_misc else None , bot if show_bot else None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import utils [EOL] [docstring] [EOL] import logging [EOL] from typing import List [EOL] [EOL] from utils . client import Client [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] , [string] ) async def follow ( client , args ) : [EOL] [docstring] [EOL] link = args [ [number] ] [EOL] return MDTeXDocument ( Section ( [string] , KeyValueItem ( Bold ( [string] ) , Code ( link ) ) , KeyValueItem ( Bold ( [string] ) , Code ( await client . resolve_url ( link , base_domain = False ) ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] import logging [EOL] import telethon [EOL] import utils [EOL] [docstring] [EOL] import logging [EOL] from typing import List , Dict [EOL] [EOL] from spamwatch . types import Permission [EOL] from telethon . tl . patched import Message [EOL] [EOL] from utils . client import Client [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k , Command [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ k . command ( [string] , [string] , document = False ) async def sw ( client , args , kwargs , event ) : [EOL] [docstring] [EOL] if not client . sw : [EOL] return [EOL] subcommand , * args = args [EOL] [EOL] result = [string] [EOL] [EOL] if client . sw . permission != Permission . Root : [EOL] await client . respond ( event , MDTeXDocument ( Section ( [string] , [string] ) ) ) [EOL] if subcommand == [string] : [EOL] result = await _token ( event , client , args , kwargs ) [EOL] if result : [EOL] await client . respond ( event , result ) [EOL] [EOL] [EOL] async def _token ( event , client , args , keyword_args ) : [EOL] command , * args = args [EOL] msg = event . message [EOL] userid = [ uid for uid in args if isinstance ( uid , int ) ] [EOL] if not userid : [EOL] if msg . is_reply : [EOL] reply_message = await msg . get_reply_message ( ) [EOL] userid = reply_message . from_id [EOL] else : [EOL] return MDTeXDocument ( Section ( [string] , [string] ) ) [EOL] else : [EOL] userid = userid [ [number] ] [EOL] if command == [string] : [EOL] from spamwatch . types import _permission_map [comment] [EOL] permission = keyword_args . get ( [string] , [string] ) [EOL] permission = _permission_map . get ( permission ) [EOL] token = client . sw . create_token ( userid , permission ) [EOL] return MDTeXDocument ( Section ( [string] , KeyValueItem ( [string] , Code ( token . id ) ) , KeyValueItem ( [string] , Code ( token . userid ) ) , KeyValueItem ( [string] , token . permission . name ) , KeyValueItem ( [string] , Code ( token . token ) ) ) , Section ( [string] , KeyValueItem ( [string] , client . sw_url . split ( [string] ) [ - [number] ] ) , KeyValueItem ( [string] , [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from typing import List [EOL] [EOL] from utils import helpers [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] , [string] ) async def invitelink ( args ) : [EOL] [docstring] [EOL] link = args [ [number] ] [EOL] link_creator , chatid , random_part = await helpers . resolve_invite_link ( link ) [EOL] return MDTeXDocument ( Section ( [string] , KeyValueItem ( [string] , f' [string] { link_creator } [string] { link_creator } [string] ' ) , KeyValueItem ( [string] , Code ( chatid ) ) , KeyValueItem ( [string] , Code ( random_part ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import telethon [EOL] import utils [EOL] [docstring] [EOL] import logging [EOL] [EOL] from telethon . tl . custom import Message [EOL] from telethon . tl . types import Channel [EOL] [EOL] from utils . client import Client [EOL] from utils . pluginmgr import k [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] ) async def puge ( client , chat , msg , args , event ) : [EOL] [docstring] [EOL] await msg . delete ( ) [EOL] if not msg . is_reply : [EOL] if args : [EOL] count = args [ [number] ] [EOL] message_ids = [ msg . id ] [EOL] async for m in client . iter_messages ( chat , limit = count , offset_id = msg . id ) : [EOL] message_ids . append ( m . id ) [EOL] else : [EOL] return [EOL] else : [EOL] reply_msg = await msg . get_reply_message ( ) [EOL] if event . is_private : [EOL] message_ids = await client . get_messages ( chat , min_id = reply_msg . id , max_id = msg . id ) [EOL] else : [EOL] message_ids = list ( range ( reply_msg . id , msg . id ) ) [EOL] await client . delete_messages ( chat , message_ids ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import utils [EOL] import subprocess [EOL] [EOL] from utils import helpers [EOL] from utils . client import Client [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k , Command [EOL] from utils . tags import Tags [EOL] [EOL] [EOL] @ k . command ( [string] ) async def update ( client , event , tags ) : [EOL] [docstring] [EOL] silent = tags . get ( [string] , False ) [EOL] if not silent : [EOL] progess_message = await client . respond ( event , MDTeXDocument ( Section ( [string] , f' [string] { Code ( [string] ) }' ) ) ) [EOL] else : [EOL] await event . delete ( ) [EOL] subprocess . call ( [ [string] , [string] , [string] ] ) [EOL] new_commit = helpers . get_commit ( ) [EOL] if not silent : [EOL] await progess_message . delete ( ) [EOL] await client . respond ( event , MDTeXDocument ( Section ( [string] , KeyValueItem ( [string] , Link ( new_commit , helpers . link_commit ( new_commit ) ) ) , Italic ( [string] ) ) ) ) [EOL] await client . disconnect ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import datetime [EOL] import telethon [EOL] import utils [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from datetime import datetime , timedelta , timezone [EOL] from typing import Dict [EOL] [EOL] from telethon . errors import FloodWaitError [EOL] from telethon . tl . functions . messages import GetScheduledHistoryRequest , DeleteScheduledMessagesRequest [EOL] from telethon . tl . patched import Message [EOL] from telethon . tl . types import Channel , MessageMediaDocument [EOL] [EOL] from utils import parsers [EOL] from utils . client import Client [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k , Command [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] ) async def schedule ( client , chat , msg , kwargs , event ) : [EOL] [docstring] [EOL] offset = kwargs . get ( [string] , [string] ) [EOL] offset = parsers . time ( offset ) [EOL] dynamic = kwargs . get ( [string] , False ) [EOL] if kwargs . get ( [string] ) : [EOL] scheduled = await client ( GetScheduledHistoryRequest ( chat , [number] ) ) [EOL] scheduled_ids = [ smsg . id for smsg in scheduled . messages ] [EOL] await client ( DeleteScheduledMessagesRequest ( chat , scheduled_ids ) ) [EOL] [EOL] if msg . is_reply : [EOL] reply_msg = await msg . get_reply_message ( ) [EOL] if isinstance ( reply_msg . media , MessageMediaDocument ) : [EOL] commands = ( await reply_msg . download_media ( bytes ) ) . decode ( ) . split ( [string] ) [EOL] else : [EOL] commands = reply_msg . text . split ( [string] ) [EOL] current = datetime . now ( ) [EOL] next_time = current . astimezone ( timezone . utc ) [EOL] next_time += timedelta ( minutes = [number] ) [EOL] from_time = next_time [EOL] for cmd in commands : [EOL] if cmd : [EOL] if dynamic : [EOL] offset = ( len ( cmd . split ( ) ) ** [number] ) * [number] [EOL] try : [EOL] await client . send_message ( chat , cmd , schedule = next_time ) [EOL] except FloodWaitError as err : [EOL] await msg . edit ( f' [string] { err . seconds } [string] ' ) [EOL] await asyncio . sleep ( err . seconds ) [EOL] [EOL] next_time += timedelta ( seconds = offset ) [EOL] await asyncio . sleep ( [number] ) [EOL] await event . delete ( ) [EOL] return MDTeXDocument ( Section ( [string] , KeyValueItem ( Bold ( [string] ) , from_time . astimezone ( current . tzinfo ) . strftime ( [string] ) ) , KeyValueItem ( Bold ( [string] ) , next_time . astimezone ( current . tzinfo ) . strftime ( [string] ) ) , KeyValueItem ( Bold ( [string] ) , Code ( len ( commands ) ) ) ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import _csv [EOL] import telethon [EOL] import utils [EOL] import logging [EOL] import codecs [EOL] import typing [EOL] import builtins [EOL] import io [EOL] import database [EOL] [docstring] [EOL] import codecs [EOL] import csv [EOL] import logging [EOL] import os [EOL] import time [EOL] from io import BytesIO [EOL] [EOL] from spamwatch . types import Ban , Permission [EOL] from telethon . tl . custom import Message [EOL] from telethon . tl . types import DocumentAttributeFilename [EOL] [EOL] from database . database import Database [EOL] from utils import helpers [EOL] from utils . client import Client [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] SWAPI_SLICE_LENGTH = [number] [EOL] [EOL] [EOL] @ k . command ( [string] , [string] ) async def banlist ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] @ banlist . subcommand ( ) async def query ( db , args , kwargs ) : [EOL] [docstring] [EOL] reason = kwargs . get ( [string] ) [EOL] if args : [EOL] users = await db . banlist . get_multiple ( args ) [EOL] query_results = [ KeyValueItem ( Code ( user . id ) , user . reason ) for user in users ] or [ Italic ( [string] ) ] [EOL] elif reason is not None : [EOL] count = await db . banlist . count_reason ( reason ) [EOL] query_results = [ KeyValueItem ( Bold ( [string] ) , Code ( count ) ) ] [EOL] else : [EOL] count = await db . banlist . total_count ( ) [EOL] query_results = [ KeyValueItem ( Bold ( [string] ) , Code ( count ) ) ] [EOL] return MDTeXDocument ( Section ( [string] , * query_results ) ) [EOL] [EOL] [EOL] @ banlist . subcommand ( ) async def import_ ( client , db , msg ) : [EOL] [docstring] [EOL] if msg . is_reply : [comment] [EOL] reply_msg = await msg . get_reply_message ( ) [EOL] _ , ext = os . path . splitext ( reply_msg . document . attributes [ [number] ] . file_name ) [EOL] if ext == [string] : [EOL] data = await reply_msg . download_media ( bytes ) [EOL] start_time = time . time ( ) [EOL] _banlist = await helpers . rose_csv_to_dict ( data ) [EOL] if _banlist : [EOL] await db . banlist . upsert_multiple ( _banlist ) [EOL] if client . sw and client . sw . permission in [ Permission . Admin , Permission . Root ] : [EOL] bans = { } [EOL] for b in _banlist : [EOL] bans [ b [ [string] ] ] = bans . get ( b [ [string] ] , [ ] ) + [ b [ [string] ] ] [EOL] admin_id = ( await client . get_me ( ) ) . id [EOL] for reason , uids in bans . items ( ) : [EOL] uids_copy = uids [ : ] [EOL] while uids_copy : [EOL] client . sw . add_bans ( [ Ban ( int ( uid ) , reason , admin_id ) for uid in uids_copy [ : SWAPI_SLICE_LENGTH ] ] ) [EOL] uids_copy = uids_copy [ SWAPI_SLICE_LENGTH : ] [EOL] [EOL] stop_time = time . time ( ) - start_time [EOL] return MDTeXDocument ( Section ( [string] , f' [string] { len ( _banlist ) } [string] ' ) , Italic ( f' [string] { stop_time : [string] } [string] ' ) ) [EOL] else : [EOL] return MDTeXDocument ( Section ( [string] , [string] ) ) [EOL] [EOL] [EOL] @ banlist . subcommand ( ) async def export ( client , db , chat , msg , kwargs ) : [EOL] [docstring] [EOL] start_time = time . time ( ) [EOL] with_diff = kwargs . get ( [string] , False ) [EOL] [EOL] if with_diff and msg . is_reply : [comment] [EOL] reply_msg = await msg . get_reply_message ( ) [EOL] _ , ext = os . path . splitext ( reply_msg . document . attributes [ [number] ] . file_name ) [EOL] if ext == [string] : [EOL] data = await reply_msg . download_media ( bytes ) [EOL] _banlist = await helpers . rose_csv_to_dict ( data ) [EOL] _banlist = [ u [ [string] ] for u in _banlist ] [EOL] else : [EOL] _banlist = None [EOL] [EOL] if with_diff : [EOL] users = await db . banlist . get_all_not_in ( _banlist ) [EOL] else : [EOL] users = await db . banlist . get_all ( ) [EOL] export = BytesIO ( ) [EOL] wrapper_file = codecs . getwriter ( [string] ) ( export ) [EOL] cwriter = csv . writer ( wrapper_file , lineterminator = [string] ) [EOL] cwriter . writerow ( [ [string] , [string] ] ) [EOL] for user in users : [EOL] cwriter . writerow ( [ user . id , user . reason ] ) [EOL] stop_time = time . time ( ) - start_time [EOL] await client . send_file ( chat , export . getvalue ( ) , attributes = [ DocumentAttributeFilename ( [string] ) ] , caption = str ( Italic ( f' [string] { stop_time : [string] } [string] ' ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Pattern , Dict , Any , Optional [EOL] import telethon [EOL] import utils [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] import database [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import re [EOL] from collections import Counter [EOL] [EOL] import logzero [EOL] from telethon . errors import MessageIdInvalidError [EOL] from telethon . tl . custom import Message [EOL] [EOL] from database . database import Database , ItemDoesNotExistError [EOL] from utils import helpers , constants [EOL] from utils . client import Client [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] logger = logzero . logger [EOL] [EOL] AUTOBAHN_TYPES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [comment] [EOL] MAX_QUERY_ITEMS = [number] [EOL] [EOL] INVITELINK_PATTERN = re . compile ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] , [string] ) async def autobahn ( ) : [EOL] [docstring] [EOL] return MDTeXDocument ( Section ( [string] , * [ KeyValueItem ( Bold ( name ) , Code ( code ) ) for name , code in AUTOBAHN_TYPES . items ( ) ] ) ) [EOL] [EOL] [EOL] @ autobahn . subcommand ( ) async def add ( client , db , msg , args , event ) : [comment] [EOL] [docstring] [EOL] item_type = args [ [number] ] [EOL] items = args [ [number] : ] [EOL] added_items = [ ] [EOL] existing_items = [ ] [EOL] skipped_items = [ ] [EOL] hex_type = AUTOBAHN_TYPES . get ( item_type ) [EOL] blacklist = await db . blacklists . get ( hex_type ) [EOL] warn_message = [string] [EOL] [EOL] for item in items : [comment] [EOL] if hex_type is None or blacklist is None : [EOL] continue [EOL] if hex_type == [string] : [EOL] _item = item [EOL] _ , chat_id , _ = await helpers . resolve_invite_link ( item ) [EOL] item = chat_id [EOL] if item is None : [EOL] if _item . startswith ( [string] ) : [EOL] [comment] [EOL] params = re . split ( [string] , _item ) [ [number] : ] [EOL] for param in params : [EOL] if param . startswith ( [string] ) : [EOL] _ , _item = param . split ( [string] ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] _item = _item . split ( [string] ) [ [number] ] . replace ( [string] , [string] ) [EOL] try : [EOL] entity = await event . client . get_entity ( _item ) [EOL] except constants . GET_ENTITY_ERRORS as err : [EOL] logger . error ( err ) [EOL] skipped_items . append ( _item ) [EOL] continue [EOL] if entity : [EOL] item = entity . id [EOL] elif hex_type == [string] : [EOL] item = ( await client . resolve_url ( item ) ) . lower ( ) [EOL] if item in constants . TELEGRAM_DOMAINS : [EOL] skipped_items . append ( item ) [EOL] continue [EOL] elif hex_type == [string] : [EOL] item = item . replace ( [string] , [string] ) [EOL] [comment] [EOL] if item is None : [EOL] skipped_items . append ( item ) [EOL] continue [EOL] existing_one = await blacklist . get_by_value ( item ) [EOL] if not existing_one : [EOL] entry = await blacklist . add ( item ) [EOL] added_items . append ( KeyValueItem ( entry . index , Code ( entry . value ) ) ) [EOL] else : [EOL] existing_items . append ( KeyValueItem ( existing_one . index , Code ( existing_one . value ) ) ) [EOL] [EOL] if not items and hex_type == [string] : [EOL] if msg . is_reply : [EOL] reply_msg = await msg . get_reply_message ( ) [EOL] if reply_msg . file : [EOL] await msg . edit ( [string] ) [EOL] [EOL] file = await reply_msg . download_media ( bytes , progress_callback = lambda r , t : _sync_file_callback ( r , t , msg ) ) [EOL] file_hash = helpers . hash_file ( file ) [EOL] await msg . delete ( ) [EOL] existing_one = await blacklist . get ( item ) [EOL] [EOL] if not existing_one : [EOL] entry = await blacklist . add ( file_hash ) [EOL] short_hash = f'{ entry . value [ : [number] ] } [string] ' [EOL] KeyValueItem ( entry . index , Code ( short_hash ) ) [EOL] else : [EOL] existing_items . append ( KeyValueItem ( existing_one . index , Code ( existing_one . value ) ) ) [EOL] else : [EOL] return MDTeXDocument ( Section ( [string] , [string] ) ) [EOL] else : [EOL] return MDTeXDocument ( Section ( [string] , [string] ) ) [EOL] if not items and hex_type == [string] : [EOL] if msg . is_reply : [EOL] reply_msg = await msg . get_reply_message ( ) [EOL] if reply_msg . photo : [EOL] await msg . edit ( [string] ) [EOL] [EOL] dl_photo = await reply_msg . download_media ( bytes ) [EOL] photo_hash = await helpers . hash_photo ( dl_photo ) [EOL] await msg . delete ( ) [EOL] existing_one = await blacklist . get_by_value ( photo_hash ) [EOL] [EOL] if not existing_one : [EOL] entry = await blacklist . add ( photo_hash ) [EOL] if Counter ( photo_hash ) . get ( [string] , [number] ) > [number] : [EOL] warn_message = ( [string] [string] ) [EOL] [EOL] added_items . append ( KeyValueItem ( entry . index , Code ( entry . value ) ) ) [EOL] else : [EOL] existing_items . append ( KeyValueItem ( existing_one . index , Code ( existing_one . value ) ) ) [EOL] else : [EOL] return MDTeXDocument ( Section ( [string] , [string] ) ) [EOL] else : [EOL] return MDTeXDocument ( Section ( [string] , [string] ) ) [EOL] [EOL] return MDTeXDocument ( Section ( [string] , SubSection ( item_type , * added_items ) ) if added_items else [string] , Section ( [string] , SubSection ( item_type , * existing_items ) ) if existing_items else [string] , Section ( [string] , SubSection ( item_type , * skipped_items ) ) if skipped_items else [string] , Section ( [string] , warn_message ) if warn_message else [string] ) [EOL] [EOL] [EOL] @ autobahn . subcommand ( ) async def del_ ( db , args ) : [EOL] [docstring] [EOL] item_type = args [ [number] ] [EOL] items = args [ [number] : ] [EOL] removed_items = [ ] [EOL] skipped_items = [ ] [EOL] for item in items : [EOL] hex_type = AUTOBAHN_TYPES . get ( item_type ) [EOL] blacklist = await db . blacklists . get ( hex_type ) [EOL] if hex_type is None or blacklist is None : [EOL] continue [EOL] [EOL] if hex_type == [string] : [EOL] _ , chat_id , _ = await helpers . resolve_invite_link ( str ( item ) ) [EOL] item = chat_id [EOL] [EOL] try : [EOL] await blacklist . retire ( item ) [EOL] removed_items . append ( Code ( item ) ) [EOL] except ItemDoesNotExistError : [EOL] skipped_items . append ( Code ( item ) ) [EOL] [EOL] return MDTeXDocument ( Section ( [string] , SubSection ( item_type , * removed_items ) ) if removed_items else None , Section ( [string] , SubSection ( item_type , * skipped_items ) ) if skipped_items else None ) [EOL] [EOL] [EOL] @ autobahn . subcommand ( ) async def query ( args , kwargs , db ) : [EOL] [docstring] [EOL] item_type = kwargs . get ( [string] ) [EOL] code = kwargs . get ( [string] ) [EOL] if item_type is None and args : [EOL] item_type = args [ [number] ] [EOL] else : [EOL] return MDTeXDocument ( Section ( [string] , Italic ( [string] ) ) ) [EOL] if code is None and len ( args ) > [number] : [EOL] code = args [ [number] ] [EOL] [EOL] hex_type = None [EOL] blacklist = None [EOL] if item_type is not None : [EOL] hex_type = AUTOBAHN_TYPES . get ( item_type , item_type ) [EOL] blacklist = await db . blacklists . get ( hex_type ) [EOL] [EOL] blacklist_items = await blacklist . get_all ( ) [EOL] [EOL] if code is not None : [EOL] if isinstance ( code , int ) : [EOL] code = [ code ] [EOL] all_items = await blacklist . get_indices ( list ( code ) [ : MAX_QUERY_ITEMS ] ) [EOL] else : [EOL] all_items = blacklist_items [EOL] items = [ KeyValueItem ( Bold ( item . index ) , Code ( item . value ) ) for item in all_items [ : MAX_QUERY_ITEMS ] ] [EOL] [EOL] return MDTeXDocument ( Section ( f' [string] { item_type } [string] { hex_type } [string] ' , * items or [ Italic ( [string] ) ] ) , Italic ( f' [string] { len ( blacklist_items ) }' ) if blacklist_items else None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ autobahn . subcommand ( ) async def count ( db ) : [EOL] [docstring] [EOL] sec = Section ( [string] ) [EOL] for hextype , blacklist in db . blacklists . _map . items ( ) : [EOL] name = f'{ blacklist . __class__ . __name__ . replace ( [string] , [string] ) } [string] { Code ( hextype ) } [string] ' [EOL] sec . append ( KeyValueItem ( name , len ( await blacklist . get_all ( ) ) ) ) [EOL] [EOL] return MDTeXDocument ( sec ) [EOL] [EOL] [EOL] def _sync_file_callback ( received , total , msg ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . create_task ( _file_callback ( received , total , msg ) ) [EOL] [comment] [EOL] [EOL] [EOL] async def _file_callback ( received , total , msg ) : [EOL] text = MDTeXDocument ( Section ( [string] , KeyValueItem ( [string] , f'{ received / [number] ** [number] : [string] } [string] { total / [number] ** [number] : [string] } [string] ' f' [string] { ( received / total ) * [number] : [string] } [string] ' ) ) ) [EOL] try : [EOL] await msg . edit ( str ( text ) ) [EOL] except MessageIdInvalidError as err : [EOL] logger . error ( err ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any [EOL] import telethon [EOL] import utils [EOL] import logging [EOL] import typing [EOL] import database [EOL] [docstring] [EOL] import asyncio [EOL] import itertools [EOL] import logging [EOL] [EOL] import logzero [EOL] from PIL import UnidentifiedImageError [EOL] from photohash import hashes_are_similar [EOL] from telethon import events [EOL] from telethon . errors import UserNotParticipantError , ChannelPrivateError [EOL] from telethon . events import ChatAction , NewMessage [EOL] from telethon . tl . custom import Message [EOL] from telethon . tl . custom import MessageButton [EOL] from telethon . tl . functions . channels import DeleteUserHistoryRequest , GetParticipantRequest [EOL] from telethon . tl . functions . users import GetFullUserRequest [EOL] from telethon . tl . types import ( Channel , MessageEntityTextUrl , UserFull , MessageEntityUrl , MessageEntityMention , ChannelParticipantsAdmins , ChannelParticipantAdmin ) [EOL] [EOL] from database . database import Database [EOL] from utils import helpers , constants [EOL] from utils . client import Client [EOL] from utils . helpers import hash_photo [EOL] from utils . pluginmgr import k [EOL] from utils . tags import Tags [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] logger = logzero . logger [EOL] [EOL] [EOL] @ k . event ( events . MessageEdited ( outgoing = False ) ) @ k . event ( events . NewMessage ( outgoing = False ) , name = [string] ) async def polizei ( event ) : [EOL] [docstring] [EOL] if event . is_private : [EOL] return [EOL] client = event . client [EOL] chat = await event . get_chat ( ) [EOL] tags = await Tags . create ( event ) [EOL] bancmd = tags . get ( [string] , [string] ) [EOL] polizei_tag = tags . get ( [string] ) [EOL] if polizei_tag == [string] : [EOL] return [EOL] ban_type , ban_reason = await _check_message ( event ) [EOL] if ban_type and ban_reason : [EOL] uid = event . message . from_id [EOL] admins = [ p . id for p in await client . get_participants ( event . chat_id , filter = ChannelParticipantsAdmins ( ) ) ] [EOL] if uid not in admins : [EOL] await _banuser ( event , chat , uid , bancmd , ban_type , ban_reason ) [EOL] [EOL] [EOL] @ k . event ( events . chataction . ChatAction ( ) ) async def join_polizei ( event ) : [EOL] [docstring] [EOL] [comment] [EOL] if not event . user_joined : [EOL] return [EOL] client = event . client [EOL] chat = await event . get_chat ( ) [EOL] db = client . db [EOL] tags = await Tags . create ( event ) [EOL] bancmd = tags . get ( [string] ) [EOL] polizei_tag = tags . get ( [string] ) [EOL] if polizei_tag == [string] : [EOL] return [EOL] ban_type , ban_reason = False , False [EOL] bio_blacklist = await db . blacklists . bio . get_all ( ) [EOL] mhash_blacklist = await db . blacklists . mhash . get_all ( ) [EOL] [EOL] try : [EOL] user = await client ( GetFullUserRequest ( await event . get_input_user ( ) ) ) [EOL] except TypeError as e : [EOL] logger . error ( e ) [EOL] return [EOL] [EOL] for item in bio_blacklist : [EOL] if user . about and item . value in user . about and not item . retired : [EOL] ban_type , ban_reason = db . blacklists . bio . hex_type , item . index [EOL] [EOL] if user . profile_photo : [EOL] try : [EOL] dl_photo = await client . download_file ( user . profile_photo ) [EOL] except constants . DOWNLOAD_ERRORS : [EOL] dl_photo = None [EOL] if dl_photo : [EOL] photo_hash = await hash_photo ( dl_photo ) [EOL] [EOL] for mhash in mhash_blacklist : [EOL] if mhash and not mhash . retired : [EOL] if hashes_are_similar ( mhash . value , photo_hash , tolerance = [number] ) : [EOL] ban_type , ban_reason = db . blacklists . mhash . hex_type , mhash . index [EOL] [EOL] if ban_type and ban_reason : [EOL] await _banuser ( event , chat , event . user_id , bancmd , ban_type , ban_reason ) [EOL] [EOL] [EOL] async def _banuser ( event , chat , userid , bancmd , ban_type , ban_reason ) : [EOL] formatted_reason = f' [string] { ban_type } [string] { ban_reason . rjust ( [number] , [string] ) } [string] ' [EOL] client = event . client [EOL] db = client . db [EOL] chat = await event . get_chat ( ) [EOL] admin = chat . creator or chat . admin_rights [EOL] await event . delete ( ) [EOL] old_ban = await db . banlist . get ( userid ) [EOL] if old_ban : [EOL] if old_ban . reason == formatted_reason : [EOL] logger . info ( [string] , userid ) [EOL] return [EOL] if admin : [EOL] if bancmd == [string] : [EOL] await client . ban ( chat , userid ) [EOL] elif bancmd is not None : [EOL] await client . respond ( event , f'{ bancmd } [string] { userid } [string] { formatted_reason }' ) [EOL] await asyncio . sleep ( [number] ) [EOL] await client . gban ( userid , formatted_reason , await helpers . textify_message ( event . message ) ) [EOL] [EOL] message_count = len ( await client . get_messages ( chat , from_user = userid , limit = [number] ) ) [EOL] if admin and message_count <= [number] : [EOL] await client ( DeleteUserHistoryRequest ( chat , userid ) ) [EOL] [EOL] [EOL] async def _check_message ( event ) : [comment] [EOL] client = event . client [EOL] msg = event . message [EOL] user_id = msg . from_id [EOL] if user_id is None : [EOL] return False , False [EOL] [comment] [EOL] if user_id and user_id < [number] : [EOL] return False , False [EOL] try : [EOL] result = await client ( GetParticipantRequest ( event . chat_id , user_id ) ) [EOL] if isinstance ( result . participant , ChannelParticipantAdmin ) : [EOL] return False , False [EOL] except ( ValueError , UserNotParticipantError ) : [EOL] return False , False [EOL] [EOL] [comment] [EOL] user = await client . get_cached_entity ( user_id ) [EOL] if user is None or user . bot : [EOL] return False , False [EOL] [EOL] [comment] [EOL] [comment] [EOL] blacklisting_commands = [ [string] , ] [EOL] [EOL] for cmd in blacklisting_commands : [EOL] if msg . text and msg . text . startswith ( cmd ) : [EOL] return False , False [EOL] [EOL] db = client . db [EOL] [comment] [EOL] [EOL] inline_bot = msg . via_bot_id [EOL] if inline_bot is not None : [EOL] result = await db . blacklists . channel . get_by_value ( inline_bot ) [EOL] if result : [EOL] return db . blacklists . channel . hex_type , result . index [EOL] [EOL] if msg . buttons : [EOL] _buttons = await msg . get_buttons ( ) [EOL] button = ... [EOL] for button in itertools . chain . from_iterable ( _buttons ) : [EOL] if button . url : [EOL] _ , chat_id , _ = await helpers . resolve_invite_link ( button . url ) [EOL] result = await db . blacklists . channel . get_by_value ( chat_id ) [EOL] if result : [EOL] return db . blacklists . channel . hex_type , result . index [EOL] [EOL] domain = await client . resolve_url ( button . url ) [EOL] result = await db . blacklists . domain . get_by_value ( domain ) [EOL] if result : [EOL] return db . blacklists . domain . hex_type , result . index [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] face_domain = await helpers . netloc ( button . url ) [EOL] result = await db . blacklists . domain . get_by_value ( face_domain ) [EOL] if result : [EOL] return db . blacklists . domain . hex_type , result . index [EOL] [EOL] elif domain in constants . TELEGRAM_DOMAINS : [EOL] _entity = await client . get_cached_entity ( domain ) [EOL] if _entity : [EOL] result = await db . blacklists . channel . get_by_value ( _entity ) [EOL] if result : [EOL] return db . blacklists . channel . hex_type , result . index [EOL] [EOL] entities = msg . get_entities_text ( ) [EOL] for entity , text in entities : [comment] [EOL] _ , chat_id , _ = await helpers . resolve_invite_link ( text ) [EOL] result = await db . blacklists . channel . get_by_value ( chat_id ) [EOL] if result : [EOL] return db . blacklists . channel . hex_type , result . index [EOL] [EOL] domain = [string] [EOL] face_domain = [string] [EOL] channel = [string] [EOL] _entity = None [EOL] if isinstance ( entity , MessageEntityUrl ) : [EOL] domain = await client . resolve_url ( text ) [EOL] face_domain = await helpers . netloc ( text ) [EOL] if domain in constants . TELEGRAM_DOMAINS : [EOL] [comment] [EOL] [comment] [EOL] url = await client . resolve_url ( text , base_domain = False ) [EOL] username = url . split ( [string] ) [ [number] ] . replace ( [string] , [string] ) [EOL] _entity = username [EOL] [EOL] elif isinstance ( entity , MessageEntityTextUrl ) : [EOL] domain = await client . resolve_url ( entity . url ) [EOL] face_domain = await helpers . netloc ( entity . url ) [EOL] if domain in constants . TELEGRAM_DOMAINS : [EOL] url = await client . resolve_url ( entity . url , base_domain = False ) [EOL] username = url . split ( [string] ) [ [number] ] . replace ( [string] , [string] ) [EOL] _entity = username [EOL] [EOL] elif isinstance ( entity , MessageEntityMention ) : [EOL] _entity = text [EOL] [EOL] if _entity : [EOL] try : [EOL] full_entity = await client . get_cached_entity ( _entity ) [EOL] if full_entity : [EOL] channel = full_entity . id [EOL] try : [EOL] profile_photo = await client . download_profile_photo ( full_entity , bytes ) [EOL] except constants . DOWNLOAD_ERRORS : [EOL] profile_photo = None [EOL] if profile_photo : [EOL] try : [EOL] photo_hash = await hash_photo ( profile_photo ) [EOL] for mhash in await db . blacklists . mhash . get_all ( ) : [EOL] if mhash and not mhash . retired : [EOL] if hashes_are_similar ( mhash . value , photo_hash , tolerance = [number] ) : [EOL] return db . blacklists . mhash . hex_type , mhash . index [EOL] except UnidentifiedImageError : [EOL] pass [EOL] [EOL] except ( * constants . GET_ENTITY_ERRORS , ChannelPrivateError ) : [EOL] pass [EOL] [EOL] [comment] [EOL] if not face_domain : [EOL] face_domain = await helpers . netloc ( f' [string] { domain }' ) [EOL] [EOL] if domain : [EOL] result = await db . blacklists . domain . get_by_value ( domain ) [EOL] if result : [EOL] return db . blacklists . domain . hex_type , result . index [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if face_domain : [EOL] result = await db . blacklists . domain . get_by_value ( face_domain ) [EOL] if result : [EOL] return db . blacklists . domain . hex_type , result . index [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if channel : [EOL] result = await db . blacklists . channel . get_by_value ( channel ) [EOL] if result : [EOL] return db . blacklists . channel . hex_type , result . index [EOL] [EOL] for string in await db . blacklists . string . get_all ( ) : [EOL] if string . value in msg . raw_text : [EOL] return db . blacklists . string . hex_type , string . index [EOL] [EOL] if msg . file : [EOL] [comment] [EOL] ten_mib = ( [number] ** [number] ) * [number] [EOL] [comment] [EOL] if msg . document and msg . file . size < ten_mib : [EOL] try : [EOL] dl_file = await msg . download_media ( bytes ) [EOL] except constants . DOWNLOAD_ERRORS : [EOL] dl_file = None [EOL] if dl_file : [EOL] filehash = helpers . hash_file ( dl_file ) [EOL] result = await db . blacklists . file . get_by_value ( filehash ) [EOL] if result : [EOL] return db . blacklists . file . hex_type , result . index [EOL] else : [EOL] pass [EOL] [EOL] if msg . photo : [EOL] try : [EOL] dl_photo = await msg . download_media ( bytes ) [EOL] except constants . DOWNLOAD_ERRORS : [EOL] dl_photo = None [EOL] if dl_photo : [EOL] try : [EOL] photo_hash = await hash_photo ( dl_photo ) [EOL] except UnidentifiedImageError : [EOL] photo_hash = None [EOL] if photo_hash : [EOL] for mhash in await db . blacklists . mhash . get_all ( ) : [EOL] if hashes_are_similar ( mhash . value , photo_hash , tolerance = [number] ) : [EOL] return db . blacklists . mhash . hex_type , mhash . index [EOL] [EOL] return False , False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import telethon [EOL] import utils [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import logzero [EOL] from telethon import events [EOL] from telethon . errors import UserNotParticipantError [EOL] from telethon . events import ChatAction [EOL] from telethon . tl . functions . channels import ( DeleteUserHistoryRequest , GetParticipantRequest ) [EOL] from telethon . tl . types import ( Channel , User , ChannelAdminLogEventActionParticipantLeave , ChannelAdminLogEventActionParticipantJoin ) [EOL] [EOL] from utils . client import Client [EOL] from utils . constants import GET_ENTITY_ERRORS [EOL] from utils . pluginmgr import k [EOL] from utils . tags import Tags [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] logger = logzero . logger [EOL] [EOL] [EOL] @ k . event ( events . chataction . ChatAction ( ) , name = [string] ) async def kriminalamt ( event ) : [EOL] [docstring] [EOL] client = event . client [EOL] chat = await event . get_chat ( ) [EOL] user = await event . get_user ( ) [EOL] tags = await Tags . create ( event ) [EOL] enabled = tags . get ( [string] , False ) [EOL] bancmd = tags . get ( [string] , [string] ) [EOL] delay = [number] [EOL] if not event . user_joined or not ( chat . creator or chat . admin_rights ) : [EOL] return [EOL] [EOL] if not enabled or user . bot : [EOL] return [EOL] [EOL] await asyncio . sleep ( delay ) [EOL] [EOL] try : [EOL] await client ( GetParticipantRequest ( chat , user ) ) [EOL] except GET_ENTITY_ERRORS : [EOL] return [EOL] except UserNotParticipantError : [EOL] userid = event . user_id [EOL] leave_event = None [EOL] async for e in client . iter_admin_log ( chat , join = True , leave = True ) : [EOL] if e . user_id == userid : [EOL] if isinstance ( e . action , ChannelAdminLogEventActionParticipantLeave ) : [EOL] leave_event = e [EOL] elif isinstance ( e . action , ChannelAdminLogEventActionParticipantJoin ) : [EOL] if leave_event and e . date < leave_event . date : [EOL] diff = leave_event . date - e . date [EOL] if diff . seconds > delay : [EOL] return [EOL] if leave_event is None : [EOL] return [EOL] reason = f' [string] { chat . id } [string] { delay }' [EOL] await client . gban ( userid , reason ) [EOL] if bancmd == [string] : [EOL] await client . ban ( chat , userid ) [EOL] elif bancmd is not None : [EOL] await event . reply ( f'{ bancmd } [string] { userid } [string] { reason }' ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] messages = await client . get_messages ( chat , from_user = userid , limit = [number] ) [EOL] if messages . total <= [number] : [EOL] await client ( DeleteUserHistoryRequest ( chat , userid ) ) [EOL] else : [EOL] await event . delete ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import telethon [EOL] import utils [EOL] [docstring] [EOL] import logging [EOL] [EOL] from telethon import events [EOL] from telethon . events import NewMessage [EOL] [EOL] from utils . client import Client [EOL] from utils . pluginmgr import k [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . event ( events . NewMessage ( ) ) async def add_groups ( event ) : [EOL] [docstring] [EOL] if event . is_private : [EOL] return [EOL] client = event . client [EOL] await client . db . chats . get ( event . chat_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import telethon [EOL] import utils [EOL] [docstring] [EOL] import logging [EOL] [EOL] from telethon . errors import ChatNotModifiedError [EOL] from telethon . tl . functions . messages import EditChatDefaultBannedRightsRequest [EOL] from telethon . tl . types import ChatBannedRights , InputPeerChannel [EOL] [EOL] from utils . client import Client [EOL] from utils . mdtex import * [EOL] from utils . pluginmgr import k , Command [EOL] [EOL] tlog = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] @ k . command ( [string] , admins = True ) async def lock ( client , event ) : [EOL] [docstring] [EOL] chat = await event . get_input_chat ( ) [EOL] try : [EOL] await client ( EditChatDefaultBannedRightsRequest ( chat , banned_rights = ChatBannedRights ( until_date = None , view_messages = None , send_messages = True , send_media = True , send_stickers = True , send_gifs = True , send_games = True , send_inline = True , send_polls = True , change_info = True , invite_users = True , pin_messages = True ) ) ) [EOL] return MDTeXDocument ( [string] ) [EOL] except ChatNotModifiedError : [EOL] return MDTeXDocument ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0