[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] import lists [EOL] from typing import List [EOL] [EOL] [EOL] class Node : [EOL] [docstring] [EOL] def __init__ ( self , data = None ) : [EOL] self . data = data [EOL] self . next = None [EOL] [EOL] [EOL] class LinkedList : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . head = Node ( ) [EOL] [EOL] def append ( self , data ) : [EOL] [comment] [EOL] new_node = Node ( data ) [EOL] current_node = self . head [EOL] while current_node . next is not None : [EOL] current_node = current_node . next [EOL] current_node . next = new_node [EOL] [comment] [EOL] [EOL] def length ( self ) : [EOL] current_node = self . head [EOL] total_nodes = [number] [EOL] while current_node . next is not None : [EOL] total_nodes += [number] [EOL] current_node = current_node . next [EOL] return total_nodes [EOL] [EOL] def display ( self ) : [EOL] [docstring] [EOL] elements = [ ] [EOL] current_node = self . head [EOL] while current_node . next is not None : [EOL] current_node = current_node . next [EOL] elements . append ( current_node . data ) [EOL] return elements [EOL] [EOL] def get ( self , index ) : [EOL] [comment] [EOL] if index >= self . length ( ) : [EOL] raise IndexError ( [string] ) [EOL] current_index = [number] [EOL] current_node = self . head [EOL] while True : [EOL] [comment] [EOL] current_node = current_node . next [EOL] if current_index == index : [EOL] return current_node . data [EOL] current_index += [number] [EOL] [EOL] def remove ( self , index ) : [EOL] if index >= self . length ( ) : [EOL] raise IndexError ( [string] ) [EOL] current_index = [number] [EOL] current_node = self . head [EOL] while True : [EOL] last_node = current_node [EOL] current_node = current_node . next [EOL] if current_index == index : [EOL] last_node . next = current_node . next [EOL] return [number] [EOL] current_index += [number] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] ll = LinkedList ( ) [EOL] ll . append ( [number] ) [EOL] ll . append ( [number] ) [EOL] ll . append ( [number] ) [EOL] ll . append ( [number] ) [EOL] [EOL] print ( [string] , ll . display ( ) ) [EOL] print ( [string] , ll . length ( ) ) [EOL] [EOL] ll . remove ( [number] ) [EOL] print ( [string] , ll . display ( ) ) [EOL] print ( [string] , ll . length ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $linked-lists.linked_list.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $linked-lists.linked_list.Node$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def bubblesort ( l ) : [EOL] changes = True [EOL] pass_num = len ( l ) - [number] [EOL] while pass_num > [number] and changes : [EOL] changes = False [EOL] for index in range ( pass_num ) : [EOL] if l [ index ] > l [ index + [number] ] : [EOL] changes = True [EOL] tmp = l [ index ] [EOL] l [ index ] = l [ index + [number] ] [EOL] l [ index + [number] ] = tmp [EOL] pass_num = pass_num - [number] [EOL] return l [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( bubblesort ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def expand_list ( mylist ) : [EOL] for item in mylist : [EOL] print ( item ) [EOL] return [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] expand_list ( [ [number] , [number] , [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] class file_manager : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename , open_as ) : [EOL] self . file_object = open ( filename , open_as ) [EOL] [EOL] def __enter__ ( self ) : [EOL] return self . file_object [EOL] [EOL] def __exit__ ( self , type , value , traceback ) : [EOL] self . file_object . close ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with file_manager ( [string] , [string] ) as f : [EOL] f . write ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] import builtins [EOL] import binary_search_trees [EOL] class Node : [EOL] def __init__ ( self , value = None ) : [EOL] self . value = value [EOL] self . left_child = None [EOL] self . right_child = None [EOL] [EOL] [EOL] class BST : [EOL] def __init__ ( self ) : [EOL] self . root = None [EOL] [EOL] def insert ( self , value ) : [EOL] if self . root is None : [EOL] [comment] [EOL] self . root = Node ( value ) [EOL] else : [EOL] [comment] [EOL] self . _insert ( value , self . root ) [EOL] [EOL] def _insert ( self , value , current_node ) : [EOL] if value < current_node . value : [EOL] [comment] [EOL] if current_node . left_child is None : [EOL] [comment] [EOL] current_node . left_child = Node ( value ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] self . _insert ( value , current_node . left_child ) [EOL] elif value > current_node . value : [EOL] [comment] [EOL] if current_node . right_child is None : [EOL] current_node . right_child = Node ( value ) [EOL] else : [EOL] self . _insert ( value , current_node . right_child ) [EOL] else : [EOL] [comment] [EOL] print ( [string] ) [EOL] [EOL] def print_tree ( self ) : [EOL] if self . root is not None : [EOL] self . _print_tree ( self . root ) [EOL] [EOL] def _print_tree ( self , current_node ) : [EOL] if current_node is not None : [EOL] self . _print_tree ( current_node . left_child ) [EOL] print ( f" [string] { current_node . value }" ) [EOL] self . _print_tree ( current_node . right_child ) [EOL] [EOL] def height ( self ) : [EOL] if self . root is not None : [EOL] return self . _height ( self . root , [number] ) [EOL] else : [EOL] return [number] [EOL] [EOL] def _height ( self , current_node , current_height ) : [EOL] if current_node is None : [EOL] return current_height [EOL] left_height = self . _height ( current_node . left_child , current_height + [number] ) [EOL] right_height = self . _height ( current_node . right_child , current_height + [number] ) [EOL] return max ( left_height , right_height ) [EOL] [EOL] def search ( self , value ) : [EOL] if self . root is not None : [EOL] return self . _search ( value , self . root ) [EOL] else : [EOL] return False [EOL] [EOL] def _search ( self , value , current_node ) : [EOL] if value == current_node . value : [EOL] return True [EOL] elif value < current_node . value and current_node . left_child is not None : [EOL] return self . _search ( value , current_node . left_child ) [EOL] elif value > current_node . value and current_node . right_child is not None : [EOL] return self . _search ( value , current_node . right_child ) [EOL] return False [EOL] [EOL] [EOL] def fill_tree ( tree , num_elems = [number] , max_int = [number] ) : [EOL] from random import randint [EOL] for x in range ( num_elems ) : [EOL] current_elem = randint ( [number] , max_int ) [EOL] tree . insert ( current_elem ) [EOL] return tree [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] tree = BST ( ) [EOL] [comment] [EOL] tree . insert ( [number] ) [EOL] tree . insert ( [number] ) [EOL] tree . insert ( [number] ) [EOL] tree . insert ( [number] ) [EOL] tree . insert ( [number] ) [EOL] tree . insert ( [number] ) [EOL] tree . insert ( [number] ) [EOL] tree . insert ( [number] ) [EOL] tree . insert ( [number] ) [EOL] tree . print_tree ( ) [EOL] print ( f" [string] { tree . height ( ) }" ) [EOL] print ( tree . search ( [number] ) ) [EOL] print ( tree . search ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0