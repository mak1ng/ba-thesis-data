[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import homeassistant [EOL] import builtins [EOL] import threading [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] import functools [EOL] import socket [EOL] import threading [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . helpers . event import track_point_in_utc_time [EOL] from homeassistant . util import dt as dt_util [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( EVENT_HOMEASSISTANT_START , EVENT_HOMEASSISTANT_STOP , CONF_HOST , CONF_PORT , CONF_WHITELIST , CONF_PROTOCOL ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_SEND_DELAY = [string] [EOL] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_SEND_DELAY = [number] [EOL] DOMAIN = [string] [EOL] [EOL] EVENT = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] RF_CODE_SCHEMA = vol . Schema ( { vol . Required ( CONF_PROTOCOL ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] SERVICE_NAME = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_WHITELIST , default = { } ) : { cv . string : [ cv . string ] } , vol . Optional ( CONF_SEND_DELAY , default = DEFAULT_SEND_DELAY ) : vol . Coerce ( float ) , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] from pilight import pilight [EOL] [EOL] host = config [ DOMAIN ] [ CONF_HOST ] [EOL] port = config [ DOMAIN ] [ CONF_PORT ] [EOL] send_throttler = CallRateDelayThrottle ( hass , config [ DOMAIN ] [ CONF_SEND_DELAY ] ) [EOL] [EOL] try : [EOL] pilight_client = pilight . Client ( host = host , port = port ) [EOL] except ( socket . error , socket . timeout ) as err : [EOL] _LOGGER . error ( [string] , host , port , err ) [EOL] return False [EOL] [EOL] def start_pilight_client ( _ ) : [EOL] [docstring] [EOL] pilight_client . start ( ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , start_pilight_client ) [EOL] [EOL] def stop_pilight_client ( _ ) : [EOL] [docstring] [EOL] pilight_client . stop ( ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , stop_pilight_client ) [EOL] [EOL] @ send_throttler . limited def send_code ( call ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] message_data = dict ( call . data ) [EOL] [EOL] try : [EOL] pilight_client . send_code ( message_data ) [EOL] except IOError : [EOL] _LOGGER . error ( [string] , str ( message_data ) ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_NAME , send_code , schema = RF_CODE_SCHEMA ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] whitelist = config [ DOMAIN ] . get ( CONF_WHITELIST ) [EOL] [EOL] def handle_received_code ( data ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] data = dict ( { [string] : data [ [string] ] , [string] : data [ [string] ] } , ** data [ [string] ] ) [EOL] [EOL] [comment] [EOL] if not whitelist : [EOL] hass . bus . fire ( EVENT , data ) [EOL] [comment] [EOL] elif all ( str ( data [ key ] ) in whitelist [ key ] for key in whitelist ) : [EOL] hass . bus . fire ( EVENT , data ) [EOL] [EOL] pilight_client . set_callback ( handle_received_code ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class CallRateDelayThrottle : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , delay_seconds ) : [EOL] [docstring] [EOL] self . _delay = timedelta ( seconds = max ( [number] , delay_seconds ) ) [EOL] self . _queue = [ ] [EOL] self . _active = False [EOL] self . _lock = threading . Lock ( ) [EOL] self . _next_ts = dt_util . utcnow ( ) [EOL] self . _schedule = functools . partial ( track_point_in_utc_time , hass ) [EOL] [EOL] def limited ( self , method ) : [EOL] [docstring] [EOL] @ functools . wraps ( method ) def decorated ( * args , ** kwargs ) : [EOL] [docstring] [EOL] if self . _delay . total_seconds ( ) == [number] : [EOL] method ( * args , ** kwargs ) [EOL] return [EOL] [EOL] def action ( event ) : [EOL] [docstring] [EOL] method ( * args , ** kwargs ) [EOL] [EOL] with self . _lock : [EOL] self . _next_ts = dt_util . utcnow ( ) + self . _delay [EOL] [EOL] if not self . _queue : [EOL] self . _active = False [EOL] else : [EOL] next_action = self . _queue . pop ( [number] ) [EOL] self . _schedule ( next_action , self . _next_ts ) [EOL] [EOL] with self . _lock : [EOL] if self . _active : [EOL] self . _queue . append ( action ) [EOL] else : [EOL] self . _active = True [EOL] schedule_ts = max ( dt_util . utcnow ( ) , self . _next_ts ) [EOL] self . _schedule ( action , schedule_ts ) [EOL] [EOL] return decorated [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
import builtins [EOL] from typing import Union , Any , Dict , List [EOL] import threading [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import threading [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( EVENT_HOMEASSISTANT_START , EVENT_HOMEASSISTANT_STOP , CONF_HOST , CONF_METHOD , CONF_PORT , CONF_TYPE , CONF_TIMEOUT , ATTR_STATE ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] [comment] [EOL] CONF_BAUDRATE = [string] [EOL] CONF_BYTESIZE = [string] [EOL] CONF_STOPBITS = [string] [EOL] CONF_PARITY = [string] [EOL] [EOL] SERIAL_SCHEMA = { vol . Required ( CONF_BAUDRATE ) : cv . positive_int , vol . Required ( CONF_BYTESIZE ) : vol . Any ( [number] , [number] , [number] , [number] ) , vol . Required ( CONF_METHOD ) : vol . Any ( [string] , [string] ) , vol . Required ( CONF_PORT ) : cv . string , vol . Required ( CONF_PARITY ) : vol . Any ( [string] , [string] , [string] ) , vol . Required ( CONF_STOPBITS ) : vol . Any ( [number] , [number] ) , vol . Required ( CONF_TYPE ) : [string] , vol . Optional ( CONF_TIMEOUT , default = [number] ) : cv . socket_timeout , } [EOL] [EOL] ETHERNET_SCHEMA = { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PORT ) : cv . positive_int , vol . Required ( CONF_TYPE ) : vol . Any ( [string] , [string] , [string] ) , vol . Optional ( CONF_TIMEOUT , default = [number] ) : cv . socket_timeout , } [EOL] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Any ( SERIAL_SCHEMA , ETHERNET_SCHEMA ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SERVICE_WRITE_REGISTER = [string] [EOL] SERVICE_WRITE_COIL = [string] [EOL] [EOL] ATTR_ADDRESS = [string] [EOL] ATTR_UNIT = [string] [EOL] ATTR_VALUE = [string] [EOL] [EOL] SERVICE_WRITE_REGISTER_SCHEMA = vol . Schema ( { vol . Required ( ATTR_UNIT ) : cv . positive_int , vol . Required ( ATTR_ADDRESS ) : cv . positive_int , vol . Required ( ATTR_VALUE ) : vol . All ( cv . ensure_list , [ cv . positive_int ] ) } ) [EOL] [EOL] SERVICE_WRITE_COIL_SCHEMA = vol . Schema ( { vol . Required ( ATTR_UNIT ) : cv . positive_int , vol . Required ( ATTR_ADDRESS ) : cv . positive_int , vol . Required ( ATTR_STATE ) : cv . boolean } ) [EOL] [EOL] HUB = None [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] [comment] [EOL] client_type = config [ DOMAIN ] [ CONF_TYPE ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if client_type == [string] : [EOL] from pymodbus . client . sync import ModbusSerialClient as ModbusClient [EOL] client = ModbusClient ( method = config [ DOMAIN ] [ CONF_METHOD ] , port = config [ DOMAIN ] [ CONF_PORT ] , baudrate = config [ DOMAIN ] [ CONF_BAUDRATE ] , stopbits = config [ DOMAIN ] [ CONF_STOPBITS ] , bytesize = config [ DOMAIN ] [ CONF_BYTESIZE ] , parity = config [ DOMAIN ] [ CONF_PARITY ] , timeout = config [ DOMAIN ] [ CONF_TIMEOUT ] ) [EOL] elif client_type == [string] : [EOL] from pymodbus . client . sync import ModbusTcpClient as ModbusClient [EOL] from pymodbus . transaction import ModbusRtuFramer as ModbusFramer [EOL] client = ModbusClient ( host = config [ DOMAIN ] [ CONF_HOST ] , port = config [ DOMAIN ] [ CONF_PORT ] , framer = ModbusFramer , timeout = config [ DOMAIN ] [ CONF_TIMEOUT ] ) [EOL] elif client_type == [string] : [EOL] from pymodbus . client . sync import ModbusTcpClient as ModbusClient [EOL] client = ModbusClient ( host = config [ DOMAIN ] [ CONF_HOST ] , port = config [ DOMAIN ] [ CONF_PORT ] , timeout = config [ DOMAIN ] [ CONF_TIMEOUT ] ) [EOL] elif client_type == [string] : [EOL] from pymodbus . client . sync import ModbusUdpClient as ModbusClient [EOL] client = ModbusClient ( host = config [ DOMAIN ] [ CONF_HOST ] , port = config [ DOMAIN ] [ CONF_PORT ] , timeout = config [ DOMAIN ] [ CONF_TIMEOUT ] ) [EOL] else : [EOL] return False [EOL] [EOL] global HUB [EOL] HUB = ModbusHub ( client ) [EOL] [EOL] def stop_modbus ( event ) : [EOL] [docstring] [EOL] HUB . close ( ) [EOL] [EOL] def start_modbus ( event ) : [EOL] [docstring] [EOL] HUB . connect ( ) [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , stop_modbus ) [EOL] [EOL] [comment] [EOL] hass . services . register ( DOMAIN , SERVICE_WRITE_REGISTER , write_register , schema = SERVICE_WRITE_REGISTER_SCHEMA ) [EOL] hass . services . register ( DOMAIN , SERVICE_WRITE_COIL , write_coil , schema = SERVICE_WRITE_COIL_SCHEMA ) [EOL] [EOL] def write_register ( service ) : [EOL] [docstring] [EOL] unit = int ( float ( service . data . get ( ATTR_UNIT ) ) ) [EOL] address = int ( float ( service . data . get ( ATTR_ADDRESS ) ) ) [EOL] value = service . data . get ( ATTR_VALUE ) [EOL] if isinstance ( value , list ) : [EOL] HUB . write_registers ( unit , address , [ int ( float ( i ) ) for i in value ] ) [EOL] else : [EOL] HUB . write_register ( unit , address , int ( float ( value ) ) ) [EOL] [EOL] def write_coil ( service ) : [EOL] [docstring] [EOL] unit = service . data . get ( ATTR_UNIT ) [EOL] address = service . data . get ( ATTR_ADDRESS ) [EOL] state = service . data . get ( ATTR_STATE ) [EOL] HUB . write_coil ( unit , address , state ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , start_modbus ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class ModbusHub : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , modbus_client ) : [EOL] [docstring] [EOL] self . _client = modbus_client [EOL] self . _lock = threading . Lock ( ) [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] self . _client . close ( ) [EOL] [EOL] def connect ( self ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] self . _client . connect ( ) [EOL] [EOL] def read_coils ( self , unit , address , count ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] kwargs = { [string] : unit } if unit else { } [EOL] return self . _client . read_coils ( address , count , ** kwargs ) [EOL] [EOL] def read_input_registers ( self , unit , address , count ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] kwargs = { [string] : unit } if unit else { } [EOL] return self . _client . read_input_registers ( address , count , ** kwargs ) [EOL] [EOL] def read_holding_registers ( self , unit , address , count ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] kwargs = { [string] : unit } if unit else { } [EOL] return self . _client . read_holding_registers ( address , count , ** kwargs ) [EOL] [EOL] def write_coil ( self , unit , address , value ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] kwargs = { [string] : unit } if unit else { } [EOL] self . _client . write_coil ( address , value , ** kwargs ) [EOL] [EOL] def write_register ( self , unit , address , value ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] kwargs = { [string] : unit } if unit else { } [EOL] self . _client . write_register ( address , value , ** kwargs ) [EOL] [EOL] def write_registers ( self , unit , address , values ) : [EOL] [docstring] [EOL] with self . _lock : [EOL] kwargs = { [string] : unit } if unit else { } [EOL] self . _client . write_registers ( address , values , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0
from typing import Any , List [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_TYPE = [string] [EOL] [EOL] DATA = None [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_PORT = [number] [EOL] DOMAIN = [string] [EOL] [EOL] KEY_STATUS = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] VALUE_ONLINE = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] global DATA [EOL] conf = config [ DOMAIN ] [EOL] host = conf . get ( CONF_HOST ) [EOL] port = conf . get ( CONF_PORT ) [EOL] [EOL] DATA = APCUPSdData ( host , port ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] DATA . update ( no_throttle = True ) [EOL] except Exception : [EOL] _LOGGER . exception ( [string] ) [EOL] return False [EOL] return True [EOL] [EOL] [EOL] class APCUPSdData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port ) : [EOL] [docstring] [EOL] from apcaccess import status [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _status = None [EOL] self . _get = status . get [EOL] self . _parse = status . parse [EOL] [EOL] @ property def status ( self ) : [EOL] [docstring] [EOL] self . update ( ) [EOL] return self . _status [EOL] [EOL] def _get_status ( self ) : [EOL] [docstring] [EOL] return self . _parse ( self . _get ( host = self . _host , port = self . _port ) ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _status = self . _get_status ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_API_KEY [EOL] from homeassistant . util import Throttle [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_AUTO_BACKUPS = [string] [EOL] ATTR_ALLOWED_BANDWIDTH = [string] [EOL] ATTR_COST_PER_MONTH = [string] [EOL] ATTR_CURRENT_BANDWIDTH_USED = [string] [EOL] ATTR_CREATED_AT = [string] [EOL] ATTR_DISK = [string] [EOL] ATTR_SUBSCRIPTION_ID = [string] [EOL] ATTR_SUBSCRIPTION_NAME = [string] [EOL] ATTR_IPV4_ADDRESS = [string] [EOL] ATTR_IPV6_ADDRESS = [string] [EOL] ATTR_MEMORY = [string] [EOL] ATTR_OS = [string] [EOL] ATTR_PENDING_CHARGES = [string] [EOL] ATTR_REGION = [string] [EOL] ATTR_VCPUS = [string] [EOL] [EOL] CONF_SUBSCRIPTION = [string] [EOL] [EOL] DATA_VULTR = [string] [EOL] DOMAIN = [string] [EOL] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] VULTR_PLATFORMS = [ [string] , [string] , [string] ] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_API_KEY ) : cv . string , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] api_key = config [ DOMAIN ] . get ( CONF_API_KEY ) [EOL] [EOL] vultr = Vultr ( api_key ) [EOL] [EOL] try : [EOL] vultr . update ( ) [EOL] except RuntimeError as ex : [EOL] _LOGGER . error ( [string] , ex ) [EOL] hass . components . persistent_notification . create ( [string] [string] . format ( ex ) , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] return False [EOL] [EOL] hass . data [ DATA_VULTR ] = vultr [EOL] return True [EOL] [EOL] [EOL] class Vultr : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_key ) : [EOL] [docstring] [EOL] from vultr import Vultr as VultrAPI [EOL] [EOL] self . _api_key = api_key [EOL] self . data = None [EOL] self . api = VultrAPI ( self . _api_key ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . data = self . api . server_list ( ) [EOL] [EOL] def _force_update ( self ) : [EOL] [docstring] [EOL] self . data = self . api . server_list ( ) [EOL] [EOL] def halt ( self , subscription ) : [EOL] [docstring] [EOL] self . api . server_halt ( subscription ) [EOL] self . _force_update ( ) [EOL] [EOL] def start ( self , subscription ) : [EOL] [docstring] [EOL] self . api . server_start ( subscription ) [EOL] self . _force_update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . discovery import SERVICE_XIAOMI_GW [EOL] from homeassistant . const import ( ATTR_BATTERY_LEVEL , CONF_HOST , CONF_MAC , CONF_PORT , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers import discovery [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import async_track_point_in_utc_time [EOL] from homeassistant . util . dt import utcnow [EOL] from homeassistant . util import slugify [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_GW_MAC = [string] [EOL] ATTR_RINGTONE_ID = [string] [EOL] ATTR_RINGTONE_VOL = [string] [EOL] ATTR_DEVICE_ID = [string] [EOL] [EOL] CONF_DISCOVERY_RETRY = [string] [EOL] CONF_GATEWAYS = [string] [EOL] CONF_INTERFACE = [string] [EOL] CONF_KEY = [string] [EOL] CONF_DISABLE = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] PY_XIAOMI_GATEWAY = [string] [EOL] [EOL] TIME_TILL_UNAVAILABLE = timedelta ( minutes = [number] ) [EOL] [EOL] SERVICE_PLAY_RINGTONE = [string] [EOL] SERVICE_STOP_RINGTONE = [string] [EOL] SERVICE_ADD_DEVICE = [string] [EOL] SERVICE_REMOVE_DEVICE = [string] [EOL] [EOL] GW_MAC = vol . All ( cv . string , lambda value : value . replace ( [string] , [string] ) . lower ( ) , vol . Length ( min = [number] , max = [number] ) ) [EOL] [EOL] SERVICE_SCHEMA_PLAY_RINGTONE = vol . Schema ( { vol . Required ( ATTR_RINGTONE_ID ) : vol . All ( vol . Coerce ( int ) , vol . NotIn ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) ) , vol . Optional ( ATTR_RINGTONE_VOL ) : vol . All ( vol . Coerce ( int ) , vol . Clamp ( min = [number] , max = [number] ) ) } ) [EOL] [EOL] SERVICE_SCHEMA_REMOVE_DEVICE = vol . Schema ( { vol . Required ( ATTR_DEVICE_ID ) : vol . All ( cv . string , vol . Length ( min = [number] , max = [number] ) ) } ) [EOL] [EOL] [EOL] GATEWAY_CONFIG = vol . Schema ( { vol . Optional ( CONF_MAC , default = None ) : vol . Any ( GW_MAC , None ) , vol . Optional ( CONF_KEY ) : vol . All ( cv . string , vol . Length ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = [number] ) : cv . port , vol . Optional ( CONF_DISABLE , default = False ) : cv . boolean , } ) [EOL] [EOL] [EOL] def _fix_conf_defaults ( config ) : [EOL] [docstring] [EOL] config [ [string] ] = config . pop ( CONF_MAC , None ) [EOL] [EOL] if config . get ( CONF_KEY ) is None : [EOL] _LOGGER . warning ( [string] [string] , config [ [string] ] ) [EOL] [EOL] if config . get ( CONF_HOST ) is None : [EOL] config . pop ( CONF_PORT ) [EOL] [EOL] return config [EOL] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Optional ( CONF_GATEWAYS , default = { } ) : vol . All ( cv . ensure_list , [ GATEWAY_CONFIG ] , [ _fix_conf_defaults ] ) , vol . Optional ( CONF_INTERFACE , default = [string] ) : cv . string , vol . Optional ( CONF_DISCOVERY_RETRY , default = [number] ) : cv . positive_int } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] gateways = [ ] [EOL] interface = [string] [EOL] discovery_retry = [number] [EOL] if DOMAIN in config : [EOL] gateways = config [ DOMAIN ] [ CONF_GATEWAYS ] [EOL] interface = config [ DOMAIN ] [ CONF_INTERFACE ] [EOL] discovery_retry = config [ DOMAIN ] [ CONF_DISCOVERY_RETRY ] [EOL] [EOL] @ asyncio . coroutine def xiaomi_gw_discovered ( service , discovery_info ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] discovery . listen ( hass , SERVICE_XIAOMI_GW , xiaomi_gw_discovered ) [EOL] [EOL] from xiaomi_gateway import XiaomiGatewayDiscovery [EOL] xiaomi = hass . data [ PY_XIAOMI_GATEWAY ] = XiaomiGatewayDiscovery ( hass . add_job , gateways , interface ) [EOL] [EOL] _LOGGER . debug ( [string] , len ( gateways ) ) [EOL] for k in range ( discovery_retry ) : [EOL] _LOGGER . info ( [string] , k + [number] ) [EOL] xiaomi . discover_gateways ( ) [EOL] if len ( xiaomi . gateways ) >= len ( gateways ) : [EOL] break [EOL] [EOL] if not xiaomi . gateways : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] xiaomi . listen ( ) [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] for component in [ [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] discovery . load_platform ( hass , component , DOMAIN , { } , config ) [EOL] [EOL] def stop_xiaomi ( event ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] xiaomi . stop_listen ( ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , stop_xiaomi ) [EOL] [EOL] def play_ringtone_service ( call ) : [EOL] [docstring] [EOL] ring_id = call . data . get ( ATTR_RINGTONE_ID ) [EOL] gateway = call . data . get ( ATTR_GW_MAC ) [EOL] [EOL] kwargs = { [string] : ring_id } [EOL] [EOL] ring_vol = call . data . get ( ATTR_RINGTONE_VOL ) [EOL] if ring_vol is not None : [EOL] kwargs [ [string] ] = ring_vol [EOL] [EOL] gateway . write_to_hub ( gateway . sid , ** kwargs ) [EOL] [EOL] def stop_ringtone_service ( call ) : [EOL] [docstring] [EOL] gateway = call . data . get ( ATTR_GW_MAC ) [EOL] gateway . write_to_hub ( gateway . sid , mid = [number] ) [EOL] [EOL] def add_device_service ( call ) : [EOL] [docstring] [EOL] gateway = call . data . get ( ATTR_GW_MAC ) [EOL] gateway . write_to_hub ( gateway . sid , join_permission = [string] ) [EOL] hass . components . persistent_notification . async_create ( [string] [string] , title = [string] ) [EOL] [EOL] def remove_device_service ( call ) : [EOL] [docstring] [EOL] device_id = call . data . get ( ATTR_DEVICE_ID ) [EOL] gateway = call . data . get ( ATTR_GW_MAC ) [EOL] gateway . write_to_hub ( gateway . sid , remove_device = device_id ) [EOL] [EOL] gateway_only_schema = _add_gateway_to_schema ( xiaomi , vol . Schema ( { } ) ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_PLAY_RINGTONE , play_ringtone_service , schema = _add_gateway_to_schema ( xiaomi , SERVICE_SCHEMA_PLAY_RINGTONE ) ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_STOP_RINGTONE , stop_ringtone_service , schema = gateway_only_schema ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_ADD_DEVICE , add_device_service , schema = gateway_only_schema ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_REMOVE_DEVICE , remove_device_service , schema = _add_gateway_to_schema ( xiaomi , SERVICE_SCHEMA_REMOVE_DEVICE ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class XiaomiDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , device_type , xiaomi_hub ) : [EOL] [docstring] [EOL] self . _state = None [EOL] self . _is_available = True [EOL] self . _sid = device [ [string] ] [EOL] self . _name = [string] . format ( device_type , self . _sid ) [EOL] self . _type = device_type [EOL] self . _write_to_hub = xiaomi_hub . write_to_hub [EOL] self . _get_from_hub = xiaomi_hub . get_from_hub [EOL] self . _device_state_attributes = { } [EOL] self . _remove_unavailability_tracker = None [EOL] xiaomi_hub . callbacks [ self . _sid ] . append ( self . _add_push_data_job ) [EOL] self . parse_data ( device [ [string] ] , device [ [string] ] ) [EOL] self . parse_voltage ( device [ [string] ] ) [EOL] [EOL] if hasattr ( self , [string] ) \ [EOL] and self . _data_key : [comment] [EOL] self . _unique_id = slugify ( [string] . format ( self . _data_key , self . _sid ) ) [EOL] else : [EOL] self . _unique_id = slugify ( [string] . format ( self . _type , self . _sid ) ) [EOL] [EOL] def _add_push_data_job ( self , * args ) : [EOL] self . hass . add_job ( self . push_data , * args ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _async_track_unavailable ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _unique_id [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _is_available [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _device_state_attributes [EOL] [EOL] @ callback def _async_set_unavailable ( self , now ) : [EOL] [docstring] [EOL] self . _remove_unavailability_tracker = None [EOL] self . _is_available = False [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ callback def _async_track_unavailable ( self ) : [EOL] if self . _remove_unavailability_tracker : [EOL] self . _remove_unavailability_tracker ( ) [EOL] self . _remove_unavailability_tracker = async_track_point_in_utc_time ( self . hass , self . _async_set_unavailable , utcnow ( ) + TIME_TILL_UNAVAILABLE ) [EOL] if not self . _is_available : [EOL] self . _is_available = True [EOL] return True [EOL] return False [EOL] [EOL] @ callback def push_data ( self , data , raw_data ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self , data ) [EOL] was_unavailable = self . _async_track_unavailable ( ) [EOL] is_data = self . parse_data ( data , raw_data ) [EOL] is_voltage = self . parse_voltage ( data ) [EOL] if is_data or is_voltage or was_unavailable : [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] def parse_voltage ( self , data ) : [EOL] [docstring] [EOL] if [string] not in data : [EOL] return False [EOL] max_volt = [number] [EOL] min_volt = [number] [EOL] voltage = data [ [string] ] [EOL] voltage = min ( voltage , max_volt ) [EOL] voltage = max ( voltage , min_volt ) [EOL] percent = ( ( voltage - min_volt ) / ( max_volt - min_volt ) ) * [number] [EOL] self . _device_state_attributes [ ATTR_BATTERY_LEVEL ] = round ( percent , [number] ) [EOL] return True [EOL] [EOL] def parse_data ( self , data , raw_data ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] [EOL] def _add_gateway_to_schema ( xiaomi , schema ) : [EOL] [docstring] [EOL] def gateway ( sid ) : [EOL] [docstring] [EOL] sid = str ( sid ) . replace ( [string] , [string] ) . lower ( ) [EOL] [EOL] for gateway in xiaomi . gateways . values ( ) : [EOL] if gateway . sid == sid : [EOL] return gateway [EOL] [EOL] raise vol . Invalid ( [string] . format ( sid ) ) [EOL] [EOL] gateways = list ( xiaomi . gateways . values ( ) ) [EOL] kwargs = { } [EOL] [EOL] [comment] [EOL] if len ( gateways ) == [number] : [EOL] kwargs [ [string] ] = gateways [ [number] ] [EOL] [EOL] return schema . extend ( { vol . Required ( ATTR_GW_MAC , ** kwargs ) : gateway } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] from homeassistant . components . alarm_control_panel import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_UNKNOWN ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] url = [string] . format ( host , port ) [EOL] [EOL] try : [EOL] add_entities ( [ NX584Alarm ( hass , url , name ) ] ) [EOL] except requests . exceptions . ConnectionError as ex : [EOL] _LOGGER . error ( [string] , str ( ex ) ) [EOL] return False [EOL] [EOL] [EOL] class NX584Alarm ( alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , url , name ) : [EOL] [docstring] [EOL] from nx584 import client [EOL] self . _hass = hass [EOL] self . _name = name [EOL] self . _url = url [EOL] self . _alarm = client . Client ( self . _url ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _alarm . list_zones ( ) [EOL] self . _state = STATE_UNKNOWN [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] part = self . _alarm . list_partitions ( ) [ [number] ] [EOL] zones = self . _alarm . list_zones ( ) [EOL] except requests . exceptions . ConnectionError as ex : [EOL] _LOGGER . error ( [string] , dict ( host = self . _url , reason = ex ) ) [EOL] self . _state = STATE_UNKNOWN [EOL] zones = [ ] [EOL] except IndexError : [EOL] _LOGGER . error ( [string] ) [EOL] self . _state = STATE_UNKNOWN [EOL] zones = [ ] [EOL] [EOL] bypassed = False [EOL] for zone in zones : [EOL] if zone [ [string] ] : [EOL] _LOGGER . debug ( [string] , dict ( zone = zone [ [string] ] ) ) [EOL] bypassed = True [EOL] break [EOL] [EOL] if not part [ [string] ] : [EOL] self . _state = STATE_ALARM_DISARMED [EOL] elif bypassed : [EOL] self . _state = STATE_ALARM_ARMED_HOME [EOL] else : [EOL] self . _state = STATE_ALARM_ARMED_AWAY [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] self . _alarm . disarm ( code ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] self . _alarm . arm ( [string] ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] self . _alarm . arm ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] from homeassistant . components . alarm_control_panel import AlarmControlPanel [EOL] from homeassistant . components . homematicip_cloud import ( HMIPC_HAPID , HomematicipGenericDevice ) [EOL] from homeassistant . components . homematicip_cloud import DOMAIN as HMIPC_DOMAIN [EOL] from homeassistant . const import ( STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_ALARM_TRIGGERED ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] HMIP_ZONE_AWAY = [string] [EOL] HMIP_ZONE_HOME = [string] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_entities ) : [EOL] [docstring] [EOL] from homematicip . aio . group import AsyncSecurityZoneGroup [EOL] [EOL] home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home [EOL] devices = [ ] [EOL] for group in home . groups : [EOL] if isinstance ( group , AsyncSecurityZoneGroup ) : [EOL] devices . append ( HomematicipSecurityZone ( home , group ) ) [EOL] [EOL] if devices : [EOL] async_add_entities ( devices ) [EOL] [EOL] [EOL] class HomematicipSecurityZone ( HomematicipGenericDevice , AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] device . modelType = [string] [EOL] device . windowState = [string] [EOL] super ( ) . __init__ ( home , device ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] from homematicip . base . enums import WindowState [EOL] [EOL] if self . _device . active : [EOL] if ( self . _device . sabotage or self . _device . motionDetected or self . _device . windowState == WindowState . OPEN ) : [EOL] return STATE_ALARM_TRIGGERED [EOL] [EOL] active = self . _home . get_security_zones_activation ( ) [EOL] if active == ( True , True ) : [EOL] return STATE_ALARM_ARMED_AWAY [EOL] if active == ( False , True ) : [EOL] return STATE_ALARM_ARMED_HOME [EOL] [EOL] return STATE_ALARM_DISARMED [EOL] [EOL] async def async_alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] await self . _home . set_security_zones_activation ( False , False ) [EOL] [EOL] async def async_alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] await self . _home . set_security_zones_activation ( True , False ) [EOL] [EOL] async def async_alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] await self . _home . set_security_zones_activation ( True , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . tts import Provider , CONF_LANG , PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_API_KEY [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORTED_LANGUAGES = [ [string] ] [EOL] DEFAULT_LANG = [string] [EOL] [EOL] CONF_APP_ID = [string] [EOL] CONF_SECRET_KEY = [string] [EOL] CONF_SPEED = [string] [EOL] CONF_PITCH = [string] [EOL] CONF_VOLUME = [string] [EOL] CONF_PERSON = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_LANG , default = DEFAULT_LANG ) : vol . In ( SUPPORTED_LANGUAGES ) , vol . Required ( CONF_APP_ID ) : cv . string , vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_SECRET_KEY ) : cv . string , vol . Optional ( CONF_SPEED , default = [number] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_PITCH , default = [number] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_VOLUME , default = [number] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_PERSON , default = [number] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] _OPTIONS = { CONF_PERSON : [string] , CONF_PITCH : [string] , CONF_SPEED : [string] , CONF_VOLUME : [string] , } [EOL] SUPPORTED_OPTIONS = [ CONF_PERSON , CONF_PITCH , CONF_SPEED , CONF_VOLUME , ] [EOL] [EOL] [EOL] def get_engine ( hass , config ) : [EOL] [docstring] [EOL] return BaiduTTSProvider ( hass , config ) [EOL] [EOL] [EOL] class BaiduTTSProvider ( Provider ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , conf ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _lang = conf . get ( CONF_LANG ) [EOL] self . _codec = [string] [EOL] self . name = [string] [EOL] [EOL] self . _app_data = { [string] : conf . get ( CONF_APP_ID ) , [string] : conf . get ( CONF_API_KEY ) , [string] : conf . get ( CONF_SECRET_KEY ) , } [EOL] [EOL] self . _speech_conf_data = { _OPTIONS [ CONF_PERSON ] : conf . get ( CONF_PERSON ) , _OPTIONS [ CONF_PITCH ] : conf . get ( CONF_PITCH ) , _OPTIONS [ CONF_SPEED ] : conf . get ( CONF_SPEED ) , _OPTIONS [ CONF_VOLUME ] : conf . get ( CONF_VOLUME ) , } [EOL] [EOL] @ property def default_language ( self ) : [EOL] [docstring] [EOL] return self . _lang [EOL] [EOL] @ property def supported_languages ( self ) : [EOL] [docstring] [EOL] return SUPPORTED_LANGUAGES [EOL] [EOL] @ property def default_options ( self ) : [EOL] [docstring] [EOL] return { CONF_PERSON : self . _speech_conf_data [ _OPTIONS [ CONF_PERSON ] ] , CONF_PITCH : self . _speech_conf_data [ _OPTIONS [ CONF_PITCH ] ] , CONF_SPEED : self . _speech_conf_data [ _OPTIONS [ CONF_SPEED ] ] , CONF_VOLUME : self . _speech_conf_data [ _OPTIONS [ CONF_VOLUME ] ] , } [EOL] [EOL] @ property def supported_options ( self ) : [EOL] [docstring] [EOL] return SUPPORTED_OPTIONS [EOL] [EOL] def get_tts_audio ( self , message , language , options = None ) : [EOL] [docstring] [EOL] from aip import AipSpeech [EOL] aip_speech = AipSpeech ( self . _app_data [ [string] ] , self . _app_data [ [string] ] , self . _app_data [ [string] ] ) [EOL] [EOL] if options is None : [EOL] result = aip_speech . synthesis ( message , language , [number] , self . _speech_conf_data ) [EOL] else : [EOL] speech_data = self . _speech_conf_data . copy ( ) [EOL] for key , value in options . items ( ) : [EOL] speech_data [ _OPTIONS [ key ] ] = value [EOL] [EOL] result = aip_speech . synthesis ( message , language , [number] , speech_data ) [EOL] [EOL] if isinstance ( result , dict ) : [EOL] _LOGGER . error ( [string] , result [ [string] ] , result [ [string] ] , result [ [string] ] ) [EOL] return None , None [EOL] [EOL] return self . _codec , result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any , List [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . ffmpeg import ( FFmpegBase , DATA_FFMPEG , CONF_INPUT , CONF_EXTRA_ARGUMENTS , CONF_INITIAL_STATE ) [EOL] from homeassistant . const import CONF_NAME [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_RESET = [string] [EOL] CONF_CHANGES = [string] [EOL] CONF_REPEAT = [string] [EOL] CONF_REPEAT_TIME = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_INIT_STATE = True [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_INPUT ) : cv . string , vol . Optional ( CONF_INITIAL_STATE , default = DEFAULT_INIT_STATE ) : cv . boolean , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_EXTRA_ARGUMENTS ) : cv . string , vol . Optional ( CONF_RESET , default = [number] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) , vol . Optional ( CONF_CHANGES , default = [number] ) : vol . All ( vol . Coerce ( float ) , vol . Range ( min = [number] , max = [number] ) ) , vol . Inclusive ( CONF_REPEAT , [string] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) , vol . Inclusive ( CONF_REPEAT_TIME , [string] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] manager = hass . data [ DATA_FFMPEG ] [EOL] [EOL] if not manager . async_run_test ( config . get ( CONF_INPUT ) ) : [EOL] return [EOL] [EOL] entity = FFmpegMotion ( hass , manager , config ) [EOL] async_add_entities ( [ entity ] ) [EOL] [EOL] [EOL] class FFmpegBinarySensor ( FFmpegBase , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( config . get ( CONF_INITIAL_STATE ) ) [EOL] [EOL] self . _state = False [EOL] self . _config = config [EOL] self . _name = config . get ( CONF_NAME ) [EOL] [EOL] @ callback def _async_callback ( self , state ) : [EOL] [docstring] [EOL] self . _state = state [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] [EOL] class FFmpegMotion ( FFmpegBinarySensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , manager , config ) : [EOL] [docstring] [EOL] from haffmpeg import SensorMotion [EOL] [EOL] super ( ) . __init__ ( config ) [EOL] self . ffmpeg = SensorMotion ( manager . binary , hass . loop , self . _async_callback ) [EOL] [EOL] @ asyncio . coroutine def _async_start_ffmpeg ( self , entity_ids ) : [EOL] [docstring] [EOL] if entity_ids is not None and self . entity_id not in entity_ids : [EOL] return [EOL] [EOL] [comment] [EOL] self . ffmpeg . set_options ( time_reset = self . _config . get ( CONF_RESET ) , time_repeat = self . _config . get ( CONF_REPEAT_TIME , [number] ) , repeat = self . _config . get ( CONF_REPEAT , [number] ) , changes = self . _config . get ( CONF_CHANGES ) , ) [EOL] [EOL] [comment] [EOL] yield from self . ffmpeg . open_sensor ( input_source = self . _config . get ( CONF_INPUT ) , extra_cmd = self . _config . get ( CONF_EXTRA_ARGUMENTS ) , ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import datetime [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . components . envisalink import ( DATA_EVL , ZONE_SCHEMA , CONF_ZONENAME , CONF_ZONETYPE , EnvisalinkDevice , SIGNAL_ZONE_UPDATE ) [EOL] from homeassistant . const import ATTR_LAST_TRIP_TIME [EOL] from homeassistant . util import dt as dt_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] configured_zones = discovery_info [ [string] ] [EOL] [EOL] devices = [ ] [EOL] for zone_num in configured_zones : [EOL] device_config_data = ZONE_SCHEMA ( configured_zones [ zone_num ] ) [EOL] device = EnvisalinkBinarySensor ( hass , zone_num , device_config_data [ CONF_ZONENAME ] , device_config_data [ CONF_ZONETYPE ] , hass . data [ DATA_EVL ] . alarm_state [ [string] ] [ zone_num ] , hass . data [ DATA_EVL ] ) [EOL] devices . append ( device ) [EOL] [EOL] async_add_entities ( devices ) [EOL] [EOL] [EOL] class EnvisalinkBinarySensor ( EnvisalinkDevice , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , zone_number , zone_name , zone_type , info , controller ) : [EOL] [docstring] [EOL] self . _zone_type = zone_type [EOL] self . _zone_number = zone_number [EOL] [EOL] _LOGGER . debug ( [string] , zone_name ) [EOL] super ( ) . __init__ ( zone_name , info , controller ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_ZONE_UPDATE , self . _update_callback ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] seconds_ago = self . _info [ [string] ] [EOL] if seconds_ago < [number] * [number] : [EOL] now = dt_util . now ( ) . replace ( microsecond = [number] ) [EOL] delta = datetime . timedelta ( seconds = seconds_ago ) [EOL] last_trip_time = ( now - delta ) . isoformat ( ) [EOL] else : [EOL] last_trip_time = None [EOL] [EOL] attr [ ATTR_LAST_TRIP_TIME ] = last_trip_time [EOL] return attr [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _info [ [string] ] [ [string] ] [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _zone_type [EOL] [EOL] @ callback def _update_callback ( self , zone ) : [EOL] [docstring] [EOL] if zone is None or int ( zone ) == self . _zone_number : [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $None$ 0 0 $typing.Any$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $None$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . components . eight_sleep import ( DATA_EIGHT , EightSleepHeatEntity , CONF_BINARY_SENSORS , NAME_MAP ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] name = [string] [EOL] sensors = discovery_info [ CONF_BINARY_SENSORS ] [EOL] eight = hass . data [ DATA_EIGHT ] [EOL] [EOL] all_sensors = [ ] [EOL] [EOL] for sensor in sensors : [EOL] all_sensors . append ( EightHeatSensor ( name , eight , sensor ) ) [EOL] [EOL] async_add_entities ( all_sensors , True ) [EOL] [EOL] [EOL] class EightHeatSensor ( EightSleepHeatEntity , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , eight , sensor ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( eight ) [EOL] [EOL] self . _sensor = sensor [EOL] self . _mapped_name = NAME_MAP . get ( self . _sensor , self . _sensor ) [EOL] self . _name = [string] . format ( name , self . _mapped_name ) [EOL] self . _state = None [EOL] [EOL] self . _side = self . _sensor . split ( [string] ) [ [number] ] [EOL] self . _userid = self . _eight . fetch_userid ( self . _side ) [EOL] self . _usrobj = self . _eight . users [ self . _userid ] [EOL] [EOL] _LOGGER . debug ( [string] , self . _sensor , self . _side , self . _userid ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] self . _state = self . _usrobj . bed_presence [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict , List [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . climate import ( ClimateDevice , PLATFORM_SCHEMA , STATE_HEAT , STATE_OFF , STATE_AUTO , SUPPORT_AUX_HEAT , SUPPORT_OPERATION_MODE , SUPPORT_TARGET_TEMPERATURE ) [EOL] from homeassistant . const import ( TEMP_CELSIUS , CONF_USERNAME , CONF_PASSWORD , ATTR_TEMPERATURE ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] OPERATION_LIST = [ STATE_AUTO , STATE_HEAT , STATE_OFF ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string } ) [EOL] [EOL] EPH_TO_HA_STATE = { [string] : STATE_AUTO , [string] : STATE_HEAT , [string] : STATE_OFF } [EOL] [EOL] HA_STATE_TO_EPH = { value : key for key , value in EPH_TO_HA_STATE . items ( ) } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pyephember . pyephember import EphEmber [EOL] [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] try : [EOL] ember = EphEmber ( username , password ) [EOL] zones = ember . get_zones ( ) [EOL] for zone in zones : [EOL] add_entities ( [ EphEmberThermostat ( ember , zone ) ] ) [EOL] except RuntimeError : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] return [EOL] [EOL] [EOL] class EphEmberThermostat ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ember , zone ) : [EOL] [docstring] [EOL] self . _ember = ember [EOL] self . _zone_name = zone [ [string] ] [EOL] self . _zone = zone [EOL] self . _hot_water = zone [ [string] ] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . _hot_water : [EOL] return SUPPORT_AUX_HEAT | SUPPORT_OPERATION_MODE [EOL] [EOL] return ( SUPPORT_TARGET_TEMPERATURE | SUPPORT_AUX_HEAT | SUPPORT_OPERATION_MODE ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _zone_name [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _zone [ [string] ] [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _zone [ [string] ] [EOL] [EOL] @ property def target_temperature_step ( self ) : [EOL] [docstring] [EOL] if self . _hot_water : [EOL] return None [EOL] [EOL] return [number] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = { [string] : self . _zone [ [string] ] } [EOL] return attributes [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] mode = self . _ember . get_zone_mode ( self . _zone_name ) [EOL] return self . map_mode_eph_hass ( mode ) [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return OPERATION_LIST [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] mode = self . map_mode_hass_eph ( operation_mode ) [EOL] if mode is not None : [EOL] self . _ember . set_mode_by_name ( self . _zone_name , mode ) [EOL] else : [EOL] _LOGGER . error ( [string] , operation_mode ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] if self . _zone [ [string] ] : [EOL] return True [EOL] [EOL] return None [EOL] [EOL] @ property def is_aux_heat_on ( self ) : [EOL] [docstring] [EOL] return self . _zone [ [string] ] [EOL] [EOL] def turn_aux_heat_on ( self ) : [EOL] [docstring] [EOL] self . _ember . activate_boost_by_name ( self . _zone_name , self . _zone [ [string] ] ) [EOL] [EOL] def turn_aux_heat_off ( self ) : [EOL] [docstring] [EOL] self . _ember . deactivate_boost_by_name ( self . _zone_name ) [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if temperature is None : [EOL] return [EOL] [EOL] if self . _hot_water : [EOL] return [EOL] [EOL] if temperature == self . target_temperature : [EOL] return [EOL] [EOL] if temperature > self . max_temp or temperature < self . min_temp : [EOL] return [EOL] [EOL] self . _ember . set_target_temperture_by_name ( self . _zone_name , int ( temperature ) ) [EOL] [EOL] @ property def min_temp ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _hot_water : [EOL] return self . _zone [ [string] ] [EOL] [EOL] return [number] [EOL] [EOL] @ property def max_temp ( self ) : [EOL] [docstring] [EOL] if self . _hot_water : [EOL] return self . _zone [ [string] ] [EOL] [EOL] return [number] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _zone = self . _ember . get_zone ( self . _zone_name ) [EOL] [EOL] @ staticmethod def map_mode_hass_eph ( operation_mode ) : [EOL] [docstring] [EOL] from pyephember . pyephember import ZoneMode [EOL] return getattr ( ZoneMode , HA_STATE_TO_EPH . get ( operation_mode ) , None ) [EOL] [EOL] @ staticmethod def map_mode_eph_hass ( operation_mode ) : [EOL] [docstring] [EOL] return EPH_TO_HA_STATE . get ( operation_mode . name , STATE_AUTO ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict , List [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import datetime [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . climate import ( STATE_AUTO , STATE_COOL , STATE_HEAT , STATE_IDLE , STATE_ON , STATE_OFF , ClimateDevice , PLATFORM_SCHEMA , SUPPORT_TARGET_TEMPERATURE , SUPPORT_OPERATION_MODE , SUPPORT_FAN_MODE , SUPPORT_AWAY_MODE ) [EOL] from homeassistant . const import ( CONF_HOST , TEMP_FAHRENHEIT , ATTR_TEMPERATURE , PRECISION_HALVES ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_FAN = [string] [EOL] ATTR_MODE = [string] [EOL] [EOL] CONF_HOLD_TEMP = [string] [EOL] CONF_AWAY_TEMPERATURE_HEAT = [string] [EOL] CONF_AWAY_TEMPERATURE_COOL = [string] [EOL] [EOL] DEFAULT_AWAY_TEMPERATURE_HEAT = [number] [EOL] DEFAULT_AWAY_TEMPERATURE_COOL = [number] [EOL] [EOL] STATE_CIRCULATE = [string] [EOL] [EOL] OPERATION_LIST = [ STATE_AUTO , STATE_COOL , STATE_HEAT , STATE_OFF ] [EOL] CT30_FAN_OPERATION_LIST = [ STATE_ON , STATE_AUTO ] [EOL] CT80_FAN_OPERATION_LIST = [ STATE_ON , STATE_CIRCULATE , STATE_AUTO ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] CODE_TO_TEMP_MODE = { [number] : STATE_OFF , [number] : STATE_HEAT , [number] : STATE_COOL , [number] : STATE_AUTO } [EOL] TEMP_MODE_TO_CODE = { v : k for k , v in CODE_TO_TEMP_MODE . items ( ) } [EOL] [EOL] [comment] [EOL] CODE_TO_FAN_MODE = { [number] : STATE_AUTO , [number] : STATE_CIRCULATE , [number] : STATE_ON } [EOL] FAN_MODE_TO_CODE = { v : k for k , v in CODE_TO_FAN_MODE . items ( ) } [EOL] [EOL] [comment] [EOL] [comment] [EOL] CODE_TO_TEMP_STATE = { [number] : STATE_IDLE , [number] : STATE_HEAT , [number] : STATE_COOL } [EOL] [EOL] [comment] [EOL] [comment] [EOL] CODE_TO_FAN_STATE = { [number] : STATE_OFF , [number] : STATE_ON } [EOL] [EOL] [EOL] def round_temp ( temperature ) : [EOL] [docstring] [EOL] return round ( temperature * [number] ) / [number] [EOL] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_HOLD_TEMP , default = False ) : cv . boolean , vol . Optional ( CONF_AWAY_TEMPERATURE_HEAT , default = DEFAULT_AWAY_TEMPERATURE_HEAT ) : vol . All ( vol . Coerce ( float ) , round_temp ) , vol . Optional ( CONF_AWAY_TEMPERATURE_COOL , default = DEFAULT_AWAY_TEMPERATURE_COOL ) : vol . All ( vol . Coerce ( float ) , round_temp ) , } ) [EOL] [EOL] SUPPORT_FLAGS = ( SUPPORT_TARGET_TEMPERATURE | SUPPORT_OPERATION_MODE | SUPPORT_FAN_MODE | SUPPORT_AWAY_MODE ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import radiotherm [EOL] [EOL] hosts = [ ] [EOL] if CONF_HOST in config : [EOL] hosts = config [ CONF_HOST ] [EOL] else : [EOL] hosts . append ( radiotherm . discover . discover_address ( ) ) [EOL] [EOL] if hosts is None : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] hold_temp = config . get ( CONF_HOLD_TEMP ) [EOL] away_temps = [ config . get ( CONF_AWAY_TEMPERATURE_HEAT ) , config . get ( CONF_AWAY_TEMPERATURE_COOL ) ] [EOL] tstats = [ ] [EOL] [EOL] for host in hosts : [EOL] try : [EOL] tstat = radiotherm . get_thermostat ( host ) [EOL] tstats . append ( RadioThermostat ( tstat , hold_temp , away_temps ) ) [EOL] except OSError : [EOL] _LOGGER . exception ( [string] , host ) [EOL] [EOL] add_entities ( tstats , True ) [EOL] [EOL] [EOL] class RadioThermostat ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , hold_temp , away_temps ) : [EOL] [docstring] [EOL] self . device = device [EOL] self . _target_temperature = None [EOL] self . _current_temperature = None [EOL] self . _current_operation = STATE_IDLE [EOL] self . _name = None [EOL] self . _fmode = None [EOL] self . _fstate = None [EOL] self . _tmode = None [EOL] self . _tstate = None [EOL] self . _hold_temp = hold_temp [EOL] self . _hold_set = False [EOL] self . _away = False [EOL] self . _away_temps = away_temps [EOL] self . _prev_temp = None [EOL] [EOL] [comment] [EOL] import radiotherm [EOL] self . _is_model_ct80 = isinstance ( self . device , radiotherm . thermostat . CT80 ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FLAGS [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . hass . async_add_job ( self . set_time ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_FAHRENHEIT [EOL] [EOL] @ property def precision ( self ) : [EOL] [docstring] [EOL] return PRECISION_HALVES [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_FAN : self . _fmode , ATTR_MODE : self . _tmode , } [EOL] [EOL] @ property def fan_list ( self ) : [EOL] [docstring] [EOL] if self . _is_model_ct80 : [EOL] return CT80_FAN_OPERATION_LIST [EOL] return CT30_FAN_OPERATION_LIST [EOL] [EOL] @ property def current_fan_mode ( self ) : [EOL] [docstring] [EOL] return self . _fmode [EOL] [EOL] def set_fan_mode ( self , fan_mode ) : [EOL] [docstring] [EOL] code = FAN_MODE_TO_CODE . get ( fan_mode , None ) [EOL] if code is not None : [EOL] self . device . fmode = code [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _current_temperature [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] return self . _current_operation [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return OPERATION_LIST [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _target_temperature [EOL] [EOL] @ property def is_away_mode_on ( self ) : [EOL] [docstring] [EOL] return self . _away [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . _name is None : [EOL] self . _name = self . device . name [ [string] ] [EOL] [EOL] [comment] [EOL] data = self . device . tstat [ [string] ] [EOL] [EOL] current_temp = data [ [string] ] [EOL] if current_temp == - [number] : [EOL] _LOGGER . error ( [string] , self . _name , self . device . host ) [EOL] return [EOL] [EOL] [comment] [EOL] self . _current_temperature = current_temp [EOL] self . _fmode = CODE_TO_FAN_MODE [ data [ [string] ] ] [EOL] self . _fstate = CODE_TO_FAN_STATE [ data [ [string] ] ] [EOL] self . _tmode = CODE_TO_TEMP_MODE [ data [ [string] ] ] [EOL] self . _tstate = CODE_TO_TEMP_STATE [ data [ [string] ] ] [EOL] [EOL] self . _current_operation = self . _tmode [EOL] if self . _tmode == STATE_COOL : [EOL] self . _target_temperature = data [ [string] ] [EOL] elif self . _tmode == STATE_HEAT : [EOL] self . _target_temperature = data [ [string] ] [EOL] elif self . _tmode == STATE_AUTO : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . _tstate == STATE_COOL : [EOL] self . _target_temperature = data [ [string] ] [EOL] elif self . _tstate == STATE_HEAT : [EOL] self . _target_temperature = data [ [string] ] [EOL] else : [EOL] self . _current_operation = STATE_IDLE [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if temperature is None : [EOL] return [EOL] [EOL] temperature = round_temp ( temperature ) [EOL] [EOL] if self . _current_operation == STATE_COOL : [EOL] self . device . t_cool = temperature [EOL] elif self . _current_operation == STATE_HEAT : [EOL] self . device . t_heat = temperature [EOL] elif self . _current_operation == STATE_AUTO : [EOL] if self . _tstate == STATE_COOL : [EOL] self . device . t_cool = temperature [EOL] elif self . _tstate == STATE_HEAT : [EOL] self . device . t_heat = temperature [EOL] [EOL] [comment] [EOL] [comment] [EOL] if kwargs . get ( [string] , False ) or not self . _hold_set : [EOL] if self . _hold_temp or self . _away : [EOL] self . device . hold = [number] [EOL] self . _hold_set = True [EOL] else : [EOL] self . device . hold = [number] [EOL] [EOL] def set_time ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] now = datetime . datetime . now ( ) [EOL] self . device . time = { [string] : now . weekday ( ) , [string] : now . hour , [string] : now . minute } [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] if operation_mode in ( STATE_OFF , STATE_AUTO ) : [EOL] self . device . tmode = TEMP_MODE_TO_CODE [ operation_mode ] [EOL] [EOL] [comment] [EOL] elif operation_mode == STATE_COOL : [EOL] self . device . t_cool = self . _target_temperature [EOL] elif operation_mode == STATE_HEAT : [EOL] self . device . t_heat = self . _target_temperature [EOL] [EOL] def turn_away_mode_on ( self ) : [EOL] [docstring] [EOL] away_temp = None [EOL] if not self . _away : [EOL] self . _prev_temp = self . _target_temperature [EOL] if self . _current_operation == STATE_HEAT : [EOL] away_temp = self . _away_temps [ [number] ] [EOL] elif self . _current_operation == STATE_COOL : [EOL] away_temp = self . _away_temps [ [number] ] [EOL] [EOL] self . _away = True [EOL] self . set_temperature ( temperature = away_temp , hold_changed = True ) [EOL] [EOL] def turn_away_mode_off ( self ) : [EOL] [docstring] [EOL] self . _away = False [EOL] self . set_temperature ( temperature = self . _prev_temp , hold_changed = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] DEBOUNCE_TIMEOUT = [number] [EOL] DOMAIN = [string] [EOL] HOMEKIT_FILE = [string] [EOL] HOMEKIT_NOTIFY_ID = [number] [EOL] [EOL] [comment] [EOL] CONF_AUTO_START = [string] [EOL] CONF_ENTITY_CONFIG = [string] [EOL] CONF_FEATURE = [string] [EOL] CONF_FEATURE_LIST = [string] [EOL] CONF_FILTER = [string] [EOL] [EOL] [comment] [EOL] DEFAULT_AUTO_START = True [EOL] DEFAULT_PORT = [number] [EOL] [EOL] [comment] [EOL] FEATURE_ON_OFF = [string] [EOL] FEATURE_PLAY_PAUSE = [string] [EOL] FEATURE_PLAY_STOP = [string] [EOL] FEATURE_TOGGLE_MUTE = [string] [EOL] [EOL] [comment] [EOL] SERVICE_HOMEKIT_START = [string] [EOL] [EOL] [comment] [EOL] BRIDGE_MODEL = [string] [EOL] BRIDGE_NAME = [string] [EOL] BRIDGE_SERIAL_NUMBER = [string] [EOL] MANUFACTURER = [string] [EOL] [EOL] [comment] [EOL] TYPE_OUTLET = [string] [EOL] TYPE_SWITCH = [string] [EOL] [EOL] [comment] [EOL] SERV_ACCESSORY_INFO = [string] [EOL] SERV_AIR_QUALITY_SENSOR = [string] [EOL] SERV_BATTERY_SERVICE = [string] [EOL] SERV_CARBON_DIOXIDE_SENSOR = [string] [EOL] SERV_CARBON_MONOXIDE_SENSOR = [string] [EOL] SERV_CONTACT_SENSOR = [string] [EOL] SERV_FANV2 = [string] [EOL] SERV_GARAGE_DOOR_OPENER = [string] [EOL] SERV_HUMIDITY_SENSOR = [string] [EOL] SERV_LEAK_SENSOR = [string] [EOL] SERV_LIGHT_SENSOR = [string] [EOL] SERV_LIGHTBULB = [string] [EOL] SERV_LOCK = [string] [EOL] SERV_MOTION_SENSOR = [string] [EOL] SERV_OCCUPANCY_SENSOR = [string] [EOL] SERV_OUTLET = [string] [EOL] SERV_SECURITY_SYSTEM = [string] [EOL] SERV_SMOKE_SENSOR = [string] [EOL] SERV_SWITCH = [string] [EOL] SERV_TEMPERATURE_SENSOR = [string] [EOL] SERV_THERMOSTAT = [string] [EOL] SERV_WINDOW_COVERING = [string] [EOL] [EOL] [comment] [EOL] CHAR_ACTIVE = [string] [EOL] CHAR_AIR_PARTICULATE_DENSITY = [string] [EOL] CHAR_AIR_QUALITY = [string] [EOL] CHAR_BATTERY_LEVEL = [string] [EOL] CHAR_BRIGHTNESS = [string] [EOL] CHAR_CARBON_DIOXIDE_DETECTED = [string] [EOL] CHAR_CARBON_DIOXIDE_LEVEL = [string] [EOL] CHAR_CARBON_DIOXIDE_PEAK_LEVEL = [string] [EOL] CHAR_CARBON_MONOXIDE_DETECTED = [string] [EOL] CHAR_CHARGING_STATE = [string] [EOL] CHAR_COLOR_TEMPERATURE = [string] [EOL] CHAR_CONTACT_SENSOR_STATE = [string] [EOL] CHAR_COOLING_THRESHOLD_TEMPERATURE = [string] [EOL] CHAR_CURRENT_AMBIENT_LIGHT_LEVEL = [string] [EOL] CHAR_CURRENT_DOOR_STATE = [string] [EOL] CHAR_CURRENT_HEATING_COOLING = [string] [EOL] CHAR_CURRENT_POSITION = [string] [EOL] CHAR_CURRENT_HUMIDITY = [string] [EOL] CHAR_CURRENT_SECURITY_STATE = [string] [EOL] CHAR_CURRENT_TEMPERATURE = [string] [EOL] CHAR_FIRMWARE_REVISION = [string] [EOL] CHAR_HEATING_THRESHOLD_TEMPERATURE = [string] [EOL] CHAR_HUE = [string] [EOL] CHAR_LEAK_DETECTED = [string] [EOL] CHAR_LOCK_CURRENT_STATE = [string] [EOL] CHAR_LOCK_TARGET_STATE = [string] [EOL] CHAR_LINK_QUALITY = [string] [EOL] CHAR_MANUFACTURER = [string] [EOL] CHAR_MODEL = [string] [EOL] CHAR_MOTION_DETECTED = [string] [EOL] CHAR_NAME = [string] [EOL] CHAR_OCCUPANCY_DETECTED = [string] [EOL] CHAR_OUTLET_IN_USE = [string] [EOL] CHAR_ON = [string] [EOL] CHAR_POSITION_STATE = [string] [EOL] CHAR_ROTATION_DIRECTION = [string] [EOL] CHAR_SATURATION = [string] [EOL] CHAR_SERIAL_NUMBER = [string] [EOL] CHAR_SMOKE_DETECTED = [string] [EOL] CHAR_STATUS_LOW_BATTERY = [string] [EOL] CHAR_SWING_MODE = [string] [EOL] CHAR_TARGET_DOOR_STATE = [string] [EOL] CHAR_TARGET_HEATING_COOLING = [string] [EOL] CHAR_TARGET_POSITION = [string] [EOL] CHAR_TARGET_SECURITY_STATE = [string] [EOL] CHAR_TARGET_TEMPERATURE = [string] [EOL] CHAR_TEMP_DISPLAY_UNITS = [string] [EOL] [EOL] [comment] [EOL] PROP_MAX_VALUE = [string] [EOL] PROP_MIN_VALUE = [string] [EOL] PROP_CELSIUS = { [string] : - [number] , [string] : [number] } [EOL] [EOL] [comment] [EOL] DEVICE_CLASS_CO2 = [string] [EOL] DEVICE_CLASS_DOOR = [string] [EOL] DEVICE_CLASS_GARAGE_DOOR = [string] [EOL] DEVICE_CLASS_GAS = [string] [EOL] DEVICE_CLASS_MOISTURE = [string] [EOL] DEVICE_CLASS_MOTION = [string] [EOL] DEVICE_CLASS_OCCUPANCY = [string] [EOL] DEVICE_CLASS_OPENING = [string] [EOL] DEVICE_CLASS_PM25 = [string] [EOL] DEVICE_CLASS_SMOKE = [string] [EOL] DEVICE_CLASS_WINDOW = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_HS_COLOR , ENTITY_ID_FORMAT , SUPPORT_BRIGHTNESS , SUPPORT_COLOR , Light ) [EOL] from homeassistant . components . vera import ( VERA_CONTROLLER , VERA_DEVICES , VeraDevice ) [EOL] import homeassistant . util . color as color_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] add_entities ( [ VeraLight ( device , hass . data [ VERA_CONTROLLER ] ) for device in hass . data [ VERA_DEVICES ] [ [string] ] ] , True ) [EOL] [EOL] [EOL] class VeraLight ( VeraDevice , Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , vera_device , controller ) : [EOL] [docstring] [EOL] self . _state = False [EOL] self . _color = None [EOL] self . _brightness = None [EOL] VeraDevice . __init__ ( self , vera_device , controller ) [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( self . vera_id ) [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return self . _color [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . _color : [EOL] return SUPPORT_BRIGHTNESS | SUPPORT_COLOR [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_HS_COLOR in kwargs and self . _color : [EOL] rgb = color_util . color_hs_to_RGB ( * kwargs [ ATTR_HS_COLOR ] ) [EOL] self . vera_device . set_color ( rgb ) [EOL] elif ATTR_BRIGHTNESS in kwargs and self . vera_device . is_dimmable : [EOL] self . vera_device . set_brightness ( kwargs [ ATTR_BRIGHTNESS ] ) [EOL] else : [EOL] self . vera_device . switch_on ( ) [EOL] [EOL] self . _state = True [EOL] self . schedule_update_ha_state ( True ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . vera_device . switch_off ( ) [EOL] self . _state = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _state = self . vera_device . is_switched_on ( ) [EOL] if self . vera_device . is_dimmable : [EOL] [comment] [EOL] [comment] [EOL] self . _brightness = self . vera_device . get_brightness ( ) [EOL] rgb = self . vera_device . get_color ( ) [EOL] self . _color = color_util . color_RGB_to_hs ( * rgb ) if rgb else None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0
from typing import Any , Tuple , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import random [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_EFFECT , ATTR_HS_COLOR , ATTR_WHITE_VALUE , SUPPORT_BRIGHTNESS , SUPPORT_COLOR_TEMP , SUPPORT_EFFECT , SUPPORT_COLOR , SUPPORT_WHITE_VALUE , Light ) [EOL] [EOL] LIGHT_COLORS = [ ( [number] , [number] ) , ( [number] , [number] ) , ] [EOL] [EOL] LIGHT_EFFECT_LIST = [ [string] , [string] ] [EOL] [EOL] LIGHT_TEMPS = [ [number] , [number] ] [EOL] [EOL] SUPPORT_DEMO = ( SUPPORT_BRIGHTNESS | SUPPORT_COLOR_TEMP | SUPPORT_EFFECT | SUPPORT_COLOR | SUPPORT_WHITE_VALUE ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities_callback , discovery_info = None ) : [EOL] [docstring] [EOL] add_entities_callback ( [ DemoLight ( [number] , [string] , False , True , effect_list = LIGHT_EFFECT_LIST , effect = LIGHT_EFFECT_LIST [ [number] ] ) , DemoLight ( [number] , [string] , True , True , LIGHT_COLORS [ [number] ] , LIGHT_TEMPS [ [number] ] ) , DemoLight ( [number] , [string] , True , True , LIGHT_COLORS [ [number] ] , LIGHT_TEMPS [ [number] ] ) ] ) [EOL] [EOL] [EOL] class DemoLight ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , unique_id , name , state , available = False , hs_color = None , ct = None , brightness = [number] , white = [number] , effect_list = None , effect = None ) : [EOL] [docstring] [EOL] self . _unique_id = unique_id [EOL] self . _name = name [EOL] self . _state = state [EOL] self . _hs_color = hs_color [EOL] self . _ct = ct or random . choice ( LIGHT_TEMPS ) [EOL] self . _brightness = brightness [EOL] self . _white = white [EOL] self . _effect_list = effect_list [EOL] self . _effect = effect [EOL] self . _available = True [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _unique_id [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] return self . _available [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return self . _hs_color [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] return self . _ct [EOL] [EOL] @ property def white_value ( self ) : [EOL] [docstring] [EOL] return self . _white [EOL] [EOL] @ property def effect_list ( self ) : [EOL] [docstring] [EOL] return self . _effect_list [EOL] [EOL] @ property def effect ( self ) : [EOL] [docstring] [EOL] return self . _effect [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_DEMO [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _state = True [EOL] [EOL] if ATTR_HS_COLOR in kwargs : [EOL] self . _hs_color = kwargs [ ATTR_HS_COLOR ] [EOL] [EOL] if ATTR_COLOR_TEMP in kwargs : [EOL] self . _ct = kwargs [ ATTR_COLOR_TEMP ] [EOL] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] [EOL] if ATTR_WHITE_VALUE in kwargs : [EOL] self . _white = kwargs [ ATTR_WHITE_VALUE ] [EOL] [EOL] if ATTR_EFFECT in kwargs : [EOL] self . _effect = kwargs [ ATTR_EFFECT ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _state = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_HOST , CONF_PORT , CONF_DEVICES ) [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light , PLATFORM_SCHEMA ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DRIVER = [string] [EOL] CONF_DRIVER_FNIP6X10AD = [string] [EOL] CONF_DRIVER_FNIP8X10A = [string] [EOL] CONF_DRIVER_TYPES = [ CONF_DRIVER_FNIP6X10AD , CONF_DRIVER_FNIP8X10A ] [EOL] [EOL] DEVICE_SCHEMA = vol . Schema ( { vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( [string] , default = False ) : cv . boolean , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DRIVER ) : vol . In ( CONF_DRIVER_TYPES ) , vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PORT ) : cv . port , vol . Required ( CONF_DEVICES ) : { cv . string : DEVICE_SCHEMA } , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] lights = [ ] [EOL] for channel , device_config in config [ CONF_DEVICES ] . items ( ) : [EOL] device = { } [EOL] device [ [string] ] = device_config [ CONF_NAME ] [EOL] device [ [string] ] = device_config [ [string] ] [EOL] device [ [string] ] = channel [EOL] device [ [string] ] = config [ CONF_DRIVER ] [EOL] device [ [string] ] = config [ CONF_HOST ] [EOL] device [ [string] ] = config [ CONF_PORT ] [EOL] lights . append ( FutureNowLight ( device ) ) [EOL] [EOL] add_entities ( lights , True ) [EOL] [EOL] [EOL] def to_futurenow_level ( level ) : [EOL] [docstring] [EOL] return int ( ( level * [number] ) / [number] ) [EOL] [EOL] [EOL] def to_hass_level ( level ) : [EOL] [docstring] [EOL] return int ( ( level * [number] ) / [number] ) [EOL] [EOL] [EOL] class FutureNowLight ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] import pyfnip [EOL] [EOL] self . _name = device [ [string] ] [EOL] self . _dimmable = device [ [string] ] [EOL] self . _channel = device [ [string] ] [EOL] self . _brightness = None [EOL] self . _last_brightness = [number] [EOL] self . _state = None [EOL] [EOL] if device [ [string] ] == CONF_DRIVER_FNIP6X10AD : [EOL] self . _light = pyfnip . FNIP6x2adOutput ( device [ [string] ] , device [ [string] ] , self . _channel ) [EOL] if device [ [string] ] == CONF_DRIVER_FNIP8X10A : [EOL] self . _light = pyfnip . FNIP8x10aOutput ( device [ [string] ] , device [ [string] ] , self . _channel ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . _dimmable : [EOL] return SUPPORT_BRIGHTNESS [EOL] return [number] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _dimmable : [EOL] level = kwargs . get ( ATTR_BRIGHTNESS , self . _last_brightness ) [EOL] else : [EOL] level = [number] [EOL] self . _light . turn_on ( to_futurenow_level ( level ) ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _light . turn_off ( ) [EOL] if self . _brightness : [EOL] self . _last_brightness = self . _brightness [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] state = int ( self . _light . is_on ( ) ) [EOL] self . _state = bool ( state ) [EOL] self . _brightness = to_hass_level ( state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . util . dt as dt_util [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , CONF_ICON , CONF_NAME ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . event import async_track_point_in_utc_time [EOL] [EOL] from homeassistant . loader import bind_hass [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] DEFAULT_DURATION = [number] [EOL] ATTR_DURATION = [string] [EOL] ATTR_REMAINING = [string] [EOL] CONF_DURATION = [string] [EOL] [EOL] STATUS_IDLE = [string] [EOL] STATUS_ACTIVE = [string] [EOL] STATUS_PAUSED = [string] [EOL] [EOL] EVENT_TIMER_FINISHED = [string] [EOL] EVENT_TIMER_CANCELLED = [string] [EOL] [EOL] SERVICE_START = [string] [EOL] SERVICE_PAUSE = [string] [EOL] SERVICE_CANCEL = [string] [EOL] SERVICE_FINISH = [string] [EOL] [EOL] SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] SERVICE_SCHEMA_DURATION = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Optional ( ATTR_DURATION , default = timedelta ( DEFAULT_DURATION ) ) : cv . time_period , } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { cv . slug : vol . Any ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_ICON ) : cv . icon , vol . Optional ( CONF_DURATION , timedelta ( DEFAULT_DURATION ) ) : cv . time_period , } , None ) } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ bind_hass def start ( hass , entity_id , duration ) : [EOL] [docstring] [EOL] hass . add_job ( async_start , hass , entity_id , { ATTR_ENTITY_ID : entity_id , ATTR_DURATION : duration } ) [EOL] [EOL] [EOL] @ callback @ bind_hass def async_start ( hass , entity_id , duration ) : [EOL] [docstring] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_START , { ATTR_ENTITY_ID : entity_id , ATTR_DURATION : duration } ) ) [EOL] [EOL] [EOL] @ bind_hass def pause ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . add_job ( async_pause , hass , entity_id ) [EOL] [EOL] [EOL] @ callback @ bind_hass def async_pause ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_PAUSE , { ATTR_ENTITY_ID : entity_id } ) ) [EOL] [EOL] [EOL] @ bind_hass def cancel ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . add_job ( async_cancel , hass , entity_id ) [EOL] [EOL] [EOL] @ callback @ bind_hass def async_cancel ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_CANCEL , { ATTR_ENTITY_ID : entity_id } ) ) [EOL] [EOL] [EOL] @ bind_hass def finish ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . add_job ( async_cancel , hass , entity_id ) [EOL] [EOL] [EOL] @ callback @ bind_hass def async_finish ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_FINISH , { ATTR_ENTITY_ID : entity_id } ) ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass ) [EOL] [EOL] entities = [ ] [EOL] [EOL] for object_id , cfg in config [ DOMAIN ] . items ( ) : [EOL] if not cfg : [EOL] cfg = { } [EOL] [EOL] name = cfg . get ( CONF_NAME ) [EOL] icon = cfg . get ( CONF_ICON ) [EOL] duration = cfg . get ( CONF_DURATION ) [EOL] [EOL] entities . append ( Timer ( hass , object_id , name , icon , duration ) ) [EOL] [EOL] if not entities : [EOL] return False [EOL] [EOL] component . async_register_entity_service ( SERVICE_START , SERVICE_SCHEMA_DURATION , [string] ) [EOL] component . async_register_entity_service ( SERVICE_PAUSE , SERVICE_SCHEMA , [string] ) [EOL] component . async_register_entity_service ( SERVICE_CANCEL , SERVICE_SCHEMA , [string] ) [EOL] component . async_register_entity_service ( SERVICE_FINISH , SERVICE_SCHEMA , [string] ) [EOL] [EOL] await component . async_add_entities ( entities ) [EOL] return True [EOL] [EOL] [EOL] class Timer ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , object_id , name , icon , duration ) : [EOL] [docstring] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( object_id ) [EOL] self . _name = name [EOL] self . _state = STATUS_IDLE [EOL] self . _duration = duration [EOL] self . _remaining = self . _duration [EOL] self . _icon = icon [EOL] self . _hass = hass [EOL] self . _end = None [EOL] self . _listener = None [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_DURATION : str ( self . _duration ) , ATTR_REMAINING : str ( self . _remaining ) } [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _state is not None : [EOL] return [EOL] [EOL] restore_state = self . _hass . helpers . restore_state [EOL] state = await restore_state . async_get_last_state ( self . entity_id ) [EOL] self . _state = state and state . state == state [EOL] [EOL] async def async_start ( self , duration ) : [EOL] [docstring] [EOL] if self . _listener : [EOL] self . _listener ( ) [EOL] self . _listener = None [EOL] newduration = None [EOL] if duration : [EOL] newduration = duration [EOL] [EOL] self . _state = STATUS_ACTIVE [EOL] [comment] [EOL] start = dt_util . utcnow ( ) [EOL] if self . _remaining and newduration is None : [EOL] self . _end = start + self . _remaining [EOL] else : [EOL] if newduration : [EOL] self . _duration = newduration [EOL] self . _remaining = newduration [EOL] else : [EOL] self . _remaining = self . _duration [EOL] self . _end = start + self . _duration [EOL] self . _listener = async_track_point_in_utc_time ( self . _hass , self . async_finished , self . _end ) [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_pause ( self ) : [EOL] [docstring] [EOL] if self . _listener is None : [EOL] return [EOL] [EOL] self . _listener ( ) [EOL] self . _listener = None [EOL] self . _remaining = self . _end - dt_util . utcnow ( ) [EOL] self . _state = STATUS_PAUSED [EOL] self . _end = None [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_cancel ( self ) : [EOL] [docstring] [EOL] if self . _listener : [EOL] self . _listener ( ) [EOL] self . _listener = None [EOL] self . _state = STATUS_IDLE [EOL] self . _end = None [EOL] self . _remaining = timedelta ( ) [EOL] self . _hass . bus . async_fire ( EVENT_TIMER_CANCELLED , { [string] : self . entity_id } ) [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_finish ( self ) : [EOL] [docstring] [EOL] if self . _state != STATUS_ACTIVE : [EOL] return [EOL] [EOL] self . _listener = None [EOL] self . _state = STATUS_IDLE [EOL] self . _remaining = timedelta ( ) [EOL] self . _hass . bus . async_fire ( EVENT_TIMER_FINISHED , { [string] : self . entity_id } ) [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_finished ( self , time ) : [EOL] [docstring] [EOL] if self . _state != STATUS_ACTIVE : [EOL] return [EOL] [EOL] self . _listener = None [EOL] self . _state = STATUS_IDLE [EOL] self . _remaining = timedelta ( ) [EOL] self . _hass . bus . async_fire ( EVENT_TIMER_FINISHED , { [string] : self . entity_id } ) [EOL] await self . async_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import asyncio [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . weather import ( WeatherEntity , PLATFORM_SCHEMA , ATTR_FORECAST_CONDITION , ATTR_FORECAST_TEMP , ATTR_FORECAST_TEMP_LOW , ATTR_FORECAST_TIME ) [EOL] from homeassistant . const import CONF_NAME , TEMP_CELSIUS , CONF_LATITUDE , CONF_LONGITUDE [EOL] from homeassistant . helpers import config_validation as cv [EOL] [comment] [EOL] from homeassistant . components . sensor . buienradar import ( BrData ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DATA_CONDITION = [string] [EOL] [EOL] DEFAULT_TIMEFRAME = [number] [EOL] [EOL] CONF_FORECAST = [string] [EOL] [EOL] [EOL] CONDITION_CLASSES = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_LATITUDE ) : cv . latitude , vol . Optional ( CONF_LONGITUDE ) : cv . longitude , vol . Optional ( CONF_FORECAST , default = True ) : cv . boolean , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] latitude = config . get ( CONF_LATITUDE , hass . config . latitude ) [EOL] longitude = config . get ( CONF_LONGITUDE , hass . config . longitude ) [EOL] [EOL] if None in ( latitude , longitude ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] coordinates = { CONF_LATITUDE : float ( latitude ) , CONF_LONGITUDE : float ( longitude ) } [EOL] [EOL] [comment] [EOL] data = BrData ( hass , coordinates , DEFAULT_TIMEFRAME , None ) [EOL] [comment] [EOL] _LOGGER . debug ( [string] , coordinates ) [EOL] [EOL] [comment] [EOL] if DATA_CONDITION not in hass . data : [EOL] cond_keys = [ str ( chr ( x ) ) for x in range ( [number] , [number] ) ] [EOL] hass . data [ DATA_CONDITION ] = dict . fromkeys ( cond_keys ) [EOL] for cond , condlst in CONDITION_CLASSES . items ( ) : [EOL] for condi in condlst : [EOL] hass . data [ DATA_CONDITION ] [ condi ] = cond [EOL] [EOL] async_add_entities ( [ BrWeather ( data , config ) ] ) [EOL] [EOL] [comment] [EOL] yield from data . schedule_update ( [number] ) [EOL] [EOL] [EOL] class BrWeather ( WeatherEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , config ) : [EOL] [docstring] [EOL] self . _stationname = config . get ( CONF_NAME , None ) [EOL] self . _forecast = config . get ( CONF_FORECAST ) [EOL] self . _data = data [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] return self . _data . attribution [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _stationname or [string] . format ( self . _data . stationname or [string] ) [EOL] [EOL] @ property def condition ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import ( CONDCODE ) [EOL] if self . _data and self . _data . condition : [EOL] ccode = self . _data . condition . get ( CONDCODE ) [EOL] if ccode : [EOL] conditions = self . hass . data . get ( DATA_CONDITION ) [EOL] if conditions : [EOL] return conditions . get ( ccode ) [EOL] [EOL] @ property def temperature ( self ) : [EOL] [docstring] [EOL] return self . _data . temperature [EOL] [EOL] @ property def pressure ( self ) : [EOL] [docstring] [EOL] return self . _data . pressure [EOL] [EOL] @ property def humidity ( self ) : [EOL] [docstring] [EOL] return self . _data . humidity [EOL] [EOL] @ property def visibility ( self ) : [EOL] [docstring] [EOL] return self . _data . visibility [EOL] [EOL] @ property def wind_speed ( self ) : [EOL] [docstring] [EOL] return self . _data . wind_speed [EOL] [EOL] @ property def wind_bearing ( self ) : [EOL] [docstring] [EOL] return self . _data . wind_bearing [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def forecast ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import ( CONDITION , CONDCODE , DATETIME , MIN_TEMP , MAX_TEMP ) [EOL] [EOL] if self . _forecast : [EOL] fcdata_out = [ ] [EOL] cond = self . hass . data [ DATA_CONDITION ] [EOL] if self . _data . forecast : [EOL] for data_in in self . _data . forecast : [EOL] [comment] [EOL] [comment] [EOL] data_out = { } [EOL] condcode = data_in . get ( CONDITION , [ ] ) . get ( CONDCODE ) [EOL] [EOL] data_out [ ATTR_FORECAST_TIME ] = data_in . get ( DATETIME ) [EOL] data_out [ ATTR_FORECAST_CONDITION ] = cond [ condcode ] [EOL] data_out [ ATTR_FORECAST_TEMP_LOW ] = data_in . get ( MIN_TEMP ) [EOL] data_out [ ATTR_FORECAST_TEMP ] = data_in . get ( MAX_TEMP ) [EOL] [EOL] fcdata_out . append ( data_out ) [EOL] [EOL] return fcdata_out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
from typing import Union , List , Dict , Optional , Any [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import functools as ft [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . loader import bind_hass [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . config_validation import PLATFORM_SCHEMA [comment] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components import group [EOL] from homeassistant . helpers import intent [EOL] from homeassistant . const import ( SERVICE_OPEN_COVER , SERVICE_CLOSE_COVER , SERVICE_SET_COVER_POSITION , SERVICE_STOP_COVER , SERVICE_OPEN_COVER_TILT , SERVICE_CLOSE_COVER_TILT , SERVICE_STOP_COVER_TILT , SERVICE_SET_COVER_TILT_POSITION , STATE_OPEN , STATE_CLOSED , STATE_UNKNOWN , STATE_OPENING , STATE_CLOSING , ATTR_ENTITY_ID ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] GROUP_NAME_ALL_COVERS = [string] [EOL] ENTITY_ID_ALL_COVERS = group . ENTITY_ID_FORMAT . format ( [string] ) [EOL] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] DEVICE_CLASSES = [ [string] , [string] , ] [EOL] [EOL] DEVICE_CLASSES_SCHEMA = vol . All ( vol . Lower , vol . In ( DEVICE_CLASSES ) ) [EOL] [EOL] SUPPORT_OPEN = [number] [EOL] SUPPORT_CLOSE = [number] [EOL] SUPPORT_SET_POSITION = [number] [EOL] SUPPORT_STOP = [number] [EOL] SUPPORT_OPEN_TILT = [number] [EOL] SUPPORT_CLOSE_TILT = [number] [EOL] SUPPORT_STOP_TILT = [number] [EOL] SUPPORT_SET_TILT_POSITION = [number] [EOL] [EOL] ATTR_CURRENT_POSITION = [string] [EOL] ATTR_CURRENT_TILT_POSITION = [string] [EOL] ATTR_POSITION = [string] [EOL] ATTR_TILT_POSITION = [string] [EOL] [EOL] INTENT_OPEN_COVER = [string] [EOL] INTENT_CLOSE_COVER = [string] [EOL] [EOL] COVER_SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] COVER_SET_COVER_POSITION_SCHEMA = COVER_SERVICE_SCHEMA . extend ( { vol . Required ( ATTR_POSITION ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , } ) [EOL] [EOL] COVER_SET_COVER_TILT_POSITION_SCHEMA = COVER_SERVICE_SCHEMA . extend ( { vol . Required ( ATTR_TILT_POSITION ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , } ) [EOL] [EOL] [EOL] @ bind_hass def is_closed ( hass , entity_id = None ) : [EOL] [docstring] [EOL] entity_id = entity_id or ENTITY_ID_ALL_COVERS [EOL] return hass . states . is_state ( entity_id , STATE_CLOSED ) [EOL] [EOL] [EOL] @ bind_hass def open_cover ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] hass . services . call ( DOMAIN , SERVICE_OPEN_COVER , data ) [EOL] [EOL] [EOL] @ bind_hass def close_cover ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] hass . services . call ( DOMAIN , SERVICE_CLOSE_COVER , data ) [EOL] [EOL] [EOL] @ bind_hass def set_cover_position ( hass , position , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else { } [EOL] data [ ATTR_POSITION ] = position [EOL] hass . services . call ( DOMAIN , SERVICE_SET_COVER_POSITION , data ) [EOL] [EOL] [EOL] @ bind_hass def stop_cover ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] hass . services . call ( DOMAIN , SERVICE_STOP_COVER , data ) [EOL] [EOL] [EOL] @ bind_hass def open_cover_tilt ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] hass . services . call ( DOMAIN , SERVICE_OPEN_COVER_TILT , data ) [EOL] [EOL] [EOL] @ bind_hass def close_cover_tilt ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] hass . services . call ( DOMAIN , SERVICE_CLOSE_COVER_TILT , data ) [EOL] [EOL] [EOL] @ bind_hass def set_cover_tilt_position ( hass , tilt_position , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else { } [EOL] data [ ATTR_TILT_POSITION ] = tilt_position [EOL] hass . services . call ( DOMAIN , SERVICE_SET_COVER_TILT_POSITION , data ) [EOL] [EOL] [EOL] @ bind_hass def stop_cover_tilt ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] hass . services . call ( DOMAIN , SERVICE_STOP_COVER_TILT , data ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass , SCAN_INTERVAL , GROUP_NAME_ALL_COVERS ) [EOL] [EOL] await component . async_setup ( config ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_OPEN_COVER , COVER_SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_CLOSE_COVER , COVER_SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_SET_COVER_POSITION , COVER_SET_COVER_POSITION_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_STOP_COVER , COVER_SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_OPEN_COVER_TILT , COVER_SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_CLOSE_COVER_TILT , COVER_SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_STOP_COVER_TILT , COVER_SERVICE_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_SET_COVER_TILT_POSITION , COVER_SET_COVER_TILT_POSITION_SCHEMA , [string] ) [EOL] [EOL] hass . helpers . intent . async_register ( intent . ServiceIntentHandler ( INTENT_OPEN_COVER , DOMAIN , SERVICE_OPEN_COVER , [string] ) ) [EOL] hass . helpers . intent . async_register ( intent . ServiceIntentHandler ( INTENT_CLOSE_COVER , DOMAIN , SERVICE_CLOSE_COVER , [string] ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class CoverDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] @ property def current_cover_position ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property def current_cover_tilt_position ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . is_opening : [EOL] return STATE_OPENING [EOL] if self . is_closing : [EOL] return STATE_CLOSING [EOL] [EOL] closed = self . is_closed [EOL] [EOL] if closed is None : [EOL] return STATE_UNKNOWN [EOL] [EOL] return STATE_CLOSED if closed else STATE_OPEN [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] [EOL] current = self . current_cover_position [EOL] if current is not None : [EOL] data [ ATTR_CURRENT_POSITION ] = self . current_cover_position [EOL] [EOL] current_tilt = self . current_cover_tilt_position [EOL] if current_tilt is not None : [EOL] data [ ATTR_CURRENT_TILT_POSITION ] = self . current_cover_tilt_position [EOL] [EOL] return data [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] supported_features = SUPPORT_OPEN | SUPPORT_CLOSE | SUPPORT_STOP [EOL] [EOL] if self . current_cover_position is not None : [EOL] supported_features |= SUPPORT_SET_POSITION [EOL] [EOL] if self . current_cover_tilt_position is not None : [EOL] supported_features |= ( SUPPORT_OPEN_TILT | SUPPORT_CLOSE_TILT | SUPPORT_STOP_TILT | SUPPORT_SET_TILT_POSITION ) [EOL] [EOL] return supported_features [EOL] [EOL] @ property def is_opening ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property def is_closing ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def async_open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . open_cover , ** kwargs ) ) [EOL] [EOL] def close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def async_close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . close_cover , ** kwargs ) ) [EOL] [EOL] def set_cover_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def async_set_cover_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . set_cover_position , ** kwargs ) ) [EOL] [EOL] def stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def async_stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . stop_cover , ** kwargs ) ) [EOL] [EOL] def open_cover_tilt ( self , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def async_open_cover_tilt ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . open_cover_tilt , ** kwargs ) ) [EOL] [EOL] def close_cover_tilt ( self , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def async_close_cover_tilt ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . close_cover_tilt , ** kwargs ) ) [EOL] [EOL] def set_cover_tilt_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def async_set_cover_tilt_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . set_cover_tilt_position , ** kwargs ) ) [EOL] [EOL] def stop_cover_tilt ( self , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def async_stop_cover_tilt ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . stop_cover_tilt , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] from homeassistant . components . cover import ( CoverDevice , PLATFORM_SCHEMA , SUPPORT_OPEN , SUPPORT_CLOSE ) [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD , STATE_UNKNOWN , STATE_CLOSED ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DEVICE_ID = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICE_ID ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , } ) [EOL] [EOL] SUPPORTED_FEATURES = ( SUPPORT_OPEN | SUPPORT_CLOSE ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from py_ryobi_gdo import RyobiGDO as ryobi_door [EOL] covers = [ ] [EOL] [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] devices = config . get ( CONF_DEVICE_ID ) [EOL] [EOL] for device_id in devices : [EOL] my_door = ryobi_door ( username , password , device_id ) [EOL] _LOGGER . debug ( [string] ) [EOL] if my_door . get_api_key ( ) is False : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] _LOGGER . debug ( [string] ) [EOL] if my_door . check_device_id ( ) is False : [EOL] _LOGGER . error ( [string] , device_id ) [EOL] return [EOL] _LOGGER . debug ( [string] , device_id ) [EOL] covers . append ( RyobiCover ( hass , my_door ) ) [EOL] if covers : [EOL] _LOGGER . debug ( [string] ) [EOL] add_entities ( covers , True ) [EOL] [EOL] [EOL] class RyobiCover ( CoverDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , ryobi_door ) : [EOL] [docstring] [EOL] self . ryobi_door = ryobi_door [EOL] self . _name = [string] . format ( ryobi_door . get_device_id ( ) ) [EOL] self . _door_state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] if self . _door_state == STATE_UNKNOWN : [EOL] return False [EOL] return self . _door_state == STATE_CLOSED [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORTED_FEATURES [EOL] [EOL] def close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] self . ryobi_door . close_device ( ) [EOL] [EOL] def open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] self . ryobi_door . open_device ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] self . ryobi_door . update ( ) [EOL] self . _door_state = self . ryobi_door . get_door_status ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
from typing import Any , Tuple , List [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] from requests import RequestException [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . media_player import ( SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PREVIOUS_TRACK , PLATFORM_SCHEMA , SUPPORT_TURN_OFF , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_STEP , SUPPORT_SELECT_SOURCE , SUPPORT_PLAY , MEDIA_TYPE_CHANNEL , MediaPlayerDevice ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_ACCESS_TOKEN , STATE_OFF , STATE_PLAYING , STATE_PAUSED , STATE_UNKNOWN ) [EOL] from homeassistant import util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] SUPPORT_LGTV = SUPPORT_PAUSE | SUPPORT_VOLUME_STEP | SUPPORT_VOLUME_MUTE | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE | SUPPORT_PLAY [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_ACCESS_TOKEN ) : vol . All ( cv . string , vol . Length ( max = [number] ) ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pylgnetcast import LgNetCastClient [EOL] host = config . get ( CONF_HOST ) [EOL] access_token = config . get ( CONF_ACCESS_TOKEN ) [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] client = LgNetCastClient ( host , access_token ) [EOL] [EOL] add_entities ( [ LgTVDevice ( client , name ) ] , True ) [EOL] [EOL] [EOL] class LgTVDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , name ) : [EOL] [docstring] [EOL] self . _client = client [EOL] self . _name = name [EOL] self . _muted = False [EOL] [comment] [EOL] self . _playing = True [EOL] self . _volume = [number] [EOL] self . _channel_name = [string] [EOL] self . _program_name = [string] [EOL] self . _state = STATE_UNKNOWN [EOL] self . _sources = { } [EOL] self . _source_names = [ ] [EOL] [EOL] def send_command ( self , command ) : [EOL] [docstring] [EOL] from pylgnetcast import LgNetCastError [EOL] try : [EOL] with self . _client as client : [EOL] client . send_command ( command ) [EOL] except ( LgNetCastError , RequestException ) : [EOL] self . _state = STATE_OFF [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update ( self ) : [EOL] [docstring] [EOL] from pylgnetcast import LgNetCastError [EOL] try : [EOL] with self . _client as client : [EOL] self . _state = STATE_PLAYING [EOL] volume_info = client . query_data ( [string] ) [EOL] if volume_info : [EOL] volume_info = volume_info [ [number] ] [EOL] self . _volume = float ( volume_info . find ( [string] ) . text ) [EOL] self . _muted = volume_info . find ( [string] ) . text == [string] [EOL] [EOL] channel_info = client . query_data ( [string] ) [EOL] if channel_info : [EOL] channel_info = channel_info [ [number] ] [EOL] self . _channel_name = channel_info . find ( [string] ) . text [EOL] self . _program_name = channel_info . find ( [string] ) . text [EOL] [EOL] channel_list = client . query_data ( [string] ) [EOL] if channel_list : [EOL] channel_names = [ ] [EOL] for channel in channel_list : [EOL] channel_name = channel . find ( [string] ) [EOL] if channel_name is not None : [EOL] channel_names . append ( str ( channel_name . text ) ) [EOL] self . _sources = dict ( zip ( channel_names , channel_list ) ) [EOL] [comment] [EOL] source_tuples = [ ( k , self . _sources [ k ] . find ( [string] ) . text ) for k in self . _sources ] [EOL] sorted_sources = sorted ( source_tuples , key = lambda channel : int ( channel [ [number] ] ) ) [EOL] self . _source_names = [ n for n , k in sorted_sources ] [EOL] except ( LgNetCastError , RequestException ) : [EOL] self . _state = STATE_OFF [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _muted [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume / [number] [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _channel_name [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _source_names [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_CHANNEL [EOL] [EOL] @ property def media_channel ( self ) : [EOL] [docstring] [EOL] return self . _channel_name [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _program_name [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_LGTV [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . _client . url + [string] [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . send_command ( [number] ) [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] self . send_command ( [number] ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] self . send_command ( [number] ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . send_command ( [number] ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] self . _client . change_channel ( self . _sources [ source ] ) [EOL] [EOL] def media_play_pause ( self ) : [EOL] [docstring] [EOL] if self . _playing : [EOL] self . media_pause ( ) [EOL] else : [EOL] self . media_play ( ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _playing = True [EOL] self . _state = STATE_PLAYING [EOL] self . send_command ( [number] ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _playing = False [EOL] self . _state = STATE_PAUSED [EOL] self . send_command ( [number] ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . send_command ( [number] ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . send_command ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,unknown]]$ 0 0 0 $typing.List[typing.Tuple[typing.Any,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import socket [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_USERNAME ) [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_PORT_RECV = [string] [EOL] CONF_PORT_SEND = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_PORT_RECV ) : cv . port , vol . Required ( CONF_PORT_SEND ) : cv . port , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_HOST ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST , None ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] port_recv = config . get ( CONF_PORT_RECV ) [EOL] port_send = config . get ( CONF_PORT_SEND ) [EOL] [EOL] from anel_pwrctrl import DeviceMaster [EOL] [EOL] try : [EOL] master = DeviceMaster ( username = username , password = password , read_port = port_send , write_port = port_recv ) [EOL] master . query ( ip_addr = host ) [EOL] except socket . error as ex : [EOL] _LOGGER . error ( [string] , str ( ex ) ) [EOL] return False [EOL] [EOL] devices = [ ] [EOL] for device in master . devices . values ( ) : [EOL] parent_device = PwrCtrlDevice ( device ) [EOL] devices . extend ( PwrCtrlSwitch ( switch , parent_device ) for switch in device . switches . values ( ) ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class PwrCtrlSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , port , parent_device ) : [EOL] [docstring] [EOL] self . _port = port [EOL] self . _parent_device = parent_device [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return [string] . format ( device = self . _port . device . host , switch_idx = self . _port . get_index ( ) ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _port . label [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _port . get_state ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _parent_device . update ( ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _port . on ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _port . off ( ) [EOL] [EOL] [EOL] class PwrCtrlDevice : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] self . _device = device [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . _device . update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . vultr import ( CONF_SUBSCRIPTION , ATTR_AUTO_BACKUPS , ATTR_ALLOWED_BANDWIDTH , ATTR_CREATED_AT , ATTR_SUBSCRIPTION_ID , ATTR_SUBSCRIPTION_NAME , ATTR_IPV4_ADDRESS , ATTR_IPV6_ADDRESS , ATTR_MEMORY , ATTR_DISK , ATTR_COST_PER_MONTH , ATTR_OS , ATTR_REGION , ATTR_VCPUS , DATA_VULTR ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SUBSCRIPTION ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] vultr = hass . data [ DATA_VULTR ] [EOL] [EOL] subscription = config . get ( CONF_SUBSCRIPTION ) [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] if subscription not in vultr . data : [EOL] _LOGGER . error ( [string] , subscription ) [EOL] return False [EOL] [EOL] add_entities ( [ VultrSwitch ( vultr , subscription , name ) ] , True ) [EOL] [EOL] [EOL] class VultrSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , vultr , subscription , name ) : [EOL] [docstring] [EOL] self . _vultr = vultr [EOL] self . _name = name [EOL] [EOL] self . subscription = subscription [EOL] self . data = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] try : [EOL] return self . _name . format ( self . data [ [string] ] ) [EOL] except ( TypeError , KeyError ) : [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . data [ [string] ] == [string] [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return [string] if self . is_on else [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ALLOWED_BANDWIDTH : self . data . get ( [string] ) , ATTR_AUTO_BACKUPS : self . data . get ( [string] ) , ATTR_COST_PER_MONTH : self . data . get ( [string] ) , ATTR_CREATED_AT : self . data . get ( [string] ) , ATTR_DISK : self . data . get ( [string] ) , ATTR_IPV4_ADDRESS : self . data . get ( [string] ) , ATTR_IPV6_ADDRESS : self . data . get ( [string] ) , ATTR_MEMORY : self . data . get ( [string] ) , ATTR_OS : self . data . get ( [string] ) , ATTR_REGION : self . data . get ( [string] ) , ATTR_SUBSCRIPTION_ID : self . data . get ( [string] ) , ATTR_SUBSCRIPTION_NAME : self . data . get ( [string] ) , ATTR_VCPUS : self . data . get ( [string] ) , } [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . data [ [string] ] != [string] : [EOL] self . _vultr . start ( self . subscription ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . data [ [string] ] == [string] : [EOL] self . _vultr . halt ( self . subscription ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _vultr . update ( ) [EOL] self . data = self . _vultr . data [ self . subscription ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import homeassistant [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] import urllib [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import dt as dt_util [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( ATTR_TEMPERATURE , CONF_HOST , CONF_NAME , CONF_PASSWORD , CONF_USERNAME , TEMP_CELSIUS ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PASSWORD = [string] [EOL] DEFAULT_USERNAME = [string] [EOL] CONF_USE_LEGACY_PROTOCOL = [string] [EOL] [EOL] ATTR_TOTAL_CONSUMPTION = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_USERNAME , default = DEFAULT_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD , default = DEFAULT_PASSWORD ) : cv . string , vol . Optional ( CONF_USE_LEGACY_PROTOCOL , default = False ) : cv . boolean , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pyW215 . pyW215 import SmartPlug [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] use_legacy_protocol = config . get ( CONF_USE_LEGACY_PROTOCOL ) [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] smartplug = SmartPlug ( host , password , username , use_legacy_protocol ) [EOL] data = SmartPlugData ( smartplug ) [EOL] [EOL] add_entities ( [ SmartPlugSwitch ( hass , data , name ) ] , True ) [EOL] [EOL] [EOL] class SmartPlugSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , data , name ) : [EOL] [docstring] [EOL] self . units = hass . config . units [EOL] self . data = data [EOL] self . _name = name [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] try : [EOL] ui_temp = self . units . temperature ( int ( self . data . temperature ) , TEMP_CELSIUS ) [EOL] temperature = ui_temp [EOL] except ( ValueError , TypeError ) : [EOL] temperature = None [EOL] [EOL] try : [EOL] total_consumption = float ( self . data . total_consumption ) [EOL] except ( ValueError , TypeError ) : [EOL] total_consumption = None [EOL] [EOL] attrs = { ATTR_TOTAL_CONSUMPTION : total_consumption , ATTR_TEMPERATURE : temperature , } [EOL] [EOL] return attrs [EOL] [EOL] @ property def current_power_w ( self ) : [EOL] [docstring] [EOL] try : [EOL] return float ( self . data . current_consumption ) [EOL] except ( ValueError , TypeError ) : [EOL] return None [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . data . state == [string] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . data . smartplug . state = [string] [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . data . smartplug . state = [string] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . data . available [EOL] [EOL] [EOL] class SmartPlugData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , smartplug ) : [EOL] [docstring] [EOL] self . smartplug = smartplug [EOL] self . state = None [EOL] self . temperature = None [EOL] self . current_consumption = None [EOL] self . total_consumption = None [EOL] self . available = False [EOL] self . _n_tried = [number] [EOL] self . _last_tried = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . _last_tried is not None : [EOL] last_try_s = ( dt_util . now ( ) - self . _last_tried ) . total_seconds ( ) / [number] [EOL] retry_seconds = min ( self . _n_tried * [number] , [number] ) - last_try_s [EOL] if self . _n_tried > [number] and retry_seconds > [number] : [EOL] _LOGGER . warning ( [string] , retry_seconds ) [EOL] return [EOL] [EOL] _state = [string] [EOL] try : [EOL] self . _last_tried = dt_util . now ( ) [EOL] _state = self . smartplug . state [EOL] except urllib . error . HTTPError : [EOL] _LOGGER . error ( [string] ) [EOL] if _state == [string] : [EOL] self . _n_tried += [number] [EOL] self . available = False [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] self . state = _state [EOL] self . available = True [EOL] [EOL] self . temperature = self . smartplug . temperature [EOL] self . current_consumption = self . smartplug . current_consumption [EOL] self . total_consumption = self . smartplug . total_consumption [EOL] self . _n_tried = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 $builtins.str$ 0 $None$ 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
from typing import Any , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . switch import SwitchDevice , PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME , CONF_MAC [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] HANDLE = [number] [EOL] ON_KEY = [string] [EOL] OFF_KEY = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MAC ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] mac_addr = config . get ( CONF_MAC ) [EOL] add_entities ( [ Switchmate ( mac_addr , name ) ] , True ) [EOL] [EOL] [EOL] class Switchmate ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mac , name ) : [EOL] [docstring] [EOL] [comment] [EOL] import bluepy [EOL] self . _state = False [EOL] self . _name = name [EOL] self . _mac = mac [EOL] try : [EOL] self . _device = bluepy . btle . Peripheral ( self . _mac , bluepy . btle . ADDR_TYPE_RANDOM ) [EOL] except bluepy . btle . BTLEException : [EOL] _LOGGER . error ( [string] ) [EOL] raise PlatformNotReady ( ) [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _mac . replace ( [string] , [string] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _state = self . _device . readCharacteristic ( HANDLE ) == ON_KEY [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _device . writeCharacteristic ( HANDLE , ON_KEY , True ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _device . writeCharacteristic ( HANDLE , OFF_KEY , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . gc100 import DATA_GC100 , CONF_PORTS [EOL] from homeassistant . components . switch import ( PLATFORM_SCHEMA ) [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] from homeassistant . const import DEVICE_DEFAULT_NAME [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _SWITCH_SCHEMA = vol . Schema ( { cv . string : cv . string , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_PORTS ) : vol . All ( cv . ensure_list , [ _SWITCH_SCHEMA ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] switches = [ ] [EOL] ports = config . get ( CONF_PORTS ) [EOL] for port in ports : [EOL] for port_addr , port_name in port . items ( ) : [EOL] switches . append ( GC100Switch ( port_name , port_addr , hass . data [ DATA_GC100 ] ) ) [EOL] add_entities ( switches , True ) [EOL] [EOL] [EOL] class GC100Switch ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , port_addr , gc100 ) : [EOL] [docstring] [EOL] self . _name = name or DEVICE_DEFAULT_NAME [EOL] self . _port_addr = port_addr [EOL] self . _gc100 = gc100 [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _gc100 . write_switch ( self . _port_addr , [number] , self . set_state ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _gc100 . write_switch ( self . _port_addr , [number] , self . set_state ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _gc100 . read_sensor ( self . _port_addr , self . set_state ) [EOL] [EOL] def set_state ( self , state ) : [EOL] [docstring] [EOL] self . _state = state == [number] [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components import rpi_pfio [EOL] from homeassistant . components . switch import PLATFORM_SCHEMA [EOL] from homeassistant . const import ATTR_NAME , DEVICE_DEFAULT_NAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] ATTR_INVERT_LOGIC = [string] [EOL] [EOL] CONF_PORTS = [string] [EOL] [EOL] DEFAULT_INVERT_LOGIC = False [EOL] [EOL] PORT_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_NAME ) : cv . string , vol . Optional ( ATTR_INVERT_LOGIC , default = DEFAULT_INVERT_LOGIC ) : cv . boolean , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_PORTS , default = { } ) : vol . Schema ( { cv . positive_int : PORT_SCHEMA , } ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] switches = [ ] [EOL] ports = config . get ( CONF_PORTS ) [EOL] for port , port_entity in ports . items ( ) : [EOL] name = port_entity . get ( ATTR_NAME ) [EOL] invert_logic = port_entity [ ATTR_INVERT_LOGIC ] [EOL] [EOL] switches . append ( RPiPFIOSwitch ( port , name , invert_logic ) ) [EOL] add_entities ( switches ) [EOL] [EOL] [EOL] class RPiPFIOSwitch ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , port , name , invert_logic ) : [EOL] [docstring] [EOL] self . _port = port [EOL] self . _name = name or DEVICE_DEFAULT_NAME [EOL] self . _invert_logic = invert_logic [EOL] self . _state = False [EOL] rpi_pfio . write_output ( self . _port , [number] if self . _invert_logic else [number] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] rpi_pfio . write_output ( self . _port , [number] if self . _invert_logic else [number] ) [EOL] self . _state = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] rpi_pfio . write_output ( self . _port , [number] if self . _invert_logic else [number] ) [EOL] self . _state = False [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] from collections import OrderedDict [EOL] import logging [EOL] import os [EOL] [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import config_entries , data_entry_flow [EOL] from homeassistant . core import callback [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] from homeassistant . util . json import load_json [EOL] [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] DATA_FLOW_IMPL = [string] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ callback def register_flow_implementation ( hass , domain , name , gen_authorize_url , convert_code ) : [EOL] [docstring] [EOL] if DATA_FLOW_IMPL not in hass . data : [EOL] hass . data [ DATA_FLOW_IMPL ] = OrderedDict ( ) [EOL] [EOL] hass . data [ DATA_FLOW_IMPL ] [ domain ] = { [string] : domain , [string] : name , [string] : gen_authorize_url , [string] : convert_code , } [EOL] [EOL] [EOL] class NestAuthError ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CodeInvalid ( NestAuthError ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ config_entries . HANDLERS . register ( DOMAIN ) class NestFlowHandler ( data_entry_flow . FlowHandler ) : [EOL] [docstring] [EOL] [EOL] VERSION = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . flow_impl = None [EOL] [EOL] async def async_step_user ( self , user_input = None ) : [EOL] [docstring] [EOL] return await self . async_step_init ( user_input ) [EOL] [EOL] async def async_step_init ( self , user_input = None ) : [EOL] [docstring] [EOL] flows = self . hass . data . get ( DATA_FLOW_IMPL , { } ) [EOL] [EOL] if self . hass . config_entries . async_entries ( DOMAIN ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] if not flows : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] if len ( flows ) == [number] : [EOL] self . flow_impl = list ( flows ) [ [number] ] [EOL] return await self . async_step_link ( ) [EOL] [EOL] if user_input is not None : [EOL] self . flow_impl = user_input [ [string] ] [EOL] return await self . async_step_link ( ) [EOL] [EOL] return self . async_show_form ( step_id = [string] , data_schema = vol . Schema ( { vol . Required ( [string] ) : vol . In ( list ( flows ) ) } ) ) [EOL] [EOL] async def async_step_link ( self , user_input = None ) : [EOL] [docstring] [EOL] flow = self . hass . data [ DATA_FLOW_IMPL ] [ self . flow_impl ] [EOL] [EOL] errors = { } [EOL] [EOL] if user_input is not None : [EOL] try : [EOL] with async_timeout . timeout ( [number] ) : [EOL] tokens = await flow [ [string] ] ( user_input [ [string] ] ) [EOL] return self . _entry_from_tokens ( [string] . format ( flow [ [string] ] ) , flow , tokens ) [EOL] [EOL] except asyncio . TimeoutError : [EOL] errors [ [string] ] = [string] [EOL] except CodeInvalid : [EOL] errors [ [string] ] = [string] [EOL] except NestAuthError : [EOL] errors [ [string] ] = [string] [EOL] except Exception : [comment] [EOL] errors [ [string] ] = [string] [EOL] _LOGGER . exception ( [string] ) [EOL] [EOL] try : [EOL] with async_timeout . timeout ( [number] ) : [EOL] url = await flow [ [string] ] ( self . flow_id ) [EOL] except asyncio . TimeoutError : [EOL] return self . async_abort ( reason = [string] ) [EOL] except Exception : [comment] [EOL] _LOGGER . exception ( [string] ) [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] return self . async_show_form ( step_id = [string] , description_placeholders = { [string] : url } , data_schema = vol . Schema ( { vol . Required ( [string] ) : str , } ) , errors = errors , ) [EOL] [EOL] async def async_step_import ( self , info ) : [EOL] [docstring] [EOL] if self . hass . config_entries . async_entries ( DOMAIN ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] config_path = info [ [string] ] [EOL] [EOL] if not await self . hass . async_add_job ( os . path . isfile , config_path ) : [EOL] self . flow_impl = DOMAIN [EOL] return await self . async_step_link ( ) [EOL] [EOL] flow = self . hass . data [ DATA_FLOW_IMPL ] [ DOMAIN ] [EOL] tokens = await self . hass . async_add_job ( load_json , config_path ) [EOL] [EOL] return self . _entry_from_tokens ( [string] , flow , tokens ) [EOL] [EOL] @ callback def _entry_from_tokens ( self , title , flow , tokens ) : [EOL] [docstring] [EOL] return self . async_create_entry ( title = title , data = { [string] : tokens , [string] : flow [ [string] ] , } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import requests [EOL] [EOL] from homeassistant . components import nest [EOL] from homeassistant . components . camera import ( PLATFORM_SCHEMA , Camera , SUPPORT_ON_OFF ) [EOL] from homeassistant . util . dt import utcnow [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] NEST_BRAND = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry , async_add_entities ) : [EOL] [docstring] [EOL] camera_devices = await hass . async_add_job ( hass . data [ nest . DATA_NEST ] . cameras ) [EOL] cameras = [ NestCamera ( structure , device ) for structure , device in camera_devices ] [EOL] async_add_entities ( cameras , True ) [EOL] [EOL] [EOL] class NestCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , structure , device ) : [EOL] [docstring] [EOL] super ( NestCamera , self ) . __init__ ( ) [EOL] self . structure = structure [EOL] self . device = device [EOL] self . _location = None [EOL] self . _name = None [EOL] self . _online = None [EOL] self . _is_streaming = None [EOL] self . _is_video_history_enabled = False [EOL] [comment] [EOL] self . _time_between_snapshots = timedelta ( seconds = [number] ) [EOL] self . _last_image = None [EOL] self . _next_snapshot_at = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def is_recording ( self ) : [EOL] [docstring] [EOL] return self . _is_streaming [EOL] [EOL] @ property def brand ( self ) : [EOL] [docstring] [EOL] return NEST_BRAND [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_ON_OFF [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _online and self . _is_streaming [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . device . is_streaming = False [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] if not self . _online : [EOL] _LOGGER . error ( [string] , self . _name ) [EOL] return [EOL] [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . device . is_streaming = True [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _location = self . device . where [EOL] self . _name = self . device . name [EOL] self . _online = self . device . online [EOL] self . _is_streaming = self . device . is_streaming [EOL] self . _is_video_history_enabled = self . device . is_video_history_enabled [EOL] [EOL] if self . _is_video_history_enabled : [EOL] [comment] [EOL] self . _time_between_snapshots = timedelta ( seconds = [number] ) [EOL] else : [EOL] [comment] [EOL] self . _time_between_snapshots = timedelta ( seconds = [number] ) [EOL] [EOL] def _ready_for_snapshot ( self , now ) : [EOL] return ( self . _next_snapshot_at is None or now > self . _next_snapshot_at ) [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] now = utcnow ( ) [EOL] if self . _ready_for_snapshot ( now ) : [EOL] url = self . device . snapshot_url [EOL] [EOL] try : [EOL] response = requests . get ( url ) [EOL] except requests . exceptions . RequestException as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] return None [EOL] [EOL] self . _next_snapshot_at = now + self . _time_between_snapshots [EOL] self . _last_image = response . content [EOL] [EOL] return self . _last_image [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] import random [EOL] from datetime import timedelta [EOL] from math import pi , cos , sin , radians [EOL] [EOL] from typing import Optional [EOL] [EOL] from homeassistant . components . geo_location import GeoLocationEvent [EOL] from homeassistant . helpers . event import track_time_interval [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] AVG_KM_PER_DEGREE = [number] [EOL] DEFAULT_UNIT_OF_MEASUREMENT = [string] [EOL] DEFAULT_UPDATE_INTERVAL = timedelta ( minutes = [number] ) [EOL] MAX_RADIUS_IN_KM = [number] [EOL] NUMBER_OF_DEMO_DEVICES = [number] [EOL] [EOL] EVENT_NAMES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] DemoManager ( hass , add_entities ) [EOL] [EOL] [EOL] class DemoManager : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , add_entities ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _add_entities = add_entities [EOL] self . _managed_devices = [ ] [EOL] self . _update ( count = NUMBER_OF_DEMO_DEVICES ) [EOL] self . _init_regular_updates ( ) [EOL] [EOL] def _generate_random_event ( self ) : [EOL] [docstring] [EOL] home_latitude = self . _hass . config . latitude [EOL] home_longitude = self . _hass . config . longitude [EOL] [EOL] [comment] [EOL] radius_in_degrees = random . random ( ) * MAX_RADIUS_IN_KM / AVG_KM_PER_DEGREE [EOL] radius_in_km = radius_in_degrees * AVG_KM_PER_DEGREE [EOL] angle = random . random ( ) * [number] * pi [EOL] [comment] [EOL] [comment] [EOL] latitude = home_latitude + radius_in_degrees * sin ( angle ) [EOL] longitude = home_longitude + radius_in_degrees * cos ( angle ) / cos ( radians ( home_latitude ) ) [EOL] [EOL] event_name = random . choice ( EVENT_NAMES ) [EOL] return DemoGeoLocationEvent ( event_name , radius_in_km , latitude , longitude , DEFAULT_UNIT_OF_MEASUREMENT ) [EOL] [EOL] def _init_regular_updates ( self ) : [EOL] [docstring] [EOL] track_time_interval ( self . _hass , lambda now : self . _update ( ) , DEFAULT_UPDATE_INTERVAL ) [EOL] [EOL] def _update ( self , count = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] for _ in range ( [number] , count + [number] ) : [EOL] if self . _managed_devices : [EOL] device = random . choice ( self . _managed_devices ) [EOL] if device : [EOL] _LOGGER . debug ( [string] , device ) [EOL] self . _managed_devices . remove ( device ) [EOL] self . _hass . add_job ( device . async_remove ( ) ) [EOL] [comment] [EOL] new_devices = [ ] [EOL] for _ in range ( [number] , count + [number] ) : [EOL] new_device = self . _generate_random_event ( ) [EOL] _LOGGER . debug ( [string] , new_device ) [EOL] new_devices . append ( new_device ) [EOL] self . _managed_devices . append ( new_device ) [EOL] self . _add_entities ( new_devices ) [EOL] [EOL] [EOL] class DemoGeoLocationEvent ( GeoLocationEvent ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , distance , latitude , longitude , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _distance = distance [EOL] self . _latitude = latitude [EOL] self . _longitude = longitude [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def distance ( self ) : [EOL] [docstring] [EOL] return self . _distance [EOL] [EOL] @ property def latitude ( self ) : [EOL] [docstring] [EOL] return self . _latitude [EOL] [EOL] @ property def longitude ( self ) : [EOL] [docstring] [EOL] return self . _longitude [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] import xml [EOL] import logging [EOL] import datetime [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] import xml . etree . ElementTree as ET [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ID = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ID ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] ohmid = config . get ( CONF_ID ) [EOL] [EOL] add_entities ( [ OhmconnectSensor ( name , ohmid ) ] , True ) [EOL] [EOL] [EOL] class OhmconnectSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , ohmid ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _ohmid = ohmid [EOL] self . _data = { } [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _data . get ( [string] ) == [string] : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _data . get ( [string] ) , [string] : self . _ohmid } [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] url = ( [string] [string] ) . format ( self . _ohmid ) [EOL] response = requests . get ( url , timeout = [number] ) [EOL] root = ET . fromstring ( response . text ) [EOL] [EOL] for child in root : [EOL] self . _data [ child . tag ] = child . text [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] , url ) [EOL] self . _data = { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $xml.etree.ElementTree.Element$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $xml.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . daikin import ( SENSOR_TYPES , SENSOR_TYPE_TEMPERATURE , ATTR_INSIDE_TEMPERATURE , ATTR_OUTSIDE_TEMPERATURE , daikin_api_setup ) [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_ICON , CONF_NAME , CONF_MONITORED_CONDITIONS , CONF_TYPE ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util . unit_system import UnitSystem [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , } ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] host = discovery_info . get ( [string] ) [EOL] name = None [EOL] monitored_conditions = discovery_info . get ( CONF_MONITORED_CONDITIONS , list ( SENSOR_TYPES . keys ( ) ) ) [EOL] else : [EOL] host = config [ CONF_HOST ] [EOL] name = config . get ( CONF_NAME ) [EOL] monitored_conditions = config [ CONF_MONITORED_CONDITIONS ] [EOL] _LOGGER . info ( [string] , host ) [EOL] [EOL] api = daikin_api_setup ( hass , host , name ) [EOL] units = hass . config . units [EOL] sensors = [ ] [EOL] for monitored_state in monitored_conditions : [EOL] sensors . append ( DaikinClimateSensor ( api , monitored_state , units , name ) ) [EOL] [EOL] add_entities ( sensors , True ) [EOL] [EOL] [EOL] class DaikinClimateSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api , monitored_state , units , name = None ) : [EOL] [docstring] [EOL] self . _api = api [EOL] self . _sensor = SENSOR_TYPES . get ( monitored_state ) [EOL] if name is None : [EOL] name = [string] . format ( self . _sensor [ CONF_NAME ] , api . name ) [EOL] [EOL] self . _name = [string] . format ( name , monitored_state . replace ( [string] , [string] ) ) [EOL] self . _device_attribute = monitored_state [EOL] [EOL] if self . _sensor [ CONF_TYPE ] == SENSOR_TYPE_TEMPERATURE : [EOL] self . _unit_of_measurement = units . temperature_unit [EOL] [EOL] def get ( self , key ) : [EOL] [docstring] [EOL] value = None [EOL] cast_to_float = False [EOL] [EOL] if key == ATTR_INSIDE_TEMPERATURE : [EOL] value = self . _api . device . values . get ( [string] ) [EOL] cast_to_float = True [EOL] elif key == ATTR_OUTSIDE_TEMPERATURE : [EOL] value = self . _api . device . values . get ( [string] ) [EOL] [EOL] if value is None : [EOL] _LOGGER . warning ( [string] , key ) [EOL] else : [EOL] if value in ( [string] , [string] ) : [EOL] value = None [EOL] elif cast_to_float : [EOL] try : [EOL] value = float ( value ) [EOL] except ValueError : [EOL] value = None [EOL] [EOL] return value [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _sensor [ CONF_ICON ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . get ( self . _device_attribute ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _api . update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $homeassistant.util.unit_system.UnitSystem$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.util.unit_system.UnitSystem$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict , List [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( TEMP_CELSIUS , CONF_NAME , CONF_MONITORED_CONDITIONS ) [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] DOMAIN = [string] [EOL] DEFAULT_NAME = [string] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] , [string] , TEMP_CELSIUS ] , [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] octoprint_api = hass . data [ DOMAIN ] [ [string] ] [EOL] name = config . get ( CONF_NAME ) [EOL] monitored_conditions = config . get ( CONF_MONITORED_CONDITIONS ) [EOL] tools = octoprint_api . get_tools ( ) [EOL] [EOL] if [string] in monitored_conditions : [EOL] if not tools : [EOL] hass . components . persistent_notification . create ( [string] [string] [string] [string] [string] [string] , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] [EOL] devices = [ ] [EOL] types = [ [string] , [string] ] [EOL] for octo_type in monitored_conditions : [EOL] if octo_type == [string] : [EOL] for tool in tools : [EOL] for temp_type in types : [EOL] new_sensor = OctoPrintSensor ( octoprint_api , temp_type , temp_type , name , SENSOR_TYPES [ octo_type ] [ [number] ] , SENSOR_TYPES [ octo_type ] [ [number] ] , SENSOR_TYPES [ octo_type ] [ [number] ] , tool ) [EOL] devices . append ( new_sensor ) [EOL] else : [EOL] new_sensor = OctoPrintSensor ( octoprint_api , octo_type , SENSOR_TYPES [ octo_type ] [ [number] ] , name , SENSOR_TYPES [ octo_type ] [ [number] ] , SENSOR_TYPES [ octo_type ] [ [number] ] , SENSOR_TYPES [ octo_type ] [ [number] ] ) [EOL] devices . append ( new_sensor ) [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class OctoPrintSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api , condition , sensor_type , sensor_name , unit , endpoint , group , tool = None ) : [EOL] [docstring] [EOL] self . sensor_name = sensor_name [EOL] if tool is None : [EOL] self . _name = [string] . format ( sensor_name , condition ) [EOL] else : [EOL] self . _name = [string] . format ( sensor_name , condition , tool , [string] ) [EOL] self . sensor_type = sensor_type [EOL] self . api = api [EOL] self . _state = None [EOL] self . _unit_of_measurement = unit [EOL] self . api_endpoint = endpoint [EOL] self . api_group = group [EOL] self . api_tool = tool [EOL] _LOGGER . debug ( [string] , self ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] sensor_unit = self . unit_of_measurement [EOL] if sensor_unit in ( TEMP_CELSIUS , [string] ) : [EOL] [comment] [EOL] if self . _state is None : [EOL] self . _state = [number] [EOL] return round ( self . _state , [number] ) [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _state = self . api . update ( self . sensor_type , self . api_endpoint , self . api_group , self . api_tool ) [EOL] except requests . exceptions . ConnectionError : [EOL] [comment] [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import DefaultDict , Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] from collections import defaultdict [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_USERNAME , CONF_PASSWORD , ATTR_ATTRIBUTION ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import slugify [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . util . dt import now , parse_date [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_UPDATE_INTERVAL = [string] [EOL] COOKIE = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] STATUS_DELIVERED = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_UPDATE_INTERVAL , default = timedelta ( seconds = [number] ) ) : vol . All ( cv . time_period , cv . positive_timedelta ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import fedexdeliverymanager [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] update_interval = config . get ( CONF_UPDATE_INTERVAL ) [EOL] [EOL] try : [EOL] cookie = hass . config . path ( COOKIE ) [EOL] session = fedexdeliverymanager . get_session ( config . get ( CONF_USERNAME ) , config . get ( CONF_PASSWORD ) , cookie_path = cookie ) [EOL] except fedexdeliverymanager . FedexError : [EOL] _LOGGER . exception ( [string] ) [EOL] return False [EOL] [EOL] add_entities ( [ FedexSensor ( session , name , update_interval ) ] , True ) [EOL] [EOL] [EOL] class FedexSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session , name , interval ) : [EOL] [docstring] [EOL] self . _session = session [EOL] self . _name = name [EOL] self . _attributes = None [EOL] self . _state = None [EOL] self . update = Throttle ( interval ) ( self . _update ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name or DOMAIN [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def _update ( self ) : [EOL] [docstring] [EOL] import fedexdeliverymanager [EOL] status_counts = defaultdict ( int ) [EOL] for package in fedexdeliverymanager . get_packages ( self . _session ) : [EOL] status = slugify ( package [ [string] ] ) [EOL] skip = status == STATUS_DELIVERED and parse_date ( package [ [string] ] ) < now ( ) . date ( ) [EOL] if skip : [EOL] continue [EOL] status_counts [ status ] += [number] [EOL] self . _attributes = { ATTR_ATTRIBUTION : fedexdeliverymanager . ATTRIBUTION } [EOL] self . _attributes . update ( status_counts ) [EOL] self . _state = sum ( status_counts . values ( ) ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
from typing import Any , List [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import json [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_VALUE_TEMPLATE , STATE_UNKNOWN , CONF_UNIT_OF_MEASUREMENT ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DEVICE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICE ) : cv . string , vol . Required ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_UNIT_OF_MEASUREMENT ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import dweepy [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] device = config . get ( CONF_DEVICE ) [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] unit = config . get ( CONF_UNIT_OF_MEASUREMENT ) [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] try : [EOL] content = json . dumps ( dweepy . get_latest_dweet_for ( device ) [ [number] ] [ [string] ] ) [EOL] except dweepy . DweepyError : [EOL] _LOGGER . error ( [string] , device ) [EOL] return False [EOL] [EOL] if value_template . render_with_possible_json_value ( content ) == [string] : [EOL] _LOGGER . error ( [string] , value_template ) [EOL] return False [EOL] [EOL] dweet = DweetData ( device ) [EOL] [EOL] add_entities ( [ DweetSensor ( hass , dweet , name , value_template , unit ) ] , True ) [EOL] [EOL] [EOL] class DweetSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , dweet , name , value_template , unit_of_measurement ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . dweet = dweet [EOL] self . _name = name [EOL] self . _value_template = value_template [EOL] self . _state = STATE_UNKNOWN [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . dweet . update ( ) [EOL] [EOL] if self . dweet . data is None : [EOL] self . _state = STATE_UNKNOWN [EOL] else : [EOL] values = json . dumps ( self . dweet . data [ [number] ] [ [string] ] ) [EOL] self . _state = self . _value_template . render_with_possible_json_value ( values , STATE_UNKNOWN ) [EOL] [EOL] [EOL] class DweetData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] self . _device = device [EOL] self . data = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] import dweepy [EOL] [EOL] try : [EOL] self . data = dweepy . get_latest_dweet_for ( self . _device ) [EOL] except dweepy . DweepyError : [EOL] _LOGGER . warning ( [string] , self . _device ) [EOL] self . data = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import socket [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] import socket [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_RESOURCES , STATE_OFF , STATE_ON , CONF_TYPE [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ARG = [string] [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_RESOURCES , default = { CONF_TYPE : [string] } ) : vol . All ( cv . ensure_list , [ vol . Schema ( { vol . Required ( CONF_TYPE ) : vol . In ( SENSOR_TYPES ) , vol . Optional ( CONF_ARG ) : cv . string , } ) ] ) } ) [EOL] [EOL] IO_COUNTER = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] IF_ADDRS_FAMILY = { [string] : socket . AF_INET , [string] : socket . AF_INET6 , } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] dev = [ ] [EOL] for resource in config [ CONF_RESOURCES ] : [EOL] if CONF_ARG not in resource : [EOL] resource [ CONF_ARG ] = [string] [EOL] dev . append ( SystemMonitorSensor ( resource [ CONF_TYPE ] , resource [ CONF_ARG ] ) ) [EOL] [EOL] add_entities ( dev , True ) [EOL] [EOL] [EOL] class SystemMonitorSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor_type , argument = [string] ) : [EOL] [docstring] [EOL] self . _name = [string] . format ( SENSOR_TYPES [ sensor_type ] [ [number] ] , argument ) [EOL] self . argument = argument [EOL] self . type = sensor_type [EOL] self . _state = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name . rstrip ( ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES [ self . type ] [ [number] ] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] import psutil [EOL] if self . type == [string] : [EOL] self . _state = psutil . disk_usage ( self . argument ) . percent [EOL] elif self . type == [string] : [EOL] self . _state = round ( psutil . disk_usage ( self . argument ) . used / [number] ** [number] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( psutil . disk_usage ( self . argument ) . free / [number] ** [number] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = psutil . virtual_memory ( ) . percent [EOL] elif self . type == [string] : [EOL] virtual_memory = psutil . virtual_memory ( ) [EOL] self . _state = round ( ( virtual_memory . total - virtual_memory . available ) / [number] ** [number] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( psutil . virtual_memory ( ) . available / [number] ** [number] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = psutil . swap_memory ( ) . percent [EOL] elif self . type == [string] : [EOL] self . _state = round ( psutil . swap_memory ( ) . used / [number] ** [number] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( psutil . swap_memory ( ) . free / [number] ** [number] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( psutil . cpu_percent ( interval = None ) ) [EOL] elif self . type == [string] : [EOL] for proc in psutil . process_iter ( ) : [EOL] try : [EOL] if self . argument == proc . name ( ) : [EOL] self . _state = STATE_ON [EOL] return [EOL] except psutil . NoSuchProcess as err : [EOL] _LOGGER . warning ( [string] , err . pid , err . name ) [EOL] self . _state = STATE_OFF [EOL] elif self . type == [string] or self . type == [string] : [EOL] counters = psutil . net_io_counters ( pernic = True ) [EOL] if self . argument in counters : [EOL] counter = counters [ self . argument ] [ IO_COUNTER [ self . type ] ] [EOL] self . _state = round ( counter / [number] ** [number] , [number] ) [EOL] else : [EOL] self . _state = None [EOL] elif self . type == [string] or self . type == [string] : [EOL] counters = psutil . net_io_counters ( pernic = True ) [EOL] if self . argument in counters : [EOL] self . _state = counters [ self . argument ] [ IO_COUNTER [ self . type ] ] [EOL] else : [EOL] self . _state = None [EOL] elif self . type == [string] or self . type == [string] : [EOL] addresses = psutil . net_if_addrs ( ) [EOL] if self . argument in addresses : [EOL] for addr in addresses [ self . argument ] : [EOL] if addr . family == IF_ADDRS_FAMILY [ self . type ] : [EOL] self . _state = addr . address [EOL] else : [EOL] self . _state = None [EOL] elif self . type == [string] : [EOL] self . _state = dt_util . as_local ( dt_util . utc_from_timestamp ( psutil . boot_time ( ) ) ) . date ( ) . isoformat ( ) [EOL] elif self . type == [string] : [EOL] self . _state = dt_util . utcnow ( ) - dt_util . utc_from_timestamp ( psutil . boot_time ( ) ) [EOL] elif self . type == [string] : [EOL] self . _state = os . getloadavg ( ) [ [number] ] [EOL] elif self . type == [string] : [EOL] self . _state = os . getloadavg ( ) [ [number] ] [EOL] elif self . type == [string] : [EOL] self . _state = os . getloadavg ( ) [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,socket.AddressFamily]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,socket.AddressFamily]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_ICON , CONF_NAME , CONF_PORT , CONF_RESOURCES ) [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] CONF_ELEMENT = [string] [EOL] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] DEFAULT_ICON = [string] [EOL] [EOL] RESOURCE_SCHEMA = vol . Any ( { vol . Required ( CONF_ELEMENT ) : cv . string , vol . Optional ( CONF_ICON , default = DEFAULT_ICON ) : cv . icon , vol . Optional ( CONF_NAME ) : cv . string , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Required ( CONF_RESOURCES ) : vol . Schema ( { cv . string : RESOURCE_SCHEMA } ) , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from netdata import Netdata [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] resources = config . get ( CONF_RESOURCES ) [EOL] [EOL] session = async_get_clientsession ( hass ) [EOL] netdata = NetdataData ( Netdata ( host , hass . loop , session , port = port ) ) [EOL] await netdata . async_update ( ) [EOL] [EOL] if netdata . api . metrics is None : [EOL] raise PlatformNotReady [EOL] [EOL] dev = [ ] [EOL] for entry , data in resources . items ( ) : [EOL] sensor = entry [EOL] element = data [ CONF_ELEMENT ] [EOL] sensor_name = icon = None [EOL] try : [EOL] resource_data = netdata . api . metrics [ sensor ] [EOL] unit = [string] if resource_data [ [string] ] == [string] else \ [EOL] resource_data [ [string] ] [EOL] if data is not None : [EOL] sensor_name = data . get ( CONF_NAME ) [EOL] icon = data . get ( CONF_ICON ) [EOL] except KeyError : [EOL] _LOGGER . error ( [string] , sensor ) [EOL] continue [EOL] [EOL] dev . append ( NetdataSensor ( netdata , name , sensor , sensor_name , element , icon , unit ) ) [EOL] [EOL] async_add_entities ( dev , True ) [EOL] [EOL] [EOL] class NetdataSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , netdata , name , sensor , sensor_name , element , icon , unit ) : [EOL] [docstring] [EOL] self . netdata = netdata [EOL] self . _state = None [EOL] self . _sensor = sensor [EOL] self . _element = element [EOL] self . _sensor_name = self . _sensor if sensor_name is None else \ [EOL] sensor_name [EOL] self . _name = name [EOL] self . _icon = icon [EOL] self . _unit_of_measurement = unit [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name , self . _sensor_name ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . netdata . available [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] await self . netdata . async_update ( ) [EOL] resource_data = self . netdata . api . metrics . get ( self . _sensor ) [EOL] self . _state = round ( resource_data [ [string] ] [ self . _element ] [ [string] ] , [number] ) [EOL] [EOL] [EOL] class NetdataData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api ) : [EOL] [docstring] [EOL] self . api = api [EOL] self . available = True [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) async def async_update ( self ) : [EOL] [docstring] [EOL] from netdata . exceptions import NetdataError [EOL] [EOL] try : [EOL] await self . api . get_allmetrics ( ) [EOL] self . available = True [EOL] except NetdataError : [EOL] _LOGGER . error ( [string] ) [EOL] self . available = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant import config_entries , data_entry_flow [EOL] from homeassistant . const import ( CONF_NAME , CONF_LATITUDE , CONF_LONGITUDE , CONF_ICON , CONF_RADIUS ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . util import slugify [EOL] [EOL] from . const import CONF_PASSIVE , DOMAIN , HOME_ZONE [EOL] [EOL] [EOL] @ callback def configured_zones ( hass ) : [EOL] [docstring] [EOL] return set ( ( slugify ( entry . data [ CONF_NAME ] ) ) for entry in hass . config_entries . async_entries ( DOMAIN ) ) [EOL] [EOL] [EOL] @ config_entries . HANDLERS . register ( DOMAIN ) class ZoneFlowHandler ( data_entry_flow . FlowHandler ) : [EOL] [docstring] [EOL] [EOL] VERSION = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] async def async_step_user ( self , user_input = None ) : [EOL] [docstring] [EOL] return await self . async_step_init ( user_input ) [EOL] [EOL] async def async_step_init ( self , user_input = None ) : [EOL] [docstring] [EOL] errors = { } [EOL] [EOL] if user_input is not None : [EOL] name = slugify ( user_input [ CONF_NAME ] ) [EOL] if name not in configured_zones ( self . hass ) and name != HOME_ZONE : [EOL] return self . async_create_entry ( title = user_input [ CONF_NAME ] , data = user_input , ) [EOL] errors [ [string] ] = [string] [EOL] [EOL] return self . async_show_form ( step_id = [string] , data_schema = vol . Schema ( { vol . Required ( CONF_NAME ) : str , vol . Required ( CONF_LATITUDE ) : cv . latitude , vol . Required ( CONF_LONGITUDE ) : cv . longitude , vol . Optional ( CONF_RADIUS ) : vol . Coerce ( float ) , vol . Optional ( CONF_ICON ) : str , vol . Optional ( CONF_PASSIVE ) : bool , } ) , errors = errors , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0
import ssl [EOL] [docstring] [EOL] import ssl [EOL] [EOL] import certifi [EOL] [EOL] [EOL] def client_context ( ) : [EOL] [docstring] [EOL] context = ssl . create_default_context ( purpose = ssl . Purpose . SERVER_AUTH , cafile = certifi . where ( ) ) [EOL] return context [EOL] [EOL] [EOL] def server_context_modern ( ) : [EOL] [docstring] [EOL] context = ssl . SSLContext ( ssl . PROTOCOL_TLS ) [comment] [EOL] [EOL] context . options |= ( ssl . OP_NO_SSLv2 | ssl . OP_NO_SSLv3 | ssl . OP_NO_TLSv1 | ssl . OP_NO_TLSv1_1 | ssl . OP_CIPHER_SERVER_PREFERENCE ) [EOL] if hasattr ( ssl , [string] ) : [EOL] context . options |= ssl . OP_NO_COMPRESSION [EOL] [EOL] context . set_ciphers ( [string] [string] [string] [string] [string] ) [EOL] [EOL] return context [EOL] [EOL] [EOL] def server_context_intermediate ( ) : [EOL] [docstring] [EOL] context = ssl . SSLContext ( ssl . PROTOCOL_TLS ) [comment] [EOL] [EOL] context . options |= ( ssl . OP_NO_SSLv2 | ssl . OP_NO_SSLv3 | ssl . OP_CIPHER_SERVER_PREFERENCE ) [EOL] if hasattr ( ssl , [string] ) : [EOL] context . options |= ssl . OP_NO_COMPRESSION [EOL] [EOL] context . set_ciphers ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] return context [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components import fan [EOL] from homeassistant . const import ATTR_ASSUMED_STATE , STATE_UNAVAILABLE [EOL] [EOL] from tests . common import ( mock_mqtt_component , fire_mqtt_message , get_test_home_assistant ) [EOL] [EOL] [EOL] class TestMqttFan ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . mock_publish = mock_mqtt_component ( self . hass ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_default_availability_payload ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , fan . DOMAIN , { fan . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] self . assertFalse ( state . attributes . get ( ATTR_ASSUMED_STATE ) ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] def test_custom_availability_payload ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , fan . DOMAIN , { fan . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] self . assertFalse ( state . attributes . get ( ATTR_ASSUMED_STATE ) ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from pyhap . accessory_driver import AccessoryDriver [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def hk_driver ( ) : [EOL] [docstring] [EOL] with patch ( [string] ) , patch ( [string] ) , patch ( [string] ) , patch ( [string] ) : [EOL] return AccessoryDriver ( pincode = [string] , address = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Union , Any , Dict [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import Mock , patch [EOL] [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_send [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components import deconz [EOL] [EOL] from tests . common import mock_coro [EOL] [EOL] CONFIG = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } [EOL] [EOL] [EOL] async def test_config_with_host_passed_to_config_entry ( hass ) : [EOL] [docstring] [EOL] with patch . object ( hass , [string] ) as mock_config_entries , patch . object ( deconz , [string] , return_value = [ ] ) , patch . object ( deconz , [string] , return_value = { } ) : [EOL] assert await async_setup_component ( hass , deconz . DOMAIN , { deconz . DOMAIN : { deconz . CONF_HOST : [string] , deconz . CONF_PORT : [number] } } ) is True [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] [EOL] [EOL] async def test_config_file_passed_to_config_entry ( hass ) : [EOL] [docstring] [EOL] with patch . object ( hass , [string] ) as mock_config_entries , patch . object ( deconz , [string] , return_value = [ ] ) , patch . object ( deconz , [string] , return_value = { [string] : [string] } ) : [EOL] assert await async_setup_component ( hass , deconz . DOMAIN , { deconz . DOMAIN : { } } ) is True [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] [EOL] [EOL] async def test_config_without_host_not_passed_to_config_entry ( hass ) : [EOL] [docstring] [EOL] with patch . object ( hass , [string] ) as mock_config_entries , patch . object ( deconz , [string] , return_value = [ ] ) , patch . object ( deconz , [string] , return_value = { } ) : [EOL] assert await async_setup_component ( hass , deconz . DOMAIN , { deconz . DOMAIN : { } } ) is True [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] [EOL] [EOL] async def test_config_already_registered_not_passed_to_config_entry ( hass ) : [EOL] [docstring] [EOL] with patch . object ( hass , [string] ) as mock_config_entries , patch . object ( deconz , [string] , return_value = [ [string] ] ) , patch . object ( deconz , [string] , return_value = { } ) : [EOL] assert await async_setup_component ( hass , deconz . DOMAIN , { deconz . DOMAIN : { deconz . CONF_HOST : [string] , deconz . CONF_PORT : [number] } } ) is True [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] [EOL] [EOL] async def test_config_discovery ( hass ) : [EOL] [docstring] [EOL] with patch . object ( hass , [string] ) as mock_config_entries : [EOL] assert await async_setup_component ( hass , deconz . DOMAIN , { } ) is True [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] [EOL] [EOL] async def test_setup_entry_already_registered_bridge ( hass ) : [EOL] [docstring] [EOL] hass . data [ deconz . DOMAIN ] = True [EOL] assert await deconz . async_setup_entry ( hass , { } ) is False [EOL] [EOL] [EOL] async def test_setup_entry_no_available_bridge ( hass ) : [EOL] [docstring] [EOL] entry = Mock ( ) [EOL] entry . data = { [string] : [string] , [string] : [number] , [string] : [string] } [EOL] with patch ( [string] , return_value = mock_coro ( False ) ) : [EOL] assert await deconz . async_setup_entry ( hass , entry ) is False [EOL] [EOL] [EOL] async def test_setup_entry_successful ( hass ) : [EOL] [docstring] [EOL] entry = Mock ( ) [EOL] entry . data = { [string] : [string] , [string] : [number] , [string] : [string] } [EOL] with patch . object ( hass , [string] ) as mock_add_job , patch . object ( hass , [string] ) as mock_config_entries , patch ( [string] , return_value = mock_coro ( CONFIG ) ) , patch ( [string] , return_value = True ) , patch ( [string] , return_value = mock_coro ( Mock ( ) ) ) : [EOL] assert await deconz . async_setup_entry ( hass , entry ) is True [EOL] assert hass . data [ deconz . DOMAIN ] [EOL] assert hass . data [ deconz . DATA_DECONZ_ID ] == { } [EOL] assert len ( hass . data [ deconz . DATA_DECONZ_UNSUB ] ) == [number] [EOL] assert len ( mock_add_job . mock_calls ) == [number] [EOL] assert len ( mock_config_entries . async_forward_entry_setup . mock_calls ) == [number] [EOL] assert mock_config_entries . async_forward_entry_setup . mock_calls [ [number] ] [ [number] ] == ( entry , [string] ) [EOL] assert mock_config_entries . async_forward_entry_setup . mock_calls [ [number] ] [ [number] ] == ( entry , [string] ) [EOL] assert mock_config_entries . async_forward_entry_setup . mock_calls [ [number] ] [ [number] ] == ( entry , [string] ) [EOL] assert mock_config_entries . async_forward_entry_setup . mock_calls [ [number] ] [ [number] ] == ( entry , [string] ) [EOL] assert mock_config_entries . async_forward_entry_setup . mock_calls [ [number] ] [ [number] ] == ( entry , [string] ) [EOL] [EOL] [EOL] async def test_unload_entry ( hass ) : [EOL] [docstring] [EOL] entry = Mock ( ) [EOL] entry . data = { [string] : [string] , [string] : [number] , [string] : [string] } [EOL] entry . async_unload . return_value = mock_coro ( True ) [EOL] deconzmock = Mock ( ) [EOL] deconzmock . async_load_parameters . return_value = mock_coro ( True ) [EOL] deconzmock . sensors = { } [EOL] with patch ( [string] , return_value = deconzmock ) : [EOL] assert await deconz . async_setup_entry ( hass , entry ) is True [EOL] [EOL] assert deconz . DATA_DECONZ_EVENT in hass . data [EOL] [EOL] hass . data [ deconz . DATA_DECONZ_EVENT ] . append ( Mock ( ) ) [EOL] hass . data [ deconz . DATA_DECONZ_ID ] = { [string] : [string] } [EOL] assert await deconz . async_unload_entry ( hass , entry ) [EOL] assert deconz . DOMAIN not in hass . data [EOL] assert len ( hass . data [ deconz . DATA_DECONZ_UNSUB ] ) == [number] [EOL] assert len ( hass . data [ deconz . DATA_DECONZ_EVENT ] ) == [number] [EOL] assert len ( hass . data [ deconz . DATA_DECONZ_ID ] ) == [number] [EOL] [EOL] [EOL] async def test_add_new_device ( hass ) : [EOL] [docstring] [EOL] entry = Mock ( ) [EOL] entry . data = { [string] : [string] , [string] : [number] , [string] : [string] , [string] : False } [EOL] new_event = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : [string] , [string] : { } , [string] : [string] } } [EOL] with patch . object ( deconz , [string] ) as mock_dispatch_send , patch ( [string] , return_value = mock_coro ( CONFIG ) ) , patch ( [string] , return_value = True ) : [EOL] assert await deconz . async_setup_entry ( hass , entry ) is True [EOL] hass . data [ deconz . DOMAIN ] . async_event_handler ( new_event ) [EOL] await hass . async_block_till_done ( ) [EOL] assert len ( mock_dispatch_send . mock_calls ) == [number] [EOL] assert len ( mock_dispatch_send . mock_calls [ [number] ] ) == [number] [EOL] [EOL] [EOL] async def test_add_new_remote ( hass ) : [EOL] [docstring] [EOL] entry = Mock ( ) [EOL] entry . data = { [string] : [string] , [string] : [number] , [string] : [string] , [string] : False } [EOL] remote = Mock ( ) [EOL] remote . name = [string] [EOL] remote . type = [string] [EOL] remote . register_async_callback = Mock ( ) [EOL] with patch ( [string] , return_value = mock_coro ( CONFIG ) ) , patch ( [string] , return_value = True ) : [EOL] assert await deconz . async_setup_entry ( hass , entry ) is True [EOL] async_dispatcher_send ( hass , [string] , [ remote ] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert len ( hass . data [ deconz . DATA_DECONZ_EVENT ] ) == [number] [EOL] [EOL] [EOL] async def test_do_not_allow_clip_sensor ( hass ) : [EOL] [docstring] [EOL] entry = Mock ( ) [EOL] entry . data = { [string] : [string] , [string] : [number] , [string] : [string] , [string] : False } [EOL] remote = Mock ( ) [EOL] remote . name = [string] [EOL] remote . type = [string] [EOL] remote . register_async_callback = Mock ( ) [EOL] with patch ( [string] , return_value = mock_coro ( CONFIG ) ) , patch ( [string] , return_value = True ) : [EOL] assert await deconz . async_setup_entry ( hass , entry ) is True [EOL] [EOL] async_dispatcher_send ( hass , [string] , [ remote ] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert len ( hass . data [ deconz . DATA_DECONZ_EVENT ] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Type , Dict [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import unittest [EOL] from unittest import mock [EOL] from libsoundtouch . device import SoundTouchDevice as STD , Status , Volume , Preset , Config [EOL] [EOL] from homeassistant . components . media_player import soundtouch [EOL] from homeassistant . const import ( STATE_OFF , STATE_PAUSED , STATE_PLAYING ) [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class MockService : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , master , slaves ) : [EOL] [docstring] [EOL] self . data = { [string] : master , [string] : slaves } [EOL] [EOL] [EOL] def _mock_soundtouch_device ( * args , ** kwargs ) : [EOL] return MockDevice ( ) [EOL] [EOL] [EOL] class MockDevice ( STD ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _config = MockConfig [EOL] [EOL] [EOL] class MockConfig ( Config ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _name = [string] [EOL] [EOL] [EOL] def _mocked_presets ( * args , ** kwargs ) : [EOL] [docstring] [EOL] return [ MockPreset ( [string] ) ] [EOL] [EOL] [EOL] class MockPreset ( Preset ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , id ) : [EOL] [docstring] [EOL] self . _id = id [EOL] self . _name = [string] [EOL] [EOL] [EOL] class MockVolume ( Volume ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _actual = [number] [EOL] [EOL] [EOL] class MockVolumeMuted ( Volume ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _actual = [number] [EOL] self . _muted = True [EOL] [EOL] [EOL] class MockStatusStandby ( Status ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _source = [string] [EOL] [EOL] [EOL] class MockStatusPlaying ( Status ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _source = [string] [EOL] self . _play_status = [string] [EOL] self . _image = [string] [EOL] self . _artist = [string] [EOL] self . _track = [string] [EOL] self . _album = [string] [EOL] self . _duration = [number] [EOL] self . _station_name = None [EOL] [EOL] [EOL] class MockStatusPlayingRadio ( Status ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _source = [string] [EOL] self . _play_status = [string] [EOL] self . _image = [string] [EOL] self . _artist = None [EOL] self . _track = None [EOL] self . _album = None [EOL] self . _duration = None [EOL] self . _station_name = [string] [EOL] [EOL] [EOL] class MockStatusUnknown ( Status ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _source = [string] [EOL] self . _play_status = [string] [EOL] self . _image = [string] [EOL] self . _artist = None [EOL] self . _track = None [EOL] self . _album = None [EOL] self . _duration = None [EOL] self . _station_name = None [EOL] [EOL] [EOL] class MockStatusPause ( Status ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _source = [string] [EOL] self . _play_status = [string] [EOL] [EOL] [EOL] def default_component ( ) : [EOL] [docstring] [EOL] return { [string] : [string] , [string] : [number] , [string] : [string] } [EOL] [EOL] [EOL] class TestSoundtouchMediaPlayer ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] logging . disable ( logging . CRITICAL ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] logging . disable ( logging . NOTSET ) [EOL] self . hass . stop ( ) [EOL] [EOL] @ mock . patch ( [string] , side_effect = None ) def test_ensure_setup_config ( self , mocked_soundtouch_device ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( len ( all_devices ) , [number] ) [EOL] self . assertEqual ( all_devices [ [number] ] . name , [string] ) [EOL] self . assertEqual ( all_devices [ [number] ] . config [ [string] ] , [number] ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] , side_effect = None ) def test_ensure_setup_discovery ( self , mocked_soundtouch_device ) : [EOL] [docstring] [EOL] new_device = { [string] : [string] , [string] : [string] , [string] : { } , [string] : [string] } [EOL] soundtouch . setup_platform ( self . hass , None , mock . MagicMock ( ) , new_device ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( len ( all_devices ) , [number] ) [EOL] self . assertEqual ( all_devices [ [number] ] . config [ [string] ] , [number] ) [EOL] self . assertEqual ( all_devices [ [number] ] . config [ [string] ] , [string] ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] , side_effect = None ) def test_ensure_setup_discovery_no_duplicate ( self , mocked_soundtouch_device ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( len ( self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] ) , [number] ) [EOL] new_device = { [string] : [string] , [string] : [string] , [string] : { } , [string] : [string] } [EOL] soundtouch . setup_platform ( self . hass , None , mock . MagicMock ( ) , new_device ) [EOL] self . assertEqual ( len ( self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] ) , [number] ) [EOL] existing_device = { [string] : [string] , [string] : [string] , [string] : { } , [string] : [string] } [EOL] soundtouch . setup_platform ( self . hass , None , mock . MagicMock ( ) , existing_device ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( len ( self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] ) , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_update ( self , mocked_soundtouch_device , mocked_status , mocked_volume ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [ [number] ] . update ( ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = MockStatusPlaying ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_playing_media ( self , mocked_soundtouch_device , mocked_status , mocked_volume ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( all_devices [ [number] ] . state , STATE_PLAYING ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_image_url , [string] ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_title , [string] ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_track , [string] ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_artist , [string] ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_album_name , [string] ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_duration , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = MockStatusUnknown ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_playing_unknown_media ( self , mocked_soundtouch_device , mocked_status , mocked_volume ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( all_devices [ [number] ] . media_title , None ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = MockStatusPlayingRadio ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_playing_radio ( self , mocked_soundtouch_device , mocked_status , mocked_volume ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( all_devices [ [number] ] . state , STATE_PLAYING ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_image_url , [string] ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_title , [string] ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_track , None ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_artist , None ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_album_name , None ) [EOL] self . assertEqual ( all_devices [ [number] ] . media_duration , None ) [EOL] [EOL] @ mock . patch ( [string] , side_effect = MockVolume ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_get_volume_level ( self , mocked_soundtouch_device , mocked_status , mocked_volume ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( all_devices [ [number] ] . volume_level , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = MockStatusStandby ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_get_state_off ( self , mocked_soundtouch_device , mocked_status , mocked_volume ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( all_devices [ [number] ] . state , STATE_OFF ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = MockStatusPause ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_get_state_pause ( self , mocked_soundtouch_device , mocked_status , mocked_volume ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( all_devices [ [number] ] . state , STATE_PAUSED ) [EOL] [EOL] @ mock . patch ( [string] , side_effect = MockVolumeMuted ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_is_muted ( self , mocked_soundtouch_device , mocked_status , mocked_volume ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( all_devices [ [number] ] . is_volume_muted , True ) [EOL] [EOL] @ mock . patch ( [string] ) def test_media_commands ( self , mocked_soundtouch_device ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( all_devices [ [number] ] . supported_features , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_should_turn_off ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_power_off ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . turn_off ( ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] self . assertEqual ( mocked_power_off . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_should_turn_on ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_power_on ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . turn_on ( ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] self . assertEqual ( mocked_power_on . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_volume_up ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_volume_up ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . volume_up ( ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume_up . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_volume_down ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_volume_down ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . volume_down ( ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume_down . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_set_volume_level ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_set_volume ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . set_volume_level ( [number] ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] mocked_set_volume . assert_called_with ( [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_mute ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_mute ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . mute_volume ( None ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] self . assertEqual ( mocked_mute . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_play ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_play ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . media_play ( ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] self . assertEqual ( mocked_play . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_pause ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_pause ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . media_pause ( ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] self . assertEqual ( mocked_pause . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_play_pause_play ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_play_pause ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . media_play_pause ( ) [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] self . assertEqual ( mocked_play_pause . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_next_previous_track ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_next_track , mocked_previous_track ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices [ [number] ] . media_next_track ( ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_next_track . call_count , [number] ) [EOL] all_devices [ [number] ] . media_previous_track ( ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_previous_track . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mocked_presets ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_play_media ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_presets , mocked_select_preset ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices [ [number] ] . play_media ( [string] , [number] ) [EOL] self . assertEqual ( mocked_presets . call_count , [number] ) [EOL] self . assertEqual ( mocked_select_preset . call_count , [number] ) [EOL] all_devices [ [number] ] . play_media ( [string] , [number] ) [EOL] self . assertEqual ( mocked_presets . call_count , [number] ) [EOL] self . assertEqual ( mocked_select_preset . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_play_media_url ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_play_url ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] all_devices [ [number] ] . play_media ( [string] , [string] ) [EOL] mocked_play_url . assert_called_with ( [string] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_play_everywhere ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_create_zone ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . entity_id = [string] [EOL] all_devices [ [number] ] . entity_id = [string] [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_PLAY_EVERYWHERE , { [string] : [string] } , True ) [EOL] self . assertEqual ( mocked_create_zone . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_PLAY_EVERYWHERE , { [string] : [string] } , True ) [EOL] self . assertEqual ( mocked_create_zone . call_count , [number] ) [EOL] [EOL] [comment] [EOL] all_devices . pop ( [number] ) [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_PLAY_EVERYWHERE , { [string] : [string] } , True ) [EOL] self . assertEqual ( mocked_create_zone . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_create_zone ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_create_zone ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . entity_id = [string] [EOL] all_devices [ [number] ] . entity_id = [string] [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_CREATE_ZONE , { [string] : [string] , [string] : [ [string] ] } , True ) [EOL] self . assertEqual ( mocked_create_zone . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_CREATE_ZONE , { [string] : [string] , [string] : [ [string] ] } , True ) [EOL] self . assertEqual ( mocked_create_zone . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_CREATE_ZONE , { [string] : [string] , [string] : [ ] } , True ) [EOL] self . assertEqual ( mocked_create_zone . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_remove_zone_slave ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_remove_zone_slave ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . entity_id = [string] [EOL] all_devices [ [number] ] . entity_id = [string] [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_REMOVE_ZONE_SLAVE , { [string] : [string] , [string] : [ [string] ] } , True ) [EOL] self . assertEqual ( mocked_remove_zone_slave . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_REMOVE_ZONE_SLAVE , { [string] : [string] , [string] : [ [string] ] } , True ) [EOL] self . assertEqual ( mocked_remove_zone_slave . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_REMOVE_ZONE_SLAVE , { [string] : [string] , [string] : [ ] } , True ) [EOL] self . assertEqual ( mocked_remove_zone_slave . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] , side_effect = _mock_soundtouch_device ) def test_add_zone_slave ( self , mocked_soundtouch_device , mocked_status , mocked_volume , mocked_add_zone_slave ) : [EOL] [docstring] [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] soundtouch . setup_platform ( self . hass , default_component ( ) , mock . MagicMock ( ) ) [EOL] all_devices = self . hass . data [ soundtouch . DATA_SOUNDTOUCH ] [EOL] all_devices [ [number] ] . entity_id = [string] [EOL] all_devices [ [number] ] . entity_id = [string] [EOL] self . assertEqual ( mocked_soundtouch_device . call_count , [number] ) [EOL] self . assertEqual ( mocked_status . call_count , [number] ) [EOL] self . assertEqual ( mocked_volume . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_ADD_ZONE_SLAVE , { [string] : [string] , [string] : [ [string] ] } , True ) [EOL] self . assertEqual ( mocked_add_zone_slave . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_ADD_ZONE_SLAVE , { [string] : [string] , [string] : [ [string] ] } , True ) [EOL] self . assertEqual ( mocked_add_zone_slave . call_count , [number] ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( soundtouch . DOMAIN , soundtouch . SERVICE_ADD_ZONE_SLAVE , { [string] : [string] , [string] : [ [string] ] } , True ) [EOL] self . assertEqual ( mocked_add_zone_slave . call_count , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.components.media_player.test_soundtouch.MockConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Union , Any , Tuple , Dict [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest import mock [EOL] import voluptuous as vol [EOL] [EOL] from collections import defaultdict [EOL] from homeassistant . components . media_player import ( DOMAIN , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_SELECT_SOURCE ) [EOL] from homeassistant . const import STATE_ON , STATE_OFF [EOL] [EOL] import tests . common [EOL] from homeassistant . components . media_player . blackbird import ( DATA_BLACKBIRD , PLATFORM_SCHEMA , SERVICE_SETALLZONES , setup_platform ) [EOL] [EOL] [EOL] class AttrDict ( dict ) : [EOL] [docstring] [EOL] [EOL] def __setattr__ ( self , name , value ) : [EOL] [docstring] [EOL] self [ name ] = value [EOL] [EOL] def __getattr__ ( self , item ) : [EOL] [docstring] [EOL] return self [ item ] [EOL] [EOL] [EOL] class MockBlackbird : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . zones = defaultdict ( lambda : AttrDict ( power = True , av = [number] ) ) [EOL] [EOL] def zone_status ( self , zone_id ) : [EOL] [docstring] [EOL] status = self . zones [ zone_id ] [EOL] status . zone = zone_id [EOL] return AttrDict ( status ) [EOL] [EOL] def set_zone_source ( self , zone_id , source_idx ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . av = source_idx [EOL] [EOL] def set_zone_power ( self , zone_id , power ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . power = power [EOL] [EOL] def set_all_zone_source ( self , source_idx ) : [EOL] [docstring] [EOL] self . zones [ [number] ] . av = source_idx [EOL] [EOL] [EOL] class TestBlackbirdSchema ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_valid_serial_schema ( self ) : [EOL] [docstring] [EOL] valid_schema = { [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , } , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , } } [EOL] PLATFORM_SCHEMA ( valid_schema ) [EOL] [EOL] def test_valid_socket_schema ( self ) : [EOL] [docstring] [EOL] valid_schema = { [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , } , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , } } [EOL] PLATFORM_SCHEMA ( valid_schema ) [EOL] [EOL] def test_invalid_schemas ( self ) : [EOL] [docstring] [EOL] schemas = ( { } , None , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { } } , } , ) [EOL] for value in schemas : [EOL] with self . assertRaises ( vol . MultipleInvalid ) : [EOL] PLATFORM_SCHEMA ( value ) [EOL] [EOL] [EOL] class TestBlackbirdMediaPlayer ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . blackbird = MockBlackbird ( ) [EOL] self . hass = tests . common . get_test_home_assistant ( ) [EOL] self . hass . start ( ) [EOL] [comment] [EOL] with mock . patch ( [string] , new = lambda * a : self . blackbird ) : [EOL] setup_platform ( self . hass , { [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } } , } , lambda * args , ** kwargs : None , { } ) [EOL] self . hass . block_till_done ( ) [EOL] self . media_player = self . hass . data [ DATA_BLACKBIRD ] [ [string] ] [EOL] self . media_player . hass = self . hass [EOL] self . media_player . entity_id = [string] [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_platform ( self , * args ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertTrue ( self . hass . services . has_service ( DOMAIN , SERVICE_SETALLZONES ) ) [EOL] self . assertEqual ( len ( self . hass . data [ DATA_BLACKBIRD ] ) , [number] ) [EOL] self . assertEqual ( self . hass . data [ DATA_BLACKBIRD ] [ [string] ] . name , [string] ) [EOL] [EOL] def test_setallzones_service_call_with_entity_id ( self ) : [EOL] [docstring] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_SETALLZONES , { [string] : [string] , [string] : [string] } , blocking = True ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( [number] , self . blackbird . zones [ [number] ] . av ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_setallzones_service_call_without_entity_id ( self ) : [EOL] [docstring] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_SETALLZONES , { [string] : [string] } , blocking = True ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( [number] , self . blackbird . zones [ [number] ] . av ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_update ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . state ) [EOL] self . assertIsNone ( self . media_player . source ) [EOL] [EOL] self . media_player . update ( ) [EOL] [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_name ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] [EOL] def test_state ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . state ) [EOL] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] [EOL] self . blackbird . zones [ [number] ] . power = False [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_OFF , self . media_player . state ) [EOL] [EOL] def test_supported_features ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE , self . media_player . supported_features ) [EOL] [EOL] def test_source ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . source ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_media_title ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . media_title ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . media_title ) [EOL] [EOL] def test_source_list ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertEqual ( [ [string] , [string] , [string] ] , self . media_player . source_list ) [EOL] [EOL] def test_select_source ( self ) : [EOL] [docstring] [EOL] self . media_player . update ( ) [EOL] [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] self . media_player . select_source ( [string] ) [EOL] self . assertEqual ( [number] , self . blackbird . zones [ [number] ] . av ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] self . media_player . select_source ( [string] ) [EOL] self . assertEqual ( [number] , self . blackbird . zones [ [number] ] . av ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_turn_on ( self ) : [EOL] [docstring] [EOL] self . blackbird . zones [ [number] ] . power = False [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_OFF , self . media_player . state ) [EOL] [EOL] self . media_player . turn_on ( ) [EOL] self . assertTrue ( self . blackbird . zones [ [number] ] . power ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] [EOL] def test_turn_off ( self ) : [EOL] [docstring] [EOL] self . blackbird . zones [ [number] ] . power = True [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] [EOL] self . media_player . turn_off ( ) [EOL] self . assertFalse ( self . blackbird . zones [ [number] ] . power ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_OFF , self . media_player . state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],None,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],None,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.media_player.test_blackbird.MockBlackbird$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.media_player.test_blackbird.MockBlackbird$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Tuple , Dict [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest import mock [EOL] import voluptuous as vol [EOL] [EOL] from collections import defaultdict [EOL] from homeassistant . components . media_player import ( DOMAIN , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_VOLUME_STEP , SUPPORT_SELECT_SOURCE ) [EOL] from homeassistant . const import STATE_ON , STATE_OFF [EOL] [EOL] import tests . common [EOL] from homeassistant . components . media_player . monoprice import ( DATA_MONOPRICE , PLATFORM_SCHEMA , SERVICE_SNAPSHOT , SERVICE_RESTORE , setup_platform ) [EOL] [EOL] [EOL] class AttrDict ( dict ) : [EOL] [docstring] [EOL] [EOL] def __setattr__ ( self , name , value ) : [EOL] [docstring] [EOL] self [ name ] = value [EOL] [EOL] def __getattr__ ( self , item ) : [EOL] [docstring] [EOL] return self [ item ] [EOL] [EOL] [EOL] class MockMonoprice : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . zones = defaultdict ( lambda : AttrDict ( power = True , volume = [number] , mute = True , source = [number] ) ) [EOL] [EOL] def zone_status ( self , zone_id ) : [EOL] [docstring] [EOL] status = self . zones [ zone_id ] [EOL] status . zone = zone_id [EOL] return AttrDict ( status ) [EOL] [EOL] def set_source ( self , zone_id , source_idx ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . source = source_idx [EOL] [EOL] def set_power ( self , zone_id , power ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . power = power [EOL] [EOL] def set_mute ( self , zone_id , mute ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . mute = mute [EOL] [EOL] def set_volume ( self , zone_id , volume ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . volume = volume [EOL] [EOL] def restore_zone ( self , zone ) : [EOL] [docstring] [EOL] self . zones [ zone . zone ] = AttrDict ( zone ) [EOL] [EOL] [EOL] class TestMonopriceSchema ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_valid_schema ( self ) : [EOL] [docstring] [EOL] valid_schema = { [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , } , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } } } [EOL] PLATFORM_SCHEMA ( valid_schema ) [EOL] [EOL] def test_invalid_schemas ( self ) : [EOL] [docstring] [EOL] schemas = ( { } , None , { [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { } } , } , ) [EOL] for value in schemas : [EOL] with self . assertRaises ( vol . MultipleInvalid ) : [EOL] PLATFORM_SCHEMA ( value ) [EOL] [EOL] [EOL] class TestMonopriceMediaPlayer ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . monoprice = MockMonoprice ( ) [EOL] self . hass = tests . common . get_test_home_assistant ( ) [EOL] self . hass . start ( ) [EOL] [comment] [EOL] with mock . patch ( [string] , new = lambda * a : self . monoprice ) : [EOL] setup_platform ( self . hass , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } } , } , lambda * args , ** kwargs : None , { } ) [EOL] self . hass . block_till_done ( ) [EOL] self . media_player = self . hass . data [ DATA_MONOPRICE ] [ [number] ] [EOL] self . media_player . hass = self . hass [EOL] self . media_player . entity_id = [string] [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_platform ( self , * args ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertTrue ( self . hass . services . has_service ( DOMAIN , SERVICE_RESTORE ) ) [EOL] self . assertTrue ( self . hass . services . has_service ( DOMAIN , SERVICE_SNAPSHOT ) ) [EOL] self . assertEqual ( len ( self . hass . data [ DATA_MONOPRICE ] ) , [number] ) [EOL] self . assertEqual ( self . hass . data [ DATA_MONOPRICE ] [ [number] ] . name , [string] ) [EOL] [EOL] def test_service_calls_with_entity_id ( self ) : [EOL] [docstring] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] self . assertTrue ( self . media_player . is_volume_muted ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_SNAPSHOT , { [string] : [string] } , blocking = True ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] self . media_player . select_source ( [string] ) [EOL] self . media_player . mute_volume ( False ) [EOL] self . media_player . turn_off ( ) [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_OFF , self . media_player . state ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] self . assertFalse ( self . media_player . is_volume_muted ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_RESTORE , { [string] : [string] } , blocking = True ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_OFF , self . media_player . state ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] self . assertFalse ( self . media_player . is_volume_muted ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_RESTORE , { [string] : [string] } , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] self . assertTrue ( self . media_player . is_volume_muted ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_service_calls_without_entity_id ( self ) : [EOL] [docstring] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] self . assertTrue ( self . media_player . is_volume_muted ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_RESTORE , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] self . assertTrue ( self . media_player . is_volume_muted ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_SNAPSHOT , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] self . media_player . select_source ( [string] ) [EOL] self . media_player . mute_volume ( False ) [EOL] self . media_player . turn_off ( ) [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_OFF , self . media_player . state ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] self . assertFalse ( self . media_player . is_volume_muted ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_RESTORE , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] self . assertTrue ( self . media_player . is_volume_muted ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_update ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . state ) [EOL] self . assertIsNone ( self . media_player . volume_level ) [EOL] self . assertIsNone ( self . media_player . is_volume_muted ) [EOL] self . assertIsNone ( self . media_player . source ) [EOL] [EOL] self . media_player . update ( ) [EOL] [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] self . assertTrue ( self . media_player . is_volume_muted ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_name ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [string] , self . media_player . name ) [EOL] [EOL] def test_state ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . state ) [EOL] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] [EOL] self . monoprice . zones [ [number] ] . power = False [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_OFF , self . media_player . state ) [EOL] [EOL] def test_volume_level ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . volume_level ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] [EOL] self . monoprice . zones [ [number] ] . volume = [number] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] [EOL] self . monoprice . zones [ [number] ] . volume = [number] [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [number] , self . media_player . volume_level , [number] ) [EOL] [EOL] def test_is_volume_muted ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . is_volume_muted ) [EOL] [EOL] self . media_player . update ( ) [EOL] self . assertTrue ( self . media_player . is_volume_muted ) [EOL] [EOL] self . monoprice . zones [ [number] ] . mute = False [EOL] self . media_player . update ( ) [EOL] self . assertFalse ( self . media_player . is_volume_muted ) [EOL] [EOL] def test_supported_features ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_STEP | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE , self . media_player . supported_features ) [EOL] [EOL] def test_source ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . source ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_media_title ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( self . media_player . media_title ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . media_title ) [EOL] [EOL] def test_source_list ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertEqual ( [ [string] , [string] , [string] ] , self . media_player . source_list ) [EOL] [EOL] def test_select_source ( self ) : [EOL] [docstring] [EOL] self . media_player . update ( ) [EOL] [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] self . media_player . select_source ( [string] ) [EOL] self . assertEqual ( [number] , self . monoprice . zones [ [number] ] . source ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] [comment] [EOL] self . media_player . select_source ( [string] ) [EOL] self . assertEqual ( [number] , self . monoprice . zones [ [number] ] . source ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( [string] , self . media_player . source ) [EOL] [EOL] def test_turn_on ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . power = False [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_OFF , self . media_player . state ) [EOL] [EOL] self . media_player . turn_on ( ) [EOL] self . assertTrue ( self . monoprice . zones [ [number] ] . power ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] [EOL] def test_turn_off ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . power = True [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_ON , self . media_player . state ) [EOL] [EOL] self . media_player . turn_off ( ) [EOL] self . assertFalse ( self . monoprice . zones [ [number] ] . power ) [EOL] self . media_player . update ( ) [EOL] self . assertEqual ( STATE_OFF , self . media_player . state ) [EOL] [EOL] def test_mute_volume ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . mute = True [EOL] self . media_player . update ( ) [EOL] self . assertTrue ( self . media_player . is_volume_muted ) [EOL] [EOL] self . media_player . mute_volume ( False ) [EOL] self . assertFalse ( self . monoprice . zones [ [number] ] . mute ) [EOL] self . media_player . update ( ) [EOL] self . assertFalse ( self . media_player . is_volume_muted ) [EOL] [EOL] self . media_player . mute_volume ( True ) [EOL] self . assertTrue ( self . monoprice . zones [ [number] ] . mute ) [EOL] self . media_player . update ( ) [EOL] self . assertTrue ( self . media_player . is_volume_muted ) [EOL] [EOL] def test_set_volume_level ( self ) : [EOL] [docstring] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] self . assertEqual ( [number] , self . monoprice . zones [ [number] ] . volume ) [EOL] self . assertTrue ( isinstance ( self . monoprice . zones [ [number] ] . volume , int ) ) [EOL] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] self . assertEqual ( [number] , self . monoprice . zones [ [number] ] . volume ) [EOL] self . assertTrue ( isinstance ( self . monoprice . zones [ [number] ] . volume , int ) ) [EOL] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] self . assertEqual ( [number] , self . monoprice . zones [ [number] ] . volume ) [EOL] self . assertTrue ( isinstance ( self . monoprice . zones [ [number] ] . volume , int ) ) [EOL] [EOL] def test_volume_up ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . volume = [number] [EOL] self . media_player . update ( ) [EOL] self . media_player . volume_up ( ) [EOL] self . assertEqual ( [number] , self . monoprice . zones [ [number] ] . volume ) [EOL] self . assertTrue ( isinstance ( self . monoprice . zones [ [number] ] . volume , int ) ) [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] self . media_player . volume_up ( ) [EOL] self . assertEqual ( [number] , self . monoprice . zones [ [number] ] . volume ) [EOL] self . assertTrue ( isinstance ( self . monoprice . zones [ [number] ] . volume , int ) ) [EOL] [EOL] def test_volume_down ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . volume = [number] [EOL] self . media_player . update ( ) [EOL] self . media_player . volume_down ( ) [EOL] self . assertEqual ( [number] , self . monoprice . zones [ [number] ] . volume ) [EOL] self . assertTrue ( isinstance ( self . monoprice . zones [ [number] ] . volume , int ) ) [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] self . media_player . volume_down ( ) [EOL] self . assertEqual ( [number] , self . monoprice . zones [ [number] ] . volume ) [EOL] self . assertTrue ( isinstance ( self . monoprice . zones [ [number] ] . volume , int ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],None,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],None,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.media_player.test_monoprice.MockMonoprice$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.media_player.test_monoprice.MockMonoprice$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import patch , Mock [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components import onboarding [EOL] [EOL] from tests . common import mock_coro , MockUser [EOL] [EOL] from . import mock_storage [EOL] [EOL] [comment] [EOL] [EOL] [EOL] async def test_not_setup_views_if_onboarded ( hass , hass_storage ) : [EOL] [docstring] [EOL] mock_storage ( hass_storage , { [string] : onboarding . STEPS } ) [EOL] [EOL] with patch ( [string] ) as mock_setup : [EOL] assert await async_setup_component ( hass , [string] , { } ) [EOL] [EOL] assert len ( mock_setup . mock_calls ) == [number] [EOL] assert onboarding . DOMAIN not in hass . data [EOL] assert onboarding . async_is_onboarded ( hass ) [EOL] [EOL] [EOL] async def test_setup_views_if_not_onboarded ( hass ) : [EOL] [docstring] [EOL] with patch ( [string] , return_value = mock_coro ( ) ) as mock_setup : [EOL] assert await async_setup_component ( hass , [string] , { } ) [EOL] [EOL] assert len ( mock_setup . mock_calls ) == [number] [EOL] assert onboarding . DOMAIN in hass . data [EOL] [EOL] with patch ( [string] , return_value = True ) : [EOL] assert not onboarding . async_is_onboarded ( hass ) [EOL] [EOL] [EOL] async def test_is_onboarded ( ) : [EOL] [docstring] [EOL] hass = Mock ( ) [EOL] hass . data = { } [EOL] [EOL] with patch ( [string] , return_value = False ) : [EOL] assert onboarding . async_is_onboarded ( hass ) [EOL] [EOL] with patch ( [string] , return_value = True ) : [EOL] assert onboarding . async_is_onboarded ( hass ) [EOL] [EOL] hass . data [ onboarding . DOMAIN ] = True [EOL] assert onboarding . async_is_onboarded ( hass ) [EOL] [EOL] hass . data [ onboarding . DOMAIN ] = False [EOL] assert not onboarding . async_is_onboarded ( hass ) [EOL] [EOL] [EOL] async def test_having_owner_finishes_user_step ( hass , hass_storage ) : [EOL] [docstring] [EOL] MockUser ( is_owner = True ) . add_to_hass ( hass ) [EOL] [EOL] with patch ( [string] ) as mock_setup , patch . object ( onboarding , [string] , [ onboarding . STEP_USER ] ) : [EOL] assert await async_setup_component ( hass , [string] , { } ) [EOL] [EOL] assert len ( mock_setup . mock_calls ) == [number] [EOL] assert onboarding . DOMAIN not in hass . data [EOL] assert onboarding . async_is_onboarded ( hass ) [EOL] [EOL] done = hass_storage [ onboarding . STORAGE_KEY ] [ [string] ] [ [string] ] [EOL] assert onboarding . STEP_USER in done [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Union , List , Dict , Any , Generator [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import json [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . components . device_tracker . meraki import ( CONF_VALIDATOR , CONF_SECRET ) [EOL] from homeassistant . setup import async_setup_component [EOL] import homeassistant . components . device_tracker as device_tracker [EOL] from homeassistant . const import CONF_PLATFORM [EOL] from homeassistant . components . device_tracker . meraki import URL [EOL] [EOL] [EOL] @ pytest . fixture def meraki_client ( loop , hass , aiohttp_client ) : [EOL] [docstring] [EOL] assert loop . run_until_complete ( async_setup_component ( hass , device_tracker . DOMAIN , { device_tracker . DOMAIN : { CONF_PLATFORM : [string] , CONF_VALIDATOR : [string] , CONF_SECRET : [string] } } ) ) [EOL] [EOL] yield loop . run_until_complete ( aiohttp_client ( hass . http . app ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_invalid_or_missing_data ( mock_device_tracker_conf , meraki_client ) : [EOL] [docstring] [EOL] req = yield from meraki_client . get ( URL ) [EOL] text = yield from req . text ( ) [EOL] assert req . status == [number] [EOL] assert text == [string] [EOL] [EOL] req = yield from meraki_client . post ( URL , data = [string] ) [EOL] text = yield from req . json ( ) [EOL] assert req . status == [number] [EOL] assert text [ [string] ] == [string] [EOL] [EOL] req = yield from meraki_client . post ( URL , data = [string] ) [EOL] text = yield from req . json ( ) [EOL] assert req . status == [number] [EOL] assert text [ [string] ] == [string] [EOL] [EOL] data = { [string] : [string] , [string] : [string] } [EOL] req = yield from meraki_client . post ( URL , data = json . dumps ( data ) ) [EOL] text = yield from req . json ( ) [EOL] assert req . status == [number] [EOL] assert text [ [string] ] == [string] [EOL] [EOL] data = { [string] : [string] , [string] : [string] } [EOL] req = yield from meraki_client . post ( URL , data = json . dumps ( data ) ) [EOL] text = yield from req . json ( ) [EOL] assert req . status == [number] [EOL] assert text [ [string] ] == [string] [EOL] [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] req = yield from meraki_client . post ( URL , data = json . dumps ( data ) ) [EOL] text = yield from req . json ( ) [EOL] assert req . status == [number] [EOL] assert text [ [string] ] == [string] [EOL] [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [ ] } } [EOL] req = yield from meraki_client . post ( URL , data = json . dumps ( data ) ) [EOL] assert req . status == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_data_will_be_saved ( mock_device_tracker_conf , hass , meraki_client ) : [EOL] [docstring] [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [ { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } } [EOL] req = yield from meraki_client . post ( URL , data = json . dumps ( data ) ) [EOL] assert req . status == [number] [EOL] yield from hass . async_block_till_done ( ) [EOL] state_name = hass . states . get ( [string] . format ( [string] , [string] ) ) . state [EOL] assert [string] == state_name [EOL] [EOL] state_name = hass . states . get ( [string] . format ( [string] , [string] ) ) . state [EOL] assert [string] == state_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import Mock , patch [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components import hue [EOL] [EOL] from tests . common import mock_coro , MockConfigEntry [EOL] [EOL] [EOL] async def test_setup_with_no_config ( hass ) : [EOL] [docstring] [EOL] with patch . object ( hass , [string] ) as mock_config_entries , patch . object ( hue , [string] , return_value = [ ] ) : [EOL] assert await async_setup_component ( hass , hue . DOMAIN , { } ) is True [EOL] [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] [EOL] [comment] [EOL] assert hass . data [ hue . DOMAIN ] == { } [EOL] [EOL] [EOL] async def test_setup_with_discovery_no_known_auth ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( hue . API_NUPNP , json = [ { [string] : [string] , [string] : [string] } ] ) [EOL] [EOL] with patch . object ( hass , [string] ) as mock_config_entries , patch . object ( hue , [string] , return_value = [ ] ) : [EOL] mock_config_entries . flow . async_init . return_value = mock_coro ( ) [EOL] assert await async_setup_component ( hass , hue . DOMAIN , { hue . DOMAIN : { } } ) is True [EOL] [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] assert mock_config_entries . flow . mock_calls [ [number] ] [ [number] ] [ [string] ] == { [string] : [string] , [string] : [string] , } [EOL] [EOL] [comment] [EOL] assert hass . data [ hue . DOMAIN ] == { [string] : { hue . CONF_HOST : [string] , hue . CONF_FILENAME : [string] , hue . CONF_ALLOW_HUE_GROUPS : hue . DEFAULT_ALLOW_HUE_GROUPS , hue . CONF_ALLOW_UNREACHABLE : hue . DEFAULT_ALLOW_UNREACHABLE , } } [EOL] [EOL] [EOL] async def test_setup_with_discovery_known_auth ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( hue . API_NUPNP , json = [ { [string] : [string] , [string] : [string] } ] ) [EOL] [EOL] with patch . object ( hass , [string] ) as mock_config_entries , patch . object ( hue , [string] , return_value = [ [string] ] ) : [EOL] assert await async_setup_component ( hass , hue . DOMAIN , { hue . DOMAIN : { } } ) is True [EOL] [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] [EOL] [comment] [EOL] assert hass . data [ hue . DOMAIN ] == { } [EOL] [EOL] [EOL] async def test_setup_defined_hosts_known_auth ( hass ) : [EOL] [docstring] [EOL] with patch . object ( hass , [string] ) as mock_config_entries , patch . object ( hue , [string] , return_value = [ [string] ] ) : [EOL] assert await async_setup_component ( hass , hue . DOMAIN , { hue . DOMAIN : { hue . CONF_BRIDGES : { hue . CONF_HOST : [string] , hue . CONF_FILENAME : [string] , hue . CONF_ALLOW_HUE_GROUPS : False , hue . CONF_ALLOW_UNREACHABLE : True } } } ) is True [EOL] [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] [EOL] [comment] [EOL] assert hass . data [ hue . DOMAIN ] == { [string] : { hue . CONF_HOST : [string] , hue . CONF_FILENAME : [string] , hue . CONF_ALLOW_HUE_GROUPS : False , hue . CONF_ALLOW_UNREACHABLE : True } } [EOL] [EOL] [EOL] async def test_setup_defined_hosts_no_known_auth ( hass ) : [EOL] [docstring] [EOL] with patch . object ( hass , [string] ) as mock_config_entries , patch . object ( hue , [string] , return_value = [ ] ) : [EOL] mock_config_entries . flow . async_init . return_value = mock_coro ( ) [EOL] assert await async_setup_component ( hass , hue . DOMAIN , { hue . DOMAIN : { hue . CONF_BRIDGES : { hue . CONF_HOST : [string] , hue . CONF_FILENAME : [string] , hue . CONF_ALLOW_HUE_GROUPS : False , hue . CONF_ALLOW_UNREACHABLE : True } } } ) is True [EOL] [EOL] [comment] [EOL] assert len ( mock_config_entries . flow . mock_calls ) == [number] [EOL] assert mock_config_entries . flow . mock_calls [ [number] ] [ [number] ] [ [string] ] == { [string] : [string] , [string] : [string] , } [EOL] [EOL] [comment] [EOL] assert hass . data [ hue . DOMAIN ] == { [string] : { hue . CONF_HOST : [string] , hue . CONF_FILENAME : [string] , hue . CONF_ALLOW_HUE_GROUPS : False , hue . CONF_ALLOW_UNREACHABLE : True } } [EOL] [EOL] [EOL] async def test_config_passed_to_config_entry ( hass ) : [EOL] [docstring] [EOL] entry = MockConfigEntry ( domain = hue . DOMAIN , data = { [string] : [string] , } ) [EOL] entry . add_to_hass ( hass ) [EOL] mock_registry = Mock ( ) [EOL] with patch . object ( hue , [string] ) as mock_bridge , patch ( [string] , return_value = mock_coro ( mock_registry ) ) : [EOL] mock_bridge . return_value . async_setup . return_value = mock_coro ( True ) [EOL] mock_bridge . return_value . api . config = Mock ( mac = [string] , bridgeid = [string] , raw = { [string] : [string] , [string] : [string] , } ) [EOL] [comment] [EOL] mock_bridge . return_value . api . config . name = [string] [EOL] assert await async_setup_component ( hass , hue . DOMAIN , { hue . DOMAIN : { hue . CONF_BRIDGES : { hue . CONF_HOST : [string] , hue . CONF_FILENAME : [string] , hue . CONF_ALLOW_HUE_GROUPS : False , hue . CONF_ALLOW_UNREACHABLE : True } } } ) is True [EOL] [EOL] assert len ( mock_bridge . mock_calls ) == [number] [EOL] p_hass , p_entry , p_allow_unreachable , p_allow_groups = mock_bridge . mock_calls [ [number] ] [ [number] ] [EOL] [EOL] assert p_hass is hass [EOL] assert p_entry is entry [EOL] assert p_allow_unreachable is True [EOL] assert p_allow_groups is False [EOL] [EOL] assert len ( mock_registry . mock_calls ) == [number] [EOL] assert mock_registry . mock_calls [ [number] ] [ [number] ] == { [string] : entry . entry_id , [string] : { ( [string] , [string] ) } , [string] : { ( [string] , [string] ) } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] async def test_unload_entry ( hass ) : [EOL] [docstring] [EOL] entry = MockConfigEntry ( domain = hue . DOMAIN , data = { [string] : [string] , } ) [EOL] entry . add_to_hass ( hass ) [EOL] [EOL] with patch . object ( hue , [string] ) as mock_bridge , patch ( [string] , return_value = mock_coro ( Mock ( ) ) ) : [EOL] mock_bridge . return_value . async_setup . return_value = mock_coro ( True ) [EOL] mock_bridge . return_value . api . config = Mock ( ) [EOL] assert await async_setup_component ( hass , hue . DOMAIN , { } ) is True [EOL] [EOL] assert len ( mock_bridge . return_value . mock_calls ) == [number] [EOL] [EOL] mock_bridge . return_value . async_reset . return_value = mock_coro ( True ) [EOL] assert await hue . async_unload_entry ( hass , entry ) [EOL] assert len ( mock_bridge . return_value . async_reset . mock_calls ) == [number] [EOL] assert hass . data [ hue . DOMAIN ] == { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Union , List , Pattern , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] [EOL] import requests_mock [EOL] import unittest [EOL] [EOL] from homeassistant . components . sensor . uk_transport import ( UkTransportSensor , ATTR_ATCOCODE , ATTR_LOCALITY , ATTR_STOP_NAME , ATTR_NEXT_BUSES , ATTR_STATION_CODE , ATTR_CALLING_AT , ATTR_NEXT_TRAINS , CONF_API_APP_KEY , CONF_API_APP_ID ) [EOL] from homeassistant . setup import setup_component [EOL] from tests . common import load_fixture , get_test_home_assistant [EOL] [EOL] BUS_ATCOCODE = [string] [EOL] BUS_DIRECTION = [string] [EOL] TRAIN_STATION_CODE = [string] [EOL] TRAIN_DESTINATION_NAME = [string] [EOL] [EOL] VALID_CONFIG = { [string] : [string] , CONF_API_APP_ID : [string] , CONF_API_APP_KEY : [string] , [string] : [ { [string] : [string] , [string] : BUS_ATCOCODE , [string] : BUS_DIRECTION } , { [string] : [string] , [string] : TRAIN_STATION_CODE , [string] : TRAIN_DESTINATION_NAME } ] } [EOL] [EOL] [EOL] class TestUkTransportSensor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . config = VALID_CONFIG [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ requests_mock . Mocker ( ) def test_bus ( self , mock_req ) : [EOL] [docstring] [EOL] with requests_mock . Mocker ( ) as mock_req : [EOL] uri = re . compile ( UkTransportSensor . TRANSPORT_API_URL_BASE + [string] ) [EOL] mock_req . get ( uri , text = load_fixture ( [string] ) ) [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : self . config } ) ) [EOL] [EOL] bus_state = self . hass . states . get ( [string] ) [EOL] [EOL] assert type ( bus_state . state ) == str [EOL] assert bus_state . name == [string] . format ( BUS_DIRECTION ) [EOL] assert bus_state . attributes . get ( ATTR_ATCOCODE ) == BUS_ATCOCODE [EOL] assert bus_state . attributes . get ( ATTR_LOCALITY ) == [string] [EOL] assert bus_state . attributes . get ( ATTR_STOP_NAME ) == [string] [EOL] assert len ( bus_state . attributes . get ( ATTR_NEXT_BUSES ) ) == [number] [EOL] [EOL] direction_re = re . compile ( BUS_DIRECTION ) [EOL] for bus in bus_state . attributes . get ( ATTR_NEXT_BUSES ) : [EOL] print ( bus [ [string] ] , direction_re . match ( bus [ [string] ] ) ) [EOL] assert direction_re . search ( bus [ [string] ] ) is not None [EOL] [EOL] @ requests_mock . Mocker ( ) def test_train ( self , mock_req ) : [EOL] [docstring] [EOL] with requests_mock . Mocker ( ) as mock_req : [EOL] uri = re . compile ( UkTransportSensor . TRANSPORT_API_URL_BASE + [string] ) [EOL] mock_req . get ( uri , text = load_fixture ( [string] ) ) [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : self . config } ) ) [EOL] [EOL] train_state = self . hass . states . get ( [string] ) [EOL] [EOL] assert type ( train_state . state ) == str [EOL] assert train_state . name == [string] . format ( TRAIN_DESTINATION_NAME ) [EOL] assert train_state . attributes . get ( ATTR_STATION_CODE ) == TRAIN_STATION_CODE [EOL] assert train_state . attributes . get ( ATTR_CALLING_AT ) == TRAIN_DESTINATION_NAME [EOL] assert len ( train_state . attributes . get ( ATTR_NEXT_TRAINS ) ) == [number] [EOL] [EOL] assert train_state . attributes . get ( ATTR_NEXT_TRAINS ) [ [number] ] [ [string] ] == [string] [EOL] assert train_state . attributes . get ( ATTR_NEXT_TRAINS ) [ [number] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Union , Any , Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] [EOL] from homeassistant . components . light import ATTR_BRIGHTNESS [EOL] from homeassistant . components . rflink import EVENT_BUTTON_PRESSED [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , SERVICE_TURN_OFF , SERVICE_TURN_ON ) [EOL] from homeassistant . core import callback [EOL] [EOL] from . . test_rflink import mock_rflink [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] CONFIG = { [string] : { [string] : [string] , [string] : [ [string] , [string] ] , } , DOMAIN : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [ [string] ] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } } , } , } [EOL] [EOL] [EOL] @ asyncio . coroutine def test_default_setup ( hass , monkeypatch ) : [EOL] [docstring] [EOL] [comment] [EOL] event_callback , create , protocol , _ = yield from mock_rflink ( hass , CONFIG , DOMAIN , monkeypatch ) [EOL] [EOL] [comment] [EOL] assert create . call_args_list [ [number] ] [ [number] ] [ [string] ] [EOL] [EOL] [comment] [EOL] light_initial = hass . states . get ( DOMAIN + [string] ) [EOL] assert light_initial . state == [string] [EOL] assert light_initial . attributes [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] light_after_first_command = hass . states . get ( DOMAIN + [string] ) [EOL] assert light_after_first_command . state == [string] [EOL] [comment] [EOL] assert not light_after_first_command . attributes . get ( [string] ) [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] light_after_first_command = hass . states . get ( DOMAIN + [string] ) [EOL] assert light_after_first_command . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_ON , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_ON , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] [EOL] [comment] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_ON , { ATTR_ENTITY_ID : DOMAIN + [string] , ATTR_BRIGHTNESS : [number] , } ) ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_ON , { ATTR_ENTITY_ID : DOMAIN + [string] , ATTR_BRIGHTNESS : [number] , } ) ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_firing_bus_event ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [ [string] ] , [string] : True , } , } , } , } [EOL] [EOL] [comment] [EOL] event_callback , _ , _ , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] calls = [ ] [EOL] [EOL] @ callback def listener ( event ) : [EOL] calls . append ( event ) [EOL] hass . bus . async_listen_once ( EVENT_BUTTON_PRESSED , listener ) [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert calls [ [number] ] . data == { [string] : [string] , [string] : DOMAIN + [string] } [EOL] [EOL] [EOL] @ asyncio . coroutine def test_signal_repetitions ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : { [string] : [number] , } , [string] : { [string] : { [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] , } , [string] : { [string] : [string] , } } , } , } [EOL] [EOL] [comment] [EOL] event_callback , _ , protocol , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] [comment] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] [EOL] [comment] [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert protocol . send_command_ack . call_count == [number] [EOL] [EOL] [comment] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] [EOL] [comment] [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert protocol . send_command_ack . call_count == [number] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] [EOL] [comment] [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] [EOL] [comment] [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert protocol . send_command_ack . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_signal_repetitions_alternation ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] , [string] : [number] , } , } , } , } [EOL] [EOL] [comment] [EOL] _ , _ , protocol , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_signal_repetitions_cancelling ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [number] , } , } , } , } [EOL] [EOL] [comment] [EOL] _ , _ , protocol , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] [EOL] hass . async_add_job ( hass . services . async_call ( DOMAIN , SERVICE_TURN_ON , { ATTR_ENTITY_ID : DOMAIN + [string] } ) ) [EOL] [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert protocol . send_command_ack . call_args_list [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_type_toggle ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , } , } , } , } [EOL] [EOL] [comment] [EOL] event_callback , _ , _ , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_group_alias ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [ [string] ] , } , } , } , } [EOL] [EOL] [comment] [EOL] event_callback , _ , _ , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_nogroup_alias ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [ [string] ] , } , } , } , } [EOL] [EOL] [comment] [EOL] event_callback , _ , _ , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [comment] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [comment] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_nogroup_device_id ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : False , } , } , } , } [EOL] [EOL] [comment] [EOL] event_callback , _ , _ , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [comment] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [comment] [EOL] assert hass . states . get ( DOMAIN + [string] ) . state == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_disable_automatic_add ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : False , } , } [EOL] [EOL] [comment] [EOL] event_callback , _ , _ , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert not hass . states . get ( DOMAIN + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] import unittest [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] from homeassistant . const import ( TEMP_CELSIUS , PRECISION_WHOLE , TEMP_FAHRENHEIT , PRECISION_HALVES , PRECISION_TENTHS ) [EOL] from homeassistant . helpers . temperature import display_temp [EOL] from homeassistant . util . unit_system import METRIC_SYSTEM [EOL] [EOL] TEMP = [number] [EOL] [EOL] [EOL] class TestHelpersTemperature ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . hass . config . unit_system = METRIC_SYSTEM [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_temperature_not_a_number ( self ) : [EOL] [docstring] [EOL] temp = [string] [EOL] with self . assertRaises ( Exception ) as context : [EOL] display_temp ( self . hass , temp , TEMP_CELSIUS , PRECISION_HALVES ) [EOL] [EOL] self . assertTrue ( [string] . format ( temp ) in str ( context . exception ) ) [EOL] [EOL] def test_celsius_halves ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , display_temp ( self . hass , TEMP , TEMP_CELSIUS , PRECISION_HALVES ) ) [EOL] [EOL] def test_celsius_tenths ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , display_temp ( self . hass , TEMP , TEMP_CELSIUS , PRECISION_TENTHS ) ) [EOL] [EOL] def test_fahrenheit_wholes ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( - [number] , display_temp ( self . hass , TEMP , TEMP_FAHRENHEIT , PRECISION_WHOLE ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0