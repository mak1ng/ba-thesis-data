from typing import Optional , Any [EOL] import typing [EOL] import logging [EOL] import tornado [EOL] import logging [EOL] from os import environ [EOL] [EOL] import tornado . ioloop [EOL] from tornado . options import options , parse_command_line [EOL] [EOL] from . app import make_app [EOL] [EOL] [EOL] def parse_environment_variables ( ) : [EOL] for option_name in options . _options : [EOL] env_name = option_name . upper ( ) . replace ( [string] , [string] ) [EOL] env_value = environ . get ( env_name ) [EOL] if env_value is None : [EOL] continue [EOL] option = options . _options [ option_name ] [EOL] option . parse ( env_value ) [EOL] [EOL] [EOL] def load_config ( ) : [EOL] parse_command_line ( ) [EOL] parse_environment_variables ( ) [EOL] [EOL] [EOL] load_config ( ) [EOL] logger = logging . getLogger ( __name__ ) [EOL] app = make_app ( ) [EOL] logger . info ( [string] ) [EOL] app . listen ( options . port ) [EOL] tornado . ioloop . IOLoop . current ( ) . start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import pathlib [EOL] import logging [EOL] import typing [EOL] import tornado [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Any , List [EOL] [EOL] import tornado . ioloop [EOL] from tornado . options import define , options [EOL] import tornado . web [EOL] [EOL] from . import handlers [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] root_dir = Path ( __file__ ) . parents [ [number] ] [EOL] static_dir = root_dir / [string] [EOL] templates_dir = root_dir / [string] [EOL] [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] define ( [string] , default = [number] , help = [string] ) [EOL] define ( [string] , default = None , help = [string] ) [EOL] define ( [string] , default = None , help = [string] ) [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] define ( [string] , default = [number] , help = [string] ) [EOL] define ( [string] , default = False , help = [string] ) [EOL] [EOL] [EOL] def make_app ( ** kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] routes = [ ( [string] , handlers . TypecheckHandler ) , ( [string] , handlers . GistHandler ) , ( [string] , handlers . IndexHandler ) , ] [EOL] return tornado . web . Application ( routes , static_path = static_dir , template_path = templates_dir , debug = options . debug , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Union , Any [EOL] import typing [EOL] import builtins [EOL] import tornado [EOL] import json [EOL] from typing import Dict , Optional [EOL] [EOL] from tornado . httpclient import AsyncHTTPClient [EOL] from tornado . options import options [EOL] [EOL] [EOL] API_ENDPOINT = [string] [EOL] [EOL] [EOL] async def create_gist ( source ) : [EOL] data = { [string] : [string] , [string] : True , [string] : { [string] : { [string] : source } } } [EOL] headers = { [string] : f" [string] { options . github_token }" , [string] : [string] , [string] : [string] } [EOL] [EOL] client = AsyncHTTPClient ( ) [EOL] res = await client . fetch ( API_ENDPOINT , method = [string] , headers = headers , body = json . dumps ( data ) , raise_error = False ) [EOL] [EOL] if res . code != [number] : [EOL] [comment] [EOL] return None [EOL] [EOL] res_data = json . loads ( res . body ) [EOL] result = { [string] : res_data [ [string] ] , [string] : res_data [ [string] ] , [string] : source } [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Tuple , Union , Any , List , Optional [EOL] import typing [EOL] import app [EOL] import builtins [EOL] import logging [EOL] from http import HTTPStatus [EOL] import json [EOL] import logging [EOL] import traceback [EOL] from typing import Any , Dict , Union [EOL] [EOL] import tornado . escape [EOL] from tornado . options import options [EOL] import tornado . web [EOL] [EOL] from . import gist , sandbox [EOL] from . utils import get_mypy_versions [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] initial_code = [string] [EOL] [EOL] [EOL] class IndexHandler ( tornado . web . RequestHandler ) : [EOL] async def get ( self ) : [EOL] mypy_versions = get_mypy_versions ( ) [EOL] default = { flag : False for flag in sandbox . ARGUMENT_FLAGS } [EOL] default [ [string] ] = mypy_versions [ [number] ] [ [number] ] [EOL] default [ [string] ] = sandbox . PYTHON_VERSIONS [ [number] ] [EOL] context = { [string] : default , [string] : initial_code , [string] : sandbox . PYTHON_VERSIONS , [string] : mypy_versions , [string] : sandbox . ARGUMENT_FLAGS , [string] : options . ga_tracking_id , } [EOL] self . render ( [string] , context = json . dumps ( context ) ) [EOL] [EOL] [EOL] class JsonRequestHandler ( tornado . web . RequestHandler ) : [EOL] def prepare ( self ) : [EOL] content_type = self . request . headers . get ( [string] , [string] ) [EOL] if not content_type . startswith ( [string] ) : [EOL] raise tornado . web . HTTPError ( HTTPStatus . UNSUPPORTED_MEDIA_TYPE , log_message = [string] ) [EOL] [EOL] def write_error ( self , status_code , ** kwargs ) : [EOL] error = { } [EOL] [EOL] if [string] in kwargs : [EOL] exc_info = kwargs [ [string] ] [EOL] if self . settings . get ( [string] ) : [EOL] [comment] [EOL] lines = traceback . format_exception ( * exc_info ) [EOL] error [ [string] ] = [string] . join ( lines ) [EOL] [EOL] exc = exc_info [ [number] ] [EOL] if isinstance ( exc , tornado . web . HTTPError ) and exc . log_message : [EOL] error [ [string] ] = exc . log_message [EOL] [EOL] self . finish ( error ) [EOL] [EOL] def parse_json_request_body ( self ) : [EOL] try : [EOL] return tornado . escape . json_decode ( self . request . body ) [EOL] except json . JSONDecodeError : [EOL] raise tornado . web . HTTPError ( HTTPStatus . BAD_REQUEST , log_message = [string] ) [EOL] [EOL] [EOL] class TypecheckHandler ( JsonRequestHandler ) : [EOL] async def post ( self ) : [EOL] json = self . parse_json_request_body ( ) [EOL] [EOL] source = json . get ( [string] ) [EOL] if source is None or not isinstance ( source , str ) : [EOL] raise tornado . web . HTTPError ( HTTPStatus . BAD_REQUEST , log_message = [string] ) [EOL] [EOL] args = { } [EOL] python_version = json . get ( [string] ) [EOL] if ( python_version is not None [EOL] and python_version in sandbox . PYTHON_VERSIONS ) : [EOL] args [ [string] ] = python_version [EOL] for flag in sandbox . ARGUMENT_FLAGS : [EOL] flag_value = json . get ( flag ) [EOL] if flag_value is not None and flag_value is True : [EOL] args [ flag ] = flag_value [EOL] [EOL] mypy_version = json . get ( [string] ) [EOL] if mypy_version is None : [EOL] mypy_version = get_mypy_versions ( ) [ [number] ] [ [number] ] [EOL] args [ [string] ] = mypy_version [EOL] [EOL] result = await sandbox . run_typecheck_in_sandbox ( sandbox . DockerSandbox ( ) , source , ** args ) [EOL] if result is None : [EOL] logger . error ( [string] ) [EOL] raise tornado . web . HTTPError ( HTTPStatus . INTERNAL_SERVER_ERROR , log_message = [string] ) [EOL] [EOL] self . write ( result . to_dict ( ) ) [EOL] [EOL] [EOL] class GistHandler ( JsonRequestHandler ) : [EOL] async def post ( self ) : [EOL] json = self . parse_json_request_body ( ) [EOL] [EOL] source = json . get ( [string] ) [EOL] if source is None or not isinstance ( source , str ) : [EOL] raise tornado . web . HTTPError ( HTTPStatus . BAD_REQUEST , log_message = [string] ) [EOL] [EOL] result = await gist . create_gist ( source ) [EOL] [EOL] if result is None : [EOL] logger . error ( [string] ) [EOL] raise tornado . web . HTTPError ( HTTPStatus . INTERNAL_SERVER_ERROR , log_message = [string] ) [EOL] [EOL] self . set_status ( [number] ) [EOL] self . write ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[app.mypy_playground.sandbox.Result]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Optional[app.mypy_playground.sandbox.Result]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[app.mypy_playground.sandbox.Result]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0
from typing import Dict , Tuple , List [EOL] import typing [EOL] import builtins [EOL] from functools import lru_cache [EOL] from typing import Dict , List , Tuple , cast [EOL] [EOL] from tornado . options import options [EOL] [EOL] [EOL] @ lru_cache ( ) def parse_option_as_dict ( name ) : [EOL] [comment] [EOL] [comment] [EOL] return dict ( cast ( List [ Tuple [ str , str ] ] , [ tuple ( i . split ( [string] , [number] ) ) for i in options [ name ] . split ( [string] ) ] ) ) [EOL] [EOL] [EOL] @ lru_cache ( maxsize = [number] ) def get_mypy_versions ( ) : [EOL] return list ( parse_option_as_dict ( [string] ) . items ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , Union , Any , List , Optional [EOL] import logging [EOL] import pathlib [EOL] import io [EOL] import builtins [EOL] import tarfile [EOL] import typing [EOL] import asyncio [EOL] from abc import ABC , abstractmethod [EOL] import asyncio [EOL] from dataclasses import dataclass [EOL] from io import BytesIO [EOL] import logging [EOL] from pathlib import Path [EOL] import tarfile [EOL] import time [EOL] from typing import Any , Dict , Optional [EOL] [EOL] import aiodocker [EOL] from tornado . options import options [EOL] [EOL] from . utils import parse_option_as_dict [EOL] [EOL] [EOL] ARGUMENT_FLAGS_NORMAL = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] ARGUMENT_FLAGS_STRICT = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] ARGUMENT_FLAGS = ARGUMENT_FLAGS_NORMAL + ARGUMENT_FLAGS_STRICT [EOL] PYTHON_VERSIONS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ dataclass class Result : [EOL] exit_code = ... [EOL] stdout = ... [EOL] stderr = ... [EOL] duration = ... [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . exit_code , [string] : self . stdout , [string] : self . stderr , [string] : self . duration , } [EOL] [EOL] [EOL] class AbstractSandbox ( ABC ) : [EOL] @ abstractmethod def __init__ ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod async def run_typecheck ( self , source , * , mypy_version , python_version = None , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] class DockerSandbox ( AbstractSandbox ) : [EOL] client = ... [EOL] source_file_path = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . client = aiodocker . Docker ( ) [EOL] self . source_file_path = Path ( [string] ) [EOL] [EOL] def create_archive ( self , source ) : [EOL] stream = BytesIO ( ) [EOL] with tarfile . TarFile ( fileobj = stream , mode = [string] ) as tar : [EOL] data = source . encode ( [string] ) [EOL] tarinfo = tarfile . TarInfo ( name = self . source_file_path . name ) [EOL] tarinfo . size = len ( data ) [EOL] tarinfo . mtime = int ( time . time ( ) ) [EOL] tar . addfile ( tarinfo , BytesIO ( data ) ) [EOL] stream . seek ( [number] ) [EOL] return stream [EOL] [EOL] async def run_typecheck ( self , source , * , mypy_version , python_version = None , ** kwargs ) : [EOL] docker_image = self . get_docker_image ( mypy_version ) [EOL] if docker_image is None : [EOL] logger . error ( f" [string] { mypy_version }" ) [EOL] return None [EOL] [EOL] cmd = [ [string] , [string] , [string] , [string] ] [EOL] if python_version : [EOL] cmd += [ [string] , f"{ python_version }" ] [EOL] for key , value in kwargs . items ( ) : [EOL] if key in ARGUMENT_FLAGS : [EOL] cmd . append ( f" [string] { key }" ) [EOL] cmd . append ( self . source_file_path . name ) [EOL] try : [EOL] start_time = time . time ( ) [EOL] logger . info ( [string] ) [EOL] config = { [string] : docker_image , [string] : cmd , [string] : { [string] : [ [string] ] , [string] : [number] * [number] * [number] , [string] : [string] , [string] : [number] , [string] : [ [string] ] } } [EOL] c = await self . client . containers . create ( config = config ) [EOL] await c . put_archive ( str ( self . source_file_path . parent ) , self . create_archive ( source ) ) [EOL] await c . start ( ) [EOL] exit_code = ( await c . wait ( ) ) [ [string] ] [EOL] stdout = [string] . join ( await c . log ( stdout = True , stderr = False ) ) . strip ( ) [EOL] stderr = [string] . join ( await c . log ( stdout = False , stderr = True ) ) . strip ( ) [EOL] await c . delete ( ) [EOL] duration = int ( [number] * ( time . time ( ) - start_time ) ) [EOL] logger . info ( [string] , duration ) [EOL] return Result ( exit_code = exit_code , stdout = stdout , stderr = stderr , duration = duration ) [EOL] except aiodocker . exceptions . DockerError as e : [EOL] logger . error ( f" [string] { e }" ) [EOL] [comment] [EOL] return None [EOL] [EOL] def get_docker_image ( self , mypy_version_id ) : [EOL] return parse_option_as_dict ( [string] ) . get ( mypy_version_id ) [EOL] [EOL] [EOL] semaphore = None [EOL] [EOL] [EOL] def get_semaphore ( ) : [EOL] [comment] [EOL] global semaphore [EOL] if not semaphore : [EOL] value = options . sandbox_concurrency [EOL] logger . info ( [string] , value ) [EOL] semaphore = asyncio . Semaphore ( value ) [EOL] return semaphore [EOL] [EOL] [EOL] async def run_typecheck_in_sandbox ( sandbox , source , ** kwargs ) : [EOL] logger . debug ( [string] ) [EOL] with await get_semaphore ( ) : [EOL] logger . debug ( [string] ) [EOL] return await sandbox . run_typecheck ( source , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiodocker.Docker$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Result]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0