from itertools import tee [EOL] [EOL] def pairwise ( iterable ) : [EOL] [docstring] [EOL] a , b = tee ( iterable ) [EOL] next ( b , None ) [EOL] return zip ( a , b )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Tuple [EOL] import numpy [EOL] import typing [EOL] import numpy as np [EOL] from typing import Optional , Tuple [EOL] from bnh import Bin [EOL] [EOL] def tabulate ( x , y , w = None ) : [EOL] [EOL] if w is None : [EOL] w = np . ones ( len ( x ) ) [EOL] [EOL] uniq = np . unique ( x ) [EOL] ux = uniq [ ... , np . newaxis ] [comment] [EOL] cnts = np . array ( tuple ( ( ( x == ux ) [ : , y == v ] ) . dot ( w [ y == v ] ) for v in [ [number] , [number] ] ) ) . T [EOL] [EOL] return ( uniq , cnts ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[numpy.ndarray,numpy.ndarray]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import typing [EOL] import numpy [EOL] import bnh [EOL] import metrics [EOL] import builtins [EOL] import numpy as np [EOL] import typing [EOL] from __future__ import annotations [EOL] from typing import Union , Optional , List , Tuple [EOL] from util import pairwise [EOL] from tabulate import tabulate [EOL] from metrics import Metric [EOL] [EOL] class Bin : [EOL] [EOL] def __init__ ( self , uniq , cnts ) : [EOL] self . uniq = uniq [EOL] self . cnts = cnts [EOL] pass [EOL] [EOL] def best_split ( self , metric ) : [EOL] [EOL] vals = metric . evaluate ( self ) [EOL] i = metric . best_index ( vals ) [EOL] [EOL] return self . uniq [ i ] , vals [ i ] [EOL] [EOL] [EOL] class BNH : [EOL] def __init__ ( self , max_bins = [number] , min_obs_per_bin = [number] , exceptions = None , epsilon_break = [number] , epsilon_heal = [number] ) : [EOL] [EOL] [docstring] [EOL] [EOL] if exceptions is None : [EOL] exceptions = [ ] [EOL] [EOL] self . max_bins = max_bins [EOL] self . min_obs_per_bin = max_bins [EOL] self . exceptions = exceptions [EOL] self . epsilon_break = epsilon_break [EOL] self . epsilon_heal = epsilon_heal [EOL] [EOL] self . bins = [ ] [EOL] [EOL] [EOL] def _break_bin ( self , bin ) : [EOL] pass [EOL] [EOL] def _merge_bins ( self , binx , biny ) : [EOL] pass [EOL] [EOL] [comment] [EOL] def _break ( self ) : [EOL] for bin in self . bins : [EOL] self . _break_bin ( bin ) [EOL] [EOL] [comment] [EOL] def _heal ( self ) : [EOL] [comment] [EOL] for ( binx , biny ) in pairwise ( self . bins ) : [EOL] self . _merge_bins ( binx , biny ) [EOL] [EOL] def _break_and_heal ( self ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def _fit ( self , x , y , w = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] uniq , cnts = tabulate ( x , y , w ) [EOL] [EOL] [comment] [EOL] self . bins . append ( Bin ( uniq , cnts ) ) [EOL] [EOL] self . _break_and_heal ( ) [EOL] [EOL] return ( list ( uniq ) , self . exceptions ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] clf = BNH ( [number] , [number] , [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 $metrics.Metric$ 0 0 0 0 $typing.Any$ 0 $metrics.Metric$ 0 0 0 0 0 0 $typing.Any$ 0 $metrics.Metric$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.float]$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[builtins.float]$ 0 $typing.List[builtins.float]$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $typing.List[Bin]$ 0 0 0 0 0 0 0 $typing.List[Bin]$ 0 0 0 0 0 0 0 0 0 0 0 $Bin$ 0 0 0 $Bin$ 0 $Bin$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.float],typing.List[builtins.float]]$ 0 0 0 $numpy.ndarray$ 0 $numpy.ndarray$ 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 $numpy.ndarray$ 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bnh.bnh.BNH$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
from bnh . tabulate import * [EOL] import unittest [EOL] import numpy as np [EOL] [EOL] class TestTabulate ( unittest . TestCase ) : [EOL] [EOL] def test_tabulate ( self ) : [EOL] uniq , table = tabulate ( np . array ( [ [number] , [number] ] ) , np . array ( [ [number] , [number] ] ) ) [EOL] np . testing . assert_array_equal ( uniq , np . array ( [ [ [number] ] , [ [number] ] ] ) ) [EOL] np . testing . assert_array_equal ( table , np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] , dtype = [string] ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0