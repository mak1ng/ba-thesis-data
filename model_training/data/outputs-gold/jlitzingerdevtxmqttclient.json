[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from OpenSSL import crypto [EOL] from twisted . internet import ssl [EOL] [EOL] [EOL] def load_client_cert_and_key ( cert_path , key_path ) : [EOL] [docstring] [EOL] with open ( cert_path , [string] ) as cert_file : [EOL] cert = ssl . Certificate . loadPEM ( cert_file . read ( ) ) [EOL] [EOL] with open ( key_path , [string] ) as key_file : [EOL] key = key_file . read ( ) [EOL] [EOL] client_certs = ssl . PrivateCertificate . fromCertificateAndKeyPair ( cert , ssl . KeyPair . load ( key , format = crypto . FILETYPE_PEM ) ) [EOL] [EOL] return client_certs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Any [EOL] import typing [EOL] import src [EOL] [docstring] [EOL] from __future__ import absolute_import [EOL] [EOL] import binascii [EOL] [EOL] from twisted . internet import ssl , endpoints , reactor , protocol , task , defer [EOL] from twisted . logger import Logger [EOL] import mqttpacket . v311 as mqttpacket [EOL] [EOL] defer . setDebugging ( True ) [EOL] [EOL] _logMQTT = True [EOL] [EOL] [EOL] class MQTTClient ( protocol . Protocol ) : [EOL] [docstring] [EOL] log = Logger ( ) [EOL] [EOL] def __init__ ( self , client_id ) : [EOL] self . client_id = client_id [EOL] self . _incoming = bytearray ( ) [EOL] self . _connack_d = defer . Deferred ( ) [EOL] self . _maintenance = None [EOL] [EOL] def connect ( self ) : [EOL] [docstring] [EOL] self . log . info ( [string] ) [EOL] connpkt = mqttpacket . connect ( self . client_id ) [EOL] if _logMQTT : [EOL] self . log . info ( [string] , bdata = binascii . hexlify ( connpkt ) ) [EOL] [EOL] self . transport . write ( connpkt ) [EOL] return self . _connack_d [EOL] [EOL] def connectionMade ( self ) : [EOL] self . log . info ( [string] ) [EOL] [EOL] def connectionLost ( self , reason = protocol . connectionDone ) : [EOL] self . log . warn ( [string] , reason = reason . getErrorMessage ( ) ) [EOL] if not self . _connack_d . called : [EOL] self . _connack_d . errback ( reason ) [EOL] [EOL] def logPrefix ( self ) : [EOL] return [string] [EOL] [EOL] def _send_ping ( self ) : [EOL] msg = mqttpacket . pingreq ( ) [EOL] self . transport . write ( msg ) [EOL] [EOL] def _start_maintenance ( self ) : [EOL] self . _maintenance = task . LoopingCall ( self . _send_ping ) [EOL] self . _maintenance . start ( [number] , now = False ) [EOL] [EOL] def dataReceived ( self , data ) : [EOL] if _logMQTT : [EOL] self . log . info ( [string] , bdata = binascii . hexlify ( data ) ) [EOL] self . _incoming . extend ( data ) [EOL] packets = [ ] [EOL] consumed = mqttpacket . parse ( self . _incoming , packets ) [EOL] if _logMQTT : [EOL] self . log . info ( [string] , cons = consumed ) [EOL] [EOL] for packet in packets : [EOL] self . log . debug ( [string] , pkt = packet ) [EOL] if packet . pkt_type == mqttpacket . MQTT_PACKET_CONNACK : [EOL] if not self . _connack_d . called : [EOL] self . _connack_d . callback ( self ) [EOL] self . _start_maintenance ( ) [EOL] [EOL] self . _incoming = self . _incoming [ consumed : ] [EOL] [EOL] def subscribe ( self , topic ) : [EOL] [docstring] [EOL] tfs = [ mqttpacket . SubscriptionSpec ( topic , [number] ) ] [EOL] subscription = mqttpacket . subscribe ( [number] , tfs ) [EOL] if _logMQTT : [EOL] self . log . info ( [string] , subs = binascii . hexlify ( subscription ) ) [EOL] self . transport . write ( subscription ) [EOL] [EOL] def publish ( self , topic , message ) : [EOL] [comment] [EOL] [docstring] [EOL] if not isinstance ( message , bytes ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] msg = mqttpacket . publish ( topic , False , [number] , False , message ) [EOL] if _logMQTT : [EOL] self . log . info ( [string] , pub = binascii . hexlify ( msg ) ) [EOL] self . transport . write ( msg ) [EOL] [EOL] [EOL] def connect_mqtt_tls ( client_id , host , rootpath , port , client_creds = None , protocols = None , ) : [EOL] [docstring] [EOL] with open ( rootpath , [string] ) as rootf : [EOL] rootblob = rootf . read ( ) [EOL] [EOL] trust_root = ssl . trustRootFromCertificates ( [ ssl . Certificate . loadPEM ( rootblob ) ] ) [EOL] [EOL] tls_options = ssl . optionsForClientTLS ( host , trustRoot = trust_root , clientCertificate = client_creds , acceptableProtocols = protocols ) [EOL] [EOL] endpoint = endpoints . SSL4ClientEndpoint ( reactor , host , port , tls_options ) [EOL] [EOL] d = endpoints . connectProtocol ( endpoint , MQTTClient ( client_id ) ) [EOL] [EOL] def _socket_connected ( client ) : [EOL] return client . connect ( ) [EOL] [EOL] d . addCallback ( _socket_connected ) [EOL] return d [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.txmqttclient.clients.MQTTClient]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.bytearray$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0