from typing import List , Iterator , Any [EOL] import asyncio [EOL] import threading [EOL] import typing [EOL] import asyncio [EOL] from queue import Queue [EOL] from functools import wraps [EOL] from threading import Thread [EOL] from collections . abc import Awaitable [EOL] [EOL] from tenacity import AsyncRetrying [EOL] [EOL] [EOL] def async_retry ( * dargs , ** dkw ) : [EOL] if len ( dargs ) == [number] and callable ( dargs [ [number] ] ) : [EOL] return async_retry ( ) ( dargs [ [number] ] ) [EOL] else : [EOL] return AsyncRetrying ( * dargs , ** dkw ) . wraps [EOL] [EOL] [EOL] def task_function ( coroutine_function , * , loop = None ) : [EOL] @ wraps ( coroutine_function ) def _task_function ( * args , ** kwargs ) : [EOL] return asyncio . ensure_future ( coroutine_function ( * args , ** kwargs ) , loop = loop ) [EOL] [EOL] return _task_function [EOL] [EOL] [EOL] def sync ( f , loop = None ) : [EOL] @ wraps ( f ) def _sync ( * args , ** kwargs ) : [EOL] coro = f ( * args , ** kwargs ) [EOL] if loop is None : [EOL] return asyncio . run ( coro ) [EOL] return loop . run_until_complete ( coro ) [EOL] [EOL] return _sync [EOL] [EOL] [EOL] def agnostic ( f ) : [EOL] @ wraps ( f ) def _agnostic ( * args , ** kwargs ) : [EOL] result = f ( * args , ** kwargs ) [EOL] if not isinstance ( result , Awaitable ) : [EOL] return result [EOL] try : [EOL] asyncio . get_running_loop ( ) [EOL] return result [EOL] except RuntimeError : [EOL] return asyncio . run ( result ) [EOL] [EOL] return _agnostic [EOL] [EOL] [EOL] def flatten ( f ) : [EOL] @ wraps ( f ) def _flatten ( * args , ** kwargs ) : [EOL] return flat ( f ( * args , ** kwargs ) ) [EOL] [EOL] return _flatten [EOL] [EOL] [EOL] async def flat ( coro ) : [EOL] while isinstance ( coro , Awaitable ) : [EOL] coro = await coro [EOL] return coro [EOL] [EOL] [EOL] async def resolve ( awaitable_or_not ) : [EOL] if isinstance ( awaitable_or_not , Awaitable ) : [EOL] return await awaitable_or_not [EOL] return awaitable_or_not [EOL] [EOL] [EOL] async def then ( f , coro ) : [EOL] return await flatten ( f ) ( await flat ( coro ) ) [EOL] [EOL] [EOL] class AsCompletedQueue : [EOL] def __init__ ( self , * , loop = None , timeout = None ) : [EOL] self . _loop = loop if loop is not None else asyncio . get_event_loop ( ) [EOL] self . _todo = set ( ) [EOL] self . _done = asyncio . Queue ( loop = self . _loop ) [EOL] self . _timeout_handle = None [EOL] if timeout is not None : [EOL] self . _timeout_handle = loop . call_later ( timeout , self . _on_timeout ) [EOL] self . _qsize = [number] [EOL] [EOL] def qsize ( self ) : [EOL] return self . _qsize [EOL] [EOL] def get_nowait ( self ) : [EOL] if not self . _qsize : [EOL] raise asyncio . QueueEmpty ( [string] ) [EOL] else : [EOL] self . _qsize -= [number] [EOL] return self . _wait_for_one ( ) [EOL] [EOL] def get_all_nowait ( self ) : [EOL] acc = [ ] [EOL] while True : [EOL] try : [EOL] acc . append ( self . get_nowait ( ) ) [EOL] except asyncio . QueueEmpty : [EOL] break [EOL] return acc [EOL] [EOL] def put_nowait ( self , awaitable ) : [EOL] task = self . _loop . create_task ( awaitable ) [EOL] self . _todo . add ( task ) [EOL] task . add_done_callback ( self . _on_completion ) [EOL] self . _qsize += [number] [EOL] [EOL] def submit ( self , f , * args , ** kwargs ) : [EOL] self . put_nowait ( f ( * args , ** kwargs ) ) [EOL] [EOL] def submit_flatten ( self , f , * args , ** kwargs ) : [EOL] self . submit ( flatten ( f ) , * args , ** kwargs ) [EOL] [EOL] def iter_until_empty ( self ) : [EOL] for coro in self . get_until_empty ( ) : [EOL] yield self . _loop . run_until_complete ( coro ) [EOL] [EOL] async def aiter_until_empty ( self ) : [EOL] for coro in self . get_until_empty ( ) : [EOL] yield await coro [EOL] [EOL] def get_until_empty ( self ) : [EOL] while True : [EOL] try : [EOL] coro = self . get_nowait ( ) [EOL] except asyncio . QueueEmpty : [EOL] break [EOL] yield coro [EOL] [EOL] def _on_timeout ( self ) : [EOL] for f in self . _todo : [EOL] f . remove_done_callback ( self . _on_completion ) [EOL] self . _done . put_nowait ( None ) [EOL] self . _todo . clear ( ) [EOL] self . _qsize = [number] [EOL] [EOL] def _on_completion ( self , f ) : [EOL] if not self . _todo : [EOL] return [EOL] self . _todo . remove ( f ) [EOL] self . _done . put_nowait ( f ) [EOL] if not self . _todo and self . _timeout_handle is not None : [EOL] self . _timeout_handle . cancel ( ) [EOL] [EOL] async def _wait_for_one ( self ) : [EOL] f = await self . _done . get ( ) [EOL] if f is None : [EOL] raise asyncio . futures . TimeoutError [EOL] return f . result ( ) [EOL] [EOL] [EOL] async def as_completed_map ( f , * its , loop = None ) : [EOL] if loop is None : [EOL] loop = asyncio . get_event_loop ( ) [EOL] [EOL] _ = map ( f , * its ) [EOL] _ = map ( loop . create_task , _ ) [EOL] _ = asyncio . as_completed ( list ( _ ) ) [EOL] [EOL] for completed in _ : [EOL] yield await completed [EOL] [EOL] [EOL] class aiter_to_iter : [EOL] def __init__ ( self , it , loop = None ) : [EOL] if loop is None : [EOL] self . _loop = asyncio . get_event_loop ( ) [EOL] else : [EOL] self . _loop = loop [EOL] self . _it = it [EOL] self . _queue = Queue ( ) [EOL] [EOL] def __iter__ ( self ) : [EOL] t = Thread ( target = self . _worker ) [EOL] t . start ( ) [EOL] while True : [EOL] done , value = self . _queue . get ( ) [EOL] if done : [EOL] break [EOL] yield value [EOL] [EOL] if value is not None : [EOL] raise value [EOL] [EOL] t . join ( ) [EOL] [EOL] def _worker ( self ) : [EOL] self . _loop . run_until_complete ( self . _enqueue_each_done ( ) ) [EOL] [EOL] async def _enqueue_each_done ( self ) : [EOL] try : [EOL] async for el in self . _it : [EOL] self . _queue . put ( ( False , el ) ) [EOL] self . _queue . put ( ( True , None ) ) [EOL] except Exception as e : [EOL] self . _queue . put ( ( True , e ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import concurrent [EOL] import typing [EOL] import os [EOL] from subprocess import Popen , PIPE , CalledProcessError [EOL] from concurrent . futures import ThreadPoolExecutor as Pool [EOL] [EOL] [EOL] def lines ( cmd ) : [EOL] [docstring] [EOL] with Popen ( cmd , shell = True , text = True , bufsize = [number] , stdout = PIPE ) as process : [EOL] yield from map ( process_line , process . stdout ) [EOL] [EOL] [EOL] def process_line ( line ) : [EOL] return line [ : - [number] ] if line [ - [number] ] == os . linesep else line [EOL] [EOL] [EOL] def pipe_iter ( it , command ) : [EOL] [docstring] [EOL] with Popen ( command , shell = True , text = True , stdin = PIPE , stdout = PIPE , stderr = PIPE ) as process , Pool ( max_workers = [number] ) as executor : [EOL] [comment] [EOL] stderr = executor . submit ( [string] . join , process . stderr ) [EOL] executor . submit ( _write_each , it , process . stdin ) [EOL] [EOL] try : [EOL] yield from map ( process_line , process . stdout ) [EOL] except : [EOL] process . kill ( ) [EOL] raise [EOL] [EOL] retcode = process . poll ( ) [EOL] if retcode : [EOL] raise CalledProcessError ( retcode , process . args , stderr = stderr . result ( ) ) [EOL] [EOL] [EOL] def _write_each ( it , fp ) : [EOL] for el in it : [EOL] fp . write ( str ( el ) ) [EOL] fp . write ( os . linesep ) [EOL] fp . flush ( ) [EOL] fp . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , List , Any , Dict [EOL] import types [EOL] import typing [EOL] import collections . abc [EOL] from itertools import cycle [EOL] from functools import partial [EOL] from types import SimpleNamespace [EOL] [EOL] import aiohttp [EOL] import dateparser [EOL] from parsel import Selector [EOL] from fake_useragent import UserAgent [EOL] [EOL] from . asynctools import agnostic [EOL] [EOL] [EOL] @ agnostic async def scrape ( url , * args , ** kwargs ) : [EOL] if isinstance ( url , str ) and url . startswith ( [string] ) : [EOL] if [string] not in kwargs : [EOL] kwargs . update ( session = { [string] : True } ) [EOL] [EOL] response = await get ( url , * args , ** kwargs ) [EOL] html = response . body . decode ( response . charset ) [EOL] [EOL] return Selector ( text = html , base_url = url ) [EOL] [EOL] else : [EOL] try : [EOL] return Selector ( text = url ) [EOL] except TypeError : [EOL] return Selector ( text = url . body . decode ( url . charset ) ) [EOL] [EOL] [EOL] async def request ( method , url , * args , session = None , ** kwargs ) : [EOL] if session is None : [EOL] session = { } [EOL] if isinstance ( session , dict ) : [EOL] async with aiohttp . ClientSession ( ** session ) as session : [EOL] return await request ( method , url , * args , session = session , ** kwargs ) [EOL] async with session . request ( method , url , * args , ** kwargs ) as response : [EOL] await response . read ( ) [EOL] return response [EOL] [EOL] [EOL] locals ( ) . update ( ** { method : partial ( request , method ) for method in [ [string] , [string] , [string] ] } ) [EOL] [EOL] [EOL] @ agnostic async def get_proxies ( ) : [EOL] document = await scrape ( [string] ) [EOL] [EOL] keys = [string] [EOL] keys = keys . split ( ) [EOL] [EOL] y_n = { [string] : True , [string] : False } [EOL] [EOL] acc = [ ] [EOL] trs = document . css ( [string] ) [ [number] : - [number] ] [EOL] for tr in trs : [EOL] tds = ( td . css ( [string] ) . extract_first ( ) for td in tr . css ( [string] ) ) [EOL] d = SimpleNamespace ( ** dict ( zip ( keys , tds ) ) ) [EOL] [EOL] d . google = _try ( lambda : y_n [ d . google ] ) [EOL] d . https = _try ( lambda : y_n [ d . https ] ) [EOL] d . last_checked = _try ( lambda : dateparser . parse ( d . last_checked ) ) [EOL] [EOL] acc . append ( d ) [EOL] return acc [EOL] [EOL] [EOL] def _try ( f , default = None ) : [EOL] try : [EOL] return f ( ) [EOL] except Exception : [EOL] return default [EOL] [EOL] [EOL] class Identities ( collections . abc . Iterator ) : [EOL] def __init__ ( self ) : [EOL] self . _user_agents = UserAgent ( ) [EOL] self . _proxies = cycle ( [ p for p in get_proxies ( ) if p . anonymity == [string] ] ) [EOL] [EOL] def __next__ ( self ) : [EOL] return SimpleNamespace ( user_agent = self . _user_agents . random , ** next ( self . _proxies ) . __dict__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import ValuesView , Tuple , Generator , Any , Type [EOL] import misc [EOL] import inspect [EOL] import typing [EOL] import inspect [EOL] from functools import wraps , update_wrapper [EOL] [EOL] from toolz . functoolz import compose [EOL] [EOL] [EOL] class infix : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , function ) : [EOL] self . _function = function [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return self . _function ( * args , ** kwargs ) [EOL] [EOL] def __ror__ ( self , left_argument ) : [EOL] return left_section ( self . _function , left_argument ) [EOL] [EOL] def __or__ ( self , right_argument ) : [EOL] return right_section ( self . _function , right_argument ) [EOL] [EOL] [EOL] class left_section : [EOL] def __init__ ( self , function , left_argument ) : [EOL] self . _function = function [EOL] self . _left_argument = left_argument [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return self . _function ( self . _left_argument , * args , ** kwargs ) [EOL] [EOL] __or__ = __call__ [EOL] [EOL] [EOL] class right_section : [EOL] def __init__ ( self , function , right_argument ) : [EOL] self . _function = function [EOL] self . _right_argument = right_argument [EOL] [EOL] def __call__ ( self , arg , * args , ** kwargs ) : [EOL] return self . _function ( arg , self . _right_argument , * args , ** kwargs ) [EOL] [EOL] __ror__ = __call__ [EOL] [EOL] [EOL] class profunction : [EOL] def __init__ ( self , function = lambda arg : arg ) : [EOL] self . _function = function [EOL] update_wrapper ( self , function ) [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return self . _function ( * args , ** kwargs ) [EOL] [EOL] def before ( self , * fs ) : [EOL] return self . __class__ ( compose ( self . _function , * reversed ( fs ) ) ) [EOL] [EOL] def after ( self , * fs ) : [EOL] return self . __class__ ( compose ( * reversed ( fs ) , self . _function ) ) [EOL] [EOL] [EOL] def decorate ( decorator ) : [EOL] def _decorate ( to_wrap ) : [EOL] return wraps ( to_wrap ) ( lambda * args , ** kwargs : decorator ( to_wrap , * args , ** kwargs ) ) [EOL] [EOL] return _decorate [EOL] [EOL] [EOL] def before ( * process_arguments ) : [EOL] def _before ( f ) : [EOL] return profunction ( f ) . before ( * process_arguments ) . _function [EOL] [EOL] return _before [EOL] [EOL] [EOL] def after ( * process_result ) : [EOL] def _after ( f ) : [EOL] return profunction ( f ) . after ( * process_result ) . _function [EOL] [EOL] return _after [EOL] [EOL] [EOL] def kwargs ( f ) : [EOL] [docstring] [EOL] parameters = inspect . signature ( f ) . parameters . values ( ) [EOL] [EOL] @ wraps ( f ) def _kwargs ( ** user_kwargs ) : [EOL] _ = ( ( p . name , user_kwargs . get ( p . name , p . default ) ) for p in parameters ) [EOL] return f ( ** dict ( ( k , v ) for k , v in _ if v is not inspect . _empty ) ) [EOL] [EOL] return _kwargs [EOL] [EOL] [EOL] def match ( test , obj , cases ) : [EOL] [docstring] [EOL] for type_ , handler in cases . items ( ) : [EOL] if test ( obj , type_ ) : [EOL] return handler ( obj ) [EOL] else : [EOL] raise TypeError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0