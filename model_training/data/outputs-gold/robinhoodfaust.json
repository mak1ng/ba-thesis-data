	0
from typing import List [EOL] import typing [EOL] from time import time [EOL] from faust . events import Event [EOL] from faust . types . tuples import Message [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] def message ( key = None , value = None , * , topic = [string] , partition = [number] , timestamp = None , headers = None , offset = [number] , checksum = None ) : [EOL] return Message ( key = key , value = value , topic = topic , partition = partition , offset = offset , timestamp = timestamp or time ( ) , timestamp_type = [number] if timestamp else [number] , headers = headers , checksum = checksum , ) [EOL] [EOL] [EOL] def new_event ( app , key = None , value = None , * , headers = None , ** kwargs ) : [EOL] return Event ( app , key , value , headers , message ( key = key , value = value , headers = headers , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List [EOL] import typing [EOL] from . faust import app [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] def main ( ) : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import faust [EOL] [EOL] [EOL] def create_app ( ) : [EOL] return faust . App ( [string] , origin = [string] , autodiscover = True , ) [EOL] [EOL] [EOL] app = create_app ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from proj324 . faust import app [EOL] [EOL] print ( [string] ) [EOL] [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
print ( [string] ) [EOL]	0 0 0 0 0
	0
	0
	0
from proj324 import app [EOL] [EOL] [EOL] @ app . command ( ) async def myprocesscommandi324 ( ) : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import faust [EOL] [EOL] [EOL] def create_app ( ) : [EOL] return faust . App ( [string] , origin = [string] , autodiscover = True , ) [EOL] [EOL] [EOL] app = create_app ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . faust import app [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] def main ( ) : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0
	0
	0
from proj323 import app [EOL] [EOL] [EOL] @ app . command ( ) async def myprocesscommandi323 ( ) : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import faust . exceptions [comment] [EOL] import faust . transport . drivers . aiokafka [comment] [EOL] import faust . transport . base [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import faust [EOL] import typing [EOL] import ssl [EOL] import pytest [EOL] from faust . auth import GSSAPICredentials , SASLCredentials , SSLCredentials [EOL] from faust . types . auth import AuthProtocol , SASLMechanism [EOL] from mode . utils . mocks import Mock , patch [EOL] [EOL] [EOL] class test_SASLCredentials : [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ pytest . param ( [string] , SASLCredentials ( username = [string] , password = [string] ) , { [string] : [string] , [string] : [string] , [string] : SASLMechanism . PLAIN , [string] : AuthProtocol . SASL_PLAINTEXT } ) , pytest . param ( [string] , SASLCredentials ( username = [string] , password = [string] , mechanism = [string] ) , { [string] : SASLMechanism . GSSAPI } ) , pytest . param ( [string] , SASLCredentials ( username = [string] , password = [string] , mechanism = SASLMechanism . GSSAPI ) , { [string] : SASLMechanism . GSSAPI } ) , pytest . param ( [string] , SASLCredentials ( username = [string] , password = [string] , ssl_context = { [string] : [string] } ) , { [string] : [string] , [string] : [string] , [string] : { [string] : [string] } , [string] : AuthProtocol . SASL_SSL } ) , ] ) def test_constructor ( self , credentials , expected_fields , reason ) : [EOL] assert repr ( credentials ) [EOL] for field , value in expected_fields . items ( ) : [EOL] assert getattr ( credentials , field ) == value , reason [EOL] [EOL] [EOL] class test_GSSAPICredentials : [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ pytest . param ( [string] , GSSAPICredentials ( kerberos_service_name = [string] , kerberos_domain_name = [string] ) , { [string] : [string] , [string] : [string] , [string] : SASLMechanism . GSSAPI , [string] : AuthProtocol . SASL_PLAINTEXT } ) , pytest . param ( [string] , GSSAPICredentials ( kerberos_service_name = [string] , kerberos_domain_name = [string] , mechanism = [string] ) , { [string] : SASLMechanism . PLAIN } ) , pytest . param ( [string] , GSSAPICredentials ( kerberos_service_name = [string] , kerberos_domain_name = [string] , mechanism = SASLMechanism . PLAIN ) , { [string] : SASLMechanism . PLAIN } ) , pytest . param ( [string] , GSSAPICredentials ( kerberos_service_name = [string] , kerberos_domain_name = [string] , ssl_context = { [string] : [string] } ) , { [string] : [string] , [string] : [string] , [string] : { [string] : [string] } , [string] : AuthProtocol . SASL_SSL } ) , ] ) def test_constructor ( self , credentials , expected_fields , reason ) : [EOL] assert repr ( credentials ) [EOL] for field , value in expected_fields . items ( ) : [EOL] assert getattr ( credentials , field ) == value , reason [EOL] [EOL] [EOL] class test_SSLCredentials : [EOL] [EOL] def test_constructor ( self ) : [EOL] with patch ( [string] ) as cdc : [EOL] c = SSLCredentials ( purpose = ssl . Purpose . SERVER_AUTH , cafile = [string] , capath = [string] , cadata = [string] , ) [EOL] assert c . context is cdc . return_value [EOL] assert repr ( c ) [EOL] cdc . assert_called_once_with ( purpose = ssl . Purpose . SERVER_AUTH , cafile = [string] , capath = [string] , cadata = [string] , ) [EOL] [EOL] def test_having_context ( self ) : [EOL] context = Mock ( name = [string] ) [EOL] c = SSLCredentials ( context ) [EOL] assert c . context is context [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.auth.SSLCredentials$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.auth.SSLCredentials$ 0 0 0 0 0 0 0 0 0 0 $faust.auth.SSLCredentials$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $faust.auth.SSLCredentials$ 0 0 0 $typing.Any$ 0 0 0 $faust.auth.SSLCredentials$ 0 $typing.Any$ 0 $typing.Any$ 0
from typing import Any [EOL] import pathlib [EOL] import faust [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] import warnings [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from faust import Sensor [EOL] from faust . worker import Worker [EOL] from faust . utils import terminal [EOL] from mode . utils . logging import CompositeLogger [EOL] from mode . utils . trees import Node [EOL] from mode . utils . mocks import AsyncMock , Mock , patch [EOL] from yarl import URL [EOL] [EOL] [EOL] class CoroEq : [EOL] [EOL] def __init__ ( self , coro ) : [EOL] self . coro = coro [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return other . cr_code . co_name == self . coro . __name__ [EOL] [EOL] [EOL] class test_Worker : [EOL] [EOL] @ pytest . fixture def worker ( self , app ) : [EOL] return Worker ( app ) [EOL] [EOL] def test_constructor ( self , app ) : [EOL] w = Worker ( app ) [EOL] assert w . app is app [EOL] assert w . sensors == set ( ) [EOL] assert w . workdir == Path . cwd ( ) [EOL] assert isinstance ( w . spinner , terminal . Spinner ) [EOL] w2 = Worker ( app , redirect_stdouts = False ) [EOL] assert not w2 . redirect_stdouts [EOL] w3 = Worker ( app , redirect_stdouts_level = [string] ) [EOL] assert w3 . redirect_stdouts_level == [number] [EOL] w4 = Worker ( app , logging_config = { [string] : [number] } ) [EOL] assert w4 . logging_config == { [string] : [number] } [EOL] [EOL] def test_set_sensors ( self , app ) : [EOL] assert Worker ( app , sensors = [ [number] , [number] ] ) . sensors == { [number] , [number] } [EOL] [EOL] def test_set_workdir ( self , app ) : [EOL] assert Worker ( app , workdir = [string] ) . workdir == Path ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start ( self , worker ) : [EOL] await worker . on_start ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_siginit ( self , worker ) : [EOL] with warnings . catch_warnings ( ) : [EOL] with patch ( [string] ) as ensure_future : [EOL] worker . _on_sigint ( ) [EOL] assert worker . _shutdown_immediately [EOL] assert worker . spinner . stopped [EOL] ensure_future . assert_called_with ( CoroEq ( worker . _stop_on_signal ) , loop = worker . loop ) [EOL] coro = ensure_future . call_args [ [number] ] [ [number] ] [EOL] asyncio . ensure_future ( coro ) . cancel ( ) [comment] [EOL] [EOL] @ pytest . mark . asyncio async def test_on_siginit__no_spinner ( self , worker , loop ) : [EOL] worker . spinner = None [EOL] with patch ( [string] ) as ensure_future : [EOL] worker . _on_sigint ( ) [EOL] coro = ensure_future . call_args [ [number] ] [ [number] ] [EOL] asyncio . ensure_future ( coro , loop = loop ) . cancel ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test__on_sigterm ( self , worker ) : [EOL] with patch ( [string] ) as ensure_future : [EOL] worker . _on_sigterm ( ) [EOL] assert worker . _shutdown_immediately [EOL] assert worker . spinner . stopped [EOL] ensure_future . assert_called_with ( CoroEq ( worker . _stop_on_signal ) , loop = worker . loop ) [EOL] coro = ensure_future . call_args [ [number] ] [ [number] ] [EOL] asyncio . ensure_future ( coro ) . cancel ( ) [comment] [EOL] [EOL] @ pytest . mark . asyncio async def test_on_startup_finished__shutdown_requested ( self , worker ) : [EOL] worker . _shutdown_immediately = True [EOL] worker . _on_shutdown_immediately = Mock ( name = [string] ) [EOL] await worker . on_startup_finished ( ) [EOL] worker . _on_shutdown_immediately . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_startup_finished ( self , worker ) : [EOL] worker . maybe_start_blockdetection = AsyncMock ( name = [string] ) [EOL] worker . _on_startup_end_spinner = Mock ( name = [string] ) [EOL] await worker . on_startup_finished ( ) [EOL] worker . maybe_start_blockdetection . assert_called_once_with ( ) [EOL] worker . _on_startup_end_spinner . assert_called_once_with ( ) [EOL] [EOL] def test_on_startup_end_spinner ( self , worker ) : [EOL] spinner = worker . spinner = Mock ( name = [string] , autospec = terminal . Spinner , ) [EOL] spinner . file . isatty . return_value = True [EOL] worker . say = Mock ( name = [string] ) [EOL] worker . _on_startup_end_spinner ( ) [EOL] spinner . finish . assert_called_once_with ( ) [EOL] worker . say . assert_called_once_with ( [string] ) [EOL] [EOL] def test_on_startup_end_spinner__no_spinner ( self , worker ) : [EOL] worker . spinner = None [EOL] worker . log = Mock ( name = [string] , spec = CompositeLogger ) [EOL] worker . _on_startup_end_spinner ( ) [EOL] worker . log . info . assert_called_once_with ( [string] ) [EOL] [EOL] def test_on_startup_end_spinner__notatty ( self , worker ) : [EOL] spinner = worker . spinner = Mock ( name = [string] , autospec = terminal . Spinner , ) [EOL] spinner . file . isatty . return_value = False [EOL] worker . say = Mock ( name = [string] ) [EOL] worker . _on_startup_end_spinner ( ) [EOL] spinner . finish . assert_called_once_with ( ) [EOL] worker . say . assert_called_once_with ( [string] ) [EOL] [EOL] def test_on_shutdown_immediately ( self , worker ) : [EOL] worker . say = Mock ( name = [string] ) [EOL] worker . _on_shutdown_immediately ( ) [EOL] worker . say . assert_called_once_with ( [string] ) [EOL] [EOL] def test_on_init_dependencies ( self , worker , app ) : [EOL] app . beacon = Mock ( name = [string] , autospec = Node ) [EOL] deps = worker . on_init_dependencies ( ) [EOL] assert list ( deps ) == list ( worker . services ) + [ app ] [EOL] app . beacon . reattach . assert_called_once_with ( worker . beacon ) [EOL] assert app . on_startup_finished == worker . on_startup_finished [EOL] [EOL] def test_on_init_dependencies__sensors_to_app ( self , worker , app ) : [EOL] s1 = Mock ( name = [string] , autospec = Sensor ) [EOL] s2 = Mock ( name = [string] , autospec = Sensor ) [EOL] worker . sensors = { s1 , s2 } [EOL] worker . on_init_dependencies ( ) [EOL] assert app . sensors . _sensors . issubset ( worker . sensors ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_first_start ( self , worker ) : [EOL] worker . change_workdir = Mock ( name = [string] ) [EOL] worker . autodiscover = Mock ( name = [string] ) [EOL] worker . default_on_first_start = AsyncMock ( name = [string] ) [EOL] await worker . on_first_start ( ) [EOL] worker . change_workdir . assert_called_once_with ( worker . workdir ) [EOL] worker . autodiscover . assert_called_once_with ( ) [EOL] worker . default_on_first_start . assert_called_once_with ( ) [EOL] [EOL] def test_change_workdir ( self , worker ) : [EOL] with patch ( [string] ) as chdir : [EOL] p = Path ( [string] ) [EOL] worker . change_workdir ( p ) [EOL] chdir . assert_called_once_with ( p . absolute ( ) ) [EOL] [EOL] def test_change_workdir__already_cwd ( self , worker ) : [EOL] with patch ( [string] ) as chdir : [EOL] p = Path . cwd ( ) [EOL] worker . change_workdir ( p ) [EOL] chdir . assert_not_called ( ) [EOL] [EOL] def test_autodiscover ( self , worker ) : [EOL] worker . app . conf . autodiscover = True [EOL] worker . app . discover = Mock ( name = [string] ) [EOL] worker . autodiscover ( ) [EOL] worker . app . discover . assert_called_once_with ( ) [EOL] [EOL] def test_autodiscover__disabled ( self , worker ) : [EOL] worker . app . conf . autodiscover = False [EOL] worker . app . discover = Mock ( name = [string] ) [EOL] worker . autodiscover ( ) [EOL] worker . app . discover . assert_not_called ( ) [EOL] [EOL] def test_setproctitle ( self , worker , app ) : [EOL] with patch ( [string] ) as setproctitle : [EOL] worker . _setproctitle ( [string] ) [EOL] setproctitle . assert_called_with ( f' [string] { app . conf . web_port } [string] ' f'{ app . conf . datadir . absolute ( ) }' ) [EOL] [EOL] def test_proc_ident ( self , worker , app ) : [EOL] assert ( worker . _proc_ident ( ) == f' [string] { app . conf . web_port } [string] { app . conf . datadir . absolute ( ) }' ) [EOL] [EOL] def test_proc_web_ident__unix ( self , worker , app ) : [EOL] worker . app . conf . web_transport = URL ( [string] ) [EOL] assert worker . _proc_web_ident ( ) == str ( URL ( [string] ) ) [EOL] [EOL] def test_proc_web_ident__tcp ( self , worker ) : [EOL] worker . app . conf . web_transport_scheme = [string] [EOL] assert worker . _proc_web_ident ( ) == [string] [EOL] [EOL] def test_on_worker_shutdown ( self , worker ) : [EOL] worker . spinner = None [EOL] worker . _say = Mock ( name = [string] ) [EOL] worker . on_worker_shutdown ( ) [EOL] worker . spinner = Mock ( name = [string] ) [EOL] worker . on_worker_shutdown ( ) [EOL] worker . spinner . reset . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_execute ( self , worker ) : [EOL] worker . _setproctitle = Mock ( name = [string] ) [EOL] worker . spinner = Mock ( name = [string] , autospec = terminal . Spinner , ) [EOL] worker . _say = Mock ( name = [string] ) [EOL] await worker . on_execute ( ) [EOL] worker . _setproctitle . assert_called_with ( [string] ) [EOL] worker . _say . assert_called_with ( [string] , end = [string] , flush = True ) [EOL] worker . spinner = None [EOL] await worker . on_execute ( ) [EOL] [EOL] def test_on_setup_root_logger ( self , worker ) : [EOL] worker . _disable_spinner_if_level_below_WARN = Mock ( name = [string] ) [EOL] worker . _setup_spinner_handler = Mock ( name = [string] ) [EOL] logger = Mock ( name = [string] , autospec = logging . Logger ) [EOL] worker . on_setup_root_logger ( logger , logging . INFO ) [EOL] worker . _disable_spinner_if_level_below_WARN . assert_called_with ( logging . INFO ) [EOL] worker . _setup_spinner_handler . assert_called_with ( logger , logging . INFO ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , True ) , ( logging . CRITICAL , True ) , ( logging . ERROR , True ) , ( logging . WARN , True ) , ( logging . INFO , False ) , ( logging . DEBUG , False ) , ] ) def test_disable_spinner_if_level_below_WARN ( self , loglevel , expected , worker ) : [EOL] worker . _disable_spinner_if_level_below_WARN ( loglevel ) [EOL] if expected : [EOL] assert worker . spinner [EOL] else : [EOL] assert worker . spinner is None [EOL] [EOL] def test_setup_spinner_handler ( self , worker ) : [EOL] logger = Mock ( name = [string] , autospec = logging . Logger ) [EOL] logger . handlers = [ Mock ( name = [string] , autospec = logging . Handler ) ] [EOL] with patch ( [string] ) as SpinnerHandler : [EOL] worker . _setup_spinner_handler ( logger , logging . INFO ) [EOL] logger . handlers [ [number] ] . setLevel . assert_called_with ( logging . INFO ) [EOL] SpinnerHandler . assert_called_once_with ( worker . spinner , level = logging . DEBUG ) [EOL] logger . addHandler . assert_called_once_with ( SpinnerHandler ( ) ) [EOL] logger . setLevel . assert_called_once_with ( logging . DEBUG ) [EOL] [EOL] def test_setup_spinner_handler__when_no_spinner ( self , worker ) : [EOL] worker . spinner = None [EOL] worker . _setup_spinner_handler ( Mock ( name = [string] , autospec = logging . Logger , ) , logging . INFO , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 0 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.worker.Worker$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import faust [EOL] import pytest [EOL] from faust . transport . producer import Producer [EOL] from faust . utils . tracing import set_current_span [EOL] from mode . utils . mocks import AsyncMock , Mock [EOL] [EOL] [EOL] @ pytest . fixture ( ) def app ( event_loop , request ) : [EOL] settings = request . node . get_closest_marker ( [string] ) [EOL] kwargs = settings . kwargs or { } if settings else { } [EOL] [EOL] os . environ . pop ( [string] , None ) [EOL] os . environ . pop ( [string] , None ) [EOL] os . environ . pop ( [string] , None ) [EOL] os . environ . pop ( [string] , None ) [EOL] instance = faust . App ( [string] , ** kwargs ) [EOL] instance . producer = Mock ( name = [string] , autospec = Producer , maybe_start = AsyncMock ( ) , start = AsyncMock ( ) , send = AsyncMock ( ) , send_and_wait = AsyncMock ( ) , ) [EOL] instance . finalize ( ) [EOL] set_current_span ( None ) [EOL] return instance [EOL] [EOL] [EOL] @ pytest . fixture ( ) def web ( app ) : [EOL] return app . web [EOL] [EOL] [EOL] def pytest_configure ( config ) : [EOL] config . addinivalue_line ( [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
import datetime [EOL] from datetime import datetime , timedelta , timezone [EOL] import pytest [EOL] from mode . utils . mocks import ContextMock , patch [EOL] from faust . livecheck . models import TestExecution [EOL] from faust . livecheck . runners import TestRunner [EOL] [EOL] [EOL] @ pytest . fixture ( ) def livecheck ( * , app ) : [EOL] return app . LiveCheck ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def execution ( ) : [EOL] now = datetime . now ( ) . astimezone ( timezone . utc ) [EOL] expires = now + timedelta ( hours = [number] ) [EOL] return TestExecution ( id = [string] , case_name = [string] , timestamp = now , test_args = ( [string] , ) , test_kwargs = { [string] : [number] } , expires = expires , ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def case ( * , livecheck ) : [EOL] @ livecheck . case ( ) class test_foo ( livecheck . Case ) : [EOL] [EOL] async def run ( self , arg1 , kw1 = None ) : [EOL] assert arg1 == [string] [EOL] assert kw1 == [number] [EOL] assert True [EOL] return test_foo [EOL] [EOL] [EOL] @ pytest . fixture ( ) def runner ( * , execution , case ) : [EOL] return TestRunner ( case , execution , started = [number] ) [EOL] [EOL] [EOL] @ pytest . yield_fixture ( ) def current_test_stack ( ) : [EOL] with patch ( [string] ) as cts : [EOL] cts . push = ContextMock ( ) [EOL] yield cts [EOL] [EOL] [EOL] @ pytest . yield_fixture ( ) def current_execution_stack ( ) : [EOL] with patch ( [string] ) as ces : [EOL] ces . push = ContextMock ( ) [EOL] yield ces [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Dict , Type , List [EOL] import typing [EOL] import t [EOL] import asyncio [EOL] from typing import Union [EOL] import pytest [EOL] from mode . utils . compat import want_bytes [EOL] from mode . utils . mocks import AsyncMock , Mock , call [EOL] from faust . livecheck import LiveCheck [EOL] from faust . livecheck . app import LiveCheckSensor [EOL] from faust . livecheck . exceptions import TestFailed [EOL] from faust . livecheck . locals import current_test_stack [EOL] from faust . livecheck . models import SignalEvent , TestExecution , TestReport [EOL] from faust . livecheck . signals import BaseSignal [EOL] [EOL] [EOL] class test_LiveCheckSensor : [EOL] [EOL] @ pytest . fixture ( ) def sensor ( self ) : [EOL] return LiveCheckSensor ( ) [EOL] [EOL] def test_on_stream_event__no_test ( self , * , sensor ) : [EOL] stream = Mock ( ) [EOL] stream . current_test = None [EOL] event = Mock ( ) [EOL] event . headers = { } [EOL] state = sensor . on_stream_event_in ( ( [string] , [string] ) , [number] , stream , event ) [EOL] sensor . on_stream_event_out ( ( [string] , [string] ) , [number] , stream , event , state ) [EOL] [EOL] def test_on_stream_event ( self , * , sensor , execution ) : [EOL] stream = Mock ( ) [EOL] stream . current_test = None [EOL] event = Mock ( ) [EOL] event . headers = execution . as_headers ( ) [EOL] assert current_test_stack . top is None [EOL] state = sensor . on_stream_event_in ( ( [string] , [string] ) , [number] , stream , event ) [EOL] assert current_test_stack . top . id == execution . id [EOL] assert stream . current_test . id == execution . id [EOL] sensor . on_stream_event_out ( ( [string] , [string] ) , [number] , stream , event , state ) [EOL] assert current_test_stack . top is None [EOL] assert stream . current_test is None [EOL] [EOL] [EOL] class test_LiveCheck : [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , False , False ) , ] ) def test_constructor ( self , kwarg , value , expected_value ) : [EOL] app = LiveCheck ( [string] , ** { kwarg : value } ) [EOL] assert getattr ( app , kwarg ) == value [EOL] [EOL] def test_current_test ( self , * , livecheck ) : [EOL] test = Mock ( ) [EOL] assert livecheck . current_test is None [EOL] with current_test_stack . push ( test ) : [EOL] assert livecheck . current_test is test [EOL] assert livecheck . current_test is None [EOL] [EOL] def test__can_resolve ( self , livecheck ) : [EOL] assert isinstance ( livecheck . _can_resolve , asyncio . Event ) [EOL] [EOL] def test_on_produce_attach_test_headers ( self , * , livecheck , app , execution ) : [EOL] headers = [ ( [string] , [string] ) ] [EOL] original_headers = list ( headers ) [EOL] with current_test_stack . push ( execution ) : [EOL] livecheck . on_produce_attach_test_headers ( sender = app , key = [string] , value = [string] , partition = [number] , headers = headers , ) [EOL] kafka_headers = { k : want_bytes ( v ) for k , v in execution . as_headers ( ) . items ( ) } [EOL] assert headers == ( original_headers + list ( kafka_headers . items ( ) ) ) [EOL] [EOL] def test_on_produce_attach_test_headers__no_test ( self , * , livecheck , app ) : [EOL] assert livecheck . current_test is None [EOL] headers = [ ] [EOL] livecheck . on_produce_attach_test_headers ( sender = app , key = [string] , value = [string] , partition = [number] , headers = headers , ) [EOL] assert not headers [EOL] [EOL] def test_on_produce_attach_test_headers__missing ( self , * , livecheck , app ) : [EOL] test = Mock ( ) [EOL] with current_test_stack . push ( test ) : [EOL] with pytest . raises ( TypeError ) : [EOL] livecheck . on_produce_attach_test_headers ( sender = app , key = [string] , value = [string] , partition = [number] , headers = None , ) [EOL] [EOL] def test_case_decorator ( self , * , livecheck ) : [EOL] [EOL] class SignalWithNoneOrigin ( livecheck . Signal ) : [EOL] __origin__ = None [EOL] [EOL] @ livecheck . case ( ) class test_foo : [EOL] [EOL] signal1 = ... [EOL] signal2 = ... [EOL] signal3 = livecheck . Signal ( ) [EOL] foo = ... [EOL] bar = ... [EOL] [EOL] assert isinstance ( test_foo . signal1 , BaseSignal ) [EOL] assert isinstance ( test_foo . signal2 , SignalWithNoneOrigin ) [EOL] assert isinstance ( test_foo . signal3 , BaseSignal ) [EOL] [EOL] assert test_foo . signal1 . case is test_foo [EOL] assert test_foo . signal2 . case is test_foo [EOL] assert test_foo . signal1 . index == [number] [EOL] assert test_foo . signal2 . index == [number] [EOL] assert test_foo . signal3 . index == [number] [EOL] [EOL] def test_add_case ( self , * , livecheck ) : [EOL] case = Mock ( ) [EOL] livecheck . add_case ( case ) [EOL] assert livecheck . cases [ case . name ] is case [EOL] [EOL] @ pytest . mark . asyncio async def test_post_report ( self , * , livecheck ) : [EOL] report = Mock ( ) [EOL] report . test = None [EOL] livecheck . reports . send = AsyncMock ( ) [EOL] await livecheck . post_report ( report ) [EOL] livecheck . reports . send . assert_called_once_with ( key = None , value = report ) [EOL] [EOL] @ pytest . mark . asyncio async def test_post_report__with_test ( self , * , livecheck ) : [EOL] report = Mock ( ) [EOL] report . test = Mock ( ) [EOL] report . test . id = [string] [EOL] livecheck . reports . send = AsyncMock ( ) [EOL] await livecheck . post_report ( report ) [EOL] livecheck . reports . send . assert_called_once_with ( key = [string] , value = report ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start ( self , * , livecheck ) : [EOL] livecheck . _install_bus_agent = Mock ( ) [EOL] livecheck . _install_test_execution_agent = Mock ( ) [EOL] [EOL] await livecheck . on_start ( ) [EOL] [EOL] livecheck . _install_bus_agent . assert_called_once_with ( ) [EOL] livecheck . _install_test_execution_agent . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_started ( self , * , livecheck ) : [EOL] case1 = Mock ( name = [string] ) [EOL] case2 = Mock ( name = [string] ) [EOL] livecheck . cases = { [string] : case1 , [string] : case2 } [EOL] livecheck . add_runtime_dependency = AsyncMock ( ) [EOL] [EOL] await livecheck . on_started ( ) [EOL] [EOL] livecheck . add_runtime_dependency . assert_has_calls ( [ call . coro ( case1 ) , call . coro ( case2 ) , ] ) [EOL] [EOL] def test__install_bus_agent ( self , * , livecheck ) : [EOL] livecheck . agent = Mock ( ) [EOL] ag = livecheck . _install_bus_agent ( ) [EOL] assert ag is livecheck . agent . return_value . return_value [EOL] livecheck . agent . assert_called_once_with ( channel = livecheck . bus , concurrency = livecheck . bus_concurrency , ) [EOL] [EOL] def test__install_test_execution_agent ( self , * , livecheck ) : [EOL] livecheck . agent = Mock ( ) [EOL] ag = livecheck . _install_test_execution_agent ( ) [EOL] assert ag is livecheck . agent . return_value . return_value [EOL] livecheck . agent . assert_called_once_with ( channel = livecheck . pending_tests , concurrency = livecheck . test_concurrency , ) [EOL] [EOL] @ pytest . mark . asyncio async def test__populate_signals ( self , * , livecheck , execution ) : [EOL] events = Mock ( ) [EOL] signal = SignalEvent ( signal_name = [string] , case_name = execution . case_name , key = [string] , value = [string] , ) [EOL] signal2 = SignalEvent ( signal_name = [string] , case_name = [string] , key = [string] , value = [string] , ) [EOL] case = livecheck . cases [ execution . case_name ] = Mock ( resolve_signal = AsyncMock ( ) , ) [EOL] livecheck . cases . pop ( [string] , None ) [comment] [EOL] [EOL] async def iterate_events ( ) : [EOL] yield execution . id , signal [EOL] yield execution . id , signal2 [EOL] [EOL] events . items . side_effect = iterate_events [EOL] [EOL] await livecheck . _populate_signals ( events ) [EOL] case . resolve_signal . assert_called_once_with ( execution . id , signal ) [EOL] [EOL] @ pytest . mark . asyncio async def test__excecute_tests ( self , * , livecheck , execution ) : [EOL] tests = Mock ( ) [EOL] [EOL] execution2 = execution . derive ( case_name = [string] ) [EOL] [EOL] async def iterate_tests ( ) : [EOL] yield execution . id , execution [EOL] yield execution . id , execution2 [EOL] [EOL] tests . items . side_effect = iterate_tests [EOL] [EOL] case = livecheck . cases [ execution . case_name ] = Mock ( execute = AsyncMock ( ) , ) [EOL] livecheck . cases . pop ( [string] , None ) [comment] [EOL] [EOL] await livecheck . _execute_tests ( tests ) [EOL] case . execute . assert_called_once_with ( execution ) [EOL] [EOL] @ pytest . mark . asyncio async def test__excecute_tests__raises ( self , * , livecheck , execution ) : [EOL] tests = Mock ( ) [EOL] [EOL] async def iterate_tests ( ) : [EOL] yield execution . id , execution [EOL] [EOL] tests . items . side_effect = iterate_tests [EOL] [EOL] case = livecheck . cases [ execution . case_name ] = Mock ( execute = AsyncMock ( side_effect = TestFailed ( ) ) , ) [EOL] [EOL] await livecheck . _execute_tests ( tests ) [EOL] case . execute . assert_called_once_with ( execution ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ] ) def test_prepare_case_name ( self , name , origin , expected , * , livecheck ) : [EOL] livecheck . conf . origin = origin [EOL] assert livecheck . _prepare_case_name ( name ) == expected [EOL] [EOL] def test_prepare_case_name__no_origin ( self , * , livecheck ) : [EOL] livecheck . conf . origin = None [EOL] with pytest . raises ( RuntimeError ) : [EOL] livecheck . _prepare_case_name ( [string] ) [EOL] [EOL] def test_bus ( self , * , livecheck ) : [EOL] livecheck . topic = Mock ( ) [EOL] assert livecheck . bus is livecheck . topic . return_value [EOL] livecheck . topic . assert_called_once_with ( livecheck . bus_topic_name , key_type = str , value_type = SignalEvent , ) [EOL] [EOL] def test_pending_tests ( self , * , livecheck ) : [EOL] livecheck . topic = Mock ( ) [EOL] assert livecheck . pending_tests is livecheck . topic . return_value [EOL] livecheck . topic . assert_called_once_with ( livecheck . test_topic_name , key_type = str , value_type = TestExecution , ) [EOL] [EOL] def test_reports ( self , * , livecheck ) : [EOL] livecheck . topic = Mock ( ) [EOL] assert livecheck . reports is livecheck . topic . return_value [EOL] livecheck . topic . assert_called_once_with ( livecheck . report_topic_name , key_type = str , value_type = TestReport , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bytes]]$ 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bytes]]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.bytes]]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bytes]]$ 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bytes]]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[t.unit.livecheck.test_app.test_LiveCheck.test_case_decorator.SignalWithNoneOrigin]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Signal$ 0 0 0 $t.unit.livecheck.test_app.test_LiveCheck.test_case_decorator.SignalWithNoneOrigin$ 0 0 0 $Signal$ 0 0 0 0 0 0 0 $typing.Union[builtins.str,builtins.int]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import faust [EOL] import typing [EOL] from contextlib import contextmanager [EOL] from collections import deque [EOL] from datetime import datetime , timedelta , timezone [EOL] from statistics import median [EOL] import pytest [EOL] from mode import label [EOL] from mode . utils . mocks import ANY , AsyncMock , Mock , patch [EOL] from faust . livecheck import Case [EOL] from faust . livecheck . exceptions import SuiteFailed [EOL] from faust . livecheck . models import State , TestReport [EOL] [EOL] [EOL] class test_Case : [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , False , False ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , timedelta ( seconds = [number] ) ) , ( [string] , [number] , [number] ) , ( [string] , True , True ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ] ) def test_constructor ( self , arg , value , expected , * , livecheck ) : [EOL] kwargs = { [string] : livecheck , [string] : [string] } [EOL] case = Case ( ** { arg : value } , ** kwargs ) [EOL] assert getattr ( case , arg ) == expected [EOL] [EOL] @ pytest . mark . asyncio async def test__sampler ( self , * , case ) : [EOL] case . _sample = AsyncMock ( ) [EOL] case . sleep = AsyncMock ( ) [EOL] [EOL] def on_sample ( ) : [EOL] if case . _sample . call_count == [number] : [EOL] case . _stopped . set ( ) [EOL] case . _sample . coro . side_effect = on_sample [EOL] [EOL] await case . _sampler ( case ) [EOL] [EOL] assert case . _sample . call_count == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test__sample ( self , * , case ) : [EOL] await case . _sample ( ) [EOL] [EOL] case . frequency_history . extend ( range ( [number] ) ) [EOL] case . latency_history . extend ( range ( [number] , [number] ) ) [EOL] case . runtime_history . extend ( range ( [number] , [number] ) ) [EOL] [EOL] await case . _sample ( ) [EOL] [EOL] assert case . frequency_avg == median ( case . frequency_history ) [EOL] assert case . latency_avg == median ( case . latency_history ) [EOL] assert case . runtime_avg == median ( case . runtime_history ) [EOL] [EOL] @ pytest . mark . asyncio async def test_maybe_trigger ( self , * , case ) : [EOL] case . trigger = AsyncMock ( [string] ) [EOL] [EOL] with patch ( [string] ) : [EOL] with patch ( [string] ) as uniform : [EOL] uniform . return_value = [number] [EOL] async with case . maybe_trigger ( ) as test : [EOL] assert test is None [EOL] case . trigger . assert_not_called ( ) [EOL] [EOL] uniform . return_value = [number] [EOL] async with case . maybe_trigger ( ) as test : [EOL] assert test is case . trigger . coro . return_value [EOL] assert case . current_test is test [EOL] [EOL] @ pytest . mark . asyncio async def test_run ( self , * , case ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await Case . run ( case ) [EOL] [EOL] @ pytest . mark . asyncio async def test_trigger ( self , * , case ) : [EOL] case . app = Mock ( pending_tests = Mock ( send = AsyncMock ( ) ) ) [EOL] t = await case . trigger ( [string] , [number] , kw = [number] ) [EOL] assert t . id == [string] [EOL] case . app . pending_tests . send . coro . assert_called_once_with ( key = [string] , value = t , ) [EOL] [EOL] def test_now ( self , * , case ) : [EOL] assert isinstance ( case . _now ( ) , datetime ) [EOL] assert case . _now ( ) . tzinfo == timezone . utc [EOL] [EOL] @ pytest . mark . asyncio async def test_resolve_signal ( self , * , case ) : [EOL] key = [string] [EOL] event = Mock ( name = [string] ) [EOL] case . signals [ event . signal_name ] = Mock ( resolve = AsyncMock ( ) ) [EOL] await case . resolve_signal ( key , event ) [EOL] case . signals [ event . signal_name ] . resolve . coro . assert_called_once_with ( key , event , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_execute ( self , * , case , execution , current_execution_stack , frozen_monotonic ) : [EOL] case . Runner = Mock ( name = [string] ) [EOL] runner = case . Runner . return_value [EOL] runner . execute = AsyncMock ( name = [string] ) [EOL] await case . execute ( execution ) [EOL] [EOL] case . Runner . assert_called_once_with ( case , execution , started = frozen_monotonic . return_value ) [EOL] runner . execute . coro . assert_called_once_with ( ) [EOL] current_execution_stack . push . assert_called_once_with ( runner ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( [number] , None , None ) , ( [number] , [number] , [number] ) , ( [number] , [number] , None ) , ] ) async def test_on_test_start ( self , started , last_received , frequency , * , case , runner ) : [EOL] case . latency_history = deque ( [ [number] ] * case . max_history ) [EOL] case . frequency_history = deque ( [ [number] ] * case . max_history ) [EOL] runner . started = started [EOL] case . frequency = frequency [EOL] case . last_test_received = last_received [EOL] [EOL] await case . on_test_start ( runner ) [EOL] [EOL] if last_received : [EOL] time_since = started - last_received [EOL] if frequency : [EOL] latency = time_since - frequency [EOL] assert case . latency_history [ - [number] ] == latency [EOL] assert len ( case . latency_history ) == case . max_history [EOL] assert case . frequency_history [ - [number] ] == time_since [EOL] assert len ( case . frequency_history ) == case . max_history [EOL] [EOL] @ pytest . yield_fixture ( ) def frozen_monotonic ( self ) : [EOL] with self . _patch_monotonic ( ) as monotonic : [EOL] yield monotonic [EOL] [EOL] def _patch_monotonic ( self ) : [EOL] return patch ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_test_skipped ( self , * , case , runner , frozen_monotonic ) : [EOL] await case . on_test_skipped ( runner ) [EOL] assert case . last_test_received is frozen_monotonic . return_value [EOL] [EOL] @ pytest . mark . asyncio async def test_on_test_failed ( self , * , case , runner ) : [EOL] case . _set_test_error_state = AsyncMock ( ) [EOL] await case . on_test_failed ( runner , KeyError ( ) ) [EOL] case . _set_test_error_state . coro . assert_called_once_with ( State . FAIL ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_test_error ( self , * , case , runner ) : [EOL] case . _set_test_error_state = AsyncMock ( ) [EOL] await case . on_test_error ( runner , KeyError ( ) ) [EOL] case . _set_test_error_state . coro . assert_called_once_with ( State . ERROR ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_test_timeout ( self , * , case , runner ) : [EOL] case . _set_test_error_state = AsyncMock ( ) [EOL] await case . on_test_timeout ( runner , KeyError ( ) ) [EOL] case . _set_test_error_state . coro . assert_called_once_with ( State . TIMEOUT ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( State . FAIL , [number] , False ) , ( State . FAIL , [number] , True ) , ( State . ERROR , [number] , False ) , ( State . ERROR , [number] , True ) , ( State . STALL , [number] , False ) , ( State . STALL , [number] , True ) , ] ) async def test__set_test_error_state ( self , state , failures , fail_suite , * , case ) : [EOL] case . max_consecutive_failures = [number] [EOL] case . consecutive_failures = failures [EOL] case . on_suite_fail = AsyncMock ( ) [EOL] await case . _set_test_error_state ( state ) [EOL] assert case . status == state [EOL] assert case . consecutive_failures == failures + [number] [EOL] assert case . total_failures == [number] [EOL] assert case . total_by_state [ state ] == [number] [EOL] if fail_suite : [EOL] case . on_suite_fail . coro . assert_called_once_with ( ANY ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( State . INIT , [number] , [number] , None , State . PASS ) , ( State . PASS , [number] , [number] , [number] , State . PASS ) , ( State . FAIL , [number] , [number] , [number] , State . FAIL ) , ( State . FAIL , [number] , [number] , None , State . PASS ) , ( State . FAIL , [number] , [number] , [number] , State . PASS ) , ( State . FAIL , [number] , [number] , [number] , State . FAIL ) , ] ) async def test_on_suite_pass ( self , initial_state , ts , now , failed , expected_state , * , case , runner , execution ) : [EOL] assert runner . test is execution [EOL] runner . test . timestamp = Mock ( ) [EOL] runner . test . timestamp . timestamp . return_value = ts [EOL] case . runtime_history = deque ( [ [number] ] * case . max_history ) [EOL] runner . runtime = [number] [EOL] with self . seconds_since_last_fail ( case , now = now , failed = failed ) : [EOL] case . status = initial_state [EOL] await case . on_test_pass ( runner ) [EOL] assert case . status == expected_state [EOL] assert len ( case . runtime_history ) == case . max_history [EOL] assert case . runtime_history [ - [number] ] == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_post_report ( self , * , case ) : [EOL] report = Mock ( ) [EOL] case . app . post_report = AsyncMock ( ) [EOL] await case . post_report ( report ) [EOL] case . app . post_report . assert_called_once_with ( report ) [EOL] [EOL] @ pytest . mark . asyncio async def test__send_frequency__first_stop ( self , * , case , loop ) : [EOL] case . frequency = [number] [EOL] case . sleep = AsyncMock ( ) [EOL] with patch ( [string] ) as ti : [EOL] [EOL] async def on_itertimer ( * args , ** kwargs ) : [EOL] case . _stopped . set ( ) [EOL] yield [number] [EOL] yield [number] [EOL] yield [number] [EOL] yield [number] [EOL] ti . side_effect = on_itertimer [EOL] [EOL] await case . _send_frequency ( case ) [EOL] [EOL] @ pytest . mark . asyncio async def test__send_frequency__no_frequency ( self , * , case , loop ) : [EOL] case . frequency = [number] [EOL] case . sleep = AsyncMock ( ) [EOL] case . make_fake_request = AsyncMock ( ) [EOL] with patch ( [string] ) as ti : [EOL] [EOL] async def on_itertimer ( * args , ** kwargs ) : [EOL] case . _stopped . set ( ) [EOL] yield [number] [EOL] yield [number] [EOL] yield [number] [EOL] yield [number] [EOL] ti . side_effect = on_itertimer [EOL] [EOL] await case . _send_frequency ( case ) [EOL] case . make_fake_request . assert_not_called ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test__send_frequency__last_stop ( self , * , case ) : [EOL] case . frequency = [number] [EOL] case . sleep = AsyncMock ( ) [EOL] case . app . is_leader = Mock ( return_value = False ) [EOL] with patch ( [string] ) as ti : [EOL] [EOL] async def on_itertimer ( * args , ** kwargs ) : [EOL] for val in [ [number] , [number] , [number] , [number] ] : [EOL] await case . sleep ( val ) [EOL] yield val [EOL] [EOL] ti . side_effect = on_itertimer [EOL] [EOL] async def on_sleep ( secs , ** kwargs ) : [EOL] if case . sleep . call_count >= [number] : [EOL] case . _stopped . set ( ) [EOL] case . sleep . side_effect = on_sleep [EOL] [EOL] await case . _send_frequency ( case ) [EOL] [EOL] @ pytest . mark . asyncio async def test__send_frequency__no_frequency_None ( self , * , case ) : [EOL] case . frequency = None [EOL] await case . _send_frequency ( case ) [EOL] [EOL] @ pytest . mark . asyncio async def test__send_frequency__timer_ends ( self , * , case ) : [EOL] case . sleep = AsyncMock ( ) [EOL] case . frequency = [number] [EOL] case . app . is_leader = Mock ( return_value = False ) [EOL] with patch ( [string] ) as ti : [EOL] async def on_itertimer ( * args , ** kwargs ) : [EOL] for val in [ [number] , [number] , [number] , [number] ] : [EOL] yield val [EOL] ti . side_effect = on_itertimer [EOL] await case . _send_frequency ( case ) [EOL] [EOL] @ pytest . mark . asyncio async def test__send_frequency ( self , * , case ) : [EOL] case . frequency = [number] [EOL] case . make_fake_request = AsyncMock ( ) [EOL] case . sleep = AsyncMock ( ) [EOL] case . app . is_leader = Mock ( return_value = False ) [EOL] [EOL] def on_make_fake_request ( ) : [EOL] if case . make_fake_request . call_count == [number] : [EOL] case . _stopped . set ( ) [EOL] case . make_fake_request . coro . side_effect = on_make_fake_request [EOL] [EOL] def on_is_leader ( ) : [EOL] if case . app . is_leader . call_count >= [number] : [EOL] return True [EOL] case . app . is_leader . side_effect = on_is_leader [EOL] [EOL] await case . _send_frequency ( case ) [EOL] [EOL] assert case . make_fake_request . call_count == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test__check_frequency ( self , * , case ) : [EOL] with patch ( [string] ) as ti : [EOL] [EOL] async def on_itertimer ( * args , ** kwargs ) : [EOL] for val in [ [number] , [number] , [number] , [number] , [number] ] : [EOL] yield val [EOL] ti . side_effect = on_itertimer [EOL] case . sleep = AsyncMock ( ) [EOL] await case . _check_frequency ( case ) [EOL] [EOL] @ pytest . mark . asyncio async def test__check_frequency__last ( self , * , case , frozen_monotonic ) : [EOL] frozen_monotonic . return_value = [number] [EOL] case . warn_stalled_after = [number] [EOL] case . on_suite_fail = AsyncMock ( ) [EOL] with patch ( [string] ) as ti : [EOL] [EOL] async def on_itertimer ( * args , ** kwargs ) : [EOL] case . last_test_received = [number] [EOL] for val in [ [number] , [number] , [number] , [number] , [number] ] : [EOL] yield val [EOL] ti . side_effect = on_itertimer [EOL] case . sleep = AsyncMock ( ) [EOL] [EOL] await case . _check_frequency ( case ) [EOL] case . on_suite_fail . assert_called_once_with ( ANY , State . STALL ) [EOL] [EOL] @ pytest . mark . asyncio async def test__check_frequency__should_stop1 ( self , * , case ) : [EOL] with patch ( [string] ) as ti : [EOL] [EOL] async def on_itertimer ( * args , ** kwargs ) : [EOL] case . _stopped . set ( ) [EOL] yield [number] [EOL] yield [number] [EOL] yield [number] [EOL] yield [number] [EOL] yield [number] [EOL] ti . side_effect = on_itertimer [EOL] [EOL] case . sleep = AsyncMock ( ) [EOL] await case . _check_frequency ( case ) [EOL] [EOL] @ pytest . mark . asyncio async def test__check_frequency__last_stop ( self , * , case ) : [EOL] with patch ( [string] ) as ti : [EOL] case . _stopped . clear ( ) [EOL] assert not case . should_stop [EOL] [EOL] async def on_itertimer ( * args , ** kwargs ) : [EOL] for val in [ [number] , [number] , [number] , [number] , [number] ] : [EOL] await case . sleep ( val ) [EOL] yield val [EOL] ti . side_effect = on_itertimer [EOL] case . sleep = AsyncMock ( ) [EOL] [EOL] async def on_sleep ( arg , ** kwargs ) : [EOL] if case . sleep . call_count >= [number] : [EOL] case . _stopped . set ( ) [EOL] case . sleep . side_effect = on_sleep [EOL] [EOL] await case . _check_frequency ( case ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( State . PASS , [number] , [number] , True ) , ( State . PASS , [number] , [number] , False ) , ( State . FAIL , [number] , [number] , False ) , ( State . FAIL , [number] , [number] , True ) , ( State . TIMEOUT , [number] , [number] , False ) , ( State . TIMEOUT , [number] , [number] , True ) , ] ) async def test_on_suite_fail ( self , initial_state , now , failed , posts_report , * , case ) : [EOL] case . log = Mock ( ) [EOL] case . post_report = AsyncMock ( ) [EOL] exc = None [EOL] try : [EOL] raise SuiteFailed ( [string] ) [EOL] except SuiteFailed as e : [EOL] exc = e [EOL] with self . seconds_since_last_fail ( case , now = now , failed = failed ) : [EOL] case . status = initial_state [EOL] await case . on_suite_fail ( exc ) [EOL] assert case . status == State . FAIL [EOL] assert case . last_fail == now [EOL] if posts_report : [EOL] case . log . exception . assert_called_once_with ( str ( exc ) ) [EOL] case . post_report . coro . assert_called_once_with ( TestReport ( case_name = case . name , state = State . FAIL , test = None , runtime = None , signal_latency = { } , error = str ( exc ) , traceback = ANY , ) ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( State . INIT , [number] , None , State . PASS ) , ( State . PASS , [number] , [number] , State . PASS ) , ( State . FAIL , [number] , [number] , State . FAIL ) , ( State . FAIL , [number] , [number] , State . PASS ) , ] ) def test__maybe_recover_from_failed_state ( self , initial_state , now , failed , expected_state , * , case ) : [EOL] with self . seconds_since_last_fail ( case , now = now , failed = failed ) : [EOL] case . status = initial_state [EOL] case . _maybe_recover_from_failed_state ( ) [EOL] assert case . status == expected_state [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , False ) , ( [number] , None , [number] , True ) , ] ) def test_failed_longer_than ( self , now , failed , arg , expected , * , case ) : [EOL] with self . seconds_since_last_fail ( case , now = now , failed = failed ) : [EOL] assert case . _failed_longer_than ( arg ) == expected [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [number] , [number] , pytest . approx ( [number] ) ) , ( [number] , None , None ) , ) ) def test_seconds_since_last_fail ( self , now , failed , expected , * , case ) : [EOL] with self . seconds_since_last_fail ( case , now = now , failed = failed ) : [EOL] if expected is None : [EOL] assert case . seconds_since_last_fail is None [EOL] else : [EOL] assert case . seconds_since_last_fail == expected [EOL] [EOL] @ contextmanager def seconds_since_last_fail ( self , case , now , failed ) : [EOL] with self . _patch_monotonic ( ) as monotonic : [EOL] monotonic . return_value = now [EOL] case . last_fail = failed [EOL] yield [EOL] [EOL] @ pytest . mark . asyncio async def test_get_url ( self , * , case ) : [EOL] url = [string] [EOL] await self . assert_url_called ( case , case . get_url ( url , kw = [number] ) , [string] , url , kw = [number] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_post_url ( self , * , case ) : [EOL] url = [string] [EOL] await self . assert_url_called ( case , case . post_url ( url , kw = [number] ) , [string] , url , kw = [number] ) [EOL] [EOL] async def assert_url_called ( self , case , fut , method , url , ** kwargs ) : [EOL] case . url_request = AsyncMock ( [string] ) [EOL] response = await fut [EOL] assert response is case . url_request . coro . return_value [EOL] case . url_request . coro . assert_called_once_with ( method , url , ** kwargs , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_url_request ( self , * , case , mock_http_client ) : [EOL] case . app . _http_client = mock_http_client [EOL] case . _maybe_recover_from_failed_state = Mock ( ) [EOL] await case . url_request ( [string] , [string] ) == [string] [EOL] case . _maybe_recover_from_failed_state . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . http_session ( status_code = [number] , max_failures = None ) async def test_url_request_fails ( self , * , case , mock_http_client ) : [EOL] case . on_suite_fail = AsyncMock ( ) [EOL] case . sleep = AsyncMock ( ) [EOL] case . app . _http_client = mock_http_client [EOL] await case . url_request ( [string] , [string] ) is None [EOL] case . on_suite_fail . assert_called_once_with ( ANY ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . http_session ( status_code = [number] , max_failures = [number] ) async def test_url_request_fails_recover ( self , * , case , mock_http_client ) : [EOL] case . sleep = AsyncMock ( ) [EOL] case . app . _http_client = mock_http_client [EOL] await case . url_request ( [string] , [string] ) == [string] [EOL] [EOL] def test_current_test ( self , * , case ) : [EOL] with patch ( [string] ) as cts : [EOL] assert case . current_test is cts . top [EOL] [EOL] def test_current_execution ( self , * , case ) : [EOL] with patch ( [string] ) as ces : [EOL] assert case . current_execution is ces . top [EOL] [EOL] def test_label ( self , * , case ) : [EOL] assert label ( case ) == case . label [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $faust.livecheck.case.Case$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $faust.livecheck.case.Case$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.livecheck.exceptions.SuiteFailed$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.livecheck.exceptions.SuiteFailed$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.livecheck.exceptions.SuiteFailed$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.livecheck.exceptions.SuiteFailed$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.livecheck.exceptions.SuiteFailed$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from faust . fixups import fixups [EOL] from faust . fixups . django import Fixup [EOL] from mode . utils . mocks import Mock , mask_module , patch_module [EOL] [EOL] [EOL] class test_Fixup : [EOL] [EOL] @ pytest . fixture ( ) def fixup ( self , * , app ) : [EOL] return Fixup ( app ) [EOL] [EOL] def test_fixup_env_enabled ( self , * , app , fixup , monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] with patch_module ( [string] ) : [EOL] assert fixup . enabled ( ) [EOL] assert any ( isinstance ( f , Fixup ) for f in fixups ( app ) ) [EOL] [EOL] def test_fixup_env_enabled_no_django ( self , * , app , fixup , monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] with mask_module ( [string] ) : [EOL] with pytest . warns ( UserWarning ) : [EOL] assert not fixup . enabled ( ) [EOL] assert not any ( isinstance ( f , Fixup ) for f in fixups ( app ) ) [EOL] [EOL] def test_fixup_env_disabled ( self , * , app , fixup , monkeypatch ) : [EOL] monkeypatch . delenv ( [string] , raising = False ) [EOL] assert not fixup . enabled ( ) [EOL] assert not any ( isinstance ( f , Fixup ) for f in fixups ( app ) ) [EOL] [EOL] def test_wait_for_django_calls_django_setup ( self , * , fixup , monkeypatch ) : [EOL] with patch_module ( [string] , [string] , [string] ) : [EOL] import django [EOL] from django . conf import settings [EOL] settings . configure ( ) [EOL] settings . DEBUG = False [EOL] fixup . wait_for_django ( ) [EOL] django . setup . assert_called_once_with ( ) [EOL] settings . DEBUG = True [EOL] with pytest . warns ( UserWarning ) : [EOL] fixup . wait_for_django ( ) [EOL] [EOL] def test_autodiscover_modules ( self , * , fixup ) : [EOL] with patch_module ( [string] , [string] , [string] , [string] ) : [EOL] from django . apps import apps [EOL] config1 = Mock ( ) [EOL] config1 . name = [string] [EOL] config2 = Mock ( ) [EOL] config2 . name = [string] [EOL] apps . get_app_configs . return_value = [ config1 , config2 ] [EOL] [EOL] assert fixup . autodiscover_modules ( ) == [ [string] , [string] ] [EOL] [EOL] def test_on_worker_init ( self , * , fixup ) : [EOL] with patch_module ( [string] , [string] , [string] , [string] ) : [EOL] import django [EOL] from django . conf import settings [EOL] from django . core . checks import run_checks [EOL] [EOL] settings . DEBUG = False [EOL] fixup . on_worker_init ( ) [EOL] django . setup . assert_called_once_with ( ) [EOL] run_checks . assert_called_once_with ( ) [EOL] [EOL] settings . DEBUG = True [EOL] with pytest . warns ( UserWarning ) : [EOL] fixup . on_worker_init ( ) [EOL] [EOL] def test_apps ( self , * , fixup ) : [EOL] with patch_module ( [string] , [string] ) : [EOL] from django . apps import apps [EOL] assert fixup . apps is apps [EOL] [EOL] def test_settings ( self , * , fixup ) : [EOL] with patch_module ( [string] , [string] ) : [EOL] from django . conf import settings [EOL] assert fixup . settings is settings [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from faust . fixups . base import Fixup [EOL] [EOL] [EOL] class test_Fixup : [EOL] [EOL] def test_init ( self , * , app ) : [EOL] assert Fixup ( app ) . app is app [EOL] [EOL] def test_enabled ( self , * , app ) : [EOL] assert not Fixup ( app ) . enabled ( ) [EOL] [EOL] def test_autodiscover_modules ( self , * , app ) : [EOL] assert Fixup ( app ) . autodiscover_modules ( ) == [ ] [EOL] [EOL] def test_on_worker_init ( self , * , app ) : [EOL] Fixup ( app ) . on_worker_init ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , List [EOL] import decimal [EOL] import faust [EOL] import typing [EOL] import builtins [EOL] from decimal import Decimal [EOL] import pytest [EOL] from mode . utils . mocks import Mock [EOL] from faust import Record [EOL] from faust . exceptions import ValidationError [EOL] from faust . models . fields import ( BooleanField , BytesField , DecimalField , FieldDescriptor , ) [EOL] [EOL] [EOL] class X ( Record ) : [EOL] foo = ... [EOL] [EOL] [EOL] class test_ValidationError : [EOL] [EOL] @ pytest . fixture ( ) def field ( self ) : [EOL] return DecimalField ( model = X , field = [string] ) [EOL] [EOL] @ pytest . fixture ( ) def error ( self , * , field ) : [EOL] return ValidationError ( [string] , field = field ) [EOL] [EOL] def test_repr ( self , * , error ) : [EOL] assert repr ( error ) [EOL] [EOL] def test_str ( self , * , error ) : [EOL] assert str ( error ) [EOL] [EOL] [EOL] class test_FieldDescriptor : [EOL] [EOL] def test_validate ( self ) : [EOL] f = FieldDescriptor ( ) [EOL] assert list ( f . validate ( [string] ) ) == [ ] [EOL] [EOL] [EOL] class test_BooleanField : [EOL] [EOL] @ pytest . fixture ( ) def model ( self ) : [EOL] model = Mock ( name = [string] ) [EOL] model . __name__ = [string] [EOL] return model [EOL] [EOL] @ pytest . fixture ( ) def field ( self , * , model ) : [EOL] return self . _new_field ( model , required = True ) [EOL] [EOL] def _new_field ( self , model , required , ** kwargs ) : [EOL] return BooleanField ( field = [string] , type = bool , required = True , model = model , coerce = True , ** kwargs , ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ True , False , ] ) def test_validate_bool ( self , value , * , field ) : [EOL] assert not list ( field . validate ( value ) ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , None , [number] , [number] , object , ] ) def test_validate_other ( self , value , * , field ) : [EOL] errors = list ( field . validate ( value ) ) [EOL] assert errors [EOL] assert str ( errors [ [number] ] ) . startswith ( [string] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , False ) , ( [string] , True ) , ( [number] , False ) , ( [number] , True ) , ( [number] , True ) , ( object ( ) , True ) , ( None , False ) , ( { } , False ) , ( [ ] , False ) , ( [ [number] ] , True ) , ] ) def test_prepare_value__when_coerce ( self , value , expected , * , field ) : [EOL] assert field . prepare_value ( value ) is expected [EOL] [EOL] def test_prepare_value__no_coerce ( self , * , field ) : [EOL] assert field . prepare_value ( None , coerce = False ) is None [EOL] [EOL] [EOL] class test_DecimalField : [EOL] [EOL] def test_init_options ( self ) : [EOL] assert DecimalField ( max_digits = [number] ) . max_digits == [number] [EOL] assert DecimalField ( max_decimal_places = [number] ) . max_decimal_places == [number] [EOL] [EOL] f = DecimalField ( max_digits = [number] , max_decimal_places = [number] ) [EOL] f2 = f . clone ( ) [EOL] assert f2 . max_digits == [number] [EOL] assert f2 . max_decimal_places == [number] [EOL] [EOL] f3 = DecimalField ( ) [EOL] assert f3 . max_digits is None [EOL] assert f3 . max_decimal_places is None [EOL] f4 = f3 . clone ( ) [EOL] assert f4 . max_digits is None [EOL] assert f4 . max_decimal_places is None [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Decimal ( [string] ) , Decimal ( [string] ) , Decimal ( [string] ) , ] ) def test_infinite ( self , value ) : [EOL] f = DecimalField ( coerce = True , field = [string] ) [EOL] with pytest . raises ( ValidationError ) : [EOL] raise next ( f . validate ( value ) ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Decimal ( [number] ) , [number] , [number] ) , ( Decimal ( [number] ) , [number] , [number] ) , ( Decimal ( [number] ) , None , [number] ) , ( Decimal ( [number] ) , [number] , None ) , ( Decimal ( [number] ) , [number] , None ) , ( [number] , [number] , [number] ) , ( Decimal ( [number] ) , [number] , [number] ) , ( Decimal ( [number] ) , [number] , [number] ) , ] ) def test_max_decimal_places__good ( self , value , places , digits ) : [EOL] f = DecimalField ( max_decimal_places = places , max_digits = digits , coerce = True , field = [string] , ) [EOL] d = f . prepare_value ( value ) [EOL] for error in f . validate ( d ) : [EOL] raise error [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Decimal ( [number] ) , Decimal ( [number] ) , Decimal ( [number] ) , ] ) def test_max_decimal_places__bad ( self , value ) : [EOL] f = DecimalField ( max_decimal_places = [number] , coerce = True , field = [string] ) [EOL] with pytest . raises ( ValidationError ) : [EOL] raise next ( f . validate ( value ) ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Decimal ( [number] ) , Decimal ( [number] ) , Decimal ( [number] ) , ] ) def test_max_digits__bad ( self , value ) : [EOL] f = DecimalField ( max_digits = [number] , coerce = True , field = [string] ) [EOL] with pytest . raises ( ValidationError ) : [EOL] raise next ( f . validate ( value ) ) [EOL] [EOL] [EOL] class test_BytesField : [EOL] [EOL] def test_init_options ( self ) : [EOL] assert BytesField ( encoding = [string] ) . encoding == [string] [EOL] assert BytesField ( errors = [string] ) . errors == [string] [EOL] [EOL] f = BytesField ( encoding = [string] , errors = [string] ) [EOL] f2 = f . clone ( ) [EOL] assert f2 . encoding == [string] [EOL] assert f2 . errors == [string] [EOL] [EOL] f3 = BytesField ( ) [EOL] assert f3 . encoding == [string] [EOL] assert f3 . errors == [string] [EOL] f4 = f3 . clone ( ) [EOL] assert f4 . encoding == [string] [EOL] assert f4 . errors == [string] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , True , False , [string] ) , ( [string] , True , False , [string] ) , ( [string] , False , False , [string] ) , ( [string] , True , True , [string] ) , ( [string] , True , True , [string] ) , ( [string] , True , False , [string] ) , ] ) def test_prepare_value ( self , value , coerce , trim , expected_result ) : [EOL] f = BytesField ( coerce = coerce , trim_whitespace = trim ) [EOL] assert f . prepare_value ( value ) == expected_result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.FieldDescriptor[typing.Any]$ 0 0 0 0 0 0 0 0 $faust.models.fields.FieldDescriptor[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.BooleanField$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.DecimalField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.DecimalField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.DecimalField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 $faust.models.fields.DecimalField$ 0 0 0 0 0 0 0 0 0 $faust.models.fields.DecimalField$ 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.DecimalField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.DecimalField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.DecimalField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.DecimalField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.BytesField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.models.fields.BytesField$ 0 0 0 0 0 0 0 0
import pytest [EOL] from faust . exceptions import SecurityError [EOL] from faust . models . tags import Secret , Sensitive [EOL] [EOL] [EOL] class test_Sensitive : [EOL] [EOL] @ pytest . fixture def typ ( self ) : [EOL] return Sensitive [ str ] [EOL] [EOL] @ pytest . fixture def v ( self , * , typ ) : [EOL] return typ ( [string] ) [EOL] [EOL] def test_repr ( self , * , v ) : [EOL] assert repr ( v ) [EOL] assert [string] not in repr ( v ) [EOL] [EOL] def test_str ( self , * , v ) : [EOL] with pytest . raises ( SecurityError ) : [EOL] str ( v ) [EOL] [EOL] def test_nested ( self , * , v , typ ) : [EOL] with pytest . raises ( SecurityError ) : [EOL] typ ( v ) [EOL] [EOL] [EOL] class test_Secret ( test_Sensitive ) : [EOL] [EOL] @ pytest . fixture def typ ( self ) : [EOL] return Secret [ str ] [EOL] [EOL] def test_str ( self , * , v ) : [EOL] assert str ( v ) == v . mask [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import faust [EOL] import typing [EOL] from faust . windows import TumblingWindow [EOL] [EOL] [EOL] class test_TumblingWindow : [EOL] [EOL] def test_tumbling_window_has_just_one_range ( self ) : [EOL] tumbling = TumblingWindow ( [number] ) [EOL] assert len ( tumbling . ranges ( [number] ) ) == [number] [EOL] assert len ( tumbling . ranges ( [number] ) ) == [number] [EOL] assert len ( tumbling . ranges ( [number] ) ) == [number] [EOL] [EOL] def test_end_range_in_tumbling_window_is_within_range ( self ) : [EOL] tumbling = TumblingWindow ( [number] ) [EOL] [EOL] [comment] [EOL] base_range = tumbling . ranges ( [number] ) [ [number] ] [EOL] base_range_end = base_range [ [number] ] [EOL] [EOL] compare_range = tumbling . ranges ( base_range_end ) [ [number] ] [EOL] [EOL] assert base_range [ [number] ] == compare_range [ [number] ] [EOL] assert base_range [ [number] ] == compare_range [ [number] ] [EOL] [EOL] def test_earliest_and_current_range_are_the_same ( self ) : [EOL] size = [number] [EOL] timestamp = [number] [EOL] window = TumblingWindow ( size ) [EOL] [EOL] assert window . current ( timestamp ) == window . earliest ( timestamp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.windows.TumblingWindow$ 0 0 0 0 0 0 0 0 0 $faust.windows.TumblingWindow$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.windows.TumblingWindow$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.windows.TumblingWindow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.windows.TumblingWindow$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 $faust.windows.TumblingWindow$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 $faust.windows.TumblingWindow$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $faust.windows.TumblingWindow$ 0 0 0 $builtins.int$ 0 0 0 0 $faust.windows.TumblingWindow$ 0 0 0 $builtins.int$ 0 0 $faust.windows.TumblingWindow$ 0 0 0 $builtins.int$ 0 0
from typing import Any , Type [EOL] import faust [EOL] import typing [EOL] import t [EOL] import builtins [EOL] import asyncio [EOL] import collections . abc [EOL] import pytest [EOL] from faust . agents import Agent [EOL] from faust . agents . actor import Actor , AsyncIterableActor , AwaitableActor [EOL] from faust . types import TP [EOL] from mode . utils . mocks import AsyncMock , Mock [EOL] [EOL] [EOL] class FakeActor ( Actor ) : [EOL] [comment] [EOL] [EOL] def traceback ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class test_Actor : [EOL] [EOL] ActorType = FakeActor [EOL] [EOL] @ pytest . fixture ( ) def agent ( self ) : [EOL] agent = Mock ( name = [string] , autospec = Agent ) [EOL] agent . name = [string] [EOL] return agent [EOL] [EOL] @ pytest . fixture ( ) def stream ( self ) : [EOL] stream = Mock ( name = [string] ) [EOL] stream . active_partitions = None [EOL] return stream [EOL] [EOL] @ pytest . fixture ( ) def it ( self ) : [EOL] it = Mock ( name = [string] , autospec = collections . abc . Iterator ) [EOL] it . __aiter__ = Mock ( name = [string] ) [EOL] it . __await__ = Mock ( name = [string] ) [EOL] return it [EOL] [EOL] @ pytest . fixture ( ) def actor ( self , * , agent , stream , it ) : [EOL] return self . ActorType ( agent , stream , it ) [EOL] [EOL] def test_constructor ( self , * , actor , agent , stream , it ) : [EOL] assert actor . agent is agent [EOL] assert actor . stream is stream [EOL] assert actor . it is it [EOL] assert actor . index is None [EOL] assert actor . active_partitions is None [EOL] assert actor . actor_task is None [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start ( self , * , actor ) : [EOL] actor . actor_task = Mock ( name = [string] , autospec = asyncio . Task ) [EOL] actor . add_future = Mock ( name = [string] ) [EOL] await actor . on_start ( ) [EOL] actor . add_future . assert_called_once_with ( actor . actor_task ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop ( self , * , actor ) : [EOL] actor . cancel = Mock ( name = [string] ) [EOL] await actor . on_stop ( ) [EOL] actor . cancel . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_isolated_partition_revoked ( self , * , actor ) : [EOL] actor . cancel = Mock ( name = [string] ) [EOL] actor . stop = AsyncMock ( name = [string] ) [EOL] await actor . on_isolated_partition_revoked ( TP ( [string] , [number] ) ) [EOL] actor . cancel . assert_called_once_with ( ) [EOL] actor . stop . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_isolated_partition_assigned ( self , * , actor ) : [EOL] await actor . on_isolated_partition_assigned ( TP ( [string] , [number] ) ) [EOL] [EOL] def test_cancel ( self , * , actor ) : [EOL] actor . actor_task = Mock ( name = [string] , autospec = asyncio . Task ) [EOL] actor . cancel ( ) [EOL] actor . stream . channel . _throw . assert_called_once ( ) [EOL] actor . stream . channel . _throw . call_args [ [number] ] [ [number] ] == StopAsyncIteration ( ) [EOL] [EOL] def test_cancel__when_no_task ( self , * , actor ) : [EOL] actor . actor_task = None [EOL] actor . cancel ( ) [EOL] [EOL] def test_repr ( self , * , actor ) : [EOL] assert repr ( actor ) [EOL] [EOL] [EOL] class test_AsyncIterableActor ( test_Actor ) : [EOL] [EOL] ActorType = AsyncIterableActor [EOL] [EOL] def test_aiter ( self , * , actor , it ) : [EOL] res = actor . __aiter__ ( ) [EOL] it . __aiter__ . assert_called_with ( ) [EOL] assert res is it . __aiter__ ( ) [EOL] [EOL] [EOL] class test_AwaitableActor ( test_Actor ) : [EOL] [EOL] ActorType = AwaitableActor [EOL] [EOL] def test_await ( self , * , actor , it ) : [EOL] res = actor . __await__ ( ) [EOL] it . __await__ . assert_called_with ( ) [EOL] assert res is it . __await__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[t.unit.agents.test_actor.FakeActor]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[faust.agents.actor.AsyncIterableActor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[faust.agents.actor.AwaitableActor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
	0
from typing import Tuple , Set , Any , Union , List [EOL] import faust [EOL] import typing [EOL] import t [EOL] import asyncio [EOL] [EOL] import faust [EOL] import pytest [EOL] from faust import App , Channel , Record [EOL] from faust . agents . actor import Actor [EOL] [EOL] from faust . agents . models import ( ModelReqRepRequest , ModelReqRepResponse , ReqRepRequest , ReqRepResponse , ) [EOL] from faust . agents . replies import ReplyConsumer [EOL] from faust . events import Event [EOL] from faust . exceptions import ImproperlyConfigured [EOL] from faust . types import Message , TP [EOL] from mode import SupervisorStrategy , label [EOL] from mode . utils . aiter import aiter [EOL] from mode . utils . futures import done_future [EOL] from mode . utils . logging import CompositeLogger [EOL] from mode . utils . mocks import ANY , AsyncMock , FutureMock , Mock , call , patch [EOL] from mode . utils . trees import Node [EOL] [EOL] [EOL] class Word ( Record ) : [EOL] word = ... [EOL] [EOL] [EOL] class test_AgentService : [EOL] [EOL] @ pytest . fixture def agent ( self , * , app ) : [EOL] [EOL] @ app . agent ( ) async def myagent ( stream ) : [EOL] async for value in stream : [EOL] yield value [EOL] [EOL] return myagent [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] , None ) , ( [number] , [number] , [number] ) , ] ) async def test_start_one ( self , concurrency , index , expected_index , * , agent ) : [EOL] agent . concurrency = concurrency [EOL] agent . _start_task = AsyncMock ( name = [string] ) [EOL] [EOL] tps = { TP ( [string] , [number] ) } [EOL] await agent . _start_one ( index = index , active_partitions = tps ) [EOL] agent . _start_task . assert_called_once_with ( index = expected_index , active_partitions = tps , stream = None , channel = None , beacon = agent . beacon , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_start_for_partitions ( self , * , agent ) : [EOL] agent . _start_one_supervised = AsyncMock ( name = [string] ) [EOL] s = agent . _start_one_supervised . return_value = Mock ( name = [string] ) [EOL] s . maybe_start = AsyncMock ( name = [string] ) [EOL] tps = { TP ( [string] , [number] ) } [EOL] await agent . _start_for_partitions ( tps ) [EOL] agent . _start_one_supervised . assert_called_once_with ( None , tps ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start ( self , * , agent ) : [EOL] agent . _new_supervisor = Mock ( name = [string] ) [EOL] agent . _on_start_supervisor = AsyncMock ( name = [string] ) [EOL] await agent . on_start ( ) [EOL] [EOL] agent . _new_supervisor . assert_called_once_with ( ) [EOL] assert agent . supervisor is agent . _new_supervisor ( ) [EOL] agent . _on_start_supervisor . assert_called_once_with ( ) [EOL] [EOL] def test_new_supervisor ( self , * , agent ) : [EOL] strategy = agent . _get_supervisor_strategy = Mock ( name = [string] ) [EOL] s = agent . _new_supervisor ( ) [EOL] strategy . assert_called_once_with ( ) [EOL] strategy . return_value . assert_called_once_with ( max_restarts = [number] , over = [number] , replacement = agent . _replace_actor , loop = agent . loop , beacon = agent . beacon , ) [EOL] assert s is strategy ( ) ( ) [EOL] [EOL] def test_get_supervisor_strategy ( self , * , agent ) : [EOL] agent . supervisor_strategy = [number] [EOL] assert agent . _get_supervisor_strategy ( ) == [number] [EOL] agent . supervisor_strategy = None [EOL] agent . app = Mock ( name = [string] , autospec = App ) [EOL] assert ( agent . _get_supervisor_strategy ( ) is agent . app . conf . agent_supervisor ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start_supervisor ( self , * , agent ) : [EOL] agent . concurrency = [number] [EOL] agent . _get_active_partitions = Mock ( name = [string] ) [EOL] agent . _start_one = AsyncMock ( name = [string] ) [EOL] agent . supervisor = Mock ( name = [string] , autospec = SupervisorStrategy , start = AsyncMock ( ) , ) [EOL] await agent . _on_start_supervisor ( ) [EOL] [EOL] aref = agent . _start_one . coro . return_value [EOL] [EOL] agent . _start_one . coro . assert_has_calls ( [ call ( index = i , channel = aref . stream . channel if i else None , active_partitions = agent . _get_active_partitions ( ) ) for i in range ( [number] ) ] ) [EOL] agent . supervisor . add . assert_has_calls ( [ call ( agent . _start_one . coro ( ) ) for i in range ( [number] ) ] ) [EOL] agent . supervisor . start . assert_called_once_with ( ) [EOL] [EOL] def test_get_active_partitions ( self , * , agent ) : [EOL] agent . isolated_partitions = None [EOL] assert agent . _get_active_partitions ( ) is None [EOL] agent . isolated_partitions = True [EOL] assert agent . _get_active_partitions ( ) == set ( ) [EOL] assert agent . _pending_active_partitions == set ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_replace_actor ( self , * , agent ) : [EOL] aref = Mock ( name = [string] , autospec = Actor ) [EOL] agent . _start_one = AsyncMock ( name = [string] ) [EOL] assert ( await agent . _replace_actor ( aref , [number] ) == agent . _start_one . coro ( ) ) [EOL] agent . _start_one . assert_called_once_with ( index = [number] , active_partitions = aref . active_partitions , stream = aref . stream , channel = aref . stream . channel , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop ( self , * , agent ) : [EOL] agent . _stop_supervisor = AsyncMock ( name = [string] ) [EOL] await agent . on_stop ( ) [EOL] agent . _stop_supervisor . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_stop_supervisor ( self , * , agent ) : [EOL] supervisor = agent . supervisor = Mock ( name = [string] , autospec = SupervisorStrategy , stop = AsyncMock ( ) , ) [EOL] await agent . _stop_supervisor ( ) [EOL] assert agent . supervisor is None [EOL] await agent . _stop_supervisor ( ) [EOL] supervisor . stop . assert_called_once_with ( ) [EOL] [EOL] def test_label ( self , * , agent ) : [EOL] assert label ( agent ) [EOL] [EOL] [EOL] class test_Agent : [EOL] [EOL] @ pytest . fixture def agent ( self , * , app ) : [EOL] [EOL] @ app . agent ( ) async def myagent ( stream ) : [EOL] async for value in stream : [EOL] yield value [EOL] [EOL] return myagent [EOL] [EOL] @ pytest . fixture def isolated_agent ( self , * , app ) : [EOL] [EOL] @ app . agent ( isolated_partitions = True ) async def isoagent ( stream ) : [EOL] async for value in stream : [EOL] yield value [EOL] [EOL] return isoagent [EOL] [EOL] @ pytest . fixture def foo_topic ( self , * , app ) : [EOL] return app . topic ( [string] ) [EOL] [EOL] @ pytest . fixture def agent2 ( self , * , app , foo_topic ) : [EOL] [EOL] @ app . agent ( foo_topic ) async def other_agent ( stream ) : [EOL] async for value in stream : [EOL] value [EOL] [EOL] return other_agent [EOL] [EOL] def test_init_schema_and_channel ( self , * , app ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] @ app . agent ( app . topic ( [string] ) , schema = faust . Schema ( key_type = bytes ) ) async def foo ( ) : [EOL] ... [EOL] [EOL] def test_init_key_type_and_channel ( self , * , app ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] @ app . agent ( app . topic ( [string] ) , key_type = bytes ) async def foo ( ) : [EOL] ... [EOL] [EOL] def test_init_value_type_and_channel ( self , * , app ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] @ app . agent ( app . topic ( [string] ) , value_type = bytes ) async def foo ( ) : [EOL] ... [EOL] [EOL] def test_isolated_partitions_cannot_have_concurrency ( self , * , app ) : [EOL] with pytest . raises ( ImproperlyConfigured ) : [EOL] @ app . agent ( isolated_partitions = True , concurrency = [number] ) async def foo ( ) : [EOL] ... [EOL] [EOL] def test_agent_call_reuse_stream ( self , * , agent , app ) : [EOL] stream = app . stream ( [string] ) [EOL] stream . concurrency_index = [number] [EOL] stream . active_partitions = { [number] , [number] } [EOL] actor = agent ( stream = stream , index = [number] , active_partitions = { [number] , [number] } ) [EOL] assert actor . stream is stream [EOL] [EOL] def test_cancel ( self , * , agent ) : [EOL] actor1 = Mock ( name = [string] ) [EOL] actor2 = Mock ( name = [string] ) [EOL] agent . _actors = [ actor1 , actor2 ] [EOL] agent . cancel ( ) [EOL] actor1 . cancel . assert_called_once_with ( ) [EOL] actor2 . cancel . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked ( self , * , agent ) : [EOL] revoked = { TP ( [string] , [number] ) } [EOL] agent . on_shared_partitions_revoked = AsyncMock ( name = [string] ) [EOL] await agent . on_partitions_revoked ( revoked ) [EOL] agent . on_shared_partitions_revoked . assert_called_once_with ( revoked ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_revoked__isolated ( self , * , isolated_agent ) : [EOL] revoked = { TP ( [string] , [number] ) } [EOL] i = isolated_agent . on_isolated_partitions_revoked = AsyncMock ( name = [string] ) [EOL] await isolated_agent . on_partitions_revoked ( revoked ) [EOL] i . assert_called_once_with ( revoked ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_assigned ( self , * , agent ) : [EOL] assigned = { TP ( [string] , [number] ) } [EOL] agent . on_shared_partitions_assigned = AsyncMock ( name = [string] ) [EOL] await agent . on_partitions_assigned ( assigned ) [EOL] agent . on_shared_partitions_assigned . assert_called_once_with ( assigned ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_partitions_assigned__isolated ( self , * , isolated_agent ) : [EOL] assigned = { TP ( [string] , [number] ) } [EOL] i = isolated_agent . on_isolated_partitions_assigned = AsyncMock ( ) [EOL] await isolated_agent . on_partitions_assigned ( assigned ) [EOL] i . assert_called_once_with ( assigned ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_isolated_partitions_revoked ( self , * , agent ) : [EOL] tp = TP ( [string] , [number] ) [EOL] aref = Mock ( name = [string] , autospec = Actor , on_isolated_partition_revoked = AsyncMock ( ) , ) [EOL] agent . _actor_by_partition = { tp : aref } [EOL] [EOL] await agent . on_isolated_partitions_revoked ( { tp } ) [EOL] aref . on_isolated_partition_revoked . assert_called_once_with ( tp ) [EOL] assert not agent . _actor_by_partition [EOL] await agent . on_isolated_partitions_revoked ( { tp } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_isolated_partitions_assigned ( self , * , agent ) : [EOL] agent . _assign_isolated_partition = AsyncMock ( name = [string] ) [EOL] await agent . on_isolated_partitions_assigned ( { TP ( [string] , [number] ) } ) [EOL] agent . _assign_isolated_partition . assert_called_once_with ( TP ( [string] , [number] ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test_assign_isolated_partition ( self , * , agent ) : [EOL] agent . _on_first_isolated_partition_assigned = Mock ( name = [string] ) [EOL] agent . _maybe_start_isolated = AsyncMock ( name = [string] ) [EOL] agent . _first_assignment_done = True [EOL] [EOL] tp = TP ( [string] , [number] ) [EOL] await agent . _assign_isolated_partition ( tp ) [EOL] [EOL] agent . _on_first_isolated_partition_assigned . assert_not_called ( ) [EOL] agent . _maybe_start_isolated . assert_called_once_with ( tp ) [EOL] [EOL] agent . _first_assignment_done = False [EOL] agent . _actor_by_partition = set ( ) [EOL] await agent . _assign_isolated_partition ( tp ) [EOL] agent . _on_first_isolated_partition_assigned . assert_called_once_with ( tp ) [EOL] [EOL] def test_on_first_isolated_partition_assigned ( self , * , agent ) : [EOL] aref = Mock ( name = [string] , autospec = Actor ) [EOL] agent . _actors = [ aref ] [EOL] agent . _pending_active_partitions = set ( ) [EOL] tp = TP ( [string] , [number] ) [EOL] agent . _on_first_isolated_partition_assigned ( tp ) [EOL] assert agent . _actor_by_partition [ tp ] is aref [EOL] assert agent . _pending_active_partitions == { tp } [EOL] agent . _pending_active_partitions = None [EOL] agent . _on_first_isolated_partition_assigned ( tp ) [EOL] [EOL] @ pytest . mark . asyncio async def test_maybe_start_isolated ( self , * , isolated_agent ) : [EOL] aref = Mock ( name = [string] , autospec = Actor , on_isolated_partition_assigned = AsyncMock ( ) , ) [EOL] isolated_agent . _start_isolated = AsyncMock ( name = [string] , return_value = aref , ) [EOL] tp = TP ( [string] , [number] ) [EOL] await isolated_agent . _maybe_start_isolated ( tp ) [EOL] [EOL] isolated_agent . _start_isolated . assert_called_once_with ( tp ) [EOL] assert isolated_agent . _actor_by_partition [ tp ] is aref [EOL] aref . on_isolated_partition_assigned . assert_called_once_with ( tp ) [EOL] [EOL] @ pytest . mark . asyncio async def test_start_isolated ( self , * , agent ) : [EOL] agent . _start_for_partitions = AsyncMock ( name = [string] , ) [EOL] ret = await agent . _start_isolated ( TP ( [string] , [number] ) ) [EOL] agent . _start_for_partitions . assert_called_once_with ( { TP ( [string] , [number] ) } ) [EOL] assert ret is agent . _start_for_partitions . coro ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_shared_partitions_revoked ( self , * , agent ) : [EOL] await agent . on_shared_partitions_revoked ( set ( ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_shared_partitions_assigned ( self , * , agent ) : [EOL] await agent . on_shared_partitions_assigned ( set ( ) ) [EOL] [EOL] def test_info ( self , * , agent ) : [EOL] assert agent . info ( ) == { [string] : agent . app , [string] : agent . fun , [string] : agent . name , [string] : agent . channel , [string] : agent . concurrency , [string] : agent . help , [string] : agent . _sinks , [string] : agent . _on_error , [string] : agent . supervisor_strategy , [string] : agent . isolated_partitions , } [EOL] [EOL] def test_clone ( self , * , agent ) : [EOL] assert agent . clone ( isolated_partitions = True ) . isolated_partitions [EOL] [EOL] def test_stream__active_partitions ( self , * , agent ) : [EOL] assert agent . stream ( active_partitions = { TP ( [string] , [number] ) } ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( ReqRepRequest ( [string] , [string] , [string] ) , [string] ) , ( [string] , [string] ) , ] ) def test_maybe_unwrap_reply_request ( self , input , expected , * , agent ) : [EOL] assert agent . _maybe_unwrap_reply_request ( input ) == expected [EOL] [EOL] @ pytest . mark . asyncio async def test_start_task ( self , * , agent ) : [EOL] agent . _prepare_actor = AsyncMock ( name = [string] ) [EOL] ret = await agent . _start_task ( index = [number] ) [EOL] agent . _prepare_actor . assert_called_once_with ( ANY , agent . beacon ) [EOL] assert ret is agent . _prepare_actor . coro ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_prepare_actor__AsyncIterable ( self , * , agent ) : [EOL] aref = agent ( index = [number] , active_partitions = None ) [EOL] with patch ( [string] ) as Task : [EOL] agent . _slurp = Mock ( name = [string] ) [EOL] agent . _execute_actor = Mock ( name = [string] ) [EOL] beacon = Mock ( name = [string] , autospec = Node ) [EOL] ret = await agent . _prepare_actor ( aref , beacon ) [EOL] agent . _slurp . assert_called ( ) [EOL] coro = agent . _slurp ( ) [EOL] agent . _execute_actor . assert_called_once_with ( coro , aref ) [EOL] Task . assert_called_once_with ( agent . _execute_actor ( ) , loop = agent . loop ) [EOL] task = Task ( ) [EOL] assert task . _beacon is beacon [EOL] assert aref . actor_task is task [EOL] assert aref in agent . _actors [EOL] assert ret is aref [EOL] [EOL] @ pytest . mark . asyncio async def test_prepare_actor__Awaitable ( self , * , agent2 ) : [EOL] aref = agent2 ( index = [number] , active_partitions = None ) [EOL] asyncio . ensure_future ( aref . it ) . cancel ( ) [comment] [EOL] return [EOL] with patch ( [string] ) as Task : [EOL] agent2 . _execute_actor = Mock ( name = [string] ) [EOL] beacon = Mock ( name = [string] , autospec = Node ) [EOL] ret = await agent2 . _prepare_actor ( aref , beacon ) [EOL] coro = aref [EOL] agent2 . _execute_actor . assert_called_once_with ( coro , aref ) [EOL] Task . assert_called_once_with ( agent2 . _execute_actor ( ) , loop = agent2 . loop ) [EOL] task = Task ( ) [EOL] assert task . _beacon is beacon [EOL] assert aref . actor_task is task [EOL] assert aref in agent2 . _actors [EOL] assert ret is aref [EOL] [EOL] @ pytest . mark . asyncio async def test_prepare_actor__Awaitable_cannot_have_sinks ( self , * , agent2 ) : [EOL] aref = agent2 ( index = [number] , active_partitions = None ) [EOL] asyncio . ensure_future ( aref . it ) . cancel ( ) [comment] [EOL] agent2 . _sinks = [ agent2 ] [EOL] with pytest . raises ( ImproperlyConfigured ) : [EOL] await agent2 . _prepare_actor ( aref , Mock ( name = [string] , autospec = Node ) , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_execute_actor ( self , * , agent ) : [EOL] coro = done_future ( ) [EOL] await agent . _execute_actor ( coro , Mock ( name = [string] , autospec = Actor ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test_execute_actor__cancelled_stopped ( self , * , agent ) : [EOL] coro = FutureMock ( ) [EOL] coro . side_effect = asyncio . CancelledError ( ) [EOL] await agent . stop ( ) [EOL] with pytest . raises ( asyncio . CancelledError ) : [EOL] await agent . _execute_actor ( coro , Mock ( name = [string] , autospec = Actor ) ) [EOL] coro . assert_awaited ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_execute_actor__cancelled_running ( self , * , agent ) : [EOL] coro = FutureMock ( ) [EOL] coro . side_effect = asyncio . CancelledError ( ) [EOL] await agent . _execute_actor ( coro , Mock ( name = [string] , autospec = Actor ) ) [EOL] coro . assert_awaited ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_execute_actor__raising ( self , * , agent ) : [EOL] agent . _on_error = AsyncMock ( name = [string] ) [EOL] agent . log = Mock ( name = [string] , autospec = CompositeLogger ) [EOL] aref = Mock ( name = [string] , autospec = Actor , crash = AsyncMock ( ) , ) [EOL] agent . supervisor = Mock ( name = [string] ) [EOL] coro = FutureMock ( ) [EOL] exc = coro . side_effect = KeyError ( [string] ) [EOL] await agent . _execute_actor ( coro , aref ) [EOL] coro . assert_awaited ( ) [EOL] [EOL] aref . crash . assert_called_once_with ( exc ) [EOL] agent . supervisor . wakeup . assert_called_once_with ( ) [EOL] agent . _on_error . assert_called_once_with ( agent , exc ) [EOL] [EOL] agent . _on_error = None [EOL] await agent . _execute_actor ( coro , aref ) [EOL] [EOL] @ pytest . mark . asyncio async def test_slurp ( self , * , agent , app ) : [EOL] aref = agent ( index = None , active_partitions = None ) [EOL] stream = aref . stream . get_active_stream ( ) [EOL] agent . _delegate_to_sinks = AsyncMock ( name = [string] ) [EOL] agent . _reply = AsyncMock ( name = [string] ) [EOL] [EOL] def on_delegate ( value ) : [EOL] raise StopAsyncIteration ( ) [EOL] [EOL] word = Word ( [string] ) [EOL] word_req = ReqRepRequest ( word , [string] , [string] ) [EOL] message1 = Mock ( name = [string] , autospec = Message ) [EOL] message2 = Mock ( name = [string] , autospec = Message ) [EOL] event1 = Event ( app , None , word_req , { } , message1 ) [EOL] event2 = Event ( app , [string] , [string] , { } , message2 ) [EOL] values = [ ( event1 , word ) , ( event2 , [string] ) , ] [EOL] [EOL] class AIT : [EOL] [EOL] async def __aiter__ ( self ) : [EOL] for event , value in values : [EOL] stream . current_event = event [EOL] yield value [EOL] it = aiter ( AIT ( ) ) [EOL] await agent . _slurp ( aref , it ) [EOL] [EOL] agent . _reply . assert_called_once_with ( None , word , word_req . reply_to , word_req . correlation_id ) [EOL] agent . _delegate_to_sinks . coro . assert_has_calls ( [ call ( word ) , call ( [string] ) , ] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_slurp__headers ( self , * , agent , app ) : [EOL] agent . use_reply_headers = True [EOL] aref = agent ( index = None , active_partitions = None ) [EOL] stream = aref . stream . get_active_stream ( ) [EOL] agent . _delegate_to_sinks = AsyncMock ( name = [string] ) [EOL] agent . _reply = AsyncMock ( name = [string] ) [EOL] [EOL] def on_delegate ( value ) : [EOL] raise StopAsyncIteration ( ) [EOL] [EOL] word = Word ( [string] ) [EOL] message1 = Mock ( name = [string] , autospec = Message ) [EOL] headers1 = message1 . headers = { [string] : [string] , [string] : [string] , } [EOL] message2 = Mock ( name = [string] , autospec = Message ) [EOL] headers2 = message2 . headers = { } [EOL] event1 = Event ( app , None , word , headers1 , message1 ) [EOL] event2 = Event ( app , [string] , [string] , headers2 , message2 ) [EOL] values = [ ( event1 , word , True ) , ( event1 , word , False ) , ( event2 , [string] , True ) , ] [EOL] [EOL] class AIT : [EOL] [EOL] async def __aiter__ ( self ) : [EOL] for event , value , set_cur_event in values : [EOL] if set_cur_event : [EOL] stream . current_event = event [EOL] else : [EOL] stream . current_event = None [EOL] yield value [EOL] it = aiter ( AIT ( ) ) [EOL] await agent . _slurp ( aref , it ) [EOL] [EOL] agent . _reply . assert_called_once_with ( None , word , [string] , [string] ) [EOL] agent . _delegate_to_sinks . coro . assert_has_calls ( [ call ( word ) , call ( [string] ) , ] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_delegate_to_sinks ( self , * , agent , agent2 , foo_topic ) : [EOL] agent2 . send = AsyncMock ( name = [string] ) [EOL] foo_topic . send = AsyncMock ( name = [string] ) [EOL] sink_callback = Mock ( name = [string] ) [EOL] sink_callback2_mock = Mock ( name = [string] ) [EOL] [EOL] async def sink_callback2 ( value ) : [EOL] return sink_callback2_mock ( value ) [EOL] [EOL] agent . _sinks = [ agent2 , foo_topic , sink_callback , sink_callback2 , ] [EOL] [EOL] value = Mock ( name = [string] ) [EOL] await agent . _delegate_to_sinks ( value ) [EOL] [EOL] agent2 . send . assert_called_once_with ( value = value ) [EOL] foo_topic . send . assert_called_once_with ( value = value ) [EOL] sink_callback . assert_called_once_with ( value ) [EOL] sink_callback2_mock . assert_called_once_with ( value ) [EOL] [EOL] @ pytest . mark . asyncio async def test_reply ( self , * , agent ) : [EOL] agent . app = Mock ( name = [string] , autospec = App , send = AsyncMock ( ) , ) [EOL] req = ReqRepRequest ( [string] , [string] , [string] ) [EOL] await agent . _reply ( [string] , [string] , req . reply_to , req . correlation_id ) [EOL] agent . app . send . assert_called_once_with ( req . reply_to , key = None , value = ReqRepResponse ( key = [string] , value = [string] , correlation_id = req . correlation_id , ) , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_cast ( self , * , agent ) : [EOL] agent . send = AsyncMock ( name = [string] ) [EOL] await agent . cast ( [string] , key = [string] , partition = [number] ) [EOL] agent . send . assert_called_once_with ( key = [string] , value = [string] , partition = [number] , headers = None , timestamp = None , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_ask ( self , * , agent ) : [EOL] agent . app = Mock ( name = [string] , autospec = App , maybe_start_client = AsyncMock ( ) , _reply_consumer = Mock ( autospec = ReplyConsumer , add = AsyncMock ( ) , ) , ) [EOL] pp = done_future ( ) [EOL] agent . ask_nowait = Mock ( name = [string] ) [EOL] agent . ask_nowait . return_value = done_future ( pp ) [EOL] pp . correlation_id = [string] [EOL] [EOL] await agent . ask ( value = [string] , key = [string] , partition = [number] , correlation_id = [string] , headers = { [string] : [string] } , ) [EOL] agent . ask_nowait . assert_called_once_with ( [string] , key = [string] , partition = [number] , reply_to = agent . app . conf . reply_to , correlation_id = [string] , force = True , timestamp = None , headers = { [string] : [string] } , ) [EOL] agent . app . _reply_consumer . add . assert_called_once_with ( pp . correlation_id , pp ) [EOL] [EOL] @ pytest . mark . asyncio async def test_ask_nowait ( self , * , agent ) : [EOL] agent . _create_req = Mock ( name = [string] ) [EOL] agent . _create_req . return_value = [ [string] , None ] [EOL] agent . channel . send = AsyncMock ( name = [string] ) [EOL] res = await agent . ask_nowait ( value = [string] , key = [string] , partition = [number] , timestamp = None , headers = None , reply_to = [string] , correlation_id = [string] , force = True , ) [EOL] [EOL] agent . _create_req . assert_called_once_with ( [string] , [string] , [string] , [string] , None ) [EOL] agent . channel . send . assert_called_once_with ( key = [string] , value = agent . _create_req ( ) [ [number] ] , partition = [number] , timestamp = None , force = True , headers = None , ) [EOL] [EOL] assert res . reply_to [EOL] assert res . correlation_id [EOL] [EOL] @ pytest . mark . asyncio async def test_ask_nowait__missing_reply_to ( self , * , agent ) : [EOL] with pytest . raises ( TypeError ) : [EOL] await agent . ask_nowait ( value = [string] , key = [string] , partition = [number] , reply_to = None , ) [EOL] [EOL] def test_create_req ( self , * , agent ) : [EOL] agent . use_reply_headers = False [EOL] agent . _get_strtopic = Mock ( name = [string] ) [EOL] with patch ( [string] ) as uuid4 : [EOL] uuid4 . return_value = [string] [EOL] reqrep = agent . _create_req ( key = [string] , value = [string] , reply_to = [string] , headers = { [string] : [string] } ) [ [number] ] [EOL] [EOL] agent . _get_strtopic . assert_called_once_with ( [string] ) [EOL] [EOL] assert reqrep . value == [string] [EOL] assert reqrep . reply_to == agent . _get_strtopic ( ) [EOL] assert reqrep . correlation_id == [string] [EOL] [EOL] def test_create_req__use_reply_headers ( self , * , agent ) : [EOL] agent . use_reply_headers = True [EOL] agent . _get_strtopic = Mock ( name = [string] ) [EOL] with patch ( [string] ) as uuid4 : [EOL] uuid4 . return_value = [string] [EOL] value , h = agent . _create_req ( key = [string] , value = [string] , reply_to = [string] , headers = { [string] : [string] } ) [EOL] [EOL] agent . _get_strtopic . assert_called_once_with ( [string] ) [EOL] [EOL] assert value == [string] [EOL] assert h [ [string] ] == agent . _get_strtopic ( ) [EOL] assert h [ [string] ] == [string] . encode ( ) [EOL] [EOL] def test_create_req__model ( self , * , agent ) : [EOL] agent . use_reply_headers = False [EOL] agent . _get_strtopic = Mock ( name = [string] ) [EOL] with patch ( [string] ) as uuid4 : [EOL] uuid4 . return_value = [string] [EOL] value = Word ( [string] ) [EOL] reqrep = agent . _create_req ( key = [string] , value = value , reply_to = [string] , headers = { [string] : [string] } ) [ [number] ] [EOL] assert isinstance ( reqrep , ReqRepRequest ) [EOL] [EOL] agent . _get_strtopic . assert_called_once_with ( [string] ) [EOL] assert isinstance ( reqrep , ModelReqRepRequest ) [EOL] [EOL] assert reqrep . value is value [EOL] assert reqrep . reply_to == agent . _get_strtopic ( ) [EOL] assert reqrep . correlation_id == [string] [EOL] [EOL] def test_create_req__requires_reply_to ( self , * , agent ) : [EOL] with pytest . raises ( TypeError ) : [EOL] agent . _create_req ( key = [string] , value = [string] , reply_to = None , ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , ReqRepResponse ) , ( Word ( [string] ) , ModelReqRepResponse ) , ] ) def test_response_class ( self , value , expected_class , * , agent ) : [EOL] assert agent . _response_class ( value ) is expected_class [EOL] [EOL] @ pytest . mark . asyncio async def test_send ( self , * , agent ) : [EOL] agent . channel = Mock ( name = [string] , autospec = Channel , send = AsyncMock ( ) , ) [EOL] agent . _create_req = Mock ( name = [string] ) [EOL] agent . _create_req . return_value = ( [string] , { [string] : [string] } ) [EOL] callback = Mock ( name = [string] ) [EOL] [EOL] ret = await agent . send ( key = [string] , value = [string] , partition = [number] , timestamp = None , headers = { [string] : [string] } , key_serializer = [string] , value_serializer = [string] , callback = callback , reply_to = [string] , correlation_id = [string] , force = True , ) [EOL] [EOL] agent . _create_req . assert_called_once_with ( [string] , [string] , [string] , [string] , { [string] : [string] } , ) [EOL] [EOL] agent . channel . send . assert_called_once_with ( key = [string] , value = agent . _create_req ( ) [ [number] ] , partition = [number] , timestamp = None , headers = { [string] : [string] } , key_serializer = [string] , value_serializer = [string] , force = True , ) [EOL] [EOL] assert ret is agent . channel . send . coro ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send__without_reply_to ( self , * , agent ) : [EOL] agent . channel = Mock ( name = [string] , autospec = Channel , send = AsyncMock ( ) , ) [EOL] agent . _create_req = Mock ( name = [string] ) [EOL] callback = Mock ( name = [string] ) [EOL] [EOL] ret = await agent . send ( key = [string] , value = [string] , partition = [number] , timestamp = None , headers = { [string] : [string] } , key_serializer = [string] , value_serializer = [string] , callback = callback , reply_to = None , correlation_id = [string] , force = True , ) [EOL] [EOL] agent . _create_req . assert_not_called ( ) [EOL] [EOL] agent . channel . send . assert_called_once_with ( key = [string] , value = [string] , partition = [number] , timestamp = None , headers = { [string] : [string] } , key_serializer = [string] , value_serializer = [string] , force = True , ) [EOL] [EOL] assert ret is agent . channel . send . coro ( ) [EOL] [EOL] def test_get_strtopic__agent ( self , * , agent , agent2 ) : [EOL] assert agent . _get_strtopic ( agent2 ) == agent2 . channel . get_topic_name ( ) [EOL] [EOL] def test_get_strtopic__topic ( self , * , agent , foo_topic ) : [EOL] assert agent . _get_strtopic ( foo_topic ) == foo_topic . get_topic_name ( ) [EOL] [EOL] def test_get_strtopic__str ( self , * , agent ) : [EOL] assert agent . _get_strtopic ( [string] ) == [string] [EOL] [EOL] def test_get_strtopic__channel_raises ( self , * , agent , app ) : [EOL] with pytest . raises ( ValueError ) : [EOL] agent . _get_strtopic ( app . channel ( ) ) [EOL] [EOL] def test_get_topic_names ( self , * , agent , app ) : [EOL] agent . channel = app . topic ( [string] ) [EOL] assert agent . get_topic_names ( ) == ( [string] , ) [EOL] [EOL] def test_get_topic_names__channel ( self , * , agent , app ) : [EOL] agent . channel = app . channel ( ) [EOL] assert agent . get_topic_names ( ) == [ ] [EOL] [EOL] def test_repr ( self , * , agent ) : [EOL] assert repr ( agent ) [EOL] [EOL] def test_channel ( self , * , agent ) : [EOL] agent . _prepare_channel = Mock ( name = [string] ) [EOL] agent . _channel = None [EOL] channel = agent . channel [EOL] agent . _prepare_channel . assert_called_once_with ( agent . _channel_arg , schema = agent . _schema , key_type = agent . _key_type , value_type = agent . _value_type , ** agent . _channel_kwargs ) [EOL] assert channel is agent . _prepare_channel . return_value [EOL] assert agent . _channel is channel [EOL] [EOL] def test_prepare_channel__not_channel ( self , * , agent ) : [EOL] with pytest . raises ( TypeError ) : [EOL] agent . _prepare_channel ( object ( ) ) [EOL] [EOL] def test_add_sink ( self , * , agent , agent2 ) : [EOL] agent . add_sink ( agent2 ) [EOL] assert agent2 in agent . _sinks [EOL] agent . add_sink ( agent2 ) [EOL] [EOL] def test_channel_iterator ( self , * , agent ) : [EOL] agent . channel = Mock ( name = [string] , autospec = Channel ) [EOL] agent . _channel_iterator = None [EOL] it = agent . channel_iterator [EOL] [EOL] agent . channel . clone . assert_called_once_with ( is_iterator = False ) [EOL] assert it is agent . channel . clone ( ) [EOL] agent . channel_iterator = [ [number] ] [EOL] assert agent . channel_iterator == [ [number] ] [EOL] [EOL] def test_label ( self , * , agent ) : [EOL] assert label ( agent ) [EOL] [EOL] async def test_context_calls_sink ( self , * , agent ) : [EOL] class SinkCalledException ( Exception ) : [EOL] pass [EOL] [EOL] def dummy_sink ( _ ) : [EOL] raise SinkCalledException ( ) [EOL] [EOL] agent . add_sink ( dummy_sink ) [EOL] async with agent . test_context ( ) as agent_mock : [EOL] with pytest . raises ( SinkCalledException ) : [EOL] await agent_mock . put ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.events.Event$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $faust.events.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Tuple[faust.events.Event,typing.Union[builtins.str,t.unit.agents.test_agent.Word]]]$ 0 0 0 $faust.events.Event$ 0 $t.unit.agents.test_agent.Word$ 0 0 0 $faust.events.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $t.unit.agents.test_agent.Word$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $faust.events.Event$ 0 0 0 0 0 0 0 $t.unit.agents.test_agent.Word$ 0 0 0 $typing.Any$ 0 0 $faust.events.Event$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Tuple[faust.events.Event,typing.Union[builtins.str,t.unit.agents.test_agent.Word],builtins.bool]]$ 0 0 0 $faust.events.Event$ 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 $faust.events.Event$ 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 $faust.events.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $t.unit.agents.test_agent.Word$ 0 $t.unit.agents.test_agent.Word$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $t.unit.agents.test_agent.Word$ 0 $t.unit.agents.test_agent.Word$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from faust import Event [EOL] from faust . stores . memory import Store [EOL] from faust . types import TP [EOL] from mode . utils . mocks import Mock [EOL] [EOL] [EOL] class test_Store : [EOL] [EOL] @ pytest . fixture def store ( self , * , app ) : [EOL] return Store ( url = [string] , app = app , table = Mock ( name = [string] ) ) [EOL] [EOL] def test_clear ( self , * , store ) : [EOL] store . data [ [string] ] = [number] [EOL] store . _clear ( ) [EOL] assert not store . data [EOL] [EOL] def test_apply_changelog_batch ( self , * , store ) : [EOL] event , to_key , to_value = self . mock_event_to_key_value ( ) [EOL] store . apply_changelog_batch ( [ event ] , to_key = to_key , to_value = to_value ) [EOL] [EOL] to_key . assert_called_once_with ( [string] ) [EOL] to_value . assert_called_once_with ( [string] ) [EOL] assert store . data [ to_key ( ) ] == to_value ( ) [EOL] [EOL] def test_apply_changelog_batch__deletes_key_for_None_value ( self , * , store ) : [EOL] self . test_apply_changelog_batch ( store = store ) [EOL] event2 , to_key , to_value = self . mock_event_to_key_value ( value = None ) [EOL] [EOL] assert to_key ( ) in store . data [EOL] store . apply_changelog_batch ( [ event2 ] , to_key = to_key , to_value = to_value ) [EOL] [EOL] assert to_key ( ) not in store . data [EOL] [EOL] def mock_event_to_key_value ( self , key = [string] , value = [string] ) : [EOL] event = self . mock_event ( key = key , value = value ) [EOL] to_key , to_value = self . mock_to_key_value ( event ) [EOL] return event , to_key , to_value [EOL] [EOL] def mock_event ( self , key = [string] , value = [string] ) : [EOL] event = Mock ( name = [string] , autospec = Event ) [EOL] event . key = key [EOL] event . value = value [EOL] event . message . key = key [EOL] event . message . value = value [EOL] return event [EOL] [EOL] def mock_to_key_value ( self , event ) : [EOL] to_key = Mock ( name = [string] ) [EOL] to_key . return_value = event . key [EOL] to_value = Mock ( name = [string] ) [EOL] to_value . return_value = event . value [EOL] return to_key , to_value [EOL] [EOL] def test_persisted_offset ( self , * , store ) : [EOL] assert store . persisted_offset ( TP ( [string] , [number] ) ) is None [EOL] [EOL] def test_reset_state ( self , * , store ) : [EOL] store . reset_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] import pytest [EOL] from faust . types . _env import _getenv [EOL] [EOL] [EOL] def test_getenv_not_set ( ) : [EOL] os . environ . pop ( [string] , None ) [EOL] with pytest . raises ( KeyError ) : [EOL] _getenv ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from mode . utils . mocks import Mock [EOL] [EOL] [EOL] @ pytest . fixture ( ) def context ( * , app , request ) : [EOL] context = Mock ( ) [EOL] context . app = app [EOL] context . find_root . return_value = context [EOL] return context [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import t [EOL] import datetime [EOL] import faust [EOL] import pytest [EOL] [EOL] from faust . events import Event [EOL] from faust . types import Message [EOL] from faust . tables . wrappers import WindowSet , WindowWrapper [EOL] from mode . utils . mocks import Mock , patch [EOL] [EOL] [EOL] class TableKey ( faust . Record ) : [EOL] value = ... [EOL] [EOL] [EOL] class TableValue ( faust . Record ) : [EOL] id = ... [EOL] num = ... [EOL] [EOL] [EOL] KEY1 = TableKey ( [string] ) [EOL] VALUE1 = TableValue ( [string] , [number] ) [EOL] [EOL] WINDOW1 = faust . HoppingWindow ( size = [number] , step = [number] , expires = [number] ) [EOL] [EOL] [EOL] def event ( ) : [EOL] message = Message ( topic = [string] , key = [string] , value = [string] , partition = [number] , offset = [number] , checksum = None , timestamp = datetime . datetime . now ( ) . timestamp ( ) , timestamp_type = [number] , headers = { } ) [EOL] return Event ( app = [string] , key = [string] , value = [string] , headers = { } , message = message , ) [EOL] [EOL] [EOL] class test_Table : [EOL] [EOL] @ pytest . fixture def table ( self , * , app ) : [EOL] return self . create_table ( app , name = [string] , default = int ) [EOL] [EOL] @ pytest . fixture def strict_table ( self , * , app ) : [EOL] return self . create_table ( app , name = [string] ) [EOL] [EOL] def create_table ( self , app , * , name = [string] , key_type = TableKey , value_type = TableValue , ** kwargs ) : [EOL] return app . Table ( name , key_type = key_type , value_type = value_type , ** kwargs ) [EOL] [EOL] @ patch ( [string] , return_value = event ( ) ) def test_using_window ( self , patch_current , * , table ) : [EOL] with_wrapper = table . using_window ( WINDOW1 ) [EOL] self . assert_wrapper ( with_wrapper , table , WINDOW1 ) [EOL] self . assert_current ( with_wrapper , patch_current ) [EOL] [EOL] @ patch ( [string] , return_value = event ( ) ) def test_hopping ( self , patch_current , * , table ) : [EOL] with_wrapper = table . hopping ( [number] , [number] , [number] ) [EOL] self . assert_wrapper ( with_wrapper , table ) [EOL] self . assert_current ( with_wrapper , patch_current ) [EOL] [EOL] @ patch ( [string] , return_value = event ( ) ) def test_tumbling ( self , patch_current , * , table ) : [EOL] with_wrapper = table . tumbling ( [number] , [number] ) [EOL] self . assert_wrapper ( with_wrapper , table ) [EOL] self . assert_current ( with_wrapper , patch_current ) [EOL] [EOL] def assert_wrapper ( self , wrapper , table , window = None ) : [EOL] assert wrapper . table is table [EOL] t = wrapper . table [EOL] if window is not None : [EOL] assert t . window is window [EOL] assert t . _changelog_compacting [EOL] assert t . _changelog_deleting [EOL] assert t . _changelog_topic is None [EOL] assert isinstance ( wrapper , WindowWrapper ) [EOL] [EOL] def assert_current ( self , wrapper , patch_current ) : [EOL] value = wrapper [ [string] ] [EOL] assert isinstance ( value , WindowSet ) [EOL] patch_current . asssert_called_once_with ( ) [EOL] assert value . current ( ) == [number] [EOL] [EOL] def test_missing__when_default ( self , * , table ) : [EOL] assert table [ [string] ] == [number] [EOL] table . data [ [string] ] = [number] [EOL] assert table [ [string] ] == [number] [EOL] [EOL] def test_missing__no_default ( self , * , strict_table ) : [EOL] with pytest . raises ( KeyError ) : [EOL] strict_table [ [string] ] [EOL] strict_table . data [ [string] ] = [number] [EOL] assert strict_table [ [string] ] == [number] [EOL] [EOL] def test_has_key ( self , * , table ) : [EOL] assert not table . _has_key ( [string] ) [EOL] table . data [ [string] ] = [number] [EOL] assert table . _has_key ( [string] ) [EOL] [EOL] def test_get_key ( self , * , table ) : [EOL] assert table . _get_key ( [string] ) == [number] [EOL] table . data [ [string] ] = [number] [EOL] assert table . _get_key ( [string] ) == [number] [EOL] [EOL] def test_set_key ( self , * , table ) : [EOL] with patch ( [string] ) as current_event : [EOL] event = current_event . return_value [EOL] partition = event . message . partition [EOL] table . send_changelog = Mock ( name = [string] ) [EOL] table . _set_key ( [string] , [string] ) [EOL] table . send_changelog . asssert_called_once_with ( partition , [string] , [string] ) [EOL] assert table [ [string] ] == [string] [EOL] [EOL] def test_del_key ( self , * , table ) : [EOL] with patch ( [string] ) as current_event : [EOL] event = current_event . return_value [EOL] partition = event . message . partition [EOL] table . send_changelog = Mock ( name = [string] ) [EOL] table . data [ [string] ] = [number] [EOL] table . _del_key ( [string] ) [EOL] table . send_changelog . asssert_called_once_with ( partition , [string] , None ) [EOL] assert [string] not in table . data [EOL] [EOL] def test_as_ansitable ( self , * , table ) : [EOL] table . data [ [string] ] = [string] [EOL] table . data [ [string] ] = [string] [EOL] assert table . as_ansitable ( sort = True ) [EOL] assert table . as_ansitable ( sort = False ) [EOL] [EOL] def test_on_key_set__no_event ( self , * , table ) : [EOL] with patch ( [string] ) as ce : [EOL] ce . return_value = None [EOL] with pytest . raises ( TypeError ) : [EOL] table . on_key_set ( [string] , [string] ) [EOL] [EOL] def test_on_key_del__no_event ( self , * , table ) : [EOL] with patch ( [string] ) as ce : [EOL] ce . return_value = None [EOL] with pytest . raises ( TypeError ) : [EOL] table . on_key_del ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $t.unit.tables.test_table.TableKey$ 0 0 0 0 0 0 $t.unit.tables.test_table.TableValue$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from faust . tables . objects import ChangeloggedObjectManager [EOL] from faust . types import TP [EOL] from mode . utils . mocks import AsyncMock , Mock , patch [EOL] [EOL] TP1 = TP ( [string] , [number] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def key ( ) : [EOL] return Mock ( name = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def table ( ) : [EOL] return Mock ( name = [string] , _new_store_by_url = Mock ( return_value = Mock ( on_rebalance = AsyncMock ( ) , ) , ) , ) [EOL] [EOL] [EOL] @ pytest . yield_fixture ( ) def current_event ( ) : [EOL] with patch ( [string] ) as current_event : [EOL] yield current_event [EOL] [EOL] [EOL] class ValueType : [EOL] [EOL] def __init__ ( self , man , key ) : [EOL] self . man = man [EOL] self . key = key [EOL] self . synced = set ( ) [EOL] self . changes = [ ] [EOL] [EOL] def sync_from_storage ( self , value ) : [EOL] self . synced . add ( value ) [EOL] [EOL] def as_stored_value ( self ) : [EOL] return f'{ self . key } [string] ' [EOL] [EOL] def apply_changelog_event ( self , operation , value ) : [EOL] self . changes . append ( ( operation , value ) ) [EOL] [EOL] [EOL] class test_ChangeloggedObjectManager : [EOL] [EOL] @ pytest . fixture ( ) def man ( self , * , table ) : [EOL] man = ChangeloggedObjectManager ( table ) [EOL] man . ValueType = ValueType [EOL] return man [EOL] [EOL] @ pytest . fixture ( ) def storage ( self , * , table ) : [EOL] return table . _new_store_by_url . return_value [EOL] [EOL] def test_send_changelog_event ( self , * , man , table , key , current_event ) : [EOL] man . send_changelog_event ( key , [number] , [string] ) [EOL] assert key in man . _dirty [EOL] table . _send_changelog . assert_called_once_with ( current_event ( ) , ( [number] , key ) , [string] , ) [EOL] [EOL] def test__getitem__ ( self , * , man ) : [EOL] v1 = man [ [string] ] [EOL] v2 = man [ [string] ] [EOL] assert v1 is v2 [EOL] v3 = man [ [string] ] [EOL] assert v3 is not v1 [EOL] [EOL] assert man . data [ [string] ] . man is man [EOL] assert man . data [ [string] ] . key == [string] [EOL] assert man . data [ [string] ] . man is man [EOL] assert man . data [ [string] ] . key == [string] [EOL] [EOL] def test__setitem__ ( self , * , man ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] man [ [string] ] = [number] [EOL] [EOL] def test__delitem__ ( self , * , man ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] del ( man [ [string] ] ) [EOL] [EOL] def test_table_type_name ( self , * , man ) : [EOL] assert man . _table_type_name [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start ( self , * , man ) : [EOL] man . add_runtime_dependency = AsyncMock ( ) [EOL] await man . on_start ( ) [EOL] man . add_runtime_dependency . assert_called_once_with ( man . storage ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop ( self , * , man ) : [EOL] man . flush_to_storage = Mock ( ) [EOL] await man . on_stop ( ) [EOL] man . flush_to_storage . assert_called_once_with ( ) [EOL] [EOL] def test_persisted_offset ( self , * , man , storage ) : [EOL] ret = man . persisted_offset ( TP1 ) [EOL] storage . persisted_offset . assert_called_once_with ( TP1 ) [EOL] assert ret is storage . persisted_offset ( ) [EOL] [EOL] def test_set_persisted_offset ( self , * , man , storage ) : [EOL] man . set_persisted_offset ( TP1 , [number] ) [EOL] storage . set_persisted_offset . assert_called_once_with ( TP1 , [number] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_rebalance ( self , * , man , storage , table ) : [EOL] await man . on_rebalance ( table , { TP1 } , { TP1 } , { TP1 } ) [EOL] man . storage . on_rebalance . assert_called_once_with ( table , { TP1 } , { TP1 } , { TP1 } , ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_recovery_completed ( self , * , man ) : [EOL] man . sync_from_storage = Mock ( ) [EOL] await man . on_recovery_completed ( { TP1 } , { TP1 } ) [EOL] man . sync_from_storage . assert_called_once_with ( ) [EOL] [EOL] def test_sync_from_storage ( self , * , man , storage ) : [EOL] storage . items . return_value = [ ( [string] , [number] ) , ( [string] , [number] ) ] [EOL] man . sync_from_storage ( ) [EOL] assert [number] in man [ [string] ] . synced [EOL] assert [number] in man [ [string] ] . synced [EOL] [EOL] def test_flush_to_storage ( self , * , man ) : [EOL] man . _storage = { } [EOL] man . _dirty = { [string] , [string] } [EOL] assert man [ [string] ] [EOL] assert man [ [string] ] [EOL] man . flush_to_storage ( ) [EOL] assert man . _storage [ [string] ] == [string] [EOL] [EOL] def test_reset_state ( self , * , man , storage ) : [EOL] man . reset_state ( ) [EOL] storage . reset_state . assert_called_once_with ( ) [EOL] [EOL] def test_apply_changelog_batch__key_is_None ( self , * , man ) : [EOL] event1 = Mock ( name = [string] ) [EOL] event1 . key = None [EOL] with pytest . raises ( RuntimeError ) : [EOL] man . apply_changelog_batch ( [ event1 ] , Mock ( ) , Mock ( ) ) [EOL] [EOL] def test_apply_changelog_batch__empty ( self , * , man ) : [EOL] man . apply_changelog_batch ( [ ] , lambda k : k , lambda v : v ) [EOL] [EOL] def test_apply_changelog_batch ( self , * , man ) : [EOL] event1 = Mock ( name = [string] ) [EOL] event1 . key = [number] , [string] [EOL] event1 . value = [string] [EOL] man . apply_changelog_batch ( [ event1 ] , lambda k : k , lambda v : v ) [EOL] assert ( [number] , [string] ) in man [ [string] ] . changes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from faust . tables . recovery import Recovery [EOL] from faust . types import TP [EOL] from mode . utils . mocks import AsyncMock , Mock [EOL] [EOL] TP1 = TP ( [string] , [number] ) [EOL] TP2 = TP ( [string] , [number] ) [EOL] TP3 = TP ( [string] , [number] ) [EOL] [EOL] [EOL] class test_Manager : [EOL] [EOL] @ pytest . fixture ( ) def tables ( self , * , app ) : [EOL] return app . tables [EOL] [EOL] def test_persist_offset_on_commit ( self , * , tables ) : [EOL] store = Mock ( name = [string] ) [EOL] tables . persist_offset_on_commit ( store , TP1 , [number] ) [EOL] assert tables . _pending_persisted_offsets [ TP1 ] == ( store , [number] ) [EOL] [EOL] tables . persist_offset_on_commit ( store , TP1 , [number] ) [EOL] assert tables . _pending_persisted_offsets [ TP1 ] == ( store , [number] ) [EOL] [EOL] tables . persist_offset_on_commit ( store , TP1 , [number] ) [EOL] assert tables . _pending_persisted_offsets [ TP1 ] == ( store , [number] ) [EOL] [EOL] def test_on_commit ( self , * , tables ) : [EOL] tables . on_commit_tp = Mock ( name = [string] ) [EOL] tables . on_commit ( { TP1 : [number] } ) [EOL] tables . on_commit_tp . assert_called_once_with ( TP1 ) [EOL] [EOL] def test_on_commit_tp ( self , * , tables ) : [EOL] store = Mock ( name = [string] ) [EOL] tables . on_commit_tp ( TP1 ) [EOL] tables . persist_offset_on_commit ( store , TP1 , [number] ) [EOL] tables . on_commit_tp ( TP1 ) [EOL] store . set_persisted_offset . assert_called_once_with ( TP1 , [number] ) [EOL] [EOL] def test_on_rebalance_start ( self , * , tables ) : [EOL] tables . on_rebalance_start ( ) [EOL] assert not tables . actives_ready [EOL] assert not tables . standbys_ready [EOL] [EOL] tables . on_actives_ready ( ) [EOL] assert tables . actives_ready [EOL] [EOL] tables . on_standbys_ready ( ) [EOL] assert tables . standbys_ready [EOL] [EOL] def test_hash ( self , * , tables ) : [EOL] assert hash ( tables ) [EOL] [EOL] def test_changelog_topics ( self , * , tables ) : [EOL] assert tables . changelog_topics == set ( ) [EOL] [EOL] def test_changelog_queue ( self , * , tables , app ) : [EOL] assert tables . changelog_queue [EOL] assert tables . changelog_queue . maxsize == app . conf . stream_buffer_maxsize [EOL] [EOL] def test_recovery ( self , * , tables ) : [EOL] assert tables . recovery [EOL] assert isinstance ( tables . recovery , Recovery ) [EOL] assert tables . recovery . beacon . parent is tables . beacon [EOL] assert tables . recovery . loop is tables . loop [EOL] [EOL] def test_add ( self , * , tables ) : [EOL] table = Mock ( name = [string] ) [EOL] assert tables . add ( table ) is table [EOL] assert tables [ table . name ] is table [EOL] assert tables . _changelogs [ table . changelog_topic . get_topic_name ( ) ] [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] tables . add ( table ) [comment] [EOL] [EOL] def test_add__when_recovery_started_raises ( self , * , tables ) : [EOL] tables . _tables_finalized . set ( ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] tables . add ( Mock ( name = [string] ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_start ( self , * , tables ) : [EOL] tables . sleep = AsyncMock ( ) [EOL] tables . _update_channels = AsyncMock ( ) [EOL] tables . _recovery = Mock ( start = AsyncMock ( ) ) [EOL] [EOL] tables . _stopped . set ( ) [EOL] await tables . on_start ( ) [EOL] [EOL] tables . sleep . assert_called_once_with ( [number] ) [EOL] tables . _update_channels . assert_not_called ( ) [EOL] tables . _recovery . start . assert_not_called ( ) [EOL] [EOL] tables . _stopped . clear ( ) [EOL] await tables . on_start ( ) [EOL] [EOL] tables . _update_channels . assert_called_once_with ( ) [EOL] tables . _recovery . start . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test__update_channels ( self , * , tables , app ) : [EOL] app . consumer = Mock ( name = [string] ) [EOL] app . consumer . assignment . return_value = set ( ) [EOL] await tables . _update_channels ( ) [EOL] tables . _tables_finalized . clear ( ) [EOL] [EOL] app . topics = Mock ( name = [string] ) [EOL] table1 = Mock ( name = [string] , maybe_start = AsyncMock ( ) ) [EOL] tables . add ( table1 ) [EOL] await tables . _update_channels ( ) [EOL] tables . _tables_finalized . clear ( ) [EOL] [EOL] table1 . maybe_start . assert_called_once_with ( ) [EOL] assert tables . _channels [ table1 ] [EOL] await tables . _update_channels ( ) [EOL] assert tables . _tables_finalized . is_set ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop ( self , * , tables , app ) : [EOL] app . _fetcher = Mock ( name = [string] , stop = AsyncMock ( ) ) [EOL] await tables . on_stop ( ) [EOL] [EOL] app . _fetcher . stop . assert_called_once_with ( ) [EOL] [EOL] table1 = Mock ( name = [string] , stop = AsyncMock ( ) ) [EOL] tables . _recovery = Mock ( name = [string] , stop = AsyncMock ( ) ) [EOL] tables . add ( table1 ) [EOL] await tables . on_stop ( ) [EOL] [EOL] tables . _recovery . stop . assert_called_once_with ( ) [EOL] table1 . stop . assert_called_once_with ( ) [EOL] [EOL] def test_on_partitions_revoked ( self , * , tables ) : [EOL] tables . _recovery = Mock ( name = [string] ) [EOL] tables . on_partitions_revoked ( { TP1 } ) [EOL] tables . _recovery . on_partitions_revoked . assert_called_once_with ( { TP1 } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_rebalance ( self , * , tables ) : [EOL] tables . _update_channels = AsyncMock ( ) [EOL] tables . _recovery = Mock ( on_rebalance = AsyncMock ( ) ) [EOL] [EOL] await tables . on_rebalance ( { TP1 , TP2 , TP3 } , set ( ) , { TP1 , TP2 , TP3 } ) [EOL] tables . _recovery_started . clear ( ) [EOL] [EOL] tables . _update_channels . assert_called_once_with ( ) [EOL] tables . _recovery . on_rebalance . assert_called_once_with ( { TP1 , TP2 , TP3 } , set ( ) , { TP1 , TP2 , TP3 } ) [EOL] [EOL] table1 = Mock ( name = [string] , on_rebalance = AsyncMock ( ) ) [EOL] tables . add ( table1 ) [EOL] [EOL] await tables . on_rebalance ( { TP2 , TP3 } , { TP1 } , set ( ) ) [EOL] table1 . on_rebalance . assert_called_once_with ( { TP2 , TP3 } , { TP1 } , set ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
import pytest [EOL] from faust . utils . codegen import reprcall , reprkwargs [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( { } , [string] ) , ( { [string] : [string] } , [string] ) , ( { [string] : [string] , [string] : [number] } , [string] ) , ] ) def test_reprkwargs ( input , expected ) : [EOL] assert reprkwargs ( input ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , ( ) , { } , [string] ) , ( [string] , ( [number] , [number] , [number] ) , { } , [string] ) , ( [string] , ( [number] , [number] , [number] ) , { [string] : [string] } , [string] ) , ( [string] , ( [number] , [number] , [number] ) , { [string] : [string] , [string] : [number] } , [string] ) , ] ) def test_reprcall ( name , args , kwargs , expected ) : [EOL] assert reprcall ( name , args , kwargs ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import typing [EOL] from faust . utils import uuid [EOL] [EOL] [EOL] def test_uuid ( ) : [EOL] seen = set ( ) [EOL] for _ in range ( [number] ) : [EOL] uid = uuid ( ) [EOL] assert uid not in seen [EOL] seen . add ( uid ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] from yarl import URL [EOL] from faust . utils . urls import urllist [EOL] [EOL] [EOL] def test_urllist_URL ( ) : [EOL] assert urllist ( URL ( [string] ) ) == [ URL ( [string] ) ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None , [string] , ] ) def test_urllist_empty_raises ( value ) : [EOL] with pytest . raises ( ValueError ) : [EOL] urllist ( value ) [EOL] [EOL] [EOL] def test_urllist_str ( ) : [EOL] assert urllist ( [string] ) == [ URL ( [string] ) ] [EOL] [EOL] [EOL] def test_urllist_str_no_scheme ( ) : [EOL] assert urllist ( [string] , default_scheme = [string] ) == [ URL ( [string] ) ] [EOL] [EOL] [EOL] def test_urllist_URL_no_scheme_scalar_arg ( ) : [EOL] assert urllist ( URL ( [string] ) , default_scheme = [string] ) == [ URL ( [string] ) , ] [EOL] [EOL] [EOL] def test_urllist_URL_no_scheme_list_arg ( ) : [EOL] assert urllist ( [ URL ( [string] ) , URL ( [string] ) ] , default_scheme = [string] ) == [ URL ( [string] ) , URL ( [string] ) , ] [EOL] [EOL] [EOL] def test_urllist_strsep ( ) : [EOL] assert urllist ( [string] ) == [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) , ] [EOL] [EOL] [EOL] def test_urllist_strsep_no_scheme ( ) : [EOL] assert urllist ( [string] , default_scheme = [string] ) == [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) , ] [EOL] [EOL] [EOL] def test_urllist_list_of_strings ( ) : [EOL] assert urllist ( [ [string] , [string] , ] ) == [ URL ( [string] ) , URL ( [string] ) ] [EOL] [EOL] [EOL] def test_urllist_URLs ( ) : [EOL] assert urllist ( [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) , ] ) == [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) , ] [EOL] [EOL] [EOL] def test_urllist_URLs_no_scheme ( ) : [EOL] assert urllist ( [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) , ] , default_scheme = [string] ) == [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from faust . utils import venusian [EOL] from mode . utils . mocks import Mock , patch [EOL] [EOL] [EOL] def test_attach ( ) : [EOL] callable = Mock ( name = [string] ) [EOL] category = [string] [EOL] with patch ( [string] ) as _attach : [EOL] with patch ( [string] ) as _on_found : [EOL] venusian . attach ( callable , category ) [EOL] _attach . assert_called_with ( callable , _on_found , category = category ) [EOL] [EOL] [EOL] def test_on_found ( ) : [EOL] venusian . _on_found ( Mock ( name = [string] ) , [string] , Mock ( name = [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import decimal [EOL] import faust [EOL] import enum [EOL] from collections import Counter [EOL] from datetime import date , datetime , timezone [EOL] from decimal import Decimal [EOL] from uuid import uuid4 [EOL] from faust . utils . json import JSONEncoder , str_to_decimal [EOL] from hypothesis import assume , given [EOL] from hypothesis . strategies import decimals [EOL] import pytest [EOL] [EOL] [EOL] @ given ( decimals ( ) ) def test_str_to_decimal_decimals ( x ) : [EOL] assume ( x . is_finite ( ) ) [EOL] assert str_to_decimal ( str ( x ) ) == x [EOL] [EOL] [EOL] def test_str_to_decimal_None ( ) : [EOL] assert str_to_decimal ( None ) is None [EOL] [EOL] [EOL] def test_str ( ) : [EOL] d1 = Decimal ( [string] ) [EOL] assert str_to_decimal ( str ( d1 ) ) == d1 [EOL] [EOL] [EOL] def test_maxlen ( ) : [EOL] s = [string] + [string] * [number] [EOL] with pytest . raises ( ValueError ) : [EOL] str_to_decimal ( s ) [EOL] [EOL] [EOL] def test_NaN ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] str_to_decimal ( [string] ) [EOL] [EOL] [EOL] def test_Inf ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] str_to_decimal ( [string] ) [EOL] [EOL] [EOL] def test_negative_Inf ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] str_to_decimal ( [string] ) [EOL] [EOL] [EOL] def test_sNaN ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] str_to_decimal ( [string] ) [EOL] [EOL] [EOL] class Flags ( enum . Enum ) : [EOL] X = [string] [EOL] Y = [string] [EOL] [EOL] [EOL] class CanJson : [EOL] [EOL] def __json__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] def test_JSONEncoder ( ) : [EOL] encoder = JSONEncoder ( ) [EOL] assert encoder . default ( date ( [number] , [number] , [number] ) ) [EOL] assert encoder . default ( datetime . utcnow ( ) ) [EOL] assert encoder . default ( datetime . now ( timezone . utc ) ) [EOL] assert encoder . default ( Counter ( [ ( [string] , [number] ) , ( [string] , [number] ) ] ) ) [EOL] assert encoder . default ( uuid4 ( ) ) [EOL] assert encoder . default ( Flags . X ) == [string] [EOL] assert encoder . default ( Flags . Y ) == [string] [EOL] assert encoder . default ( { [number] , [number] , [number] } ) == [ [number] , [number] , [number] ] [EOL] assert encoder . default ( CanJson ( ) ) == [string] [EOL] with pytest . raises ( TypeError ) : [EOL] encoder . default ( object ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] from pathlib import Path [EOL] import pytest [EOL] from faust import web [EOL] from mode . utils . mocks import Mock [EOL] [EOL] [EOL] class test_Blueprint : [EOL] [EOL] @ pytest . fixture ( ) def bp ( self ) : [EOL] return web . Blueprint ( [string] ) [EOL] [EOL] def test_cache__with_prefix ( self , * , bp ) : [EOL] assert bp . cache ( key_prefix = [string] ) . key_prefix == [string] [EOL] [EOL] def test_apply_static ( self , * , bp ) : [EOL] bp . static ( [string] , [string] , name = [string] ) [EOL] assert bp . static_routes [EOL] route = bp . static_routes [ [number] ] [EOL] assert route . name == [string] [EOL] app = Mock ( name = [string] ) [EOL] bp . register ( app , url_prefix = [string] ) [EOL] app . web . add_static . assert_called_once_with ( [string] , Path ( [string] ) , ) [EOL] [EOL] def test_apply_static__already_prefixed ( self , * , bp ) : [EOL] bp . static ( [string] , [string] , name = [string] ) [EOL] assert bp . static_routes [EOL] route = bp . static_routes [ [number] ] [EOL] assert route . name == [string] [EOL] [EOL] def test_repr ( self , * , bp ) : [EOL] assert repr ( bp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import faust [EOL] from faust . web import exceptions [EOL] [EOL] [EOL] def test_WebError ( ) : [EOL] exc = exceptions . WebError ( detail = [string] , code = [number] ) [EOL] assert exc . detail == [string] [EOL] assert exc . code == [number] [EOL] [EOL] [EOL] def test_WebError_defaults ( ) : [EOL] exc = exceptions . WebError ( ) [EOL] assert exc . detail == exceptions . WebError . detail [EOL] assert exc . code is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Dict , Any , List , MutableMapping [EOL] import faust [EOL] import typing [EOL] from faust . types import TP [EOL] from faust . transport . utils import ( DefaultSchedulingStrategy , TopicBuffer , ) [EOL] [EOL] TP1 = TP ( [string] , [number] ) [EOL] TP2 = TP ( [string] , [number] ) [EOL] TP3 = TP ( [string] , [number] ) [EOL] TP4 = TP ( [string] , [number] ) [EOL] TP5 = TP ( [string] , [number] ) [EOL] [EOL] [EOL] BUF1 = [ [number] , [number] , [number] , [number] , [number] ] [EOL] BUF2 = [ [number] , [number] , [number] , [number] ] [EOL] BUF3 = [ [number] , [number] ] [EOL] BUF4 = [ [number] , [number] , [number] ] [EOL] BUF5 = [ [number] , [number] ] [EOL] [EOL] [EOL] class test_TopicBuffer : [EOL] [EOL] def test_iter ( self ) : [EOL] buffer = TopicBuffer ( ) [EOL] buffer . add ( TP1 , BUF1 ) [EOL] buffer . add ( TP2 , BUF2 ) [EOL] buffer . add ( TP3 , BUF3 ) [EOL] buffer . add ( TP4 , BUF4 ) [EOL] buffer . add ( TP5 , BUF5 ) [EOL] [EOL] consumed = [ ] [EOL] for tp , item in buffer : [EOL] consumed . append ( ( tp , item ) ) [EOL] [EOL] assert consumed == [ ( TP1 , [number] ) , ( TP2 , [number] ) , ( TP3 , [number] ) , ( TP4 , [number] ) , ( TP5 , [number] ) , ( TP1 , [number] ) , ( TP2 , [number] ) , ( TP3 , [number] ) , ( TP4 , [number] ) , ( TP5 , [number] ) , ( TP1 , [number] ) , ( TP2 , [number] ) , ( TP4 , [number] ) , ( TP1 , [number] ) , ( TP2 , [number] ) , ( TP1 , [number] ) , ] [EOL] [EOL] def test_map_from_records ( self ) : [EOL] records = { TP1 : BUF1 , TP2 : BUF2 , TP3 : BUF3 } [EOL] m = DefaultSchedulingStrategy . map_from_records ( records ) [EOL] assert isinstance ( m [ [string] ] , TopicBuffer ) [EOL] buf1 = m [ [string] ] . _buffers [EOL] assert len ( buf1 ) == [number] [EOL] assert list ( buf1 [ TP1 ] ) == BUF1 [EOL] assert list ( buf1 [ TP2 ] ) == BUF2 [EOL] [EOL] assert isinstance ( m [ [string] ] , TopicBuffer ) [EOL] buf2 = m [ [string] ] . _buffers [EOL] assert list ( buf2 [ TP3 ] ) == BUF3 [EOL] [EOL] def test_next ( self ) : [EOL] buffer = TopicBuffer ( ) [EOL] buffer . add ( TP1 , BUF1 ) [EOL] [EOL] consumed = [ ] [EOL] while True : [EOL] try : [EOL] consumed . append ( next ( buffer ) ) [EOL] except StopIteration : [EOL] break [EOL] assert consumed == [ ( TP1 , [number] ) , ( TP1 , [number] ) , ( TP1 , [number] ) , ( TP1 , [number] ) , ( TP1 , [number] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.transport.utils.TopicBuffer$ 0 0 0 0 0 $faust.transport.utils.TopicBuffer$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 $faust.transport.utils.TopicBuffer$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 $faust.transport.utils.TopicBuffer$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 $faust.transport.utils.TopicBuffer$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 $faust.transport.utils.TopicBuffer$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $faust.transport.utils.TopicBuffer$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[builtins.int]]$ 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 $typing.MutableMapping[builtins.str,faust.transport.utils.TopicBuffer]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[builtins.int]]$ 0 0 0 0 0 $typing.MutableMapping[builtins.str,faust.transport.utils.TopicBuffer]$ 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,faust.transport.utils.TopicBuffer]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.MutableMapping[builtins.str,faust.transport.utils.TopicBuffer]$ 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,faust.transport.utils.TopicBuffer]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $faust.transport.utils.TopicBuffer$ 0 0 0 0 0 $faust.transport.utils.TopicBuffer$ 0 0 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $faust.transport.utils.TopicBuffer$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from mode . utils . mocks import AsyncMock , Mock , call [EOL] from faust . transport . producer import Producer , ProducerBuffer [EOL] [EOL] [EOL] class test_ProducerBuffer : [EOL] [EOL] @ pytest . fixture ( ) def buf ( self ) : [EOL] return ProducerBuffer ( ) [EOL] [EOL] def test_put ( self , * , buf ) : [EOL] fut = Mock ( name = [string] ) [EOL] buf . pending = Mock ( name = [string] ) [EOL] buf . put ( fut ) [EOL] [EOL] buf . pending . put_nowait . assert_called_once_with ( fut ) [EOL] [EOL] @ pytest . mark . asyncio async def test_on_stop ( self , * , buf ) : [EOL] buf . flush = AsyncMock ( name = [string] ) [EOL] await buf . on_stop ( ) [EOL] buf . flush . coro . assert_called_once_with ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test__send_pending ( self , * , buf ) : [EOL] fut = Mock ( name = [string] ) [EOL] fut . message . channel . publish_message = AsyncMock ( ) [EOL] await buf . _send_pending ( fut ) [EOL] fut . message . channel . publish_message . coro . assert_called_once_with ( fut , wait = False , ) [EOL] [EOL] @ pytest . mark . asyncio async def test__handle_pending ( self , * , buf ) : [EOL] buf . pending = Mock ( get = AsyncMock ( ) ) [EOL] buf . _send_pending = AsyncMock ( ) [EOL] [EOL] async def on_send ( fut ) : [EOL] if buf . _send_pending . call_count >= [number] : [EOL] buf . _stopped . set ( ) [EOL] [EOL] buf . _send_pending . side_effect = on_send [EOL] [EOL] await buf . _handle_pending ( buf ) [EOL] [EOL] buf . _send_pending . assert_has_calls ( [ call ( buf . pending . get . coro . return_value ) , call ( buf . pending . get . coro . return_value ) , ] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_wait_until_ebb ( self , * , buf ) : [EOL] buf . max_messages = [number] [EOL] buf . _send_pending = AsyncMock ( ) [EOL] self . _put ( buf , range ( [number] ) ) [EOL] assert buf . size == [number] [EOL] [EOL] await buf . wait_until_ebb ( ) [EOL] assert list ( buf . pending . _queue ) == list ( range ( [number] , [number] ) ) [EOL] assert buf . size == [number] [EOL] [EOL] await buf . wait_until_ebb ( ) [EOL] assert list ( buf . pending . _queue ) == list ( range ( [number] , [number] ) ) [EOL] assert buf . size == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_flush ( self , * , buf ) : [EOL] buf . _send_pending = AsyncMock ( ) [EOL] assert not buf . size [EOL] await buf . flush ( ) [EOL] [EOL] self . _put ( buf , range ( [number] ) ) [EOL] assert buf . size == [number] [EOL] [EOL] await buf . flush ( ) [EOL] assert not buf . size [EOL] [EOL] def _put ( self , buf , items ) : [EOL] for item in items : [EOL] buf . pending . put_nowait ( item ) [EOL] [EOL] @ pytest . mark . asyncio async def test_flush_atmost ( self , * , buf ) : [EOL] buf . _send_pending = AsyncMock ( ) [EOL] assert await buf . flush_atmost ( [number] ) == [number] [EOL] [EOL] self . _put ( buf , range ( [number] ) ) [EOL] assert buf . size == [number] [EOL] assert await buf . flush_atmost ( [number] ) == [number] [EOL] [EOL] self . _put ( buf , range ( [number] ) ) [EOL] assert buf . size == [number] [EOL] assert ( await buf . flush_atmost ( [number] ) ) == [number] [EOL] assert buf . size == [number] [EOL] [EOL] assert ( await buf . flush_atmost ( [number] ) ) == [number] [EOL] assert not buf . size [EOL] [EOL] [EOL] class ProducerTests : [EOL] [EOL] @ pytest . mark . asyncio async def test_send ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . send ( [string] , [string] , [string] , [number] , None , { } ) [EOL] [EOL] def test_send_soon ( self , * , producer ) : [EOL] producer . buffer = Mock ( name = [string] ) [EOL] fut = Mock ( name = [string] ) [EOL] producer . send_soon ( fut ) [EOL] producer . buffer . put . assert_called_once_with ( fut ) [EOL] [EOL] @ pytest . mark . asyncio async def test_flush ( self , * , producer ) : [EOL] await producer . flush ( ) [EOL] [EOL] @ pytest . mark . asyncio async def test_send_and_wait ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . send_and_wait ( [string] , [string] , [string] , [number] , None , { } ) [EOL] [EOL] @ pytest . mark . asyncio async def test_create_topic ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . create_topic ( [string] , [number] , [number] ) [EOL] [EOL] def test_key_partition ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] producer . key_partition ( [string] , [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_begin_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . begin_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . commit_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_abort_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . abort_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_stop_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . stop_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_maybe_begin_transaction ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . maybe_begin_transaction ( [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_commit_transactions ( self , * , producer ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] await producer . commit_transactions ( { } , [string] ) [EOL] [EOL] def test_supports_headers ( self , * , producer ) : [EOL] assert not producer . supports_headers ( ) [EOL] [EOL] [EOL] class test_Producer ( ProducerTests ) : [EOL] [EOL] @ pytest . fixture def producer ( self , * , app ) : [EOL] return Producer ( app . transport ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Set , Any , Dict , MutableMapping , Counter [EOL] import faust [EOL] import typing [EOL] import collections [EOL] import builtins [EOL] import copy [EOL] from collections import Counter [EOL] from typing import MutableMapping [EOL] from faust . assignor . client_assignment import CopartitionedAssignment [EOL] from faust . assignor . copartitioned_assignor import CopartitionedAssignor [EOL] from hypothesis import assume , given , settings [EOL] from hypothesis . strategies import integers [EOL] [EOL] TEST_DEADLINE = [number] [EOL] [EOL] [EOL] _topics = { [string] , [string] , [string] } [EOL] [EOL] [EOL] def is_valid ( cli_assignments , num_partitions , replicas ) : [EOL] all_partitions = set ( range ( num_partitions ) ) [EOL] active_counts = Counter ( partition for assignment in cli_assignments . values ( ) for partition in assignment . actives ) [EOL] assert all ( count == [number] for count in active_counts . values ( ) ) , [string] [EOL] assert set ( active_counts . keys ( ) ) == all_partitions [EOL] standby_counts = Counter ( partition for assignment in cli_assignments . values ( ) for partition in assignment . standbys ) [EOL] assert all ( count == replicas for count in standby_counts . values ( ) ) , [string] [EOL] assert not replicas or set ( standby_counts . keys ( ) ) == all_partitions [EOL] return True [EOL] [EOL] [EOL] def client_addition_sticky ( old , new , ) : [EOL] assert all ( partition in old [ client ] . actives for client in old for partition in new [ client ] . actives ) [EOL] return True [EOL] [EOL] [EOL] def client_removal_sticky ( old , new , ) : [EOL] removed = set ( old ) . difference ( set ( new ) ) [EOL] reassigned_partitions = { partition for client , assignment in old . items ( ) for partition in assignment . actives if client in removed } [EOL] assert all ( partition in old [ client ] . actives or partition in reassigned_partitions for client in new for partition in new [ client ] . actives ) [EOL] return True [EOL] [EOL] [EOL] @ given ( partitions = integers ( min_value = [number] , max_value = [number] ) , replicas = integers ( min_value = [number] , max_value = [number] ) , num_clients = integers ( min_value = [number] , max_value = [number] ) ) @ settings ( deadline = TEST_DEADLINE ) def test_fresh_assignment ( partitions , replicas , num_clients ) : [EOL] assume ( replicas < num_clients ) [EOL] client_assignments = { str ( client ) : CopartitionedAssignment ( topics = _topics ) for client in range ( num_clients ) } [EOL] new_assignments = CopartitionedAssignor ( _topics , client_assignments , partitions , replicas = replicas ) . get_assignment ( ) [EOL] assert is_valid ( new_assignments , partitions , replicas ) [EOL] [EOL] [EOL] @ given ( partitions = integers ( min_value = [number] , max_value = [number] ) , replicas = integers ( min_value = [number] , max_value = [number] ) , num_clients = integers ( min_value = [number] , max_value = [number] ) , num_additional_clients = integers ( min_value = [number] , max_value = [number] ) ) @ settings ( deadline = TEST_DEADLINE ) def test_add_new_clients ( partitions , replicas , num_clients , num_additional_clients ) : [EOL] assume ( replicas < num_clients and num_additional_clients < num_clients ) [EOL] client_assignments = { str ( client ) : CopartitionedAssignment ( topics = _topics ) for client in range ( num_clients ) } [EOL] valid_assignment = CopartitionedAssignor ( _topics , client_assignments , partitions , replicas = replicas ) . get_assignment ( ) [EOL] old_assignments = copy . deepcopy ( valid_assignment ) [EOL] [EOL] [comment] [EOL] for client in range ( num_clients , num_clients + num_additional_clients ) : [EOL] valid_assignment [ str ( client ) ] = CopartitionedAssignment ( topics = _topics ) [EOL] [EOL] new_assignments = CopartitionedAssignor ( _topics , valid_assignment , partitions , replicas = replicas , ) . get_assignment ( ) [EOL] [EOL] assert is_valid ( new_assignments , partitions , replicas ) [EOL] assert client_addition_sticky ( old_assignments , new_assignments ) [EOL] [EOL] [EOL] @ given ( partitions = integers ( min_value = [number] , max_value = [number] ) , replicas = integers ( min_value = [number] , max_value = [number] ) , num_clients = integers ( min_value = [number] , max_value = [number] ) , num_removal_clients = integers ( min_value = [number] , max_value = [number] ) ) @ settings ( deadline = TEST_DEADLINE ) def test_remove_clients ( partitions , replicas , num_clients , num_removal_clients ) : [EOL] assume ( num_removal_clients < num_clients and replicas < ( num_clients - num_removal_clients ) ) [EOL] client_assignments = { str ( client ) : CopartitionedAssignment ( topics = _topics ) for client in range ( num_clients ) } [EOL] valid_assignment = CopartitionedAssignor ( _topics , client_assignments , partitions , replicas = replicas ) . get_assignment ( ) [EOL] old_assignments = copy . deepcopy ( valid_assignment ) [EOL] [EOL] [comment] [EOL] for client in range ( num_clients - num_removal_clients , num_clients ) : [EOL] del valid_assignment [ str ( client ) ] [EOL] [EOL] new_assignments = CopartitionedAssignor ( _topics , valid_assignment , partitions , replicas = replicas , ) . get_assignment ( ) [EOL] [EOL] assert is_valid ( new_assignments , partitions , replicas ) [EOL] assert client_removal_sticky ( old_assignments , new_assignments ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] def test_json ( faust_json ) : [EOL] exitcode , models , stderr = faust_json ( [string] , [string] ) [EOL] assert not exitcode [EOL] [EOL] assert { [string] : [string] , [string] : [string] } in models [EOL] assert { [string] : [string] , [string] : [string] } in models [EOL] assert { [string] : [string] , [string] : [string] } in models [EOL] [EOL] names = [ model [ [string] ] for model in models ] [EOL] assert ( names . index ( [string] ) < names . index ( [string] ) < names . index ( [string] ) ) [comment] [EOL] [EOL] [EOL] def test_tabulated ( faust ) : [EOL] exitcode , stdout , stderr = faust ( [string] , [string] ) [EOL] assert not exitcode [EOL] assert [string] in stdout [EOL] [EOL] [EOL] def test_colors ( faust_color ) : [EOL] exitcode , stdout , stderr = faust_color ( [string] , [string] ) [EOL] assert not exitcode [EOL] assert [string] in stdout [EOL] [EOL] [EOL] def test_json_no_local ( faust_json ) : [EOL] exitcode , models , stderr = faust_json ( [string] ) [EOL] assert not exitcode [EOL] [EOL] names = [ model [ [string] ] for model in models ] [EOL] assert [string] in names [EOL] assert [string] in names [EOL] assert names . index ( [string] ) < names . index ( [string] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
def test_command_returns_nonzero_exit_status ( * , faust ) : [EOL] exitcode , stdout , stderr = faust ( [string] ) [EOL] assert not stdout [EOL] assert stderr [EOL] assert exitcode [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , AsyncIterator [EOL] import typing [EOL] from typing import Any , AsyncIterator [EOL] import faust [EOL] [EOL] app = faust . App ( [string] ) [EOL] rpc_topic = app . topic ( [string] ) [EOL] [EOL] [EOL] @ app . agent ( rpc_topic , concurrency = [number] ) async def simple ( it ) : [EOL] async for value in it : [EOL] yield value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.AsyncIterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Tuple , Any , Dict , List [EOL] import typing [EOL] import t [EOL] import asyncio [EOL] from collections import defaultdict [EOL] from aiokafka import AIOKafkaClient , AIOKafkaConsumer [EOL] from faust . utils import json [EOL] from kafka . protocol . commit import ( GroupCoordinatorRequest_v0 , OffsetFetchRequest_v1 , ) [EOL] from kafka . structs import TopicPartition [EOL] [EOL] [EOL] class MissingDataException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] bootstrap_servers = [string] [EOL] [EOL] [EOL] class BaseKafkaTableBuilder ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , topic , loop ) : [EOL] self . topic = topic [EOL] self . consumer = None [EOL] self . messages = [ ] [EOL] self . loop = loop [EOL] self . table = defaultdict ( int ) [EOL] self . key_tps = defaultdict ( set ) [EOL] self . _assignment = None [EOL] [EOL] async def build ( self ) : [EOL] await self . _init_consumer ( ) [EOL] await self . _build_table ( ) [EOL] [EOL] def get_key ( self , message ) : [EOL] return json . loads ( message . key . decode ( ) ) [EOL] [EOL] def get_value ( self , message ) : [EOL] return json . loads ( message . value . decode ( ) ) [EOL] [EOL] async def _init_consumer ( self ) : [EOL] if not self . consumer : [EOL] self . consumer = AIOKafkaConsumer ( self . topic , loop = self . loop , bootstrap_servers = bootstrap_servers , auto_offset_reset = [string] , ) [EOL] await self . consumer . start ( ) [EOL] self . _assignment = self . consumer . assignment ( ) [EOL] [EOL] async def _build_table ( self ) : [EOL] while True : [EOL] message = await self . consumer . getone ( ) [EOL] self . messages . append ( message ) [EOL] await self . _apply ( message ) [EOL] if await self . _positions ( ) == self . _highwaters ( ) : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] async def _apply ( self , message ) : [EOL] print ( message ) [EOL] [EOL] async def _positions ( self ) : [EOL] assert self . consumer [EOL] return { tp : await self . consumer . position ( tp ) for tp in self . _assignment } [EOL] [EOL] def _highwaters ( self ) : [EOL] assert self . consumer [EOL] return { tp : self . consumer . highwater ( tp ) for tp in self . _assignment } [EOL] [EOL] [EOL] class ChangelogTableBuilder ( BaseKafkaTableBuilder ) : [EOL] [EOL] async def _apply ( self , message ) : [EOL] k = self . get_key ( message ) [EOL] v = self . get_value ( message ) [EOL] self . table [ k ] = v [EOL] self . key_tps [ k ] . add ( message . partition ) [EOL] [EOL] [EOL] class SourceTableBuilder ( BaseKafkaTableBuilder ) : [EOL] [EOL] async def _apply ( self , message ) : [EOL] k = self . get_key ( message ) [EOL] v = self . get_value ( message ) [EOL] self . table [ k ] += v [ [string] ] [EOL] self . key_tps [ k ] . add ( message . partition ) [EOL] [EOL] [EOL] class ConsistencyChecker ( object ) : [EOL] [EOL] def __init__ ( self , source , changelog , loop ) : [EOL] self . source = source [EOL] self . loop = loop [EOL] self . client = AIOKafkaClient ( bootstrap_servers = bootstrap_servers , loop = self . loop ) [EOL] self . _source_builder = SourceTableBuilder ( source , loop ) [EOL] self . changelog = changelog [EOL] self . _changelog_builder = ChangelogTableBuilder ( changelog , loop ) [EOL] [EOL] async def build_source ( self ) : [EOL] await self . _source_builder . build ( ) [EOL] [EOL] async def build_changelog ( self ) : [EOL] await self . _changelog_builder . build ( ) [EOL] [EOL] async def wait_no_lag ( self ) : [EOL] print ( [string] ) [EOL] consumer_group = [string] [EOL] client = self . client [EOL] await self . client . bootstrap ( ) [EOL] source = self . source [EOL] source_builder = self . _source_builder [EOL] [EOL] source_highwaters = source_builder . _highwaters ( ) [EOL] source_tps = source_builder . _assignment [EOL] protocol_tps = [ ( source , [ tp . partition for tp in source_tps ] ) ] [EOL] [EOL] node_id = next ( broker . nodeId for broker in client . cluster . brokers ( ) ) [EOL] coordinator_request = GroupCoordinatorRequest_v0 ( consumer_group ) [EOL] coordinator_response = await client . send ( node_id , coordinator_request ) [EOL] coordinator_id = coordinator_response . coordinator_id [EOL] [EOL] while True : [EOL] consumer_offsets_req = OffsetFetchRequest_v1 ( consumer_group , protocol_tps ) [EOL] consumer_offsets_resp = await client . send ( coordinator_id , consumer_offsets_req ) [EOL] topics = consumer_offsets_resp . topics [EOL] assert len ( topics ) == [number] , f'{ topics !r}' [EOL] topic , partition_resps = topics [ [number] ] [EOL] assert topic == source , f'{ source }' [EOL] assert len ( partition_resps ) == len ( source_tps ) [EOL] [EOL] [comment] [EOL] positions = { TopicPartition ( topic = source , partition = partition ) : offset + [number] for partition , offset , _ , _ in partition_resps } [EOL] [EOL] if positions != source_highwaters : [EOL] print ( [string] ) [EOL] await asyncio . sleep ( [number] ) [EOL] else : [EOL] return [EOL] [EOL] async def check_consistency ( self ) : [EOL] self . _analyze ( ) [EOL] self . _assert_results ( ) [EOL] [EOL] def _analyze ( self ) : [EOL] res = self . _changelog_builder . table [EOL] truth = self . _source_builder . table [EOL] print ( [string] . format ( len ( res ) , len ( truth ) ) ) [EOL] print ( [string] . format ( set ( res ) . issubset ( truth ) ) ) [EOL] [EOL] self . _analyze_keys ( ) [EOL] self . _analyze_key_partitions ( ) [EOL] [EOL] def _analyze_keys ( self ) : [EOL] res = self . _changelog_builder . table [EOL] truth = self . _source_builder . table [EOL] [EOL] [comment] [EOL] keys_same = True [EOL] for key in res : [EOL] if truth [ key ] != res [ key ] : [EOL] keys_same = False [EOL] break [EOL] print ( [string] . format ( keys_same ) ) [EOL] diff_keys = [ k for k in res if truth [ k ] != res [ k ] ] [EOL] print ( [string] . format ( len ( diff_keys ) ) ) [EOL] [EOL] for key in diff_keys : [EOL] self . _analyze_non_atomic_commit ( key ) [EOL] [EOL] def _get_messages_for_key ( self , key ) : [EOL] source_messages = [ message for message in self . _source_builder . messages if self . _source_builder . get_key ( message ) == key ] [EOL] cl_messages = [ message for message in self . _changelog_builder . messages if self . _changelog_builder . get_key ( message ) == key ] [EOL] return source_messages , cl_messages [EOL] [EOL] def _analyze_non_atomic_commit ( self , key ) : [EOL] print ( [string] . format ( key ) ) [EOL] source_messages , cl_messages = self . _get_messages_for_key ( key ) [EOL] print ( [string] . format ( len ( source_messages ) , len ( cl_messages ) ) ) [EOL] cl_pos = source_sum = [number] [EOL] for i , message in enumerate ( source_messages ) : [EOL] source_sum += self . _source_builder . get_value ( message ) [ [string] ] [EOL] while True : [EOL] cl_sum = self . _changelog_builder . get_value ( cl_messages [ cl_pos ] ) [EOL] if cl_sum > source_sum : [EOL] print ( [string] [string] . format ( i , cl_pos ) ) [EOL] return [EOL] elif cl_sum == source_sum : [EOL] break [EOL] cl_pos += [number] [EOL] if cl_pos >= len ( cl_messages ) : [EOL] raise MissingDataException [EOL] [EOL] def _analyze_key_partitions ( self ) : [EOL] res_kps = self . _changelog_builder . key_tps [EOL] truth_kps = self . _source_builder . key_tps [EOL] [EOL] [comment] [EOL] print ( [string] . format ( res_kps . keys ( ) == truth_kps . keys ( ) ) ) [EOL] diff_kps = [ ( key , truth_kps [ key ] , res_kps [ key ] ) for key in truth_kps if truth_kps [ key ] != res_kps [ key ] ] [EOL] print ( [string] . format ( not diff_kps ) ) [EOL] [EOL] def _assert_results ( self ) : [EOL] res = self . _changelog_builder . table [EOL] truth = self . _source_builder . table [EOL] res_kps = self . _changelog_builder . key_tps [EOL] truth_kps = self . _source_builder . key_tps [EOL] assert res == truth , [string] [EOL] assert res_kps == truth_kps , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $t.consistency.consistency_checker.SourceTableBuilder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.consistency.consistency_checker.ChangelogTableBuilder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.consistency.consistency_checker.SourceTableBuilder$ 0 0 0 0 0 0 $typing.Any$ 0 $t.consistency.consistency_checker.SourceTableBuilder$ 0 0 0 0 0 0 0 $t.consistency.consistency_checker.SourceTableBuilder$ 0 0 0 $typing.List[typing.Tuple[unknown,typing.list]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[unknown,typing.list]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import t [EOL] import asyncio [EOL] import asyncio [EOL] import os [EOL] import random [EOL] import subprocess [EOL] import sys [EOL] from t . consistency . consistency_checker import ConsistencyChecker [EOL] [EOL] [EOL] class Stresser ( object ) : [EOL] [EOL] def __init__ ( self , num_workers , num_producers , loop ) : [EOL] self . workers = set ( range ( num_workers ) ) [EOL] self . _worker_procs = { } [EOL] self . num_workers = num_workers [EOL] self . num_producers = num_producers [EOL] self . producers = set ( range ( num_producers ) ) [EOL] self . _producer_procs = { } [EOL] self . loop = loop [EOL] self . _stop_stresser = asyncio . Event ( loop = loop ) [EOL] [EOL] @ property def _stopped ( self ) : [EOL] return self . workers - self . _running [EOL] [EOL] @ property def _running ( self ) : [EOL] return set ( self . _worker_procs ) [EOL] [EOL] @ property def _stopped_producers ( self ) : [EOL] return self . producers - self . _running_producers [EOL] [EOL] @ property def _running_producers ( self ) : [EOL] return set ( self . _producer_procs ) [EOL] [EOL] async def _run_stresser ( self ) : [EOL] print ( [string] ) [EOL] while not self . _stop_stresser . is_set ( ) : [EOL] print ( [string] ) [EOL] if self . _should ( ) : [EOL] await self . _maybe_stop_worker ( ) [EOL] if self . _should ( ) : [EOL] await self . _maybe_spawn_worker ( ) [EOL] await asyncio . sleep ( random . uniform ( [number] , [number] ) ) [EOL] [EOL] def stop_stresser ( self ) : [EOL] print ( [string] ) [EOL] self . _stop_stresser . set ( ) [EOL] [EOL] def _should ( self ) : [EOL] return ( random . choices ( [ True , False ] , [ [number] , [number] ] , k = [number] ) [ [number] ] and not self . _stop_stresser . is_set ( ) ) [EOL] [EOL] async def _maybe_stop_worker ( self ) : [EOL] print ( [string] ) [EOL] if len ( self . _running ) > [number] : [EOL] await self . _stop_worker ( random . choice ( list ( self . _running ) ) ) [EOL] [EOL] async def _maybe_spawn_worker ( self ) : [EOL] print ( [string] ) [EOL] if self . _stopped : [EOL] await self . _start_worker ( random . choice ( list ( self . _stopped ) ) ) [EOL] [EOL] async def start ( self , stopped_at_start = [number] ) : [EOL] assert stopped_at_start < self . num_workers [EOL] start_workers = random . sample ( list ( self . workers ) , self . num_workers - stopped_at_start ) [EOL] print ( f' [string] { start_workers !r}' ) [EOL] await asyncio . wait ( [ self . _start_producer ( producer ) for producer in self . producers ] ) [EOL] await asyncio . wait ( [ self . _start_worker ( worker ) for worker in start_workers ] , loop = self . loop , return_when = asyncio . ALL_COMPLETED ) [EOL] asyncio . ensure_future ( self . _run_stresser ( ) , loop = self . loop ) [EOL] [EOL] async def _start_worker ( self , worker ) : [EOL] assert worker in self . workers [EOL] with open ( f' [string] { worker } [string] ' , [string] ) as f : [EOL] if worker not in self . _worker_procs : [EOL] print ( f' [string] { worker }' ) [EOL] self . _worker_procs [ worker ] = await self . _exec_worker ( web_port = [number] + worker , stdout = f , ) [EOL] [EOL] async def _exec_worker ( self , module = [string] , app = [string] , loglevel = [string] , web_port = [number] , stdout = None , stderr = subprocess . STDOUT , ** kwargs ) : [EOL] return await asyncio . create_subprocess_exec ( sys . executable , [string] , module , [string] , app , [string] , [string] , loglevel , [string] , str ( web_port ) , stdout = stdout , stderr = stderr , env = { ** os . environ , ** { [string] : [string] } } , ** kwargs ) [EOL] [EOL] async def stop_all ( self ) : [EOL] await asyncio . wait ( [ self . _stop_worker ( worker ) for worker in self . _running ] , loop = self . loop , return_when = asyncio . ALL_COMPLETED , ) [EOL] [EOL] async def stop_all_producers ( self ) : [EOL] await asyncio . wait ( [ self . _stop_producer ( producer ) for producer in self . _running_producers ] , loop = self . loop , return_when = asyncio . ALL_COMPLETED , ) [EOL] [EOL] async def _stop_worker ( self , worker ) : [EOL] assert worker in self . workers [EOL] print ( f' [string] { worker }' ) [EOL] proc = self . _worker_procs . pop ( worker ) [EOL] await self . _stop_process ( proc ) [EOL] [EOL] async def _start_producer ( self , producer ) : [EOL] assert producer in self . producers [EOL] if producer not in self . _producer_procs : [EOL] with open ( f' [string] { producer } [string] ' , [string] ) as f : [EOL] print ( f' [string] { producer }' ) [EOL] self . _producer_procs [ producer ] = await self . _exec_producer ( stdout = f , ) [EOL] [EOL] async def _exec_producer ( self , path = [string] , loglevel = [string] , stdout = None , stderr = subprocess . STDOUT , ** kwargs ) : [EOL] return await asyncio . create_subprocess_exec ( sys . executable , path , [string] , [string] , loglevel , stdout = stdout , stderr = stderr , ** kwargs ) [EOL] [EOL] async def _stop_producer ( self , producer ) : [EOL] assert producer in self . producers [EOL] print ( f' [string] { producer }' ) [EOL] proc = self . _producer_procs . pop ( producer ) [EOL] await self . _stop_process ( proc ) [EOL] [EOL] async def _stop_process ( self , proc ) : [EOL] try : [EOL] proc . terminate ( ) [EOL] except ProcessLookupError : [EOL] pass [EOL] await proc . wait ( ) [EOL] [EOL] [EOL] async def test_consistency ( loop ) : [EOL] stresser = Stresser ( num_workers = [number] , num_producers = [number] , loop = loop ) [EOL] checker = ConsistencyChecker ( [string] , [string] , loop = loop ) [EOL] print ( [string] ) [EOL] await stresser . start ( stopped_at_start = [number] ) [EOL] print ( [string] ) [EOL] await asyncio . sleep ( [number] ) [comment] [EOL] print ( [string] ) [EOL] await stresser . stop_all_producers ( ) [EOL] await checker . build_source ( ) [EOL] print ( [string] ) [EOL] await asyncio . sleep ( [number] ) [EOL] stresser . stop_stresser ( ) [EOL] await checker . wait_no_lag ( ) [EOL] print ( [string] ) [EOL] await stresser . stop_all ( ) [EOL] await checker . build_changelog ( ) [EOL] await checker . check_consistency ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( test_consistency ( loop ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.locks.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0
from typing import Any , Set [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] import random [EOL] import sys [EOL] from typing import Any , Set [EOL] from faust . cli import option [EOL] from mode . utils . aiter import aiter , anext [EOL] [EOL] [EOL] def install_produce_command ( app ) : [EOL] @ app . command ( option ( [string] , type = float , default = [number] , envvar = [string] , help = [string] ) , option ( [string] , type = int , default = None , help = [string] ) , ) async def produce ( self , max_latency , max_messages ) : [EOL] [docstring] [EOL] prods = { aiter ( p ( max_messages ) ) for p in app . stress_producers } [EOL] i = [number] [EOL] while not app . should_stop : [EOL] to_remove = set ( ) [EOL] for producer in prods : [EOL] i += [number] [EOL] try : [EOL] await anext ( producer ) [EOL] except StopAsyncIteration : [EOL] to_remove . add ( producer ) [EOL] if not max_latency : [EOL] [comment] [EOL] if not i % [number] : [EOL] self . say ( f' [string] { i }' ) [EOL] else : [EOL] [comment] [EOL] if not i % [number] : [EOL] self . say ( f' [string] { i }' ) [EOL] if not prods : [EOL] await asyncio . sleep ( [number] ) [EOL] if max_latency : [EOL] await asyncio . sleep ( random . uniform ( [number] , max_latency ) ) [EOL] for producer in to_remove : [EOL] prods . discard ( producer ) [EOL] print ( [string] , file = sys . stderr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] import random [EOL] from datetime import datetime , timezone [EOL] from itertools import count [EOL] import faust [EOL] [EOL] [EOL] class Withdrawal ( faust . Record , isodates = True , serializer = [string] ) : [EOL] user = ... [EOL] country = ... [EOL] amount = ... [EOL] date = None [EOL] [EOL] [EOL] def generate_withdrawals ( n = None ) : [EOL] for d in generate_withdrawals_dict ( n ) : [EOL] yield Withdrawal ( ** d ) [EOL] [EOL] [EOL] def generate_withdrawals_dict ( n = None ) : [EOL] num_countries = [number] [EOL] countries = [ f' [string] { i }' for i in range ( num_countries ) ] [EOL] country_dist = [ [number] ] + ( [ [number] / num_countries ] * ( num_countries - [number] ) ) [EOL] num_users = [number] [EOL] users = [ f' [string] { i }' for i in range ( num_users ) ] [EOL] for _ in range ( n ) if n is not None else count ( ) : [EOL] yield { [string] : random . choice ( users ) , [string] : random . uniform ( [number] , [number] ) , [string] : random . choices ( countries , country_dist ) [ [number] ] , [string] : datetime . utcnow ( ) . replace ( tzinfo = timezone . utc ) . isoformat ( ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import t [EOL] import random [EOL] import signal [EOL] from itertools import cycle [EOL] from typing import List , NamedTuple [EOL] [EOL] import envoy [EOL] from mode import Service , Worker [EOL] [EOL] [EOL] class Span ( NamedTuple ) : [EOL] length = ... [EOL] signals = ... [EOL] min_sleep = ... [EOL] max_sleep = ... [EOL] [EOL] def seconds_to_sleep ( self ) : [EOL] return random . uniform ( self . min_sleep , self . max_sleep ) [EOL] [EOL] [EOL] class Chaos ( Service ) : [EOL] [EOL] schedule = [ Span ( [number] , signals = [ signal . SIGTERM , signal . SIGINT ] , min_sleep = [number] , max_sleep = [number] , ) , Span ( [number] , signals = [ signal . SIGTERM ] , min_sleep = [number] , max_sleep = [number] , ) , Span ( [number] , signals = [ signal . SIGKILL ] , min_sleep = [number] , max_sleep = [number] , ) , ] [EOL] [EOL] def iterate_over_scheduled_time ( self ) : [EOL] for period in cycle ( self . schedule ) : [EOL] for _ in range ( period . length ) : [EOL] yield period [EOL] [EOL] @ Service . task async def _runs_in_background ( self ) : [EOL] self . log . info ( [string] ) [EOL] self . log . info ( [string] ) [EOL] for current_span in self . iterate_over_scheduled_time ( ) : [EOL] if self . should_stop : [EOL] return [EOL] secs = current_span . seconds_to_sleep ( ) [EOL] self . log . info ( [string] , secs ) [EOL] await self . sleep ( secs ) [EOL] sig = random . choice ( current_span . signals ) [EOL] self . log . warning ( [string] , sig ) [EOL] r = envoy . run ( f' [string] { int ( sig ) } [string] ' ) [EOL] if r . status_code : [EOL] if r . std_err . strip ( ) : [EOL] self . log . error ( [string] , r . std_err ) [EOL] else : [EOL] self . log . info ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] Worker ( Chaos ( ) , loglevel = [string] ) . execute_from_commandline ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[t.stress.killer.Span]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import DefaultDict , Set , Any , Dict , List , Counter [EOL] import jinja2 [EOL] import typing [EOL] import t [EOL] import collections [EOL] from collections import Counter , defaultdict [EOL] from . import states [EOL] from . app import get_error_topic , get_reporting_app , get_reporting_topic [EOL] from . web import env [EOL] [EOL] app = get_reporting_app ( ) [EOL] [EOL] error_topic = get_error_topic ( app ) [EOL] reporting_topic = get_reporting_topic ( app ) [EOL] [EOL] report_index = { } [EOL] report_by_category = defaultdict ( lambda : defaultdict ( dict ) ) [EOL] unique_servers = set ( ) [EOL] state_counts = Counter ( ) [EOL] [EOL] errors = defaultdict ( lambda : defaultdict ( list ) ) [EOL] [EOL] color_for_state = { states . OK : [string] , states . FAIL : [string] , states . SLOW : [string] , states . STALL : [string] , states . UNASSIGNED : [string] , states . REBALANCING : [string] , states . PAUSED : [string] , } [EOL] [EOL] [EOL] @ app . agent ( reporting_topic ) async def process_report ( reports ) : [EOL] async for r in reports : [EOL] report_by_category [ r . app_id ] [ r . category ] [ r . hostname ] = r . details [EOL] previous = report_index . get ( r . key ) [EOL] report_index [ r . key ] = r [EOL] if previous is not None and previous . state != r . state : [EOL] print ( f'{ r . key } [string] { previous . state } [string] { r . state }' ) [EOL] unique_servers . add ( ( r . app_id , r . hostname ) ) [EOL] state_counts [ r . state ] += [number] [EOL] [EOL] [EOL] @ app . agent ( error_topic ) async def process_error ( stream ) : [EOL] async for error in stream : [EOL] errors [ error . app_id ] [ error . hostname ] . append ( error ) [EOL] [EOL] [EOL] @ app . page ( [string] ) async def dashboard ( web , request , template_name = [string] ) : [EOL] template = env . get_template ( template_name ) [EOL] return web . html ( template . render ( { [string] : len ( unique_servers ) , [string] : report_by_category , [string] : errors , [string] : [ { [string] : state , [string] : count , [string] : color_for_state [ state ] , } for state , count in state_counts . items ( ) ] , } ) ) [EOL] [EOL] [EOL] @ app . page ( [string] ) async def dashboard_json ( web , request ) : [EOL] return web . json ( { [string] : report_by_category } ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.DefaultDict[typing.Any,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.DefaultDict[typing.Any,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.DefaultDict[typing.Any,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import jinja2 [EOL] from jinja2 import Environment , PackageLoader , select_autoescape [EOL] [EOL] env = Environment ( loader = PackageLoader ( [string] , [string] ) , autoescape = select_autoescape ( [ [string] , [string] ] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import typing [EOL] OK = [string] [EOL] FAIL = [string] [EOL] SLOW = [string] [EOL] STALL = [string] [EOL] UNASSIGNED = [string] [EOL] REBALANCING = [string] [EOL] PAUSED = [string] [EOL] [EOL] OK_STATES = { OK , UNASSIGNED } [EOL] MAYBE_STATES = { REBALANCING , PAUSED } [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Set[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] import models [EOL] import builtins [EOL] import socket [EOL] import faust [EOL] from . import states [EOL] from . models import Error , Status [EOL] [EOL] REPORT_TOPIC_NAME = [string] [EOL] ERRORS_TOPIC_NAME = [string] [EOL] [EOL] [EOL] def get_reporting_topic ( app ) : [EOL] return app . topic ( REPORT_TOPIC_NAME , value_type = Status ) [EOL] [EOL] [EOL] def get_error_topic ( app ) : [EOL] return app . topic ( ERRORS_TOPIC_NAME , value_type = Error ) [EOL] [EOL] [EOL] async def send_update ( app , status ) : [EOL] return await get_reporting_topic ( app ) . send ( value = status ) [EOL] [EOL] [EOL] async def send_simple_good_status ( app , category , state = states . OK , color = [string] , count = [number] , severity = [string] ) : [EOL] status = Status ( app_id = app . conf . id , hostname = socket . gethostname ( ) , category = category , state = state , color = color , count = count , severity = severity , ) [EOL] await send_update ( app , status ) [EOL] [EOL] [EOL] async def send_simple_bad_status ( app , category , state = states . STALL , color = [string] , count = [number] , severity = [string] ) : [EOL] status = Status ( app_id = app . conf . id , hostname = socket . gethostname ( ) , category = category , state = state , color = color , count = count , severity = severity , ) [EOL] await send_update ( app , status ) [EOL] [EOL] [EOL] class SimpleCheck : [EOL] [EOL] def __init__ ( self , category ) : [EOL] self . category = category [EOL] self . failed = [number] [EOL] [EOL] async def send_ok ( self , app ) : [EOL] self . failed = [number] [EOL] await send_simple_good_status ( app , self . category ) [EOL] [EOL] async def send_fail ( self , app ) : [EOL] self . failed += [number] [EOL] await send_simple_bad_status ( app , self . category , count = self . failed ) [EOL] [EOL] [EOL] class DashboardApp ( faust . App ) : [EOL] [EOL] def on_webserver_init ( self , web ) : [EOL] from . import assets [EOL] web . add_static ( [string] , assets . get_path ( ) ) [EOL] [EOL] [EOL] def get_reporting_app ( ) : [EOL] from . . app import create_app [EOL] return create_app ( [string] , base = DashboardApp , origin = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DashboardApp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List [EOL] import typing [EOL] from . app import app [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . app import app [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import t [EOL] import faust [EOL] import pytest [EOL] [EOL] [EOL] class Order ( faust . Record , serializer = [string] ) : [EOL] account_id = ... [EOL] product_id = ... [EOL] amount = ... [EOL] price = ... [EOL] [EOL] [EOL] app = faust . App ( [string] ) [EOL] orders_topic = app . topic ( [string] , value_type = Order ) [EOL] [EOL] [comment] [EOL] orders_for_account = app . Table ( [string] , default = int , ) . tumbling ( [number] ) . relative_to_stream ( ) [EOL] [EOL] [EOL] @ app . agent ( orders_topic ) async def process_order ( orders ) : [EOL] async for order in orders . group_by ( Order . account_id ) : [EOL] orders_for_account [ order . account_id ] += [number] [EOL] yield order [EOL] [EOL] [EOL] @ pytest . mark . asyncio ( ) async def test_process_order ( ) : [EOL] app . finalize ( ) [EOL] app . conf . store = [string] [EOL] app . flow_control . resume ( ) [EOL] async with process_order . test_context ( ) as agent : [EOL] order = Order ( account_id = [string] , product_id = [string] , amount = [number] , price = [number] ) [EOL] event = await agent . put ( order ) [EOL] [EOL] [comment] [EOL] assert orders_for_account [ [string] ] . current ( event ) == [number] [EOL] [EOL] [comment] [EOL] assert not orders_for_account [ [string] ] . delta ( [number] * [number] , event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] import faust [EOL] from faust . types import StreamT , TP [EOL] from mode import label [EOL] from mode . utils . aiter import aiter , anext [EOL] from mode . utils . mocks import Mock [EOL] from mode . utils . queues import FlowControlQueue [EOL] import pytest [EOL] from . helpers import channel_empty , message , times_out [EOL] [EOL] [EOL] class Point ( faust . Record ) : [EOL] x = ... [EOL] y = ... [EOL] [EOL] [EOL] @ pytest . fixture def channel ( * , app ) : [EOL] return app . channel ( ) [EOL] [EOL] [EOL] def test_repr ( * , channel ) : [EOL] assert repr ( channel ) [EOL] [EOL] [EOL] def test_schema__default ( * , channel ) : [EOL] assert channel . key_type is None [EOL] assert channel . value_type is None [EOL] [EOL] assert channel . schema is not None [EOL] assert channel . schema . key_type is None [EOL] assert channel . schema . value_type is None [EOL] assert channel . schema . key_serializer is None [EOL] assert channel . schema . value_serializer is None [EOL] [EOL] [EOL] def test_schema__from_schema ( * , app ) : [EOL] schema = faust . Schema ( key_type = [string] , value_type = [string] , key_serializer = [string] , value_serializer = [string] , ) [EOL] channel = app . channel ( schema = schema ) [EOL] [EOL] assert channel . key_type == [string] [EOL] assert channel . value_type == [string] [EOL] [EOL] assert channel . schema is schema [EOL] assert channel . schema . key_type == channel . key_type [EOL] assert channel . schema . value_type == channel . value_type [EOL] assert channel . schema . key_serializer == [string] [EOL] assert channel . schema . value_serializer == [string] [EOL] [EOL] [EOL] def test_schema__overriding ( * , app ) : [EOL] schema = faust . Schema ( key_type = [string] , value_type = [string] , key_serializer = [string] , value_serializer = [string] , ) [EOL] channel = app . channel ( schema = schema , key_type = [string] , value_type = [string] ) [EOL] [EOL] assert channel . key_type == [string] [EOL] assert channel . value_type == [string] [EOL] assert channel . schema . key_type == [string] [EOL] assert channel . schema . value_type == [string] [EOL] assert channel . schema . key_serializer == [string] [EOL] assert channel . schema . value_serializer == [string] [EOL] [EOL] [EOL] def test_repr__active_partitions_empty ( * , channel ) : [EOL] channel . active_partitions = set ( ) [EOL] assert repr ( channel ) [EOL] [EOL] [EOL] def test_repr__with_active_partitions ( * , channel ) : [EOL] channel . active_partitions = { TP ( [string] , [number] ) , TP ( [string] , [number] ) } [EOL] assert repr ( channel ) [EOL] [EOL] [EOL] def test_label ( * , channel ) : [EOL] assert label ( channel ) [EOL] [EOL] [EOL] def test_str ( * , channel ) : [EOL] assert str ( channel ) [EOL] [EOL] [EOL] def test_send_soon ( * , channel ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] channel . send_soon ( key = [string] , value = [string] ) [EOL] [EOL] [EOL] def test_stream ( * , channel ) : [EOL] s = channel . stream ( ) [EOL] assert isinstance ( s , StreamT ) [EOL] assert s . channel . queue is not channel . queue [EOL] assert s . channel . _root is channel [EOL] assert s . channel in channel . _subscribers [EOL] [EOL] [EOL] def test_get_topic_name ( * , channel ) : [EOL] with pytest . raises ( NotImplementedError ) : [EOL] channel . get_topic_name ( ) [EOL] [EOL] [EOL] def test_clone ( * , app ) : [EOL] c = app . channel ( key_type = Point , value_type = Point , maxsize = [number] , loop = [number] ) [EOL] assert isinstance ( c . queue , FlowControlQueue ) [EOL] assert c . key_type is Point [EOL] assert c . value_type is Point [EOL] assert c . maxsize == [number] [EOL] assert c . loop == [number] [EOL] assert not c . is_iterator [EOL] [EOL] c2 = c . clone ( ) [EOL] assert c2 . key_type is Point [EOL] assert c2 . value_type is Point [EOL] assert c2 . maxsize == [number] [EOL] assert c2 . loop == [number] [EOL] assert not c2 . is_iterator [EOL] assert c2 . queue is not c . queue [EOL] assert c2 . _root is c [EOL] assert c2 not in c . _subscribers [EOL] assert c . subscriber_count == [number] [EOL] [EOL] c3 = c2 . clone ( is_iterator = True ) [EOL] assert c3 . key_type is Point [EOL] assert c3 . value_type is Point [EOL] assert c3 . maxsize == [number] [EOL] assert c3 . loop == [number] [EOL] assert c3 . is_iterator [EOL] assert c3 . queue is not c . queue [EOL] assert c3 . _root is c [EOL] assert c2 . _root is c [EOL] assert c3 in c . _subscribers [EOL] assert c2 not in c . _subscribers [EOL] assert c . subscriber_count == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_send_receive ( * , app ) : [EOL] app . flow_control . resume ( ) [EOL] channel1 = app . channel ( maxsize = [number] ) [EOL] channel2 = app . channel ( maxsize = [number] ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] [comment] [EOL] await channel1 . __anext__ ( ) [EOL] it1 = aiter ( channel1 ) [EOL] it2 = aiter ( channel2 ) [EOL] await channel2 . put ( [string] ) [EOL] assert await times_out ( channel2 . put ( [string] ) ) [comment] [EOL] assert it1 . queue is not channel1 . queue [EOL] assert it1 . _root is channel1 [EOL] assert it1 in channel1 . _subscribers [EOL] assert channel1 . subscriber_count == [number] [EOL] assert channel1 . queue is not channel2 . queue [EOL] assert await channel_empty ( channel1 ) [EOL] await channel1 . put ( [string] ) [EOL] assert await anext ( it1 ) == [string] [EOL] assert await channel_empty ( channel1 ) [EOL] for i in range ( [number] ) : [EOL] await channel1 . put ( i ) [EOL] assert await times_out ( channel1 . put ( [number] ) ) [comment] [EOL] for i in range ( [number] ) : [EOL] assert await anext ( it1 ) == i [EOL] assert await channel_empty ( channel1 ) [EOL] assert await anext ( it2 ) == [string] [EOL] assert await channel_empty ( channel2 ) [EOL] [EOL] it1_2 = aiter ( channel1 ) [EOL] assert it1_2 . _root is channel1 [EOL] assert it1_2 in channel1 . _subscribers [EOL] assert channel1 . subscriber_count == [number] [EOL] [EOL] await channel1 . put ( [string] ) [EOL] [EOL] assert await anext ( it1 ) == [string] [EOL] assert await anext ( it1_2 ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_on_key_decode_error ( * , app ) : [EOL] channel = app . channel ( ) [EOL] await channel . on_key_decode_error ( KeyError ( [string] ) , [string] ) [EOL] with pytest . raises ( KeyError ) : [EOL] await channel . get ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_on_value_decode_error ( * , app ) : [EOL] channel = app . channel ( ) [EOL] await channel . on_value_decode_error ( KeyError ( [string] ) , [string] ) [EOL] with pytest . raises ( KeyError ) : [EOL] await channel . get ( ) [EOL] [EOL] [EOL] def test_derive ( * , app ) : [EOL] channel = app . channel ( maxsize = [number] ) [EOL] assert channel . derive ( ) is channel [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_declare__does_nothing ( * , app ) : [EOL] await app . channel ( ) . declare ( ) [EOL] [EOL] [EOL] def test_clone_using_queue ( * , channel ) : [EOL] queue = asyncio . Queue ( ) [EOL] chan2 = channel . clone_using_queue ( queue ) [EOL] assert chan2 . queue is queue [EOL] assert chan2 . is_iterator [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_interface_maybe_declare ( * , channel ) : [EOL] await channel . maybe_declare ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_decode ( * , channel ) : [EOL] msg = message ( [string] , [string] ) [EOL] event = await channel . decode ( msg ) [EOL] assert event . message is msg [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_deliver ( * , channel , app ) : [EOL] app . flow_control . resume ( ) [EOL] msg = message ( [string] , [string] ) [EOL] queue = channel . queue [EOL] await channel . deliver ( msg ) [EOL] event = queue . get_nowait ( ) [EOL] assert event . message is msg [EOL] [EOL] [EOL] def test_as_future_message__eager_partitioning ( * , app ) : [EOL] topic = app . topic ( [string] ) [EOL] app . producer = Mock ( name = [string] ) [EOL] fut = topic . as_future_message ( key = [string] , value = [string] , partition = None , eager_partitioning = True , ) [EOL] assert fut . message . partition is not None [EOL] [EOL] [EOL] def test_as_future_message__eager_partitioning_on_channel ( * , channel , app ) : [EOL] app . producer = Mock ( name = [string] ) [EOL] with pytest . raises ( NotImplementedError ) : [EOL] channel . as_future_message ( key = [string] , value = [string] , partition = None , eager_partitioning = True , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , ClassVar , Set , Any , Type , Mapping , List [EOL] import decimal [EOL] import typing [EOL] import t [EOL] import datetime [EOL] import builtins [EOL] import abc [EOL] from datetime import datetime [EOL] from decimal import Decimal [EOL] from typing import ClassVar , Dict , List , Mapping , Optional , Set , Tuple [EOL] from dateutil . parser import parse as parse_date [EOL] import faust [EOL] from faust . exceptions import SecurityError , ValidationError [EOL] from faust . models import maybe_model [EOL] from faust . models . fields import ( BytesField , DatetimeField , DecimalField , FieldDescriptor , FloatField , IntegerField , StringField , ) [EOL] from mode . utils . logging import get_logger [EOL] from faust . models . tags import ( Secret , Sensitive , _FrameLocal , allow_protected_vars , ) [EOL] from faust . types import ModelT [EOL] from faust . utils import json [EOL] import pytest [EOL] [EOL] logger = get_logger ( __name__ ) [EOL] [EOL] [EOL] class Record ( faust . Record , serializer = [string] ) : [EOL] [comment] [EOL] ... [EOL] [EOL] [EOL] class Account ( Record ) : [EOL] id = ... [EOL] name = ... [EOL] active = True [EOL] [EOL] [EOL] class AccountList ( Record ) : [EOL] accounts = ... [EOL] [EOL] [EOL] class AccountSet ( Record ) : [EOL] accounts = ... [EOL] [EOL] [EOL] class AccountMap ( Record ) : [EOL] accounts = ... [EOL] [EOL] [EOL] class FREFAccountList ( Record ) : [EOL] accounts = ... [EOL] [EOL] [EOL] class FREFAccountSet ( Record ) : [EOL] accounts = ... [EOL] [EOL] [EOL] class FREFAccountMap ( Record ) : [EOL] accounts = ... [EOL] something = True [EOL] [EOL] [EOL] class User ( Record ) : [EOL] id = ... [EOL] username = ... [EOL] account = ... [EOL] [EOL] [EOL] def test_parameters ( ) : [EOL] account = Account ( [string] , [string] , True ) [EOL] assert account . id == [string] [EOL] assert account . name == [string] [EOL] assert account . active [EOL] [EOL] account2 = Account ( [string] , [string] , active = False ) [EOL] assert account2 . id == [string] [EOL] assert account2 . name == [string] [EOL] assert not account2 . active [EOL] [EOL] class Account3 ( Account ) : [EOL] foo = None [EOL] [EOL] account3 = Account3 ( [string] , [string] , False , [string] ) [EOL] assert account3 . id == [string] [EOL] assert account3 . name == [string] [EOL] assert not account3 . active [EOL] assert account3 . foo == [string] [EOL] [EOL] with pytest . raises ( AttributeError ) : [EOL] account2 . foo [EOL] [EOL] [EOL] def test_paramters_with_custom_init ( ) : [EOL] [EOL] class Point ( Record , include_metadata = False ) : [EOL] x = ... [EOL] y = ... [EOL] [EOL] def __init__ ( self , x , y , ** kwargs ) : [EOL] self . x = x [EOL] self . y = y [EOL] [EOL] p = Point ( [number] , [number] ) [EOL] assert p . x == [number] [EOL] assert p . y == [number] [EOL] [EOL] payload = p . dumps ( serializer = [string] ) [EOL] assert payload == [string] [EOL] [EOL] data = json . loads ( payload ) [EOL] p2 = Point . from_data ( data ) [EOL] assert p2 . x == [number] [EOL] assert p2 . y == [number] [EOL] [EOL] [EOL] def test_parameters_with_custom_init_and_super ( ) : [EOL] [EOL] class Point ( Record , include_metadata = False ) : [EOL] x = ... [EOL] y = ... [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . z = self . x + self . y [EOL] [EOL] p = Point ( [number] , [number] ) [EOL] assert p . x == [number] [EOL] assert p . y == [number] [EOL] assert p . z == [number] [EOL] [EOL] payload = p . dumps ( serializer = [string] ) [EOL] assert payload == [string] [EOL] [EOL] data = json . loads ( payload ) [EOL] p2 = Point . from_data ( data ) [EOL] assert p2 . x == [number] [EOL] assert p2 . y == [number] [EOL] assert p2 . z == [number] [EOL] [EOL] [EOL] def test_datetimes ( ) : [EOL] [EOL] class Date ( Record , coerce = True ) : [EOL] date = ... [EOL] [EOL] class OptionalDate ( Record , coerce = True ) : [EOL] date = ... [EOL] [EOL] class TupleOfDate ( Record , coerce = True ) : [EOL] dates = ... [EOL] [EOL] class SetOfDate ( Record , coerce = True ) : [EOL] dates = ... [EOL] [EOL] class MapOfDate ( Record , coerce = True ) : [EOL] dates = ... [EOL] [EOL] class ListOfDate ( Record , coerce = True ) : [EOL] dates = ... [EOL] [EOL] class OptionalListOfDate ( Record , coerce = True ) : [EOL] dates = None [EOL] [EOL] class OptionalListOfDate2 ( Record , coerce = True ) : [EOL] dates = ... [EOL] [EOL] assert isinstance ( OptionalDate . date , DatetimeField ) [EOL] [EOL] n1 = datetime . utcnow ( ) [EOL] assert Date . loads ( Date ( date = n1 ) . dumps ( ) ) . date == n1 [EOL] assert OptionalDate . loads ( OptionalDate ( date = n1 ) . dumps ( ) ) . date == n1 [EOL] assert OptionalDate . loads ( OptionalDate ( date = None ) . dumps ( ) ) . date is None [EOL] n2 = datetime . utcnow ( ) [EOL] assert ListOfDate . loads ( ListOfDate ( dates = [ n1 , n2 ] ) . dumps ( ) ) . dates == [ n1 , n2 ] [EOL] assert OptionalListOfDate . loads ( OptionalListOfDate ( dates = None ) . dumps ( ) ) . dates is None [EOL] assert OptionalListOfDate . loads ( OptionalListOfDate ( dates = [ n2 , n1 ] ) . dumps ( ) ) . dates == [ n2 , n1 ] [EOL] assert OptionalListOfDate2 . loads ( OptionalListOfDate2 ( dates = None ) . dumps ( ) ) . dates is None [EOL] assert OptionalListOfDate2 . loads ( OptionalListOfDate2 ( dates = [ n1 , n2 ] ) . dumps ( ) ) . dates == [ n1 , n2 ] [EOL] assert TupleOfDate . loads ( TupleOfDate ( dates = ( n1 , n2 ) ) . dumps ( ) ) . dates == ( n1 , n2 ) [EOL] assert TupleOfDate . loads ( TupleOfDate ( dates = ( n2 , ) ) . dumps ( ) ) . dates == ( n2 , ) [EOL] assert SetOfDate . loads ( SetOfDate ( dates = { n1 , n2 } ) . dumps ( ) ) . dates == { n1 , n2 } [EOL] assert MapOfDate . loads ( MapOfDate ( dates = { [string] : n1 , [string] : n2 } ) . dumps ( ) ) . dates == { [string] : n1 , [string] : n2 } [EOL] [EOL] datelist = ListOfDate . from_data ( { [string] : [ n1 . isoformat ( ) , n2 . isoformat ( ) ] } ) [EOL] assert isinstance ( datelist . dates [ [number] ] , datetime ) [EOL] assert isinstance ( datelist . dates [ [number] ] , datetime ) [EOL] [EOL] [EOL] def test_datetimes__isodates_compat ( ) : [EOL] [EOL] class Date ( Record , coerce = False , isodates = True ) : [EOL] date = ... [EOL] [EOL] class TupleOfDate ( Record , coerce = False , isodates = True ) : [EOL] dates = ... [EOL] [EOL] class SetOfDate ( Record , coerce = False , isodates = True ) : [EOL] dates = ... [EOL] [EOL] class MapOfDate ( Record , coerce = False , isodates = True ) : [EOL] dates = ... [EOL] [EOL] class ListOfDate ( Record , coerce = False , isodates = True ) : [EOL] dates = ... [EOL] [EOL] class OptionalListOfDate ( Record , coerce = False , isodates = True ) : [EOL] dates = None [EOL] [EOL] class OptionalListOfDate2 ( Record , coerce = False , isodates = True ) : [EOL] dates = ... [EOL] [EOL] n1 = datetime . utcnow ( ) [EOL] assert Date . loads ( Date ( date = n1 ) . dumps ( ) ) . date == n1 [EOL] n2 = datetime . utcnow ( ) [EOL] assert ListOfDate . loads ( ListOfDate ( dates = [ n1 , n2 ] ) . dumps ( ) ) . dates == [ n1 , n2 ] [EOL] assert OptionalListOfDate . loads ( OptionalListOfDate ( dates = None ) . dumps ( ) ) . dates is None [EOL] assert OptionalListOfDate . loads ( OptionalListOfDate ( dates = [ n2 , n1 ] ) . dumps ( ) ) . dates == [ n2 , n1 ] [EOL] assert OptionalListOfDate2 . loads ( OptionalListOfDate2 ( dates = None ) . dumps ( ) ) . dates is None [EOL] assert OptionalListOfDate2 . loads ( OptionalListOfDate2 ( dates = [ n1 , n2 ] ) . dumps ( ) ) . dates == [ n1 , n2 ] [EOL] assert TupleOfDate . loads ( TupleOfDate ( dates = ( n1 , n2 ) ) . dumps ( ) ) . dates == ( n1 , n2 ) [EOL] assert TupleOfDate . loads ( TupleOfDate ( dates = ( n2 , ) ) . dumps ( ) ) . dates == ( n2 , ) [EOL] assert SetOfDate . loads ( SetOfDate ( dates = { n1 , n2 } ) . dumps ( ) ) . dates == { n1 , n2 } [EOL] assert MapOfDate . loads ( MapOfDate ( dates = { [string] : n1 , [string] : n2 } ) . dumps ( ) ) . dates == { [string] : n1 , [string] : n2 } [EOL] [EOL] datelist = ListOfDate . from_data ( { [string] : [ n1 . isoformat ( ) , n2 . isoformat ( ) ] } ) [EOL] assert isinstance ( datelist . dates [ [number] ] , datetime ) [EOL] assert isinstance ( datelist . dates [ [number] ] , datetime ) [EOL] [EOL] [EOL] def test_decimals ( ) : [EOL] [EOL] class IsDecimal ( Record , coerce = True , serializer = [string] ) : [EOL] number = ... [EOL] [EOL] class ListOfDecimal ( Record , coerce = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] class OptionalListOfDecimal ( Record , coerce = True , serializer = [string] ) : [EOL] numbers = None [EOL] [EOL] class OptionalListOfDecimal2 ( Record , coerce = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] class TupleOfDecimal ( Record , coerce = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] class SetOfDecimal ( Record , coerce = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] class MapOfDecimal ( Record , coerce = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] n1 = Decimal ( [string] ) [EOL] assert IsDecimal . loads ( IsDecimal ( number = n1 ) . dumps ( ) ) . number == n1 [EOL] n2 = Decimal ( [string] ) [EOL] assert ListOfDecimal . loads ( ListOfDecimal ( numbers = [ n1 , n2 ] ) . dumps ( ) ) . numbers == [ n1 , n2 ] [EOL] assert OptionalListOfDecimal . loads ( OptionalListOfDecimal ( numbers = None ) . dumps ( ) ) . numbers is None [EOL] assert OptionalListOfDecimal . loads ( OptionalListOfDecimal ( numbers = [ n2 , n1 ] ) . dumps ( ) ) . numbers == [ n2 , n1 ] [EOL] assert OptionalListOfDecimal2 . loads ( OptionalListOfDecimal2 ( numbers = None ) . dumps ( ) ) . numbers is None [EOL] assert OptionalListOfDecimal2 . loads ( OptionalListOfDecimal2 ( numbers = [ n1 , n2 ] ) . dumps ( ) ) . numbers == [ n1 , n2 ] [EOL] assert TupleOfDecimal . loads ( TupleOfDecimal ( numbers = ( n1 , n2 ) ) . dumps ( ) ) . numbers == ( n1 , n2 ) [EOL] assert TupleOfDecimal . loads ( TupleOfDecimal ( numbers = ( n2 , ) ) . dumps ( ) ) . numbers == ( n2 , ) [EOL] assert SetOfDecimal . loads ( SetOfDecimal ( numbers = { n1 , n2 } ) . dumps ( ) ) . numbers == { n1 , n2 } [EOL] assert MapOfDecimal . loads ( MapOfDecimal ( numbers = { [string] : n1 , [string] : n2 } ) . dumps ( ) ) . numbers == { [string] : n1 , [string] : n2 } [EOL] [EOL] dlist = ListOfDecimal . from_data ( { [string] : [ [string] , [string] ] } ) [EOL] assert isinstance ( dlist . numbers [ [number] ] , Decimal ) [EOL] assert isinstance ( dlist . numbers [ [number] ] , Decimal ) [EOL] [EOL] [EOL] def test_decimals_compat ( ) : [EOL] [EOL] class IsDecimal ( Record , coerce = False , decimals = True , serializer = [string] ) : [EOL] number = ... [EOL] [EOL] class ListOfDecimal ( Record , coerce = False , decimals = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] class OptionalListOfDecimal ( Record , coerce = False , decimals = True , serializer = [string] ) : [EOL] numbers = None [EOL] [EOL] class OptionalListOfDecimal2 ( Record , coerce = False , decimals = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] class TupleOfDecimal ( Record , coerce = False , decimals = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] class SetOfDecimal ( Record , coerce = False , decimals = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] class MapOfDecimal ( Record , coerce = False , decimals = True , serializer = [string] ) : [EOL] numbers = ... [EOL] [EOL] n1 = Decimal ( [string] ) [EOL] assert IsDecimal . loads ( IsDecimal ( number = n1 ) . dumps ( ) ) . number == n1 [EOL] n2 = Decimal ( [string] ) [EOL] assert ListOfDecimal . loads ( ListOfDecimal ( numbers = [ n1 , n2 ] ) . dumps ( ) ) . numbers == [ n1 , n2 ] [EOL] assert OptionalListOfDecimal . loads ( OptionalListOfDecimal ( numbers = None ) . dumps ( ) ) . numbers is None [EOL] assert OptionalListOfDecimal . loads ( OptionalListOfDecimal ( numbers = [ n2 , n1 ] ) . dumps ( ) ) . numbers == [ n2 , n1 ] [EOL] assert OptionalListOfDecimal2 . loads ( OptionalListOfDecimal2 ( numbers = None ) . dumps ( ) ) . numbers is None [EOL] assert OptionalListOfDecimal2 . loads ( OptionalListOfDecimal2 ( numbers = [ n1 , n2 ] ) . dumps ( ) ) . numbers == [ n1 , n2 ] [EOL] assert TupleOfDecimal . loads ( TupleOfDecimal ( numbers = ( n1 , n2 ) ) . dumps ( ) ) . numbers == ( n1 , n2 ) [EOL] assert TupleOfDecimal . loads ( TupleOfDecimal ( numbers = ( n2 , ) ) . dumps ( ) ) . numbers == ( n2 , ) [EOL] assert SetOfDecimal . loads ( SetOfDecimal ( numbers = { n1 , n2 } ) . dumps ( ) ) . numbers == { n1 , n2 } [EOL] assert MapOfDecimal . loads ( MapOfDecimal ( numbers = { [string] : n1 , [string] : n2 } ) . dumps ( ) ) . numbers == { [string] : n1 , [string] : n2 } [EOL] [EOL] dlist = ListOfDecimal . from_data ( { [string] : [ [string] , [string] ] } ) [EOL] assert isinstance ( dlist . numbers [ [number] ] , Decimal ) [EOL] assert isinstance ( dlist . numbers [ [number] ] , Decimal ) [EOL] [EOL] [EOL] def test_custom_coercion ( ) : [EOL] [EOL] class Foo : [EOL] [EOL] def __init__ ( self , value ) : [EOL] assert isinstance ( value , int ) [EOL] self . value = value [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if other . __class__ is self . __class__ : [EOL] return other . value == self . value [EOL] return NotImplemented [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . value ) [EOL] [EOL] def __json__ ( self ) : [EOL] return self . value [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { type ( self ) . __name__ } [string] { self . value } [string] ' [EOL] [EOL] class CanFooModel ( Record , abstract = True , coercions = { Foo : Foo } , serializer = [string] ) : [EOL] ... [EOL] [EOL] class IsFoo ( CanFooModel , serializer = [string] ) : [EOL] foo = ... [EOL] [EOL] class ListOfFoo ( CanFooModel , serializer = [string] ) : [EOL] foos = ... [EOL] [EOL] class OptionalListOfFoo ( CanFooModel , serializer = [string] ) : [EOL] foos = None [EOL] [EOL] class OptionalListOfFoo2 ( CanFooModel ) : [EOL] foos = ... [EOL] [EOL] class TupleOfFoo ( CanFooModel ) : [EOL] foos = ... [EOL] [EOL] class SetOfFoo ( CanFooModel ) : [EOL] foos = ... [EOL] [EOL] class MapOfFoo ( CanFooModel ) : [EOL] foos = ... [EOL] [EOL] n1 = Foo ( [number] ) [EOL] assert IsFoo . loads ( IsFoo ( foo = n1 ) . dumps ( ) ) . foo == n1 [EOL] n2 = Foo ( [number] ) [EOL] assert ListOfFoo . loads ( ListOfFoo ( foos = [ n1 , n2 ] ) . dumps ( ) ) . foos == [ n1 , n2 ] [EOL] assert OptionalListOfFoo . loads ( OptionalListOfFoo ( foos = None ) . dumps ( ) ) . foos is None [EOL] assert OptionalListOfFoo . loads ( OptionalListOfFoo ( foos = [ n2 , n1 ] ) . dumps ( ) ) . foos == [ n2 , n1 ] [EOL] assert OptionalListOfFoo2 . loads ( OptionalListOfFoo2 ( foos = None ) . dumps ( ) ) . foos is None [EOL] assert OptionalListOfFoo2 . loads ( OptionalListOfFoo2 ( foos = [ n1 , n2 ] ) . dumps ( ) ) . foos == [ n1 , n2 ] [EOL] assert TupleOfFoo . loads ( TupleOfFoo ( foos = ( n1 , n2 ) ) . dumps ( ) ) . foos == ( n1 , n2 ) [EOL] assert TupleOfFoo . loads ( TupleOfFoo ( foos = ( n2 , ) ) . dumps ( ) ) . foos == ( n2 , ) [EOL] assert SetOfFoo . loads ( SetOfFoo ( foos = { n1 , n2 } ) . dumps ( ) ) . foos == { n1 , n2 } [EOL] assert MapOfFoo . loads ( MapOfFoo ( foos = { [string] : n1 , [string] : n2 } ) . dumps ( ) ) . foos == { [string] : n1 , [string] : n2 } [EOL] [EOL] [EOL] def test_constructor ( ) : [EOL] with pytest . raises ( TypeError ) : [EOL] Account ( id = [string] ) [EOL] with pytest . raises ( TypeError ) : [EOL] Account ( name = [string] ) [EOL] with pytest . raises ( TypeError ) : [EOL] Account ( unknown_argument = [number] ) [EOL] account = Account ( id = [string] , name = [string] ) [EOL] assert account . id == [string] [EOL] assert account . name == [string] [EOL] assert account . active [EOL] assert not Account ( id = [string] , name = [string] , active = False ) . active [EOL] [EOL] [EOL] def test_submodels ( ) : [EOL] a1 = Account ( id = [string] , name = [string] , active = True ) [EOL] a2 = Account ( id = [string] , name = [string] , active = False ) [EOL] a3 = Account ( id = [string] , name = [string] , active = True ) [EOL] [EOL] assert AccountList . loads ( AccountList ( accounts = [ a1 , a2 , a3 ] ) . dumps ( ) ) . accounts == [ a1 , a2 , a3 ] [EOL] [EOL] expected_set = { a1 , a2 , a3 } [EOL] acc1 = AccountSet . loads ( AccountSet ( accounts = { a1 , a2 , a3 } ) . dumps ( ) ) . accounts [EOL] assert isinstance ( acc1 , set ) [EOL] assert len ( acc1 ) == len ( expected_set ) [EOL] for acc in acc1 : [EOL] assert acc in expected_set [EOL] assert AccountMap . loads ( AccountMap ( accounts = { [string] : a1 , [string] : a2 , [string] : a3 } ) . dumps ( ) ) . accounts == { [string] : a1 , [string] : a2 , [string] : a3 , } [EOL] [EOL] [EOL] def test_submodels_forward_reference ( ) : [EOL] a1 = Account ( id = [string] , name = [string] , active = True ) [EOL] a2 = Account ( id = [string] , name = [string] , active = False ) [EOL] a3 = Account ( id = [string] , name = [string] , active = True ) [EOL] [EOL] assert AccountList . loads ( FREFAccountList ( accounts = [ a1 , a2 , a3 ] ) . dumps ( ) ) . accounts == [ a1 , a2 , a3 ] [EOL] assert sorted ( AccountSet . loads ( FREFAccountSet ( accounts = { a1 , a2 , a3 } ) . dumps ( ) ) . accounts ) == sorted ( { a1 , a2 , a3 } ) [EOL] assert AccountMap . loads ( FREFAccountMap ( accounts = { [string] : a1 , [string] : a2 , [string] : a3 } ) . dumps ( ) ) . accounts == { [string] : a1 , [string] : a2 , [string] : a3 , } [EOL] [EOL] [EOL] def test_derive ( ) : [EOL] a1 = Account ( id = [string] , name = [string] , active = True ) [EOL] b1 = Account ( id = [string] , name = [string] , active = False ) [EOL] c1 = Account ( id = [string] , name = [string] , active = True ) [EOL] [EOL] assert a1 . active [EOL] a2 = a1 . derive ( active = False ) [EOL] assert a2 . id == [string] [EOL] assert a2 . name == [string] [EOL] assert not a2 . active [EOL] [EOL] c2 = a1 . derive ( b1 , c1 , name = [string] ) [EOL] assert c2 . id == [string] [EOL] assert c2 . name == [string] [EOL] assert c2 . active [EOL] [EOL] b2 = b1 . derive ( active = True ) [EOL] assert b2 . active [EOL] assert b2 . id == [string] [EOL] assert b2 . name == [string] [EOL] [EOL] [EOL] def test_classvar_is_not_a_field ( ) : [EOL] [EOL] class PP ( Record ) : [EOL] x = ... [EOL] y = ... [EOL] z = [number] [EOL] [EOL] p = PP ( [number] , [number] ) [EOL] assert [string] not in repr ( p ) [EOL] assert p . asdict ( ) == { [string] : [number] , [string] : [number] } [EOL] assert p . z == [number] [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] PP ( [number] , [number] , z = [number] ) [EOL] [EOL] p . z = [number] [EOL] assert p . z == [number] [EOL] [EOL] [EOL] def test_constructor_from_data ( ) : [EOL] with pytest . raises ( TypeError ) : [EOL] Account . from_data ( { [string] : [string] } ) [EOL] with pytest . raises ( TypeError ) : [EOL] Account . from_data ( { [string] : [string] } ) [EOL] with pytest . raises ( TypeError ) : [EOL] Account . from_data ( { [string] : [number] } ) [EOL] account = Account . from_data ( { [string] : [string] , [string] : [string] } ) [EOL] assert account . id == [string] [EOL] assert account . name == [string] [EOL] assert account . active [EOL] assert not Account . from_data ( { [string] : [string] , [string] : [string] , [string] : False } ) . active [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] ) ) , User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] ) ) ) , ( User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] , active = False ) ) , User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] , active = False ) ) ) , ] ) def test_eq ( a , b ) : [EOL] assert a == b [EOL] [EOL] [EOL] def test_eq__incompatible ( ) : [EOL] assert Account ( id = [number] , name = [number] ) != object ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] ) ) , User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] ) ) ) , ( User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] ) ) , User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] ) ) ) , ( User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] ) ) , User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] ) ) ) , ( User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] , active = False ) ) , User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] , active = True ) ) ) , ] ) def test_ne ( a , b ) : [EOL] assert a != b [EOL] [EOL] [EOL] def test_json ( ) : [EOL] account = Account ( id = [number] , name = [number] ) [EOL] user = User ( [number] , [number] , account ) [EOL] [EOL] payload = json . dumps ( user ) [EOL] deser = json . loads ( payload ) [EOL] assert deser == { [string] : [number] , [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : True , [string] : { [string] : Account . _options . namespace } , } , [string] : { [string] : User . _options . namespace } , } [EOL] [EOL] assert user . __json__ ( ) == { [string] : [number] , [string] : [number] , [string] : account , [string] : { [string] : User . _options . namespace } , } [EOL] [EOL] assert User . from_data ( deser ) == user [EOL] [EOL] [EOL] class test_FieldDescriptor : [EOL] [EOL] def test_getattr ( self ) : [EOL] u = User ( id = [number] , username = [number] , account = Account ( id = [number] , name = [number] ) ) [EOL] [EOL] assert User . id . getattr ( u ) == [number] [EOL] assert User . username . getattr ( u ) == [number] [EOL] assert User . account . id . getattr ( u ) == [number] [EOL] assert User . account . name . getattr ( u ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Account ( id = None , name = None ) , Account ( id = [string] , name = [string] ) , Account ( id = [string] , name = [string] , active = False ) , User ( id = [string] , username = [string] , account = Account ( id = [string] , name = [string] , active = True ) ) , User ( id = [string] , username = [string] , account = None ) , User ( id = None , username = None , account = None ) , AccountList ( accounts = [ Account ( id = None , name = None ) ] ) , AccountMap ( accounts = { [string] : Account ( id = None , name = [string] ) } ) , ] ) def test_dumps ( record ) : [EOL] assert record . loads ( record . dumps ( ) ) == record [EOL] assert repr ( record ) [EOL] [EOL] [EOL] def test_subclass_default_values ( ) : [EOL] [EOL] class X ( Record ) : [EOL] x = ... [EOL] y = None [EOL] [EOL] class Z ( X ) : [EOL] z = None [EOL] [EOL] assert X ( x = None ) . y is None [EOL] assert X ( x = None , y = [number] ) . y == [number] [EOL] assert Z ( x = None ) . y is None [EOL] assert Z ( x = None ) . z is None [EOL] assert Z ( x = None , y = [number] , z = [number] ) . y == [number] [EOL] assert Z ( x = None , y = [number] , z = [number] ) . z == [number] [EOL] [EOL] [EOL] def test_subclass_preserves_required_values ( ) : [EOL] [EOL] class X ( Record ) : [EOL] x = ... [EOL] z = None [EOL] [EOL] class Y ( X ) : [EOL] y = ... [EOL] [EOL] assert Y . _options . defaults == { [string] : None } [EOL] assert Y . _options . optionalset == { [string] } [EOL] with pytest . raises ( TypeError ) : [EOL] Y ( y = [number] ) [EOL] with pytest . raises ( TypeError ) : [EOL] Y ( y = [number] , z = [number] ) [EOL] Y ( x = [number] , y = [number] ) [EOL] [EOL] [EOL] def test_too_many_arguments_raises_TypeError ( ) : [EOL] class X ( Record ) : [EOL] x = ... [EOL] [EOL] class Y ( X ) : [EOL] y = ... [EOL] [EOL] with pytest . raises ( TypeError ) as einfo : [EOL] Y ( [number] , [number] , [number] ) [EOL] reason = str ( einfo . value ) [EOL] assert [string] in reason [EOL] [EOL] [EOL] def test_fields_with_concrete_polymorphic_type__dict ( ) : [EOL] [EOL] class X ( Record , isodates = True ) : [EOL] foo = ... [EOL] details = ... [EOL] [EOL] [EOL] def test_fields_with_concrete_polymorphic_type__dict_optional ( ) : [EOL] [EOL] class X ( Record , isodates = True ) : [EOL] username = ... [EOL] metric_name = ... [EOL] value = ... [EOL] timestamp = ... [EOL] details = None [EOL] [EOL] [EOL] def test_fields_with_concrete_polymorphic_type__tuple ( ) : [EOL] [EOL] class X ( Record , isodates = True ) : [EOL] foo = ... [EOL] details = ... [EOL] [EOL] [EOL] def test_fields_with_concrete_polymorphic_type__list ( ) : [EOL] [EOL] class X ( Record , isodates = True ) : [EOL] foo = ... [EOL] details = ... [EOL] [EOL] [EOL] def test_fields_with_concrete_polymorphic_type__set ( ) : [EOL] [EOL] class X ( Record , isodates = True ) : [EOL] foo = ... [EOL] details = ... [EOL] [EOL] [EOL] def test_fields_with_concrete_polymorphic_type__frozenset ( ) : [EOL] [EOL] class X ( Record , isodates = True ) : [EOL] foo = ... [EOL] details = ... [EOL] [EOL] [EOL] def test_supports_post_init ( ) : [EOL] [EOL] class X ( Record ) : [EOL] x = ... [EOL] y = ... [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . z = self . x + self . y [EOL] [EOL] x = X ( [number] , [number] ) [EOL] assert x . z == [number] [EOL] [EOL] [EOL] def test_default_no_blessed_key ( ) : [EOL] [EOL] class X ( Record ) : [EOL] a = ... [EOL] [EOL] class LooksLikeX ( Record ) : [EOL] a = ... [EOL] [EOL] class Y ( Record ) : [EOL] x = ... [EOL] [EOL] x = LooksLikeX ( [number] ) [EOL] y = Y ( x ) [EOL] [EOL] data = Y . dumps ( y , serializer = [string] ) [EOL] y2 = Y . loads ( data , serializer = [string] ) [EOL] assert isinstance ( y2 . x , X ) [EOL] [EOL] [EOL] def test_default_multiple_levels_no_blessed_key ( ) : [EOL] [EOL] class StdAttribution ( Record ) : [EOL] first_name = ... [EOL] last_name = ... [EOL] [EOL] class Address ( Record ) : [EOL] country = ... [EOL] [EOL] class Account ( StdAttribution ) : [EOL] address = ... [EOL] [EOL] class Event ( Record ) : [EOL] account = ... [EOL] [EOL] event = Event ( account = Account ( first_name = [string] , last_name = [string] , address = Address ( [string] ) , ) ) [EOL] s = event . loads ( event . dumps ( serializer = [string] ) , serializer = [string] ) [EOL] assert isinstance ( s . account , Account ) [EOL] assert isinstance ( s . account . address , Address ) [EOL] [EOL] [EOL] def test_polymorphic_fields ( app ) : [EOL] [EOL] class X ( Record ) : [EOL] a = ... [EOL] [EOL] class LooksLikeX ( Record , polymorphic_fields = True ) : [EOL] a = ... [EOL] [EOL] class Y ( Record ) : [EOL] x = ... [EOL] [EOL] x = LooksLikeX ( [number] ) [EOL] y = Y ( x ) [EOL] [EOL] data = Y . dumps ( y , serializer = [string] ) [EOL] y2 = app . serializers . loads_key ( Y , data , serializer = [string] ) [EOL] assert isinstance ( y2 . x , LooksLikeX ) [EOL] [EOL] [EOL] def test_compat_enabled_blessed_key ( app ) : [EOL] [EOL] class X ( Record ) : [EOL] a = ... [EOL] [EOL] class LooksLikeX ( Record , allow_blessed_key = True ) : [EOL] a = ... [EOL] [EOL] class Y ( Record ) : [EOL] x = ... [EOL] [EOL] x = LooksLikeX ( [number] ) [EOL] y = Y ( x ) [EOL] [EOL] data = Y . dumps ( y , serializer = [string] ) [EOL] y2 = app . serializers . loads_key ( Y , data , serializer = [string] ) [EOL] assert isinstance ( y2 . x , LooksLikeX ) [EOL] [EOL] [EOL] def test__polymorphic_fields_deeply_nested ( ) : [EOL] [EOL] class BaseAttribution ( Record , abc . ABC ) : [EOL] [EOL] def __post_init__ ( self , * args , ** kwargs ) : [EOL] self . data_store = None [EOL] [EOL] class AdjustData ( Record ) : [EOL] activity_kind = ... [EOL] [EOL] class Event ( Record ) : [EOL] category = ... [EOL] event = ... [EOL] data = ... [EOL] [EOL] class AdjustRecord ( BaseAttribution ) : [EOL] event = ... [EOL] [EOL] x = AdjustRecord ( Event ( category = [string] , event = [string] , data = AdjustData ( [string] ) , ) ) [EOL] value = x . dumps ( serializer = [string] ) [EOL] value_dict = json . loads ( value ) [EOL] value_dict [ [string] ] [ [string] ] [ [string] ] = [string] [EOL] model = AdjustRecord . from_data ( value_dict ) [EOL] assert isinstance ( model . event , Event ) [EOL] assert isinstance ( model . event . data , AdjustData ) [EOL] [EOL] [EOL] def test_compat_blessed_key_deeply_nested ( ) : [EOL] [EOL] class BaseAttribution ( Record , abc . ABC ) : [EOL] [EOL] def __post_init__ ( self , * args , ** kwargs ) : [EOL] self . data_store = None [EOL] [EOL] class AdjustData ( Record ) : [EOL] activity_kind = ... [EOL] [EOL] class Event ( Record ) : [EOL] category = ... [EOL] event = ... [EOL] data = ... [EOL] [EOL] class AdjustRecord ( BaseAttribution ) : [EOL] event = ... [EOL] [EOL] x = AdjustRecord ( Event ( category = [string] , event = [string] , data = AdjustData ( [string] ) , ) ) [EOL] value = x . dumps ( serializer = [string] ) [EOL] value_dict = json . loads ( value ) [EOL] value_dict [ [string] ] [ [string] ] [ [string] ] = [string] [EOL] model = AdjustRecord . from_data ( value_dict ) [EOL] assert isinstance ( model . event , Event ) [EOL] assert isinstance ( model . event . data , AdjustData ) [EOL] [EOL] [EOL] ADTRIBUTE_PAYLOAD = [string] [EOL] [EOL] [EOL] def test_adtribute_payload ( app ) : [EOL] [EOL] class BaseAttribution ( Record , abc . ABC ) : [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . data_store = None [EOL] [EOL] class AdjustData ( Record ) : [EOL] [EOL] activity_kind = ... [EOL] network_name = ... [EOL] adid = ... [EOL] tracker = ... [EOL] reftag = ... [EOL] nonce = ... [EOL] campaign_name = None [EOL] adgroup_name = None [EOL] creative_name = None [EOL] click_referer = None [EOL] is_organic = None [EOL] reattribution_attribution_window = None [EOL] impression_attribution_window = None [EOL] store = None [EOL] match_type = None [EOL] platform_adid = None [EOL] search_term = None [EOL] event_name = None [EOL] installed_at = None [EOL] engagement_time = None [EOL] deeplink = None [EOL] source_user = None [EOL] [EOL] class User ( Record ) : [EOL] username = ... [EOL] [EOL] class App ( Record ) : [EOL] version = ... [EOL] app_id = ... [EOL] [EOL] class Device ( Record ) : [EOL] platform = ... [EOL] device_id = ... [EOL] os_version = ... [EOL] device_version = ... [EOL] manufacturer = ... [EOL] [EOL] class Event ( Record ) : [EOL] category = ... [EOL] event = ... [EOL] data = ... [EOL] [EOL] class AdjustRecord ( BaseAttribution ) : [EOL] user = ... [EOL] device = ... [EOL] app = ... [EOL] event = ... [EOL] timestamp = ... [EOL] client_ip = None [EOL] event_hash = None [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . data_store = None [EOL] [EOL] app . serializers . loads_value ( AdjustRecord , ADTRIBUTE_PAYLOAD , serializer = [string] ) [EOL] [EOL] [EOL] def test_overwrite_asdict ( ) : [EOL] [EOL] with pytest . raises ( RuntimeError ) : [EOL] [EOL] class R ( Record ) : [EOL] [EOL] def asdict ( self ) : [EOL] return { [string] : [number] } [EOL] [EOL] [EOL] def test_prepare_dict ( ) : [EOL] [EOL] class Quote ( Record ) : [EOL] ask_price = None [EOL] bid_price = None [EOL] [EOL] def _prepare_dict ( self , payload ) : [EOL] return { k : v for k , v in payload . items ( ) if v is not None } [EOL] [EOL] assert Quote ( ) . asdict ( ) == { } [EOL] assert Quote ( [number] , [number] ) . asdict ( ) == { [string] : [number] , [string] : [number] } [EOL] assert Quote ( None , [number] ) . asdict ( ) == { [string] : [number] } [EOL] [EOL] [EOL] def test_custom_init_calling_model_init ( ) : [EOL] [EOL] class Quote ( Record ) : [EOL] ask_price = ... [EOL] bid_price = ... [EOL] [EOL] def __init__ ( self , ask_price , bid_price , ** kwargs ) : [EOL] self . _model_init ( ask_price , bid_price , ** kwargs ) [EOL] [EOL] q1 = Quote ( [number] , [number] ) [EOL] assert q1 . ask_price == [number] [EOL] assert q1 . bid_price == [number] [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] Quote ( [number] , [number] , foo = [number] ) [EOL] [EOL] [EOL] def test_repr ( ) : [EOL] assert repr ( Account . id ) [EOL] [EOL] [EOL] def test_ident ( ) : [EOL] assert Account . id . ident == [string] [EOL] [EOL] [EOL] def test_list_field_refers_to_self ( ) : [EOL] [EOL] class X ( Record ) : [EOL] id = ... [EOL] xs = ... [EOL] [EOL] x = X ( [number] , [ X ( [number] , [ X ( [number] , [ ] ) ] ) ] ) [EOL] [EOL] as_json = x . dumps ( serializer = [string] ) [EOL] loads = X . loads ( as_json , serializer = [string] ) [EOL] assert loads == x [EOL] [EOL] assert isinstance ( loads . xs [ [number] ] , X ) [EOL] assert isinstance ( loads . xs [ [number] ] . xs [ [number] ] , X ) [EOL] [EOL] [EOL] def test_optional_modelfield ( ) : [EOL] [EOL] class X ( Record ) : [EOL] id = ... [EOL] [EOL] class Y ( Record ) : [EOL] x = None [EOL] [EOL] y = Y ( X ( [number] ) ) [EOL] [EOL] as_json = y . dumps ( serializer = [string] ) [EOL] loads = Y . loads ( as_json , serializer = [string] ) [EOL] assert loads == y [EOL] [EOL] assert isinstance ( loads . x , X ) [EOL] [EOL] [EOL] def test_optional_modelfield_with_coercion ( ) : [EOL] class X ( Record , coercions = { str : str } ) : [EOL] y = ... [EOL] [EOL] x = X ( y = [string] ) [EOL] [EOL] assert x . y == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , False ) , ( [string] , True ) , ( [string] , False ) , ] ) def test_subclass_inherit_flags ( flag , expected_default ) : [EOL] [EOL] class BaseX ( Record ) : [EOL] x = ... [EOL] [EOL] X = type ( [string] , ( BaseX , ) , { } , ** { flag : not expected_default } ) [EOL] Y = type ( [string] , ( X , ) , { } ) [EOL] Z = type ( [string] , ( Y , ) , { } , ** { flag : expected_default } ) [EOL] [EOL] assert getattr ( BaseX . _options , flag ) is expected_default [EOL] assert getattr ( X . _options , flag ) is not expected_default [EOL] assert getattr ( Y . _options , flag ) is not expected_default [EOL] assert getattr ( Z . _options , flag ) is expected_default [EOL] [EOL] [EOL] def test_abstract_model_repr ( ) : [EOL] [EOL] class MyBase ( faust . Record , abstract = True ) : [EOL] ... [EOL] [EOL] assert MyBase . __is_abstract__ [EOL] with pytest . raises ( NotImplementedError ) : [EOL] MyBase ( ) [EOL] [EOL] [EOL] def test_raises_when_defaults_in_wrong_order ( ) : [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] class X ( Record ) : [EOL] foo = ... [EOL] bar = [number] [EOL] baz = ... [EOL] [EOL] [EOL] def test_maybe_namespace_raises_for_missing_abstract_type ( ) : [EOL] class X ( Record ) : [EOL] foo = ... [EOL] [EOL] with pytest . raises ( KeyError ) : [EOL] X . _maybe_namespace ( { X . _blessed_key : { [string] : [string] } } , preferred_type = ModelT ) [EOL] [EOL] [EOL] def test_compat_loads_DeprecationWarning ( ) : [EOL] class X ( Record ) : [EOL] foo = ... [EOL] [EOL] payload = X ( [string] ) . dumps ( serializer = [string] ) [EOL] with pytest . warns ( DeprecationWarning ) : [EOL] X . loads ( payload , default_serializer = [string] ) [EOL] [EOL] [EOL] def test_model_overriding_Options_sets_options ( ) : [EOL] [EOL] class X ( Record ) : [EOL] foo = ... [EOL] [EOL] class Options : [EOL] coercions = { [string] : [string] } [EOL] foo = [number] [EOL] [EOL] with pytest . raises ( AttributeError ) : [EOL] X . Options [EOL] assert X . _options . coercions == { [string] : [string] } [EOL] assert X . _options . foo == [number] [EOL] [EOL] [EOL] def test_model_with_custom_hash ( ) : [EOL] class X ( Record ) : [EOL] foo = ... [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . foo [EOL] [EOL] assert hash ( X ( [number] ) ) == [number] [EOL] [EOL] [EOL] def test_model_with_custom_eq ( ) : [EOL] class X ( Record ) : [EOL] foo = ... [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return True [EOL] [EOL] assert X ( [number] ) == X ( [number] ) [EOL] [EOL] [EOL] def test_Record_comparison ( ) : [EOL] class X ( Record ) : [EOL] x = ... [EOL] y = ... [EOL] [EOL] assert X ( [number] , [number] ) > X ( [number] , [number] ) [EOL] assert X ( [number] , [number] ) >= X ( [number] , [number] ) [EOL] assert X ( [number] , [number] ) < X ( [number] , [number] ) [EOL] assert X ( [number] , [number] ) <= X ( [number] , [number] ) [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] X ( [number] ) >= object ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] X ( [number] ) <= object ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] X ( [number] ) < object ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] X ( [number] ) > object ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] object ( ) > X ( [number] ) [EOL] with pytest . raises ( TypeError ) : [EOL] object ( ) >= X ( [number] ) [EOL] with pytest . raises ( TypeError ) : [EOL] object ( ) < X ( [number] ) [EOL] with pytest . raises ( TypeError ) : [EOL] object ( ) <= X ( [number] ) [EOL] [EOL] [EOL] def test_maybe_model ( ) : [EOL] [EOL] class X ( Record ) : [EOL] x = ... [EOL] y = ... [EOL] [EOL] assert maybe_model ( [string] ) == [string] [EOL] assert maybe_model ( [number] ) == [number] [EOL] assert maybe_model ( [number] ) == [number] [EOL] [EOL] x1 = X ( [number] , [number] ) [EOL] assert maybe_model ( json . loads ( x1 . dumps ( serializer = [string] ) ) ) == x1 [EOL] [EOL] [EOL] def test_StringField ( ) : [EOL] [EOL] class Moo ( Record ) : [EOL] foo = StringField ( max_length = [number] , min_length = [number] , allow_blank = False ) [EOL] [EOL] too_long_moo = Moo ( [string] ) [EOL] too_short_moo = Moo ( [string] ) [EOL] perfect_moo = Moo ( [string] ) [EOL] [EOL] assert perfect_moo . is_valid ( ) [EOL] assert not too_long_moo . is_valid ( ) [EOL] assert not too_short_moo . is_valid ( ) [EOL] [EOL] assert not perfect_moo . validation_errors [EOL] assert too_long_moo . validation_errors [EOL] assert too_short_moo . validation_errors [EOL] [EOL] assert too_long_moo . foo == [string] [EOL] assert too_short_moo . foo == [string] [EOL] assert perfect_moo . foo == [string] [EOL] [EOL] assert not Moo ( [string] ) . is_valid ( ) [EOL] assert Moo ( [string] ) . validation_errors [EOL] assert [string] in str ( Moo ( [string] ) . validation_errors [ [number] ] ) [EOL] [EOL] [EOL] def test_StringField_optional__explicit ( ) : [EOL] [EOL] class Moo ( Record ) : [EOL] foo = StringField ( max_length = [number] , min_length = [number] , required = False , allow_blank = False ) [EOL] [EOL] moo = Moo ( ) [EOL] assert moo . foo is None [EOL] assert moo . is_valid ( ) [EOL] [EOL] [EOL] def test_StringField_optional__Optional ( ) : [EOL] [EOL] class Moo ( Record ) : [EOL] foo = StringField ( max_length = [number] , min_length = [number] , allow_blank = False ) [EOL] [EOL] moo = Moo ( ) [EOL] assert moo . foo is None [EOL] assert moo . is_valid ( ) [EOL] [EOL] [EOL] def test_validation_ensures_types_match ( ) : [EOL] [EOL] class Order ( Record , validation = True ) : [EOL] price = DecimalField ( ) [EOL] quantity = IntegerField ( ) [EOL] side = StringField ( ) [EOL] foo = FloatField ( required = False , default = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] Order ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] Order ( price = Decimal ( [string] ) ) [EOL] with pytest . raises ( TypeError ) : [EOL] Order ( price = Decimal ( [string] ) , quantity = [number] ) [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] Order ( price = [string] , quantity = [number] , side = [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] Order ( price = [string] , quantity = [string] , side = [string] ) [EOL] [EOL] assert Order ( price = Decimal ( [number] ) , quantity = [number] , side = [string] ) [EOL] [EOL] order = Order ( price = [string] , quantity = [string] , side = [string] , foo = [string] ) [EOL] assert order . price == Decimal ( [string] ) [EOL] assert isinstance ( order . price , Decimal ) [EOL] assert order . quantity == [number] [EOL] assert order . side == [string] [EOL] assert order . foo == [number] [EOL] assert isinstance ( order . foo , float ) [EOL] [EOL] [EOL] def test_Decimal_max_digits ( ) : [EOL] [EOL] class X ( Record , validation = True ) : [EOL] foo = DecimalField ( max_digits = [number] ) [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] X ( foo = [string] ) [EOL] [EOL] assert X ( foo = [string] ) . foo [EOL] [EOL] [EOL] def test_StringField_trim_whitespace ( ) : [EOL] [EOL] class X ( Record , validation = True ) : [EOL] foo = StringField ( trim_whitespace = True ) [EOL] [EOL] assert X ( foo = [string] ) . foo == [string] [EOL] [EOL] [EOL] def test_BytesField ( ) : [EOL] [EOL] class X ( Record , validation = True ) : [EOL] foo = BytesField ( max_length = [number] , min_length = [number] ) [EOL] [EOL] assert X ( foo = [string] ) . foo == [string] [EOL] [EOL] [EOL] def test_BytesField_trim_whitespace ( ) : [EOL] [EOL] class X ( Record , validation = True ) : [EOL] foo = BytesField ( trim_whitespace = True ) [EOL] [EOL] assert X ( foo = [string] ) . foo == [string] [EOL] [EOL] [EOL] def test_field_descriptors_may_mix_with_non_defaults ( ) : [EOL] [EOL] class Person ( faust . Record , validation = True ) : [EOL] age = IntegerField ( min_value = [number] , max_value = [number] ) [EOL] name = ... [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] Person ( age = [number] , name = [string] ) [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] Person ( age = [number] , name = [string] ) [EOL] [EOL] [EOL] def test_field_descriptors_throws_type_error ( ) : [EOL] [EOL] class Person ( faust . Record ) : [EOL] age = ... [EOL] name = ... [EOL] [EOL] person = Person ( age = [string] , name = [string] ) [EOL] assert person . validation_errors [EOL] [EOL] [EOL] def test_implicit_descritor_types ( ) : [EOL] [EOL] class X ( Record ) : [EOL] a = ... [EOL] b = ... [EOL] c = ... [EOL] d = ... [EOL] e = ... [EOL] [EOL] assert isinstance ( X . a , IntegerField ) [EOL] assert isinstance ( X . b , FloatField ) [EOL] assert isinstance ( X . c , StringField ) [EOL] assert isinstance ( X . d , BytesField ) [EOL] assert isinstance ( X . e , DecimalField ) [EOL] [EOL] [EOL] def test_exclude ( ) : [EOL] [EOL] class X ( Record ) : [EOL] a = ... [EOL] b = ... [EOL] c = StringField ( exclude = True ) [EOL] [EOL] x = X ( [string] , [string] , [string] ) [EOL] [EOL] assert X . a . required [EOL] assert X . b . required [EOL] assert X . c . required [EOL] [EOL] assert not X . a . exclude [EOL] assert not X . b . exclude [EOL] assert X . c . exclude [EOL] [EOL] assert x . asdict ( ) == { [string] : [string] , [string] : [string] } [EOL] [EOL] assert [string] not in x . to_representation ( ) [EOL] [EOL] [EOL] def test_custom_field_validation ( ) : [EOL] [EOL] class ChoiceField ( FieldDescriptor [ str ] ) : [EOL] [EOL] def __init__ ( self , choices , ** kwargs ) : [EOL] self . choices = choices [EOL] [comment] [EOL] [comment] [EOL] super ( ) . __init__ ( choices = choices , ** kwargs ) [EOL] [EOL] def validate ( self , value ) : [EOL] if value not in self . choices : [EOL] choices = [string] . join ( self . choices ) [EOL] yield self . validation_error ( f' [string] { self . field } [string] { choices }' ) [EOL] [EOL] class Order ( faust . Record , validation = True ) : [EOL] side = ChoiceField ( [ [string] , [string] ] ) [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] Order ( side = [string] ) [EOL] [EOL] class Order2 ( faust . Record , validation = True ) : [EOL] side = ChoiceField ( [ [string] , [string] ] , required = False ) [EOL] [EOL] assert Order2 ( ) [EOL] [EOL] [EOL] def test_custom_field__internal_errot ( ) : [EOL] [EOL] class XField ( FieldDescriptor [ str ] ) : [EOL] [EOL] def prepare_value ( self , value , coerce = None ) : [EOL] if coerce : [EOL] raise RuntimeError ( ) [EOL] return value [EOL] [EOL] class Foo ( Record , coerce = False ) : [EOL] foo = XField ( ) [EOL] [EOL] f = Foo ( [string] ) [EOL] assert f . validation_errors [EOL] assert [string] in str ( f . validation_errors [ [number] ] ) [EOL] [EOL] [EOL] def test_datetime_does_not_coerce ( ) : [EOL] [EOL] class X ( Record , coerce = False ) : [EOL] d = ... [EOL] [EOL] date_string = [string] [EOL] assert X ( date_string ) . d == date_string [EOL] [EOL] [EOL] def test_datetime_custom_date_parser ( ) : [EOL] [EOL] class X ( Record , coerce = True , date_parser = parse_date ) : [EOL] d = ... [EOL] [EOL] date_string = [string] [EOL] assert X . from_data ( { [string] : date_string } ) . d == parse_date ( date_string ) [EOL] [EOL] [EOL] def test_float_does_not_coerce ( ) : [EOL] [EOL] class X ( Record , coerce = False ) : [EOL] f = ... [EOL] X . make_final ( ) [comment] [EOL] [EOL] assert X ( [string] ) . f == [string] [EOL] [EOL] [EOL] def test_payload_with_reserved_keyword ( ) : [EOL] [EOL] class X ( Record ) : [EOL] location = StringField ( input_name = [string] ) [EOL] foo = StringField ( required = False , default = [string] , input_name = [string] , output_name = [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] X ( ) [EOL] [EOL] assert X ( [string] ) . location == [string] [EOL] assert X ( location = [string] ) . location == [string] [EOL] [EOL] d = X . from_data ( { [string] : [string] , [string] : [string] } ) [EOL] assert d . location == [string] [EOL] assert d . foo == [string] [EOL] [EOL] assert d . asdict ( ) == { [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] class LazyX ( Record , lazy_creation = True ) : [EOL] y = ... [EOL] [EOL] [EOL] class EagerY ( Record ) : [EOL] x = ... [EOL] [EOL] [EOL] def test_lazy_creation ( ) : [EOL] assert LazyX . _pending_finalizers [EOL] LazyX . make_final ( ) [EOL] assert LazyX . _pending_finalizers is None [EOL] [EOL] [EOL] def test_Sensitive ( * , capsys ) : [EOL] [EOL] class Foo ( Record ) : [EOL] name = ... [EOL] phone_number = ... [EOL] [EOL] class Bar ( Record ) : [EOL] alias = ... [EOL] foo = ... [EOL] [EOL] class Baz ( Record ) : [EOL] alias = ... [EOL] bar = ... [EOL] [EOL] x = Foo ( name = [string] , phone_number = [string] ) [EOL] [EOL] assert Foo . _options . has_sensitive_fields [EOL] assert Foo . _options . has_tagged_fields [EOL] assert not Foo . _options . has_secret_fields [EOL] assert not Foo . _options . has_personal_fields [EOL] [EOL] assert [string] in Foo . _options . sensitive_fields [EOL] assert [string] not in Foo . _options . sensitive_fields [EOL] [EOL] [comment] [EOL] assert Bar . _options . has_sensitive_fields [EOL] assert [string] in Bar . _options . sensitive_fields [EOL] assert [string] not in Bar . _options . sensitive_fields [EOL] [EOL] assert Baz . _options . has_sensitive_fields [EOL] assert [string] in Baz . _options . sensitive_fields [EOL] assert [string] not in Baz . _options . sensitive_fields [EOL] [EOL] assert x . name == [string] [EOL] with pytest . raises ( SecurityError ) : [EOL] str ( x . phone_number ) [EOL] assert x . phone_number . get_value ( ) == [string] [EOL] [EOL] with pytest . raises ( SecurityError ) : [EOL] f' [string] { x . name } [string] { x . phone_number }' [EOL] [EOL] logger . critical ( [string] , x . phone_number ) [EOL] stderr_content = capsys . readouterr ( ) [EOL] assert [string] in stderr_content . err [EOL] assert [string] in stderr_content . err [EOL] [EOL] def exclaim ( x ) : [EOL] assert isinstance ( x , _FrameLocal ) [EOL] return f'{ x } [string] ' [EOL] [EOL] with pytest . raises ( SecurityError ) : [EOL] exclaim ( x . phone_number . get_value ( ) ) [EOL] [EOL] def upper ( x ) : [EOL] return x . upper ( ) [EOL] [EOL] with pytest . raises ( SecurityError ) : [EOL] upper ( x . phone_number . get_value ( ) ) [EOL] [EOL] with allow_protected_vars ( ) : [EOL] assert upper ( x . phone_number . get_value ( ) ) == [string] [EOL] [EOL] [EOL] def test_Secret ( * , caplog ) : [EOL] [EOL] class Foo ( Record ) : [EOL] name = ... [EOL] phone_number = ... [EOL] [EOL] class Bar ( Record ) : [EOL] alias = ... [EOL] foo = ... [EOL] [EOL] class Baz ( Record ) : [EOL] alias = ... [EOL] bar = ... [EOL] [EOL] x = Foo ( name = [string] , phone_number = [string] ) [EOL] [EOL] assert Foo . _options . has_secret_fields [EOL] assert not Foo . _options . has_sensitive_fields [EOL] assert Foo . _options . has_tagged_fields [EOL] assert not Foo . _options . has_personal_fields [EOL] [EOL] assert [string] in Foo . _options . secret_fields [EOL] assert [string] not in Foo . _options . secret_fields [EOL] [EOL] [comment] [EOL] assert Bar . _options . has_secret_fields [EOL] assert [string] in Bar . _options . secret_fields [EOL] assert [string] not in Bar . _options . secret_fields [EOL] [EOL] assert Baz . _options . has_secret_fields [EOL] assert [string] in Baz . _options . secret_fields [EOL] assert [string] not in Baz . _options . secret_fields [EOL] [EOL] assert x . name == [string] [EOL] assert str ( x . phone_number ) == x . phone_number . mask [EOL] assert x . phone_number . get_value ( ) == [string] [EOL] [EOL] assert ( f' [string] { x . name } [string] { x . phone_number }' == f' [string] { x . name } [string] { x . phone_number . mask }' ) [EOL] [EOL] logger . critical ( [string] , x . phone_number ) [EOL] [EOL] assert x . phone_number . get_value ( ) not in caplog . text [EOL] assert x . phone_number . mask in caplog . text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Account]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[Account]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Account]$ 0 0 0 0 0 0 0 0 0 0 0 0 $'List[Account]'$ 0 0 0 0 0 0 0 0 0 0 0 0 $'Set[Account]'$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,'Account']$ 0 0 0 $'ClassVar[bool]'$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $Account$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[datetime.datetime,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.int,datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[datetime.datetime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[datetime.datetime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[datetime.datetime,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.int,datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[datetime.datetime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[datetime.datetime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[decimal.Decimal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[decimal.Decimal,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[decimal.Decimal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[decimal.Decimal,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Foo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.List]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List,...]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.User$ 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $datetime.datetime$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.set$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.frozenset$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.test_supports_post_init.X$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $Address$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.test_default_no_blessed_key.LooksLikeX$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.test_default_no_blessed_key.LooksLikeX$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $AdjustData$ 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.test_default_multiple_levels_no_blessed_key.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $AdjustData$ 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.test_default_multiple_levels_no_blessed_key.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $AdjustData$ 0 0 0 0 0 0 0 0 0 0 0 $t.functional.test_models.User$ 0 0 0 $Device$ 0 0 0 $App$ 0 0 0 $t.functional.test_models.test_default_multiple_levels_no_blessed_key.Event$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List['X']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[t.functional.test_models.test_supports_post_init.X]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'EagerY'$ 0 0 0 0 0 0 0 0 0 0 0 0 $LazyX$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $faust.models.tags.Sensitive[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[Bar]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $faust.models.tags.Secret[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] from aiokafka . structs import TopicPartition [EOL] from faust . types import TP [EOL] [EOL] [EOL] def test_TP_TopicPartition_hashability ( ) : [EOL] d = { } [EOL] d [ TP ( [string] , [number] ) ] = [number] [EOL] assert d [ TopicPartition ( [string] , [number] ) ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import pathlib [EOL] import typing [EOL] import t [EOL] import test_settings [EOL] import socket [EOL] import sys [EOL] from typing import Any , Mapping , NamedTuple [EOL] from pathlib import Path [EOL] [EOL] import faust [EOL] import mode [EOL] import pytest [EOL] import pytz [EOL] [EOL] from mode . supervisors import OneForAllSupervisor [EOL] from mode . utils . mocks import patch [EOL] from yarl import URL [EOL] [EOL] from faust import App [EOL] from faust . app import BootStrategy [EOL] from faust . assignor import LeaderAssignor , PartitionAssignor [EOL] from faust . exceptions import AlreadyConfiguredWarning , ImproperlyConfigured [EOL] from faust . app . router import Router [EOL] from faust . sensors import Monitor [EOL] from faust . serializers import Registry [EOL] from faust . tables import TableManager [EOL] from faust . transport . utils import DefaultSchedulingStrategy [EOL] from faust . types . enums import ProcessingGuarantee [EOL] from faust . types . settings import Settings [EOL] from faust . types . settings . params import Param [EOL] from faust . types . web import ResourceOptions [EOL] [EOL] TABLEDIR = ... [EOL] DATADIR = ... [EOL] if sys . platform == [string] : [EOL] TABLEDIR = Path ( [string] ) [EOL] DATADIR = Path ( [string] ) [EOL] else : [EOL] DATADIR = Path ( [string] ) [EOL] TABLEDIR = Path ( [string] ) [EOL] [EOL] [EOL] class OtherSchedulingStrategy ( DefaultSchedulingStrategy ) : [EOL] ... [EOL] [EOL] [EOL] def _dummy_partitioner ( a , b , c ) : [EOL] return [number] [EOL] [EOL] [EOL] class EnvCase ( NamedTuple ) : [EOL] env = ... [EOL] setting = ... [EOL] expected_value = ... [EOL] [EOL] [EOL] class test_settings : [EOL] [EOL] def App ( self , id = [string] , ** kwargs ) : [EOL] app = App ( id , ** kwargs ) [EOL] app . finalize ( ) [EOL] return app [EOL] [EOL] def test_env_with_prefix ( self ) : [EOL] env = { [string] : [string] , } [EOL] app = self . App ( env = env , env_prefix = [string] , broker = [string] ) [EOL] assert app . conf . broker == [ URL ( [string] ) ] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ EnvCase ( env = { [string] : [string] } , setting = Settings . datadir , expected_value = Path ( [string] ) , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . tabledir , expected_value = Path ( [string] ) , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . debug , expected_value = True , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . debug , expected_value = False , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . debug , expected_value = False , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . debug , expected_value = False , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . timezone , expected_value = pytz . timezone ( [string] ) , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . version , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . agent_supervisor , expected_value = OneForAllSupervisor , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . blocking_timeout , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . blocking_timeout , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker , expected_value = [ URL ( [string] ) ] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker , expected_value = [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) ] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_consumer , expected_value = [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) ] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_producer , expected_value = [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) ] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_consumer , expected_value = [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) ] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_producer , expected_value = [ URL ( [string] ) , URL ( [string] ) , URL ( [string] ) ] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_api_version , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . consumer_api_version , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . consumer_api_version , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_api_version , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_api_version , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_check_crcs , expected_value = False , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_client_id , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_commit_every , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_commit_interval , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_commit_interval , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_commit_livelock_soft_timeout , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_heartbeat_interval , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_max_poll_interval , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_max_poll_records , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_rebalance_timeout , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_request_timeout , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . broker_session_timeout , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . consumer_max_fetch_size , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . consumer_auto_offset_reset , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . key_serializer , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . value_serializer , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_acks , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_acks , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_acks , expected_value = - [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_compression_type , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_linger , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_linger , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_max_batch_size , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_max_request_size , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . producer_request_timeout , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . reply_create_topic , expected_value = True , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . reply_expires , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . reply_to_prefix , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . processing_guarantee , expected_value = ProcessingGuarantee . EXACTLY_ONCE , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . processing_guarantee , expected_value = ProcessingGuarantee . AT_LEAST_ONCE , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . stream_buffer_maxsize , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . stream_processing_timeout , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . stream_recovery_delay , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . stream_wait_empty , expected_value = False , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . stream_wait_empty , expected_value = True , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . store , expected_value = URL ( [string] ) , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . table_cleanup_interval , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . table_key_index_size , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . table_standby_replicas , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . topic_allow_declare , expected_value = False , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . topic_allow_declare , expected_value = True , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . topic_disable_leader , expected_value = False , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . topic_disable_leader , expected_value = True , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . topic_partitions , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . topic_replication_factor , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . cache , expected_value = URL ( [string] ) , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . web_bind , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . web_enabled , expected_value = False , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . web_host , expected_value = [string] , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . canonical_url , expected_value = URL ( [string] ) , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . web_port , expected_value = [number] , ) , EnvCase ( env = { [string] : [string] , [string] : [string] } , setting = Settings . canonical_url , expected_value = URL ( [string] ) , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . worker_redirect_stdouts , expected_value = False , ) , EnvCase ( env = { [string] : [string] } , setting = Settings . worker_redirect_stdouts_level , expected_value = [string] , ) , ] ) def test_env ( self , env , setting , expected_value ) : [EOL] app = self . App ( env = env ) [EOL] self . assert_expected ( setting . __get__ ( app . conf ) , expected_value ) [EOL] [EOL] [comment] [EOL] prefixed_env = { [string] + k : v for k , v in env . items ( ) } [EOL] app2 = self . App ( env = prefixed_env , env_prefix = [string] ) [EOL] self . assert_expected ( setting . __get__ ( app2 . conf ) , expected_value ) [EOL] [EOL] [comment] [EOL] prefixed_env2 = { [string] + k : v for k , v in env . items ( ) } [EOL] prefixed_env2 [ [string] ] = [string] [EOL] app3 = self . App ( env = prefixed_env2 ) [EOL] assert app3 . conf . env_prefix == [string] [EOL] self . assert_expected ( setting . __get__ ( app3 . conf ) , expected_value ) [EOL] [EOL] def assert_expected ( self , value , expected_value ) : [EOL] if expected_value is None : [EOL] assert value is None [EOL] elif expected_value is True : [EOL] assert value is True [EOL] elif expected_value is False : [EOL] assert value is False [EOL] else : [EOL] assert value == expected_value [EOL] [EOL] def test_defaults ( self ) : [EOL] app = self . App ( ) [EOL] conf = app . conf [EOL] assert not conf . debug [EOL] assert conf . broker == [ URL ( Settings . DEFAULT_BROKER_URL ) ] [EOL] assert conf . broker_consumer == [ URL ( Settings . DEFAULT_BROKER_URL ) ] [EOL] assert conf . broker_producer == [ URL ( Settings . DEFAULT_BROKER_URL ) ] [EOL] assert conf . store == URL ( Settings . store . default ) [EOL] assert conf . cache == URL ( Settings . cache . default ) [EOL] assert conf . web == URL ( Settings . web . default ) [EOL] assert conf . web_enabled [EOL] assert not conf . web_in_thread [EOL] assert conf . datadir == Path ( [string] ) [EOL] assert conf . tabledir == Path ( [string] ) [EOL] assert conf . blocking_timeout is None [EOL] assert conf . processing_guarantee == ProcessingGuarantee . AT_LEAST_ONCE [EOL] assert conf . broker_api_version == Settings . broker_api_version . default [EOL] assert conf . broker_client_id == Settings . broker_client_id . default [EOL] assert ( conf . broker_request_timeout == Settings . broker_request_timeout . default ) [EOL] assert ( conf . broker_session_timeout == Settings . broker_session_timeout . default ) [EOL] assert ( conf . broker_rebalance_timeout == Settings . broker_rebalance_timeout . default ) [EOL] assert ( conf . broker_heartbeat_interval == Settings . broker_heartbeat_interval . default ) [EOL] assert ( conf . broker_commit_interval == Settings . broker_commit_interval . default ) [EOL] assert ( conf . broker_commit_every == Settings . broker_commit_every . default ) [EOL] assert ( conf . broker_commit_livelock_soft_timeout == Settings . broker_commit_livelock_soft_timeout . default ) [EOL] assert conf . broker_check_crcs [EOL] assert ( conf . consumer_api_version == Settings . broker_api_version . default ) [EOL] assert conf . timezone is Settings . timezone . default [EOL] assert ( conf . table_cleanup_interval == Settings . table_cleanup_interval . default ) [EOL] assert ( conf . table_key_index_size == Settings . table_key_index_size . default ) [EOL] assert conf . reply_to_prefix == Settings . reply_to_prefix . default [EOL] assert conf . reply_expires == Settings . reply_expires . default [EOL] assert ( conf . stream_buffer_maxsize == Settings . stream_buffer_maxsize . default ) [EOL] assert ( conf . stream_recovery_delay == Settings . stream_recovery_delay . default ) [EOL] assert ( conf . stream_processing_timeout == Settings . stream_processing_timeout . default ) [EOL] assert ( conf . producer_partitioner == Settings . producer_partitioner . default ) [EOL] assert ( conf . producer_request_timeout == Settings . producer_request_timeout . default ) [EOL] assert ( conf . producer_api_version == Settings . broker_api_version . default ) [EOL] assert conf . producer_linger == [number] [EOL] assert ( conf . stream_publish_on_commit == Settings . stream_publish_on_commit . default ) [EOL] assert conf . stream_wait_empty [EOL] assert ( conf . broker_max_poll_records == Settings . broker_max_poll_records . default ) [EOL] assert ( conf . broker_max_poll_interval == Settings . broker_max_poll_interval . default ) [EOL] assert ( conf . consumer_auto_offset_reset == Settings . consumer_auto_offset_reset . default ) [EOL] assert not conf . autodiscover [EOL] assert conf . origin is None [EOL] assert conf . key_serializer == [string] [EOL] assert conf . value_serializer == [string] [EOL] assert conf . reply_to is not None [EOL] assert not conf . reply_create_topic [EOL] assert conf . table_standby_replicas == [number] [EOL] assert conf . topic_replication_factor == [number] [EOL] assert conf . topic_partitions == [number] [EOL] assert conf . topic_allow_declare [EOL] assert not conf . topic_disable_leader [EOL] assert conf . logging_config is None [EOL] assert conf . loghandlers == [ ] [EOL] assert conf . version == [number] [EOL] assert conf . canonical_url == URL ( f' [string] { socket . gethostname ( ) } [string] ' ) [EOL] assert conf . web_bind == [string] [EOL] assert conf . web_port == [number] [EOL] assert conf . web_transport == Settings . web_transport . default [EOL] assert conf . web_cors_options is None [EOL] assert conf . worker_redirect_stdouts [EOL] assert conf . worker_redirect_stdouts_level == [string] [EOL] [EOL] assert conf . agent_supervisor is mode . OneForOneSupervisor [EOL] [EOL] assert conf . Agent is faust . Agent [EOL] assert conf . ConsumerScheduler is DefaultSchedulingStrategy [EOL] assert conf . Event is faust . Event [EOL] assert conf . Schema is faust . Schema [EOL] assert conf . Stream is faust . Stream [EOL] assert conf . Table is faust . Table [EOL] assert conf . TableManager is TableManager [EOL] assert conf . Serializers is Registry [EOL] assert conf . Worker is faust . Worker [EOL] assert conf . PartitionAssignor is PartitionAssignor [EOL] assert conf . LeaderAssignor is LeaderAssignor [EOL] assert conf . Router is Router [EOL] assert conf . Topic is faust . Topic [EOL] from aiohttp . client import ClientSession [EOL] assert conf . HttpClient is ClientSession [EOL] assert conf . Monitor is Monitor [EOL] [EOL] def test_reply_prefix_unique ( self ) : [EOL] app1 = self . App ( ) [EOL] app2 = self . App ( ) [EOL] assert app1 . conf . reply_to != app2 . conf . reply_to [EOL] [EOL] def test_app_config ( self ) : [EOL] self . assert_config_equivalent ( ) [EOL] [EOL] def test_broker_as_URL ( self ) : [EOL] app = self . assert_config_equivalent ( broker = [string] ) [EOL] assert isinstance ( app . conf . broker , list ) [EOL] assert app . conf . broker [ [number] ] == URL ( [string] ) [EOL] [EOL] def test_store_as_URL ( self ) : [EOL] app = self . assert_config_equivalent ( store = URL ( [string] ) ) [EOL] assert isinstance ( app . conf . store , URL ) [EOL] [EOL] def test_cache_as_URL ( self ) : [EOL] app = self . assert_config_equivalent ( cache = URL ( [string] ) ) [EOL] assert isinstance ( app . conf . cache , URL ) [EOL] [EOL] def test_web_as_URL ( self ) : [EOL] app = self . assert_config_equivalent ( web = URL ( [string] ) ) [EOL] assert isinstance ( app . conf . web , URL ) [EOL] [EOL] def test_datadir_as_Path ( self ) : [EOL] app = self . assert_config_equivalent ( datadir = DATADIR ) [EOL] assert isinstance ( app . conf . datadir , Path ) [EOL] [EOL] def test_tabledir_is_relative_to_path ( self ) : [EOL] app = self . assert_config_equivalent ( datadir = str ( DATADIR ) , tabledir = [string] , ) [EOL] assert app . conf . tabledir == app . conf . appdir / Path ( [string] ) [EOL] [EOL] def assert_config_equivalent ( self , id = [string] , version = [number] , broker = [string] , store = [string] , cache = [string] , web = [string] , web_enabled = False , autodiscover = True , origin = [string] , canonical_url = [string] , broker_client_id = [string] , datadir = str ( DATADIR ) , tabledir = str ( TABLEDIR ) , processing_guarantee = [string] , blocking_timeout = [number] , broker_api_version = [string] , broker_request_timeout = [number] , broker_heartbeat_interval = [number] , broker_session_timeout = [number] , broker_rebalance_timeout = [number] , broker_commit_every = [number] , broker_commit_interval = [number] , broker_commit_livelock_soft_timeout = [number] , broker_check_crcs = False , broker_producer = [string] , broker_consumer = [string] , consumer_api_version = [string] , producer_partitioner = _dummy_partitioner , producer_request_timeout = [number] , producer_api_version = [string] , producer_linger = [number] , table_cleanup_interval = [number] , table_key_index_size = [number] , key_serializer = [string] , value_serializer = [string] , table_standby_replicas = [number] , topic_replication_factor = [number] , topic_allow_declare = False , topic_disable_leader = True , reply_to = [string] , reply_create_topic = True , reply_expires = [number] , stream_buffer_maxsize = [number] , stream_wait_empty = True , stream_publish_on_commit = False , stream_recovery_delay = [number] , stream_processing_timeout = [number] , web_bind = [string] , web_port = [number] , web_host = [string] , web_transport = [string] , web_in_thread = True , web_cors_options = { [string] : ResourceOptions ( allow_credentials = True , expose_headers = [string] , allow_headers = [string] , max_age = [number] , allow_methods = [string] , ) , } , worker_redirect_stdouts = False , worker_redirect_stdouts_level = [string] , broker_max_poll_records = [number] , broker_max_poll_interval = [number] , timezone = pytz . timezone ( [string] ) , logging_config = { [string] : [number] } , consumer_auto_offset_reset = [string] , ConsumerScheduler = OtherSchedulingStrategy , ** kwargs ) : [EOL] livelock_soft_timeout = broker_commit_livelock_soft_timeout [EOL] app = self . App ( id , version = version , broker = broker , broker_consumer = broker_consumer , broker_producer = broker_producer , store = store , cache = cache , web = web , web_enabled = web_enabled , autodiscover = autodiscover , origin = origin , canonical_url = canonical_url , blocking_timeout = blocking_timeout , broker_client_id = broker_client_id , datadir = datadir , tabledir = tabledir , processing_guarantee = processing_guarantee , broker_api_version = broker_api_version , broker_request_timeout = broker_request_timeout , broker_session_timeout = broker_session_timeout , broker_rebalance_timeout = broker_rebalance_timeout , broker_heartbeat_interval = broker_heartbeat_interval , broker_commit_every = broker_commit_every , broker_commit_interval = broker_commit_interval , broker_commit_livelock_soft_timeout = livelock_soft_timeout , broker_check_crcs = broker_check_crcs , broker_max_poll_records = broker_max_poll_records , broker_max_poll_interval = broker_max_poll_interval , consumer_api_version = consumer_api_version , producer_partitioner = producer_partitioner , producer_request_timeout = producer_request_timeout , producer_api_version = producer_api_version , producer_linger = producer_linger , table_cleanup_interval = table_cleanup_interval , table_key_index_size = table_key_index_size , key_serializer = key_serializer , value_serializer = value_serializer , table_standby_replicas = table_standby_replicas , topic_replication_factor = topic_replication_factor , topic_allow_declare = topic_allow_declare , topic_disable_leader = topic_disable_leader , reply_to = reply_to , reply_create_topic = reply_create_topic , reply_expires = reply_expires , stream_buffer_maxsize = stream_buffer_maxsize , stream_wait_empty = stream_wait_empty , stream_publish_on_commit = stream_publish_on_commit , stream_recovery_delay = stream_recovery_delay , stream_processing_timeout = stream_processing_timeout , timezone = timezone , web_bind = web_bind , web_port = web_port , web_host = web_host , web_transport = web_transport , web_in_thread = web_in_thread , web_cors_options = web_cors_options , worker_redirect_stdouts = worker_redirect_stdouts , worker_redirect_stdouts_level = worker_redirect_stdouts_level , logging_config = logging_config , consumer_auto_offset_reset = consumer_auto_offset_reset , ConsumerScheduler = ConsumerScheduler , ) [EOL] conf = app . conf [EOL] assert conf . id == app . conf . _prepare_id ( id ) [EOL] assert conf . broker == [ URL ( broker ) ] [EOL] assert conf . broker_consumer == [ URL ( broker_consumer ) ] [EOL] assert conf . broker_producer == [ URL ( broker_producer ) ] [EOL] assert conf . blocking_timeout == blocking_timeout [EOL] assert conf . store == URL ( str ( store ) ) [EOL] assert conf . cache == URL ( str ( cache ) ) [EOL] assert conf . web == URL ( str ( web ) ) [EOL] assert not conf . web_enabled [EOL] assert conf . web_in_thread [EOL] assert conf . autodiscover == autodiscover [EOL] assert conf . canonical_url == URL ( str ( canonical_url ) ) [EOL] assert conf . broker_client_id == broker_client_id [EOL] assert conf . datadir == Path ( str ( datadir ) ) [EOL] if Path ( tabledir ) . is_absolute ( ) : [EOL] assert conf . tabledir == Path ( str ( tabledir ) ) [EOL] else : [EOL] assert conf . tabledir . relative_to ( conf . appdir ) == Path ( tabledir ) [EOL] assert conf . processing_guarantee == ProcessingGuarantee . EXACTLY_ONCE [EOL] assert conf . broker_api_version == broker_api_version [EOL] assert conf . broker_request_timeout == broker_request_timeout [EOL] assert conf . broker_heartbeat_interval == broker_heartbeat_interval [EOL] assert conf . broker_session_timeout == broker_session_timeout [EOL] assert conf . broker_rebalance_timeout == broker_rebalance_timeout [EOL] assert conf . broker_commit_every == broker_commit_every [EOL] assert conf . broker_commit_interval == broker_commit_interval [EOL] assert ( conf . broker_commit_livelock_soft_timeout == broker_commit_livelock_soft_timeout ) [EOL] assert conf . broker_check_crcs == broker_check_crcs [EOL] assert conf . consumer_api_version == consumer_api_version [EOL] assert conf . producer_partitioner is producer_partitioner [EOL] assert conf . producer_request_timeout == producer_request_timeout [EOL] assert conf . producer_api_version == producer_api_version [EOL] assert conf . producer_linger == producer_linger [EOL] assert conf . table_cleanup_interval == table_cleanup_interval [EOL] assert conf . table_key_index_size == table_key_index_size [EOL] assert conf . key_serializer == key_serializer [EOL] assert conf . value_serializer == value_serializer [EOL] assert conf . table_standby_replicas == table_standby_replicas [EOL] assert conf . topic_replication_factor == topic_replication_factor [EOL] assert conf . topic_allow_declare == topic_allow_declare [EOL] assert conf . topic_disable_leader == topic_disable_leader [EOL] assert conf . reply_to == reply_to [EOL] assert conf . reply_expires == reply_expires [EOL] assert conf . stream_buffer_maxsize == stream_buffer_maxsize [EOL] assert conf . stream_wait_empty == stream_wait_empty [EOL] assert conf . stream_publish_on_commit == stream_publish_on_commit [EOL] assert conf . stream_recovery_delay == stream_recovery_delay [EOL] assert conf . stream_processing_timeout == stream_processing_timeout [EOL] assert conf . timezone is timezone [EOL] assert conf . web_bind == web_bind [EOL] assert conf . web_port == web_port [EOL] assert conf . web_host == web_host [EOL] assert conf . web_transport == URL ( web_transport ) [EOL] assert conf . web_cors_options == web_cors_options [EOL] assert conf . worker_redirect_stdouts == worker_redirect_stdouts [EOL] assert ( conf . worker_redirect_stdouts_level == worker_redirect_stdouts_level ) [EOL] assert conf . broker_max_poll_records == broker_max_poll_records [EOL] assert conf . broker_max_poll_interval == broker_max_poll_interval [EOL] assert conf . logging_config == logging_config [EOL] assert conf . consumer_auto_offset_reset == consumer_auto_offset_reset [EOL] assert conf . ConsumerScheduler is OtherSchedulingStrategy [EOL] return app [EOL] [EOL] def test_custom_host_port_to_canonical ( self , web_bind = [string] , web_port = [number] , web_host = [string] ) : [EOL] app = self . App ( [string] , web_bind = web_bind , web_port = web_port , web_host = web_host , ) [EOL] assert app . conf . canonical_url == URL ( f' [string] { app . conf . web_host } [string] { app . conf . web_port }' ) [EOL] [EOL] def test_producer_linger_ms__compat ( self ) : [EOL] app = self . App ( producer_linger_ms = [number] ) [EOL] assert app . conf . producer_linger == [number] [EOL] [EOL] def test_id_no_version ( self ) : [EOL] assert self . App ( [string] , version = [number] ) . conf . id == [string] [EOL] [EOL] def test_version_cannot_be_zero ( self ) : [EOL] app = App ( [string] , version = [number] ) [EOL] with pytest . raises ( ImproperlyConfigured ) : [EOL] app . finalize ( ) [EOL] [EOL] def test_compat_url ( self ) : [EOL] assert self . App ( url = [string] ) . conf . broker == [ URL ( [string] ) ] [EOL] [EOL] def test_compat_client_id ( self ) : [EOL] with pytest . warns ( FutureWarning ) : [EOL] assert self . App ( client_id = [string] ) . conf . broker_client_id == [string] [EOL] [EOL] def test_compat_commit_interval ( self ) : [EOL] with pytest . warns ( FutureWarning ) : [EOL] assert self . App ( commit_interval = [number] ) . conf . broker_commit_interval == [number] [EOL] [EOL] def test_compat_create_reply_topic ( self ) : [EOL] with pytest . warns ( FutureWarning ) : [EOL] assert self . App ( create_reply_topic = True ) . conf . reply_create_topic [EOL] with pytest . warns ( FutureWarning ) : [EOL] assert not self . App ( create_reply_topic = False ) . conf . reply_create_topic [EOL] [EOL] def test_compat_num_standby_replicas ( self ) : [EOL] with pytest . warns ( FutureWarning ) : [EOL] assert self . App ( num_standby_replicas = [number] ) . conf . table_standby_replicas == [number] [EOL] [EOL] def test_compat_stream_ack_cancelled_tasks ( self ) : [EOL] with pytest . warns ( UserWarning ) : [EOL] assert not self . App ( stream_ack_cancelled_tasks = False , ) . conf . stream_ack_cancelled_tasks [EOL] [EOL] def test_compat_stream_ack_exceptions ( self ) : [EOL] with pytest . warns ( UserWarning ) : [EOL] assert self . App ( stream_ack_exceptions = True ) . conf . stream_ack_exceptions [EOL] [EOL] def test_compat_default_partitions ( self ) : [EOL] with pytest . warns ( FutureWarning ) : [EOL] assert self . App ( default_partitions = [number] ) . conf . topic_partitions == [number] [EOL] [EOL] def test_compat_replication_factor ( self ) : [EOL] with pytest . warns ( FutureWarning ) : [EOL] assert self . App ( replication_factor = [number] ) . conf . topic_replication_factor == [number] [EOL] [EOL] def test_warns_when_key_already_configured ( self ) : [EOL] app = self . App ( topic_partitions = [number] , topic_replication_factor = [number] ) [EOL] assert app . conf . topic_partitions == [number] [EOL] with pytest . warns ( AlreadyConfiguredWarning ) : [EOL] app . conf . topic_partitions = [number] [EOL] assert app . conf . topic_partitions == [number] [EOL] app . conf . topic_replication_factor = [number] [EOL] assert app . conf . topic_replication_factor == [number] [EOL] [EOL] def test_broker_with_no_scheme_set ( self ) : [EOL] app = self . App ( broker = [string] ) [EOL] url = app . conf . broker [ [number] ] [EOL] assert url . scheme == Settings . broker . default_scheme [EOL] assert url . host == [string] [EOL] assert url . port == [number] [EOL] [EOL] def test_consumer_api_version__defaults_to_broker ( self ) : [EOL] expected_broker_version = [string] [EOL] app = self . App ( broker_api_version = expected_broker_version , consumer_api_version = None , ) [EOL] assert app . conf . consumer_api_version == expected_broker_version [EOL] [EOL] def test_producer_api_version__defaults_to_broker ( self ) : [EOL] expected_broker_version = [string] [EOL] app = self . App ( broker_api_version = expected_broker_version , producer_api_version = None , ) [EOL] assert app . conf . producer_api_version == expected_broker_version [EOL] [EOL] [EOL] class test_BootStrategy : [EOL] [EOL] def test_init ( self , * , app ) : [EOL] assert not BootStrategy ( app , enable_web = False ) . enable_web [EOL] assert BootStrategy ( app , enable_web = True ) . enable_web [EOL] assert not BootStrategy ( app , enable_kafka = False ) . enable_kafka [EOL] assert BootStrategy ( app , enable_kafka = True ) . enable_kafka [EOL] assert not BootStrategy ( app , enable_kafka_producer = False , ) . enable_kafka_producer [EOL] assert BootStrategy ( app , enable_kafka_producer = True , ) . enable_kafka_producer [EOL] assert not BootStrategy ( app , enable_kafka_consumer = False , ) . enable_kafka_consumer [EOL] assert BootStrategy ( app , enable_kafka_consumer = True , ) . enable_kafka_consumer [EOL] assert not BootStrategy ( app , enable_sensors = False ) . enable_sensors [EOL] assert BootStrategy ( app , enable_sensors = True ) . enable_sensors [EOL] [EOL] def test_sensors ( self , * , app ) : [EOL] assert BootStrategy ( app , enable_sensors = True ) . sensors ( ) is app . sensors [EOL] assert not BootStrategy ( app , enable_sensors = False ) . sensors ( ) [EOL] [EOL] def test_kafka_consumer ( self , * , app ) : [EOL] assert BootStrategy ( app , enable_kafka_consumer = True ) . kafka_consumer ( ) [EOL] assert BootStrategy ( app , enable_kafka_consumer = True ) . kafka_conductor ( ) [EOL] assert not BootStrategy ( app , enable_kafka_consumer = False ) . kafka_consumer ( ) [EOL] assert not BootStrategy ( app , enable_kafka_consumer = False ) . kafka_conductor ( ) [EOL] assert BootStrategy ( app , enable_kafka = True ) . kafka_consumer ( ) [EOL] assert BootStrategy ( app , enable_kafka = True ) . kafka_conductor ( ) [EOL] assert not BootStrategy ( app , enable_kafka = False ) . kafka_consumer ( ) [EOL] assert not BootStrategy ( app , enable_kafka = False ) . kafka_conductor ( ) [EOL] [EOL] def test_kafka_producer ( self , * , app ) : [EOL] assert BootStrategy ( app , enable_kafka_producer = True ) . kafka_producer ( ) [EOL] assert not BootStrategy ( app , enable_kafka_producer = False ) . kafka_producer ( ) [EOL] assert BootStrategy ( app , enable_kafka = True ) . kafka_producer ( ) [EOL] assert BootStrategy ( app , enable_kafka_producer = None ) . kafka_producer ( ) [EOL] assert not BootStrategy ( app , enable_kafka = False ) . kafka_producer ( ) [EOL] [EOL] def test_web_server ( self , * , app ) : [EOL] assert BootStrategy ( app , enable_web = True ) . web_server ( ) [EOL] assert not BootStrategy ( app , enable_web = False ) . web_server ( ) [EOL] assert BootStrategy ( app , enable_web = True ) . web_server ( ) [EOL] assert not BootStrategy ( app , enable_web = False ) . web_server ( ) [EOL] assert BootStrategy ( app , enable_web = None ) . web_server ( ) [EOL] [EOL] def test_disable_kafka ( self , * , app ) : [EOL] class B ( BootStrategy ) : [EOL] enable_kafka = False [EOL] [EOL] b = B ( app ) [EOL] assert not b . enable_kafka [EOL] assert not b . kafka_conductor ( ) [EOL] assert not b . kafka_consumer ( ) [EOL] assert not b . kafka_producer ( ) [EOL] [EOL] def test_disable_kafka_consumer ( self , * , app ) : [EOL] class B ( BootStrategy ) : [EOL] enable_kafka_consumer = False [EOL] [EOL] b = B ( app ) [EOL] assert b . enable_kafka [EOL] assert not b . kafka_conductor ( ) [EOL] assert not b . kafka_consumer ( ) [EOL] assert b . kafka_producer ( ) [EOL] [EOL] @ pytest . mark . app ( debug = True ) @ pytest . mark . asyncio async def test_debug_enabled_warns_on_start ( self , * , app ) : [EOL] with patch ( [string] ) as logger : [EOL] await app . on_start ( ) [EOL] logger . warning . assert_called_once ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,builtins.str]$ 0 0 0 $faust.types.settings.params.Param$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test_settings.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka.B$ 0 0 0 0 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka.B$ 0 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka.B$ 0 0 0 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka.B$ 0 0 0 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka.B$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka_consumer.B$ 0 0 0 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka_consumer.B$ 0 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka_consumer.B$ 0 0 0 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka_consumer.B$ 0 0 0 0 0 0 $t.functional.test_app.test_BootStrategy.test_disable_kafka_consumer.B$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import faust [EOL] [EOL] [EOL] def test_dir ( ) : [EOL] assert dir ( faust ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] from faust . sensors . statsd import StatsdMonitor [EOL] [EOL] PREFIX = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def mon ( ) : [EOL] return StatsdMonitor ( prefix = PREFIX ) [EOL] [EOL] [EOL] def stream_from_channel ( app ) : [EOL] return app . stream ( app . channel ( ) ) [EOL] [EOL] [EOL] def stream_from_topic ( app ) : [EOL] return app . stream ( app . topic ( [string] ) ) [EOL] [EOL] [EOL] def stream_from_multiple_topics ( app ) : [EOL] return app . stream ( app . topic ( [string] , [string] ) ) [EOL] [EOL] [EOL] def stream_from_combined_streams ( app ) : [EOL] return app . stream ( app . topic ( [string] ) ) & app . stream ( app . topic ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( stream_from_channel , [string] ) , ( stream_from_topic , [string] ) , ( stream_from_multiple_topics , [string] ) , ( stream_from_combined_streams , [string] ) , ] ) def test_stream_label ( make_stream , expected , * , app , mon ) : [EOL] assert mon . _stream_label ( make_stream ( app ) ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
import pytest [EOL] from faust . exceptions import SameNode [EOL] from mode . utils . mocks import Mock [EOL] [EOL] [EOL] @ pytest . yield_fixture ( ) def web_client ( loop , aiohttp_client , web ) : [EOL] try : [EOL] yield aiohttp_client ( web . web_app ) [EOL] finally : [EOL] [comment] [EOL] [comment] [EOL] if loop . _default_executor is not None : [EOL] loop . _default_executor . shutdown ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def router_same ( app ) : [EOL] app . router . route_req = Mock ( name = [string] ) [EOL] app . router . route_req . side_effect = SameNode ( ) [EOL] return app . router [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( ) def table_foo ( app ) : [EOL] return app . Table ( [string] , help = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def table_bar ( app ) : [EOL] return app . Table ( [string] , help = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def tables ( table_foo , table_bar ) : [EOL] return [ table_foo , table_bar ] [EOL] [EOL] [EOL] async def test_list_tables ( web_client , tables ) : [EOL] async with await web_client as client : [EOL] resp = await client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] payload = await resp . json ( ) [EOL] tables = { t [ [string] ] : t for t in payload } [EOL] assert [string] in tables [EOL] assert tables [ [string] ] [ [string] ] == [string] [EOL] assert [string] in tables [EOL] assert tables [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_table_detail ( web_client , tables ) : [EOL] async with await web_client as client : [EOL] resp = await client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] payload = await resp . json ( ) [EOL] assert payload [ [string] ] == [string] [EOL] assert payload [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_table_detail__missing_table ( web_client , tables ) : [EOL] async with await web_client as client : [EOL] resp = await client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] payload = await resp . json ( ) [EOL] assert payload == { [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] async def test_table_key ( web_client , tables , table_foo , router_same ) : [EOL] async with await web_client as client : [EOL] table_foo . data . data [ [string] ] = [string] [EOL] resp = await client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] payload = await resp . json ( ) [EOL] assert payload == [string] [EOL] [EOL] [EOL] async def test_table_key__missing_key ( web_client , tables , table_foo , router_same ) : [EOL] async with await web_client as client : [EOL] resp = await client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] payload = await resp . json ( ) [EOL] assert payload == { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import faust [EOL] import builtins [EOL] import pytest [EOL] from collections import Counter [EOL] from pprint import pformat [EOL] from typing import List , NamedTuple [EOL] from faust . exceptions import ImproperlyConfigured [EOL] from faust . types import EventT , StreamT [EOL] from . helpers import AgentCase [EOL] [EOL] [EOL] class _param ( NamedTuple ) : [EOL] partitions = ... [EOL] num_messages = ... [EOL] isolated_partitions = False [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( _param . _fields , [ _param ( [ [number] ] , [number] , isolated_partitions = True ) , _param ( [ [number] ] , [number] , isolated_partitions = False ) , _param ( list ( range ( [number] ) ) , [number] , isolated_partitions = True ) , _param ( list ( range ( [number] ) ) , [number] , isolated_partitions = False ) , _param ( list ( range ( [number] ) ) , [number] , isolated_partitions = True ) , _param ( list ( range ( [number] ) ) , [number] , isolated_partitions = True ) , _param ( list ( range ( [number] ) ) , [number] , isolated_partitions = False ) , ] ) async def test_agent_isolated_partitions ( partitions , num_messages , isolated_partitions , * , app , logging ) : [EOL] await AgentIsolatedCase . run_test ( app = app , num_messages = num_messages , concurrency = [number] , partitions = partitions , isolated_partitions = isolated_partitions , ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_agent_isolated_partitions__concurrency ( * , app , logging ) : [EOL] with pytest . raises ( ImproperlyConfigured ) : [EOL] await AgentIsolatedCase . run_test ( app = app , concurrency = [number] , isolated_partitions = True , ) [EOL] [EOL] [EOL] class AgentIsolatedCase ( AgentCase ) : [EOL] name = [string] [EOL] [EOL] def on_init ( self ) : [EOL] [comment] [EOL] self . processed_by_tp = Counter ( ) [EOL] [EOL] async def on_agent_event ( self , stream , event ) : [EOL] [comment] [EOL] if self . isolated_partitions : [EOL] [comment] [EOL] assert stream . active_partitions is not None [EOL] assert len ( stream . active_partitions ) == [number] [EOL] assert event . message . tp in stream . active_partitions [EOL] else : [EOL] assert stream . active_partitions is None [EOL] [EOL] [comment] [EOL] assert event . message . tp == next ( self . expected_tp ) [EOL] [EOL] self . processed_by_tp [ event . message . tp ] += [number] [EOL] [EOL] async def assert_success ( self ) : [EOL] await super ( ) . assert_success ( ) [EOL] self . log . info ( [string] , pformat ( [ ( tp . partition , total ) for tp , total in self . processed_by_tp . most_common ( ) ] ) , ) [EOL] max_ = None [EOL] for _ , total in self . processed_by_tp . most_common ( ) : [EOL] if max_ is None : [EOL] max_ = total [EOL] assert total == max_ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.StreamT$ 0 0 0 0 0 0 0 0 0 $faust.types.StreamT$ 0 0 0 0 0 0 0 $faust.types.EventT$ 0 0 0 0 0 $faust.types.StreamT$ 0 0 0 0 0 0 0 $faust.types.StreamT$ 0 0 0 0 0 0 0 0 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0
	0
	0
[comment] [EOL] [docstring] [EOL] [EOL] [EOL] import fileinput [EOL] import os [EOL] import sys [EOL] [EOL] EXPECTED_SUM = int ( os . environ . get ( [string] , [number] ) ) [EOL] [EOL] expected = [number] [EOL] prev = None [EOL] for i , line in enumerate ( fileinput . input ( ) ) : [EOL] expected += i [EOL] found = int ( line ) [EOL] if found != expected : [EOL] print ( f' [string] { i } [string] { found } [string] { expected }' ) [EOL] sys . exit ( [number] ) [EOL] if found == EXPECTED_SUM : [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Type , List , Iterator [EOL] import typing [EOL] import faust [EOL] import builtins [EOL] import extra [EOL] import sys [EOL] from typing import Any , Iterator , List , Type [EOL] from faust . types . settings import Settings [EOL] from faust . types . settings . params import Param [EOL] from faust . types . settings . sections import Section [EOL] [EOL] SECTION_TEMPLATE = [string] [EOL] [EOL] SETTING_TEMPLATE = [string] [EOL] [EOL] [EOL] class Rst : [EOL] [EOL] def to_ref ( self , t ) : [EOL] name = ... [EOL] module = t . __module__ [EOL] if module == [string] : [EOL] return self . _class ( t . __name__ ) [EOL] elif module == [string] : [EOL] if t is Any : [EOL] name = [string] [EOL] else : [EOL] name = getattr ( t , [string] , None ) or t . __name__ [EOL] if name == [string] : [EOL] list_type = t . __args__ and t . __args__ [ [number] ] or Any [EOL] return [string] . join ( [ self . literal ( [string] ) , self . to_ref ( list_type ) , self . literal ( [string] ) , ] ) [EOL] elif name . startswith ( ( [string] , [string] , [string] ) ) : [EOL] key_type = value_type = Any [EOL] if t . __args__ : [EOL] key_type = t . __args__ [ [number] ] [EOL] if len ( t . __args__ ) > [number] : [EOL] value_type = t . __args__ [ [number] ] [EOL] return [string] . join ( [ self . literal ( [string] ) , [string] . join ( [ self . to_ref ( key_type ) , self . to_ref ( value_type ) , ] ) , self . literal ( [string] ) , ] ) [EOL] else : [EOL] name = t . __name__ [EOL] [EOL] return self . _class ( f'{ module } [string] { name }' ) [EOL] [EOL] def header ( self , sep , title ) : [EOL] return [string] . join ( [ title , sep * len ( title ) ] ) [EOL] [EOL] def header1 ( self , title ) : [EOL] return self . header ( [string] , title ) [EOL] [EOL] def header2 ( self , title ) : [EOL] return self . header ( [string] , title ) [EOL] [EOL] def header3 ( self , title ) : [EOL] return self . header ( [string] , title ) [EOL] [EOL] def header4 ( self , title ) : [EOL] return self . header ( [string] , title ) [EOL] [EOL] def ref ( self , ref_class , value ) : [EOL] return f' [string] { ref_class } [string] { value } [string] ' [EOL] [EOL] def envvar ( self , name ) : [EOL] return self . ref ( [string] , name ) [EOL] [EOL] def const ( self , value ) : [EOL] return self . ref ( [string] , value ) [EOL] [EOL] def _class ( self , value ) : [EOL] if [string] in value : [EOL] value = [string] + value [EOL] return self . ref ( [string] , value ) [EOL] [EOL] def option ( self , value ) : [EOL] return self . ref ( [string] , value ) [EOL] [EOL] def literal ( self , s ) : [EOL] return f' [string] { s } [string] ' [EOL] [EOL] def directive ( self , name , value , content = None ) : [EOL] res = f' [string] { name } [string] { value } [string] ' [EOL] if content is not None : [EOL] res += [string] + self . reindent ( [number] , content ) + [string] [EOL] return res [EOL] [EOL] def inforow ( self , name , value ) : [EOL] return f' [string] { name } [string] { value }' [EOL] [EOL] def normalize_docstring_indent ( self , text ) : [EOL] [comment] [EOL] return self . normalize_indent ( text , line_start = [number] ) [EOL] [EOL] def normalize_indent ( self , text , line_start = [number] ) : [EOL] lines = text . splitlines ( ) [EOL] if len ( lines ) <= [number] : [EOL] return text [EOL] [comment] [EOL] [comment] [EOL] non_whitespace_index = [number] [EOL] [comment] [EOL] for line in lines [ line_start : ] : [EOL] if line and not line . isspace ( ) : [EOL] [comment] [EOL] for i , c in enumerate ( line ) : [EOL] if not c . isspace ( ) : [EOL] non_whitespace_index = i [EOL] break [EOL] if non_whitespace_index : [EOL] break [EOL] if not non_whitespace_index : [EOL] return text [EOL] return [string] . join ( self . strip_space ( non_whitespace_index , line ) for line in lines ) [EOL] [EOL] def strip_space ( self , n , line ) : [EOL] sentinel = False [EOL] result = [ ] [EOL] for i , c in enumerate ( line ) : [EOL] if not c . isspace ( ) or i > n : [EOL] sentinel = True [EOL] if sentinel : [EOL] result . append ( c ) [EOL] return [string] . join ( result ) [EOL] [EOL] def reindent ( self , new_indent , text ) : [EOL] return [string] . join ( [string] * new_indent + line for line in self . normalize_docstring_indent ( text ) . splitlines ( ) ) [EOL] [EOL] [EOL] class ConfigRef ( Rst ) : [EOL] [EOL] def section ( self , section , settings ) : [EOL] return SECTION_TEMPLATE . format ( section = section , title = self . header1 ( section . title ) , settings = [string] . join ( self . setting ( setting ) for setting in settings if not setting . deprecated ) , ) [EOL] [EOL] def setting ( self , setting ) : [EOL] return SETTING_TEMPLATE . format ( setting = setting , title = self . header2 ( self . literal ( setting . name ) ) , content = self . normalize_docstring_indent ( setting . __doc__ ) , metadata = [string] . join ( self . setting_metadata ( setting ) ) , ) [EOL] [EOL] def setting_default ( self , default_value ) : [EOL] if default_value is None : [EOL] return self . const ( [string] ) [EOL] elif default_value is True : [EOL] return self . const ( [string] ) [EOL] elif default_value is False : [EOL] return self . const ( [string] ) [EOL] return self . literal ( repr ( default_value ) ) [EOL] [EOL] def setting_metadata ( self , setting ) : [EOL] if setting . version_introduced : [EOL] yield self . directive ( [string] , setting . version_introduced ) [EOL] if setting . version_changed : [EOL] for version , reason in setting . version_changed . items ( ) : [EOL] yield self . directive ( [string] , version , reason ) [EOL] yield self . inforow ( [string] , [string] . join ( self . to_ref ( t ) for t in setting . text_type ) ) [EOL] [EOL] if setting . default_template : [EOL] default_info_title = [string] [EOL] default_value = self . setting_default ( setting . default_template ) [EOL] elif setting . default_alias : [EOL] default_info_title = [string] [EOL] default_value = self . settingref ( setting . default_alias ) [EOL] else : [EOL] default_info_title = [string] [EOL] default_value = self . setting_default ( setting . default ) [EOL] yield self . inforow ( default_info_title , default_value ) [EOL] [EOL] if setting . env_name : [EOL] yield self . inforow ( [string] , self . envvar ( setting . env_name ) ) [EOL] [EOL] if setting . related_cli_options : [EOL] yield self . inforow ( [string] , [string] . join ( self . option ( f'{ command } [string] { opt }' ) for command , opts in setting . related_cli_options . items ( ) for opt in opts ) , ) [EOL] if setting . related_settings : [EOL] yield self . inforow ( [string] , [string] . join ( self . settingref ( setting . name ) for setting in setting . related_settings ) , ) [EOL] [EOL] def settingref ( self , setting ) : [EOL] return self . ref ( [string] , setting ) [EOL] [EOL] [EOL] def render ( fh = sys . stdout ) : [EOL] configref = ConfigRef ( ) [EOL] for section , settings in Settings . SETTINGS_BY_SECTION . items ( ) : [EOL] print ( configref . section ( section , settings ) , file = fh , end = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] render ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $faust.types.settings.sections.Section$ 0 $typing.List[faust.types.settings.params.Param]$ 0 0 0 0 0 0 0 0 $faust.types.settings.sections.Section$ 0 $faust.types.settings.sections.Section$ 0 0 0 0 0 0 0 $faust.types.settings.sections.Section$ 0 0 0 0 $typing.List[faust.types.settings.params.Param]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[faust.types.settings.params.Param]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.settings.params.Param$ 0 0 0 0 $faust.types.settings.params.Param$ 0 $faust.types.settings.params.Param$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] REFBASE = [string] [EOL] REFS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Set [EOL] import typing [EOL] import typing [EOL] from docutils import nodes [EOL] try : [EOL] from sphinx . errors import NoUri [EOL] except ImportError : [EOL] from sphinx . environment import NoUri [comment] [EOL] [EOL] APPATTRS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] APPDIRECT = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] APPATTRS . update ( { x : [string] . format ( x ) for x in APPDIRECT } ) [EOL] [EOL] ABBRS = { [string] : [string] , } [EOL] [EOL] ABBR_EMPTY = { [string] : [string] , } [EOL] DEFAULT_EMPTY = [string] [EOL] [EOL] [EOL] def typeify ( S , type ) : [EOL] if type in ( [string] , [string] ) : [EOL] return S + [string] [EOL] return S [EOL] [EOL] [EOL] def shorten ( S , newtarget , src_dict ) : [EOL] if S . startswith ( [string] ) : [EOL] return S [ [number] : ] [EOL] elif S . startswith ( [string] ) : [EOL] if src_dict is APPATTRS : [EOL] return [string] . join ( [ [string] , S [ [number] : ] ] ) [EOL] return S [ [number] : ] [EOL] return S [EOL] [EOL] [EOL] def get_abbr ( pre , rest , type , orig = None ) : [EOL] if pre : [EOL] for d in APPATTRS , ABBRS : [EOL] try : [EOL] return d [ pre ] , rest , d [EOL] except KeyError : [EOL] pass [EOL] raise KeyError ( [string] . format ( [string] . join ( [ pre , rest ] ) if orig is None else orig , type , ) ) [EOL] else : [EOL] for d in APPATTRS , ABBRS : [EOL] try : [EOL] return d [ rest ] , [string] , d [EOL] except KeyError : [EOL] pass [EOL] return ABBR_EMPTY . get ( type , DEFAULT_EMPTY ) , rest , ABBR_EMPTY [EOL] [EOL] [EOL] def resolve ( S , type ) : [EOL] if [string] not in S : [EOL] try : [EOL] getattr ( typing , S ) [EOL] except AttributeError : [EOL] pass [EOL] else : [EOL] return [string] . format ( S ) , None [EOL] orig = S [EOL] if S . startswith ( [string] ) : [EOL] S = S . lstrip ( [string] ) [EOL] try : [EOL] pre , rest = S . split ( [string] , [number] ) [EOL] except ValueError : [EOL] pre , rest = [string] , S [EOL] [EOL] target , rest , src = get_abbr ( pre , rest , type , orig ) [EOL] return [string] . join ( [ target , rest ] ) if rest else target , src [EOL] return S , None [EOL] [EOL] [EOL] def pkg_of ( module_fqdn ) : [EOL] return module_fqdn . split ( [string] , [number] ) [ [number] ] [EOL] [EOL] [EOL] def basename ( module_fqdn ) : [EOL] return module_fqdn . lstrip ( [string] ) . rsplit ( [string] , - [number] ) [ - [number] ] [EOL] [EOL] [EOL] def modify_textnode ( T , newtarget , node , src_dict , type ) : [EOL] src = node . children [ [number] ] . rawsource [EOL] return nodes . Text ( ( typeify ( basename ( T ) , type ) if [string] in src [EOL] else typeify ( shorten ( T , newtarget , src_dict ) , type ) ) , src , ) [EOL] [EOL] [EOL] def maybe_resolve_abbreviations ( app , env , node , contnode ) : [EOL] domainname = node . get ( [string] ) [EOL] target = node [ [string] ] [EOL] typ = node [ [string] ] [EOL] if target . startswith ( [string] ) : [EOL] newtarget , src_dict = resolve ( target , typ ) [EOL] node [ [string] ] = newtarget [EOL] [comment] [EOL] if len ( contnode ) and isinstance ( contnode [ [number] ] , nodes . Text ) : [EOL] contnode [ [number] ] = modify_textnode ( target , newtarget , node , src_dict , typ ) [EOL] if domainname : [EOL] try : [EOL] domain = env . domains [ node . get ( [string] ) ] [EOL] except KeyError : [EOL] raise NoUri [EOL] return domain . resolve_xref ( env , node [ [string] ] , app . builder , typ , newtarget , node , contnode ) [EOL] [EOL] [EOL] def setup ( app ) : [EOL] app . connect ( [string] , maybe_resolve_abbreviations , ) [EOL] app . add_crossref_type ( directivename = [string] , rolename = [string] , indextemplate = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import faust [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import typing [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] from . types . models import FieldDescriptorT as _FieldDescriptorT [EOL] else : [EOL] class _FieldDescriptorT : ... [comment] [EOL] [EOL] [EOL] class FaustError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class FaustWarning ( UserWarning ) : [EOL] [docstring] [EOL] [EOL] [EOL] class FaustPredicate ( FaustError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class SecurityError ( FaustError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class NotReady ( FaustPredicate ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Skip ( FaustPredicate ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AlreadyConfiguredWarning ( FaustWarning ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ImproperlyConfigured ( FaustError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ValidationError ( FaustError , ValueError ) : [EOL] [docstring] [EOL] [EOL] field = ... [EOL] [EOL] def __init__ ( self , reason , * , field ) : [EOL] self . reason = reason [EOL] self . field = field [EOL] super ( ) . __init__ ( reason , field ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f'{ self . reason } [string] { self . field !r}' [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { type ( self ) . __name__ } [string] { self } [string] ' [EOL] [EOL] [EOL] class DecodeError ( FaustError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class KeyDecodeError ( DecodeError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ValueDecodeError ( DecodeError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class SameNode ( FaustPredicate ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ProducerSendError ( FaustError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ConsumerNotStarted ( NotReady ) : [EOL] [docstring] [EOL] [EOL] [EOL] class PartitionsMismatch ( FaustError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ConsistencyError ( FaustError ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.models.FieldDescriptorT$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $faust.types.models.FieldDescriptorT[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Awaitable , Any , Union , Type [EOL] import faust [EOL] import typing [EOL] import types [EOL] import builtins [EOL] [docstring] [EOL] import typing [EOL] [EOL] from types import TracebackType [EOL] from typing import Any , Awaitable , Optional , Type , Union , cast [EOL] [EOL] from faust . types import ( AppT , ChannelT , CodecArg , EventT , HeadersArg , K , Message , MessageSentCallback , RecordMetadata , SchemaT , V , ) [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from . app . base import App as _App [EOL] else : [EOL] class _App : ... [comment] [EOL] [EOL] USE_EXISTING_KEY = object ( ) [EOL] USE_EXISTING_VALUE = object ( ) [EOL] USE_EXISTING_HEADERS = object ( ) [EOL] [EOL] [EOL] class Event ( EventT ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , app , key , value , headers , message ) : [EOL] self . app = app [EOL] self . key = key [EOL] self . value = value [EOL] self . message = message [EOL] if headers is not None : [EOL] if not isinstance ( headers , dict ) : [EOL] self . headers = dict ( headers ) [EOL] else : [EOL] self . headers = headers [EOL] else : [EOL] self . headers = { } [EOL] [EOL] self . acked = False [EOL] [EOL] async def send ( self , channel , key = USE_EXISTING_KEY , value = USE_EXISTING_VALUE , partition = None , timestamp = None , headers = USE_EXISTING_HEADERS , schema = None , key_serializer = None , value_serializer = None , callback = None , force = False ) : [EOL] [docstring] [EOL] if key is USE_EXISTING_KEY : [EOL] key = self . key [EOL] if value is USE_EXISTING_VALUE : [EOL] value = self . value [EOL] if headers is USE_EXISTING_HEADERS : [EOL] headers = self . headers [EOL] return await self . _send ( channel , key , value , partition , timestamp , headers , schema , key_serializer , value_serializer , callback , force = force , ) [EOL] [EOL] async def forward ( self , channel , key = USE_EXISTING_KEY , value = USE_EXISTING_VALUE , partition = None , timestamp = None , headers = USE_EXISTING_HEADERS , schema = None , key_serializer = None , value_serializer = None , callback = None , force = False ) : [EOL] [docstring] [EOL] if key is USE_EXISTING_KEY : [EOL] key = self . message . key [EOL] if value is USE_EXISTING_VALUE : [EOL] value = self . message . value [EOL] if headers is USE_EXISTING_HEADERS : [EOL] headers = self . message . headers [EOL] if not headers : [EOL] headers = None [EOL] return await self . _send ( channel , key , value , partition , timestamp , headers , schema , key_serializer , value_serializer , callback , force = force , ) [EOL] [EOL] async def _send ( self , channel , key = None , value = None , partition = None , timestamp = None , headers = None , schema = None , key_serializer = None , value_serializer = None , callback = None , force = False ) : [EOL] return await cast ( _App , self . app ) . _attachments . maybe_put ( channel , key , value , partition , timestamp , headers , schema , key_serializer , value_serializer , callback , force = force , ) [EOL] [EOL] def _attach ( self , channel , key = None , value = None , partition = None , timestamp = None , headers = None , schema = None , key_serializer = None , value_serializer = None , callback = None , ) : [EOL] return cast ( _App , self . app ) . _attachments . put ( self . message , channel , key , value , partition = partition , timestamp = timestamp , headers = headers , schema = schema , key_serializer = key_serializer , value_serializer = value_serializer , callback = callback , ) [EOL] [EOL] def ack ( self ) : [EOL] [docstring] [EOL] return self . message . ack ( self . app . consumer ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { type ( self ) . __name__ } [string] { self . key !r} [string] { self . value !r} [string] ' [EOL] [EOL] async def __aenter__ ( self ) : [EOL] return self [EOL] [EOL] async def __aexit__ ( self , _exc_type = None , _exc_val = None , _exc_tb = None ) : [EOL] self . ack ( ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $faust.types.K$ 0 $faust.types.V$ 0 0 0 $faust.types.Message$ 0 0 0 0 0 $faust.types.AppT$ 0 $faust.types.AppT$ 0 0 0 $faust.types.K$ 0 $faust.types.K$ 0 0 0 $faust.types.V$ 0 $faust.types.V$ 0 0 0 $faust.types.Message$ 0 $faust.types.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Awaitable[faust.types.RecordMetadata]$ 0 0 0 $typing.Union[builtins.str,faust.types.ChannelT]$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.object$ 0 $faust.types.SchemaT$ 0 0 0 $faust.types.CodecArg$ 0 0 0 $faust.types.CodecArg$ 0 0 0 $faust.types.MessageSentCallback$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,faust.types.ChannelT]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 $faust.types.SchemaT$ 0 $faust.types.CodecArg$ 0 $faust.types.CodecArg$ 0 $faust.types.MessageSentCallback$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Awaitable[faust.types.RecordMetadata]$ 0 0 0 $typing.Union[builtins.str,faust.types.ChannelT]$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $None$ 0 $builtins.object$ 0 $faust.types.SchemaT$ 0 0 0 $faust.types.CodecArg$ 0 0 0 $faust.types.CodecArg$ 0 0 0 $faust.types.MessageSentCallback$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.object$ 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,faust.types.ChannelT]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 $None$ 0 $faust.types.SchemaT$ 0 $faust.types.CodecArg$ 0 $faust.types.CodecArg$ 0 $faust.types.MessageSentCallback$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Awaitable[faust.types.RecordMetadata]$ 0 0 0 $typing.Union[builtins.str,faust.types.ChannelT]$ 0 $faust.types.K$ 0 0 0 $faust.types.V$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $faust.types.HeadersArg$ 0 0 0 $faust.types.SchemaT$ 0 0 0 $faust.types.CodecArg$ 0 0 0 $faust.types.CodecArg$ 0 0 0 $faust.types.MessageSentCallback$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,faust.types.ChannelT]$ 0 $faust.types.K$ 0 $faust.types.V$ 0 $builtins.int$ 0 $builtins.float$ 0 $faust.types.HeadersArg$ 0 $faust.types.SchemaT$ 0 $faust.types.CodecArg$ 0 $faust.types.CodecArg$ 0 $faust.types.MessageSentCallback$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Awaitable[faust.types.RecordMetadata]$ 0 0 0 $typing.Union[faust.types.ChannelT,builtins.str]$ 0 $faust.types.K$ 0 0 0 $faust.types.V$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $faust.types.HeadersArg$ 0 0 0 $faust.types.SchemaT$ 0 0 0 $faust.types.CodecArg$ 0 0 0 $faust.types.CodecArg$ 0 0 0 $faust.types.MessageSentCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[faust.types.ChannelT,builtins.str]$ 0 $faust.types.K$ 0 $faust.types.V$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.float$ 0 $builtins.float$ 0 $faust.types.HeadersArg$ 0 $faust.types.HeadersArg$ 0 $faust.types.SchemaT$ 0 $faust.types.SchemaT$ 0 $faust.types.CodecArg$ 0 $faust.types.CodecArg$ 0 $faust.types.CodecArg$ 0 $faust.types.CodecArg$ 0 $faust.types.MessageSentCallback$ 0 $faust.types.MessageSentCallback$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Type[builtins.BaseException]$ 0 0 0 $builtins.BaseException$ 0 0 0 $types.TracebackType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import IO , Tuple , Iterable , Set , Any , Union , Dict , Type , List [EOL] import typing [EOL] import faust [EOL] import types [EOL] import pathlib [EOL] import asyncio [EOL] import logging [EOL] import builtins [EOL] import mode [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] from collections import defaultdict [EOL] from itertools import chain [EOL] from pathlib import Path [EOL] from typing import Any , Dict , IO , Iterable , Mapping , Optional , Set , Union [EOL] [EOL] import mode [EOL] from aiokafka . structs import TopicPartition [EOL] from mode import ServiceT , get_logger [EOL] from mode . utils . logging import Severity , formatter2 [EOL] [EOL] from . types import AppT , SensorT , TP , TopicT [EOL] from . types . _env import CONSOLE_PORT , DEBUG [EOL] from . utils import terminal [EOL] from . utils . functional import consecutive_numbers [EOL] [EOL] try : [comment] [EOL] [comment] [EOL] from setproctitle import setproctitle [EOL] except ImportError : [comment] [EOL] def setproctitle ( title ) : ... [comment] [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [comment] [EOL] PSIDENT = [string] [EOL] [EOL] TP_TYPES = ( TP , TopicPartition ) [EOL] [EOL] logger = get_logger ( __name__ ) [EOL] [EOL] [EOL] @ formatter2 def format_log_arguments ( arg , record ) : [comment] [EOL] [comment] [EOL] [EOL] if arg and isinstance ( arg , Mapping ) : [EOL] first_k , first_v = next ( iter ( arg . items ( ) ) ) [EOL] [comment] [EOL] if ( isinstance ( first_k , str ) and isinstance ( first_v , set ) and isinstance ( next ( iter ( first_v ) , None ) , TopicT ) ) : [EOL] return [string] + terminal . logtable ( sorted ( arg . items ( ) ) , title = [string] , headers = [ [string] , [string] ] , ) [EOL] [comment] [EOL] [comment] [EOL] elif isinstance ( first_v , TP_TYPES ) : [EOL] return [string] + terminal . logtable ( [ ( k . topic , k . partition , v ) for k , v in sorted ( arg . items ( ) ) ] , title = [string] , headers = [ [string] , [string] , [string] ] , ) [EOL] elif arg and isinstance ( arg , ( set , list ) ) : [EOL] if [string] in record . msg : [EOL] return [string] + terminal . logtable ( [ [ str ( v ) ] for v in sorted ( arg ) ] , title = [string] , headers = [ [string] ] , ) [EOL] elif isinstance ( next ( iter ( arg ) ) , TP_TYPES ) : [EOL] [comment] [EOL] return _partition_set_logtable ( arg ) [EOL] [EOL] elif arg and isinstance ( arg , frozenset ) : [EOL] if [string] in record . msg : [EOL] [comment] [EOL] [comment] [EOL] return [string] + terminal . logtable ( [ [ str ( v ) ] for v in sorted ( arg ) ] , title = [string] , headers = [ [string] ] , ) [EOL] elif isinstance ( next ( iter ( arg ) ) , TP_TYPES ) : [EOL] [comment] [EOL] return _partition_set_logtable ( arg ) [EOL] [EOL] [EOL] def _partition_set_logtable ( arg ) : [EOL] topics = defaultdict ( set ) [EOL] for tp in arg : [EOL] topics [ tp . topic ] . add ( tp . partition ) [EOL] [EOL] return [string] + terminal . logtable ( [ ( k , _repr_partition_set ( v ) ) for k , v in sorted ( topics . items ( ) ) ] , title = [string] , headers = [ [string] , [string] ] , ) [EOL] [EOL] [EOL] def _repr_partition_set ( s ) : [EOL] [docstring] [EOL] elements = [string] . join ( _iter_consecutive_numbers ( sorted ( s ) ) ) [EOL] return f' [string] { elements } [string] ' [EOL] [EOL] [EOL] def _iter_consecutive_numbers ( s ) : [EOL] [docstring] [EOL] for numbers in consecutive_numbers ( s ) : [EOL] if len ( numbers ) > [number] : [EOL] yield f'{ numbers [ [number] ] } [string] { numbers [ - [number] ] }' [EOL] else : [EOL] yield f'{ numbers [ [number] ] }' [EOL] [EOL] [EOL] class Worker ( mode . Worker ) : [EOL] [docstring] [EOL] [EOL] logger = logger [EOL] [EOL] [comment] [EOL] app = ... [EOL] [EOL] [comment] [EOL] sensors = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] workdir = ... [EOL] [EOL] [comment] [EOL] spinner = ... [EOL] [EOL] [comment] [EOL] _shutdown_immediately = False [EOL] [EOL] def __init__ ( self , app , * services , sensors = None , debug = DEBUG , quiet = False , loglevel = None , logfile = None , stdout = sys . stdout , stderr = sys . stderr , blocking_timeout = None , workdir = None , console_port = CONSOLE_PORT , loop = None , redirect_stdouts = None , redirect_stdouts_level = None , logging_config = None , ** kwargs ) : [EOL] self . app = app [EOL] self . sensors = set ( sensors or [ ] ) [EOL] self . workdir = Path ( workdir or Path . cwd ( ) ) [EOL] conf = app . conf [EOL] if redirect_stdouts is None : [EOL] redirect_stdouts = conf . worker_redirect_stdouts [EOL] if redirect_stdouts_level is None : [EOL] redirect_stdouts_level = ( conf . worker_redirect_stdouts_level or logging . INFO ) [EOL] if logging_config is None and app . conf . logging_config : [EOL] logging_config = dict ( app . conf . logging_config ) [EOL] super ( ) . __init__ ( * services , debug = debug , quiet = quiet , loglevel = loglevel , logfile = logfile , loghandlers = app . conf . loghandlers , stdout = stdout , stderr = stderr , blocking_timeout = blocking_timeout or [number] , console_port = console_port , redirect_stdouts = redirect_stdouts , redirect_stdouts_level = redirect_stdouts_level , logging_config = logging_config , loop = loop , ** kwargs ) [EOL] self . spinner = terminal . Spinner ( file = self . stdout ) [EOL] [EOL] async def on_start ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . app . in_worker = True [EOL] [EOL] await super ( ) . on_start ( ) [EOL] [EOL] def _on_sigint ( self ) : [EOL] self . _flag_as_shutdown_by_signal ( ) [EOL] super ( ) . _on_sigint ( ) [EOL] [EOL] def _on_sigterm ( self ) : [EOL] self . _flag_as_shutdown_by_signal ( ) [EOL] super ( ) . _on_sigterm ( ) [EOL] [EOL] def _flag_as_shutdown_by_signal ( self ) : [EOL] self . _shutdown_immediately = True [EOL] if self . spinner : [EOL] self . spinner . stop ( ) [EOL] [EOL] async def maybe_start_blockdetection ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if self . blocking_timeout : [EOL] await self . blocking_detector . maybe_start ( ) [EOL] [EOL] async def on_startup_finished ( self ) : [EOL] [docstring] [EOL] if self . _shutdown_immediately : [EOL] return self . _on_shutdown_immediately ( ) [EOL] [comment] [EOL] [comment] [EOL] await self . maybe_start_blockdetection ( ) [EOL] [EOL] [comment] [EOL] self . _on_startup_end_spinner ( ) [EOL] [EOL] def _on_startup_end_spinner ( self ) : [EOL] if self . spinner : [EOL] self . spinner . finish ( ) [EOL] if self . spinner . file . isatty ( ) : [EOL] self . say ( [string] ) [EOL] else : [EOL] self . say ( [string] ) [EOL] else : [EOL] self . log . info ( [string] ) [EOL] [EOL] def _on_shutdown_immediately ( self ) : [EOL] self . say ( [string] ) [comment] [EOL] [EOL] def on_init_dependencies ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . app . beacon . reattach ( self . beacon ) [EOL] [comment] [EOL] for sensor in self . sensors : [EOL] self . app . sensors . add ( sensor ) [EOL] [comment] [EOL] [comment] [EOL] self . app . on_startup_finished = self . on_startup_finished [EOL] return chain ( self . services , [ self . app ] ) [EOL] [EOL] async def on_first_start ( self ) : [EOL] [docstring] [EOL] self . change_workdir ( self . workdir ) [EOL] self . autodiscover ( ) [EOL] await self . default_on_first_start ( ) [EOL] [EOL] def change_workdir ( self , path ) : [EOL] [docstring] [EOL] if path and path . absolute ( ) != path . cwd ( ) . absolute ( ) : [EOL] os . chdir ( path . absolute ( ) ) [EOL] [EOL] def autodiscover ( self ) : [EOL] [docstring] [EOL] if self . app . conf . autodiscover : [EOL] self . app . discover ( ) [EOL] [EOL] def _setproctitle ( self , info , * , ident = PSIDENT ) : [EOL] setproctitle ( f'{ ident } [string] { info } [string] { self . _proc_ident ( ) }' ) [EOL] [EOL] def _proc_ident ( self ) : [EOL] conf = self . app . conf [EOL] return f'{ conf . id } [string] { self . _proc_web_ident ( ) } [string] { conf . datadir . absolute ( ) }' [EOL] [EOL] def _proc_web_ident ( self ) : [EOL] conf = self . app . conf [EOL] if conf . web_transport . scheme == [string] : [EOL] return f'{ conf . web_transport }' [EOL] return f' [string] { conf . web_port }' [EOL] [EOL] async def on_execute ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _setproctitle ( [string] ) [EOL] if self . spinner and self . spinner . file . isatty ( ) : [EOL] self . _say ( [string] , end = [string] , flush = True ) [EOL] [EOL] def on_worker_shutdown ( self ) : [EOL] [docstring] [EOL] self . _setproctitle ( [string] ) [EOL] if self . spinner and self . spinner . file . isatty ( ) : [EOL] self . spinner . reset ( ) [EOL] self . _say ( [string] , end = [string] , flush = True ) [EOL] [EOL] def on_setup_root_logger ( self , logger , level ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] self . _disable_spinner_if_level_below_WARN ( level ) [EOL] self . _setup_spinner_handler ( logger , level ) [EOL] [EOL] def _disable_spinner_if_level_below_WARN ( self , level ) : [EOL] if level and level < logging . WARN : [EOL] self . spinner = None [EOL] [EOL] def _setup_spinner_handler ( self , logger , level ) : [EOL] if self . spinner : [EOL] logger . handlers [ [number] ] . setLevel ( level ) [EOL] logger . addHandler ( terminal . SpinnerHandler ( self . spinner , level = logging . DEBUG ) ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.AppT$ 0 0 0 0 0 0 $typing.Set[types.SensorT]$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Optional[utils.terminal.Spinner]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Union[builtins.str,builtins.int]$ 0 0 0 $typing.Union[builtins.str,typing.IO]$ 0 0 0 $typing.IO$ 0 0 0 $typing.IO$ 0 $typing.IO$ 0 0 0 $typing.IO$ 0 $builtins.float$ 0 0 0 $pathlib.Path$ 0 0 0 $builtins.int$ 0 0 0 $asyncio.AbstractEventLoop$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.Union[builtins.str,builtins.int]$ 0 $typing.Union[builtins.str,builtins.int]$ 0 $typing.Union[builtins.str,typing.IO]$ 0 $typing.Union[builtins.str,typing.IO]$ 0 0 0 0 0 0 0 0 0 $typing.IO$ 0 $typing.IO$ 0 $typing.IO$ 0 $typing.IO$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $asyncio.AbstractEventLoop$ 0 $asyncio.AbstractEventLoop$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[mode.ServiceT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $logging.Logger$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $logging.Logger$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] from faust . cli . faust import cli [EOL] [EOL] cli ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Optional , List [EOL] import typing [EOL] import builtins [EOL] import types [EOL] [docstring] [EOL] from typing import Any , Optional , Tuple [EOL] from . types import EventT , FieldDescriptorT , JoinT , JoinableT [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] class Join ( JoinT ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * , stream , fields ) : [EOL] self . fields = { field . model : field for field in fields } [EOL] self . stream = stream [EOL] [EOL] async def process ( self , event ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , type ( self ) ) : [EOL] return ( other . fields == self . fields and other . stream is self . stream ) [EOL] return False [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] [EOL] class RightJoin ( Join ) : [EOL] [docstring] [EOL] [EOL] [EOL] class LeftJoin ( Join ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InnerJoin ( Join ) : [EOL] [docstring] [EOL] [EOL] [EOL] class OuterJoin ( Join ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Set , Awaitable , Any , Sequence , Union , List , Mapping , Pattern [EOL] import functools [EOL] import typing [EOL] import faust [EOL] import types [EOL] import asyncio [EOL] import builtins [EOL] import mode [EOL] [docstring] [EOL] import asyncio [EOL] import re [EOL] import typing [EOL] [EOL] from functools import partial [EOL] from typing import ( Any , Awaitable , Callable , Mapping , Optional , Pattern , Sequence , Set , Union , cast , no_type_check , ) [EOL] [EOL] from mode import Seconds , get_logger [EOL] from mode . utils . futures import stampede [EOL] from mode . utils . queues import ThrowableQueue [EOL] [EOL] from . channels import SerializedChannel [EOL] from . events import Event [EOL] from . streams import current_event [EOL] from . types import ( AppT , CodecArg , EventT , FutureMessage , HeadersArg , K , MessageSentCallback , ModelArg , PendingMessage , RecordMetadata , SchemaT , TP , V , ) [EOL] from . types . topics import ChannelT , TopicT [EOL] from . types . transports import ProducerT [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from . app import App as _App [EOL] else : [EOL] class _App : ... [comment] [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] logger = get_logger ( __name__ ) [EOL] [EOL] [EOL] class Topic ( SerializedChannel , TopicT ) : [EOL] [docstring] [EOL] [EOL] _partitions = None [EOL] _pattern = None [EOL] [EOL] def __init__ ( self , app , * , topics = None , pattern = None , schema = None , key_type = None , value_type = None , is_iterator = False , partitions = None , retention = None , compacting = None , deleting = None , replicas = None , acks = True , internal = False , config = None , queue = None , key_serializer = None , value_serializer = None , maxsize = None , root = None , active_partitions = None , allow_empty = None , has_prefix = False , loop = None ) : [EOL] super ( ) . __init__ ( app , schema = schema , key_type = key_type , value_type = value_type , key_serializer = key_serializer , value_serializer = value_serializer , allow_empty = allow_empty , loop = loop , active_partitions = active_partitions , is_iterator = is_iterator , queue = queue , maxsize = maxsize , ) [EOL] self . topics = topics or [ ] [EOL] self . pattern = cast ( Pattern , pattern ) [EOL] self . partitions = partitions [EOL] self . retention = retention [EOL] self . compacting = compacting [EOL] self . deleting = deleting [EOL] self . replicas = replicas [EOL] self . acks = acks [EOL] self . internal = internal [EOL] self . config = config or { } [EOL] self . has_prefix = has_prefix [EOL] [EOL] self . _compile_decode ( ) [EOL] [EOL] def _compile_decode ( self ) : [EOL] self . decode = self . schema . compile ( self . app , on_key_decode_error = self . on_key_decode_error , on_value_decode_error = self . on_value_decode_error , ) [EOL] [EOL] async def send ( self , * , key = None , value = None , partition = None , timestamp = None , headers = None , schema = None , key_serializer = None , value_serializer = None , callback = None , force = False ) : [EOL] [docstring] [EOL] app = cast ( _App , self . app ) [EOL] if app . _attachments . enabled and not force : [EOL] event = current_event ( ) [EOL] if event is not None : [EOL] return cast ( Event , event ) . _attach ( self , key , value , partition = partition , timestamp = timestamp , headers = headers , schema = schema , key_serializer = key_serializer , value_serializer = value_serializer , callback = callback , ) [EOL] return await self . _send_now ( key , value , partition = partition , timestamp = timestamp , headers = headers , schema = schema , key_serializer = key_serializer , value_serializer = value_serializer , callback = callback , ) [EOL] [EOL] def send_soon ( self , * , key = None , value = None , partition = None , timestamp = None , headers = None , schema = None , key_serializer = None , value_serializer = None , callback = None , force = False , eager_partitioning = False ) : [EOL] [docstring] [EOL] fut = self . as_future_message ( key = key , value = value , partition = partition , timestamp = timestamp , headers = headers , schema = schema , key_serializer = key_serializer , value_serializer = value_serializer , callback = callback , eager_partitioning = eager_partitioning , ) [EOL] self . app . producer . send_soon ( fut ) [EOL] return fut [EOL] [EOL] async def put ( self , event ) : [EOL] [docstring] [EOL] if not self . is_iterator : [EOL] raise RuntimeError ( f' [string] { self } [string] ' ) [EOL] await self . queue . put ( event ) [EOL] [EOL] @ no_type_check def _clone_args ( self ) : [EOL] return { ** super ( ) . _clone_args ( ) , ** { [string] : self . topics , [string] : self . pattern , [string] : self . partitions , [string] : self . retention , [string] : self . compacting , [string] : self . deleting , [string] : self . replicas , [string] : self . internal , [string] : self . acks , [string] : self . config , [string] : self . active_partitions , [string] : self . allow_empty , [string] : self . has_prefix , } , } [EOL] [EOL] @ property def pattern ( self ) : [EOL] [docstring] [EOL] return self . _pattern [EOL] [EOL] @ pattern . setter def pattern ( self , pattern ) : [EOL] [docstring] [EOL] if pattern and self . topics : [EOL] raise TypeError ( [string] ) [EOL] self . _pattern = re . compile ( pattern ) if pattern else None [EOL] [EOL] @ property def partitions ( self ) : [EOL] [docstring] [EOL] return self . _partitions [EOL] [EOL] @ partitions . setter def partitions ( self , partitions ) : [EOL] [docstring] [EOL] if partitions == [number] : [EOL] raise ValueError ( [string] ) [EOL] self . _partitions = partitions [EOL] [EOL] def derive ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . derive_topic ( ** kwargs ) [EOL] [EOL] def derive_topic ( self , * , topics = None , schema = None , key_type = None , value_type = None , key_serializer = None , value_serializer = None , partitions = None , retention = None , compacting = None , deleting = None , internal = None , config = None , prefix = [string] , suffix = [string] , ** kwargs ) : [EOL] [docstring] [EOL] topics = self . topics if topics is None else topics [EOL] if suffix or prefix : [EOL] if self . pattern : [EOL] raise ValueError ( [string] ) [EOL] topics = [ f'{ prefix }{ topic }{ suffix }' for topic in topics ] [EOL] return type ( self ) ( self . app , topics = topics , pattern = self . pattern , schema = self . schema if schema is None else schema , key_type = key_type , value_type = value_type , key_serializer = key_serializer , value_serializer = value_serializer , partitions = self . partitions if partitions is None else partitions , retention = self . retention if retention is None else retention , compacting = self . compacting if compacting is None else compacting , deleting = self . deleting if deleting is None else deleting , config = self . config if config is None else config , internal = self . internal if internal is None else internal , has_prefix = bool ( self . has_prefix or prefix ) , ) [EOL] [EOL] def get_topic_name ( self ) : [EOL] [docstring] [EOL] if self . pattern : [EOL] raise TypeError ( [string] ) [EOL] if self . topics : [EOL] if len ( self . topics ) > [number] : [EOL] raise ValueError ( [string] ) [EOL] return self . topics [ [number] ] [EOL] raise TypeError ( [string] ) [EOL] [EOL] async def _get_producer ( self ) : [EOL] return await self . app . maybe_start_producer ( ) [EOL] [EOL] async def publish_message ( self , fut , wait = False ) : [EOL] [docstring] [EOL] app = self . app [EOL] message = fut . message [EOL] topic = self . _topic_name_or_default ( message . channel ) [EOL] key = cast ( bytes , message . key ) [EOL] value = cast ( bytes , message . value ) [EOL] partition = message . partition [EOL] timestamp = cast ( float , message . timestamp ) [EOL] headers = message . headers [EOL] logger . debug ( [string] , topic , key , value , timestamp , partition ) [EOL] assert topic is not None [EOL] producer = await self . _get_producer ( ) [EOL] state = app . sensors . on_send_initiated ( producer , topic , message = message , keysize = len ( key ) if key else [number] , valsize = len ( value ) if value else [number] , ) [EOL] if wait : [EOL] ret = await producer . send_and_wait ( topic , key , value , partition = partition , timestamp = timestamp , headers = headers , ) [EOL] app . sensors . on_send_completed ( producer , state , ret ) [EOL] return await self . _finalize_message ( fut , ret ) [EOL] else : [EOL] fut2 = cast ( asyncio . Future , await producer . send ( topic , key , value , partition = partition , timestamp = timestamp , headers = headers , ) ) [EOL] callback = partial ( self . _on_published , message = fut , state = state , producer = producer , ) [EOL] fut2 . add_done_callback ( cast ( Callable , callback ) ) [EOL] return fut2 [EOL] [EOL] def _topic_name_or_default ( self , obj ) : [EOL] if isinstance ( obj , str ) : [EOL] return obj [EOL] elif isinstance ( obj , TopicT ) : [EOL] return obj . get_topic_name ( ) [EOL] else : [EOL] return self . get_topic_name ( ) [EOL] [EOL] def _on_published ( self , fut , message , producer , state ) : [EOL] try : [EOL] res = fut . result ( ) [EOL] except Exception as exc : [EOL] message . set_exception ( exc ) [EOL] self . app . sensors . on_send_error ( producer , exc , state ) [EOL] else : [EOL] message . set_result ( res ) [EOL] if message . message . callback : [EOL] message . message . callback ( message ) [EOL] self . app . sensors . on_send_completed ( producer , state , res ) [EOL] [EOL] @ stampede async def maybe_declare ( self ) : [EOL] [docstring] [EOL] await self . declare ( ) [EOL] [EOL] async def declare ( self ) : [EOL] [docstring] [EOL] partitions = self . partitions [EOL] if partitions is None : [EOL] partitions = self . app . conf . topic_partitions [EOL] replicas = ... [EOL] if self . replicas is None : [EOL] replicas = self . app . conf . topic_replication_factor [EOL] else : [EOL] replicas = self . replicas [EOL] if self . app . conf . topic_allow_declare : [EOL] producer = await self . _get_producer ( ) [EOL] for topic in self . topics : [EOL] await producer . create_topic ( topic = topic , partitions = partitions , replication = replicas or [number] , config = self . config , compacting = self . compacting , deleting = self . deleting , retention = self . retention , ) [EOL] [EOL] def __aiter__ ( self ) : [EOL] if self . is_iterator : [EOL] return self [EOL] else : [EOL] channel = self . clone ( is_iterator = True ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . app . topics . add ( cast ( TopicT , channel ) ) [EOL] return channel [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . pattern ) if self . pattern else [string] . join ( self . topics ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Iterable , Optional , Set , Any , Sequence , List , MutableMapping , Counter [EOL] import typing [EOL] import client_assignment [EOL] import builtins [EOL] import mode [EOL] [docstring] [EOL] from itertools import cycle [EOL] from math import ceil [EOL] from typing import Iterable , Iterator , MutableMapping , Optional , Sequence , Set [EOL] from mode . utils . typing import Counter [EOL] from . client_assignment import CopartitionedAssignment [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class CopartitionedAssignor : [EOL] [docstring] [EOL] [EOL] capacity = ... [EOL] num_partitions = ... [EOL] replicas = ... [EOL] topics = ... [EOL] [EOL] _num_clients = ... [EOL] _client_assignments = ... [EOL] [EOL] def __init__ ( self , topics , cluster_asgn , num_partitions , replicas , capacity = None ) : [EOL] self . _num_clients = len ( cluster_asgn ) [EOL] assert self . _num_clients , [string] [EOL] self . num_partitions = num_partitions [EOL] self . replicas = min ( replicas , self . _num_clients - [number] ) [EOL] self . capacity = ( int ( ceil ( float ( self . num_partitions ) / self . _num_clients ) ) [EOL] if capacity is None else capacity ) [EOL] self . topics = set ( topics ) [EOL] [EOL] assert self . capacity * self . _num_clients >= self . num_partitions , [string] [EOL] [EOL] self . _client_assignments = cluster_asgn [EOL] [EOL] def get_assignment ( self ) : [EOL] for copartitioned in self . _client_assignments . values ( ) : [EOL] copartitioned . unassign_extras ( self . capacity , self . replicas ) [EOL] self . _assign ( active = True ) [EOL] self . _assign ( active = False ) [EOL] return self . _client_assignments [EOL] [EOL] def _all_assigned ( self , active ) : [EOL] assigned_counts = self . _assigned_partition_counts ( active ) [EOL] total_assigns = self . _total_assigns_per_partition ( active ) [EOL] return all ( assigned_counts [ partition ] == total_assigns for partition in range ( self . num_partitions ) ) [EOL] [EOL] def _assign ( self , active ) : [EOL] self . _unassign_overassigned ( active ) [EOL] unassigned = self . _get_unassigned ( active ) [EOL] self . _assign_round_robin ( unassigned , active ) [EOL] assert self . _all_assigned ( active ) [EOL] [EOL] def _assigned_partition_counts ( self , active ) : [EOL] return Counter ( partition for copartitioned in self . _client_assignments . values ( ) for partition in copartitioned . get_assigned_partitions ( active ) ) [EOL] [EOL] def _get_client_limit ( self , active ) : [EOL] return self . capacity * self . _total_assigns_per_partition ( active ) [EOL] [EOL] def _total_assigns_per_partition ( self , active ) : [EOL] return [number] if active else self . replicas [EOL] [EOL] def _unassign_overassigned ( self , active ) : [EOL] [comment] [EOL] [comment] [EOL] partition_counts = self . _assigned_partition_counts ( active ) [EOL] total_assigns = self . _total_assigns_per_partition ( active = active ) [EOL] for partition in range ( self . num_partitions ) : [EOL] extras = partition_counts [ partition ] - total_assigns [EOL] for _ in range ( extras ) : [EOL] assgn = next ( assgn for assgn in self . _client_assignments . values ( ) if assgn . partition_assigned ( partition , active = active ) ) [EOL] assgn . unassign_partition ( partition , active = active ) [EOL] [EOL] def _get_unassigned ( self , active ) : [EOL] partition_counts = self . _assigned_partition_counts ( active ) [EOL] total_assigns = self . _total_assigns_per_partition ( active = active ) [EOL] assert all ( partition_counts [ partition ] <= total_assigns for partition in range ( self . num_partitions ) ) [EOL] return [ partition for partition in range ( self . num_partitions ) for _ in range ( total_assigns - partition_counts [ partition ] ) ] [EOL] [EOL] def _can_assign ( self , assignment , partition , active ) : [EOL] return ( not self . _client_exhausted ( assignment , active ) and assignment . can_assign ( partition , active ) ) [EOL] [EOL] def _client_exhausted ( self , assignemnt , active , client_limit = None ) : [EOL] if client_limit is None : [EOL] client_limit = self . _get_client_limit ( active ) [EOL] return assignemnt . num_assigned ( active ) == client_limit [EOL] [EOL] def _find_promotable_standby ( self , partition , candidates , ) : [EOL] [comment] [EOL] for _ in range ( self . _num_clients ) : [EOL] assignment = next ( candidates ) [EOL] can_assign = ( assignment . partition_assigned ( partition , active = False ) and self . _can_assign ( assignment , partition , active = True ) ) [EOL] if can_assign : [EOL] return assignment [EOL] return None [EOL] [EOL] def _find_round_robin_assignable ( self , partition , candidates , active , ) : [EOL] [comment] [EOL] for _ in range ( self . _num_clients ) : [EOL] assignment = next ( candidates ) [EOL] if self . _can_assign ( assignment , partition , active ) : [EOL] return assignment [EOL] return None [EOL] [EOL] def _assign_round_robin ( self , unassigned , active ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] client_limit = self . _get_client_limit ( active ) [EOL] candidates = cycle ( self . _client_assignments . values ( ) ) [EOL] unassigned = list ( unassigned ) [EOL] while unassigned : [EOL] partition = unassigned . pop ( [number] ) [EOL] [EOL] assign_to = None [EOL] [EOL] if active : [EOL] [comment] [EOL] assign_to = self . _find_promotable_standby ( partition , candidates ) [EOL] if assign_to is not None : [EOL] [comment] [EOL] assign_to . unassign_partition ( partition , active = False ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] for _ in range ( partition ) : [EOL] next ( candidates ) [EOL] [EOL] assert assign_to is None or active [EOL] [EOL] assign_to = assign_to or self . _find_round_robin_assignable ( partition , candidates , active ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert ( assign_to is not None or ( not active and all ( assgn . partition_assigned ( partition , active = True ) or assgn . partition_assigned ( partition , active = False ) or self . _client_exhausted ( assgn , active , client_limit ) for assgn in self . _client_assignments . values ( ) ) ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if assign_to is None : [EOL] assign_to = next ( assigment for assigment in self . _client_assignments . values ( ) if ( self . _client_exhausted ( assigment , active ) and assigment . can_assign ( partition , active ) ) ) [comment] [EOL] unassigned_partition = assign_to . pop_partition ( active ) [EOL] unassigned . append ( unassigned_partition ) [EOL] [EOL] [comment] [EOL] assign_to . assign_partition ( partition , active ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.MutableMapping[builtins.str,client_assignment.CopartitionedAssignment]$ 0 0 0 0 0 $None$ 0 0 0 $typing.Set[builtins.str]$ 0 $typing.MutableMapping[builtins.str,client_assignment.CopartitionedAssignment]$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.MutableMapping[builtins.str,client_assignment.CopartitionedAssignment]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,client_assignment.CopartitionedAssignment]$ 0 0 0 $typing.MutableMapping[builtins.str,client_assignment.CopartitionedAssignment]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Sequence[builtins.int]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Sequence[builtins.int]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $mode.utils.typing.Counter[builtins.int]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $typing.Sequence[builtins.int]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $client_assignment.CopartitionedAssignment$ 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $client_assignment.CopartitionedAssignment$ 0 $builtins.bool$ 0 0 $client_assignment.CopartitionedAssignment$ 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $client_assignment.CopartitionedAssignment$ 0 $builtins.bool$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $client_assignment.CopartitionedAssignment$ 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 $typing.Optional[client_assignment.CopartitionedAssignment]$ 0 0 0 $builtins.int$ 0 $typing.Iterator[client_assignment.CopartitionedAssignment]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Iterator[client_assignment.CopartitionedAssignment]$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[client_assignment.CopartitionedAssignment]$ 0 0 0 $builtins.int$ 0 $typing.Iterator[client_assignment.CopartitionedAssignment]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[client_assignment.CopartitionedAssignment]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0
from typing import List [EOL] import typing [EOL] from . leader_assignor import LeaderAssignor [EOL] from . partition_assignor import PartitionAssignor [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from typing import Set , Any , Sequence , Type , List , MutableMapping [EOL] import client_assignment [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List , MutableMapping , Sequence , Set , cast [EOL] from faust . models import Record [EOL] from . client_assignment import ( ClientAssignment , ClientMetadata , CopartitionedAssignment , ) [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] CopartMapping = MutableMapping [ str , CopartitionedAssignment ] [EOL] [EOL] [EOL] class ClusterAssignment ( Record , serializer = [string] , include_metadata = False , namespace = [string] ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] subscriptions = cast ( MutableMapping [ str , Sequence [ str ] ] , None ) [EOL] assignments = cast ( MutableMapping [ str , ClientAssignment ] , None ) [EOL] [EOL] def __post_init__ ( self ) : [EOL] if self . subscriptions is None : [EOL] self . subscriptions = { } [EOL] if self . assignments is None : [EOL] self . assignments = { } [EOL] [EOL] def topics ( self ) : [EOL] [comment] [EOL] return { topic for sub in self . subscriptions . values ( ) for topic in sub } [EOL] [EOL] def add_client ( self , client , subscription , metadata ) : [EOL] self . subscriptions [ client ] = list ( subscription ) [EOL] self . assignments [ client ] = metadata . assignment [EOL] [EOL] def copartitioned_assignments ( self , copartitioned_topics ) : [EOL] [comment] [EOL] subscribed_clis = { cli for cli , sub in self . subscriptions . items ( ) if copartitioned_topics . issubset ( sub ) } [EOL] return { cli : assignment . copartitioned_assignment ( copartitioned_topics ) for cli , assignment in self . assignments . items ( ) if cli in subscribed_clis } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.Sequence[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,client_assignment.ClientAssignment]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.Sequence[builtins.str]]$ 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.Sequence[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $client_assignment.ClientMetadata$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $client_assignment.ClientMetadata$ 0 0 0 0 0 $CopartMapping$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0
from typing import Iterable , Set , Any , Sequence , Dict , Type , List , Mapping , MutableMapping [EOL] import kafka [EOL] import typing [EOL] import yarl [EOL] import faust [EOL] import client_assignment [EOL] import builtins [EOL] [docstring] [EOL] import socket [EOL] import zlib [EOL] [EOL] from collections import defaultdict [EOL] from typing import ( Iterable , List , Mapping , MutableMapping , Sequence , Set , cast , ) [EOL] [EOL] from kafka . cluster import ClusterMetadata [EOL] from kafka . coordinator . assignors . abstract import AbstractPartitionAssignor [EOL] from kafka . coordinator . protocol import ( ConsumerProtocolMemberAssignment , ConsumerProtocolMemberMetadata , ) [EOL] from mode import get_logger [EOL] from yarl import URL [EOL] [EOL] from faust . types . app import AppT [EOL] from faust . types . assignor import ( HostToPartitionMap , PartitionAssignorT , TopicToPartitionMap , ) [EOL] from faust . types . tables import TableManagerT [EOL] from faust . types . tuples import TP [EOL] [EOL] from . client_assignment import ClientAssignment , ClientMetadata [EOL] from . cluster_assignment import ClusterAssignment [EOL] from . copartitioned_assignor import CopartitionedAssignor [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] MemberAssignmentMapping = MutableMapping [ str , ConsumerProtocolMemberAssignment ] [EOL] MemberMetadataMapping = MutableMapping [ str , ConsumerProtocolMemberMetadata ] [EOL] MemberSubscriptionMapping = MutableMapping [ str , List [ str ] ] [EOL] ClientMetadataMapping = MutableMapping [ str , ClientMetadata ] [EOL] ClientAssignmentMapping = MutableMapping [ str , ClientAssignment ] [EOL] CopartitionedGroups = MutableMapping [ int , Iterable [ Set [ str ] ] ] [EOL] [EOL] logger = get_logger ( __name__ ) [EOL] [EOL] [EOL] class PartitionAssignor ( AbstractPartitionAssignor , PartitionAssignorT ) : [comment] [EOL] [docstring] [EOL] [EOL] _assignment = ... [EOL] _table_manager = ... [EOL] _member_urls = ... [EOL] _changelog_distribution = ... [EOL] _active_tps = ... [EOL] _standby_tps = ... [EOL] _tps_url = ... [EOL] _topic_groups = ... [EOL] [EOL] def __init__ ( self , app , replicas = [number] ) : [EOL] AbstractPartitionAssignor . __init__ ( self ) [EOL] self . app = app [EOL] self . _table_manager = self . app . tables [EOL] self . _assignment = ClientAssignment ( actives = { } , standbys = { } ) [EOL] self . _changelog_distribution = { } [EOL] self . replicas = replicas [EOL] self . _member_urls = { } [EOL] self . _tps_url = { } [EOL] self . _active_tps = set ( ) [EOL] self . _standby_tps = set ( ) [EOL] self . _topic_groups = { } [EOL] [EOL] def group_for_topic ( self , topic ) : [EOL] return self . _topic_groups [ topic ] [EOL] [EOL] @ property def changelog_distribution ( self ) : [EOL] return self . _changelog_distribution [EOL] [EOL] @ changelog_distribution . setter def changelog_distribution ( self , value ) : [EOL] self . _changelog_distribution = value [EOL] self . _tps_url = { TP ( topic , partition ) : url for url , tps in self . _changelog_distribution . items ( ) for topic , partitions in tps . items ( ) for partition in partitions } [EOL] [EOL] @ property def _metadata ( self ) : [EOL] return ClientMetadata ( assignment = self . _assignment , url = str ( self . _url ) , changelog_distribution = self . changelog_distribution , topic_groups = self . _topic_groups , ) [EOL] [EOL] @ property def _url ( self ) : [EOL] return self . app . conf . canonical_url [EOL] [EOL] def on_assignment ( self , assignment ) : [EOL] metadata = cast ( ClientMetadata , ClientMetadata . loads ( self . _decompress ( assignment . user_data ) ) ) [EOL] self . _assignment = metadata . assignment [EOL] self . _topic_groups = dict ( metadata . topic_groups ) [EOL] self . _active_tps = self . _assignment . active_tps [EOL] self . _standby_tps = self . _assignment . standby_tps [EOL] self . changelog_distribution = metadata . changelog_distribution [EOL] a = sorted ( assignment . assignment ) [EOL] b = sorted ( self . _assignment . kafka_protocol_assignment ( self . _table_manager ) ) [EOL] assert a == b , f'{ a !r} [string] { b !r}' [EOL] assert metadata . url == str ( self . _url ) [EOL] [EOL] def metadata ( self , topics ) : [EOL] return ConsumerProtocolMemberMetadata ( self . version , list ( topics ) , self . _metadata . dumps ( ) ) [EOL] [EOL] @ classmethod def _group_co_subscribed ( cls , topics , subscriptions , ) : [EOL] topic_subscriptions = defaultdict ( set ) [EOL] for client , subscription in subscriptions . items ( ) : [EOL] for topic in subscription : [EOL] topic_subscriptions [ topic ] . add ( client ) [EOL] co_subscribed = defaultdict ( set ) [EOL] for topic in topics : [EOL] clients = topic_subscriptions [ topic ] [EOL] assert clients , [string] [EOL] co_subscribed [ tuple ( clients ) ] . add ( topic ) [EOL] return co_subscribed . values ( ) [EOL] [EOL] @ classmethod def _get_copartitioned_groups ( cls , topics , cluster , subscriptions ) : [EOL] topics_by_partitions = defaultdict ( set ) [EOL] for topic in topics : [EOL] num_partitions = len ( cluster . partitions_for_topic ( topic ) or set ( ) ) [EOL] if num_partitions == [number] : [EOL] logger . warning ( [string] , topic ) [EOL] continue [EOL] topics_by_partitions [ num_partitions ] . add ( topic ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] copart_grouped = { num_partitions : cls . _group_co_subscribed ( topics , subscriptions ) for num_partitions , topics in topics_by_partitions . items ( ) } [EOL] return copart_grouped [EOL] [EOL] @ classmethod def _get_client_metadata ( cls , metadata ) : [EOL] client_metadata = ClientMetadata . loads ( metadata . user_data ) [EOL] return cast ( ClientMetadata , client_metadata ) [EOL] [EOL] def _update_member_urls ( self , clients_metadata ) : [EOL] self . _member_urls = { member_id : client_metadata . url for member_id , client_metadata in clients_metadata . items ( ) } [EOL] [EOL] def assign ( self , cluster , member_metadata ) : [EOL] if self . app . tracer : [EOL] return self . _trace_assign ( cluster , member_metadata ) [EOL] else : [EOL] return self . _assign ( cluster , member_metadata ) [EOL] [EOL] def _trace_assign ( self , cluster , member_metadata ) : [EOL] assert self . app . tracer is not None [EOL] span = self . app . tracer . get_tracer ( [string] ) . start_span ( operation_name = [string] , tags = { [string] : socket . gethostname ( ) } , ) [EOL] with span : [EOL] assignment = self . _assign ( cluster , member_metadata ) [EOL] self . app . _span_add_default_tags ( span ) [EOL] span . set_tag ( [string] , assignment ) [EOL] return assignment [EOL] [EOL] def _assign ( self , cluster , member_metadata ) : [EOL] sensor_state = self . app . sensors . on_assignment_start ( self ) [EOL] try : [EOL] assignment = self . _perform_assignment ( cluster , member_metadata ) [EOL] except MemoryError : [EOL] raise [EOL] except Exception as exc : [EOL] self . app . sensors . on_assignment_error ( self , sensor_state , exc ) [EOL] else : [EOL] self . app . sensors . on_assignment_completed ( self , sensor_state ) [EOL] return assignment [EOL] [EOL] def _perform_assignment ( self , cluster , member_metadata ) : [EOL] cluster_assgn = ClusterAssignment ( ) [EOL] [EOL] clients_metadata = { member_id : self . _get_client_metadata ( metadata ) for member_id , metadata in member_metadata . items ( ) } [EOL] [EOL] subscriptions = { member_id : cast ( List [ str ] , metadata . subscription ) for member_id , metadata in member_metadata . items ( ) } [EOL] [EOL] for member_id in member_metadata : [EOL] cluster_assgn . add_client ( member_id , subscriptions [ member_id ] , clients_metadata [ member_id ] ) [EOL] topics = cluster_assgn . topics ( ) [EOL] [EOL] copartitioned_groups = self . _get_copartitioned_groups ( topics , cluster , subscriptions ) [EOL] [EOL] self . _update_member_urls ( clients_metadata ) [EOL] [EOL] [comment] [EOL] assignments = { member_id : ClientAssignment ( actives = { } , standbys = { } ) for member_id in member_metadata } [EOL] [EOL] topic_to_group_id = { } [EOL] partitions_by_topic = { } [EOL] [EOL] for group_id , ( num_partitions , topic_groups ) in enumerate ( sorted ( copartitioned_groups . items ( ) ) ) : [EOL] for topics in topic_groups : [EOL] for topic in topics : [EOL] topic_to_group_id [ topic ] = group_id [EOL] partitions_by_topic [ topic ] = num_partitions [EOL] assert len ( topics ) > [number] and num_partitions > [number] [EOL] [comment] [EOL] assgn = cluster_assgn . copartitioned_assignments ( topics ) [EOL] assignor = CopartitionedAssignor ( topics = topics , cluster_asgn = assgn , num_partitions = num_partitions , replicas = self . replicas , ) [EOL] [comment] [EOL] for client , copart_assn in assignor . get_assignment ( ) . items ( ) : [EOL] assignments [ client ] . add_copartitioned_assignment ( copart_assn ) [EOL] [EOL] [comment] [EOL] assignments = self . _global_table_standby_assignments ( assignments , partitions_by_topic ) [EOL] [EOL] changelog_distribution = self . _get_changelog_distribution ( assignments ) [EOL] res = self . _protocol_assignments ( assignments , changelog_distribution , topic_to_group_id , ) [EOL] return res [EOL] [EOL] def _global_table_standby_assignments ( self , assignments , partitions_by_topic ) : [EOL] [comment] [EOL] [comment] [EOL] for table in self . _table_manager . data . values ( ) : [EOL] [comment] [EOL] if table . is_global : [EOL] changelog_topic_name = table . _changelog_topic_name ( ) [EOL] num_partitions = partitions_by_topic [ changelog_topic_name ] [EOL] assert num_partitions is not None [EOL] all_partitions = set ( range ( [number] , num_partitions ) ) [EOL] for assignment in assignments . values ( ) : [EOL] active_partitions = set ( assignment . actives . get ( changelog_topic_name , [ ] ) ) [EOL] [comment] [EOL] standby_partitions = all_partitions - active_partitions [EOL] assignment . standbys [ changelog_topic_name ] = list ( standby_partitions ) [EOL] return assignments [EOL] [EOL] def _protocol_assignments ( self , assignments , cl_distribution , topic_groups ) : [EOL] return { client : ConsumerProtocolMemberAssignment ( self . version , sorted ( assignment . kafka_protocol_assignment ( self . _table_manager ) ) , self . _compress ( ClientMetadata ( assignment = assignment , url = self . _member_urls [ client ] , changelog_distribution = cl_distribution , topic_groups = topic_groups , ) . dumps ( ) , ) , ) for client , assignment in assignments . items ( ) } [EOL] [EOL] @ classmethod def _compress ( cls , raw ) : [EOL] return zlib . compress ( raw ) [EOL] [EOL] @ classmethod def _decompress ( cls , compressed ) : [EOL] return zlib . decompress ( compressed ) [EOL] [EOL] @ classmethod def _topics_filtered ( cls , assignment , topics ) : [EOL] return { topic : partitions for topic , partitions in assignment . items ( ) if topic in topics } [EOL] [EOL] def _get_changelog_distribution ( self , assignments ) : [EOL] topics = self . _table_manager . changelog_topics [EOL] return { self . _member_urls [ client ] : self . _topics_filtered ( assignment . actives , topics ) for client , assignment in assignments . items ( ) } [EOL] [EOL] @ property def name ( self ) : [EOL] return [string] [EOL] [EOL] @ property def version ( self ) : [EOL] return [number] [EOL] [EOL] def assigned_standbys ( self ) : [EOL] return { TP ( topic , partition ) for topic , partitions in self . _assignment . standbys . items ( ) for partition in partitions } [EOL] [EOL] def assigned_actives ( self ) : [EOL] return { TP ( topic , partition ) for topic , partitions in self . _assignment . actives . items ( ) for partition in partitions } [EOL] [EOL] def table_metadata ( self , topic ) : [EOL] return { host : self . _topics_filtered ( assignment , { topic } ) for host , assignment in self . changelog_distribution . items ( ) } [EOL] [EOL] def tables_metadata ( self ) : [EOL] return self . changelog_distribution [EOL] [EOL] def key_store ( self , topic , key ) : [EOL] return URL ( self . _tps_url [ self . app . producer . key_partition ( topic , key ) ] ) [EOL] [EOL] def is_active ( self , tp ) : [EOL] return tp in self . _active_tps [EOL] [EOL] def is_standby ( self , tp ) : [EOL] return tp in self . _standby_tps [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $client_assignment.ClientAssignment$ 0 0 0 $faust.types.tables.TableManagerT$ 0 0 0 $typing.MutableMapping[builtins.str,builtins.str]$ 0 0 0 $faust.types.assignor.HostToPartitionMap$ 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 $typing.MutableMapping[faust.types.tuples.TP,builtins.str]$ 0 0 0 $typing.MutableMapping[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MemberAssignmentMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.MutableMapping[builtins.int,typing.Iterable[typing.Set[builtins.str]]]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.Dict[typing.Any,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.int,typing.Iterable[typing.Set[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $faust.assignor.copartitioned_assignor.CopartitionedAssignor$ 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.assignor.copartitioned_assignor.CopartitionedAssignor$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.MutableMapping[builtins.str,typing.MutableMapping[builtins.str,typing.List[builtins.int]]]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.MutableMapping[builtins.str,typing.MutableMapping[builtins.str,typing.List[builtins.int]]]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $ClientAssignmentMapping$ 0 0 0 $ClientAssignmentMapping$ 0 $typing.Mapping[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Mapping[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $ClientAssignmentMapping$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 $typing.Set[builtins.int]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 $ClientAssignmentMapping$ 0 0 0 $MemberAssignmentMapping$ 0 0 0 $ClientAssignmentMapping$ 0 $faust.types.assignor.HostToPartitionMap$ 0 $typing.Mapping[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.HostToPartitionMap$ 0 $typing.Mapping[builtins.str,builtins.int]$ 0 $typing.Mapping[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ClientAssignmentMapping$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $faust.types.assignor.TopicToPartitionMap$ 0 0 0 $faust.types.assignor.TopicToPartitionMap$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.TopicToPartitionMap$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $faust.types.assignor.HostToPartitionMap$ 0 0 0 $ClientAssignmentMapping$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 $ClientAssignmentMapping$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.HostToPartitionMap$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.HostToPartitionMap$ 0 0 0 0 0 0 0 0 0 0 0 0 $yarl.URL$ 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $faust.types.tuples.TP$ 0 0 0 0 $faust.types.tuples.TP$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $faust.types.tuples.TP$ 0 0 0 0 $faust.types.tuples.TP$ 0 0 0 0 0
from typing import Tuple , Iterator , Iterable , Optional , Awaitable , Callable , Set , Any , MutableSet , Type , List , MutableMapping , AbstractSet [EOL] import builtins [EOL] import faust [EOL] import typing [EOL] import asyncio [EOL] [docstring] [EOL] import asyncio [EOL] import os [EOL] import typing [EOL] [EOL] from collections import defaultdict [EOL] from typing import ( Any , Callable , Iterable , Iterator , MutableMapping , MutableSet , Optional , Set , Tuple , cast , ) [EOL] from mode import Service , get_logger [EOL] from mode . utils . futures import notify [EOL] [EOL] from faust . exceptions import KeyDecodeError , ValueDecodeError [EOL] from faust . types import AppT , EventT , K , Message , TP , V [EOL] from faust . types . topics import TopicT [EOL] from faust . types . transports import ConductorT , ConsumerCallback , TPorTopicSet [EOL] from faust . types . tuples import tp_set_to_map [EOL] from faust . utils . tracing import traced_from_parent_span [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from faust . topics import Topic as _Topic [EOL] else : [EOL] class _Topic : ... [comment] [EOL] [EOL] NO_CYTHON = bool ( os . environ . get ( [string] , False ) ) [EOL] [EOL] if not NO_CYTHON : [comment] [EOL] try : [EOL] from . _cython . conductor import ConductorHandler [EOL] except ImportError : [EOL] ConductorHandler = None [EOL] else : [comment] [EOL] ConductorHandler = None [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] logger = get_logger ( __name__ ) [EOL] [EOL] [EOL] class ConductorCompiler : [comment] [EOL] [docstring] [EOL] [EOL] def build ( self , conductor , tp , channels ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] topic , partition = tp [EOL] app = conductor . app [EOL] len_ = len [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] consumer_on_buffer_full = app . consumer . on_buffer_full [EOL] [EOL] [comment] [EOL] [comment] [EOL] consumer_on_buffer_drop = app . consumer . on_buffer_drop [EOL] [EOL] [comment] [EOL] [comment] [EOL] acquire_flow_control = app . flow_control . acquire [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] wait_until_producer_ebb = app . producer . buffer . wait_until_ebb [EOL] [EOL] [comment] [EOL] on_topic_buffer_full = app . sensors . on_topic_buffer_full [EOL] [EOL] [comment] [EOL] [comment] [EOL] def on_pressure_high ( ) : [EOL] on_topic_buffer_full ( tp ) [EOL] consumer_on_buffer_full ( tp ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def on_pressure_drop ( ) : [EOL] consumer_on_buffer_drop ( tp ) [EOL] [EOL] async def on_message ( message ) : [EOL] [comment] [EOL] [comment] [EOL] await acquire_flow_control ( ) [EOL] await wait_until_producer_ebb ( ) [EOL] channels_n = len_ ( channels ) [EOL] if channels_n : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] message . incref ( channels_n ) [EOL] event = None [EOL] event_keyid = None [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] delivered = set ( ) [EOL] try : [EOL] for chan in channels : [EOL] keyid = chan . key_type , chan . value_type [EOL] if event is None : [EOL] [comment] [EOL] event = await chan . decode ( message , propagate = True ) [EOL] event_keyid = keyid [EOL] [EOL] queue = chan . queue [EOL] queue . put_nowait_enhanced ( event , on_pressure_high = on_pressure_high , on_pressure_drop = on_pressure_drop , ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] dest_event = ... [EOL] if keyid == event_keyid : [EOL] [comment] [EOL] dest_event = event [EOL] else : [EOL] dest_event = await chan . decode ( message , propagate = True ) [EOL] queue = chan . queue [EOL] queue . put_nowait_enhanced ( dest_event , on_pressure_high = on_pressure_high , on_pressure_drop = on_pressure_drop , ) [EOL] delivered . add ( chan ) [EOL] [EOL] except KeyDecodeError as exc : [EOL] remaining = channels - delivered [EOL] message . ack ( app . consumer , n = len ( remaining ) ) [EOL] for channel in remaining : [EOL] await channel . on_key_decode_error ( exc , message ) [EOL] delivered . add ( channel ) [EOL] except ValueDecodeError as exc : [EOL] remaining = channels - delivered [EOL] message . ack ( app . consumer , n = len ( remaining ) ) [EOL] for channel in remaining : [EOL] await channel . on_value_decode_error ( exc , message ) [EOL] delivered . add ( channel ) [EOL] return on_message [EOL] [EOL] [EOL] class Conductor ( ConductorT , Service ) : [EOL] [docstring] [EOL] [EOL] logger = logger [EOL] [EOL] [comment] [EOL] _topics = ... [EOL] [EOL] [comment] [EOL] _tp_index = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] _topic_name_index = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _tp_to_callback = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] _subscription_changed = ... [EOL] [EOL] _subscription_done = ... [EOL] [EOL] _acking_topics = ... [EOL] [EOL] _compiler = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] _resubscribe_sleep_lock_seconds = [number] [EOL] [EOL] def __init__ ( self , app , ** kwargs ) : [EOL] Service . __init__ ( self , ** kwargs ) [EOL] self . app = app [EOL] self . _topics = set ( ) [EOL] self . _topic_name_index = defaultdict ( set ) [EOL] self . _tp_index = defaultdict ( set ) [EOL] self . _tp_to_callback = { } [EOL] self . _acking_topics = set ( ) [EOL] self . _subscription_changed = None [EOL] self . _subscription_done = None [EOL] self . _compiler = ConductorCompiler ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . on_message = ... [EOL] self . on_message = self . _compile_message_handler ( ) [EOL] [EOL] async def commit ( self , topics ) : [EOL] [docstring] [EOL] return await self . app . consumer . commit ( topics ) [EOL] [EOL] def acks_enabled_for ( self , topic ) : [EOL] [docstring] [EOL] return topic in self . _acking_topics [EOL] [EOL] def _compile_message_handler ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] get_callback_for_tp = self . _tp_to_callback . __getitem__ [EOL] [EOL] if self . app . client_only : [EOL] async def on_message ( message ) : [EOL] tp = TP ( topic = message . topic , partition = [number] ) [EOL] return await get_callback_for_tp ( tp ) ( message ) [EOL] else : [EOL] async def on_message ( message ) : [EOL] return await get_callback_for_tp ( message . tp ) ( message ) [EOL] [EOL] return on_message [EOL] [EOL] @ Service . task async def _subscriber ( self ) : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . app . client_only or self . app . producer_only : [EOL] self . log . info ( [string] ) [EOL] else : [EOL] self . log . info ( [string] ) [EOL] await self . app . agents . wait_until_agents_started ( ) [EOL] self . log . info ( [string] ) [EOL] await self . app . tables . wait_until_tables_registered ( ) [EOL] if not self . should_stop : [EOL] [comment] [EOL] await self . app . consumer . subscribe ( await self . _update_indices ( ) ) [EOL] notify ( self . _subscription_done ) [EOL] [EOL] [comment] [EOL] ev = self . _subscription_changed = asyncio . Event ( loop = self . loop ) [EOL] while not self . should_stop : [EOL] [comment] [EOL] await ev . wait ( ) [EOL] if self . app . rebalancing : [EOL] [comment] [EOL] [comment] [EOL] ev . clear ( ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] await self . sleep ( self . _resubscribe_sleep_lock_seconds ) [EOL] subscribed_topics = await self . _update_indices ( ) [EOL] await self . app . consumer . subscribe ( subscribed_topics ) [EOL] [EOL] [comment] [EOL] ev . clear ( ) [EOL] [comment] [EOL] notify ( self . _subscription_done ) [EOL] [EOL] async def wait_for_subscriptions ( self ) : [EOL] [docstring] [EOL] if self . _subscription_done is None : [EOL] self . _subscription_done = asyncio . Future ( loop = self . loop ) [EOL] await self . _subscription_done [EOL] [EOL] async def maybe_wait_for_subscriptions ( self ) : [EOL] if self . _subscription_done is not None : [EOL] await self . _subscription_done [EOL] [EOL] async def _update_indices ( self ) : [EOL] self . _topic_name_index . clear ( ) [EOL] self . _tp_to_callback . clear ( ) [EOL] for channel in self . _topics : [EOL] if channel . internal : [EOL] await channel . maybe_declare ( ) [EOL] for topic in channel . topics : [EOL] if channel . acks : [EOL] self . _acking_topics . add ( topic ) [EOL] self . _topic_name_index [ topic ] . add ( channel ) [EOL] [EOL] return self . _topic_name_index [EOL] [EOL] async def on_partitions_assigned ( self , assigned ) : [EOL] [docstring] [EOL] T = traced_from_parent_span ( ) [EOL] self . _tp_index . clear ( ) [EOL] T ( self . _update_tp_index ) ( assigned ) [EOL] T ( self . _update_callback_map ) ( ) [EOL] [EOL] async def on_client_only_start ( self ) : [EOL] tp_index = self . _tp_index [EOL] for topic in self . _topics : [EOL] for subtopic in topic . topics : [EOL] tp = TP ( topic = subtopic , partition = [number] ) [EOL] tp_index [ tp ] . add ( topic ) [EOL] self . _update_callback_map ( ) [EOL] [EOL] def _update_tp_index ( self , assigned ) : [EOL] assignmap = tp_set_to_map ( assigned ) [EOL] tp_index = self . _tp_index [EOL] for topic in self . _topics : [EOL] if topic . active_partitions is not None : [EOL] [comment] [EOL] if topic . active_partitions : [EOL] if assigned : [EOL] assert topic . active_partitions . issubset ( assigned ) [EOL] for tp in topic . active_partitions : [EOL] tp_index [ tp ] . add ( topic ) [EOL] else : [EOL] [comment] [EOL] for subtopic in topic . topics : [EOL] for tp in assignmap [ subtopic ] : [EOL] tp_index [ tp ] . add ( topic ) [EOL] [EOL] def _update_callback_map ( self ) : [EOL] self . _tp_to_callback . update ( ( tp , self . _build_handler ( tp , cast ( MutableSet [ _Topic ] , channels ) ) ) for tp , channels in self . _tp_index . items ( ) ) [EOL] [EOL] def _build_handler ( self , tp , channels ) : [EOL] if ConductorHandler is not None : [comment] [EOL] return ConductorHandler ( self , tp , channels ) [EOL] else : [EOL] return self . _compiler . build ( self , tp , channels ) [EOL] [EOL] def clear ( self ) : [EOL] [docstring] [EOL] self . _topics . clear ( ) [EOL] self . _topic_name_index . clear ( ) [EOL] self . _tp_index . clear ( ) [EOL] self . _tp_to_callback . clear ( ) [EOL] self . _acking_topics . clear ( ) [EOL] [EOL] def __contains__ ( self , value ) : [EOL] return value in self . _topics [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . _topics ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _topics ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return object . __hash__ ( self ) [EOL] [EOL] def add ( self , topic ) : [EOL] [docstring] [EOL] if topic not in self . _topics : [EOL] self . _topics . add ( topic ) [EOL] if self . _topic_contain_unsubscribed_topics ( topic ) : [EOL] self . _flag_changes ( ) [EOL] [EOL] def _topic_contain_unsubscribed_topics ( self , topic ) : [EOL] index = self . _topic_name_index [EOL] return bool ( index and any ( t not in index for t in topic . topics ) ) [EOL] [EOL] def discard ( self , topic ) : [EOL] [docstring] [EOL] self . _topics . discard ( topic ) [EOL] [EOL] def _flag_changes ( self ) : [EOL] if self . _subscription_changed is not None : [EOL] self . _subscription_changed . set ( ) [EOL] if self . _subscription_done is None : [EOL] self . _subscription_done = asyncio . Future ( loop = self . loop ) [EOL] [EOL] @ property def label ( self ) : [EOL] [docstring] [EOL] return f'{ type ( self ) . __name__ } [string] { len ( self . _topics ) } [string] ' [EOL] [EOL] @ property def shortlabel ( self ) : [EOL] [docstring] [EOL] return type ( self ) . __name__ [EOL] [EOL] @ property def acking_topics ( self ) : [EOL] return self . _acking_topics [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ConsumerCallback$ 0 0 0 $'Conductor'$ 0 $faust.types.TP$ 0 $typing.MutableSet[faust.topics.Topic]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 0 0 $'Conductor'$ 0 0 0 $typing.Callable[[typing.Any],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[faust.topics.Topic]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[faust.topics.Topic]$ 0 0 0 0 0 0 $typing.AbstractSet[faust.topics.Topic]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[faust.topics.Topic]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[faust.topics.Topic]$ 0 0 0 0 0 0 $typing.AbstractSet[faust.topics.Topic]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[faust.transport.conductor.Conductor]$ 0 $typing.Type[faust.transport.conductor.Conductor]$ 0 0 0 0 $typing.MutableSet[faust.types.topics.TopicT]$ 0 0 0 0 0 0 $typing.MutableMapping[faust.types.TP,typing.MutableSet[faust.types.topics.TopicT]]$ 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.MutableSet[faust.types.topics.TopicT]]$ 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[faust.types.TP,faust.types.transports.ConsumerCallback]$ 0 0 0 0 0 0 0 0 $typing.Optional[asyncio.Event]$ 0 0 0 0 $typing.Optional[asyncio.Future]$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $ConductorCompiler$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[asyncio.locks.Event]$ 0 0 0 0 0 $typing.Optional[asyncio.futures.Future[typing.Any]]$ 0 0 0 0 0 $faust.transport.conductor.ConductorCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[faust.types.tuples.Message],typing.Awaitable[typing.Any]]$ 0 0 0 0 0 $typing.Callable[[faust.types.tuples.Message],typing.Awaitable[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $faust.types.transports.TPorTopicSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.TPorTopicSet$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $faust.types.transports.ConsumerCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $faust.types.Message$ 0 0 0 0 0 0 0 0 0 $faust.types.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.Message$ 0 0 0 0 0 0 0 $None$ 0 $faust.types.Message$ 0 0 0 0 0 0 0 $faust.types.Message$ 0 0 0 0 $faust.types.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[asyncio.futures.Future[typing.Any]]$ 0 0 0 0 0 0 $typing.Optional[asyncio.futures.Future[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[asyncio.futures.Future[typing.Any]]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Set[faust.types.TP]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[faust.types.TP]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Set[faust.types.TP]$ 0 0 0 $typing.MutableMapping[builtins.str,typing.Set[faust.types.tuples.TP]]$ 0 0 0 $typing.Set[faust.types.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.TP]$ 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.Set[faust.types.tuples.TP]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ConsumerCallback$ 0 0 0 $faust.types.TP$ 0 $typing.MutableSet[faust.topics.Topic]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 $typing.MutableSet[faust.topics.Topic]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 $typing.MutableSet[faust.topics.Topic]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Iterator[faust.types.topics.TopicT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.topics.TopicT$ 0 0 0 0 0 0 $faust.types.topics.TopicT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.topics.TopicT$ 0 0 0 0 0 0 0 $faust.types.topics.TopicT$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $faust.types.topics.TopicT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.topics.TopicT$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[asyncio.futures.Future[typing.Any]]$ 0 0 0 0 0 0 $typing.Optional[asyncio.futures.Future[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from . drivers import by_name , by_url [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Type , List [EOL] import faust [EOL] import typing [EOL] import mode [EOL] [docstring] [EOL] from typing import Type [EOL] from mode . utils . imports import FactoryMapping [EOL] from faust . types import TransportT [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] TRANSPORTS = FactoryMapping ( aiokafka = [string] , confluent = [string] , kafka = [string] , ) [EOL] TRANSPORTS . include_setuptools_namespace ( [string] ) [EOL] by_name = TRANSPORTS . by_name [EOL] by_url = TRANSPORTS . by_url [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.TransportT]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.TransportT]]$ 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.TransportT]]$ 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.TransportT]]$ 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Iterable , Optional , List [EOL] import typing [EOL] import click [EOL] import builtins [EOL] import yarl [EOL] [docstring] [EOL] from typing import Any , Iterable , Optional [EOL] import click [EOL] from click . types import ParamType , StringParamType [EOL] from yarl import URL [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] WritableDirectory = click . Path ( exists = False , file_okay = False , dir_okay = True , writable = True , readable = True , ) [EOL] [EOL] WritableFilePath = click . Path ( exists = False , file_okay = True , dir_okay = False , writable = True , readable = True , ) [EOL] [EOL] [EOL] class CaseInsensitiveChoice ( click . Choice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , choices ) : [EOL] self . choices = [ str ( val ) . lower ( ) for val in choices ] [EOL] self . case_sensitive = False [comment] [EOL] [EOL] def convert ( self , value , param , ctx ) : [EOL] [docstring] [EOL] if value . lower ( ) in self . choices : [EOL] return value [EOL] return super ( ) . convert ( value , param , ctx ) [EOL] [EOL] [EOL] class TCPPort ( click . IntRange ) : [EOL] [docstring] [EOL] [EOL] name = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [number] , [number] ) [EOL] [EOL] [EOL] class URLParam ( ParamType ) : [EOL] [docstring] [EOL] [EOL] name = [string] [EOL] [EOL] _string_param = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . _string_param = StringParamType ( ) [EOL] [EOL] def convert ( self , value , param , ctx ) : [EOL] [docstring] [EOL] text_value = self . _string_param . convert ( value , param , ctx ) [EOL] return URL ( text_value ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.types.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.types.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Optional[click.Parameter]$ 0 $typing.Optional[click.Context]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[click.Parameter]$ 0 $typing.Optional[click.Context]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $click.types.StringParamType$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $click.types.StringParamType$ 0 0 0 0 0 0 0 $yarl.URL$ 0 0 0 $builtins.str$ 0 $typing.Optional[click.Parameter]$ 0 $typing.Optional[click.Context]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[click.Parameter]$ 0 $typing.Optional[click.Context]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Any , Type , List [EOL] import faust [EOL] import typing [EOL] [docstring] [EOL] from typing import Any [EOL] from . worker import worker [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class livecheck ( worker ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] try : [EOL] livecheck = self . app . livecheck [comment] [EOL] except AttributeError : [EOL] raise self . UsageError ( f' [string] { self . app !r} [string] ' ) [EOL] self . app = livecheck [EOL] self . _finalize_concrete_app ( self . app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Type[faust.cli.livecheck.livecheck]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[faust.cli.livecheck.livecheck]$ 0 0 0 0 0 0 0 $typing.Type[faust.cli.livecheck.livecheck]$ 0 0 0 0 0 0 0 0 0 $typing.Type[faust.cli.livecheck.livecheck]$ 0 0
from typing import Type , Sequence [EOL] import faust [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from operator import attrgetter [EOL] from typing import Any , Callable , Sequence , Type , cast [EOL] from faust . models import registry [EOL] from faust . types import ModelT [EOL] from . base import AppCommand , option [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class models ( AppCommand ) : [EOL] [docstring] [EOL] [EOL] title = [string] [EOL] headers = [ [string] , [string] ] [EOL] sortkey = attrgetter ( [string] ) [EOL] [EOL] options = [ option ( [string] , default = False ) , ] [EOL] [EOL] async def run ( self , * , builtins ) : [EOL] [docstring] [EOL] self . say ( self . tabulate ( [ self . model_to_row ( model ) for model in self . models ( builtins ) ] , headers = self . headers , title = self . title , ) ) [EOL] [EOL] def models ( self , builtins ) : [EOL] [docstring] [EOL] sortkey = cast ( Callable [ [ Type [ ModelT ] ] , Any ] , self . sortkey ) [EOL] return [ model for model in sorted ( registry . values ( ) , key = sortkey ) if not model . _options . namespace . startswith ( [string] ) or builtins ] [EOL] [EOL] def model_to_row ( self , model ) : [EOL] [docstring] [EOL] return [ self . bold_tail ( self . _name ( model ) ) , self . dark ( self . _help ( model ) ) , ] [EOL] [EOL] def _name ( self , model ) : [EOL] return self . abbreviate_fqdn ( model . _options . namespace ) [EOL] [EOL] def _help ( self , model ) : [EOL] return model . __doc__ or [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Type[faust.types.ModelT]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 $typing.Type[faust.types.ModelT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[faust.types.ModelT]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[faust.types.ModelT]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[faust.types.ModelT]$ 0 0 0 0 0 0 0 0 $typing.Type[faust.types.ModelT]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[faust.types.ModelT]$ 0 0 0 0 $typing.Type[faust.types.ModelT]$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from . base import AppCommand , Command , argument , call_command , option [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Iterable , Any , Type , List [EOL] import typing [EOL] import faust [EOL] import raven [EOL] import logging [EOL] import builtins [EOL] import asyncio [EOL] import logging [EOL] import sys [EOL] import typing [EOL] import traceback [EOL] from functools import partial [EOL] from typing import Any , Iterable , Optional , Type [EOL] [EOL] from faust . exceptions import ImproperlyConfigured [EOL] from faust . types import AppT [EOL] [EOL] try : [EOL] import raven [EOL] except ImportError : [comment] [EOL] raven = None [comment] [EOL] [EOL] try : [EOL] import sentry_sdk [EOL] except ImportError : [comment] [EOL] sentry_sdk = None [comment] [EOL] _sdk_aiohttp = None [comment] [EOL] else : [EOL] import sentry_sdk . integrations . aiohttp as _sdk_aiohttp [comment] [EOL] [EOL] try : [EOL] import raven_aiohttp [EOL] except ImportError : [comment] [EOL] raven_aiohttp = None [comment] [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] from raven . handlers . logging import SentryHandler as _SentryHandler [EOL] else : [EOL] class _SentryHandler : ... [comment] [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] DEFAULT_LEVEL = logging . WARNING [EOL] [EOL] [EOL] def _build_sentry_handler ( ) : [EOL] from raven . handlers import logging as _logging [EOL] [EOL] class FaustSentryHandler ( _logging . SentryHandler ) : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def can_record ( self , record ) : [EOL] return ( super ( ) . can_record ( record ) and not self . _is_expected_cancel ( record ) ) [EOL] [EOL] def _is_expected_cancel ( self , record ) : [EOL] [comment] [EOL] [comment] [EOL] if record . exc_info and record . exc_info [ [number] ] is not None : [EOL] return bool ( issubclass ( record . exc_info [ [number] ] , asyncio . CancelledError ) and getattr ( record . exc_info [ [number] ] , [string] , True ) ) [EOL] return False [EOL] [EOL] def emit ( self , record ) : [EOL] try : [EOL] self . format ( record ) [EOL] [EOL] if self . can_record ( record ) : [EOL] self . _emit ( record ) [EOL] else : [EOL] self . carp ( record . message ) [EOL] except Exception : [EOL] if self . client . raise_send_errors : [EOL] raise [EOL] self . carp ( [string] [string] ) [EOL] self . carp ( record . msg ) [EOL] self . carp ( traceback . format_exc ( ) ) [EOL] [EOL] def carp ( self , obj ) : [EOL] print ( _logging . to_string ( obj ) , file = sys . __stderr__ ) [EOL] [EOL] return FaustSentryHandler [EOL] [EOL] [EOL] def handler_from_dsn ( dsn = None , workers = [number] , include_paths = None , loglevel = None , qsize = [number] , ** kwargs ) : [EOL] if raven is None : [EOL] raise ImproperlyConfigured ( [string] ) [EOL] if raven_aiohttp is None : [EOL] raise ImproperlyConfigured ( [string] ) [EOL] level = loglevel if loglevel is not None else DEFAULT_LEVEL [EOL] if dsn : [EOL] client = raven . Client ( dsn = dsn , include_paths = include_paths , transport = partial ( raven_aiohttp . QueuedAioHttpTransport , workers = workers , qsize = qsize , ) , disable_existing_loggers = False , ** kwargs ) [EOL] handler = _build_sentry_handler ( ) ( client ) [EOL] handler . setLevel ( level ) [EOL] return handler [EOL] return None [EOL] [EOL] [EOL] def setup ( app , * , dsn = None , workers = [number] , max_queue_size = [number] , loglevel = None ) : [EOL] sentry_handler = handler_from_dsn ( dsn = dsn , workers = workers , qsize = max_queue_size , loglevel = loglevel , ) [EOL] if sentry_handler is not None : [EOL] if sentry_sdk is None or _sdk_aiohttp is None : [EOL] raise ImproperlyConfigured ( [string] ) [EOL] sentry_sdk . init ( dsn = dsn , integrations = [ _sdk_aiohttp . AioHttpIntegration ( ) ] , ) [EOL] app . conf . loghandlers . append ( sentry_handler ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Type[raven.handlers.logging.SentryHandler]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[logging.Handler]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from . base import Collection , CollectionT [EOL] from . globaltable import GlobalTable , GlobalTableT [EOL] from . manager import TableManager , TableManagerT [EOL] from . table import Table , TableT [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Optional , Set , Any , Dict , Type , List , Mapping , Counter [EOL] import typing [EOL] import faust [EOL] import opentracing [EOL] import builtins [EOL] import mode [EOL] [docstring] [EOL] import asyncio [EOL] import statistics [EOL] import typing [EOL] [EOL] from collections import defaultdict , deque [EOL] from time import monotonic [EOL] from typing import ( Any , Iterator , List , Mapping , MutableMapping , NamedTuple , Optional , Set , cast , ) [EOL] [EOL] import opentracing [EOL] from mode import Service [EOL] from mode . services import WaitArgT [EOL] from mode . utils . locks import Event [EOL] from mode . utils . times import humanize_seconds , humanize_seconds_ago [EOL] from mode . utils . typing import Counter , Deque [EOL] [EOL] from faust . exceptions import ConsistencyError [EOL] from faust . types import AppT , EventT , TP [EOL] from faust . types . tables import CollectionT , TableManagerT [EOL] from faust . types . transports import ConsumerT [EOL] from faust . utils import terminal [EOL] from faust . utils . terminal . tables import TableDataT [comment] [EOL] from faust . utils . tracing import finish_span , traced_from_parent_span [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] from faust . app import App as _App [EOL] from . manager import TableManager as _TableManager [EOL] else : [EOL] class _App : ... [comment] [EOL] class _TableManager : ... [comment] [EOL] [EOL] E_PERSISTED_OFFSET = [string] [EOL] [EOL] [EOL] class RecoveryStats ( NamedTuple ) : [EOL] highwater = ... [EOL] offset = ... [EOL] remaining = ... [EOL] [EOL] [EOL] RecoveryStatsMapping = Mapping [ TP , RecoveryStats ] [EOL] [EOL] [EOL] class ServiceStopped ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class RebalanceAgain ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Recovery ( Service ) : [EOL] [docstring] [EOL] [EOL] app = ... [EOL] [EOL] tables = ... [EOL] [EOL] stats_interval = [number] [EOL] [EOL] [comment] [EOL] standby_tps = ... [EOL] [EOL] [comment] [EOL] active_tps = ... [EOL] [EOL] actives_for_table = ... [EOL] standbys_for_table = ... [EOL] [EOL] [comment] [EOL] tp_to_table = ... [EOL] [EOL] [comment] [EOL] active_offsets = ... [EOL] [EOL] [comment] [EOL] standby_offsets = ... [EOL] [EOL] [comment] [EOL] highwaters = ... [EOL] [EOL] [comment] [EOL] active_highwaters = ... [EOL] [EOL] [comment] [EOL] standby_highwaters = ... [EOL] [EOL] _signal_recovery_start = None [EOL] _signal_recovery_end = None [EOL] _signal_recovery_reset = None [EOL] [EOL] completed = ... [EOL] in_recovery = False [EOL] standbys_pending = False [EOL] recovery_delay = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] buffers = ... [EOL] [EOL] [comment] [EOL] buffer_sizes = ... [EOL] [EOL] [comment] [EOL] flush_timeout_secs = [number] [EOL] [EOL] [comment] [EOL] event_timeout_secs = [number] [EOL] [EOL] [comment] [EOL] _active_events_received_at = ... [EOL] [EOL] [comment] [EOL] _standby_events_received_at = ... [EOL] [EOL] [comment] [EOL] _last_active_event_processed_at = ... [EOL] [EOL] [comment] [EOL] _last_flush_at = None [EOL] [EOL] [comment] [EOL] _recovery_started_at = None [EOL] [EOL] [comment] [EOL] _recovery_ended_at = None [EOL] [EOL] _recovery_span = None [EOL] _actives_span = None [EOL] _standbys_span = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _processing_times = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] num_samples_required_for_estimate = [number] [EOL] [EOL] def __init__ ( self , app , tables , ** kwargs ) : [EOL] self . app = app [EOL] self . tables = cast ( _TableManager , tables ) [EOL] [EOL] self . standby_tps = set ( ) [EOL] self . active_tps = set ( ) [EOL] [EOL] self . tp_to_table = { } [EOL] self . active_offsets = Counter ( ) [EOL] self . standby_offsets = Counter ( ) [EOL] [EOL] self . active_highwaters = Counter ( ) [EOL] self . standby_highwaters = Counter ( ) [EOL] self . completed = Event ( ) [EOL] [EOL] self . buffers = defaultdict ( list ) [EOL] self . buffer_sizes = { } [EOL] self . recovery_delay = self . app . conf . stream_recovery_delay [EOL] [EOL] self . actives_for_table = defaultdict ( set ) [EOL] self . standbys_for_table = defaultdict ( set ) [EOL] [EOL] self . _active_events_received_at = { } [EOL] self . _standby_events_received_at = { } [EOL] self . _processing_times = deque ( ) [EOL] [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] [EOL] @ property def signal_recovery_start ( self ) : [EOL] [docstring] [EOL] if self . _signal_recovery_start is None : [EOL] self . _signal_recovery_start = Event ( loop = self . loop ) [EOL] return self . _signal_recovery_start [EOL] [EOL] @ property def signal_recovery_end ( self ) : [EOL] [docstring] [EOL] if self . _signal_recovery_end is None : [EOL] self . _signal_recovery_end = Event ( loop = self . loop ) [EOL] return self . _signal_recovery_end [EOL] [EOL] @ property def signal_recovery_reset ( self ) : [EOL] [docstring] [EOL] if self . _signal_recovery_reset is None : [EOL] self . _signal_recovery_reset = Event ( loop = self . loop ) [EOL] return self . _signal_recovery_reset [EOL] [EOL] async def on_stop ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . flush_buffers ( ) [EOL] [EOL] def add_active ( self , table , tp ) : [EOL] [docstring] [EOL] self . active_tps . add ( tp ) [EOL] self . actives_for_table [ table ] . add ( tp ) [EOL] self . _add ( table , tp , self . active_offsets ) [EOL] [EOL] def add_standby ( self , table , tp ) : [EOL] [docstring] [EOL] self . standby_tps . add ( tp ) [EOL] self . standbys_for_table [ table ] . add ( tp ) [EOL] self . _add ( table , tp , self . standby_offsets ) [EOL] [EOL] def _add ( self , table , tp , offsets ) : [EOL] self . tp_to_table [ tp ] = table [EOL] persisted_offset = table . persisted_offset ( tp ) [EOL] if persisted_offset is not None : [EOL] offsets [ tp ] = persisted_offset [EOL] offsets . setdefault ( tp , None ) [comment] [EOL] [EOL] def revoke ( self , tp ) : [EOL] [docstring] [EOL] self . standby_offsets . pop ( tp , None ) [EOL] self . standby_highwaters . pop ( tp , None ) [EOL] self . active_offsets . pop ( tp , None ) [EOL] self . active_highwaters . pop ( tp , None ) [EOL] [EOL] def on_partitions_revoked ( self , revoked ) : [EOL] [docstring] [EOL] T = traced_from_parent_span ( ) [EOL] T ( self . flush_buffers ) ( ) [EOL] self . signal_recovery_reset . set ( ) [EOL] [EOL] async def on_rebalance ( self , assigned , revoked , newly_assigned ) : [EOL] [docstring] [EOL] app = self . app [EOL] assigned_standbys = app . assignor . assigned_standbys ( ) [EOL] assigned_actives = app . assignor . assigned_actives ( ) [EOL] [EOL] for tp in revoked : [EOL] await asyncio . sleep ( [number] ) [EOL] self . revoke ( tp ) [EOL] [EOL] self . standby_tps . clear ( ) [EOL] self . active_tps . clear ( ) [EOL] self . actives_for_table . clear ( ) [EOL] self . standbys_for_table . clear ( ) [EOL] [EOL] for tp in assigned_standbys : [EOL] table = self . tables . _changelogs . get ( tp . topic ) [EOL] if table is not None : [EOL] self . add_standby ( table , tp ) [EOL] await asyncio . sleep ( [number] ) [EOL] await asyncio . sleep ( [number] ) [EOL] for tp in assigned_actives : [EOL] table = self . tables . _changelogs . get ( tp . topic ) [EOL] if table is not None : [EOL] self . add_active ( table , tp ) [EOL] await asyncio . sleep ( [number] ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] active_offsets = { tp : offset for tp , offset in self . active_offsets . items ( ) if tp in self . active_tps } [EOL] self . active_offsets . clear ( ) [EOL] self . active_offsets . update ( active_offsets ) [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] rebalancing_span = cast ( _App , self . app ) . _rebalancing_span [EOL] if app . tracer and rebalancing_span : [EOL] self . _recovery_span = app . tracer . get_tracer ( [string] ) . start_span ( [string] , child_of = rebalancing_span , ) [EOL] app . _span_add_default_tags ( self . _recovery_span ) [EOL] self . signal_recovery_reset . clear ( ) [EOL] self . signal_recovery_start . set ( ) [EOL] [EOL] async def _resume_streams ( self ) : [EOL] app = self . app [EOL] consumer = app . consumer [EOL] await app . on_rebalance_complete . send ( ) [EOL] [comment] [EOL] self . log . info ( [string] ) [EOL] consumer . resume_flow ( ) [EOL] app . flow_control . resume ( ) [EOL] assignment = consumer . assignment ( ) [EOL] if assignment : [EOL] self . log . info ( [string] ) [EOL] await self . _wait ( consumer . perform_seek ( ) ) [EOL] self . log . dev ( [string] ) [EOL] consumer . resume_partitions ( assignment ) [EOL] else : [EOL] self . log . info ( [string] ) [EOL] self . completed . set ( ) [EOL] [comment] [EOL] await cast ( _App , app ) . _fetcher . maybe_start ( ) [EOL] self . tables . on_actives_ready ( ) [EOL] self . tables . on_standbys_ready ( ) [EOL] app . on_rebalance_end ( ) [EOL] self . log . info ( [string] ) [EOL] [EOL] @ Service . task async def _restart_recovery ( self ) : [EOL] consumer = self . app . consumer [EOL] active_tps = self . active_tps [EOL] standby_tps = self . standby_tps [EOL] standby_offsets = self . standby_offsets [EOL] standby_highwaters = self . standby_highwaters [EOL] assigned_active_tps = self . active_tps [EOL] assigned_standby_tps = self . standby_tps [EOL] active_offsets = self . active_offsets [EOL] standby_offsets = self . standby_offsets [EOL] active_highwaters = self . active_highwaters [EOL] [EOL] while not self . should_stop : [EOL] self . log . dev ( [string] ) [EOL] self . signal_recovery_reset . clear ( ) [EOL] self . _set_recovery_ended ( ) [EOL] if await self . wait_for_stopped ( self . signal_recovery_start ) : [EOL] self . signal_recovery_start . clear ( ) [EOL] break [comment] [EOL] self . signal_recovery_start . clear ( ) [EOL] [EOL] span = None [EOL] spans = [ ] [EOL] tracer = None [EOL] if self . app . tracer : [EOL] tracer = self . app . tracer . get_tracer ( [string] ) [EOL] if tracer is not None and self . _recovery_span : [EOL] span = tracer . start_span ( [string] , child_of = self . _recovery_span ) [EOL] self . app . _span_add_default_tags ( span ) [EOL] spans . extend ( [ span , self . _recovery_span ] ) [EOL] T = traced_from_parent_span ( span ) [EOL] [EOL] try : [EOL] await self . _wait ( T ( asyncio . sleep ) ( self . recovery_delay ) ) [EOL] [EOL] if not self . tables : [EOL] [comment] [EOL] await T ( self . _resume_streams ) ( ) [EOL] for _span in spans : [EOL] finish_span ( _span ) [EOL] continue [EOL] [EOL] self . _set_recovery_started ( ) [EOL] self . standbys_pending = True [EOL] [comment] [EOL] T ( self . flush_buffers ) ( ) [EOL] producer = cast ( _App , self . app ) . _producer [EOL] if producer is not None : [EOL] await self . _wait ( T ( producer . flush ) ( ) ) [EOL] [EOL] self . log . dev ( [string] ) [EOL] await self . _wait ( T ( self . _build_highwaters ) ( consumer , assigned_active_tps , active_highwaters , [string] ) ) [EOL] [EOL] self . log . dev ( [string] ) [EOL] await self . _wait ( T ( self . _build_offsets ) ( consumer , assigned_active_tps , active_offsets , [string] ) ) [EOL] [EOL] for tp in assigned_active_tps : [EOL] if active_offsets [ tp ] > active_highwaters [ tp ] : [EOL] raise ConsistencyError ( E_PERSISTED_OFFSET . format ( tp , active_offsets [ tp ] , active_highwaters [ tp ] , ) , ) [EOL] [EOL] self . log . dev ( [string] ) [EOL] await self . _wait ( T ( self . _build_offsets ) ( consumer , assigned_standby_tps , standby_offsets , [string] ) ) [EOL] [EOL] self . log . dev ( [string] ) [EOL] await self . _wait ( T ( self . _seek_offsets ) ( consumer , assigned_active_tps , active_offsets , [string] ) ) [EOL] [EOL] if self . need_recovery ( ) : [EOL] self . log . info ( [string] ) [EOL] T ( consumer . resume_partitions ) ( active_tps ) [EOL] [comment] [EOL] self . log . info ( [string] ) [EOL] T ( consumer . resume_flow ) ( ) [EOL] await T ( cast ( _App , self . app ) . _fetcher . maybe_start ) ( ) [EOL] T ( self . app . flow_control . resume ) ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if tracer is not None and span : [EOL] self . _actives_span = tracer . start_span ( [string] , child_of = span , tags = { [string] : self . active_stats ( ) } , ) [EOL] self . app . _span_add_default_tags ( span ) [EOL] try : [EOL] self . signal_recovery_end . clear ( ) [EOL] await self . _wait ( self . signal_recovery_end ) [EOL] except Exception as exc : [EOL] finish_span ( self . _actives_span , error = exc ) [EOL] else : [EOL] finish_span ( self . _actives_span ) [EOL] finally : [EOL] self . _actives_span = None [EOL] [EOL] [comment] [EOL] self . log . info ( [string] ) [EOL] T ( consumer . pause_partitions ) ( active_tps ) [EOL] else : [EOL] self . log . info ( [string] ) [EOL] T ( consumer . resume_flow ) ( ) [EOL] T ( self . app . flow_control . resume ) ( ) [EOL] [EOL] self . log . info ( [string] ) [EOL] if span : [EOL] span . set_tag ( [string] , True ) [EOL] self . _set_recovery_ended ( ) [EOL] [EOL] if standby_tps : [EOL] self . log . info ( [string] ) [EOL] [EOL] self . log . dev ( [string] ) [EOL] await self . _wait ( T ( self . _seek_offsets ) ( consumer , standby_tps , standby_offsets , [string] ) ) [EOL] [EOL] self . log . dev ( [string] ) [EOL] await self . _wait ( T ( self . _build_highwaters ) ( consumer , standby_tps , standby_highwaters , [string] , ) , ) [EOL] [EOL] for tp in standby_tps : [EOL] if standby_offsets [ tp ] > standby_highwaters [ tp ] : [EOL] raise ConsistencyError ( E_PERSISTED_OFFSET . format ( tp , standby_offsets [ tp ] , standby_highwaters [ tp ] , ) , ) [EOL] [EOL] if tracer is not None and span : [EOL] self . _standbys_span = tracer . start_span ( [string] , child_of = span , tags = { [string] : self . standby_stats ( ) } , ) [EOL] self . app . _span_add_default_tags ( span ) [EOL] self . log . dev ( [string] ) [EOL] T ( consumer . resume_partitions ) ( standby_tps ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] await self . _wait ( asyncio . sleep ( [number] ) ) [comment] [EOL] await self . _wait ( T ( self . on_recovery_completed ) ( ) ) [EOL] except RebalanceAgain as exc : [EOL] self . log . dev ( [string] ) [EOL] for _span in spans : [EOL] finish_span ( _span , error = exc ) [EOL] continue [comment] [EOL] except ServiceStopped as exc : [EOL] self . log . dev ( [string] ) [EOL] for _span in spans : [EOL] finish_span ( _span , error = exc ) [EOL] break [comment] [EOL] except Exception as exc : [EOL] for _span in spans : [EOL] finish_span ( _span , error = exc ) [EOL] raise [EOL] else : [EOL] for _span in spans : [EOL] finish_span ( _span ) [EOL] [comment] [EOL] self . _set_recovery_ended ( ) [EOL] [EOL] def _set_recovery_started ( self ) : [EOL] self . in_recovery = True [EOL] self . _recovery_ended = None [EOL] self . _recovery_started_at = monotonic ( ) [EOL] self . _active_events_received_at . clear ( ) [EOL] self . _standby_events_received_at . clear ( ) [EOL] self . _processing_times . clear ( ) [EOL] self . _last_active_event_processed_at = None [EOL] [EOL] def _set_recovery_ended ( self ) : [EOL] self . in_recovery = False [EOL] self . _recovery_ended_at = monotonic ( ) [EOL] self . _active_events_received_at . clear ( ) [EOL] self . _standby_events_received_at . clear ( ) [EOL] self . _processing_times . clear ( ) [EOL] self . _last_active_event_processed_at = None [EOL] [EOL] def active_remaining_seconds ( self , remaining ) : [EOL] s = self . _estimated_active_remaining_secs ( remaining ) [EOL] return humanize_seconds ( s , now = [string] ) if s else [string] [EOL] [EOL] def _estimated_active_remaining_secs ( self , remaining ) : [EOL] processing_times = self . _processing_times [EOL] if len ( processing_times ) >= self . num_samples_required_for_estimate : [EOL] mean_time = statistics . mean ( processing_times ) [EOL] return ( mean_time * remaining ) * [number] [comment] [EOL] else : [EOL] return None [EOL] [EOL] async def _wait ( self , coro ) : [EOL] wait_result = await self . wait_first ( coro , self . signal_recovery_reset , self . signal_recovery_start , ) [EOL] if wait_result . stopped : [EOL] [comment] [EOL] raise ServiceStopped ( ) [EOL] elif self . signal_recovery_start in wait_result . done : [EOL] [comment] [EOL] raise RebalanceAgain ( ) [EOL] elif self . signal_recovery_reset in wait_result . done : [EOL] raise RebalanceAgain ( ) [EOL] else : [EOL] return None [EOL] [EOL] async def on_recovery_completed ( self ) : [EOL] [docstring] [EOL] consumer = self . app . consumer [EOL] self . log . info ( [string] ) [EOL] await self . app . on_rebalance_complete . send ( ) [EOL] [comment] [EOL] callback_coros = [ table . on_recovery_completed ( self . actives_for_table [ table ] , self . standbys_for_table [ table ] , ) for table in self . tables . values ( ) ] [EOL] if callback_coros : [EOL] await asyncio . wait ( callback_coros ) [EOL] assignment = consumer . assignment ( ) [EOL] if assignment : [EOL] self . log . info ( [string] ) [EOL] await consumer . perform_seek ( ) [EOL] self . completed . set ( ) [EOL] self . log . dev ( [string] ) [EOL] consumer . resume_partitions ( { tp for tp in assignment if not self . _is_changelog_tp ( tp ) } ) [EOL] [comment] [EOL] await cast ( _App , self . app ) . _fetcher . maybe_start ( ) [EOL] self . tables . on_actives_ready ( ) [EOL] if not self . app . assignor . assigned_standbys ( ) : [EOL] self . tables . on_standbys_ready ( ) [EOL] self . app . on_rebalance_end ( ) [EOL] self . log . info ( [string] ) [EOL] [EOL] async def _build_highwaters ( self , consumer , tps , destination , title ) : [EOL] [comment] [EOL] highwaters = await consumer . highwaters ( * tps ) [EOL] highwaters = { tp : value - [number] if value is not None else - [number] for tp , value in highwaters . items ( ) } [EOL] self . log . info ( [string] , title , self . _highwater_logtable ( highwaters , title = title ) ) [EOL] destination . clear ( ) [EOL] destination . update ( highwaters ) [EOL] [EOL] def _highwater_logtable ( self , highwaters , * , title ) : [EOL] table_data = [ [ k . topic , str ( k . partition ) , str ( v ) ] for k , v in sorted ( highwaters . items ( ) ) ] [EOL] return terminal . logtable ( list ( self . _consolidate_table_keys ( table_data ) ) , title = f' [string] { title . capitalize ( ) }' , headers = [ [string] , [string] , [string] ] , ) [EOL] [EOL] def _consolidate_table_keys ( self , data ) : [EOL] [docstring] [EOL] prev_key = None [EOL] for key , * rest in data : [EOL] if prev_key is not None and prev_key == key : [EOL] yield [ [string] , * rest ] [comment] [EOL] else : [EOL] yield [ key , * rest ] [EOL] prev_key = key [EOL] [EOL] async def _build_offsets ( self , consumer , tps , destination , title ) : [EOL] [comment] [EOL] [comment] [EOL] earliest = await consumer . earliest_offsets ( * tps ) [EOL] [comment] [EOL] earliest = { tp : offset - [number] for tp , offset in earliest . items ( ) } [EOL] for tp in tps : [EOL] last_value = destination [ tp ] [EOL] new_value = earliest [ tp ] [EOL] [EOL] if last_value is None : [EOL] destination [ tp ] = new_value [EOL] elif new_value is None : [EOL] destination [ tp ] = last_value [EOL] else : [EOL] destination [ tp ] = max ( last_value , new_value ) [EOL] [EOL] if destination : [EOL] self . log . info ( [string] , title , self . _start_offsets_logtable ( destination , title = title ) , ) [EOL] [EOL] def _start_offsets_logtable ( self , offsets , * , title ) : [EOL] table_data = [ [ k . topic , str ( k . partition ) , str ( v ) ] for k , v in sorted ( offsets . items ( ) ) ] [EOL] return terminal . logtable ( list ( self . _consolidate_table_keys ( table_data ) ) , title = f' [string] { title . capitalize ( ) }' , headers = [ [string] , [string] , [string] ] , ) [EOL] [EOL] async def _seek_offsets ( self , consumer , tps , offsets , title ) : [EOL] [comment] [EOL] new_offsets = { } [EOL] for tp in tps : [EOL] offset = offsets [ tp ] [EOL] if offset == - [number] : [EOL] offset = [number] [EOL] new_offsets [ tp ] = offset [EOL] [comment] [EOL] await consumer . seek_wait ( new_offsets ) [EOL] [EOL] @ Service . task async def _slurp_changelogs ( self ) : [EOL] changelog_queue = self . tables . changelog_queue [EOL] tp_to_table = self . tp_to_table [EOL] [EOL] active_tps = self . active_tps [EOL] standby_tps = self . standby_tps [EOL] active_offsets = self . active_offsets [EOL] standby_offsets = self . standby_offsets [EOL] active_events_received_at = self . _active_events_received_at [EOL] standby_events_received_at = self . _standby_events_received_at [EOL] [EOL] buffers = self . buffers [EOL] buffer_sizes = self . buffer_sizes [EOL] processing_times = self . _processing_times [EOL] [EOL] def _maybe_signal_recovery_end ( ) : [EOL] if self . in_recovery and not self . active_remaining_total ( ) : [EOL] [comment] [EOL] self . flush_buffers ( ) [EOL] self . _set_recovery_ended ( ) [EOL] if self . _actives_span is not None : [EOL] self . _actives_span . set_tag ( [string] , True ) [EOL] self . signal_recovery_end . set ( ) [EOL] [EOL] while not self . should_stop : [EOL] try : [EOL] event = await asyncio . wait_for ( changelog_queue . get ( ) , timeout = [number] ) [EOL] except asyncio . TimeoutError : [EOL] if self . should_stop : [EOL] return [EOL] _maybe_signal_recovery_end ( ) [EOL] continue [EOL] [EOL] now = monotonic ( ) [EOL] message = event . message [EOL] tp = message . tp [EOL] offset = message . offset [EOL] [EOL] offsets = ... [EOL] bufsize = buffer_sizes . get ( tp ) [EOL] is_active = False [EOL] if tp in active_tps : [EOL] is_active = True [EOL] table = tp_to_table [ tp ] [EOL] offsets = active_offsets [EOL] if bufsize is None : [EOL] bufsize = buffer_sizes [ tp ] = table . recovery_buffer_size [EOL] active_events_received_at [ tp ] = now [EOL] elif tp in standby_tps : [EOL] table = tp_to_table [ tp ] [EOL] offsets = standby_offsets [EOL] if bufsize is None : [EOL] bufsize = buffer_sizes [ tp ] = table . standby_buffer_size [EOL] standby_events_received_at [ tp ] = now [EOL] else : [EOL] continue [EOL] [EOL] seen_offset = offsets . get ( tp , None ) [EOL] if seen_offset is None or offset > seen_offset : [EOL] offsets [ tp ] = offset [EOL] buf = buffers [ table ] [EOL] buf . append ( event ) [EOL] await table . on_changelog_event ( event ) [EOL] if len ( buf ) >= bufsize : [EOL] table . apply_changelog_batch ( buf ) [EOL] buf . clear ( ) [EOL] self . _last_flush_at = now [EOL] now_after = monotonic ( ) [EOL] [EOL] if is_active : [EOL] last_processed_at = self . _last_active_event_processed_at [EOL] if last_processed_at is not None : [EOL] processing_times . append ( now_after - last_processed_at ) [EOL] max_samples = self . num_samples_required_for_estimate [EOL] if len ( processing_times ) > max_samples : [EOL] processing_times . popleft ( ) [EOL] self . _last_active_event_processed_at = now_after [EOL] [EOL] _maybe_signal_recovery_end ( ) [EOL] [EOL] if self . standbys_pending and not self . standby_remaining_total ( ) : [EOL] if self . _standbys_span : [EOL] finish_span ( self . _standbys_span ) [EOL] self . _standbys_span = None [EOL] self . tables . on_standbys_ready ( ) [EOL] [EOL] def flush_buffers ( self ) : [EOL] [docstring] [EOL] for table , buffer in self . buffers . items ( ) : [EOL] table . apply_changelog_batch ( buffer ) [EOL] buffer . clear ( ) [EOL] self . _last_flush_at = monotonic ( ) [EOL] [EOL] def need_recovery ( self ) : [EOL] [docstring] [EOL] return any ( v for v in self . active_remaining ( ) . values ( ) ) [EOL] [EOL] def active_remaining ( self ) : [EOL] [docstring] [EOL] highwaters = self . active_highwaters [EOL] offsets = self . active_offsets [EOL] return Counter ( { tp : highwater - offsets [ tp ] for tp , highwater in highwaters . items ( ) if highwater is not None and offsets [ tp ] is not None } ) [EOL] [EOL] def standby_remaining ( self ) : [EOL] [docstring] [EOL] highwaters = self . standby_highwaters [EOL] offsets = self . standby_offsets [EOL] return Counter ( { tp : highwater - offsets [ tp ] for tp , highwater in highwaters . items ( ) if highwater >= [number] and offsets [ tp ] >= [number] } ) [EOL] [EOL] def active_remaining_total ( self ) : [EOL] [docstring] [EOL] return sum ( self . active_remaining ( ) . values ( ) ) [EOL] [EOL] def standby_remaining_total ( self ) : [EOL] [docstring] [EOL] return sum ( self . standby_remaining ( ) . values ( ) ) [EOL] [EOL] def active_stats ( self ) : [EOL] [docstring] [EOL] offsets = self . active_offsets [EOL] return { tp : RecoveryStats ( highwater , offsets [ tp ] , highwater - offsets [ tp ] ) for tp , highwater in self . active_highwaters . items ( ) if offsets [ tp ] is not None and highwater - offsets [ tp ] != [number] } [EOL] [EOL] def standby_stats ( self ) : [EOL] [docstring] [EOL] offsets = self . standby_offsets [EOL] return { tp : RecoveryStats ( highwater , offsets [ tp ] , highwater - offsets [ tp ] ) for tp , highwater in self . standby_highwaters . items ( ) if offsets [ tp ] is not None and highwater - offsets [ tp ] != [number] } [EOL] [EOL] def _stats_to_logtable ( self , title , stats ) : [EOL] table_data = [ list ( map ( str , [ tp . topic , tp . partition , s . highwater , s . offset , s . remaining , ] ) ) for tp , s in sorted ( stats . items ( ) ) ] [EOL] return terminal . logtable ( list ( self . _consolidate_table_keys ( table_data ) ) , title = title , headers = [ [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] [EOL] @ Service . task async def _publish_stats ( self ) : [EOL] [docstring] [EOL] interval = self . stats_interval [EOL] await self . sleep ( interval ) [EOL] async for sleep_time in self . itertimer ( interval , name = [string] ) : [EOL] if self . in_recovery : [EOL] now = monotonic ( ) [EOL] stats = self . active_stats ( ) [EOL] num_samples = len ( self . _processing_times ) [EOL] if stats and num_samples >= self . num_samples_required_for_estimate : [EOL] remaining_total = self . active_remaining_total ( ) [EOL] self . log . info ( [string] [string] [string] , self . active_remaining_seconds ( remaining_total ) , remaining_total , self . _stats_to_logtable ( [string] , stats ) , ) [EOL] elif stats : [EOL] await self . _verify_remaining ( now , stats ) [EOL] else : [EOL] recovery_started_at = self . _recovery_started_at [EOL] if recovery_started_at is None : [EOL] self . log . error ( [string] [string] [string] ) [EOL] else : [EOL] secs_since_started = now - recovery_started_at [EOL] if secs_since_started >= [number] : [EOL] [comment] [EOL] [comment] [EOL] self . log . error ( [string] [string] [string] [string] , humanize_seconds ( secs_since_started ) , ) [EOL] [EOL] async def _verify_remaining ( self , now , stats ) : [EOL] consumer = self . app . consumer [EOL] active_events_received_at = self . _active_events_received_at [EOL] recovery_started_at = self . _recovery_started_at [EOL] if recovery_started_at is None : [EOL] return [comment] [EOL] secs_since_started = now - recovery_started_at [EOL] [EOL] last_flush_at = self . _last_flush_at [EOL] if last_flush_at is None : [EOL] if secs_since_started >= self . flush_timeout_secs : [EOL] self . log . warning ( [string] [string] [string] , humanize_seconds_ago ( secs_since_started ) , self . _current_total_buffer_size ( ) , ) [EOL] else : [EOL] secs_since_last_flush = now - last_flush_at [EOL] if secs_since_last_flush >= self . flush_timeout_secs : [EOL] self . log . warning ( [string] [string] [string] , self . flush_timeout_secs , humanize_seconds_ago ( secs_since_last_flush ) , self . _current_total_buffer_size ( ) , ) [EOL] [EOL] for tp in stats : [EOL] await self . sleep ( [number] ) [EOL] if self . should_stop : [EOL] break [EOL] if not self . in_recovery : [EOL] break [EOL] consumer . verify_recovery_event_path ( now , tp ) [EOL] secs_since_started = now - recovery_started_at [EOL] [EOL] last_event_received = active_events_received_at . get ( tp ) [EOL] if last_event_received is None : [EOL] if secs_since_started >= self . event_timeout_secs : [EOL] self . log . warning ( [string] [string] , tp , humanize_seconds_ago ( secs_since_started ) , ) [EOL] continue [EOL] [EOL] secs_since_received = now - last_event_received [EOL] if secs_since_received >= self . event_timeout_secs : [EOL] self . log . warning ( [string] [string] , tp , self . event_timeout_secs , humanize_seconds_ago ( secs_since_received ) , ) [EOL] [EOL] def _current_total_buffer_size ( self ) : [EOL] return sum ( len ( buf ) for buf in self . buffers . values ( ) ) [EOL] [EOL] def _is_changelog_tp ( self , tp ) : [EOL] return tp . topic in self . tables . changelog_topics [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 0 0 0 $_TableManager$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.TP]$ 0 0 0 0 0 0 $typing.Set[faust.types.TP]$ 0 0 0 0 $typing.MutableMapping[faust.types.tables.CollectionT,typing.Set[faust.types.TP]]$ 0 0 0 $typing.MutableMapping[faust.types.tables.CollectionT,typing.Set[faust.types.TP]]$ 0 0 0 0 0 0 $typing.MutableMapping[faust.types.TP,faust.types.tables.CollectionT]$ 0 0 0 0 0 0 $mode.utils.typing.Counter[faust.types.TP]$ 0 0 0 0 0 0 $mode.utils.typing.Counter[faust.types.TP]$ 0 0 0 0 0 0 $mode.utils.typing.Counter[faust.types.TP]$ 0 0 0 0 0 0 $mode.utils.typing.Counter[faust.types.TP]$ 0 0 0 0 0 0 $mode.utils.typing.Counter[faust.types.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mode.utils.locks.Event$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[faust.types.tables.CollectionT,typing.List[faust.types.EventT]]$ 0 0 0 0 0 0 $typing.MutableMapping[faust.types.TP,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[faust.types.TP,builtins.float]$ 0 0 0 0 0 0 $typing.MutableMapping[faust.types.TP,builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mode.utils.typing.Deque[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ConsumerT$ 0 $typing.Set[faust.types.TP]$ 0 $mode.utils.typing.Counter[faust.types.TP]$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[faust.types.TP]$ 0 0 $builtins.int$ 0 $mode.utils.typing.Counter[faust.types.TP]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 $faust.types.transports.ConsumerT$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $faust.types.EventT$ 0 0 0 $typing.Any$ 0 0 0 $faust.types.EventT$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Optional[builtins.float]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mode.utils.typing.Counter[faust.types.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mode.utils.typing.Counter[faust.types.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RecoveryStatsMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RecoveryStatsMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $RecoveryStatsMapping$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RecoveryStatsMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Optional[builtins.float]$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 $RecoveryStatsMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Optional[builtins.float]$ 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Optional[builtins.float]$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RecoveryStatsMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Optional[builtins.float]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $faust.types.TP$ 0 0 0 0 $faust.types.TP$ 0 0 0 0 0 0 0 0 0
from typing import Iterator , Iterable , Optional , Set , Callable , Any , Union , List , Mapping [EOL] import typing [EOL] import yarl [EOL] import faust [EOL] import datetime [EOL] import builtins [EOL] import mode [EOL] [docstring] [EOL] import abc [EOL] import time [EOL] [EOL] from contextlib import suppress [EOL] from collections import defaultdict [EOL] from functools import lru_cache [EOL] from datetime import datetime [EOL] from heapq import heappop , heappush [EOL] from typing import ( Any , Callable , Iterable , Iterator , List , Mapping , MutableMapping , MutableSet , Optional , Set , Tuple , Union , cast , no_type_check , ) [EOL] [EOL] from mode . utils . futures import maybe_async [EOL] from mode import Seconds , Service [EOL] from yarl import URL [EOL] [EOL] from faust import stores [EOL] from faust import joins [EOL] from faust . exceptions import PartitionsMismatch [EOL] from faust . streams import current_event [EOL] from faust . types import ( AppT , CodecArg , EventT , FieldDescriptorT , FutureMessage , JoinT , RecordMetadata , SchemaT , TP , TopicT , ) [EOL] from faust . types . models import ModelArg , ModelT [EOL] from faust . types . stores import StoreT [EOL] from faust . types . streams import JoinableT , StreamT [EOL] from faust . types . tables import ( ChangelogEventCallback , CollectionT , RecoverCallback , RelativeHandler , WindowCloseCallback , ) [EOL] from faust . types . windows import WindowRange , WindowT [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] TABLE_CLEANING = [string] [EOL] [EOL] E_SOURCE_PARTITIONS_MISMATCH = [string] [EOL] [EOL] [EOL] class Collection ( Service , CollectionT ) : [EOL] [docstring] [EOL] [EOL] _store = ... [EOL] _changelog_topic = ... [EOL] _partition_timestamp_keys = ... [EOL] _partition_timestamps = ... [EOL] _partition_latest_timestamp = ... [EOL] _recover_callbacks = ... [EOL] _data = None [EOL] _changelog_compacting = True [EOL] _changelog_deleting = None [EOL] [EOL] @ abc . abstractmethod def _has_key ( self , key ) : [comment] [EOL] ... [EOL] [EOL] @ abc . abstractmethod def _get_key ( self , key ) : [comment] [EOL] ... [EOL] [EOL] @ abc . abstractmethod def _set_key ( self , key , value ) : [comment] [EOL] ... [EOL] [EOL] @ abc . abstractmethod def _del_key ( self , key ) : [comment] [EOL] ... [EOL] [EOL] def __init__ ( self , app , * , name = None , default = None , store = None , schema = None , key_type = None , value_type = None , partitions = None , window = None , changelog_topic = None , help = None , on_recover = None , on_changelog_event = None , recovery_buffer_size = [number] , standby_buffer_size = None , extra_topic_configs = None , recover_callbacks = None , options = None , use_partitioner = False , on_window_close = None , is_global = False , ** kwargs ) : [EOL] Service . __init__ ( self , ** kwargs ) [EOL] self . app = app [EOL] self . name = cast ( str , name ) [comment] [EOL] self . default = default [EOL] self . _store = URL ( store ) if store else None [EOL] self . schema = schema [EOL] self . key_type = key_type [EOL] self . value_type = value_type [EOL] self . partitions = partitions [EOL] self . window = window [EOL] self . _changelog_topic = changelog_topic [EOL] self . extra_topic_configs = extra_topic_configs or { } [EOL] self . help = help or [string] [EOL] self . _on_changelog_event = on_changelog_event [EOL] self . recovery_buffer_size = recovery_buffer_size [EOL] self . standby_buffer_size = standby_buffer_size or recovery_buffer_size [EOL] self . use_partitioner = use_partitioner [EOL] self . _on_window_close = on_window_close [EOL] self . last_closed_window = [number] [EOL] self . is_global = is_global [EOL] assert self . recovery_buffer_size > [number] and self . standby_buffer_size > [number] [EOL] [EOL] self . options = options [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . key_serializer = self . _serializer_from_type ( self . key_type ) [EOL] self . value_serializer = self . _serializer_from_type ( self . value_type ) [EOL] [EOL] [comment] [EOL] self . _partition_timestamp_keys = defaultdict ( set ) [EOL] self . _partition_timestamps = defaultdict ( list ) [EOL] self . _partition_latest_timestamp = defaultdict ( int ) [EOL] [EOL] self . _recover_callbacks = set ( recover_callbacks or [ ] ) [EOL] if on_recover : [EOL] self . on_recover ( on_recover ) [EOL] [EOL] [comment] [EOL] self . _sensor_on_get = self . app . sensors . on_table_get [EOL] self . _sensor_on_set = self . app . sensors . on_table_set [EOL] self . _sensor_on_del = self . app . sensors . on_table_del [EOL] [EOL] def _serializer_from_type ( self , typ ) : [EOL] if typ is bytes : [EOL] return [string] [EOL] serializer = None [EOL] with suppress ( AttributeError ) : [EOL] serializer = typ . _options . serializer [comment] [EOL] return serializer or [string] [EOL] [EOL] def __hash__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] return object . __hash__ ( self ) [EOL] [EOL] def _new_store ( self ) : [EOL] return self . _new_store_by_url ( self . _store or self . app . conf . store ) [EOL] [EOL] def _new_store_by_url ( self , url ) : [EOL] return stores . by_url ( url ) ( url , self . app , self , table_name = self . name , key_type = self . key_type , key_serializer = self . key_serializer , value_serializer = self . value_serializer , value_type = self . value_type , loop = self . loop , options = self . options , ) [EOL] [EOL] @ property @ no_type_check def data ( self ) : [EOL] [docstring] [EOL] if self . _data is None : [EOL] self . _data = self . _new_store ( ) [EOL] return self . _data [EOL] [EOL] async def on_start ( self ) : [EOL] [docstring] [EOL] await self . add_runtime_dependency ( self . data ) [EOL] await self . changelog_topic . maybe_declare ( ) [EOL] [EOL] def on_recover ( self , fun ) : [EOL] [docstring] [EOL] assert fun not in self . _recover_callbacks [EOL] self . _recover_callbacks . add ( fun ) [EOL] return fun [EOL] [EOL] def info ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return { [string] : self . app , [string] : self . name , [string] : self . default , [string] : self . _store , [string] : self . schema , [string] : self . key_type , [string] : self . value_type , [string] : self . partitions , [string] : self . window , [string] : self . _changelog_topic , [string] : self . _recover_callbacks , [string] : self . _on_changelog_event , [string] : self . recovery_buffer_size , [string] : self . standby_buffer_size , [string] : self . extra_topic_configs , [string] : self . use_partitioner , } [EOL] [EOL] def persisted_offset ( self , tp ) : [EOL] [docstring] [EOL] return self . data . persisted_offset ( tp ) [EOL] [EOL] async def need_active_standby_for ( self , tp ) : [EOL] [docstring] [EOL] return await self . data . need_active_standby_for ( tp ) [EOL] [EOL] def reset_state ( self ) : [EOL] [docstring] [EOL] self . data . reset_state ( ) [EOL] [EOL] def send_changelog ( self , partition , key , value , key_serializer = None , value_serializer = None ) : [EOL] [docstring] [EOL] if key_serializer is None : [EOL] key_serializer = self . key_serializer [EOL] if value_serializer is None : [EOL] value_serializer = self . value_serializer [EOL] return self . changelog_topic . send_soon ( key = key , value = value , partition = partition , key_serializer = key_serializer , value_serializer = value_serializer , callback = self . _on_changelog_sent , eager_partitioning = True , ) [EOL] [EOL] def _send_changelog ( self , event , key , value , key_serializer = None , value_serializer = None ) : [EOL] [comment] [EOL] if event is None : [EOL] raise RuntimeError ( [string] ) [EOL] self . send_changelog ( event . message . partition , key , value , key_serializer , value_serializer ) [EOL] [EOL] def partition_for_key ( self , key ) : [EOL] [docstring] [EOL] if self . use_partitioner : [EOL] return None [EOL] else : [EOL] event = current_event ( ) [EOL] if event is None : [EOL] raise TypeError ( [string] ) [EOL] self . _verify_source_topic_partitions ( event . message . topic ) [EOL] return event . message . partition [EOL] [EOL] @ lru_cache ( ) def _verify_source_topic_partitions ( self , source_topic ) : [EOL] change_topic = self . changelog_topic_name [EOL] source_n = self . app . consumer . topic_partitions ( source_topic ) [EOL] if source_n is not None : [EOL] change_n = self . app . consumer . topic_partitions ( change_topic ) [EOL] if change_n is not None : [EOL] if source_n != change_n : [EOL] raise PartitionsMismatch ( E_SOURCE_PARTITIONS_MISMATCH . format ( source_topic = source_topic , table_name = self . name , source_n = source_n , change_topic = change_topic , change_n = change_n , ) , ) [EOL] [EOL] def _on_changelog_sent ( self , fut ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] res = fut . result ( ) [EOL] if self . app . in_transaction : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . app . tables . persist_offset_on_commit ( self . data , res . topic_partition , res . offset ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] self . data . set_persisted_offset ( res . topic_partition , res . offset ) [EOL] [EOL] @ Service . task @ Service . transitions_to ( TABLE_CLEANING ) async def _clean_data ( self ) : [EOL] interval = self . app . conf . table_cleanup_interval [EOL] if self . _should_expire_keys ( ) : [EOL] await self . sleep ( interval ) [EOL] async for sleep_time in self . itertimer ( interval , name = [string] ) : [EOL] await self . _del_old_keys ( ) [EOL] [EOL] async def _del_old_keys ( self ) : [EOL] window = cast ( WindowT , self . window ) [EOL] assert window [EOL] for partition , timestamps in self . _partition_timestamps . items ( ) : [EOL] while timestamps and window . stale ( timestamps [ [number] ] , self . _partition_latest_timestamp [ partition ] ) : [EOL] timestamp = heappop ( timestamps ) [EOL] keys_to_remove = self . _partition_timestamp_keys . pop ( ( partition , timestamp ) , None ) [EOL] if keys_to_remove : [EOL] for key in keys_to_remove : [EOL] value = self . data . pop ( key , None ) [EOL] if key [ [number] ] [ [number] ] > self . last_closed_window : [EOL] await self . on_window_close ( key , value ) [EOL] self . last_closed_window = max ( self . last_closed_window , max ( key [ [number] ] [ [number] ] for key in keys_to_remove ) , ) [EOL] [EOL] async def on_window_close ( self , key , value ) : [EOL] if self . _on_window_close : [EOL] await maybe_async ( self . _on_window_close ( key , value ) ) [EOL] [EOL] def _should_expire_keys ( self ) : [EOL] window = self . window [EOL] return not ( window is None or window . expires is None ) [EOL] [EOL] def _maybe_set_key_ttl ( self , key , partition ) : [EOL] if not self . _should_expire_keys ( ) : [EOL] return [EOL] _ , window_range = key [EOL] _ , range_end = window_range [EOL] heappush ( self . _partition_timestamps [ partition ] , range_end ) [EOL] self . _partition_latest_timestamp [ partition ] = max ( self . _partition_latest_timestamp [ partition ] , range_end ) [EOL] self . _partition_timestamp_keys [ ( partition , range_end ) ] . add ( key ) [EOL] [EOL] def _maybe_del_key_ttl ( self , key , partition ) : [EOL] if not self . _should_expire_keys ( ) : [EOL] return [EOL] _ , window_range = key [EOL] ts_keys = self . _partition_timestamp_keys . get ( ( partition , window_range [ [number] ] ) ) [EOL] if ts_keys is not None : [EOL] ts_keys . discard ( key ) [EOL] [EOL] def _changelog_topic_name ( self ) : [EOL] return f'{ self . app . conf . id } [string] { self . name } [string] ' [EOL] [EOL] def join ( self , * fields ) : [EOL] [docstring] [EOL] return self . _join ( joins . RightJoin ( stream = self , fields = fields ) ) [EOL] [EOL] def left_join ( self , * fields ) : [EOL] [docstring] [EOL] return self . _join ( joins . LeftJoin ( stream = self , fields = fields ) ) [EOL] [EOL] def inner_join ( self , * fields ) : [EOL] [docstring] [EOL] return self . _join ( joins . InnerJoin ( stream = self , fields = fields ) ) [EOL] [EOL] def outer_join ( self , * fields ) : [EOL] [docstring] [EOL] return self . _join ( joins . OuterJoin ( stream = self , fields = fields ) ) [EOL] [EOL] def _join ( self , join_strategy ) : [EOL] [comment] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def clone ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . __class__ ( ** { ** self . info ( ) , ** kwargs } ) [EOL] [EOL] def combine ( self , * nodes , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def contribute_to_stream ( self , active ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] ... [EOL] [EOL] async def remove_from_stream ( self , stream ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ... [EOL] [EOL] def _new_changelog_topic ( self , * , retention = None , compacting = None , deleting = None ) : [EOL] if compacting is None : [EOL] compacting = self . _changelog_compacting [EOL] if deleting is None : [EOL] deleting = self . _changelog_deleting [EOL] if retention is None and self . window : [EOL] retention = self . window . expires [EOL] return self . app . topic ( self . _changelog_topic_name ( ) , schema = self . schema , key_type = self . key_type , value_type = self . value_type , key_serializer = self . key_serializer , value_serializer = self . value_serializer , partitions = self . partitions , retention = retention , compacting = compacting , deleting = deleting , acks = False , internal = True , config = self . extra_topic_configs , maxsize = [number] , allow_empty = True , ) [EOL] [EOL] def __copy__ ( self ) : [EOL] return self . clone ( ) [EOL] [EOL] def __and__ ( self , other ) : [EOL] return self . combine ( self , other ) [EOL] [EOL] def _apply_window_op ( self , op , key , value , timestamp ) : [EOL] get_ = self . _get_key [EOL] set_ = self . _set_key [EOL] for window_range in self . _window_ranges ( timestamp ) : [EOL] set_ ( ( key , window_range ) , op ( get_ ( ( key , window_range ) ) , value ) ) [EOL] [EOL] def _set_windowed ( self , key , value , timestamp ) : [EOL] for window_range in self . _window_ranges ( timestamp ) : [EOL] self . _set_key ( ( key , window_range ) , value ) [EOL] [EOL] def _del_windowed ( self , key , timestamp ) : [EOL] for window_range in self . _window_ranges ( timestamp ) : [EOL] self . _del_key ( ( key , window_range ) ) [EOL] [EOL] def _window_ranges ( self , timestamp ) : [EOL] window = cast ( WindowT , self . window ) [EOL] for window_range in window . ranges ( timestamp ) : [EOL] yield window_range [EOL] [EOL] def _relative_now ( self , event = None ) : [EOL] [comment] [EOL] event = event if event is not None else current_event ( ) [EOL] if event is None : [EOL] return time . time ( ) [EOL] return self . _partition_latest_timestamp [ event . message . partition ] [EOL] [EOL] def _relative_event ( self , event = None ) : [EOL] event = event if event is not None else current_event ( ) [EOL] [comment] [EOL] if event is None : [EOL] raise RuntimeError ( [string] ) [EOL] return event . message . timestamp [EOL] [EOL] def _relative_field ( self , field ) : [EOL] def to_value ( event = None ) : [EOL] if event is None : [EOL] raise RuntimeError ( [string] ) [EOL] return field . getattr ( cast ( ModelT , event . value ) ) [EOL] [EOL] return to_value [EOL] [EOL] def _relative_timestamp ( self , timestamp ) : [EOL] def handler ( event = None ) : [EOL] return timestamp [EOL] [EOL] return handler [EOL] [EOL] def _windowed_now ( self , key ) : [EOL] window = cast ( WindowT , self . window ) [EOL] return self . _get_key ( ( key , window . earliest ( self . _relative_now ( ) ) ) ) [EOL] [EOL] def _windowed_timestamp ( self , key , timestamp ) : [EOL] window = cast ( WindowT , self . window ) [EOL] return self . _get_key ( ( key , window . current ( timestamp ) ) ) [EOL] [EOL] def _windowed_contains ( self , key , timestamp ) : [EOL] window = cast ( WindowT , self . window ) [EOL] return self . _has_key ( ( key , window . current ( timestamp ) ) ) [EOL] [EOL] def _windowed_delta ( self , key , d , event = None ) : [EOL] window = cast ( WindowT , self . window ) [EOL] return self . _get_key ( ( key , window . delta ( self . _relative_event ( event ) , d ) ) , ) [EOL] [EOL] async def on_rebalance ( self , assigned , revoked , newly_assigned ) : [EOL] [docstring] [EOL] await self . data . on_rebalance ( self , assigned , revoked , newly_assigned ) [EOL] [EOL] async def on_recovery_completed ( self , active_tps , standby_tps ) : [EOL] [docstring] [EOL] await self . data . on_recovery_completed ( active_tps , standby_tps ) [EOL] await self . call_recover_callbacks ( ) [EOL] [EOL] async def call_recover_callbacks ( self ) : [EOL] [docstring] [EOL] for fun in self . _recover_callbacks : [EOL] await fun ( ) [EOL] [EOL] async def on_changelog_event ( self , event ) : [EOL] [docstring] [EOL] if self . _on_changelog_event : [EOL] await self . _on_changelog_event ( event ) [EOL] [EOL] @ property def label ( self ) : [EOL] [docstring] [EOL] return f'{ self . shortlabel } [string] { self . _store }' [EOL] [EOL] @ property def shortlabel ( self ) : [EOL] [docstring] [EOL] return f'{ type ( self ) . __name__ } [string] { self . name }' [EOL] [EOL] @ property def changelog_topic ( self ) : [EOL] [docstring] [EOL] if self . _changelog_topic is None : [EOL] self . _changelog_topic = self . _new_changelog_topic ( ) [EOL] return self . _changelog_topic [EOL] [EOL] @ changelog_topic . setter def changelog_topic ( self , topic ) : [EOL] self . _changelog_topic = topic [EOL] [EOL] @ property def changelog_topic_name ( self ) : [EOL] return self . changelog_topic . get_topic_name ( ) [EOL] [EOL] def apply_changelog_batch ( self , batch ) : [EOL] [docstring] [EOL] self . data . apply_changelog_batch ( batch , to_key = self . _to_key , to_value = self . _to_value , ) [EOL] [EOL] def _to_key ( self , k ) : [EOL] if isinstance ( k , list ) : [EOL] [comment] [EOL] [comment] [EOL] return tuple ( tuple ( v ) if isinstance ( v , list ) else v for v in k ) [EOL] return k [EOL] [EOL] def _to_value ( self , v ) : [EOL] return v [EOL] [EOL] def _human_channel ( self ) : [EOL] return f'{ type ( self ) . __name__ } [string] { self . name }' [EOL] [EOL] def _repr_info ( self ) : [EOL] return self . name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[yarl.URL]$ 0 0 0 $typing.Optional[faust.types.TopicT]$ 0 0 0 $typing.MutableMapping[typing.Tuple[builtins.int,builtins.float],typing.MutableSet[typing.Tuple[typing.Any,faust.types.windows.WindowRange]]]$ 0 0 0 $typing.MutableMapping[builtins.int,typing.List[builtins.float]]$ 0 0 0 $typing.MutableMapping[builtins.int,builtins.float]$ 0 0 0 $typing.MutableSet[faust.types.tables.RecoverCallback]$ 0 0 0 $typing.Optional[faust.types.stores.StoreT]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,yarl.URL]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TopicT$ 0 0 0 0 0 0 0 $faust.types.tables.RecoverCallback$ 0 0 0 $faust.types.tables.ChangelogEventCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.tables.RecoverCallback]$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tables.WindowCloseCallback$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,yarl.URL]$ 0 0 $typing.Union[builtins.str,yarl.URL]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TopicT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tables.ChangelogEventCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tables.WindowCloseCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.tables.RecoverCallback]$ 0 0 0 0 0 0 $faust.types.tables.RecoverCallback$ 0 0 0 0 $faust.types.tables.RecoverCallback$ 0 $faust.types.tables.RecoverCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[faust.types.CodecArg]$ 0 0 0 $typing.Optional[faust.types.models.ModelArg]$ 0 0 0 0 $typing.Optional[faust.types.models.ModelArg]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[faust.types.models.ModelArg]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.stores.StoreT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.stores.StoreT$ 0 0 0 $typing.Union[builtins.str,yarl.URL]$ 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,yarl.URL]$ 0 0 $typing.Union[builtins.str,yarl.URL]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.stores.StoreT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tables.RecoverCallback$ 0 0 0 $faust.types.tables.RecoverCallback$ 0 0 0 0 0 0 $faust.types.tables.RecoverCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tables.RecoverCallback$ 0 0 0 $faust.types.tables.RecoverCallback$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $faust.types.TP$ 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $faust.types.TP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.FutureMessage$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[faust.types.EventT]$ 0 $typing.Any$ 0 $typing.Any$ 0 $faust.types.CodecArg$ 0 0 0 $faust.types.CodecArg$ 0 0 0 0 0 0 0 0 $typing.Optional[faust.types.EventT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[faust.types.EventT]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $faust.types.CodecArg$ 0 $faust.types.CodecArg$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.FutureMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.RecordMetadata$ 0 $faust.types.FutureMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.RecordMetadata$ 0 0 0 $faust.types.RecordMetadata$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.RecordMetadata$ 0 0 0 $faust.types.RecordMetadata$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.streams.StreamT$ 0 0 0 0 $faust.types.FieldDescriptorT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.FieldDescriptorT$ 0 $faust.types.FieldDescriptorT$ 0 0 0 0 0 $faust.types.streams.StreamT$ 0 0 0 0 $faust.types.FieldDescriptorT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.FieldDescriptorT$ 0 $faust.types.FieldDescriptorT$ 0 0 0 0 0 $faust.types.streams.StreamT$ 0 0 0 0 $faust.types.FieldDescriptorT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.FieldDescriptorT$ 0 $faust.types.FieldDescriptorT$ 0 0 0 0 0 $faust.types.streams.StreamT$ 0 0 0 0 $faust.types.FieldDescriptorT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.FieldDescriptorT$ 0 $faust.types.FieldDescriptorT$ 0 0 0 0 0 $faust.types.streams.StreamT$ 0 0 0 $faust.types.JoinT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $faust.types.streams.StreamT$ 0 0 0 0 $faust.types.streams.JoinableT$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.streams.StreamT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.streams.StreamT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TopicT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $typing.Callable[[typing.Any,typing.Any],typing.Any]$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Callable[[typing.Any,typing.Any],typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Iterator[faust.types.windows.WindowRange]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tables.RelativeHandler$ 0 0 0 $faust.types.FieldDescriptorT$ 0 0 0 0 $typing.Union[builtins.float,datetime.datetime]$ 0 $faust.types.EventT$ 0 0 0 0 0 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tables.RelativeHandler$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Union[builtins.float,datetime.datetime]$ 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $mode.Seconds$ 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $faust.types.EventT$ 0 0 $mode.Seconds$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Set[faust.types.TP]$ 0 $typing.Set[faust.types.TP]$ 0 $typing.Set[faust.types.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.TP]$ 0 $typing.Set[faust.types.TP]$ 0 $typing.Set[faust.types.TP]$ 0 0 0 0 0 $None$ 0 0 0 $typing.Set[faust.types.TP]$ 0 $typing.Set[faust.types.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.TP]$ 0 $typing.Set[faust.types.TP]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.EventT$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.TopicT$ 0 0 0 0 0 0 0 $faust.types.TopicT$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[faust.types.EventT]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[faust.types.EventT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from faust . tables . table import Table [EOL] from faust . types . tables import GlobalTableT [EOL] [EOL] [EOL] class GlobalTable ( Table , GlobalTableT ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import platform [EOL] import subprocess [EOL] from typing import Optional [EOL] [EOL] [EOL] def max_open_files ( ) : [EOL] [docstring] [EOL] try : [EOL] from resource import RLIM_INFINITY , RLIMIT_NOFILE , getrlimit [EOL] except ImportError : [EOL] return None [EOL] else : [EOL] _ , hard_limit = getrlimit ( RLIMIT_NOFILE ) [EOL] if hard_limit == RLIM_INFINITY : [EOL] [comment] [EOL] [comment] [EOL] if platform . system ( ) == [string] : [EOL] output = subprocess . check_output ( [ [string] , [string] , [string] , ] ) [EOL] [comment] [EOL] [comment] [EOL] _ , _ , svalue = output . decode ( ) . partition ( [string] ) [EOL] return int ( svalue . strip ( ) ) [EOL] return None [EOL] return hard_limit [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from uuid import uuid4 [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] def uuid ( ) : [EOL] [docstring] [EOL] return str ( uuid4 ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Callable , Any , Dict , List , Mapping [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Any , Callable , Dict , List , Mapping , Tuple , cast [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] MISSING = object ( ) [EOL] [EOL] [EOL] def Function ( name , args , body , * , globals = None , locals = None , return_type = MISSING , argsep = [string] ) : [EOL] [docstring] [EOL] return build_function ( name = name , source = build_function_source ( name = name , args = args , body = body , return_type = return_type , argsep = argsep , ) , return_type = return_type , globals = globals , locals = locals , ) [EOL] [EOL] [EOL] def build_closure_source ( name , args , body , * , outer_name = [string] , outer_args = None , closures , return_type = MISSING , indentlevel = [number] , indentspaces = [number] , argsep = [string] ) : [EOL] inner_source = build_function_source ( name , args , body , return_type = return_type , indentlevel = indentlevel , indentspaces = indentspaces , argsep = argsep , ) [EOL] closure_vars = [ f'{ local_name } [string] { global_name }' for local_name , global_name in closures . items ( ) ] [EOL] outer_source = build_function_source ( name = outer_name , args = outer_args or [ ] , body = closure_vars + inner_source . split ( [string] ) + [ f' [string] { name }' ] , return_type = MISSING , indentlevel = indentlevel , indentspaces = indentspaces , argsep = argsep , ) [EOL] return outer_source [EOL] [EOL] [EOL] def build_closure ( outer_name , source , * args , return_type = MISSING , globals = None , locals = None ) : [EOL] assert locals is not None [EOL] if return_type is not MISSING : [EOL] locals [ [string] ] = return_type [EOL] exec ( source , globals , locals ) [EOL] obj = locals [ outer_name ] ( * args ) [EOL] obj . __sourcecode__ = source [EOL] return cast ( Callable , obj ) [EOL] [EOL] [EOL] def build_function ( name , source , * , return_type = MISSING , globals = None , locals = None ) : [EOL] [docstring] [EOL] assert locals is not None [EOL] if return_type is not MISSING : [EOL] locals [ [string] ] = return_type [EOL] exec ( source , globals , locals ) [EOL] obj = locals [ name ] [EOL] obj . __sourcecode__ = source [EOL] return cast ( Callable , obj ) [EOL] [EOL] [EOL] def build_function_source ( name , args , body , * , return_type = MISSING , indentlevel = [number] , indentspaces = [number] , argsep = [string] ) : [EOL] [docstring] [EOL] indent = [string] * indentspaces [EOL] curindent = indent * indentlevel [EOL] nextindent = indent * ( indentlevel + [number] ) [EOL] return_annotation = [string] [EOL] if return_type is not MISSING : [EOL] return_annotation = [string] [EOL] bodys = [string] . join ( f'{ nextindent }{ b }' for b in body ) [EOL] return ( f'{ curindent } [string] { name } [string] { argsep . join ( args ) } [string] { return_annotation } [string] ' f'{ bodys }' ) [EOL] [EOL] [EOL] def Method ( name , args , body , ** kwargs ) : [EOL] [docstring] [EOL] return Function ( name , [ [string] ] + args , body , ** kwargs ) [EOL] [EOL] [EOL] def InitMethod ( args , body , ** kwargs ) : [EOL] [docstring] [EOL] return Method ( [string] , args , body , return_type = [string] , ** kwargs ) [EOL] [EOL] [EOL] def HashMethod ( attrs , ** kwargs ) : [EOL] [docstring] [EOL] self_tuple = obj_attrs_tuple ( [string] , attrs ) [EOL] return Method ( [string] , [ ] , [ f' [string] { self_tuple } [string] ' ] , ** kwargs ) [EOL] [EOL] [EOL] def EqMethod ( fields , ** kwargs ) : [EOL] [docstring] [EOL] return CompareMethod ( name = [string] , op = [string] , fields = fields , ** kwargs ) [EOL] [EOL] [EOL] def NeMethod ( fields , ** kwargs ) : [EOL] [docstring] [EOL] return CompareMethod ( name = [string] , op = [string] , fields = fields , ** kwargs ) [EOL] [EOL] [EOL] def GeMethod ( fields , ** kwargs ) : [EOL] [docstring] [EOL] return CompareMethod ( name = [string] , op = [string] , fields = fields , ** kwargs ) [EOL] [EOL] [EOL] def GtMethod ( fields , ** kwargs ) : [EOL] [docstring] [EOL] return CompareMethod ( name = [string] , op = [string] , fields = fields , ** kwargs ) [EOL] [EOL] [EOL] def LeMethod ( fields , ** kwargs ) : [EOL] [docstring] [EOL] return CompareMethod ( name = [string] , op = [string] , fields = fields , ** kwargs ) [EOL] [EOL] [EOL] def LtMethod ( fields , ** kwargs ) : [EOL] [docstring] [EOL] return CompareMethod ( name = [string] , op = [string] , fields = fields , ** kwargs ) [EOL] [EOL] [EOL] def CompareMethod ( name , op , fields , ** kwargs ) : [EOL] [docstring] [EOL] self_tuple = obj_attrs_tuple ( [string] , fields ) [EOL] other_tuple = obj_attrs_tuple ( [string] , fields ) [EOL] return Method ( name , [ [string] ] , [ [string] , f' [string] { self_tuple }{ op }{ other_tuple }' , [string] ] , ** kwargs ) [EOL] [EOL] [EOL] def obj_attrs_tuple ( obj_name , attrs ) : [EOL] [docstring] [EOL] if not attrs : [EOL] return [string] [EOL] return f' [string] { [string] . join ( [ f"{ obj_name } [string] { f }" for f in attrs ] ) } [string] ' [EOL] [EOL] [EOL] def reprkwargs ( kwargs , * , sep = [string] , fmt = [string] ) : [EOL] return sep . join ( fmt . format ( k , repr ( v ) ) for k , v in kwargs . items ( ) ) [EOL] [EOL] [EOL] def reprcall ( name , args = ( ) , kwargs = { } , * , sep = [string] ) : [EOL] return [string] . format ( name , sep . join ( map ( repr , args or ( ) ) ) , ( args and kwargs ) and sep or [string] , reprkwargs ( kwargs , sep = sep ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] try : [comment] [EOL] import ciso8601 [EOL] except ImportError : [comment] [EOL] from . _iso8601_python import parse [EOL] else : [EOL] parse = ciso8601 . parse_datetime [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Union , Any [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] [docstring] [EOL] from datetime import datetime , tzinfo [EOL] import time [EOL] from croniter . croniter import croniter [EOL] [EOL] [EOL] def secs_for_next ( cron_format , tz = None ) : [EOL] [docstring] [EOL] now_ts = time . time ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] now = tz and datetime . now ( tz ) or now_ts [EOL] cron_it = croniter ( cron_format , start_time = now ) [EOL] return cron_it . get_next ( float ) - now_ts [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import IO , Callable , Any , Sequence , Type , List , Mapping [EOL] import typing [EOL] import terminaltables [EOL] import builtins [EOL] [docstring] [EOL] import sys [EOL] [EOL] from operator import itemgetter [EOL] from typing import ( Any , Callable , IO , Iterable , List , Mapping , Sequence , Type , cast , ) [EOL] [EOL] from mode . utils import logging [EOL] from mode . utils import text [EOL] from mode . utils . compat import isatty [EOL] [EOL] from terminaltables import AsciiTable , SingleTable [EOL] from terminaltables . base_table import BaseTable as Table [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] TableDataT = Sequence [ Sequence [ str ] ] [EOL] [EOL] [EOL] def table ( data , * , title , target = None , tty = None , ** kwargs ) : [EOL] [docstring] [EOL] if target is None : [EOL] target = sys . stdout [EOL] if tty is None : [EOL] tty = isatty ( target ) [EOL] if tty is None : [EOL] tty = False [EOL] return _get_best_table_type ( tty ) ( data , title = title , ** kwargs ) [EOL] [EOL] [EOL] def logtable ( data , * , title , target = None , tty = None , headers = None , ** kwargs ) : [EOL] [docstring] [EOL] if tty is None : [EOL] tty = logging . LOG_ISATTY [EOL] if headers : [EOL] data = [ headers ] + list ( data ) [EOL] return table ( data , title = title , target = target , tty = tty , ** kwargs ) . table [EOL] [EOL] [EOL] def _get_best_table_type ( tty ) : [EOL] return SingleTable if tty else AsciiTable [EOL] [EOL] [EOL] def dict_as_ansitable ( d , * , key = [string] , value = [string] , sort = False , sortkey = itemgetter ( [number] ) , target = sys . stdout , title = None ) : [EOL] header = [ text . title ( key ) , text . title ( value ) ] [EOL] data = cast ( Iterable [ List [ str ] ] , d . items ( ) ) [EOL] data = sorted ( data , key = sortkey ) if sort else list ( data ) [EOL] if sort : [EOL] data = sorted ( data , key = sortkey ) [EOL] return table ( [ header ] + list ( data ) , title = text . title ( title ) if title is not None else [string] , target = target , ) . table [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $terminaltables.base_table.BaseTable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[terminaltables.base_table.BaseTable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import IO , Any , List , Sequence [EOL] import typing [EOL] import logging [EOL] import faust [EOL] import builtins [EOL] [docstring] [EOL] import atexit [EOL] import logging [EOL] import random [EOL] import sys [EOL] [EOL] from typing import Any , IO , Sequence [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] SPINNER_ARC = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] SPINNER_ARROW = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] SPINNER_CIRCLE = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] SPINNER_SQUARE = [ [string] , [string] , [string] , [string] , ] [EOL] SPINNER_MOON = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] SPINNERS = [ SPINNER_ARC , SPINNER_ARROW , SPINNER_CIRCLE , SPINNER_SQUARE , SPINNER_MOON , ] [EOL] [EOL] ACTIVE_SPINNER = random . choice ( SPINNERS ) [EOL] [EOL] [EOL] class Spinner : [EOL] [docstring] [EOL] [EOL] bell = [string] [EOL] sprites = ACTIVE_SPINNER [EOL] cursor_hide = [string] [EOL] cursor_show = [string] [EOL] hide_cursor = True [EOL] stopped = False [EOL] [EOL] def __init__ ( self , file = sys . stderr ) : [EOL] self . file = file [EOL] self . width = [number] [EOL] self . count = [number] [EOL] self . stopped = False [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if not self . stopped : [EOL] if not self . count : [EOL] self . begin ( ) [EOL] i = self . count % len ( self . sprites ) [EOL] self . count += [number] [EOL] self . write ( self . sprites [ i ] ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] self . stopped = True [EOL] [EOL] def reset ( self ) : [EOL] [docstring] [EOL] self . stopped = False [EOL] self . count = [number] [EOL] [EOL] def write ( self , s ) : [EOL] [docstring] [EOL] if self . file . isatty ( ) : [EOL] self . _print ( f'{ self . bell * self . width }{ s . ljust ( self . width ) }' ) [EOL] self . width = max ( self . width , len ( s ) ) [EOL] [EOL] def _print ( self , s ) : [EOL] print ( s , end = [string] , file = self . file ) [EOL] self . file . flush ( ) [EOL] [EOL] def begin ( self ) : [EOL] [docstring] [EOL] atexit . register ( type ( self ) . _finish , self . file , at_exit = True ) [EOL] self . _print ( self . cursor_hide ) [EOL] [EOL] def finish ( self ) : [EOL] [docstring] [EOL] print ( f'{ self . bell * ( self . width + [number] ) }' , end = [string] , file = self . file ) [EOL] self . _finish ( self . file ) [EOL] self . stop ( ) [EOL] [EOL] @ classmethod def _finish ( cls , file , * , at_exit = False ) : [EOL] print ( cls . cursor_show , end = [string] , file = file ) [EOL] file . flush ( ) [EOL] [EOL] [EOL] class SpinnerHandler ( logging . Handler ) : [EOL] [docstring] [EOL] [EOL] spinner = ... [EOL] [EOL] [comment] [EOL] [EOL] def __init__ ( self , spinner , ** kwargs ) : [EOL] self . spinner = spinner [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] [EOL] def emit ( self , _record ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . spinner and not self . spinner . stopped : [EOL] self . spinner . update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Sequence[builtins.str]]$ 0 0 $typing.Sequence[builtins.str]$ 0 $typing.Sequence[builtins.str]$ 0 $typing.Sequence[builtins.str]$ 0 $typing.Sequence[builtins.str]$ 0 $typing.Sequence[builtins.str]$ 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 $typing.Sequence[typing.Sequence[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Sequence[builtins.str]$ 0 $typing.Sequence[builtins.str]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $typing.IO$ 0 0 0 0 0 0 0 0 0 $typing.IO$ 0 $typing.IO$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.IO$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO$ 0 $typing.IO$ 0 0 $typing.IO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Spinner$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.utils.terminal.spinners.Spinner$ 0 0 $typing.Any$ 0 0 0 0 0 $faust.utils.terminal.spinners.Spinner$ 0 $faust.utils.terminal.spinners.Spinner$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Union , Type , List [EOL] import faust [EOL] import typing [EOL] [docstring] [EOL] from kafka . protocol import types [EOL] from . api import Request , Response [EOL] [EOL] [EOL] class CreateTopicsResponse_v0 ( Response ) : [EOL] [docstring] [EOL] [EOL] API_KEY = [number] [EOL] API_VERSION = [number] [EOL] SCHEMA = types . Schema ( ( [string] , types . Array ( ( [string] , types . String ( [string] ) ) , ( [string] , types . Int16 ) ) ) , ) [EOL] [EOL] [EOL] class CreateTopicsResponse_v1 ( Response ) : [EOL] [docstring] [EOL] [EOL] API_KEY = [number] [EOL] API_VERSION = [number] [EOL] SCHEMA = types . Schema ( ( [string] , types . Array ( ( [string] , types . String ( [string] ) ) , ( [string] , types . Int16 ) , ( [string] , types . String ( [string] ) ) ) ) , ) [EOL] [EOL] [EOL] class CreateTopicsRequest_v0 ( Request ) : [EOL] [docstring] [EOL] [EOL] API_KEY = [number] [EOL] API_VERSION = [number] [EOL] RESPONSE_TYPE = CreateTopicsResponse_v0 [EOL] SCHEMA = types . Schema ( ( [string] , types . Array ( ( [string] , types . String ( [string] ) ) , ( [string] , types . Int32 ) , ( [string] , types . Int16 ) , ( [string] , types . Array ( ( [string] , types . Int32 ) , ( [string] , types . Array ( types . Int32 ) ) ) ) , ( [string] , types . Array ( ( [string] , types . String ( [string] ) ) , ( [string] , types . String ( [string] ) ) ) ) ) ) , ( [string] , types . Int32 ) , ) [EOL] [EOL] [EOL] class CreateTopicsRequest_v1 ( Request ) : [EOL] [docstring] [EOL] [EOL] API_KEY = [number] [EOL] API_VERSION = [number] [EOL] RESPONSE_TYPE = CreateTopicsResponse_v1 [EOL] SCHEMA = types . Schema ( ( [string] , types . Array ( ( [string] , types . String ( [string] ) ) , ( [string] , types . Int32 ) , ( [string] , types . Int16 ) , ( [string] , types . Array ( ( [string] , types . Int32 ) , ( [string] , types . Array ( types . Int32 ) ) ) ) , ( [string] , types . Array ( ( [string] , types . String ( [string] ) ) , ( [string] , types . String ( [string] ) ) ) ) ) ) , ( [string] , types . Int32 ) , ( [string] , types . Boolean ) , ) [EOL] [EOL] [EOL] CreateTopicsRequest = [ CreateTopicsRequest_v0 , CreateTopicsRequest_v1 ] [EOL] CreateTopicsResponse = [ CreateTopicsResponse_v0 , CreateTopicsRequest_v1 ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Type[faust.utils.kafka.protocol.admin.CreateTopicsResponse_v0]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Type[faust.utils.kafka.protocol.admin.CreateTopicsResponse_v1]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Type[faust.utils.kafka.protocol.admin.CreateTopicsResponse_v0]$ 0 0 0 $typing.Type[faust.utils.kafka.protocol.admin.CreateTopicsRequest_v0]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Type[faust.utils.kafka.protocol.admin.CreateTopicsResponse_v1]$ 0 0 0 $typing.Type[faust.utils.kafka.protocol.admin.CreateTopicsRequest_v1]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type[typing.Union[faust.utils.kafka.protocol.admin.CreateTopicsRequest_v0,faust.utils.kafka.protocol.admin.CreateTopicsRequest_v1]]]$ 0 0 0 0 0 0 0 $typing.List[typing.Type[typing.Union[faust.utils.kafka.protocol.admin.CreateTopicsRequest_v1,faust.utils.kafka.protocol.admin.CreateTopicsResponse_v0]]]$ 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import kafka [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] import abc [EOL] from typing import Type [EOL] from kafka . protocol . struct import Struct [EOL] from kafka . protocol . types import Schema [EOL] [EOL] [EOL] class Response ( Struct , metaclass = abc . ABCMeta ) : [comment] [EOL] [docstring] [EOL] [EOL] @ property @ abc . abstractmethod def API_KEY ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property @ abc . abstractmethod def API_VERSION ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property @ abc . abstractmethod def SCHEMA ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class Request ( Struct , metaclass = abc . ABCMeta ) : [comment] [EOL] [docstring] [EOL] [EOL] @ property @ abc . abstractmethod def API_KEY ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property @ abc . abstractmethod def API_VERSION ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property @ abc . abstractmethod def SCHEMA ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property @ abc . abstractmethod def RESPONSE_TYPE ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def expect_response ( self ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $kafka.protocol.types.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $kafka.protocol.types.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Response]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any , Optional , List [EOL] import faust [EOL] import typing [EOL] import ssl [EOL] from enum import Enum [EOL] from typing import Optional , Union [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] class AuthProtocol ( Enum ) : [EOL] SSL = [string] [EOL] PLAINTEXT = [string] [EOL] SASL_PLAINTEXT = [string] [EOL] SASL_SSL = [string] [EOL] [EOL] [EOL] class SASLMechanism ( Enum ) : [EOL] PLAIN = [string] [EOL] GSSAPI = [string] [EOL] [EOL] [EOL] AUTH_PROTOCOLS_SSL = { AuthProtocol . SSL , AuthProtocol . SASL_SSL } [EOL] AUTH_PROTOCOLS_SASL = { AuthProtocol . SASL_PLAINTEXT , AuthProtocol . SASL_SSL } [EOL] [EOL] [EOL] class CredentialsT : [EOL] protocol = ... [EOL] [EOL] [EOL] CredentialsArg = Union [ CredentialsT , ssl . SSLContext ] [EOL] [EOL] [EOL] def to_credentials ( obj = None ) : [EOL] if obj is not None : [EOL] from faust . auth import SSLCredentials [comment] [EOL] if isinstance ( obj , ssl . SSLContext ) : [EOL] return SSLCredentials ( obj ) [EOL] if isinstance ( obj , CredentialsT ) : [EOL] return obj [EOL] from faust . exceptions import ImproperlyConfigured [EOL] raise ImproperlyConfigured ( f' [string] { type ( obj ) } [string] { obj }' ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Set[faust.types.auth.AuthProtocol]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.auth.AuthProtocol]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AuthProtocol$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[CredentialsT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Sequence [EOL] import typing [EOL] import builtins [EOL] import yarl [EOL] [docstring] [EOL] import os [EOL] from typing import Any , Sequence [EOL] from yarl import URL [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] PREFICES = [ [string] , [string] ] [EOL] [EOL] [EOL] def _getenv ( name , * default , prefices = PREFICES ) : [EOL] for prefix in prefices : [EOL] try : [EOL] return os . environ [ prefix + name ] [EOL] except KeyError : [EOL] pass [EOL] if default : [EOL] return default [ [number] ] [EOL] raise KeyError ( prefices [ [number] ] + name ) [EOL] [EOL] [EOL] [comment] [EOL] DEBUG = bool ( _getenv ( [string] , False ) ) [EOL] [EOL] [comment] [EOL] WORKDIR = _getenv ( [string] , None ) [EOL] [EOL] [comment] [EOL] DATADIR = _getenv ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] BLOCKING_TIMEOUT = float ( _getenv ( [string] , [string] ) ) [EOL] FORCE_BLOCKING_TIMEOUT = bool ( _getenv ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] CONSOLE_PORT = int ( _getenv ( [string] , [number] ) ) [EOL] [EOL] STRICT = bool ( _getenv ( [string] , False ) ) [EOL] [EOL] WEB_PORT = int ( _getenv ( [string] , [string] ) ) [EOL] WEB_BIND = _getenv ( [string] , [string] ) [EOL] WEB_TRANSPORT = URL ( _getenv ( [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $yarl.URL$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Callable , Any , Union , Type , List [EOL] import typing [EOL] import yarl [EOL] import faust [EOL] import pathlib [EOL] import builtins [EOL] import mode [EOL] import abc [EOL] import typing [EOL] from pathlib import Path [EOL] from typing import ( Any , Awaitable , Callable , Coroutine , NamedTuple , Optional , Sequence , Type , Union , ) [EOL] [EOL] from aiohttp . client import ClientSession as HttpClientT [EOL] from mode import Seconds , ServiceT [EOL] from mypy_extensions import Arg , KwArg , VarArg [EOL] from yarl import URL [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] from faust . types . app import AppT as _AppT [EOL] from faust . web . base import Request , Response , Web [EOL] from faust . web . views import View [EOL] else : [EOL] class _AppT : ... [comment] [EOL] class Request : ... [comment] [EOL] class Response : ... [comment] [EOL] class Web : ... [comment] [EOL] class View : ... [comment] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] ViewHandlerMethod = Callable [ [ Arg ( Request ) , VarArg ( Any ) , KwArg ( Any ) ] , Awaitable [ Response ] , ] [EOL] [EOL] ViewHandler2ArgsFun = Callable [ [ Arg ( View ) , Arg ( Request ) ] , Union [ Coroutine [ Any , Any , Response ] , Awaitable [ Response ] ] , ] [EOL] [EOL] ViewHandlerVarArgsFun = Callable [ [ Arg ( View ) , Arg ( Request ) , VarArg ( Any ) , KwArg ( Any ) ] , Union [ Coroutine [ Any , Any , Response ] , Awaitable [ Response ] ] , ] [EOL] [EOL] ViewHandlerFun = Union [ ViewHandler2ArgsFun , ViewHandlerVarArgsFun ] [EOL] [EOL] ViewGetHandler = ViewHandlerFun [comment] [EOL] ViewDecorator = Callable [ [ ViewHandlerFun ] , ViewHandlerFun ] [EOL] RoutedViewGetHandler = ViewDecorator [comment] [EOL] PageArg = Union [ Type [ View ] , ViewHandlerFun ] [EOL] RouteDecoratorRet = Callable [ [ PageArg ] , PageArg ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] CORSListOption = Union [ str , Sequence [ str ] ] [EOL] [EOL] [EOL] class ResourceOptions ( NamedTuple ) : [EOL] [docstring] [EOL] [EOL] allow_credentials = False [EOL] expose_headers = ( ) [EOL] allow_headers = ( ) [EOL] max_age = None [EOL] allow_methods = ( ) [EOL] [EOL] [EOL] class CacheBackendT ( ServiceT ) : [EOL] [EOL] Unavailable = ... [EOL] [EOL] @ abc . abstractmethod def __init__ ( self , app , url = [string] , ** kwargs ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def get ( self , key ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def set ( self , key , value , timeout = None ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def delete ( self , key ) : [EOL] ... [EOL] [EOL] [EOL] class CacheT ( abc . ABC ) : [EOL] [EOL] timeout = ... [EOL] include_headers = ... [EOL] key_prefix = ... [EOL] backend = ... [EOL] [EOL] @ abc . abstractmethod def __init__ ( self , timeout = None , key_prefix = None , backend = None , ** kwargs ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def view ( self , timeout = None , include_headers = False , key_prefix = None , ** kwargs ) : [EOL] ... [EOL] [EOL] [EOL] class BlueprintT ( abc . ABC ) : [EOL] name = ... [EOL] url_prefix = ... [EOL] [EOL] @ abc . abstractmethod def cache ( self , timeout = None , include_headers = False , key_prefix = None , backend = None ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def route ( self , uri , * , name = None , base = View ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def static ( self , uri , file_or_directory , * , name = None ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def register ( self , app , * , url_prefix = None ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def init_webserver ( self , web ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def on_webserver_init ( self , web ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[CORSListOption]$ 0 0 0 0 $typing.Optional[CORSListOption]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[CORSListOption]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.app.AppT$ 0 $typing.Union[yarl.URL,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[mode.Seconds]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Union[typing.Type[CacheBackendT],builtins.str]]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $mode.Seconds$ 0 0 0 $builtins.str$ 0 0 0 $typing.Union[typing.Type[CacheBackendT],builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Callable],typing.Callable]$ 0 0 0 $mode.Seconds$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $CacheT$ 0 0 0 $mode.Seconds$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.Union[typing.Type[CacheBackendT],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $RouteDecoratorRet$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Type[faust.web.views.View]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Union[builtins.str,pathlib.Path]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.app.AppT$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.web.base.Web$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.web.base.Web$ 0 0 0 0 0
from typing import Tuple , List , Type , Optional [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] import mode [EOL] [docstring] [EOL] import abc [EOL] from datetime import timezone [EOL] from typing import List , Optional , Tuple [EOL] [EOL] from mode import Seconds [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] WindowRange = Tuple [ float , float ] [EOL] [EOL] [EOL] def WindowRange_from_start ( start , size ) : [EOL] [docstring] [EOL] end = start + size - [number] [EOL] return ( start , end ) [EOL] [EOL] [EOL] class WindowT ( abc . ABC ) : [EOL] [docstring] [EOL] [EOL] expires = None [EOL] tz = None [EOL] [EOL] @ abc . abstractmethod def ranges ( self , timestamp ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def stale ( self , timestamp , latest_timestamp ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def current ( self , timestamp ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def earliest ( self , timestamp ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod def delta ( self , timestamp , d ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $WindowRange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[datetime.timezone]$ 0 0 0 0 0 0 0 0 0 $typing.List[WindowRange]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $WindowRange$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $WindowRange$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $WindowRange$ 0 0 0 $builtins.float$ 0 $mode.Seconds$ 0 0 0 0 0
from enum import Enum [EOL] [EOL] [EOL] class ProcessingGuarantee ( Enum ) : [EOL] AT_LEAST_ONCE = [string] [EOL] EXACTLY_ONCE = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Type , List [EOL] import faust [EOL] import typing [EOL] import mode [EOL] [docstring] [EOL] from typing import Type [EOL] from mode . utils . imports import FactoryMapping [EOL] from faust . types import StoreT [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] STORES = FactoryMapping ( memory = [string] , rocksdb = [string] , ) [EOL] STORES . include_setuptools_namespace ( [string] ) [EOL] by_name = STORES . by_name [EOL] by_url = STORES . by_url [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.StoreT]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.StoreT]]$ 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.StoreT]]$ 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.StoreT]]$ 0 0 0
from typing import Tuple , Optional , ClassVar , Callable , Any , Union , Type , List , Mapping , MutableMapping [EOL] import typing [EOL] import yarl [EOL] import faust [EOL] import Web [EOL] import http [EOL] import pathlib [EOL] import builtins [EOL] [docstring] [EOL] import abc [EOL] import socket [EOL] [EOL] from datetime import datetime [EOL] from http import HTTPStatus [EOL] from pathlib import Path [EOL] from typing import ( Any , Callable , ClassVar , Iterable , List , Mapping , MutableMapping , Optional , Tuple , Type , Union , ) [EOL] [EOL] from urllib . parse import quote [EOL] from mode import Service [EOL] from mode . utils . compat import want_str [EOL] from mode . utils . imports import SymbolArg , symbol_by_name [EOL] from yarl import URL [EOL] [EOL] from faust . types import AppT [EOL] from faust . types . web import BlueprintT , ResourceOptions , View [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] _bytes = bytes [EOL] [EOL] _BPArg = SymbolArg [ BlueprintT ] [EOL] _BPList = Iterable [ Tuple [ str , _BPArg ] ] [EOL] [EOL] DEFAULT_BLUEPRINTS = [ ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] PRODUCTION_BLUEPRINTS = [ ( [string] , [string] ) , ] [EOL] [EOL] DEBUG_BLUEPRINTS = [ ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] CONTENT_SEPARATOR = [string] [EOL] HEADER_SEPARATOR = [string] [EOL] HEADER_KEY_VALUE_SEPARATOR = [string] [EOL] [EOL] [EOL] class Response : [EOL] [docstring] [EOL] [EOL] @ property @ abc . abstractmethod def status ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def body ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def headers ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def content_length ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def content_type ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def charset ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def chunked ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def compression ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def keep_alive ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def body_length ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class BlueprintManager : [EOL] [docstring] [EOL] [EOL] applied = ... [EOL] [EOL] _enabled = ... [EOL] _active = ... [EOL] [EOL] def __init__ ( self , initial = None ) : [EOL] self . applied = False [EOL] self . _enabled = list ( initial ) if initial else [ ] [EOL] self . _active = { } [EOL] [EOL] def add ( self , prefix , blueprint ) : [EOL] [docstring] [EOL] if self . applied : [EOL] raise RuntimeError ( [string] ) [EOL] self . _enabled . append ( ( prefix , blueprint ) ) [EOL] [EOL] def apply ( self , web ) : [EOL] [docstring] [EOL] if not self . applied : [EOL] self . applied = True [EOL] for prefix , blueprint in self . _enabled : [EOL] bp = symbol_by_name ( blueprint ) [EOL] self . _apply_blueprint ( web , prefix , bp ) [EOL] [EOL] def _apply_blueprint ( self , web , prefix , bp ) : [EOL] self . _active [ bp . name ] = bp [EOL] bp . register ( web . app , url_prefix = prefix ) [EOL] bp . init_webserver ( web ) [EOL] [EOL] [EOL] class Web ( Service ) : [EOL] [docstring] [EOL] [EOL] default_blueprints = DEFAULT_BLUEPRINTS [comment] [EOL] production_blueprints = PRODUCTION_BLUEPRINTS [EOL] debug_blueprints = DEBUG_BLUEPRINTS [EOL] [EOL] app = ... [EOL] [EOL] driver_version = ... [EOL] [EOL] views = ... [EOL] reverse_names = ... [EOL] [EOL] blueprints = ... [EOL] [EOL] content_separator = CONTENT_SEPARATOR [EOL] header_separator = HEADER_SEPARATOR [EOL] header_key_value_separator = HEADER_KEY_VALUE_SEPARATOR [EOL] [EOL] def __init__ ( self , app , ** kwargs ) : [EOL] self . app = app [EOL] self . views = { } [EOL] self . reverse_names = { } [EOL] blueprints = list ( self . default_blueprints ) [EOL] if self . app . conf . debug : [EOL] blueprints . extend ( self . debug_blueprints ) [EOL] else : [EOL] blueprints . extend ( self . production_blueprints ) [EOL] self . blueprints = BlueprintManager ( blueprints ) [EOL] Service . __init__ ( self , ** kwargs ) [EOL] [EOL] @ abc . abstractmethod def text ( self , value , * , content_type = None , status = [number] , reason = None , headers = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod def html ( self , value , * , content_type = None , status = [number] , reason = None , headers = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod def json ( self , value , * , content_type = None , status = [number] , reason = None , headers = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod def bytes ( self , value , * , content_type = None , status = [number] , reason = None , headers = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod def bytes_to_response ( self , s ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def _bytes_to_response ( self , s ) : [EOL] status_code , _ , payload = s . partition ( self . content_separator ) [EOL] headers , _ , body = payload . partition ( self . content_separator ) [EOL] [EOL] return ( HTTPStatus ( int ( status_code ) ) , dict ( self . _splitheader ( h ) for h in headers . splitlines ( ) ) , body , ) [EOL] [EOL] def _splitheader ( self , header ) : [EOL] key , value = header . split ( self . header_key_value_separator , [number] ) [EOL] return want_str ( key . strip ( ) ) , want_str ( value . strip ( ) ) [EOL] [EOL] @ abc . abstractmethod def response_to_bytes ( self , response ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def _response_to_bytes ( self , status , headers , body ) : [EOL] return self . content_separator . join ( [ str ( status ) . encode ( ) , self . content_separator . join ( [ self . _headers_serialize ( headers ) , body , ] ) , ] ) [EOL] [EOL] def _headers_serialize ( self , headers ) : [EOL] return self . header_separator . join ( self . header_key_value_separator . join ( [ k if isinstance ( k , _bytes ) else k . encode ( [string] ) , v if isinstance ( v , _bytes ) else v . encode ( [string] ) , ] ) for k , v in headers . items ( ) ) [EOL] [EOL] @ abc . abstractmethod def route ( self , pattern , handler , cors_options = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod def add_static ( self , prefix , path , ** kwargs ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def read_request_content ( self , request ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def wsgi ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def add_view ( self , view_cls , * , prefix = [string] , cors_options = None ) : [EOL] [docstring] [EOL] view = view_cls ( self . app , self ) [EOL] path = prefix . rstrip ( [string] ) + [string] + view . view_path . lstrip ( [string] ) [EOL] self . route ( path , view , cors_options ) [EOL] self . views [ path ] = view [EOL] self . reverse_names [ view . view_name ] = path [EOL] return view [EOL] [EOL] def url_for ( self , view_name , ** kwargs ) : [EOL] [docstring] [EOL] try : [EOL] path = self . reverse_names [ view_name ] [EOL] except KeyError : [EOL] raise KeyError ( f' [string] { view_name !r} [string] ' ) [EOL] else : [EOL] return path . format ( ** { k : self . _quote_for_url ( str ( v ) ) for k , v in kwargs . items ( ) } ) [EOL] [EOL] def _quote_for_url ( self , value ) : [EOL] return quote ( value , safe = [string] ) [comment] [EOL] [EOL] def init_server ( self ) : [EOL] [docstring] [EOL] self . blueprints . apply ( self ) [EOL] self . app . on_webserver_init ( self ) [EOL] [EOL] @ property def url ( self ) : [EOL] [docstring] [EOL] canon = self . app . conf . canonical_url [EOL] if canon . host == socket . gethostname ( ) : [EOL] return URL ( f' [string] { self . app . conf . web_port } [string] ' ) [EOL] return self . app . conf . canonical_url [EOL] [EOL] [EOL] class Request ( abc . ABC ) : [EOL] [docstring] [EOL] [EOL] method = ... [EOL] headers = ... [EOL] url = ... [EOL] rel_url = ... [EOL] query_string = ... [EOL] keep_alive = ... [EOL] body_exists = ... [EOL] [EOL] user = ... [EOL] [EOL] if_modified_since = ... [EOL] if_unmodified_since = ... [EOL] if_range = ... [EOL] [EOL] @ abc . abstractmethod def can_read_body ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def read ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def text ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def json ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def post ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def match_info ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def query ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abc . abstractmethod def cookies ( self ) : [EOL] [docstring] [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $_BPList$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_BPList$ 0 0 0 0 0 0 0 0 0 0 0 $_BPList$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.List[typing.Tuple[builtins.str,_BPArg]]$ 0 0 0 $typing.MutableMapping[builtins.str,faust.types.web.BlueprintT]$ 0 0 0 0 0 $None$ 0 0 0 $_BPList$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $_BPList$ 0 0 $_BPList$ 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,faust.types.web.BlueprintT]$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $_BPArg$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $_BPArg$ 0 0 0 0 0 $None$ 0 0 0 $'Web'$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.web.BlueprintT$ 0 0 0 0 0 0 0 0 0 0 $'Web'$ 0 0 0 $faust.types.web.BlueprintT$ 0 0 0 0 $None$ 0 0 0 $'Web'$ 0 $builtins.str$ 0 $faust.types.web.BlueprintT$ 0 0 0 0 0 0 0 $faust.types.web.BlueprintT$ 0 0 0 0 $faust.types.web.BlueprintT$ 0 $faust.types.web.BlueprintT$ 0 0 0 $'Web'$ 0 0 0 0 0 $builtins.str$ 0 0 $faust.types.web.BlueprintT$ 0 0 0 $'Web'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[_BPList]$ 0 $_BPList$ 0 0 $typing.ClassVar[_BPList]$ 0 $_BPList$ 0 $typing.ClassVar[_BPList]$ 0 $_BPList$ 0 0 $faust.types.AppT$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.MutableMapping[builtins.str,faust.types.web.View]$ 0 0 0 $typing.MutableMapping[builtins.str,builtins.str]$ 0 0 0 0 $BlueprintManager$ 0 0 0 0 $typing.ClassVar[Web.bytes]$ 0 $builtins.bytes$ 0 $typing.ClassVar[Web.bytes]$ 0 $builtins.bytes$ 0 $typing.ClassVar[Web.bytes]$ 0 $builtins.bytes$ 0 0 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,builtins.str]$ 0 0 0 0 $faust.web.base.BlueprintManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.web.base.BlueprintManager$ 0 0 0 0 0 0 0 0 0 0 0 $faust.web.base.BlueprintManager$ 0 0 0 0 0 0 0 0 0 0 $faust.web.base.BlueprintManager$ 0 0 0 $faust.web.base.BlueprintManager$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $Response$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Response$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Response$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Response$ 0 0 0 $_bytes$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Response$ 0 0 0 $_bytes$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[http.HTTPStatus,typing.Mapping,_bytes]$ 0 0 0 $_bytes$ 0 0 0 0 0 0 0 0 0 $_bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 $_bytes$ 0 0 0 0 0 0 0 $_bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_bytes$ 0 0 0 $Response$ 0 0 0 0 0 0 0 0 0 $_bytes$ 0 0 0 $builtins.int$ 0 $typing.Mapping$ 0 $_bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 $_bytes$ 0 0 0 0 0 0 0 0 0 $_bytes$ 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Callable$ 0 $typing.Mapping[builtins.str,faust.types.web.ResourceOptions]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Union[pathlib.Path,builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_bytes$ 0 0 0 $'Request'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.web.View$ 0 0 0 $typing.Type[faust.types.web.View]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Mapping[builtins.str,faust.types.web.ResourceOptions]$ 0 0 0 0 0 0 0 $faust.types.web.View$ 0 $typing.Type[faust.types.web.View]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $faust.types.web.View$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $faust.types.web.View$ 0 $typing.Mapping[builtins.str,faust.types.web.ResourceOptions]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $faust.types.web.View$ 0 0 0 0 0 $faust.types.web.View$ 0 0 0 0 $builtins.str$ 0 0 $faust.types.web.View$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $yarl.URL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Mapping[builtins.str,builtins.str]$ 0 0 0 $yarl.URL$ 0 0 0 $yarl.URL$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0
from typing import Optional , Union , Type , List , Mapping [EOL] import typing [EOL] import faust [EOL] import pathlib [EOL] import builtins [EOL] import mode [EOL] [docstring] [EOL] from pathlib import Path [EOL] from typing import List , Mapping , NamedTuple , Optional , Type , Union [EOL] [EOL] from mode . utils . times import Seconds [EOL] [EOL] from faust . types import AppT [EOL] from faust . types . web import ( BlueprintT , CacheBackendT , CacheT , PageArg , ResourceOptions , RouteDecoratorRet , View , Web , ) [EOL] [EOL] from . cache import Cache [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class FutureRoute ( NamedTuple ) : [EOL] [docstring] [EOL] [EOL] uri = ... [EOL] name = ... [EOL] handler = ... [EOL] base = ... [EOL] cors_options = ... [EOL] [EOL] [EOL] class FutureStaticRoute ( NamedTuple ) : [EOL] [docstring] [EOL] [EOL] uri = ... [EOL] file_or_directory = ... [EOL] name = ... [EOL] [EOL] [EOL] class Blueprint ( BlueprintT ) : [EOL] [docstring] [EOL] [EOL] routes = ... [EOL] static_routes = ... [EOL] view_name_separator = [string] [EOL] [EOL] def __init__ ( self , name , * , url_prefix = None ) : [EOL] self . name = name [EOL] self . url_prefix = url_prefix [EOL] [EOL] self . routes = [ ] [EOL] self . static_routes = [ ] [EOL] [EOL] def cache ( self , timeout = None , include_headers = False , key_prefix = None , backend = None ) : [EOL] [docstring] [EOL] if key_prefix is None : [EOL] key_prefix = self . name [EOL] return Cache ( timeout , include_headers , key_prefix , backend ) [EOL] [EOL] def route ( self , uri , * , name = None , cors_options = None , base = View ) : [EOL] [docstring] [EOL] def _inner ( handler ) : [EOL] route = FutureRoute ( uri = uri , name = name or handler . __name__ , handler = handler , base = base , cors_options = cors_options or { } , ) [EOL] self . routes . append ( route ) [EOL] return handler [EOL] return _inner [EOL] [EOL] def static ( self , uri , file_or_directory , * , name = None ) : [EOL] [docstring] [EOL] _name = name or [string] [EOL] if not _name . startswith ( self . name + [string] ) : [EOL] _name = f'{ self . name } [string] { name }' [EOL] fut = FutureStaticRoute ( uri , Path ( file_or_directory ) , _name ) [EOL] self . static_routes . append ( fut ) [EOL] [EOL] def register ( self , app , * , url_prefix = None ) : [EOL] [docstring] [EOL] url_prefix = url_prefix or self . url_prefix [EOL] [EOL] [comment] [EOL] for route in self . routes : [EOL] self . _apply_route ( app , route , url_prefix ) [EOL] [EOL] for static_route in self . static_routes : [EOL] self . _apply_static_route ( app . web , static_route , url_prefix ) [EOL] [EOL] def _apply_route ( self , app , route , url_prefix ) : [EOL] uri = self . _url_with_prefix ( route . uri , url_prefix ) [EOL] [EOL] [comment] [EOL] [EOL] app . page ( path = uri [ [number] : ] if uri . startswith ( [string] ) else uri , name = self . _view_name ( route . name ) , cors_options = route . cors_options , ) ( route . handler ) [EOL] [EOL] def _view_name ( self , name ) : [EOL] return self . view_name_separator . join ( [ self . name , name ] ) [EOL] [EOL] def init_webserver ( self , web ) : [EOL] [docstring] [EOL] self . on_webserver_init ( web ) [EOL] [EOL] def on_webserver_init ( self , web ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def _url_with_prefix ( self , url , prefix = None ) : [EOL] if prefix : [EOL] return prefix . rstrip ( [string] ) + [string] + url . lstrip ( [string] ) [EOL] return url [EOL] [EOL] def _apply_static_route ( self , web , route , url_prefix ) : [EOL] uri = self . _url_with_prefix ( route . uri , url_prefix ) [EOL] web . add_static ( uri , route . file_or_directory ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { type ( self ) . __name__ } [string] { self . name } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $faust.types.web.PageArg$ 0 0 0 $typing.Type[faust.types.web.View]$ 0 0 0 $typing.Mapping[builtins.str,faust.types.web.ResourceOptions]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[FutureRoute]$ 0 0 0 $typing.List[FutureStaticRoute]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.List[faust.web.blueprints.FutureRoute]$ 0 0 0 0 0 0 $typing.List[faust.web.blueprints.FutureStaticRoute]$ 0 0 0 0 0 0 $faust.types.web.CacheT$ 0 0 0 $mode.utils.times.Seconds$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.Union[typing.Type[faust.types.web.CacheBackendT],builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $mode.utils.times.Seconds$ 0 $builtins.bool$ 0 $builtins.str$ 0 $typing.Union[typing.Type[faust.types.web.CacheBackendT],builtins.str]$ 0 0 0 0 $faust.types.web.RouteDecoratorRet$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Mapping[builtins.str,faust.types.web.ResourceOptions]$ 0 0 0 $typing.Type[faust.types.web.View]$ 0 0 0 0 0 0 0 0 $faust.types.web.PageArg$ 0 $faust.types.web.PageArg$ 0 0 0 $faust.web.blueprints.FutureRoute$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.web.PageArg$ 0 0 0 $faust.types.web.PageArg$ 0 $faust.types.web.PageArg$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.web.blueprints.FutureRoute$ 0 0 0 $faust.types.web.PageArg$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Union[builtins.str,pathlib.Path]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $faust.web.blueprints.FutureStaticRoute$ 0 0 0 $builtins.str$ 0 0 0 $typing.Union[builtins.str,pathlib.Path]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $faust.web.blueprints.FutureStaticRoute$ 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $FutureRoute$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $FutureRoute$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $faust.types.AppT$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $FutureRoute$ 0 0 0 0 0 0 $FutureRoute$ 0 0 0 0 0 $FutureRoute$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $faust.types.web.Web$ 0 0 0 0 0 0 0 0 0 $faust.types.web.Web$ 0 0 0 0 $None$ 0 0 0 $faust.types.web.Web$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $faust.types.web.Web$ 0 $FutureStaticRoute$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $FutureStaticRoute$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 $faust.types.web.Web$ 0 0 0 $builtins.str$ 0 $FutureStaticRoute$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class CacheUnavailable ( Exception ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from . cache import Cache [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Type , List [EOL] import faust [EOL] import typing [EOL] import mode [EOL] [docstring] [EOL] from typing import Type [EOL] from mode . utils . imports import FactoryMapping [EOL] from faust . types . web import CacheBackendT [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] BACKENDS = FactoryMapping ( memory = [string] , redis = [string] , rediscluster = [string] , ) [EOL] BACKENDS . include_setuptools_namespace ( [string] ) [EOL] by_name = BACKENDS . by_name [EOL] by_url = BACKENDS . by_url [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.web.CacheBackendT]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.web.CacheBackendT]]$ 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.web.CacheBackendT]]$ 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.web.CacheBackendT]]$ 0 0 0
from typing import AsyncGenerator , Tuple , Optional , ClassVar , Any , Union , Type [EOL] import typing [EOL] import yarl [EOL] import faust [EOL] import builtins [EOL] import mode [EOL] [docstring] [EOL] import abc [EOL] from typing import Any , ClassVar , Optional , Tuple , Type , Union [EOL] [EOL] from mode import Service [EOL] from mode . utils . contexts import asynccontextmanager [EOL] from mode . utils . logging import get_logger [EOL] from mode . utils . typing import AsyncGenerator [EOL] from yarl import URL [EOL] [EOL] from faust . types import AppT [EOL] from faust . types . web import CacheBackendT [EOL] from faust . web . cache . exceptions import CacheUnavailable [EOL] [EOL] logger = get_logger ( __name__ ) [EOL] [EOL] E_CACHE_IRRECOVERABLE = [string] [EOL] E_CACHE_INVALIDATING = [string] [EOL] E_CANNOT_INVALIDATE = [string] [EOL] E_CACHE_INOPERATIONAL = [string] [EOL] [EOL] [EOL] class CacheBackend ( CacheBackendT , Service ) : [EOL] [docstring] [EOL] [EOL] logger = logger [EOL] [EOL] Unavailable = CacheUnavailable [EOL] [EOL] operational_errors = ( ) [EOL] invalidating_errors = ( ) [EOL] irrecoverable_errors = ( ) [EOL] [EOL] def __init__ ( self , app , url = [string] , ** kwargs ) : [EOL] self . app = app [EOL] self . url = URL ( url ) [EOL] Service . __init__ ( self , ** kwargs ) [EOL] [EOL] @ abc . abstractmethod async def _get ( self , key ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def _set ( self , key , value , timeout = None ) : [EOL] ... [EOL] [EOL] @ abc . abstractmethod async def _delete ( self , key ) : [EOL] ... [EOL] [EOL] async def get ( self , key ) : [EOL] [docstring] [EOL] async with self . _recovery_context ( key ) : [EOL] return await self . _get ( key ) [EOL] [EOL] async def set ( self , key , value , timeout = None ) : [EOL] [docstring] [EOL] async with self . _recovery_context ( key ) : [EOL] await self . _set ( key , value , timeout ) [EOL] [EOL] async def delete ( self , key ) : [EOL] [docstring] [EOL] async with self . _recovery_context ( key ) : [EOL] await self . _delete ( key ) [EOL] [EOL] @ asynccontextmanager async def _recovery_context ( self , key ) : [EOL] try : [EOL] yield [EOL] except self . irrecoverable_errors as exc : [EOL] self . log . exception ( E_CACHE_IRRECOVERABLE , exc ) [comment] [EOL] raise self . Unavailable ( exc ) [EOL] except self . invalidating_errors as exc : [EOL] self . log . warning ( E_CACHE_INVALIDATING , key , exc , exc_info = [number] ) [EOL] try : [EOL] await self . _delete ( key ) [EOL] except self . operational_errors + self . invalidating_errors as exc : [EOL] self . log . exception ( E_CANNOT_INVALIDATE , key , exc ) [EOL] raise self . Unavailable ( ) [EOL] except self . operational_errors as exc : [EOL] self . log . warning ( E_CACHE_INOPERATIONAL , exc , exc_info = [number] ) [EOL] raise self . Unavailable ( ) [EOL] [EOL] def _repr_info ( self ) : [EOL] return f' [string] { self . url !r}' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[faust.web.cache.backends.base.CacheBackend]$ 0 $typing.Type[faust.web.cache.backends.base.CacheBackend]$ 0 0 $typing.Type[builtins.BaseException]$ 0 0 0 0 $typing.ClassVar[typing.Tuple[typing.Type[builtins.BaseException],...]]$ 0 0 0 0 $typing.ClassVar[typing.Tuple[typing.Type[builtins.BaseException],...]]$ 0 0 0 0 $typing.ClassVar[typing.Tuple[typing.Type[builtins.BaseException],...]]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 $builtins.float$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $mode.utils.typing.AsyncGenerator$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , List , MutableMapping [EOL] import faust [EOL] import typing [EOL] [docstring] [EOL] from typing import List , MutableMapping [EOL] from faust import web [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] TPMap = MutableMapping [ str , List [ int ] ] [EOL] [EOL] [EOL] blueprint = web . Blueprint ( [string] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , name = [string] ) class Index ( web . View ) : [EOL] [docstring] [EOL] [EOL] async def get ( self , request ) : [EOL] [docstring] [EOL] return self . json ( { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.web.Response$ 0 0 0 $faust.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import io [EOL] import faust [EOL] import typing [EOL] [docstring] [EOL] import io [EOL] from faust import web [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] blueprint = web . Blueprint ( [string] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , name = [string] ) class Graph ( web . View ) : [EOL] [docstring] [EOL] [EOL] async def get ( self , request ) : [EOL] [docstring] [EOL] try : [EOL] import pydot [EOL] except ImportError : [EOL] return self . text ( [string] , status = [number] ) [EOL] o = io . StringIO ( ) [EOL] beacon = self . app . beacon . root or self . app . beacon [EOL] beacon . as_graph ( ) . to_dot ( o ) [EOL] graph , = pydot . graph_from_dot_data ( o . getvalue ( ) ) [EOL] return self . bytes ( graph . create_png ( ) , content_type = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.web.Response$ 0 0 0 $faust.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any , Type , List , MutableMapping [EOL] import faust [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from collections import defaultdict [EOL] from typing import List , MutableMapping , Set [EOL] from faust import web [EOL] from faust . types . tuples import TP [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] TPMap = MutableMapping [ str , List [ int ] ] [EOL] [EOL] [EOL] blueprint = web . Blueprint ( [string] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , name = [string] ) class Stats ( web . View ) : [EOL] [docstring] [EOL] [EOL] async def get ( self , request ) : [EOL] [docstring] [EOL] return self . json ( { f' [string] { i }' : s . asdict ( ) for i , s in enumerate ( self . app . sensors ) } ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , name = [string] ) class Assignment ( web . View ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def _topic_grouped ( cls , assignment ) : [EOL] tps = defaultdict ( list ) [EOL] for tp in sorted ( assignment ) : [EOL] tps [ tp . topic ] . append ( tp . partition ) [EOL] return dict ( tps ) [EOL] [EOL] async def get ( self , request ) : [EOL] [docstring] [EOL] assignor = self . app . assignor [EOL] return self . json ( { [string] : self . _topic_grouped ( assignor . assigned_actives ( ) ) , [string] : self . _topic_grouped ( assignor . assigned_standbys ( ) ) , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.web.Response$ 0 0 0 $faust.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TPMap$ 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 $typing.MutableMapping[builtins.str,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.tuples.TP]$ 0 0 0 $typing.MutableMapping[builtins.str,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.List[builtins.int]]$ 0 0 0 0 0 $faust.web.Response$ 0 0 0 $faust.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import faust [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from faust import web [EOL] from faust . web . exceptions import ServiceUnavailable [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] blueprint = web . Blueprint ( [string] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , name = [string] ) class TableList ( web . View ) : [EOL] [docstring] [EOL] [EOL] async def get ( self , request ) : [EOL] [docstring] [EOL] router = self . app . router [EOL] return self . json ( router . tables_metadata ( ) ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , name = [string] ) class TableDetail ( web . View ) : [EOL] [docstring] [EOL] [EOL] async def get ( self , request , name ) : [EOL] [docstring] [EOL] router = self . app . router [EOL] return self . json ( router . table_metadata ( name ) ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , name = [string] ) class TableKeyDetail ( web . View ) : [EOL] [docstring] [EOL] [EOL] async def get ( self , request , name , key ) : [EOL] [docstring] [EOL] router = self . app . router [EOL] try : [EOL] dest_url = router . key_store ( name , key ) [EOL] except KeyError : [EOL] raise ServiceUnavailable ( ) [EOL] else : [EOL] return self . json ( str ( dest_url ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.web.Response$ 0 0 0 $faust.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.web.Response$ 0 0 0 $faust.web.Request$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.web.Response$ 0 0 0 $faust.web.Request$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import List , Iterable [EOL] import typing [EOL] import faust [EOL] import builtins [EOL] [docstring] [EOL] from typing import Iterable [EOL] from faust . types import AppT , FixupT [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class Fixup ( FixupT ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , app ) : [EOL] self . app = app [EOL] [EOL] def enabled ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] def autodiscover_modules ( self ) : [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] def on_worker_init ( self ) : [EOL] [docstring] [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0
from typing import Any , Iterator , Type , List [EOL] import faust [EOL] import typing [EOL] import mode [EOL] [docstring] [EOL] from typing import Iterator , Type [EOL] from mode . utils . imports import FactoryMapping [EOL] from faust . types import AppT , FixupT [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] FIXUPS = FactoryMapping ( django = [string] , ) [EOL] FIXUPS . include_setuptools_namespace ( [string] ) [EOL] by_name = FIXUPS . by_name [EOL] by_url = FIXUPS . by_url [EOL] [EOL] [EOL] def fixups ( app ) : [EOL] [docstring] [EOL] for Fixup in FIXUPS . iterate ( ) : [EOL] fixup = Fixup ( app ) [EOL] if fixup . enabled ( ) : [EOL] yield fixup [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.FixupT]]$ 0 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.FixupT]]$ 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.FixupT]]$ 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.FixupT]]$ 0 0 0 0 0 0 $typing.Iterator[faust.types.FixupT]$ 0 0 0 0 0 0 0 0 0 0 $mode.utils.imports.FactoryMapping[typing.Type[faust.types.FixupT]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Iterable [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import os [EOL] import typing [EOL] import warnings [EOL] from typing import Iterable [EOL] [EOL] from mode . utils . imports import symbol_by_name [EOL] from mode . utils . objects import cached_property [EOL] [EOL] from . import base [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from django . apps . registry import Apps as _Apps [EOL] from django . settings import Settings as _Settings [EOL] else : [EOL] class _Apps : ... [comment] [EOL] class _Settings : ... [comment] [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] WARN_NOT_INSTALLED = [string] [EOL] [EOL] WARN_DEBUG_ENABLED = [string] [EOL] [EOL] [EOL] class Fixup ( base . Fixup ) : [EOL] [docstring] [EOL] [EOL] def enabled ( self ) : [EOL] [docstring] [EOL] if os . environ . get ( [string] ) : [EOL] try : [EOL] import django [comment] [EOL] except ImportError : [EOL] warnings . warn ( WARN_NOT_INSTALLED ) [EOL] else : [EOL] return True [EOL] return False [EOL] [EOL] def wait_for_django ( self ) : [EOL] import django [EOL] [EOL] django . setup ( ) [EOL] if self . settings . DEBUG : [EOL] warnings . warn ( WARN_DEBUG_ENABLED ) [EOL] [EOL] def autodiscover_modules ( self ) : [EOL] [docstring] [EOL] self . wait_for_django ( ) [EOL] return [ config . name for config in self . apps . get_app_configs ( ) ] [EOL] [EOL] def on_worker_init ( self ) : [EOL] [docstring] [EOL] from django . core . checks import run_checks [EOL] [EOL] self . wait_for_django ( ) [EOL] run_checks ( ) [EOL] [EOL] @ cached_property def apps ( self ) : [EOL] [docstring] [EOL] return symbol_by_name ( [string] ) [EOL] [EOL] @ cached_property def settings ( self ) : [EOL] [docstring] [EOL] return symbol_by_name ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.apps.registry.Apps$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.settings.Settings$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] import faust [EOL] import builtins [EOL] import yarl [EOL] [docstring] [EOL] from typing import Tuple [EOL] [EOL] from yarl import URL [EOL] [EOL] from faust . exceptions import SameNode [EOL] from faust . types . app import AppT [EOL] from faust . types . assignor import PartitionAssignorT [EOL] from faust . types . core import K [EOL] from faust . types . router import HostToPartitionMap , RouterT [EOL] from faust . types . tables import CollectionT [EOL] from faust . types . web import Request , Response , Web [EOL] from faust . web . exceptions import ServiceUnavailable [EOL] [EOL] [EOL] class Router ( RouterT ) : [EOL] [docstring] [EOL] [EOL] _assignor = ... [EOL] [EOL] def __init__ ( self , app ) : [EOL] self . app = app [EOL] self . _assignor = self . app . assignor [EOL] [EOL] def key_store ( self , table_name , key ) : [EOL] [docstring] [EOL] table = self . _get_table ( table_name ) [EOL] topic = self . _get_table_topic ( table ) [EOL] k = self . _get_serialized_key ( table , key ) [EOL] return self . _assignor . key_store ( topic , k ) [EOL] [EOL] def table_metadata ( self , table_name ) : [EOL] [docstring] [EOL] table = self . _get_table ( table_name ) [EOL] topic = self . _get_table_topic ( table ) [EOL] return self . _assignor . table_metadata ( topic ) [EOL] [EOL] def tables_metadata ( self ) : [EOL] [docstring] [EOL] return self . _assignor . tables_metadata ( ) [EOL] [EOL] @ classmethod def _get_table_topic ( cls , table ) : [EOL] return table . changelog_topic . get_topic_name ( ) [EOL] [EOL] @ classmethod def _get_serialized_key ( cls , table , key ) : [EOL] return table . changelog_topic . prepare_key ( key , None ) [ [number] ] [EOL] [EOL] def _get_table ( self , name ) : [EOL] return self . app . tables [ name ] [EOL] [EOL] async def route_req ( self , table_name , key , web , request ) : [EOL] [docstring] [EOL] app = self . app [EOL] try : [EOL] dest_url = app . router . key_store ( table_name , key ) [EOL] except KeyError : [EOL] raise ServiceUnavailable ( ) [EOL] dest_ident = ( host , port ) = self . _urlident ( dest_url ) [EOL] if dest_ident == self . _urlident ( app . conf . canonical_url ) : [EOL] raise SameNode ( ) [EOL] routed_url = request . url . with_host ( host ) . with_port ( int ( port ) ) [EOL] async with app . http_client . get ( routed_url ) as response : [EOL] return web . text ( await response . text ( ) , content_type = response . content_type , status = response . status , ) [EOL] [EOL] def _urlident ( self , url ) : [EOL] return ( ( url . host if url . scheme else url . path ) or [string] , int ( url . port or [number] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 0 0 0 0 $None$ 0 0 0 $faust.types.app.AppT$ 0 0 0 0 0 $faust.types.app.AppT$ 0 $faust.types.app.AppT$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 0 0 $faust.types.app.AppT$ 0 0 0 0 0 $yarl.URL$ 0 0 0 $builtins.str$ 0 $faust.types.core.K$ 0 0 0 0 0 $faust.types.tables.CollectionT$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $faust.types.tables.CollectionT$ 0 0 $builtins.bytes$ 0 0 0 0 0 $faust.types.tables.CollectionT$ 0 $faust.types.core.K$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 $faust.types.router.HostToPartitionMap$ 0 0 0 $builtins.str$ 0 0 0 0 0 $faust.types.tables.CollectionT$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $faust.types.tables.CollectionT$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $faust.types.router.HostToPartitionMap$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $faust.types.tables.CollectionT$ 0 0 0 0 $faust.types.tables.CollectionT$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $faust.types.tables.CollectionT$ 0 $faust.types.core.K$ 0 0 0 0 $faust.types.tables.CollectionT$ 0 0 0 0 0 $faust.types.core.K$ 0 0 0 0 0 0 0 0 0 $faust.types.tables.CollectionT$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $faust.types.web.Response$ 0 0 0 $builtins.str$ 0 $faust.types.core.K$ 0 $faust.types.web.Web$ 0 $faust.types.web.Request$ 0 0 0 0 0 $faust.types.app.AppT$ 0 0 0 $faust.types.app.AppT$ 0 0 0 0 $yarl.URL$ 0 $faust.types.app.AppT$ 0 0 0 0 0 $builtins.str$ 0 $faust.types.core.K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $yarl.URL$ 0 0 0 0 0 0 0 0 0 $faust.types.app.AppT$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $faust.types.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.app.AppT$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $faust.types.web.Web$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 $yarl.URL$ 0 0 0 0 0 0 $yarl.URL$ 0 0 0 $yarl.URL$ 0 0 0 $yarl.URL$ 0 0 0 0 0 0 0 0 $yarl.URL$ 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from . base import App , BootStrategy [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from typing import Optional , Any , Dict , List , Pattern [EOL] import typing [EOL] import monitor [EOL] import faust [EOL] import statsd [EOL] import builtins [EOL] [docstring] [EOL] import re [EOL] import typing [EOL] [EOL] from typing import Any , Dict , Optional , Pattern , cast [EOL] [EOL] from mode . utils . objects import cached_property [EOL] [EOL] from faust import web [EOL] from faust . exceptions import ImproperlyConfigured [EOL] from faust . types import ( AppT , CollectionT , EventT , Message , PendingMessage , RecordMetadata , StreamT , TP , ) [EOL] from faust . types . assignor import PartitionAssignorT [EOL] from faust . types . transports import ConsumerT , ProducerT [EOL] [EOL] from . monitor import Monitor , TPOffsetMapping [EOL] [EOL] try : [EOL] import statsd [EOL] except ImportError : [comment] [EOL] statsd = None [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from statsd import StatsClient [EOL] else : [EOL] class StatsClient : ... [comment] [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] RE_NORMALIZE = re . compile ( [string] ) [EOL] RE_NORMALIZE_SUBSTITUTION = [string] [EOL] [EOL] [EOL] class StatsdMonitor ( Monitor ) : [EOL] [docstring] [EOL] [EOL] host = ... [EOL] port = ... [EOL] prefix = ... [EOL] [EOL] def __init__ ( self , host = [string] , port = [number] , prefix = [string] , rate = [number] , ** kwargs ) : [EOL] self . host = host [EOL] self . port = port [EOL] self . prefix = prefix [EOL] self . rate = rate [EOL] if statsd is None : [EOL] raise ImproperlyConfigured ( [string] ) [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] [EOL] def _new_statsd_client ( self ) : [EOL] return statsd . StatsClient ( host = self . host , port = self . port , prefix = self . prefix ) [EOL] [EOL] def on_message_in ( self , tp , offset , message ) : [EOL] [docstring] [EOL] super ( ) . on_message_in ( tp , offset , message ) [EOL] [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] self . client . incr ( f' [string] { tp . topic } [string] ' , rate = self . rate ) [EOL] self . client . gauge ( f' [string] { tp . topic } [string] { tp . partition }' , offset ) [EOL] [EOL] def on_stream_event_in ( self , tp , offset , stream , event ) : [EOL] [docstring] [EOL] state = super ( ) . on_stream_event_in ( tp , offset , stream , event ) [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] self . client . incr ( f' [string] { self . _stream_label ( stream ) } [string] ' , rate = self . rate , ) [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] return state [EOL] [EOL] def _stream_label ( self , stream ) : [EOL] return self . _normalize ( stream . shortlabel . lstrip ( [string] ) , ) . strip ( [string] ) . lower ( ) [EOL] [EOL] def on_stream_event_out ( self , tp , offset , stream , event , state = None ) : [EOL] [docstring] [EOL] super ( ) . on_stream_event_out ( tp , offset , stream , event , state ) [EOL] self . client . decr ( [string] , rate = self . rate ) [EOL] self . client . timing ( [string] , self . secs_to_ms ( self . events_runtime [ - [number] ] ) , rate = self . rate ) [EOL] [EOL] def on_message_out ( self , tp , offset , message ) : [EOL] [docstring] [EOL] super ( ) . on_message_out ( tp , offset , message ) [EOL] self . client . decr ( [string] , rate = self . rate ) [EOL] [EOL] def on_table_get ( self , table , key ) : [EOL] [docstring] [EOL] super ( ) . on_table_get ( table , key ) [EOL] self . client . incr ( f' [string] { table . name } [string] ' , rate = self . rate ) [EOL] [EOL] def on_table_set ( self , table , key , value ) : [EOL] [docstring] [EOL] super ( ) . on_table_set ( table , key , value ) [EOL] self . client . incr ( f' [string] { table . name } [string] ' , rate = self . rate ) [EOL] [EOL] def on_table_del ( self , table , key ) : [EOL] [docstring] [EOL] super ( ) . on_table_del ( table , key ) [EOL] self . client . incr ( f' [string] { table . name } [string] ' , rate = self . rate ) [EOL] [EOL] def on_commit_completed ( self , consumer , state ) : [EOL] [docstring] [EOL] super ( ) . on_commit_completed ( consumer , state ) [EOL] self . client . timing ( [string] , self . ms_since ( cast ( float , state ) ) , rate = self . rate ) [EOL] [EOL] def on_send_initiated ( self , producer , topic , message , keysize , valsize ) : [EOL] [docstring] [EOL] self . client . incr ( f' [string] { topic } [string] ' , rate = self . rate ) [EOL] return super ( ) . on_send_initiated ( producer , topic , message , keysize , valsize ) [EOL] [EOL] def on_send_completed ( self , producer , state , metadata ) : [EOL] [docstring] [EOL] super ( ) . on_send_completed ( producer , state , metadata ) [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] self . client . timing ( [string] , self . ms_since ( cast ( float , state ) ) , rate = self . rate ) [EOL] [EOL] def on_send_error ( self , producer , exc , state ) : [EOL] [docstring] [EOL] super ( ) . on_send_error ( producer , exc , state ) [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] self . client . timing ( [string] , self . ms_since ( cast ( float , state ) ) , rate = self . rate ) [EOL] [EOL] def on_assignment_error ( self , assignor , state , exc ) : [EOL] [docstring] [EOL] super ( ) . on_assignment_error ( assignor , state , exc ) [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] self . client . timing ( [string] , self . ms_since ( state [ [string] ] ) , rate = self . rate ) [EOL] [EOL] def on_assignment_completed ( self , assignor , state ) : [EOL] [docstring] [EOL] super ( ) . on_assignment_completed ( assignor , state ) [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] self . client . timing ( [string] , self . ms_since ( state [ [string] ] ) , rate = self . rate ) [EOL] [EOL] def on_rebalance_start ( self , app ) : [EOL] [docstring] [EOL] state = super ( ) . on_rebalance_start ( app ) [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] return state [EOL] [EOL] def on_rebalance_return ( self , app , state ) : [EOL] [docstring] [EOL] super ( ) . on_rebalance_return ( app , state ) [EOL] self . client . decr ( [string] , rate = self . rate ) [EOL] self . client . incr ( [string] , rate = self . rate ) [EOL] self . client . timing ( [string] , self . ms_since ( state [ [string] ] ) , rate = self . rate ) [EOL] [EOL] def on_rebalance_end ( self , app , state ) : [EOL] [docstring] [EOL] super ( ) . on_rebalance_end ( app , state ) [EOL] self . client . decr ( [string] , rate = self . rate ) [EOL] self . client . timing ( [string] , self . ms_since ( state [ [string] ] ) , rate = self . rate ) [EOL] [EOL] def count ( self , metric_name , count = [number] ) : [EOL] [docstring] [EOL] super ( ) . count ( metric_name , count = count ) [EOL] self . client . incr ( metric_name , count = count , rate = self . rate ) [EOL] [EOL] def on_tp_commit ( self , tp_offsets ) : [EOL] [docstring] [EOL] super ( ) . on_tp_commit ( tp_offsets ) [EOL] for tp , offset in tp_offsets . items ( ) : [EOL] metric_name = f' [string] { tp . topic } [string] { tp . partition }' [EOL] self . client . gauge ( metric_name , offset ) [EOL] [EOL] def track_tp_end_offset ( self , tp , offset ) : [EOL] [docstring] [EOL] super ( ) . track_tp_end_offset ( tp , offset ) [EOL] metric_name = f' [string] { tp . topic } [string] { tp . partition }' [EOL] self . client . gauge ( metric_name , offset ) [EOL] [EOL] def on_web_request_end ( self , app , request , response , state , * , view = None ) : [EOL] [docstring] [EOL] super ( ) . on_web_request_end ( app , request , response , state , view = view ) [EOL] status_code = int ( state [ [string] ] ) [EOL] self . client . incr ( f' [string] { status_code }' , rate = self . rate ) [EOL] self . client . timing ( [string] , self . ms_since ( state [ [string] ] ) , rate = self . rate ) [EOL] [EOL] def _normalize ( self , name , * , pattern = RE_NORMALIZE , substitution = RE_NORMALIZE_SUBSTITUTION ) : [EOL] return pattern . sub ( substitution , name ) [EOL] [EOL] @ cached_property def client ( self ) : [EOL] [docstring] [EOL] return self . _new_statsd_client ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $statsd.StatsClient$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 $faust.types.Message$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 $faust.types.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 0 0 0 0 $faust.types.TP$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.StreamT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 $faust.types.StreamT$ 0 0 0 0 0 0 0 0 $faust.types.StreamT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 $faust.types.Message$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 $faust.types.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ConsumerT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ConsumerT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.str$ 0 $faust.types.PendingMessage$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.str$ 0 $faust.types.PendingMessage$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ProducerT$ 0 $typing.Any$ 0 $faust.types.RecordMetadata$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ProducerT$ 0 $typing.Any$ 0 $faust.types.RecordMetadata$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.BaseException$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.BaseException$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 $builtins.BaseException$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 $builtins.BaseException$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $faust.types.AppT$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $faust.types.AppT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $monitor.TPOffsetMapping$ 0 0 0 0 0 0 0 0 0 0 0 $monitor.TPOffsetMapping$ 0 0 0 0 0 0 0 $monitor.TPOffsetMapping$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.TP$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 $faust.types.TP$ 0 0 0 0 0 $faust.types.TP$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 $typing.Optional[faust.web.Response]$ 0 $typing.Dict$ 0 0 0 $faust.web.View$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 $typing.Optional[faust.web.Response]$ 0 $typing.Dict$ 0 $faust.web.View$ 0 $faust.web.View$ 0 0 $builtins.int$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Pattern$ 0 $typing.Pattern[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Pattern$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $statsd.StatsClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Optional , Set , Any , Dict , List , Mapping [EOL] import faust [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from time import monotonic [EOL] from typing import Any , Dict , Iterator , Mapping , Optional , Set [EOL] [EOL] from mode import Service [EOL] [EOL] from faust import web [EOL] from faust . types import AppT , CollectionT , EventT , StreamT [EOL] from faust . types . assignor import PartitionAssignorT [EOL] from faust . types . tuples import Message , PendingMessage , RecordMetadata , TP [EOL] from faust . types . sensors import SensorDelegateT , SensorT [EOL] from faust . types . transports import ConsumerT , ProducerT [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] class Sensor ( SensorT , Service ) : [EOL] [docstring] [EOL] [EOL] def on_message_in ( self , tp , offset , message ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_stream_event_in ( self , tp , offset , stream , event ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def on_stream_event_out ( self , tp , offset , stream , event , state = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_message_out ( self , tp , offset , message ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_topic_buffer_full ( self , tp ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_table_get ( self , table , key ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_table_set ( self , table , key , value ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_table_del ( self , table , key ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_commit_initiated ( self , consumer ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_commit_completed ( self , consumer , state ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_send_initiated ( self , producer , topic , message , keysize , valsize ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_send_completed ( self , producer , state , metadata ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_send_error ( self , producer , exc , state ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_assignment_start ( self , assignor ) : [EOL] [docstring] [EOL] return { [string] : monotonic ( ) } [EOL] [EOL] def on_assignment_error ( self , assignor , state , exc ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_assignment_completed ( self , assignor , state ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_rebalance_start ( self , app ) : [EOL] [docstring] [EOL] return { [string] : monotonic ( ) } [EOL] [EOL] def on_rebalance_return ( self , app , state ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_rebalance_end ( self , app , state ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def on_web_request_start ( self , app , request , * , view = None ) : [EOL] [docstring] [EOL] return { [string] : monotonic ( ) } [EOL] [EOL] def on_web_request_end ( self , app , request , response , state , * , view = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] def asdict ( self ) : [EOL] [docstring] [EOL] return { } [EOL] [EOL] [EOL] class SensorDelegate ( SensorDelegateT ) : [EOL] [docstring] [EOL] [EOL] _sensors = ... [EOL] [EOL] def __init__ ( self , app ) : [EOL] self . app = app [EOL] self . _sensors = set ( ) [EOL] [EOL] def add ( self , sensor ) : [EOL] [docstring] [EOL] [comment] [EOL] sensor . beacon = self . app . beacon . new ( sensor ) [EOL] self . _sensors . add ( sensor ) [EOL] [EOL] def remove ( self , sensor ) : [EOL] [docstring] [EOL] self . _sensors . remove ( sensor ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . _sensors ) [EOL] [EOL] def on_message_in ( self , tp , offset , message ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_message_in ( tp , offset , message ) [EOL] [EOL] def on_stream_event_in ( self , tp , offset , stream , event ) : [EOL] [docstring] [EOL] return { sensor : sensor . on_stream_event_in ( tp , offset , stream , event ) for sensor in self . _sensors } [EOL] [EOL] def on_stream_event_out ( self , tp , offset , stream , event , state = None ) : [EOL] [docstring] [EOL] sensor_state = state or { } [EOL] for sensor in self . _sensors : [EOL] sensor . on_stream_event_out ( tp , offset , stream , event , sensor_state . get ( sensor ) ) [EOL] [EOL] def on_topic_buffer_full ( self , tp ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_topic_buffer_full ( tp ) [EOL] [EOL] def on_message_out ( self , tp , offset , message ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_message_out ( tp , offset , message ) [EOL] [EOL] def on_table_get ( self , table , key ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_table_get ( table , key ) [EOL] [EOL] def on_table_set ( self , table , key , value ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_table_set ( table , key , value ) [EOL] [EOL] def on_table_del ( self , table , key ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_table_del ( table , key ) [EOL] [EOL] def on_commit_initiated ( self , consumer ) : [EOL] [docstring] [EOL] [comment] [EOL] return { sensor : sensor . on_commit_initiated ( consumer ) for sensor in self . _sensors } [EOL] [EOL] def on_commit_completed ( self , consumer , state ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] for sensor in self . _sensors : [EOL] sensor . on_commit_completed ( consumer , state [ sensor ] ) [EOL] [EOL] def on_send_initiated ( self , producer , topic , message , keysize , valsize ) : [EOL] [docstring] [EOL] return { sensor : sensor . on_send_initiated ( producer , topic , message , keysize , valsize ) for sensor in self . _sensors } [EOL] [EOL] def on_send_completed ( self , producer , state , metadata ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_send_completed ( producer , state [ sensor ] , metadata ) [EOL] [EOL] def on_send_error ( self , producer , exc , state ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_send_error ( producer , exc , state [ sensor ] ) [EOL] [EOL] def on_assignment_start ( self , assignor ) : [EOL] [docstring] [EOL] return { sensor : sensor . on_assignment_start ( assignor ) for sensor in self . _sensors } [EOL] [EOL] def on_assignment_error ( self , assignor , state , exc ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_assignment_error ( assignor , state [ sensor ] , exc ) [EOL] [EOL] def on_assignment_completed ( self , assignor , state ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_assignment_completed ( assignor , state [ sensor ] ) [EOL] [EOL] def on_rebalance_start ( self , app ) : [EOL] [docstring] [EOL] return { sensor : sensor . on_rebalance_start ( app ) for sensor in self . _sensors } [EOL] [EOL] def on_rebalance_return ( self , app , state ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_rebalance_return ( app , state [ sensor ] ) [EOL] [EOL] def on_rebalance_end ( self , app , state ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_rebalance_end ( app , state [ sensor ] ) [EOL] [EOL] def on_web_request_start ( self , app , request , * , view = None ) : [EOL] [docstring] [EOL] return { sensor : sensor . on_web_request_start ( app , request , view = view ) for sensor in self . _sensors } [EOL] [EOL] def on_web_request_end ( self , app , request , response , state , * , view = None ) : [EOL] [docstring] [EOL] for sensor in self . _sensors : [EOL] sensor . on_web_request_end ( app , request , response , state [ sensor ] , view = view ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { type ( self ) . __name__ } [string] { self . _sensors !r} [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.tuples.Message$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.tuples.Message$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.tuples.TP$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $faust.types.transports.ConsumerT$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ConsumerT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.str$ 0 $faust.types.tuples.PendingMessage$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ProducerT$ 0 $typing.Any$ 0 $faust.types.tuples.RecordMetadata$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.BaseException$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 $builtins.BaseException$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $faust.types.AppT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 0 0 $faust.web.View$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 $typing.Optional[faust.web.Response]$ 0 $typing.Dict$ 0 0 0 $faust.web.View$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.sensors.SensorT]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[faust.types.sensors.SensorT]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.sensors.SensorT$ 0 0 0 0 0 0 0 $faust.types.sensors.SensorT$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.sensors.SensorT$ 0 0 0 0 0 0 0 0 $faust.types.sensors.SensorT$ 0 0 0 0 $None$ 0 0 0 $faust.types.sensors.SensorT$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.sensors.SensorT$ 0 0 0 0 $typing.Iterator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.tuples.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.tuples.Message$ 0 0 0 0 $typing.Optional[typing.Dict]$ 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.StreamT$ 0 $faust.types.EventT$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.tuples.TP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tuples.TP$ 0 0 0 0 $None$ 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.tuples.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 $faust.types.tuples.Message$ 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $faust.types.transports.ConsumerT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ConsumerT$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ConsumerT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ConsumerT$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.str$ 0 $faust.types.tuples.PendingMessage$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.str$ 0 $faust.types.tuples.PendingMessage$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ProducerT$ 0 $typing.Any$ 0 $faust.types.tuples.RecordMetadata$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ProducerT$ 0 $typing.Any$ 0 0 0 0 $faust.types.tuples.RecordMetadata$ 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.BaseException$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.BaseException$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 $builtins.BaseException$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 0 0 0 $builtins.BaseException$ 0 0 0 0 $None$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $faust.types.AppT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 0 0 $faust.web.View$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 $faust.web.View$ 0 $faust.web.View$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 $typing.Optional[faust.web.Response]$ 0 $typing.Dict$ 0 0 0 $faust.web.View$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 $typing.Optional[faust.web.Response]$ 0 $typing.Dict$ 0 0 0 0 $faust.web.View$ 0 $faust.web.View$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from . base import Sensor , SensorDelegate [EOL] from . monitor import Monitor , TableState [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Optional , Callable , Any , Union , Dict , Type , List , Mapping , MutableMapping , Deque , Counter [EOL] import typing [EOL] import faust [EOL] import http [EOL] import asyncio [EOL] import builtins [EOL] import mode [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from collections import deque [EOL] from http import HTTPStatus [EOL] from statistics import median [EOL] from time import monotonic [EOL] from typing import ( Any , Callable , Dict , Mapping , MutableMapping , Optional , Tuple , cast , ) [EOL] [EOL] from mode import Service , label [EOL] from mode . utils . objects import KeywordReduce [EOL] from mode . utils . typing import Counter , Deque [EOL] [EOL] from faust import web [EOL] from faust . types import AppT , CollectionT , EventT , StreamT [EOL] from faust . types . assignor import PartitionAssignorT [EOL] from faust . types . tuples import Message , PendingMessage , RecordMetadata , TP [EOL] from faust . types . transports import ConsumerT , ProducerT [EOL] from faust . utils . functional import deque_pushpopmax [EOL] [EOL] from . base import Sensor [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] MAX_AVG_HISTORY = [number] [EOL] MAX_COMMIT_LATENCY_HISTORY = [number] [EOL] MAX_SEND_LATENCY_HISTORY = [number] [EOL] MAX_ASSIGNMENT_LATENCY_HISTORY = [number] [EOL] [EOL] TPOffsetMapping = MutableMapping [ TP , int ] [EOL] PartitionOffsetMapping = MutableMapping [ int , int ] [EOL] TPOffsetDict = MutableMapping [ str , PartitionOffsetMapping ] [EOL] [EOL] [EOL] class TableState ( KeywordReduce ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] table = cast ( CollectionT , None ) [EOL] [EOL] [comment] [EOL] keys_retrieved = [number] [EOL] [EOL] [comment] [EOL] keys_updated = [number] [EOL] [EOL] [comment] [EOL] keys_deleted = [number] [EOL] [EOL] def __init__ ( self , table , * , keys_retrieved = [number] , keys_updated = [number] , keys_deleted = [number] ) : [EOL] self . table = table [EOL] self . keys_retrieved = keys_retrieved [EOL] self . keys_updated = keys_updated [EOL] self . keys_deleted = keys_deleted [EOL] [EOL] def asdict ( self ) : [EOL] [docstring] [EOL] return { [string] : self . keys_retrieved , [string] : self . keys_updated , [string] : self . keys_deleted , } [EOL] [EOL] def __reduce_keywords__ ( self ) : [EOL] return { ** self . asdict ( ) , [string] : self . table } [EOL] [EOL] [EOL] class Monitor ( Sensor , KeywordReduce ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] max_avg_history = MAX_AVG_HISTORY [EOL] [EOL] [comment] [EOL] max_commit_latency_history = MAX_COMMIT_LATENCY_HISTORY [EOL] [EOL] [comment] [EOL] max_send_latency_history = MAX_SEND_LATENCY_HISTORY [EOL] [EOL] [comment] [EOL] max_assignment_latency_history = MAX_ASSIGNMENT_LATENCY_HISTORY [EOL] [EOL] [comment] [EOL] tables = cast ( MutableMapping [ str , TableState ] , None ) [EOL] [EOL] [comment] [EOL] messages_active = [number] [EOL] [EOL] [comment] [EOL] messages_received_total = [number] [EOL] [EOL] [comment] [EOL] messages_received_by_topic = cast ( Counter [ str ] , None ) [EOL] [EOL] [comment] [EOL] messages_s = [number] [EOL] [EOL] [comment] [EOL] messages_sent = [number] [EOL] [EOL] [comment] [EOL] messages_sent_by_topic = cast ( Counter [ str ] , None ) [EOL] [EOL] [comment] [EOL] events_active = [number] [EOL] [EOL] [comment] [EOL] events_total = [number] [EOL] [EOL] [comment] [EOL] events_s = [number] [EOL] [EOL] [comment] [EOL] events_by_stream = cast ( Counter [ str ] , None ) [EOL] [EOL] [comment] [EOL] events_by_task = cast ( Counter [ str ] , None ) [EOL] [EOL] [comment] [EOL] events_runtime_avg = [number] [EOL] [EOL] [comment] [EOL] events_runtime = cast ( Deque [ float ] , None ) [EOL] [EOL] [comment] [EOL] commit_latency = cast ( Deque [ float ] , None ) [EOL] [EOL] [comment] [EOL] send_latency = cast ( Deque [ float ] , None ) [EOL] [EOL] [comment] [EOL] assignment_latency = cast ( Deque [ float ] , None ) [EOL] [EOL] [comment] [EOL] topic_buffer_full = cast ( Counter [ TP ] , None ) [EOL] [EOL] [comment] [EOL] metric_counts = cast ( Counter [ str ] , None ) [EOL] [EOL] [comment] [EOL] tp_committed_offsets = cast ( TPOffsetMapping , None ) [EOL] [EOL] [comment] [EOL] tp_read_offsets = cast ( TPOffsetMapping , None ) [EOL] [EOL] [comment] [EOL] tp_end_offsets = cast ( TPOffsetMapping , None ) [EOL] [EOL] [comment] [EOL] send_errors = [number] [EOL] [EOL] [comment] [EOL] assignments_completed = [number] [EOL] [EOL] [comment] [EOL] assignments_failed = [number] [EOL] [EOL] [comment] [EOL] rebalances = [number] [EOL] [EOL] [comment] [EOL] rebalance_return_latency = cast ( Deque [ float ] , None ) [EOL] [EOL] [comment] [EOL] rebalance_end_latency = cast ( Deque [ float ] , None ) [EOL] [EOL] [comment] [EOL] rebalance_return_avg = [number] [EOL] [EOL] [comment] [EOL] rebalance_end_avg = [number] [EOL] [EOL] [comment] [EOL] http_response_codes = cast ( Counter [ HTTPStatus ] , None ) [EOL] [EOL] [comment] [EOL] http_response_latency = cast ( Deque [ float ] , None ) [EOL] [EOL] [comment] [EOL] http_response_latency_avg = [number] [EOL] [EOL] stream_inbound_time = cast ( Dict [ TP , float ] , None ) [EOL] [EOL] def __init__ ( self , * , max_avg_history = None , max_commit_latency_history = None , max_send_latency_history = None , max_assignment_latency_history = None , messages_sent = [number] , tables = None , messages_active = [number] , events_active = [number] , messages_received_total = [number] , messages_received_by_topic = None , events_total = [number] , events_by_stream = None , events_by_task = None , events_runtime = None , commit_latency = None , send_latency = None , assignment_latency = None , events_s = [number] , messages_s = [number] , events_runtime_avg = [number] , topic_buffer_full = None , rebalances = None , rebalance_return_latency = None , rebalance_end_latency = None , rebalance_return_avg = [number] , rebalance_end_avg = [number] , time = monotonic , http_response_codes = None , http_response_latency = None , http_response_latency_avg = [number] , ** kwargs ) : [EOL] if max_avg_history is not None : [EOL] self . max_avg_history = max_avg_history [EOL] if max_commit_latency_history is not None : [EOL] self . max_commit_latency_history = max_commit_latency_history [EOL] if max_send_latency_history is not None : [EOL] self . max_send_latency_history = max_send_latency_history [EOL] if max_assignment_latency_history is not None : [EOL] self . max_assignment_latency_history = ( [EOL] max_assignment_latency_history) [EOL] if rebalances is not None : [EOL] self . rebalances = rebalances [EOL] [EOL] self . tables = { } if tables is None else tables [EOL] self . commit_latency = ( deque ( ) if commit_latency is None else commit_latency ) [EOL] self . send_latency = deque ( ) if send_latency is None else send_latency [EOL] self . assignment_latency = ( deque ( ) if assignment_latency is None else assignment_latency ) [EOL] self . rebalance_return_latency = ( deque ( ) if rebalance_return_latency is None [EOL] else rebalance_return_latency ) [EOL] self . rebalance_end_latency = ( deque ( ) if rebalance_end_latency is None [EOL] else rebalance_end_latency ) [EOL] self . rebalance_return_avg = rebalance_return_avg [EOL] self . rebalance_end_avg = rebalance_end_avg [EOL] [EOL] self . messages_active = messages_active [EOL] self . messages_received_total = messages_received_total [EOL] self . messages_received_by_topic = Counter ( ) [EOL] self . messages_sent = messages_sent [EOL] self . messages_sent_by_topic = Counter ( ) [EOL] self . messages_s = messages_s [EOL] [EOL] self . events_active = events_active [EOL] self . events_total = events_total [EOL] self . events_by_task = Counter ( ) [EOL] self . events_by_stream = Counter ( ) [EOL] self . events_s = events_s [EOL] self . events_runtime_avg = events_runtime_avg [EOL] self . events_runtime = ( deque ( ) if events_runtime is None else events_runtime ) [EOL] self . topic_buffer_full = Counter ( ) [EOL] self . time = time [EOL] [EOL] self . http_response_codes = Counter ( ) [EOL] self . http_response_latency = deque ( ) [EOL] self . http_response_latency_avg = http_response_latency_avg [EOL] [EOL] self . metric_counts = Counter ( ) [EOL] [EOL] self . tp_committed_offsets = { } [EOL] self . tp_read_offsets = { } [EOL] self . tp_end_offsets = { } [EOL] [EOL] self . stream_inbound_time = { } [EOL] Service . __init__ ( self , ** kwargs ) [EOL] [EOL] def secs_since ( self , start_time ) : [EOL] [docstring] [EOL] return self . time ( ) - start_time [EOL] [EOL] def ms_since ( self , start_time ) : [EOL] [docstring] [EOL] return self . secs_to_ms ( self . secs_since ( start_time ) ) [EOL] [EOL] def secs_to_ms ( self , timestamp ) : [EOL] [docstring] [EOL] return timestamp * [number] [EOL] [EOL] @ Service . task async def _sampler ( self ) : [EOL] prev_message_total = self . messages_received_total [EOL] prev_event_total = self . events_total [EOL] [EOL] async for sleep_time in self . itertimer ( [number] , name = [string] ) : [EOL] prev_event_total , prev_message_total = self . _sample ( prev_event_total , prev_message_total ) [EOL] [EOL] def _sample ( self , prev_event_total , prev_message_total ) : [EOL] [comment] [EOL] if self . events_runtime : [EOL] self . events_runtime_avg = median ( self . events_runtime ) [EOL] [EOL] [comment] [EOL] self . events_s , prev_event_total = ( self . events_total - prev_event_total , self . events_total , ) [EOL] [EOL] [comment] [EOL] self . messages_s , prev_message_total = ( self . messages_received_total - prev_message_total , self . messages_received_total ) [EOL] [EOL] if self . rebalance_return_latency : [EOL] self . rebalance_return_avg = median ( self . rebalance_return_latency ) [EOL] [EOL] if self . rebalance_end_latency : [EOL] self . rebalance_end_avg = median ( self . rebalance_end_latency ) [EOL] [EOL] if self . http_response_latency : [EOL] self . http_response_latency_avg = median ( self . http_response_latency ) [EOL] [EOL] return prev_event_total , prev_message_total [EOL] [EOL] def asdict ( self ) : [EOL] [docstring] [EOL] return { [string] : self . messages_active , [string] : self . messages_received_total , [string] : self . messages_sent , [string] : self . messages_sent_by_topic , [string] : self . messages_s , [string] : self . messages_received_by_topic , [string] : self . events_active , [string] : self . events_total , [string] : self . events_s , [string] : self . events_runtime_avg , [string] : self . _events_by_task_dict ( ) , [string] : self . _events_by_stream_dict ( ) , [string] : self . commit_latency , [string] : self . send_latency , [string] : self . send_errors , [string] : self . assignment_latency , [string] : self . assignments_completed , [string] : self . assignments_failed , [string] : self . _topic_buffer_full_dict ( ) , [string] : { name : table . asdict ( ) for name , table in self . tables . items ( ) } , [string] : self . _metric_counts_dict ( ) , [string] : self . _tp_committed_offsets_dict ( ) , [string] : self . _tp_read_offsets_dict ( ) , [string] : self . _tp_end_offsets_dict ( ) , [string] : self . rebalances , [string] : self . rebalance_return_latency , [string] : self . rebalance_end_latency , [string] : self . rebalance_return_avg , [string] : self . rebalance_end_avg , [string] : self . _http_response_codes_dict ( ) , [string] : self . http_response_latency , [string] : self . http_response_latency_avg , } [EOL] [EOL] def _events_by_stream_dict ( self ) : [EOL] return { label ( stream ) : count for stream , count in self . events_by_stream . items ( ) } [EOL] [EOL] def _events_by_task_dict ( self ) : [EOL] return { label ( task ) : count for task , count in self . events_by_task . items ( ) } [EOL] [EOL] def _topic_buffer_full_dict ( self ) : [EOL] return { label ( topic ) : count for topic , count in self . topic_buffer_full . items ( ) } [EOL] [EOL] def _metric_counts_dict ( self ) : [EOL] return { key : count for key , count in self . metric_counts . items ( ) } [EOL] [EOL] def _http_response_codes_dict ( self ) : [EOL] return { int ( code ) : count for code , count in self . http_response_codes . items ( ) } [EOL] [EOL] def _tp_committed_offsets_dict ( self ) : [EOL] return self . _tp_offsets_as_dict ( self . tp_committed_offsets ) [EOL] [EOL] def _tp_read_offsets_dict ( self ) : [EOL] return self . _tp_offsets_as_dict ( self . tp_read_offsets ) [EOL] [EOL] def _tp_end_offsets_dict ( self ) : [EOL] return self . _tp_offsets_as_dict ( self . tp_end_offsets ) [EOL] [EOL] @ classmethod def _tp_offsets_as_dict ( cls , tp_offsets ) : [EOL] topic_partition_offsets = { } [EOL] for tp , offset in tp_offsets . items ( ) : [EOL] partition_offsets = topic_partition_offsets . get ( tp . topic ) or { } [EOL] partition_offsets [ tp . partition ] = offset [EOL] topic_partition_offsets [ tp . topic ] = partition_offsets [EOL] return topic_partition_offsets [EOL] [EOL] def on_message_in ( self , tp , offset , message ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] self . messages_received_total += [number] [EOL] self . messages_active += [number] [EOL] self . messages_received_by_topic [ tp . topic ] += [number] [EOL] self . tp_read_offsets [ tp ] = offset [EOL] message . time_in = self . time ( ) [EOL] [EOL] def on_stream_event_in ( self , tp , offset , stream , event ) : [EOL] [docstring] [EOL] self . events_total += [number] [EOL] self . stream_inbound_time [ tp ] = monotonic ( ) [EOL] self . events_by_stream [ str ( stream ) ] += [number] [EOL] self . events_by_task [ str ( stream . task_owner ) ] += [number] [EOL] self . events_active += [number] [EOL] return { [string] : self . time ( ) , [string] : None , [string] : None , } [EOL] [EOL] def on_stream_event_out ( self , tp , offset , stream , event , state = None ) : [EOL] [docstring] [EOL] if state is not None : [EOL] time_out = self . time ( ) [EOL] time_in = state [ [string] ] [EOL] time_total = time_out - time_in [EOL] self . events_active -= [number] [EOL] state . update ( time_out = time_out , time_total = time_total , ) [EOL] deque_pushpopmax ( self . events_runtime , time_total , self . max_avg_history ) [EOL] [EOL] def on_topic_buffer_full ( self , tp ) : [EOL] [docstring] [EOL] self . topic_buffer_full [ tp ] += [number] [EOL] [EOL] def on_message_out ( self , tp , offset , message ) : [EOL] [docstring] [EOL] self . messages_active -= [number] [EOL] time_out = message . time_out = self . time ( ) [EOL] time_in = message . time_in [EOL] if time_in is not None : [EOL] message . time_total = time_out - time_in [EOL] [EOL] def on_table_get ( self , table , key ) : [EOL] [docstring] [EOL] self . _table_or_create ( table ) . keys_retrieved += [number] [EOL] [EOL] def on_table_set ( self , table , key , value ) : [EOL] [docstring] [EOL] self . _table_or_create ( table ) . keys_updated += [number] [EOL] [EOL] def on_table_del ( self , table , key ) : [EOL] [docstring] [EOL] self . _table_or_create ( table ) . keys_deleted += [number] [EOL] [EOL] def _table_or_create ( self , table ) : [EOL] try : [EOL] return self . tables [ table . name ] [EOL] except KeyError : [EOL] state = self . tables [ table . name ] = TableState ( table ) [EOL] return state [EOL] [EOL] def on_commit_initiated ( self , consumer ) : [EOL] [docstring] [EOL] return self . time ( ) [EOL] [EOL] def on_commit_completed ( self , consumer , state ) : [EOL] [docstring] [EOL] latency = self . time ( ) - cast ( float , state ) [EOL] deque_pushpopmax ( self . commit_latency , latency , self . max_commit_latency_history , ) [EOL] [EOL] def on_send_initiated ( self , producer , topic , message , keysize , valsize ) : [EOL] [docstring] [EOL] self . messages_sent += [number] [EOL] self . messages_sent_by_topic [ topic ] += [number] [EOL] return self . time ( ) [EOL] [EOL] def on_send_completed ( self , producer , state , metadata ) : [EOL] [docstring] [EOL] latency = self . time ( ) - cast ( float , state ) [EOL] deque_pushpopmax ( self . send_latency , latency , self . max_send_latency_history ) [EOL] [EOL] def on_send_error ( self , producer , exc , state ) : [EOL] [docstring] [EOL] self . send_errors += [number] [EOL] [EOL] def count ( self , metric_name , count = [number] ) : [EOL] [docstring] [EOL] self . metric_counts [ metric_name ] += count [EOL] [EOL] def on_tp_commit ( self , tp_offsets ) : [EOL] [docstring] [EOL] self . tp_committed_offsets . update ( tp_offsets ) [EOL] [EOL] def track_tp_end_offset ( self , tp , offset ) : [EOL] [docstring] [EOL] self . tp_end_offsets [ tp ] = offset [EOL] [EOL] def on_assignment_start ( self , assignor ) : [EOL] [docstring] [EOL] return { [string] : self . time ( ) } [EOL] [EOL] def on_assignment_error ( self , assignor , state , exc ) : [EOL] [docstring] [EOL] time_total = self . time ( ) - state [ [string] ] [EOL] deque_pushpopmax ( self . assignment_latency , time_total , self . max_assignment_latency_history ) [EOL] self . assignments_failed += [number] [EOL] [EOL] def on_assignment_completed ( self , assignor , state ) : [EOL] [docstring] [EOL] time_total = self . time ( ) - state [ [string] ] [EOL] deque_pushpopmax ( self . assignment_latency , time_total , self . max_assignment_latency_history ) [EOL] self . assignments_completed += [number] [EOL] [EOL] def on_rebalance_start ( self , app ) : [EOL] [docstring] [EOL] self . rebalances = app . rebalancing_count [EOL] return { [string] : self . time ( ) } [EOL] [EOL] def on_rebalance_return ( self , app , state ) : [EOL] [docstring] [EOL] time_start = state [ [string] ] [EOL] time_return = self . time ( ) [EOL] latency_return = time_return - time_start [EOL] state . update ( time_return = time_return , latency_return = latency_return , ) [EOL] deque_pushpopmax ( self . rebalance_return_latency , latency_return , self . max_avg_history ) [EOL] [EOL] def on_rebalance_end ( self , app , state ) : [EOL] [docstring] [EOL] time_start = state [ [string] ] [EOL] time_end = self . time ( ) [EOL] latency_end = time_end - time_start [EOL] state . update ( time_end = time_end , latency_end = latency_end , ) [EOL] deque_pushpopmax ( self . rebalance_end_latency , latency_end , self . max_avg_history ) [EOL] [EOL] def on_web_request_start ( self , app , request , * , view = None ) : [EOL] [docstring] [EOL] return { [string] : self . time ( ) } [EOL] [EOL] def on_web_request_end ( self , app , request , response , state , * , view = None ) : [EOL] [docstring] [EOL] status_code = HTTPStatus ( response . status if response else [number] ) [EOL] time_start = state [ [string] ] [EOL] time_end = self . time ( ) [EOL] latency_end = time_end - time_start [EOL] state . update ( time_end = time_end , latency_end = latency_end , status_code = status_code , ) [EOL] deque_pushpopmax ( self . http_response_latency , latency_end , self . max_avg_history ) [EOL] self . http_response_codes [ status_code ] += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.CollectionT$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 0 0 $TableState$ 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 $faust.types.CollectionT$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $faust.types.transports.ConsumerT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ConsumerT$ 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.str$ 0 $faust.types.tuples.PendingMessage$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ProducerT$ 0 $typing.Any$ 0 $faust.types.tuples.RecordMetadata$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.transports.ProducerT$ 0 $builtins.BaseException$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $TPOffsetMapping$ 0 0 0 0 0 0 0 0 0 0 0 $TPOffsetMapping$ 0 0 0 0 $None$ 0 0 0 $faust.types.tuples.TP$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $faust.types.tuples.TP$ 0 0 $builtins.int$ 0 0 0 $typing.Dict$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 $builtins.BaseException$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.assignor.PartitionAssignorT$ 0 $typing.Dict$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $faust.types.AppT$ 0 0 0 0 0 0 0 $builtins.int$ 0 $faust.types.AppT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $typing.Dict$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 0 0 $faust.web.View$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $faust.types.AppT$ 0 $faust.web.Request$ 0 $typing.Optional[faust.web.Response]$ 0 $typing.Dict$ 0 0 0 $faust.web.View$ 0 0 0 0 0 0 0 $http.HTTPStatus$ 0 0 0 $typing.Optional[faust.web.Response]$ 0 0 0 $typing.Optional[faust.web.Response]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $http.HTTPStatus$ 0 $http.HTTPStatus$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $http.HTTPStatus$ 0 0 0 0
	0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] import random [EOL] from datetime import datetime , timezone [EOL] from itertools import count [EOL] import faust [EOL] from faust . cli import option [EOL] [EOL] [EOL] class Withdrawal ( faust . Record , isodates = True , serializer = [string] ) : [EOL] user = ... [EOL] country = ... [EOL] amount = ... [EOL] date = None [EOL] [EOL] [EOL] app = faust . App ( [string] , version = [number] , broker = [string] , store = [string] , origin = [string] , topic_partitions = [number] , ) [EOL] withdrawals_topic = app . topic ( [string] , value_type = Withdrawal ) [EOL] [EOL] user_to_total = app . Table ( [string] , default = int , ) . tumbling ( [number] ) . relative_to_stream ( ) [EOL] [EOL] country_to_total = app . Table ( [string] , default = int , ) . tumbling ( [number] , expires = [number] ) . relative_to_stream ( ) [EOL] [EOL] [EOL] @ app . agent ( withdrawals_topic ) async def track_user_withdrawal ( withdrawals ) : [EOL] async for withdrawal in withdrawals : [EOL] user_to_total [ withdrawal . user ] += withdrawal . amount [EOL] [EOL] [EOL] @ app . agent ( ) async def track_country_withdrawal ( withdrawals ) : [EOL] async for withdrawal in withdrawals . group_by ( Withdrawal . country ) : [EOL] country_to_total [ withdrawal . country ] += withdrawal . amount [EOL] [EOL] [EOL] @ app . command ( option ( [string] , type = float , default = [number] , envvar = [string] , help = [string] ) , option ( [string] , type = int , default = None , help = [string] ) , ) async def produce ( self , max_latency , max_messages ) : [EOL] [docstring] [EOL] for i , withdrawal in enumerate ( generate_withdrawals ( max_messages ) ) : [EOL] await withdrawals_topic . send ( key = withdrawal . user , value = withdrawal ) [EOL] if not i % [number] : [EOL] self . say ( f' [string] { i }' ) [EOL] if max_latency : [EOL] await asyncio . sleep ( random . uniform ( [number] , max_latency ) ) [EOL] [EOL] [EOL] def generate_withdrawals_dict ( n = None ) : [EOL] num_countries = [number] [EOL] countries = [ f' [string] { i }' for i in range ( num_countries ) ] [EOL] country_dist = [ [number] ] + ( [ [number] / num_countries ] * ( num_countries - [number] ) ) [EOL] num_users = [number] [EOL] users = [ f' [string] { i }' for i in range ( num_users ) ] [EOL] for _ in range ( n ) if n is not None else count ( ) : [EOL] yield { [string] : random . choice ( users ) , [string] : random . uniform ( [number] , [number] ) , [string] : random . choices ( countries , country_dist ) [ [number] ] , [string] : datetime . utcnow ( ) . replace ( tzinfo = timezone . utc ) . isoformat ( ) , } [EOL] [EOL] [EOL] def generate_withdrawals ( n = None ) : [EOL] for d in generate_withdrawals_dict ( n ) : [EOL] yield Withdrawal ( ** d ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from datetime import datetime , timedelta [EOL] from time import time [EOL] import random [EOL] import faust [EOL] [EOL] [EOL] class RawModel ( faust . Record ) : [EOL] date = ... [EOL] value = ... [EOL] [EOL] [EOL] class AggModel ( faust . Record ) : [EOL] date = ... [EOL] count = ... [EOL] mean = ... [EOL] [EOL] [EOL] TOPIC = [string] [EOL] SINK = [string] [EOL] TABLE = [string] [EOL] KAFKA = [string] [EOL] CLEANUP_INTERVAL = [number] [EOL] WINDOW = [number] [EOL] WINDOW_EXPIRES = [number] [EOL] PARTITIONS = [number] [EOL] [EOL] app = faust . App ( [string] , broker = KAFKA , version = [number] , topic_partitions = [number] ) [EOL] [EOL] app . conf . table_cleanup_interval = CLEANUP_INTERVAL [EOL] source = app . topic ( TOPIC , value_type = RawModel ) [EOL] sink = app . topic ( SINK , value_type = AggModel ) [EOL] [EOL] [EOL] def window_processor ( key , events ) : [EOL] timestamp = key [ [number] ] [ [number] ] [EOL] values = [ event . value for event in events ] [EOL] count = len ( values ) [EOL] mean = sum ( values ) / count [EOL] [EOL] print ( f' [string] ' f'{ len ( values ) } [string] ' f' [string] { mean : [string] } [string] ' f' [string] { timestamp }' , ) [EOL] [EOL] sink . send_soon ( value = AggModel ( date = timestamp , count = count , mean = mean ) ) [EOL] [EOL] [EOL] tumbling_table = ( app . Table ( TABLE , default = list , partitions = PARTITIONS , on_window_close = window_processor , ) . tumbling ( WINDOW , expires = timedelta ( seconds = WINDOW_EXPIRES ) ) . relative_to_field ( RawModel . date ) ) [EOL] [EOL] [EOL] @ app . agent ( source ) async def print_windowed_events ( stream ) : [EOL] async for event in stream : [EOL] value_list = tumbling_table [ [string] ] . value ( ) [EOL] value_list . append ( event ) [EOL] tumbling_table [ [string] ] = value_list [EOL] [EOL] [EOL] @ app . timer ( [number] ) async def produce ( ) : [EOL] await source . send ( value = RawModel ( value = random . random ( ) , date = int ( time ( ) ) ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
	0
from django . apps import AppConfig [EOL] [EOL] [EOL] class FaustappConfig ( AppConfig ) : [EOL] name = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from django . conf . urls import url [EOL] from django . contrib import admin [EOL] [EOL] urlpatterns = [ url ( [string] , admin . site . urls ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] from django . core . wsgi import get_wsgi_application [EOL] [EOL] os . environ . setdefault ( [string] , [string] ) [EOL] [EOL] application = get_wsgi_application ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
import os [EOL] import sys [EOL] os . environ . setdefault ( [string] , [string] ) [EOL] from django . core . management import execute_from_command_line [comment] [EOL] execute_from_command_line ( sys . argv ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from django . apps import AppConfig [EOL] [EOL] [EOL] class AccountsConfig ( AppConfig ) : [EOL] name = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Any [EOL] import typing [EOL] import examples [EOL] import pytz [EOL] from random import random [EOL] from datetime import datetime [EOL] import faust [EOL] import pytz [EOL] [EOL] app = faust . App ( [string] , broker = [string] ) [EOL] pacific = pytz . timezone ( [string] ) [EOL] [EOL] [EOL] class Model ( faust . Record , serializer = [string] ) : [EOL] random = ... [EOL] [EOL] [EOL] tz_aware_topic = app . topic ( [string] , value_type = Model ) [EOL] [EOL] [EOL] @ app . agent ( tz_aware_topic ) async def consume ( stream ) : [EOL] async for record in stream : [EOL] print ( f' [string] { record }' ) [EOL] [EOL] [EOL] @ app . crontab ( [string] , tz = pacific , on_leader = True ) async def publish_at_8_20_pm_pacific ( ) : [EOL] print ( [string] ) [EOL] print ( f' [string] { datetime . now ( ) }' ) [EOL] msg = Model ( random = round ( random ( ) , [number] ) ) [EOL] await tz_aware_topic . send ( value = msg ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import faust [EOL] TOPIC = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] app = faust . App ( [string] , broker = [string] ) [EOL] table = app . Table ( [string] , default = int ) [EOL] [EOL] [EOL] class Score ( faust . Record , serializer = [string] ) : [EOL] index = ... [EOL] value = ... [EOL] [EOL] [EOL] test_topic = app . topic ( TOPIC , value_type = Score ) [EOL] [EOL] [EOL] def get_score_key ( score ) : [EOL] return f' [string] { score . index % [number] }' [EOL] [EOL] [EOL] @ app . agent ( test_topic ) async def print_totals ( stream ) : [EOL] async for score in stream . group_by ( get_score_key , name = [string] ) : [EOL] ind = f' [string] { score . index % [number] }' [EOL] table [ [string] ] += [number] [EOL] table [ ind ] += [number] [EOL] print ( f' [string] { table [ [string] ] } [string] { ind } [string] { table [ ind ] }' ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import examples [EOL] from random import random [EOL] from datetime import timedelta [EOL] import faust [EOL] [EOL] app = faust . App ( [string] , broker = [string] ) [EOL] [EOL] [EOL] class Model ( faust . Record , serializer = [string] ) : [EOL] random = ... [EOL] [EOL] [EOL] TOPIC = [string] [EOL] [EOL] hopping_topic = app . topic ( TOPIC , value_type = Model ) [EOL] hopping_table = app . Table ( [string] , default = int ) . hopping ( [number] , [number] , expires = timedelta ( minutes = [number] ) ) [EOL] [EOL] [EOL] @ app . agent ( hopping_topic ) async def print_windowed_events ( stream ) : [EOL] async for _ in stream : [comment] [EOL] hopping_table [ [string] ] += [number] [EOL] value = hopping_table [ [string] ] [EOL] print ( f' [string] ' ) [EOL] print ( f' [string] { value . now ( ) }' ) [EOL] print ( f' [string] { value . current ( ) }' ) [EOL] print ( f' [string] { value . value ( ) }' ) [EOL] print ( f' [string] ' f'{ value . delta ( [number] ) }' ) [EOL] [EOL] [EOL] @ app . timer ( [number] , on_leader = True ) async def publish_every_2secs ( ) : [EOL] msg = Model ( random = round ( random ( ) , [number] ) ) [EOL] await hopping_topic . send ( value = msg ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import examples [EOL] from random import random [EOL] from datetime import timedelta [EOL] import faust [EOL] [EOL] app = faust . App ( [string] , broker = [string] ) [EOL] [EOL] [EOL] class Model ( faust . Record , serializer = [string] ) : [EOL] random = ... [EOL] [EOL] [EOL] TOPIC = [string] [EOL] [EOL] tumbling_topic = app . topic ( TOPIC , value_type = Model ) [EOL] tumbling_table = app . Table ( [string] , default = int ) . tumbling ( [number] , expires = timedelta ( minutes = [number] ) ) [EOL] [EOL] [EOL] @ app . agent ( tumbling_topic ) async def print_windowed_events ( stream ) : [EOL] async for _ in stream : [comment] [EOL] tumbling_table [ [string] ] += [number] [EOL] [EOL] value = tumbling_table [ [string] ] [EOL] [EOL] print ( [string] ) [EOL] print ( f' [string] { value . now ( ) }' ) [EOL] print ( f' [string] { value . current ( ) }' ) [EOL] print ( f' [string] { value . value ( ) }' ) [EOL] print ( [string] f'{ value . delta ( [number] ) }' ) [EOL] [EOL] [EOL] @ app . timer ( [number] , on_leader = True ) async def publish_every_2secs ( ) : [EOL] msg = Model ( random = round ( random ( ) , [number] ) ) [EOL] await tumbling_topic . send ( value = msg ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0