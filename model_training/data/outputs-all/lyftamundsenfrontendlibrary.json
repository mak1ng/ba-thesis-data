[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import os [EOL] import subprocess [EOL] [EOL] from setuptools import setup , find_packages [EOL] [EOL] BASE_DIR = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] PACKAGE_DIR = os . path . join ( BASE_DIR , [string] , [string] ) [EOL] [EOL] [EOL] def is_npm_installed ( ) : [EOL] try : [EOL] subprocess . check_call ( [ [string] ] , shell = True ) [EOL] return True [EOL] except Exception as e : [EOL] return False [EOL] [EOL] [EOL] def build_js ( ) : [EOL] if not is_npm_installed ( ) : [EOL] logging . error ( [string] ) [EOL] [EOL] try : [EOL] subprocess . check_call ( [ [string] ] , cwd = PACKAGE_DIR , shell = True ) [EOL] subprocess . check_call ( [ [string] ] , cwd = PACKAGE_DIR , shell = True ) [EOL] except Exception as e : [EOL] logging . warn ( [string] ) [EOL] logging . warn ( str ( e ) ) [EOL] [EOL] [EOL] build_js ( ) [EOL] [EOL] requirements_path = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) [EOL] with open ( requirements_path ) as requirements_file : [EOL] requirements = requirements_file . readlines ( ) [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] setup ( name = [string] , version = __version__ , description = [string] , url = [string] , maintainer = [string] , maintainer_email = [string] , packages = find_packages ( exclude = [ [string] ] ) , include_package_data = True , dependency_links = [ ] , install_requires = requirements , extras_require = { [string] : [ [string] ] } , python_requires = [string] , entry_points = [string] , classifiers = [ [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Optional , Type [EOL] import amundsen_application [EOL] import flask [EOL] import typing [EOL] from typing import Dict , Optional [EOL] from flask import Flask [EOL] from amundsen_application . config import LocalConfig [EOL] from amundsen_application . models . user import load_user , User [EOL] [EOL] [EOL] def get_access_headers ( app ) : [EOL] [docstring] [EOL] try : [EOL] access_token = app . oidc . get_access_token ( ) [EOL] return { [string] : [string] . format ( access_token ) } [EOL] except Exception : [EOL] return None [EOL] [EOL] [EOL] def get_auth_user ( app ) : [EOL] [docstring] [EOL] from flask import g [EOL] user_info = load_user ( g . oidc_id_token ) [EOL] return user_info [EOL] [EOL] [EOL] class OidcConfig ( LocalConfig ) : [EOL] AUTH_USER_METHOD = get_auth_user [EOL] REQUEST_HEADERS_METHOD = get_access_headers [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import os [EOL] from amundsen_application import create_app [EOL] [EOL] application = create_app ( config_module_class = os . getenv ( [string] ) or [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] application . run ( host = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Optional [EOL] import builtins [EOL] import amundsen_common [EOL] import typing [EOL] from typing import Dict , Optional [EOL] [EOL] from amundsen_common . models . user import UserSchema , User [EOL] from flask import current_app as app [EOL] from marshmallow import ValidationError [EOL] [EOL] [EOL] def _str_no_value ( s ) : [EOL] [comment] [EOL] if not s : [EOL] return True [EOL] if len ( s . strip ( ) ) == [number] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def load_user ( user_data ) : [EOL] try : [EOL] schema = UserSchema ( ) [EOL] [comment] [EOL] if _str_no_value ( user_data . get ( [string] ) ) : [EOL] user_data [ [string] ] = user_data . get ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if _str_no_value ( user_data . get ( [string] ) ) and app . config [ [string] ] : [EOL] user_data [ [string] ] = app . config [ [string] ] ( user_data [ [string] ] ) [EOL] data , errors = schema . load ( user_data ) [EOL] return data [EOL] except ValidationError as err : [EOL] return err . messages [EOL] [EOL] [EOL] def dump_user ( user ) : [EOL] schema = UserSchema ( ) [EOL] try : [EOL] data , errors = schema . dump ( user ) [EOL] return data [EOL] except ValidationError as err : [EOL] return err . messages [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Type [EOL] import builtins [EOL] import amundsen_application [EOL] import typing [EOL] from marshmallow import Schema , fields , post_dump [EOL] from marshmallow . exceptions import ValidationError [EOL] [EOL] from typing import Dict , List [EOL] [EOL] [EOL] class Post : [EOL] def __init__ ( self , date , title , html_content ) : [EOL] self . date = date [EOL] self . html_content = html_content [EOL] self . title = title [EOL] [EOL] [EOL] class PostSchema ( Schema ) : [EOL] date = fields . Str ( required = True ) [EOL] title = fields . Str ( required = True ) [EOL] html_content = fields . Str ( required = True ) [EOL] [EOL] [EOL] class Announcements : [EOL] def __init__ ( self , posts = [ ] ) : [EOL] self . posts = posts [EOL] [EOL] [EOL] class AnnouncementsSchema ( Schema ) : [EOL] posts = fields . Nested ( PostSchema , many = True ) [EOL] [EOL] @ post_dump def validate_data ( self , data ) : [EOL] posts = data . get ( [string] , [ ] ) [EOL] for post in posts : [EOL] if post . get ( [string] ) is None : [EOL] raise ValidationError ( [string] ) [EOL] if post . get ( [string] ) is None : [EOL] raise ValidationError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict$ 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Type [EOL] import builtins [EOL] import amundsen_application [EOL] import typing [EOL] from marshmallow import Schema , fields [EOL] from typing import List [EOL] [EOL] [EOL] class ColumnItem : [EOL] def __init__ ( self , column_name = None , column_type = None ) : [EOL] self . column_name = column_name [EOL] self . column_type = column_type [EOL] [EOL] [EOL] class ColumnItemSchema ( Schema ) : [EOL] column_name = fields . Str ( ) [EOL] column_type = fields . Str ( ) [EOL] [EOL] [EOL] class PreviewData : [EOL] def __init__ ( self , columns = [ ] , data = [ ] , error_text = [string] ) : [EOL] self . columns = columns [EOL] self . data = data [EOL] self . error_text = error_text [EOL] [EOL] [EOL] class PreviewDataSchema ( Schema ) : [EOL] columns = fields . Nested ( ColumnItemSchema , many = True ) [EOL] data = fields . List ( fields . Dict , many = True ) [EOL] error_text = fields . Str ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List [EOL] import builtins [EOL] import amundsen_application [EOL] import typing [EOL] from amundsen_application . models . data_issue import DataIssue [EOL] from typing import List , Dict [EOL] [EOL] [EOL] class IssueResults : [EOL] def __init__ ( self , issues , total , all_issues_url ) : [EOL] [docstring] [EOL] self . issues = issues [EOL] self . total = total [EOL] self . all_issues_url = all_issues_url [EOL] [EOL] def serialize ( self ) : [EOL] return { [string] : [ issue . serialize ( ) for issue in self . issues ] , [string] : self . total , [string] : self . all_issues_url } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import Dict [EOL] import builtins [EOL] import typing [EOL] PRIORITY_MAP = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] class DataIssue : [EOL] def __init__ ( self , issue_key , title , url , status , priority ) : [EOL] self . issue_key = issue_key [EOL] self . title = title [EOL] self . url = url [EOL] self . status = status [EOL] if priority in PRIORITY_MAP : [EOL] self . priority_display_name = PRIORITY_MAP [ priority ] [EOL] self . priority_name = priority . lower ( ) [EOL] else : [EOL] self . priority_display_name = None [comment] [EOL] self . priority_name = None [comment] [EOL] [EOL] def serialize ( self ) : [EOL] return { [string] : self . issue_key , [string] : self . title , [string] : self . url , [string] : self . status , [string] : self . priority_name , [string] : self . priority_display_name } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] import amundsen_application [EOL] import abc [EOL] from amundsen_application . models . data_issue import DataIssue [EOL] from amundsen_application . models . issue_results import IssueResults [EOL] [EOL] [EOL] class BaseIssueTrackerClient ( abc . ABC ) : [EOL] @ abc . abstractmethod def __init__ ( self ) : [EOL] pass [comment] [EOL] [EOL] @ abc . abstractmethod def get_issues ( self , table_uri ) : [EOL] [docstring] [EOL] raise NotImplementedError [comment] [EOL] [EOL] @ abc . abstractmethod def create_issue ( self , table_uri , title , description ) : [EOL] [docstring] [EOL] raise NotImplementedError [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.issue_results.IssueResults$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from abc import ABCMeta , abstractmethod [EOL] [EOL] [EOL] class BasePreview ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def get_preview_image ( self , * , uri ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import amundsen_application [EOL] import typing [EOL] from random import randint [EOL] from datetime import datetime , timedelta [EOL] [EOL] from amundsen_application . models . announcements import Announcements , Post [EOL] from amundsen_application . base . base_announcement_client import BaseAnnouncementClient [EOL] [EOL] try : [EOL] from sqlalchemy import Column , Integer , String , DateTime , create_engine [EOL] from sqlalchemy . ext . declarative import declarative_base [EOL] from sqlalchemy . orm import sessionmaker [EOL] except ModuleNotFoundError : [EOL] pass [EOL] [EOL] Base = declarative_base ( ) [EOL] [EOL] [EOL] class DBAnnouncement ( Base ) : [comment] [EOL] __tablename__ = [string] [EOL] [EOL] id = Column ( Integer , primary_key = True ) [EOL] [EOL] date = Column ( DateTime ) [EOL] title = Column ( String ) [EOL] content = Column ( String ) [EOL] [EOL] [EOL] class SQLAlchemyAnnouncementClient ( BaseAnnouncementClient ) : [EOL] def __init__ ( self ) : [EOL] self . _setup_mysql ( ) [EOL] [EOL] def _setup_mysql ( self ) : [EOL] self . engine = create_engine ( [string] , echo = True ) [EOL] [EOL] session = sessionmaker ( bind = self . engine ) ( ) [EOL] [EOL] [comment] [EOL] if not self . engine . dialect . has_table ( self . engine , DBAnnouncement . __tablename__ ) : [EOL] Base . metadata . create_all ( self . engine ) [EOL] [EOL] announcements = [ ] [EOL] [EOL] dummy_announcement = [string] [EOL] [EOL] for i in range ( randint ( [number] , [number] ) ) : [EOL] announcement = DBAnnouncement ( id = i + [number] , date = datetime . now ( ) + timedelta ( days = i + [number] ) , title = f' [string] { i + [number] }' , content = dummy_announcement ) [EOL] [EOL] announcements . append ( announcement ) [EOL] [EOL] session . add_all ( announcements ) [EOL] session . commit ( ) [EOL] [EOL] def get_posts ( self ) : [EOL] [docstring] [EOL] session = sessionmaker ( bind = self . engine ) ( ) [EOL] [EOL] posts = [ ] [EOL] [EOL] for row in session . query ( DBAnnouncement ) . order_by ( DBAnnouncement . date . desc ( ) ) : [EOL] post = Post ( title = row . title , date = row . date . strftime ( [string] ) , html_content = row . content ) [EOL] posts . append ( post ) [EOL] [EOL] return Announcements ( posts ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Type[amundsen_application.base.examples.example_announcement_client.DBAnnouncement]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.base.examples.example_announcement_client.DBAnnouncement]$ 0 0 0 0 0 0 $typing.Type[amundsen_application.base.examples.example_announcement_client.DBAnnouncement]$ 0 0 0 0 0 0 $typing.Type[amundsen_application.base.examples.example_announcement_client.DBAnnouncement]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $amundsen_application.models.announcements.Announcements$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.announcements.Post$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.announcements.Post$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.announcements.Post$ 0 0 0 $amundsen_application.models.announcements.Post$ 0 0 0 0 0 0 $amundsen_application.models.announcements.Post$ 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Tuple , Any , List [EOL] import email [EOL] import smtplib [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] import logging [EOL] import os [EOL] import smtplib [EOL] [EOL] from email . mime . multipart import MIMEMultipart [EOL] from email . mime . text import MIMEText [EOL] from http import HTTPStatus [EOL] from typing import Dict , List [EOL] [EOL] from flask import Response , jsonify , make_response [EOL] [EOL] from amundsen_application . base . base_mail_client import BaseMailClient [EOL] [EOL] [EOL] [comment] [EOL] class MailClient ( BaseMailClient ) : [EOL] def __init__ ( self , recipients ) : [EOL] self . recipients = recipients [EOL] [EOL] def send_email ( self , html , subject , optional_data = None , recipients = None , sender = None ) : [EOL] if not sender : [EOL] sender = os . environ . get ( [string] ) or [string] [comment] [EOL] if not recipients : [EOL] recipients = self . recipients [EOL] [EOL] sender_pass = os . environ . get ( [string] ) or [string] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] msg = MIMEMultipart ( [string] ) [EOL] msg [ [string] ] = subject [EOL] msg [ [string] ] = sender [EOL] msg [ [string] ] = [string] . join ( recipients ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] msg . attach ( MIMEText ( html , [string] ) ) [EOL] [EOL] s = smtplib . SMTP ( [string] ) [EOL] try : [EOL] s . connect ( [string] , [number] ) [EOL] s . ehlo ( ) [EOL] s . starttls ( ) [EOL] s . ehlo ( ) [EOL] s . login ( sender , sender_pass ) [EOL] message = s . send_message ( msg ) [EOL] payload = jsonify ( { [string] : message } ) [EOL] s . quit ( ) [EOL] return make_response ( payload , HTTPStatus . OK ) [EOL] except Exception as e : [EOL] err_message = [string] + str ( e ) [EOL] logging . exception ( err_message ) [EOL] payload = jsonify ( { [string] : err_message } ) [EOL] s . quit ( ) [EOL] return make_response ( payload , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 $builtins.str$ 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,builtins.bytes]]$ 0 $smtplib.SMTP$ 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,builtins.bytes]]$ 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [EOL] class MailClientNotImplemented ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import logging [EOL] import flask [EOL] import typing [EOL] import logging [EOL] [EOL] from http import HTTPStatus [EOL] [EOL] from flask import Response , jsonify , make_response [EOL] from flask import current_app as app [EOL] from flask . blueprints import Blueprint [EOL] [EOL] from amundsen_application . api . metadata . v0 import USER_ENDPOINT [EOL] from amundsen_application . api . utils . request_utils import request_metadata [EOL] from amundsen_application . models . user import load_user , dump_user [EOL] [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] blueprint = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def current_user ( ) : [EOL] try : [EOL] if app . config [ [string] ] : [EOL] user = app . config [ [string] ] ( app ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] url = [string] . format ( app . config [ [string] ] , USER_ENDPOINT , user . user_id ) [EOL] [EOL] response = request_metadata ( url = url ) [EOL] status_code = response . status_code [EOL] if status_code == HTTPStatus . OK : [EOL] message = [string] [EOL] else : [EOL] message = [string] . format ( user . user_id ) [EOL] logging . error ( message ) [EOL] [EOL] payload = { [string] : message , [string] : dump_user ( load_user ( response . json ( ) ) ) } [EOL] return make_response ( jsonify ( payload ) , status_code ) [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] payload = jsonify ( { [string] : message } ) [EOL] return make_response ( payload , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Literal , Any , Union [EOL] import builtins [EOL] import typing_extensions [EOL] import flask [EOL] import typing [EOL] from typing import Any , Tuple [EOL] [EOL] from flask import Flask , render_template [EOL] import os [EOL] [EOL] ENVIRONMENT = os . getenv ( [string] , [string] ) [EOL] [EOL] [EOL] def init_routes ( app ) : [EOL] app . add_url_rule ( [string] , [string] , healthcheck ) [EOL] app . add_url_rule ( [string] , [string] , index , defaults = { [string] : [string] } ) [comment] [EOL] app . add_url_rule ( [string] , [string] , index ) [comment] [EOL] [EOL] [EOL] def index ( path ) : [EOL] return render_template ( [string] , env = ENVIRONMENT ) [comment] [EOL] [EOL] [EOL] def healthcheck ( ) : [EOL] return [string] , [number] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Union [EOL] import http [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import flask [EOL] import logging [EOL] import json [EOL] [EOL] from http import HTTPStatus [EOL] [EOL] from typing import Any , Dict [comment] [EOL] [EOL] from flask import Response , jsonify , make_response , request [EOL] from flask import current_app as app [EOL] from flask . blueprints import Blueprint [EOL] [EOL] from amundsen_application . log . action_log import action_logging [EOL] from amundsen_application . api . utils . metadata_utils import marshall_dashboard_partial [EOL] from amundsen_application . api . utils . request_utils import get_query_param , request_search [EOL] from amundsen_application . api . utils . search_utils import generate_query_json , has_filters , map_table_result , transform_filters [EOL] from amundsen_application . models . user import load_user , dump_user [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] REQUEST_SESSION_TIMEOUT_SEC = [number] [EOL] [EOL] search_blueprint = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] SEARCH_DASHBOARD_ENDPOINT = [string] [EOL] SEARCH_DASHBOARD_FILTER_ENDPOINT = [string] [EOL] SEARCH_TABLE_ENDPOINT = [string] [EOL] SEARCH_TABLE_FILTER_ENDPOINT = [string] [EOL] SEARCH_USER_ENDPOINT = [string] [EOL] [EOL] [EOL] @ search_blueprint . route ( [string] , methods = [ [string] ] ) def search_table ( ) : [EOL] [docstring] [EOL] try : [EOL] request_json = request . get_json ( ) [EOL] [EOL] search_term = get_query_param ( request_json , [string] , [string] ) [EOL] page_index = get_query_param ( request_json , [string] , [string] ) [EOL] [EOL] search_type = request_json . get ( [string] ) [EOL] [EOL] transformed_filters = transform_filters ( filters = request_json . get ( [string] , { } ) , resource = [string] ) [EOL] [EOL] results_dict = _search_table ( filters = transformed_filters , search_term = search_term , page_index = page_index , search_type = search_type ) [EOL] return make_response ( jsonify ( results_dict ) , results_dict . get ( [string] , HTTPStatus . INTERNAL_SERVER_ERROR ) ) [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( results_dict ) , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] [EOL] @ action_logging def _search_table ( * , search_term , page_index , filters , search_type ) : [EOL] [docstring] [EOL] [comment] [EOL] tables = { [string] : int ( page_index ) , [string] : [ ] , [string] : [number] , } [EOL] [EOL] results_dict = { [string] : search_term , [string] : [string] , [string] : tables , } [EOL] [EOL] try : [EOL] if has_filters ( filters = filters , resource = [string] ) : [EOL] query_json = generate_query_json ( filters = filters , page_index = page_index , search_term = search_term ) [EOL] url_base = app . config [ [string] ] + SEARCH_TABLE_FILTER_ENDPOINT [EOL] response = request_search ( url = url_base , headers = { [string] : [string] } , method = [string] , data = json . dumps ( query_json ) ) [EOL] else : [EOL] url_base = app . config [ [string] ] + SEARCH_TABLE_ENDPOINT [EOL] url = f'{ url_base } [string] { search_term } [string] { page_index }' [EOL] response = request_search ( url = url ) [EOL] [EOL] status_code = response . status_code [EOL] if status_code == HTTPStatus . OK : [EOL] results_dict [ [string] ] = [string] [EOL] results = response . json ( ) . get ( [string] ) [EOL] tables [ [string] ] = [ map_table_result ( result ) for result in results ] [EOL] tables [ [string] ] = response . json ( ) . get ( [string] ) [EOL] else : [EOL] message = [string] [EOL] results_dict [ [string] ] = message [EOL] logging . error ( message ) [EOL] [EOL] results_dict [ [string] ] = status_code [EOL] return results_dict [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] results_dict [ [string] ] = message [EOL] logging . exception ( message ) [EOL] return results_dict [EOL] [EOL] [EOL] @ search_blueprint . route ( [string] , methods = [ [string] ] ) def search_user ( ) : [EOL] [docstring] [EOL] try : [EOL] search_term = get_query_param ( request . args , [string] , [string] ) [EOL] page_index = get_query_param ( request . args , [string] , [string] ) [EOL] search_type = request . args . get ( [string] ) [EOL] [EOL] results_dict = _search_user ( search_term = search_term , page_index = int ( page_index ) , search_type = search_type ) [EOL] [EOL] return make_response ( jsonify ( results_dict ) , results_dict . get ( [string] , HTTPStatus . INTERNAL_SERVER_ERROR ) ) [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( results_dict ) , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] [EOL] @ action_logging def _search_user ( * , search_term , page_index , search_type ) : [EOL] [docstring] [EOL] [EOL] def _map_user_result ( result ) : [EOL] user_result = dump_user ( load_user ( result ) ) [EOL] user_result [ [string] ] = [string] [EOL] return user_result [EOL] [EOL] users = { [string] : page_index , [string] : [ ] , [string] : [number] , } [EOL] [EOL] results_dict = { [string] : search_term , [string] : [string] , [string] : HTTPStatus . OK , [string] : users , } [EOL] [EOL] try : [EOL] url_base = app . config [ [string] ] + SEARCH_USER_ENDPOINT [EOL] url = f'{ url_base } [string] { search_term } [string] { page_index }' [EOL] [EOL] response = request_search ( url = url ) [EOL] status_code = response . status_code [EOL] [EOL] if status_code == HTTPStatus . OK : [EOL] results_dict [ [string] ] = [string] [EOL] results = response . json ( ) . get ( [string] , list ( ) ) [EOL] users [ [string] ] = [ _map_user_result ( result ) for result in results ] [EOL] users [ [string] ] = response . json ( ) . get ( [string] , [number] ) [EOL] else : [EOL] message = [string] [EOL] results_dict [ [string] ] = message [EOL] logging . error ( message ) [EOL] [EOL] results_dict [ [string] ] = status_code [EOL] return results_dict [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] results_dict [ [string] ] = message [EOL] results_dict [ [string] ] = HTTPStatus . INTERNAL_SERVER_ERROR [EOL] logging . exception ( message ) [EOL] return results_dict [EOL] [EOL] [EOL] @ search_blueprint . route ( [string] , methods = [ [string] ] ) def search_dashboard ( ) : [EOL] [docstring] [EOL] try : [EOL] request_json = request . get_json ( ) [EOL] [EOL] search_term = get_query_param ( request_json , [string] , [string] ) [EOL] page_index = get_query_param ( request_json , [string] , [string] ) [EOL] search_type = request_json . get ( [string] ) [EOL] transformed_filters = transform_filters ( filters = request_json . get ( [string] , { } ) , resource = [string] ) [EOL] [EOL] results_dict = _search_dashboard ( filters = transformed_filters , search_term = search_term , page_index = page_index , search_type = search_type ) [EOL] [EOL] return make_response ( jsonify ( results_dict ) , results_dict . get ( [string] , HTTPStatus . INTERNAL_SERVER_ERROR ) ) [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( results_dict ) , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] [EOL] @ action_logging def _search_dashboard ( * , search_term , page_index , filters , search_type ) : [EOL] [docstring] [EOL] [comment] [EOL] dashboards = { [string] : page_index , [string] : [ ] , [string] : [number] , } [EOL] [EOL] results_dict = { [string] : search_term , [string] : [string] , [string] : dashboards , } [EOL] [EOL] try : [EOL] if has_filters ( filters = filters , resource = [string] ) : [EOL] query_json = generate_query_json ( filters = filters , page_index = page_index , search_term = search_term ) [EOL] url_base = app . config [ [string] ] + SEARCH_DASHBOARD_FILTER_ENDPOINT [EOL] response = request_search ( url = url_base , headers = { [string] : [string] } , method = [string] , data = json . dumps ( query_json ) ) [EOL] else : [EOL] url_base = app . config [ [string] ] + SEARCH_DASHBOARD_ENDPOINT [EOL] url = f'{ url_base } [string] { search_term } [string] { page_index }' [EOL] response = request_search ( url = url ) [EOL] [EOL] status_code = response . status_code [EOL] if status_code == HTTPStatus . OK : [EOL] results_dict [ [string] ] = [string] [EOL] results = response . json ( ) . get ( [string] ) [EOL] dashboards [ [string] ] = [ marshall_dashboard_partial ( result ) for result in results ] [EOL] dashboards [ [string] ] = response . json ( ) . get ( [string] ) [EOL] else : [EOL] message = [string] [EOL] results_dict [ [string] ] = message [EOL] logging . error ( message ) [EOL] [EOL] results_dict [ [string] ] = status_code [EOL] return results_dict [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] results_dict [ [string] ] = message [EOL] logging . exception ( message ) [EOL] return results_dict [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import builtins [EOL] import logging [EOL] import flask [EOL] import typing [EOL] import logging [EOL] [EOL] from http import HTTPStatus [EOL] [EOL] from flask import Response , jsonify , make_response , request [EOL] from flask import current_app as app [EOL] from flask . blueprints import Blueprint [EOL] [EOL] from amundsen_application . api . exceptions import MailClientNotImplemented [EOL] from amundsen_application . api . utils . notification_utils import get_mail_client , send_notification [EOL] from amundsen_application . log . action_log import action_logging [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] mail_blueprint = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] [EOL] @ mail_blueprint . route ( [string] , methods = [ [string] ] ) def feedback ( ) : [EOL] [docstring] [EOL] try : [EOL] mail_client = get_mail_client ( ) [EOL] data = request . form . to_dict ( ) [EOL] html_content = [string] . join ( [string] . format ( k , v ) for k , v in data . items ( ) ) [EOL] [EOL] [comment] [EOL] feedback_type = data . get ( [string] ) [EOL] rating = data . get ( [string] ) [EOL] comment = data . get ( [string] ) [EOL] bug_summary = data . get ( [string] ) [EOL] repro_steps = data . get ( [string] ) [EOL] feature_summary = data . get ( [string] ) [EOL] value_prop = data . get ( [string] ) [EOL] subject = data . get ( [string] ) or data . get ( [string] ) [EOL] [EOL] _feedback ( feedback_type = feedback_type , rating = rating , comment = comment , bug_summary = bug_summary , repro_steps = repro_steps , feature_summary = feature_summary , value_prop = value_prop , subject = subject ) [EOL] [EOL] options = { [string] : [string] , [string] : data } [EOL] [EOL] response = mail_client . send_email ( html = html_content , subject = subject , optional_data = options ) [EOL] status_code = response . status_code [EOL] [EOL] if status_code == HTTPStatus . OK : [EOL] message = [string] [EOL] else : [EOL] message = [string] + str ( status_code ) [EOL] logging . error ( message ) [EOL] [EOL] return make_response ( jsonify ( { [string] : message } ) , status_code ) [EOL] except MailClientNotImplemented as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . NOT_IMPLEMENTED ) [EOL] except Exception as e1 : [EOL] message = [string] + str ( e1 ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] [EOL] @ action_logging def _feedback ( * , feedback_type , rating , comment , bug_summary , repro_steps , feature_summary , value_prop , subject ) : [EOL] [docstring] [EOL] pass [comment] [EOL] [EOL] [EOL] @ mail_blueprint . route ( [string] , methods = [ [string] ] ) def notification ( ) : [EOL] [docstring] [EOL] try : [EOL] data = request . get_json ( ) [EOL] [EOL] notification_type = data . get ( [string] ) [EOL] if notification_type is None : [EOL] message = [string] [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . BAD_REQUEST ) [EOL] [EOL] sender = data . get ( [string] ) [EOL] if sender is None : [EOL] sender = app . config [ [string] ] ( app ) . email [EOL] [EOL] options = data . get ( [string] , { } ) [EOL] recipients = data . get ( [string] , [ ] ) [EOL] [EOL] return send_notification ( notification_type = notification_type , options = options , recipients = recipients , sender = sender ) [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import logging [EOL] import flask [EOL] import typing [EOL] import json [EOL] import logging [EOL] [EOL] from http import HTTPStatus [EOL] from pkg_resources import iter_entry_points [EOL] [EOL] from flask import Response , jsonify , make_response , request [EOL] from flask . blueprints import Blueprint [EOL] [EOL] from amundsen_application . models . preview_data import PreviewDataSchema [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] PREVIEW_CLIENT_CLASS = None [EOL] PREVIEW_CLIENT_INSTANCE = None [EOL] [EOL] [comment] [EOL] for entry_point in iter_entry_points ( group = [string] , name = [string] ) : [EOL] preview_client_class = entry_point . load ( ) [EOL] if preview_client_class is not None : [EOL] PREVIEW_CLIENT_CLASS = preview_client_class [EOL] [EOL] preview_blueprint = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] [EOL] @ preview_blueprint . route ( [string] , methods = [ [string] ] ) def get_table_preview ( ) : [EOL] [comment] [EOL] global PREVIEW_CLIENT_INSTANCE [EOL] try : [EOL] if PREVIEW_CLIENT_INSTANCE is None and PREVIEW_CLIENT_CLASS is not None : [EOL] PREVIEW_CLIENT_INSTANCE = PREVIEW_CLIENT_CLASS ( ) [EOL] [EOL] if PREVIEW_CLIENT_INSTANCE is None : [EOL] payload = jsonify ( { [string] : { } , [string] : [string] } ) [EOL] return make_response ( payload , HTTPStatus . NOT_IMPLEMENTED ) [EOL] [EOL] [comment] [EOL] response = PREVIEW_CLIENT_INSTANCE . get_preview_data ( params = request . get_json ( ) ) [EOL] status_code = response . status_code [EOL] [EOL] preview_data = json . loads ( response . data ) . get ( [string] ) [EOL] if status_code == HTTPStatus . OK : [EOL] [comment] [EOL] data , errors = PreviewDataSchema ( ) . load ( preview_data ) [EOL] if not errors : [EOL] payload = jsonify ( { [string] : data , [string] : [string] } ) [EOL] else : [EOL] logging . error ( [string] + str ( errors ) ) [EOL] raise Exception ( [string] ) [EOL] else : [EOL] message = [string] + str ( status_code ) [EOL] logging . error ( message ) [EOL] [comment] [EOL] payload = jsonify ( { [string] : { [string] : preview_data . get ( [string] , [string] ) } , [string] : message } ) [EOL] [EOL] return make_response ( payload , status_code ) [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] payload = jsonify ( { [string] : { } , [string] : message } ) [EOL] return make_response ( payload , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import flask [EOL] import builtins [EOL] import logging [EOL] import amundsen_application [EOL] import io [EOL] import logging [EOL] from http import HTTPStatus [EOL] [EOL] from flask import send_file , jsonify , make_response , Response , current_app as app [EOL] from flask . blueprints import Blueprint [EOL] [EOL] from amundsen_application . api . preview . dashboard . dashboard_preview . preview_factory_method import DefaultPreviewMethodFactory , BasePreviewMethodFactory [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] PREVIEW_FACTORY = None [comment] [EOL] [EOL] dashboard_preview_blueprint = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] [EOL] def initialize_preview_factory_class ( ) : [EOL] [docstring] [EOL] global PREVIEW_FACTORY [EOL] [EOL] PREVIEW_FACTORY = app . config [ [string] ] [EOL] if not PREVIEW_FACTORY : [EOL] PREVIEW_FACTORY = DefaultPreviewMethodFactory ( ) [EOL] [EOL] LOGGER . info ( [string] . format ( PREVIEW_FACTORY ) ) [EOL] [EOL] [EOL] @ dashboard_preview_blueprint . route ( [string] , methods = [ [string] ] ) def get_preview_image ( uri ) : [EOL] [docstring] [EOL] [EOL] if not PREVIEW_FACTORY : [EOL] LOGGER . info ( [string] ) [EOL] initialize_preview_factory_class ( ) [EOL] [EOL] preview_client = PREVIEW_FACTORY . get_instance ( uri = uri ) [EOL] try : [EOL] return send_file ( io . BytesIO ( preview_client . get_preview_image ( uri = uri ) ) , mimetype = [string] , cache_timeout = app . config [ [string] ] ) [EOL] except FileNotFoundError as fne : [EOL] LOGGER . exception ( [string] ) [EOL] return make_response ( jsonify ( { [string] : fne . args [ [number] ] } ) , HTTPStatus . NOT_FOUND ) [EOL] except PermissionError as pe : [EOL] LOGGER . exception ( [string] ) [EOL] return make_response ( jsonify ( { [string] : pe . args [ [number] ] } ) , HTTPStatus . UNAUTHORIZED ) [EOL] except Exception as e : [EOL] LOGGER . exception ( [string] ) [EOL] return make_response ( jsonify ( { [string] : [string] + str ( e ) } ) , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.BasePreviewMethodFactory$ 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.BasePreviewMethodFactory$ 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.BasePreviewMethodFactory$ 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.BasePreviewMethodFactory$ 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.BasePreviewMethodFactory$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.BasePreviewMethodFactory$ 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.BasePreviewMethodFactory$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.BasePreviewMethodFactory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict [EOL] import builtins [EOL] import logging [EOL] import amundsen_application [EOL] import typing [EOL] import logging [EOL] from abc import ABCMeta , abstractmethod [EOL] [EOL] from amundsen_application . base . base_preview import BasePreview [EOL] from amundsen_application . api . preview . dashboard . dashboard_preview . mode_preview import ModePreview [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class BasePreviewMethodFactory ( metaclass = ABCMeta ) : [EOL] [EOL] @ abstractmethod def get_instance ( self , * , uri ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class DefaultPreviewMethodFactory ( BasePreviewMethodFactory ) : [EOL] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . _object_map = { [string] : ModePreview ( ) } [EOL] LOGGER . info ( [string] . format ( list ( self . _object_map . keys ( ) ) ) ) [EOL] [EOL] def get_instance ( self , * , uri ) : [EOL] product = self . get_product ( uri = uri ) [EOL] [EOL] if product in self . _object_map : [EOL] return self . _object_map [ product ] [EOL] [EOL] raise NotImplementedError ( [string] . format ( product ) ) [EOL] [EOL] def get_product ( self , * , uri ) : [EOL] return uri . split ( [string] ) [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.base.base_preview.BasePreview$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview]$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview]$ 0 0 0 0 0 0 0 0 0 0 $amundsen_application.base.base_preview.BasePreview$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Optional [EOL] import requests [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] import logging [EOL] from typing import Optional , Any [EOL] [EOL] import requests [EOL] from flask import has_app_context , current_app as app [EOL] from requests . auth import HTTPBasicAuth [EOL] from retrying import retry [EOL] [EOL] from amundsen_application . api . metadata . v0 import USER_ENDPOINT [EOL] from amundsen_application . api . utils . request_utils import request_metadata [EOL] from amundsen_application . base . base_preview import BasePreview [EOL] from amundsen_application . models . user import load_user [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] DEFAULT_REPORT_URL_TEMPLATE = [string] [EOL] [EOL] [EOL] def _validate_not_none ( var , var_name ) : [EOL] if not var : [EOL] raise ValueError ( [string] . format ( var_name ) ) [EOL] return var [EOL] [EOL] [EOL] def _retry_on_retriable_error ( exception ) : [EOL] return not isinstance ( exception , PermissionError ) [EOL] [EOL] [EOL] class ModePreview ( BasePreview ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * , access_token = None , password = None , organization = None , report_url_template = None ) : [EOL] self . _access_token = access_token if access_token else app . config [ [string] ] [EOL] _validate_not_none ( self . _access_token , [string] ) [EOL] self . _password = password if password else app . config [ [string] ] [EOL] _validate_not_none ( self . _password , [string] ) [EOL] self . _organization = organization if organization else app . config [ [string] ] [EOL] _validate_not_none ( self . _organization , [string] ) [EOL] [EOL] self . _report_url_template = report_url_template if report_url_template else DEFAULT_REPORT_URL_TEMPLATE [EOL] [EOL] if has_app_context ( ) and app . config [ [string] ] is not None : [EOL] self . _report_url_template = app . config [ [string] ] [EOL] [EOL] self . _is_auth_enabled = False [EOL] if has_app_context ( ) and app . config [ [string] ] : [EOL] if not app . config [ [string] ] : [EOL] raise Exception ( [string] ) [EOL] self . _is_auth_enabled = self . __class__ . __name__ in app . config [ [string] ] [EOL] self . _auth_user_method = app . config [ [string] ] [EOL] [EOL] @ retry ( stop_max_attempt_number = [number] , wait_random_min = [number] , wait_random_max = [number] , retry_on_exception = _retry_on_retriable_error ) def get_preview_image ( self , * , uri ) : [EOL] [docstring] [EOL] if self . _is_auth_enabled : [EOL] self . _authorize_access ( user_id = self . _auth_user_method ( app ) . user_id ) [EOL] [EOL] url = self . _get_preview_image_url ( uri = uri ) [EOL] r = requests . get ( url , allow_redirects = True ) [EOL] r . raise_for_status ( ) [EOL] [EOL] return r . content [EOL] [EOL] def _get_preview_image_url ( self , * , uri ) : [EOL] url = self . _report_url_template . format ( organization = self . _organization , dashboard_id = uri . split ( [string] ) [ - [number] ] ) [EOL] [EOL] LOGGER . info ( [string] . format ( url ) ) [EOL] response = requests . get ( url , auth = HTTPBasicAuth ( self . _access_token , self . _password ) ) [EOL] if response . status_code == [number] : [EOL] raise FileNotFoundError ( [string] . format ( uri ) ) [EOL] [EOL] response . raise_for_status ( ) [EOL] [EOL] web_preview_image_key = [string] [EOL] result = response . json ( ) [EOL] [EOL] if web_preview_image_key not in result : [EOL] raise FileNotFoundError ( [string] . format ( uri ) ) [EOL] [EOL] image_url = result [ web_preview_image_key ] [EOL] if image_url is None : [EOL] raise FileNotFoundError ( [string] . format ( uri ) ) [EOL] [EOL] return image_url [EOL] [EOL] def _authorize_access ( self , user_id ) : [EOL] [docstring] [EOL] [EOL] metadata_svc_url = [string] . format ( app . config [ [string] ] , USER_ENDPOINT , user_id ) [EOL] response = request_metadata ( url = metadata_svc_url ) [EOL] response . raise_for_status ( ) [EOL] [EOL] user = load_user ( response . json ( ) ) [EOL] if user . is_active and user . other_key_values and user . other_key_values . get ( [string] ) : [EOL] return [EOL] [EOL] raise PermissionError ( [string] . format ( user_id ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import flask [EOL] import logging [EOL] import amundsen_application [EOL] import typing [EOL] from flask import current_app as app [EOL] from flask import jsonify , make_response , Response [EOL] from flask_restful import Resource , reqparse [EOL] from http import HTTPStatus [EOL] import logging [EOL] [EOL] from amundsen_application . base . base_issue_tracker_client import BaseIssueTrackerClient [EOL] from amundsen_application . proxy . issue_tracker_clients import get_issue_tracker_client [EOL] from amundsen_application . proxy . issue_tracker_clients . issue_exceptions import IssueConfigurationException [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class IssuesAPI ( Resource ) : [EOL] def __init__ ( self ) : [EOL] self . reqparse = reqparse . RequestParser ( ) [EOL] self . client = ... [EOL] [EOL] def get ( self ) : [EOL] [docstring] [EOL] try : [EOL] if not app . config [ [string] ] : [EOL] message = [string] [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . ACCEPTED ) [EOL] [EOL] self . client = get_issue_tracker_client ( ) [EOL] self . reqparse . add_argument ( [string] , [string] , location = [string] ) [EOL] args = self . reqparse . parse_args ( ) [EOL] response = self . client . get_issues ( args [ [string] ] ) [EOL] return make_response ( jsonify ( { [string] : response . serialize ( ) } ) , HTTPStatus . OK ) [EOL] [EOL] except IssueConfigurationException as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . NOT_IMPLEMENTED ) [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] [EOL] class IssueAPI ( Resource ) : [EOL] def __init__ ( self ) : [EOL] self . reqparse = reqparse . RequestParser ( ) [EOL] self . client = ... [EOL] super ( IssueAPI , self ) . __init__ ( ) [EOL] [EOL] def post ( self ) : [EOL] try : [EOL] if not app . config [ [string] ] : [EOL] message = [string] [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . ACCEPTED ) [EOL] self . client = get_issue_tracker_client ( ) [EOL] [EOL] self . reqparse . add_argument ( [string] , type = str , location = [string] ) [EOL] self . reqparse . add_argument ( [string] , type = str , location = [string] ) [EOL] self . reqparse . add_argument ( [string] , type = str , location = [string] ) [EOL] args = self . reqparse . parse_args ( ) [EOL] response = self . client . create_issue ( description = args [ [string] ] , table_uri = args [ [string] ] , title = args [ [string] ] ) [EOL] return make_response ( jsonify ( { [string] : response . serialize ( ) } ) , HTTPStatus . OK ) [EOL] [EOL] except IssueConfigurationException as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . NOT_IMPLEMENTED ) [EOL] except Exception as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.base.base_issue_tracker_client.BaseIssueTrackerClient$ 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.base.base_issue_tracker_client.BaseIssueTrackerClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $amundsen_application.models.issue_results.IssueResults$ 0 0 0 $amundsen_application.base.base_issue_tracker_client.BaseIssueTrackerClient$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.issue_results.IssueResults$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.base.base_issue_tracker_client.BaseIssueTrackerClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $amundsen_application.base.base_issue_tracker_client.BaseIssueTrackerClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 $amundsen_application.base.base_issue_tracker_client.BaseIssueTrackerClient$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] from typing import Dict [EOL] [EOL] import requests [EOL] from flask import current_app as app [EOL] [EOL] [EOL] def get_query_param ( args , param , error_msg = None ) : [EOL] value = args . get ( param ) [EOL] if value is None : [EOL] msg = [string] . format ( param ) if error_msg is not None else error_msg [EOL] raise Exception ( msg ) [EOL] return value [EOL] [EOL] [EOL] def request_metadata ( * , url , method = [string] , headers = None , timeout_sec = [number] , data = None ) : [EOL] [docstring] [EOL] if headers is None : [EOL] headers = { } [EOL] [EOL] if app . config [ [string] ] : [EOL] headers . update ( app . config [ [string] ] ( app ) ) [EOL] elif app . config [ [string] ] : [EOL] headers . update ( app . config [ [string] ] ) [EOL] return request_wrapper ( method = method , url = url , client = app . config [ [string] ] , headers = headers , timeout_sec = timeout_sec , data = data ) [EOL] [EOL] [EOL] def request_search ( * , url , method = [string] , headers = None , timeout_sec = [number] , data = None ) : [EOL] [docstring] [EOL] if headers is None : [EOL] headers = { } [EOL] [EOL] if app . config [ [string] ] : [EOL] headers . update ( app . config [ [string] ] ( app ) ) [EOL] elif app . config [ [string] ] : [EOL] headers . update ( app . config [ [string] ] ) [EOL] [EOL] return request_wrapper ( method = method , url = url , client = app . config [ [string] ] , headers = headers , timeout_sec = timeout_sec , data = data ) [EOL] [EOL] [EOL] [comment] [EOL] def request_wrapper ( method , url , client , headers , timeout_sec , data = None ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] timeout_sec = timeout_sec or app . config [ [string] ] [EOL] [EOL] if client is not None : [EOL] if method == [string] : [EOL] return client . delete ( url , headers = headers , raw_response = True ) [EOL] elif method == [string] : [EOL] return client . get ( url , headers = headers , raw_response = True ) [EOL] elif method == [string] : [EOL] return client . post ( url , headers = headers , raw_response = True , raw_request = True , data = data ) [EOL] elif method == [string] : [EOL] return client . put ( url , headers = headers , raw_response = True , raw_request = True , data = data ) [EOL] else : [EOL] raise Exception ( [string] . format ( method ) ) [EOL] else : [EOL] with requests . Session ( ) as s : [EOL] if method == [string] : [EOL] return s . delete ( url , headers = headers , timeout = timeout_sec ) [EOL] elif method == [string] : [EOL] return s . get ( url , headers = headers , timeout = timeout_sec ) [EOL] elif method == [string] : [EOL] return s . post ( url , headers = headers , timeout = timeout_sec , data = data ) [EOL] elif method == [string] : [EOL] return s . put ( url , headers = headers , timeout = timeout_sec , data = data ) [EOL] else : [EOL] raise Exception ( [string] . format ( method ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Set [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , List [comment] [EOL] [EOL] [EOL] [comment] [EOL] valid_search_fields = { [string] : { [string] , [string] , [string] , [string] , [string] , [string] } , [string] : { [string] , [string] , [string] , [string] } } [EOL] [EOL] [EOL] def map_table_result ( result ) : [EOL] return { [string] : [string] , [string] : result . get ( [string] , None ) , [string] : result . get ( [string] , None ) , [string] : result . get ( [string] , None ) , [string] : result . get ( [string] , None ) , [string] : result . get ( [string] , None ) , [string] : result . get ( [string] , None ) , [string] : result . get ( [string] , None ) , [string] : result . get ( [string] , None ) , [string] : result . get ( [string] , None ) , } [EOL] [EOL] [EOL] def transform_filters ( * , filters = { } , resource ) : [EOL] [docstring] [EOL] filter_payload = { } [EOL] for category in valid_search_fields . get ( resource , { } ) : [EOL] values = filters . get ( category ) [EOL] value_list = [ ] [comment] [EOL] if values is not None : [EOL] if type ( values ) == str : [EOL] value_list = [ values , ] [EOL] elif type ( values ) == dict : [EOL] value_list = [ key for key in values . keys ( ) if values [ key ] is True ] [EOL] if len ( value_list ) > [number] : [EOL] filter_payload [ category ] = value_list [EOL] [EOL] return filter_payload [EOL] [EOL] [EOL] def generate_query_json ( * , filters = { } , page_index , search_term ) : [EOL] [docstring] [EOL] return { [string] : int ( page_index ) , [string] : { [string] : [string] , [string] : filters } , [string] : search_term } [EOL] [EOL] [EOL] def has_filters ( * , filters = { } , resource = [string] ) : [EOL] [docstring] [EOL] for category in valid_search_fields . get ( resource , { } ) : [EOL] filter_list = filters . get ( category , [ ] ) [EOL] if len ( filter_list ) > [number] : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Optional [EOL] import builtins [EOL] import flask [EOL] import typing [EOL] import logging [EOL] [EOL] from http import HTTPStatus [EOL] from enum import Enum [EOL] [EOL] from flask import current_app as app [EOL] from flask import jsonify , make_response , Response [EOL] from typing import Dict , List [EOL] [EOL] from amundsen_application . api . exceptions import MailClientNotImplemented [EOL] from amundsen_application . log . action_log import action_logging [EOL] [EOL] [EOL] class NotificationType ( str , Enum ) : [EOL] [docstring] [EOL] OWNER_ADDED = [string] [EOL] OWNER_REMOVED = [string] [EOL] METADATA_EDITED = [string] [EOL] METADATA_REQUESTED = [string] [EOL] DATA_ISSUE_REPORTED = [string] [EOL] [EOL] @ classmethod def has_value ( cls , value ) : [EOL] for key in cls : [EOL] if key . value == value : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] NOTIFICATION_STRINGS = { NotificationType . OWNER_ADDED . value : { [string] : ( [string] [string] [string] ) , [string] : ( [string] [string] [string] ) , [string] : ( [string] [string] ) , } , NotificationType . OWNER_REMOVED . value : { [string] : [string] , [string] : ( [string] [string] ) , [string] : ( [string] [string] ) , } , NotificationType . METADATA_REQUESTED . value : { [string] : [string] , [string] : [string] , [string] : [string] , } , NotificationType . DATA_ISSUE_REPORTED . value : { [string] : [string] , [string] : [string] [string] , [string] : [string] , } } [EOL] [EOL] [EOL] def get_mail_client ( ) : [comment] [EOL] [docstring] [EOL] mail_client = app . config [ [string] ] [EOL] [EOL] if not mail_client : [EOL] raise MailClientNotImplemented ( [string] ) [EOL] [EOL] return mail_client [EOL] [EOL] [EOL] def validate_options ( * , options ) : [EOL] [docstring] [EOL] if options . get ( [string] ) is None : [EOL] raise Exception ( [string] ) [EOL] if options . get ( [string] ) is None : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def get_notification_html ( * , notification_type , options , sender ) : [EOL] [docstring] [EOL] validate_options ( options = options ) [EOL] [EOL] url_base = app . config [ [string] ] [EOL] resource_url = [string] . format ( resource_path = options . get ( [string] ) , url_base = url_base ) [EOL] joined_chars = resource_url [ len ( url_base ) - [number] : len ( url_base ) + [number] ] [EOL] if joined_chars . count ( [string] ) != [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] notification_strings = NOTIFICATION_STRINGS . get ( notification_type ) [EOL] if notification_strings is None : [EOL] raise Exception ( [string] ) [EOL] [EOL] greeting = [string] [EOL] notification = notification_strings . get ( [string] , [string] ) . format ( resource_url = resource_url , resource_name = options . get ( [string] ) , sender = sender ) [EOL] comment = notification_strings . get ( [string] , [string] ) [EOL] end_note = notification_strings . get ( [string] , [string] ) [EOL] salutation = [string] [EOL] [EOL] if notification_type == NotificationType . METADATA_REQUESTED : [EOL] options_comment = options . get ( [string] ) [EOL] need_resource_description = options . get ( [string] ) [EOL] need_fields_descriptions = options . get ( [string] ) [EOL] [EOL] if need_resource_description and need_fields_descriptions : [EOL] notification = notification + [string] [EOL] elif need_resource_description : [EOL] notification = notification + [string] [EOL] elif need_fields_descriptions : [EOL] notification = notification + [string] [EOL] else : [EOL] notification = notification + [string] [EOL] [EOL] if options_comment : [EOL] comment = ( [string] [string] ) . format ( sender = sender , comment = options_comment ) [EOL] [EOL] if notification_type == NotificationType . DATA_ISSUE_REPORTED : [EOL] greeting = [string] [EOL] data_issue_url = options . get ( [string] ) [EOL] comment = comment . format ( data_issue_url = data_issue_url ) [EOL] [EOL] return [string] . format ( greeting = greeting , notification = notification , comment = comment , end_note = end_note , salutation = salutation ) [EOL] [EOL] [EOL] def get_notification_subject ( * , notification_type , options ) : [EOL] [docstring] [EOL] resource_name = options . get ( [string] ) [EOL] notification_subject_dict = { NotificationType . OWNER_ADDED . value : [string] . format ( resource_name ) , NotificationType . OWNER_REMOVED . value : [string] . format ( resource_name ) , NotificationType . METADATA_EDITED . value : [string] . format ( resource_name ) , NotificationType . METADATA_REQUESTED . value : [string] . format ( resource_name ) , NotificationType . DATA_ISSUE_REPORTED . value : [string] . format ( resource_name ) } [EOL] subject = notification_subject_dict . get ( notification_type ) [EOL] if subject is None : [EOL] raise Exception ( [string] ) [EOL] return subject [EOL] [EOL] [EOL] def send_notification ( * , notification_type , options , recipients , sender ) : [EOL] [docstring] [EOL] @ action_logging def _log_send_notification ( * , notification_type , options , recipients , sender ) : [EOL] [docstring] [EOL] pass [comment] [EOL] [EOL] try : [EOL] if not app . config [ [string] ] : [EOL] message = [string] [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . ACCEPTED ) [EOL] if sender in recipients : [EOL] recipients . remove ( sender ) [EOL] if len ( recipients ) == [number] : [EOL] logging . info ( [string] ) [EOL] return make_response ( jsonify ( { [string] : [string] } ) , HTTPStatus . OK ) [EOL] [EOL] mail_client = get_mail_client ( ) [EOL] [EOL] html = get_notification_html ( notification_type = notification_type , options = options , sender = sender ) [EOL] subject = get_notification_subject ( notification_type = notification_type , options = options ) [EOL] [EOL] _log_send_notification ( notification_type = notification_type , options = options , recipients = recipients , sender = sender ) [EOL] [EOL] response = mail_client . send_email ( html = html , subject = subject , optional_data = { [string] : notification_type , } , recipients = recipients , sender = sender , ) [EOL] status_code = response . status_code [EOL] [EOL] if status_code == HTTPStatus . OK : [EOL] message = [string] [EOL] else : [EOL] message = [string] + str ( status_code ) [EOL] logging . error ( message ) [EOL] [EOL] return make_response ( jsonify ( { [string] : message } ) , status_code ) [EOL] except MailClientNotImplemented as e : [EOL] message = [string] + str ( e ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . NOT_IMPLEMENTED ) [EOL] except Exception as e1 : [EOL] message = [string] + str ( e1 ) [EOL] logging . exception ( message ) [EOL] return make_response ( jsonify ( { [string] : message } ) , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Optional , Match , Dict , List [EOL] import builtins [EOL] import amundsen_common [EOL] import amundsen_application [EOL] import typing [EOL] import logging [EOL] [EOL] from typing import Any , Dict , List [EOL] [EOL] from amundsen_common . models . dashboard import DashboardSummary , DashboardSummarySchema [EOL] from amundsen_common . models . popular_table import PopularTable , PopularTableSchema [EOL] [comment] [EOL] from amundsen_application . models . user import load_user , dump_user [EOL] from amundsen_application . api . utils . temporary_table import Table , TableSchema [EOL] from amundsen_application . config import MatchRuleObject [EOL] from flask import current_app as app [EOL] import re [EOL] [EOL] [EOL] def marshall_table_partial ( table_dict ) : [EOL] [docstring] [EOL] schema = PopularTableSchema ( strict = True ) [EOL] [comment] [EOL] table = schema . load ( table_dict ) . data [EOL] results = schema . dump ( table ) . data [EOL] [comment] [EOL] [comment] [EOL] results [ [string] ] = f'{ table . database } [string] { table . cluster } [string] { table . schema } [string] { table . name }' [EOL] results [ [string] ] = None [EOL] results [ [string] ] = [string] [EOL] [EOL] return results [EOL] [EOL] [EOL] def _parse_editable_rule ( rule , schema , table ) : [EOL] [docstring] [EOL] if rule . schema_regex and rule . table_name_regex : [EOL] match_schema = re . match ( rule . schema_regex , schema ) [EOL] match_table = re . match ( rule . table_name_regex , table ) [EOL] if match_schema and match_table : [EOL] return False [EOL] return True [EOL] if rule . schema_regex : [EOL] match_schema = re . match ( rule . schema_regex , schema ) [EOL] if match_schema : [EOL] return False [EOL] return True [EOL] if rule . table_name_regex : [EOL] match_table = re . match ( rule . table_name_regex , table ) [EOL] if match_table : [EOL] return False [EOL] return True [EOL] return True [EOL] [EOL] [EOL] def marshall_table_full ( table_dict ) : [EOL] [docstring] [EOL] [EOL] schema = TableSchema ( strict = True ) [EOL] [comment] [EOL] table = schema . load ( table_dict ) . data [EOL] results = schema . dump ( table ) . data [EOL] [EOL] [comment] [EOL] is_editable_schema = results [ [string] ] not in app . config [ [string] ] [EOL] [EOL] [comment] [EOL] is_editable_table = True [EOL] uneditable_table_desc_match_rules = app . config [ [string] ] [EOL] for rule in uneditable_table_desc_match_rules : [EOL] is_editable_table = is_editable_table and _parse_editable_rule ( rule , results [ [string] ] , results [ [string] ] ) [EOL] [EOL] is_editable = is_editable_schema and is_editable_table [EOL] results [ [string] ] = is_editable [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] results [ [string] ] = [ _map_user_object_to_schema ( owner ) for owner in results [ [string] ] ] [EOL] readers = results [ [string] ] [EOL] for reader_object in readers : [EOL] reader_object [ [string] ] = _map_user_object_to_schema ( reader_object [ [string] ] ) [EOL] [EOL] columns = results [ [string] ] [EOL] for col in columns : [EOL] [comment] [EOL] col [ [string] ] = is_editable [EOL] [comment] [EOL] if app . config [ [string] ] : [EOL] [comment] [EOL] col [ [string] ] . sort ( key = lambda x : app . config [ [string] ] . get ( x [ [string] ] , len ( app . config [ [string] ] ) ) ) [EOL] [EOL] [comment] [EOL] results [ [string] ] = f'{ table . database } [string] { table . cluster } [string] { table . schema } [string] { table . name }' [EOL] [comment] [EOL] results [ [string] ] = _get_partition_data ( results [ [string] ] ) [EOL] [EOL] [comment] [EOL] prog_descriptions = results [ [string] ] [EOL] results [ [string] ] = _convert_prog_descriptions ( prog_descriptions ) [EOL] [EOL] return results [EOL] [EOL] [EOL] def marshall_dashboard_partial ( dashboard_dict ) : [EOL] [docstring] [EOL] schema = DashboardSummarySchema ( strict = True ) [EOL] dashboard = schema . load ( dashboard_dict ) . data [EOL] results = schema . dump ( dashboard ) . data [EOL] results [ [string] ] = [string] [EOL] [comment] [EOL] [comment] [EOL] results [ [string] ] = results . get ( [string] , [string] ) [EOL] return results [EOL] [EOL] [EOL] def marshall_dashboard_full ( dashboard_dict ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dashboard_dict [ [string] ] = [ _map_user_object_to_schema ( owner ) for owner in dashboard_dict [ [string] ] ] [EOL] dashboard_dict [ [string] ] = [ marshall_table_partial ( table ) for table in dashboard_dict [ [string] ] ] [EOL] return dashboard_dict [EOL] [EOL] [EOL] def _convert_prog_descriptions ( prog_descriptions = None ) : [EOL] [docstring] [EOL] left = [ ] [comment] [EOL] right = [ ] [comment] [EOL] other = [ ] [comment] [EOL] updated_descriptions = { } [EOL] [EOL] if prog_descriptions : [EOL] [comment] [EOL] for desc in prog_descriptions : [EOL] source = desc . get ( [string] ) [EOL] if not source : [EOL] logging . warning ( [string] + str ( desc ) ) [EOL] [EOL] [comment] [EOL] prog_display_config = app . config [ [string] ] [EOL] if prog_display_config : [EOL] left_config = prog_display_config . get ( [string] , { } ) [EOL] left = [ x for x in prog_descriptions if x . get ( [string] ) in left_config ] [EOL] left . sort ( key = lambda x : _sort_prog_descriptions ( left_config , x ) ) [EOL] [EOL] right_config = prog_display_config . get ( [string] , { } ) [EOL] right = [ x for x in prog_descriptions if x . get ( [string] ) in right_config ] [EOL] right . sort ( key = lambda x : _sort_prog_descriptions ( right_config , x ) ) [EOL] [EOL] other_config = dict ( filter ( lambda x : x not in [ [string] , [string] ] , prog_display_config . items ( ) ) ) [EOL] other = list ( filter ( lambda x : x . get ( [string] ) not in left_config and x . get ( [string] ) not in right_config , prog_descriptions ) ) [EOL] other . sort ( key = lambda x : _sort_prog_descriptions ( other_config , x ) ) [EOL] [EOL] updated_descriptions [ [string] ] = left [EOL] updated_descriptions [ [string] ] = right [EOL] updated_descriptions [ [string] ] = other [EOL] return updated_descriptions [EOL] [EOL] [EOL] def _sort_prog_descriptions ( base_config , prog_description ) : [EOL] default_order = len ( base_config ) [EOL] prog_description_source = prog_description . get ( [string] ) [EOL] config_dict = base_config . get ( prog_description_source ) [EOL] if config_dict : [EOL] return config_dict . get ( [string] , default_order ) [EOL] return default_order [EOL] [EOL] [EOL] def _map_user_object_to_schema ( u ) : [EOL] return dump_user ( load_user ( u ) ) [EOL] [EOL] [EOL] def _get_partition_data ( watermarks ) : [EOL] if watermarks : [EOL] high_watermark = next ( filter ( lambda x : x [ [string] ] == [string] , watermarks ) ) [EOL] if high_watermark : [EOL] return { [string] : True , [string] : high_watermark [ [string] ] , [string] : high_watermark [ [string] ] } [EOL] return { [string] : False } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict [EOL] import builtins [EOL] import flask [EOL] import typing [EOL] import logging [EOL] [EOL] from typing import Dict [comment] [EOL] [EOL] from flask import Response , jsonify , make_response [EOL] [EOL] [EOL] def create_error_response ( * , message , payload , status_code ) : [EOL] [docstring] [EOL] logging . info ( message ) [EOL] payload [ [string] ] = message [EOL] return make_response ( jsonify ( payload ) , status_code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import List , Type , Optional [EOL] import builtins [EOL] import amundsen_common [EOL] import amundsen_application [EOL] import typing [EOL] from typing import List , Optional [EOL] [EOL] import attr [EOL] [EOL] from amundsen_common . models . user import User [EOL] from marshmallow_annotations . ext . attrs import AttrsSchema [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class Reader : [EOL] user = ... [EOL] read_count = ... [EOL] [EOL] [EOL] class ReaderSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = Reader [EOL] register_as_scheme = True [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class Tag : [EOL] tag_type = None [EOL] tag_name = None [EOL] badge_name = None [EOL] category = None [EOL] badge_type = None [EOL] [EOL] [EOL] class TagSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = Tag [EOL] register_as_scheme = True [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class Watermark : [EOL] watermark_type = None [EOL] partition_key = None [EOL] partition_value = None [EOL] create_time = None [EOL] [EOL] [EOL] class WatermarkSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = Watermark [EOL] register_as_scheme = True [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class Statistics : [EOL] stat_type = ... [EOL] stat_val = None [EOL] start_epoch = None [EOL] end_epoch = None [EOL] [EOL] [EOL] class StatisticsSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = Statistics [EOL] register_as_scheme = True [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class Column : [EOL] name = ... [EOL] description = None [EOL] col_type = ... [EOL] sort_order = ... [EOL] stats = [ ] [EOL] [EOL] [EOL] class ColumnSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = Column [EOL] register_as_scheme = True [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class Application : [EOL] application_url = None [EOL] description = None [EOL] id = ... [EOL] name = None [EOL] kind = None [EOL] [EOL] [EOL] class ApplicationSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = Application [EOL] register_as_scheme = True [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class Source : [EOL] source_type = ... [EOL] source = ... [EOL] [EOL] [EOL] class SourceSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = Source [EOL] register_as_scheme = True [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class ResourceReport : [EOL] name = ... [EOL] url = ... [EOL] [EOL] [EOL] class ResourceReportSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = ResourceReport [EOL] register_as_scheme = True [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def default_if_none ( arg ) : [EOL] return arg or False [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class ProgrammaticDescription : [EOL] source = ... [EOL] text = ... [EOL] [EOL] [EOL] class ProgrammaticDescriptionSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = ProgrammaticDescription [EOL] register_as_scheme = True [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class Table : [EOL] database = ... [EOL] cluster = ... [EOL] schema = ... [EOL] name = ... [EOL] tags = [ ] [EOL] badges = [ ] [EOL] table_readers = [ ] [EOL] description = None [EOL] columns = ... [EOL] owners = [ ] [EOL] watermarks = [ ] [EOL] table_writer = None [EOL] resource_reports = None [EOL] last_updated_timestamp = None [EOL] source = None [EOL] is_view = attr . ib ( default = None , converter = default_if_none ) [EOL] programmatic_descriptions = [ ] [EOL] [EOL] [EOL] class TableSchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = Table [EOL] register_as_scheme = True [EOL] [EOL] [EOL] @ attr . s ( auto_attribs = True , kw_only = True ) class TableSummary : [EOL] database = attr . ib ( ) [EOL] cluster = attr . ib ( ) [EOL] schema = attr . ib ( ) [EOL] name = attr . ib ( ) [EOL] description = attr . ib ( default = None ) [EOL] schema_description = attr . ib ( default = None ) [EOL] [EOL] [EOL] class TableSummarySchema ( AttrsSchema ) : [EOL] class Meta : [EOL] target = TableSummary [EOL] register_as_scheme = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_common.models.user.User$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[Statistics]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[Tag]$ 0 0 0 0 $typing.Optional[typing.List[Tag]]$ 0 0 0 0 $typing.List[Reader]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.List[Column]$ 0 0 0 $typing.List[amundsen_common.models.user.User]$ 0 0 0 0 $typing.List[Watermark]$ 0 0 0 0 $typing.Optional[Application]$ 0 0 0 $typing.Optional[typing.List[ResourceReport]]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[Source]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ProgrammaticDescription]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[amundsen_application.api.utils.temporary_table.TableSummary]$ 0 0 0 $builtins.bool$ 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict [EOL] import amundsen_application [EOL] import flask [EOL] import typing [EOL] from flask import current_app as app [EOL] from amundsen_application . models . user import load_user , User [EOL] [EOL] TEST_USER_ID = [string] [EOL] [EOL] [EOL] def get_test_user ( app ) : [EOL] user_info = { [string] : [string] , [string] : TEST_USER_ID , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] return load_user ( user_info ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.user.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import builtins [EOL] import amundsen_application [EOL] import typing [EOL] import jira [EOL] from jira import JIRA , JIRAError , Issue [EOL] from typing import List [EOL] [EOL] from flask import current_app as app [EOL] [EOL] from amundsen_application . base . base_issue_tracker_client import BaseIssueTrackerClient [EOL] from amundsen_application . proxy . issue_tracker_clients . issue_exceptions import IssueConfigurationException [EOL] from amundsen_application . models . data_issue import DataIssue [EOL] from amundsen_application . models . issue_results import IssueResults [EOL] [EOL] import urllib . parse [EOL] import logging [EOL] [EOL] SEARCH_STUB_ALL_ISSUES = [string] [EOL] [comment] [EOL] ISSUE_TYPE_ID = [number] [EOL] ISSUE_TYPE_NAME = [string] [EOL] [EOL] [EOL] class JiraClient ( BaseIssueTrackerClient ) : [EOL] [EOL] def __init__ ( self , issue_labels , issue_tracker_url , issue_tracker_user , issue_tracker_password , issue_tracker_project_id , issue_tracker_max_results ) : [EOL] self . issue_labels = issue_labels [EOL] self . jira_url = issue_tracker_url [EOL] self . jira_user = issue_tracker_user [EOL] self . jira_password = issue_tracker_password [EOL] self . jira_project_id = issue_tracker_project_id [EOL] self . jira_max_results = issue_tracker_max_results [EOL] self . _validate_jira_configuration ( ) [EOL] self . jira_client = self . get_client ( ) [EOL] [EOL] def get_client ( self ) : [EOL] [docstring] [EOL] return JIRA ( server = self . jira_url , basic_auth = ( self . jira_user , self . jira_password ) ) [EOL] [EOL] def get_issues ( self , table_uri ) : [EOL] [docstring] [EOL] try : [EOL] issues = self . jira_client . search_issues ( SEARCH_STUB_ALL_ISSUES . format ( table_key = table_uri ) , maxResults = self . jira_max_results ) [EOL] returned_issues = self . _sort_issues ( issues ) [EOL] return IssueResults ( issues = returned_issues , total = issues . total , all_issues_url = self . _generate_all_issues_url ( table_uri , returned_issues ) ) [EOL] except JIRAError as e : [EOL] logging . exception ( str ( e ) ) [EOL] raise e [EOL] [EOL] def create_issue ( self , table_uri , title , description ) : [EOL] [docstring] [EOL] try : [EOL] if app . config [ [string] ] : [EOL] user_email = app . config [ [string] ] ( app ) . email [EOL] [comment] [EOL] [comment] [EOL] jira_id = user_email . split ( [string] ) [ [number] ] [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] issue = self . jira_client . create_issue ( fields = dict ( project = { [string] : self . jira_project_id } , issuetype = { [string] : ISSUE_TYPE_ID , [string] : ISSUE_TYPE_NAME , } , labels = self . issue_labels , summary = title , description = ( f'{ description } [string] ' f' [string] { user_email } [string] ' f' [string] { table_uri } [string] ' ) , reporter = { [string] : jira_id } ) ) [EOL] return self . _get_issue_properties ( issue = issue ) [EOL] except JIRAError as e : [EOL] logging . exception ( str ( e ) ) [EOL] raise e [EOL] [EOL] def _validate_jira_configuration ( self ) : [EOL] [docstring] [EOL] missing_fields = [ ] [EOL] if not self . jira_url : [EOL] missing_fields . append ( [string] ) [EOL] if not self . jira_user : [EOL] missing_fields . append ( [string] ) [EOL] if not self . jira_password : [EOL] missing_fields . append ( [string] ) [EOL] if not self . jira_project_id : [EOL] missing_fields . append ( [string] ) [EOL] if not self . jira_max_results : [EOL] missing_fields . append ( [string] ) [EOL] [EOL] if missing_fields : [EOL] raise IssueConfigurationException ( f' [string] { [string] . join ( missing_fields ) } [string] ' ) [EOL] [EOL] @ staticmethod def _get_issue_properties ( issue ) : [EOL] [docstring] [EOL] return DataIssue ( issue_key = issue . key , title = issue . fields . summary , url = issue . permalink ( ) , status = issue . fields . status . name , priority = issue . fields . priority . name ) [EOL] [EOL] def _generate_all_issues_url ( self , table_uri , issues ) : [EOL] [docstring] [EOL] if not issues or len ( issues ) == [number] : [EOL] return [string] [EOL] search_query = urllib . parse . quote ( SEARCH_STUB_ALL_ISSUES . format ( table_key = table_uri ) ) [EOL] return f'{ self . jira_url } [string] { search_query }' [EOL] [EOL] def _sort_issues ( self , issues ) : [EOL] [docstring] [EOL] open = [ ] [EOL] closed = [ ] [EOL] for issue in issues : [EOL] data_issue = self . _get_issue_properties ( issue ) [EOL] if not issue . fields . resolution : [EOL] open . append ( data_issue ) [EOL] else : [EOL] closed . append ( data_issue ) [EOL] return open + closed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jira.JIRA$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.issue_results.IssueResults$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 $jira.Issue$ 0 0 0 0 0 0 0 0 0 0 $jira.Issue$ 0 0 0 0 0 $jira.Issue$ 0 0 0 0 0 0 0 $jira.Issue$ 0 0 0 0 0 0 0 $jira.Issue$ 0 0 0 0 0 0 0 0 0 $jira.Issue$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 0 0 0 0 0 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 0 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[amundsen_application.models.data_issue.DataIssue]$ 0 0 0 $typing.List[jira.Issue]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[jira.Issue]$ 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0
[comment] [EOL] [comment] [EOL] [EOL] [EOL] class IssueConfigurationException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import threading [EOL] import amundsen_application [EOL] import typing [EOL] from flask import current_app as app [EOL] from threading import Lock [EOL] from werkzeug . utils import import_string [EOL] [EOL] from amundsen_application . base . base_issue_tracker_client import BaseIssueTrackerClient [EOL] [EOL] _issue_tracker_client = None [EOL] _issue_tracker_client_lock = Lock ( ) [EOL] [EOL] [EOL] def get_issue_tracker_client ( ) : [EOL] [docstring] [EOL] global _issue_tracker_client [EOL] [EOL] if _issue_tracker_client : [EOL] return _issue_tracker_client [EOL] [EOL] with _issue_tracker_client_lock : [EOL] if _issue_tracker_client : [EOL] return _issue_tracker_client [EOL] else : [EOL] [comment] [EOL] if app . config [ [string] ] : [EOL] url = app . config [ [string] ] [EOL] user = app . config [ [string] ] [EOL] password = app . config [ [string] ] [EOL] project_id = app . config [ [string] ] [EOL] max_results = app . config [ [string] ] [EOL] issue_labels = app . config [ [string] ] [EOL] [EOL] if app . config [ [string] ] : [EOL] client = import_string ( app . config [ [string] ] ) [EOL] _issue_tracker_client = client ( issue_labels = issue_labels , issue_tracker_url = url , issue_tracker_user = user , issue_tracker_password = password , issue_tracker_project_id = project_id , issue_tracker_max_results = max_results ) [EOL] [EOL] return _issue_tracker_client [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 $amundsen_application.base.base_issue_tracker_client.BaseIssueTrackerClient$ 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $threading.Lock$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Union [EOL] import typing [EOL] import json [EOL] import responses [EOL] import unittest [EOL] [EOL] from http import HTTPStatus [EOL] from unittest . mock import patch [EOL] [EOL] from amundsen_application import create_app [EOL] from amundsen_application . api . search . v0 import SEARCH_DASHBOARD_ENDPOINT , SEARCH_DASHBOARD_FILTER_ENDPOINT , SEARCH_TABLE_ENDPOINT , SEARCH_TABLE_FILTER_ENDPOINT , SEARCH_USER_ENDPOINT [EOL] [EOL] local_app = create_app ( [string] , [string] ) [EOL] [EOL] MOCK_TABLE_RESULTS = { [string] : [number] , [string] : [ { [string] : [string] , [string] : [ [string] , [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [ ] } ] } [EOL] [EOL] MOCK_PARSED_TABLE_RESULTS = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] } ] [EOL] [EOL] [EOL] class SearchTable ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . mock_table_results = MOCK_TABLE_RESULTS [EOL] self . expected_parsed_table_results = MOCK_PARSED_TABLE_RESULTS [EOL] self . search_service_url = local_app . config [ [string] ] + SEARCH_TABLE_ENDPOINT [EOL] self . search_service_filter_url = local_app . config [ [string] ] + SEARCH_TABLE_FILTER_ENDPOINT [EOL] self . fe_flask_endpoint = [string] [EOL] [EOL] def test_fail_if_term_is_none ( self ) : [EOL] [docstring] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . post ( self . fe_flask_endpoint , json = { [string] : [number] } ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] def test_fail_if_page_index_is_none ( self ) : [EOL] [docstring] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . post ( self . fe_flask_endpoint , json = { [string] : [string] } ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] @ responses . activate @ patch ( [string] ) def test_calls_transform_filters ( self , transform_filter_mock ) : [EOL] [docstring] [EOL] test_filters = { [string] : [string] } [EOL] responses . add ( responses . POST , self . search_service_filter_url , json = self . mock_table_results , status = HTTPStatus . OK ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] test . post ( self . fe_flask_endpoint , json = { [string] : [string] , [string] : [number] , [string] : test_filters , [string] : [string] } ) [EOL] transform_filter_mock . assert_called_with ( filters = test_filters , resource = [string] ) [EOL] [EOL] @ responses . activate @ patch ( [string] ) @ patch ( [string] ) def test_calls_search_table_log_helper ( self , search_table_mock , transform_filter_mock ) : [EOL] [docstring] [EOL] test_term = [string] [EOL] test_index = [number] [EOL] test_search_type = [string] [EOL] mock_filters = { [string] : [ [string] ] } [EOL] transform_filter_mock . return_value = mock_filters [EOL] responses . add ( responses . POST , self . search_service_filter_url , json = self . mock_table_results , status = HTTPStatus . OK ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] test . post ( self . fe_flask_endpoint , json = { [string] : test_term , [string] : test_index , [string] : { } , [string] : test_search_type } ) [EOL] search_table_mock . assert_called_with ( filters = mock_filters , page_index = test_index , search_term = test_term , search_type = test_search_type ) [EOL] [EOL] @ responses . activate @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) def test_calls_generate_query_json ( self , mock_generate_query_json , has_filters_mock , transform_filter_mock ) : [EOL] [docstring] [EOL] test_term = [string] [EOL] test_index = [number] [EOL] responses . add ( responses . POST , self . search_service_filter_url , json = self . mock_table_results , status = HTTPStatus . OK ) [EOL] has_filters_mock . return_value = True [EOL] mock_filters = { [string] : [ [string] ] } [EOL] transform_filter_mock . return_value = mock_filters [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] test . post ( self . fe_flask_endpoint , json = { [string] : test_term , [string] : test_index , [string] : { } } ) [EOL] mock_generate_query_json . assert_called_with ( filters = mock_filters , page_index = test_index , search_term = test_term ) [EOL] [EOL] @ responses . activate @ patch ( [string] ) @ patch ( [string] ) def test_does_not_calls_generate_query_json ( self , mock_generate_query_json , has_filters_mock ) : [EOL] [docstring] [EOL] test_term = [string] [EOL] test_index = [number] [EOL] responses . add ( responses . GET , self . search_service_url , json = self . mock_table_results , status = HTTPStatus . OK ) [EOL] has_filters_mock . return_value = False [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] test . post ( self . fe_flask_endpoint , json = { [string] : test_term , [string] : test_index , [string] : { } } ) [EOL] mock_generate_query_json . assert_not_called ( ) [EOL] [EOL] @ responses . activate def test_request_success ( self ) : [EOL] [docstring] [EOL] test_filters = { [string] : [string] } [EOL] test_term = [string] [EOL] test_index = [number] [EOL] responses . add ( responses . POST , self . search_service_filter_url , json = self . mock_table_results , status = HTTPStatus . OK ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . post ( self . fe_flask_endpoint , json = { [string] : test_term , [string] : test_index , [string] : test_filters } ) [EOL] data = json . loads ( response . data ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . OK ) [EOL] [EOL] results = data . get ( [string] ) [EOL] self . assertEqual ( results . get ( [string] ) , self . mock_table_results . get ( [string] ) ) [EOL] self . assertEqual ( results . get ( [string] ) , self . expected_parsed_table_results ) [EOL] [EOL] @ responses . activate def test_request_fail ( self ) : [EOL] [docstring] [EOL] test_filters = { [string] : [string] } [EOL] test_term = [string] [EOL] test_index = [number] [EOL] responses . add ( responses . POST , self . search_service_filter_url , json = { } , status = HTTPStatus . BAD_REQUEST ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . post ( self . fe_flask_endpoint , json = { [string] : test_term , [string] : test_index , [string] : test_filters } ) [EOL] data = json . loads ( response . data ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . BAD_REQUEST ) [EOL] self . assertEqual ( data . get ( [string] ) , [string] ) [EOL] [EOL] [EOL] class SearchUser ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . mock_search_user_results = { [string] : [number] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , } ] } [EOL] self . expected_parsed_search_user_results = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] } ] [EOL] self . bad_search_results = { [string] : [number] , [string] : [string] } [EOL] self . fe_flask_endpoint = [string] [EOL] [EOL] def test_search_user_fail_if_no_query ( self ) : [EOL] [docstring] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . get ( self . fe_flask_endpoint , query_string = dict ( page_index = [string] ) ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] def test_search_user_fail_if_no_page_index ( self ) : [EOL] [docstring] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . get ( self . fe_flask_endpoint , query_string = dict ( query = [string] ) ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] @ responses . activate def test_search_user_success_if_no_response_from_search ( self ) : [EOL] [docstring] [EOL] responses . add ( responses . GET , local_app . config [ [string] ] + SEARCH_USER_ENDPOINT , json = { } , status = HTTPStatus . OK ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . get ( self . fe_flask_endpoint , query_string = dict ( query = [string] , page_index = [string] ) ) [EOL] data = json . loads ( response . data ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . OK ) [EOL] [EOL] users = data . get ( [string] ) [EOL] self . assertEqual ( len ( users . get ( [string] ) ) , [number] ) [EOL] self . assertEqual ( users . get ( [string] ) , [number] ) [EOL] [EOL] @ responses . activate def test_search_user_success ( self ) : [EOL] [docstring] [EOL] responses . add ( responses . GET , local_app . config [ [string] ] + SEARCH_USER_ENDPOINT , json = self . mock_search_user_results , status = HTTPStatus . OK ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . get ( self . fe_flask_endpoint , query_string = dict ( query = [string] , page_index = [string] ) ) [EOL] data = json . loads ( response . data ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . OK ) [EOL] [EOL] users = data . get ( [string] ) [EOL] self . assertEqual ( users . get ( [string] ) , self . mock_search_user_results . get ( [string] ) ) [EOL] self . assertDictContainsSubset ( self . expected_parsed_search_user_results [ [number] ] , users . get ( [string] ) [ [number] ] ) [EOL] [EOL] @ responses . activate def test_search_user_fail_on_non_200_response ( self ) : [EOL] [docstring] [EOL] responses . add ( responses . GET , local_app . config [ [string] ] + SEARCH_USER_ENDPOINT , json = self . mock_search_user_results , status = HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . get ( self . fe_flask_endpoint , query_string = dict ( query = [string] , page_index = [string] ) ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] [EOL] class SearchDashboard ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . mock_results = { [string] : [number] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] } , ] } [EOL] self . expected_parsed_results = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] self . search_service_url = local_app . config [ [string] ] + SEARCH_DASHBOARD_ENDPOINT [EOL] self . search_service_filter_url = local_app . config [ [string] ] + SEARCH_DASHBOARD_FILTER_ENDPOINT [EOL] self . fe_flask_endpoint = [string] [EOL] [EOL] def test_fail_if_term_is_none ( self ) : [EOL] [docstring] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . post ( self . fe_flask_endpoint , json = { [string] : [string] } ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] def test_fail_if_page_index_is_none ( self ) : [EOL] [docstring] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . post ( self . fe_flask_endpoint , json = { [string] : [string] } ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] @ responses . activate @ patch ( [string] ) def test_calls_transform_filters ( self , transform_filter_mock ) : [EOL] [docstring] [EOL] test_filters = { } [EOL] responses . add ( responses . POST , self . search_service_url , json = self . mock_results , status = HTTPStatus . OK ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] test . post ( self . fe_flask_endpoint , json = { [string] : [string] , [string] : [number] , [string] : test_filters , [string] : [string] } ) [EOL] transform_filter_mock . assert_called_with ( filters = test_filters , resource = [string] ) [EOL] [EOL] @ responses . activate @ patch ( [string] ) def test_calls_search_dashboard_log_helper ( self , search_dashboard_mock ) : [EOL] [docstring] [EOL] test_term = [string] [EOL] test_index = [number] [EOL] test_search_type = [string] [EOL] mock_filters = { } [EOL] responses . add ( responses . GET , self . search_service_url , body = self . mock_results , status = HTTPStatus . OK ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] test . post ( self . fe_flask_endpoint , json = { [string] : test_term , [string] : test_index , [string] : mock_filters , [string] : test_search_type } ) [EOL] search_dashboard_mock . assert_called_with ( filters = mock_filters , page_index = test_index , search_term = test_term , search_type = test_search_type ) [EOL] [EOL] @ responses . activate @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) def test_calls_generate_query_json ( self , mock_generate_query_json , has_filters_mock , transform_filter_mock ) : [EOL] [docstring] [EOL] test_term = [string] [EOL] test_index = [number] [EOL] responses . add ( responses . POST , self . search_service_filter_url , json = self . mock_results , status = HTTPStatus . OK ) [EOL] has_filters_mock . return_value = True [EOL] mock_filters = { [string] : [string] } [EOL] transform_filter_mock . return_value = mock_filters [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] test . post ( self . fe_flask_endpoint , json = { [string] : test_term , [string] : test_index , [string] : { } } ) [EOL] mock_generate_query_json . assert_called_with ( filters = mock_filters , page_index = test_index , search_term = test_term ) [EOL] [EOL] @ responses . activate @ patch ( [string] ) @ patch ( [string] ) def test_does_not_calls_generate_query_json ( self , mock_generate_query_json , has_filters_mock ) : [EOL] [docstring] [EOL] test_term = [string] [EOL] test_index = [number] [EOL] responses . add ( responses . GET , self . search_service_url , json = self . mock_results , status = HTTPStatus . OK ) [EOL] has_filters_mock . return_value = False [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] test . post ( self . fe_flask_endpoint , json = { [string] : test_term , [string] : test_index , [string] : { } } ) [EOL] mock_generate_query_json . assert_not_called ( ) [EOL] [EOL] @ responses . activate def test_request_success ( self ) : [EOL] [docstring] [EOL] responses . add ( responses . GET , self . search_service_url , json = self . mock_results , status = HTTPStatus . OK ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . post ( self . fe_flask_endpoint , json = { [string] : [string] , [string] : [string] } ) [EOL] data = json . loads ( response . data ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . OK ) [EOL] [EOL] results = data . get ( [string] ) [EOL] print ( results . get ( [string] ) ) [EOL] self . assertEqual ( results . get ( [string] ) , self . mock_results . get ( [string] ) ) [EOL] self . assertEqual ( results . get ( [string] ) , self . expected_parsed_results ) [EOL] [EOL] @ responses . activate def test_request_fail ( self ) : [EOL] [docstring] [EOL] responses . add ( responses . GET , self . search_service_url , json = self . mock_results , status = HTTPStatus . BAD_REQUEST ) [EOL] [EOL] with local_app . test_client ( ) as test : [EOL] response = test . post ( self . fe_flask_endpoint , json = { [string] : [string] , [string] : [string] } ) [EOL] data = json . loads ( response . data ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . BAD_REQUEST ) [EOL] self . assertEqual ( data . get ( [string] ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]],builtins.int]]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int,builtins.str]]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import amundsen_application [EOL] import builtins [EOL] import flask [EOL] import unittest [EOL] import unittest [EOL] [EOL] from flask import current_app [EOL] from http import HTTPStatus [EOL] [EOL] [EOL] from amundsen_application import create_app [EOL] from amundsen_application . api . preview . dashboard import v0 [EOL] from amundsen_application . base . base_preview import BasePreview [EOL] from amundsen_application . api . preview . dashboard . dashboard_preview . preview_factory_method import DefaultPreviewMethodFactory , BasePreviewMethodFactory [EOL] [EOL] from unittest . mock import MagicMock [EOL] [EOL] [EOL] class TestV0 ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . app = create_app ( config_module_class = [string] ) [EOL] self . app_context = self . app . app_context ( ) [EOL] self . app_context . push ( ) [EOL] self . app . config [ [string] ] = [string] [EOL] self . app . config [ [string] ] = [string] [EOL] self . app . config [ [string] ] = [string] [EOL] [EOL] def tearDown ( self ) : [EOL] self . app_context . pop ( ) [EOL] [EOL] def test_app_exists ( self ) : [EOL] self . assertFalse ( current_app is None ) [EOL] [EOL] def test_v0_default_initialize_preview_factory_class ( self ) : [EOL] v0 . initialize_preview_factory_class ( ) [EOL] self . assertTrue ( isinstance ( v0 . PREVIEW_FACTORY , DefaultPreviewMethodFactory ) ) [EOL] [EOL] def test_v0_initialize_preview_factory_class ( self ) : [EOL] self . app . config [ [string] ] = DummyPreviewMethodFactory ( ) [EOL] [EOL] v0 . initialize_preview_factory_class ( ) [EOL] self . assertTrue ( isinstance ( v0 . PREVIEW_FACTORY , DummyPreviewMethodFactory ) ) [EOL] [EOL] def test_get_preview_image_not_available ( self ) : [EOL] mock_factory = MagicMock ( ) [EOL] mock_factory . get_instance . return_value . get_preview_image . side_effect = FileNotFoundError ( [string] ) [EOL] [EOL] self . app . config [ [string] ] = mock_factory [EOL] v0 . initialize_preview_factory_class ( ) [EOL] [EOL] response = v0 . get_preview_image ( uri = [string] ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . NOT_FOUND ) [EOL] [EOL] def test_get_preview_image_failure ( self ) : [EOL] mock_factory = MagicMock ( ) [EOL] mock_factory . get_instance . return_value . get_preview_image . side_effect = Exception ( ) [EOL] [EOL] self . app . config [ [string] ] = mock_factory [EOL] v0 . initialize_preview_factory_class ( ) [EOL] [EOL] response = v0 . get_preview_image ( uri = [string] ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] [EOL] class DummyPreviewMethodFactory ( BasePreviewMethodFactory ) : [EOL] def get_instance ( self , * , uri ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.base.base_preview.BasePreview$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import builtins [EOL] from typing import Any [EOL] import amundsen_application [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] import requests [EOL] from requests . auth import HTTPBasicAuth [EOL] from unittest . mock import MagicMock [EOL] [EOL] from amundsen_application import create_app [EOL] from amundsen_application . api . preview . dashboard . dashboard_preview . mode_preview import ModePreview , DEFAULT_REPORT_URL_TEMPLATE [EOL] from amundsen_application . api . utils import request_utils [EOL] [EOL] ACCESS_TOKEN = [string] [EOL] PASSWORD = [string] [EOL] ORGANIZATION = [string] [EOL] [EOL] [EOL] class TestModePreview ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . app = create_app ( config_module_class = [string] ) [EOL] self . app_context = self . app . app_context ( ) [EOL] self . app_context . push ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . app_context . pop ( ) [EOL] [EOL] def test_get_preview_image ( self ) : [EOL] with patch . object ( ModePreview , [string] ) as mock_get_preview_image_url , patch . object ( requests , [string] ) as mock_get : [EOL] mock_get_preview_image_url . return_value = [string] [EOL] mock_get . return_value . content = [string] [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] [EOL] mode_dashboard_uri = [string] [EOL] actual = preview . get_preview_image ( uri = mode_dashboard_uri ) [EOL] [EOL] self . assertEqual ( [string] , actual ) [EOL] mock_get . assert_called_with ( [string] , allow_redirects = True ) [EOL] [EOL] def test_get_preview_image_url_success ( self ) : [EOL] with patch . object ( requests , [string] ) as mock_get : [EOL] mock_get . return_value . json . return_value = { [string] : [string] } [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] mode_dashboard_uri = [string] [EOL] url = preview . _get_preview_image_url ( uri = mode_dashboard_uri ) [EOL] [EOL] self . assertEqual ( url , [string] ) [EOL] [EOL] expected_url = DEFAULT_REPORT_URL_TEMPLATE . format ( organization = ORGANIZATION , dashboard_id = [string] ) [EOL] mock_get . assert_called_with ( expected_url , auth = HTTPBasicAuth ( ACCESS_TOKEN , PASSWORD ) ) [EOL] [EOL] def test_get_preview_image_url_failure_none_value ( self ) : [EOL] with patch . object ( requests , [string] ) as mock_get : [EOL] mock_get . return_value . json . return_value = { [string] : None } [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] mode_dashboard_uri = [string] [EOL] self . assertRaises ( FileNotFoundError , preview . _get_preview_image_url , uri = mode_dashboard_uri ) [EOL] [EOL] def test_get_preview_image_url_failure_missing_key ( self ) : [EOL] with patch . object ( requests , [string] ) as mock_get : [EOL] mock_get . return_value . json . return_value = { } [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] mode_dashboard_uri = [string] [EOL] self . assertRaises ( FileNotFoundError , preview . _get_preview_image_url , uri = mode_dashboard_uri ) [EOL] [EOL] def test_auth_disabled ( self ) : [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] self . assertFalse ( preview . _is_auth_enabled ) [EOL] [EOL] def test_auth_disabled_2 ( self ) : [EOL] self . app . config [ [string] ] = { [string] } [EOL] self . app . config [ [string] ] = MagicMock ( ) [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] self . assertFalse ( preview . _is_auth_enabled ) [EOL] [EOL] def test_auth_enabled ( self ) : [EOL] self . app . config [ [string] ] = { [string] } [EOL] self . app . config [ [string] ] = MagicMock ( ) [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] self . assertTrue ( preview . _is_auth_enabled ) [EOL] [EOL] def test_authorization ( self ) : [EOL] self . app . config [ [string] ] = { [string] } [EOL] self . app . config [ [string] ] = MagicMock ( ) [EOL] [EOL] with patch ( [string] ) as mock_request_metadata : [EOL] mock_request_metadata . return_value . json . return_value = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] } } [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] preview . _authorize_access ( user_id = [string] ) [EOL] [EOL] with patch ( [string] ) as mock_request_metadata : [EOL] mock_request_metadata . return_value . json . return_value = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] } } [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] self . assertRaises ( PermissionError , preview . _authorize_access , user_id = [string] ) [EOL] [EOL] with patch ( [string] ) as mock_request_metadata : [EOL] mock_request_metadata . return_value . json . return_value = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { } } [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] self . assertRaises ( PermissionError , preview . _authorize_access , user_id = [string] ) [EOL] [EOL] with patch ( [string] ) as mock_request_metadata : [EOL] mock_request_metadata . return_value . json . return_value = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] } } [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] self . assertRaises ( PermissionError , preview . _authorize_access , user_id = [string] ) [EOL] [EOL] with patch ( [string] ) as mock_request_metadata : [EOL] mock_request_metadata . return_value . json . return_value = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None } [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] self . assertRaises ( PermissionError , preview . _authorize_access , user_id = [string] ) [EOL] [EOL] with patch ( [string] ) as mock_request_metadata : [EOL] mock_request_metadata . return_value . json . return_value = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] preview = ModePreview ( access_token = [string] , password = [string] , organization = [string] ) [EOL] self . assertRaises ( PermissionError , preview . _authorize_access , user_id = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.mode_preview.ModePreview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import amundsen_application [EOL] import unittest [EOL] [EOL] from flask import current_app [EOL] [EOL] from amundsen_application import create_app [EOL] from amundsen_application . api . preview . dashboard . dashboard_preview . mode_preview import ModePreview [EOL] from amundsen_application . api . preview . dashboard . dashboard_preview . preview_factory_method import DefaultPreviewMethodFactory [EOL] [EOL] [EOL] class TestDefaultPreviewFactory ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . app = create_app ( config_module_class = [string] ) [EOL] self . app_context = self . app . app_context ( ) [EOL] self . app_context . push ( ) [EOL] self . app . config [ [string] ] = [string] [EOL] self . app . config [ [string] ] = [string] [EOL] self . app . config [ [string] ] = [string] [EOL] [EOL] def tearDown ( self ) : [EOL] self . app_context . pop ( ) [EOL] [EOL] def test_app_exists ( self ) : [EOL] self . assertFalse ( current_app is None ) [EOL] [EOL] def test_factory ( self ) : [EOL] factory = DefaultPreviewMethodFactory ( ) [EOL] actual = factory . get_instance ( uri = [string] ) [EOL] [EOL] self . assertTrue ( isinstance ( actual , ModePreview ) ) [EOL] [EOL] try : [EOL] factory . get_instance ( uri = [string] ) [EOL] self . assertTrue ( False , [string] ) [EOL] except Exception : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.DefaultPreviewMethodFactory$ 0 0 0 0 0 $amundsen_application.base.base_preview.BasePreview$ 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.DefaultPreviewMethodFactory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.base.base_preview.BasePreview$ 0 0 0 0 0 0 0 0 0 $amundsen_application.api.preview.dashboard.dashboard_preview.preview_factory_method.DefaultPreviewMethodFactory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import amundsen_application [EOL] import flask [EOL] import unittest [EOL] import flask [EOL] [EOL] from amundsen_application . base . base_issue_tracker_client import BaseIssueTrackerClient [EOL] [EOL] app = flask . Flask ( __name__ ) [EOL] app . config . from_object ( [string] ) [EOL] [EOL] [EOL] class IssueTrackerClientTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] BaseIssueTrackerClient . __abstractmethods__ = frozenset ( ) [EOL] self . client = BaseIssueTrackerClient ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] def test_cover_get_issues ( self ) : [EOL] with app . test_request_context ( ) : [EOL] try : [EOL] self . client . get_issues ( table_uri = [string] ) [EOL] except NotImplementedError : [EOL] self . assertTrue ( True ) [EOL] else : [EOL] self . assertTrue ( False ) [EOL] [EOL] def test_cover_create_issue ( self ) : [EOL] with app . test_request_context ( ) : [EOL] try : [EOL] self . client . create_issue ( table_uri = [string] , title = [string] , description = [string] ) [EOL] except NotImplementedError : [EOL] self . assertTrue ( True ) [EOL] else : [EOL] self . assertTrue ( False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.base.base_issue_tracker_client.BaseIssueTrackerClient$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Union [EOL] import flask [EOL] import amundsen_application [EOL] import typing [EOL] import unittest [EOL] [EOL] from http import HTTPStatus [EOL] from typing import List [EOL] [EOL] import flask [EOL] [EOL] from amundsen_application . base . base_announcement_client import BaseAnnouncementClient [EOL] from amundsen_application . models . announcements import Announcements [EOL] [EOL] app = flask . Flask ( __name__ ) [EOL] app . config . from_object ( [string] ) [EOL] [EOL] [EOL] class MockClient ( BaseAnnouncementClient ) : [EOL] def __init__ ( self , posts ) : [EOL] self . posts = posts [EOL] self . announcements = Announcements ( posts = posts ) [EOL] [EOL] def get_posts ( self ) : [EOL] return self . announcements [EOL] [EOL] [EOL] class MockExceptionClient ( BaseAnnouncementClient ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def get_posts ( self ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] class AnnouncementClientTest ( unittest . TestCase ) : [EOL] def test_get_posts_raise_exception ( self ) : [EOL] [docstring] [EOL] with app . test_request_context ( ) : [EOL] response = MockExceptionClient ( ) . _get_posts ( ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] def test_get_posts_invalid_posts_no_date ( self ) : [EOL] [docstring] [EOL] with app . test_request_context ( ) : [EOL] invalid_posts = [ { [string] : [string] } ] [EOL] response = MockClient ( invalid_posts ) . _get_posts ( ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] def test_get_posts_invalid_posts_no_title ( self ) : [EOL] [docstring] [EOL] with app . test_request_context ( ) : [EOL] invalid_posts = [ { [string] : [string] , [string] : [string] } ] [EOL] response = MockClient ( invalid_posts ) . _get_posts ( ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] def test_get_posts_success ( self ) : [EOL] [docstring] [EOL] with app . test_request_context ( ) : [EOL] success_posts = [ { [string] : [string] , [string] : [string] , [string] : [ [string] ] , } ] [EOL] response = MockClient ( success_posts ) . _get_posts ( ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . OK ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $amundsen_application.models.announcements.Announcements$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 $amundsen_application.models.announcements.Announcements$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $amundsen_application.models.announcements.Announcements$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Union [EOL] import requests [EOL] import flask [EOL] import typing [EOL] import unittest [EOL] import flask [EOL] import json [EOL] import unittest [EOL] [EOL] from http import HTTPStatus [EOL] from requests import Response [EOL] from typing import Dict [EOL] from unittest . mock import Mock [EOL] [EOL] from amundsen_application . base . base_superset_preview_client import BaseSupersetPreviewClient [EOL] [EOL] app = flask . Flask ( __name__ ) [EOL] app . config . from_object ( [string] ) [EOL] [EOL] good_json_data = { [string] : [ { [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , [string] : False , } , { [string] : False , [string] : [string] , [string] : [string] , [string] : True , } ] , [string] : [ { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , ] } [EOL] expected_results = { [string] : [ { [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , } ] , [string] : [ { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , ] , [string] : [string] } [EOL] [EOL] bad_json_data = { [string] : [ { [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , [string] : False , } , { [string] : False , [string] : [string] , [string] : [string] , [string] : True , } ] , [string] : [string] , } [EOL] [EOL] [EOL] class MockClient ( BaseSupersetPreviewClient ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def post_to_sql_json ( self , * , params , headers ) : [EOL] mockresponse = Mock ( ) [EOL] mockresponse . json . return_value = good_json_data [EOL] mockresponse . status_code = HTTPStatus . OK [EOL] return mockresponse [EOL] [EOL] [EOL] class MockBadDataClient ( BaseSupersetPreviewClient ) : [EOL] def __init__ ( self ) : [EOL] self . headers = { } [EOL] [EOL] def post_to_sql_json ( self , * , params , headers ) : [EOL] mockresponse = Mock ( ) [EOL] mockresponse . json . return_value = bad_json_data [EOL] mockresponse . status_code = HTTPStatus . OK [EOL] return mockresponse [EOL] [EOL] [EOL] class MockExceptionClient ( BaseSupersetPreviewClient ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def post_to_sql_json ( self , * , params , headers ) : [EOL] mockresponse = Mock ( ) [EOL] mockresponse . json . return_value = None [EOL] mockresponse . status_code = HTTPStatus . OK [EOL] return mockresponse [EOL] [EOL] [EOL] class SupersetPreviewClientTest ( unittest . TestCase ) : [EOL] def test_get_preview_data_raise_exception ( self ) : [EOL] [docstring] [EOL] with app . test_request_context ( ) : [EOL] response = MockExceptionClient ( ) . get_preview_data ( params = { } ) [EOL] self . assertEqual ( json . loads ( response . data ) . get ( [string] ) , { } ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] def test_post_sql_json_incorrect_data_shape ( self ) : [EOL] [docstring] [EOL] with app . test_request_context ( ) : [EOL] response = MockBadDataClient ( ) . get_preview_data ( params = { } ) [EOL] self . assertEqual ( json . loads ( response . data ) . get ( [string] ) , { } ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . INTERNAL_SERVER_ERROR ) [EOL] [EOL] def test_post_sql_json_correct_data_shape ( self ) : [EOL] [docstring] [EOL] with app . test_request_context ( ) : [EOL] response = MockClient ( ) . get_preview_data ( params = { } , optionalHeaders = { [string] : [string] } ) [EOL] self . assertEqual ( json . loads ( response . data ) . get ( [string] ) , expected_results ) [EOL] self . assertEqual ( response . status_code , HTTPStatus . OK ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , List , Any , Union [EOL] import amundsen_application [EOL] import typing [EOL] import unittest [EOL] [EOL] from amundsen_application . api . utils . metadata_utils import _convert_prog_descriptions , _sort_prog_descriptions , _parse_editable_rule [EOL] from amundsen_application . config import MatchRuleObject [EOL] from amundsen_application import create_app [EOL] [EOL] local_app = create_app ( [string] , [string] ) [EOL] [EOL] [EOL] class ProgrammaticDescriptionsTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] pass [EOL] [EOL] def test_convert_prog_descriptions ( self ) : [EOL] with local_app . app_context ( ) : [EOL] [comment] [EOL] test_config = { [string] : { [string] : { } , [string] : { [string] : [number] } , } , [string] : { [string] : { [string] : [number] } , [string] : { [string] : [number] } , } , [string] : { [string] : [number] } , } [EOL] [comment] [EOL] test_desc = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] [EOL] [comment] [EOL] expected_programmatic_desc = { [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] } [EOL] local_app . config [ [string] ] = test_config [EOL] [EOL] result = _convert_prog_descriptions ( test_desc ) [EOL] self . assertEqual ( result . get ( [string] ) , expected_programmatic_desc . get ( [string] ) ) [EOL] self . assertEqual ( result . get ( [string] ) , expected_programmatic_desc . get ( [string] ) ) [EOL] self . assertEqual ( result . get ( [string] ) , expected_programmatic_desc . get ( [string] ) ) [EOL] [EOL] def test_sort_prog_descriptions_returns_value_from_config ( self ) : [EOL] [docstring] [EOL] with local_app . app_context ( ) : [EOL] mock_order = [number] [EOL] mock_config = { [string] : { [string] : mock_order } } [EOL] in_config_value = { [string] : [string] , [string] : [string] } [EOL] self . assertEqual ( _sort_prog_descriptions ( mock_config , in_config_value ) , mock_order ) [EOL] [EOL] def test_sort_prog_descriptions_returns_default_value ( self ) : [EOL] [docstring] [EOL] with local_app . app_context ( ) : [EOL] mock_config = { [string] : { [string] : [number] } } [EOL] not_in_config_value = { [string] : [string] , [string] : [string] } [EOL] self . assertEqual ( _sort_prog_descriptions ( mock_config , not_in_config_value ) , len ( mock_config ) ) [EOL] [EOL] [EOL] class UneditableTableDescriptionTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] pass [EOL] [EOL] def test_table_desc_match_rule_schema_only ( self ) : [EOL] [comment] [EOL] test_match_rule = MatchRuleObject ( schema_regex = [string] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( _parse_editable_rule ( test_match_rule , [string] , [string] ) , False ) [EOL] self . assertEqual ( _parse_editable_rule ( test_match_rule , [string] , [string] ) , True ) [EOL] [EOL] def test_table_desc_match_rule_table_only ( self ) : [EOL] [comment] [EOL] test_match_rule = MatchRuleObject ( table_name_regex = [string] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( _parse_editable_rule ( test_match_rule , [string] , [string] ) , False ) [EOL] self . assertEqual ( _parse_editable_rule ( test_match_rule , [string] , [string] ) , True ) [EOL] [EOL] def test_table_desc_match_rule_schema_and_table ( self ) : [EOL] [comment] [EOL] test_match_rule = MatchRuleObject ( schema_regex = [string] , table_name_regex = [string] ) [EOL] [comment] [EOL] self . assertEqual ( _parse_editable_rule ( test_match_rule , [string] , [string] ) , False ) [EOL] self . assertEqual ( _parse_editable_rule ( test_match_rule , [string] , [string] ) , True ) [EOL] self . assertEqual ( _parse_editable_rule ( test_match_rule , [string] , [string] ) , True ) [EOL] self . assertEqual ( _parse_editable_rule ( test_match_rule , [string] , [string] ) , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.config.MatchRuleObject$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Union [EOL] import typing [EOL] import unittest [EOL] [EOL] from amundsen_application . api . utils . search_utils import generate_query_json , has_filters , transform_filters [EOL] [EOL] [EOL] class SearchUtilsTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . test_filters = { [string] : [string] , [string] : [string] , [string] : { [string] : True , [string] : False , [string] : True , } , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] self . expected_transformed_filters = { [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] self . test_page_index = [string] [EOL] self . test_term = [string] [EOL] [EOL] def test_transform_filters ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( transform_filters ( filters = self . test_filters , resource = [string] ) , self . expected_transformed_filters ) [EOL] [EOL] def test_generate_query_json ( self ) : [EOL] [docstring] [EOL] query_json = generate_query_json ( filters = self . expected_transformed_filters , page_index = self . test_page_index , search_term = self . test_term ) [EOL] self . assertEqual ( query_json . get ( [string] ) , int ( self . test_page_index ) ) [EOL] self . assertEqual ( query_json . get ( [string] ) , { [string] : [string] , [string] : self . expected_transformed_filters } ) [EOL] self . assertEqual ( query_json . get ( [string] ) , self . test_term ) [EOL] [EOL] def test_has_filters_return_true ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( has_filters ( filters = self . expected_transformed_filters , resource = [string] ) ) [EOL] [EOL] def test_has_filters_return_false ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( has_filters ( filters = { [string] : [ [string] ] } , resource = [string] ) ) [EOL] self . assertFalse ( has_filters ( filters = { [string] : [ ] } , resource = [string] ) ) [EOL] self . assertFalse ( has_filters ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import flask [EOL] import typing [EOL] import json [EOL] import unittest [EOL] [EOL] from amundsen_application import create_app [EOL] from amundsen_application . api . utils . response_utils import create_error_response [EOL] [EOL] local_app = create_app ( [string] , [string] ) [EOL] [EOL] [EOL] class ResponseUtilsTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] pass [EOL] [EOL] def test_create_error_response ( self ) : [EOL] [docstring] [EOL] test_message = [string] [EOL] test_payload = { } [EOL] status_code = [number] [EOL] with local_app . app_context ( ) : [EOL] response = create_error_response ( message = test_message , payload = test_payload , status_code = status_code ) [EOL] data = json . loads ( response . data ) [EOL] self . assertEqual ( response . status_code , status_code ) [EOL] self . assertEqual ( data . get ( [string] ) , test_message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $flask.wrappers.Response$ 0 $typing.Any$ 0 0 0 0 0 0 $flask.wrappers.Response$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Generator , Dict , List , Callable [EOL] import flask [EOL] import typing [EOL] import getpass [EOL] import socket [EOL] import unittest [EOL] from contextlib import contextmanager [EOL] from typing import Generator , Any [EOL] [EOL] import flask [EOL] [EOL] from amundsen_application . log import action_log , action_log_callback [EOL] from amundsen_application . log . action_log import action_logging [EOL] from amundsen_application . log . action_log import get_epoch_millisec [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] app = flask . Flask ( __name__ ) [EOL] app . config . from_object ( [string] ) [EOL] [EOL] [EOL] class ActionLogTest ( unittest . TestCase ) : [EOL] [EOL] def test_metrics_build ( self ) : [EOL] [comment] [EOL] with app . test_request_context ( ) : [EOL] func_name = [string] [EOL] metrics = action_log . _build_metrics ( func_name , [string] , [number] , foo = [string] ) [EOL] [EOL] expected = { [string] : [string] , [string] : socket . gethostname ( ) , [string] : [string] , [string] : [string] , [string] : getpass . getuser ( ) } [EOL] [EOL] for k , v in expected . items ( ) : [EOL] self . assertEquals ( v , metrics . get ( k ) ) [EOL] [EOL] self . assertTrue ( metrics . get ( [string] ) <= get_epoch_millisec ( ) ) [comment] [EOL] [EOL] def test_fail_function ( self ) : [EOL] [docstring] [EOL] with app . test_request_context ( ) , self . assertRaises ( NotImplementedError ) : [EOL] fail_func ( ) [EOL] [EOL] def test_success_function ( self ) : [EOL] [docstring] [EOL] with app . test_request_context ( ) , fail_action_logger_callback ( ) : [EOL] success_func ( ) [EOL] [EOL] [EOL] @ contextmanager def fail_action_logger_callback ( ) : [EOL] [docstring] [EOL] tmp = action_log_callback . __pre_exec_callbacks [ : ] [EOL] [EOL] def fail_callback ( _action_callback ) : [EOL] raise NotImplementedError [EOL] [EOL] action_log_callback . register_pre_exec_callback ( fail_callback ) [EOL] yield [EOL] action_log_callback . __pre_exec_callbacks = tmp [EOL] [EOL] [EOL] @ action_logging def fail_func ( ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] @ action_logging def success_func ( ) : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import amundsen_application [EOL] import unittest [EOL] from amundsen_application . models . data_issue import DataIssue [EOL] [EOL] [EOL] class DataIssueTest ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . issue_key = [string] [EOL] self . title = [string] [EOL] self . url = [string] [EOL] self . status = [string] [EOL] self . priority = [string] [EOL] self . maxDiff = None [EOL] [EOL] def test_mapping_priority ( self ) : [EOL] expected_priority_name = [string] [EOL] expected_priority_display_name = [string] [EOL] data_issue = DataIssue ( issue_key = self . issue_key , title = self . title , url = self . url , status = self . status , priority = self . priority ) [EOL] self . assertEqual ( data_issue . priority_display_name , expected_priority_display_name ) [EOL] self . assertEqual ( data_issue . priority_name , expected_priority_name ) [EOL] self . assertEqual ( data_issue . issue_key , self . issue_key ) [EOL] self . assertEqual ( data_issue . title , self . title ) [EOL] self . assertEqual ( data_issue . url , self . url ) [EOL] self . assertEqual ( data_issue . status , self . status ) [EOL] [EOL] def test_mapping_priorty_missing ( self ) : [EOL] expected_priority_name = None [comment] [EOL] expected_priority_display_name = None [comment] [EOL] data_issue = DataIssue ( issue_key = self . issue_key , title = self . title , url = self . url , status = self . status , priority = [string] ) [EOL] self . assertEqual ( data_issue . priority_display_name , expected_priority_display_name ) [EOL] self . assertEqual ( data_issue . priority_name , expected_priority_name ) [EOL] self . assertEqual ( data_issue . issue_key , self . issue_key ) [EOL] self . assertEqual ( data_issue . title , self . title ) [EOL] self . assertEqual ( data_issue . url , self . url ) [EOL] self . assertEqual ( data_issue . status , self . status ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 $None$ 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 $None$ 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 $amundsen_application.models.data_issue.DataIssue$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL]	0 0 0 0