from typing import Any [EOL] import typing [EOL] from setuptools import setup [EOL] [EOL] FALLBACK_V_PATH = [string] [EOL] FALLBACK_V_FROM_SCM_PATH = ( [string] ) [EOL] [EOL] [EOL] def parse_version ( version ) : [EOL] [docstring] [EOL] global parse_version [EOL] try : [EOL] from pkg_resources import parse_version [EOL] except ImportError : [EOL] from distutils . version import LooseVersion as parse_version [EOL] return parse_version ( version ) [EOL] [EOL] [EOL] with open ( FALLBACK_V_PATH ) as f : [EOL] fb_version_str = f . read ( ) . strip ( ) [EOL] [EOL] try : [EOL] with open ( FALLBACK_V_FROM_SCM_PATH ) as f : [EOL] fb_version_from_scm_str = f . read ( ) . strip ( ) [EOL] [EOL] fb_version_from_scm = parse_version ( fb_version_from_scm_str ) [EOL] if parse_version ( fb_version_str ) < fb_version_from_scm : [EOL] fb_version_str = fb_version_from_scm_str [EOL] [EOL] except FileNotFoundError : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] setup ( use_scm_version = { [string] : FALLBACK_V_FROM_SCM_PATH , [string] : fb_version_str , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0
[EOL] def test_dummy ( ) : [EOL] pass [EOL]	0 0 $None$ 0 0 0 0 0 0
import jrg_pypi2nix_tests . pycemagic [EOL] from jrg_pypi2nix_tests . main_lib import main [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import pathlib [EOL] import typing [EOL] import sys [EOL] import os [EOL] from pyce import PYCEPathFinder [EOL] from json import loads [EOL] from pathlib import Path [EOL] [EOL] [EOL] def install_pyce_w_keys ( ) : [EOL] pyce_key_file = None [EOL] try : [EOL] pyce_key_file_env_str = os . environ [ [string] ] . strip ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if pyce_key_file_env_str : [EOL] pyce_key_file = Path ( pyce_key_file_env_str ) [EOL] [comment] [EOL] pyce_key_file . stat ( ) [EOL] except KeyError : [EOL] [comment] [EOL] [comment] [EOL] pyce_key_file = Path ( [string] ) [EOL] try : [EOL] [comment] [EOL] pyce_key_file . stat ( ) [EOL] except FileNotFoundError : [EOL] pass [EOL] [EOL] if pyce_key_file is not None : [EOL] pyce_key_dict = loads ( pyce_key_file . read_text ( ) ) [EOL] PYCEPathFinder . KEYS = pyce_key_dict [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . meta_path . insert ( [number] , PYCEPathFinder ) [EOL] [EOL] [EOL] install_pyce_w_keys ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . _my_sub_package . hello import say_hello [EOL] [EOL] [EOL] def main ( ) : [EOL] say_hello ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import itertools [EOL] from time import sleep [EOL] [EOL] [EOL] def say_hello ( ) : [EOL] print ( [string] ) [EOL] for s in itertools . repeat ( [string] , [number] ) : [EOL] sleep ( [number] ) [EOL] print ( s ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Set , Any , Optional [EOL] import pathlib [EOL] import logging [EOL] import typing [EOL] import release_tools [EOL] import builtins [EOL] import argparse [EOL] import argparse [EOL] import os . path [EOL] import logging [EOL] import itertools [EOL] import json [EOL] from pyce import encrypt_path [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] from typing import List , Optional [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class _Args : [EOL] paths_to_encrypt = ... [EOL] project_root_dir = ... [EOL] output_file = ... [EOL] excluded_files = ... [EOL] [EOL] [EOL] def _parse_args ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , help = [string] , default = [ ] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] paths_to_encrypt = [ Path ( p ) for p in args . paths ] [EOL] project_root_dir = None if args . root_dir is None else Path ( args . root_dir ) [EOL] output_file = None if args . output_file is None else Path ( args . output_file ) [EOL] excluded_files = [ Path ( p ) for p in args . excluded_files ] [EOL] [EOL] return _Args ( paths_to_encrypt = paths_to_encrypt , project_root_dir = project_root_dir , output_file = output_file , excluded_files = excluded_files ) [EOL] [EOL] [EOL] def main ( ) : [EOL] args = _parse_args ( ) [EOL] LOGGER . info ( [string] ) [EOL] paths = [ p . expanduser ( ) . resolve ( ) for p in args . paths_to_encrypt ] [EOL] excluded = [ p . expanduser ( ) . resolve ( ) for p in args . excluded_files ] [EOL] [EOL] for p in paths : [EOL] [comment] [EOL] p . stat ( ) [EOL] [comment] [EOL] [EOL] for p in excluded : [EOL] [comment] [EOL] p . stat ( ) [EOL] [comment] [EOL] [EOL] if args . project_root_dir is None : [EOL] root_dir = Path . cwd ( ) [EOL] else : [EOL] [comment] [EOL] args . project_root_dir . stat ( ) [EOL] root_dir = args . project_root_dir . resolve ( ) [EOL] [EOL] if args . output_file is not None : [EOL] [comment] [EOL] args . output_file . parent . stat ( ) [EOL] [EOL] excluded_set = set ( excluded ) [EOL] encrypted_paths = [ encrypt_path ( p , exclusions = excluded_set ) for p in paths ] [EOL] [EOL] def mk_rel_to_root ( k ) : [EOL] kp = Path ( k ) [EOL] [comment] [EOL] kp . stat ( ) [EOL] return str ( kp . relative_to ( root_dir ) ) [EOL] [EOL] per_path_key = list ( itertools . chain . from_iterable ( encrypted_paths ) ) [EOL] per_path_key_dict = { mk_rel_to_root ( k ) : v for k , v in per_path_key } [EOL] per_path_key_json = json . dumps ( per_path_key_dict , sort_keys = True , indent = [number] ) [EOL] [EOL] if args . output_file is None : [EOL] [comment] [EOL] print ( per_path_key_json ) [EOL] else : [EOL] [comment] [EOL] args . output_file . write_text ( per_path_key_json ) [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 $_Args$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0