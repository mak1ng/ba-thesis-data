[docstring] [EOL]	0 0
from typing import Any , Generator , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ATTR_ENTITY_ID , CONF_ICON , CONF_NAME [EOL] from homeassistant . loader import bind_hass [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . restore_state import async_get_last_state [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] CONF_INITIAL = [string] [EOL] CONF_OPTIONS = [string] [EOL] [EOL] ATTR_OPTION = [string] [EOL] ATTR_OPTIONS = [string] [EOL] [EOL] SERVICE_SELECT_OPTION = [string] [EOL] [EOL] SERVICE_SELECT_OPTION_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_OPTION ) : cv . string , } ) [EOL] [EOL] SERVICE_SELECT_NEXT = [string] [EOL] [EOL] SERVICE_SELECT_NEXT_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] SERVICE_SELECT_PREVIOUS = [string] [EOL] [EOL] SERVICE_SELECT_PREVIOUS_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] [EOL] SERVICE_SET_OPTIONS = [string] [EOL] [EOL] SERVICE_SET_OPTIONS_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_OPTIONS ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def _cv_input_select ( cfg ) : [EOL] [docstring] [EOL] options = cfg [ CONF_OPTIONS ] [EOL] initial = cfg . get ( CONF_INITIAL ) [EOL] if initial is not None and initial not in options : [EOL] raise vol . Invalid ( [string] . format ( initial , [string] . join ( options ) ) ) [EOL] return cfg [EOL] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { cv . slug : vol . All ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Required ( CONF_OPTIONS ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) , [ cv . string ] ) , vol . Optional ( CONF_INITIAL ) : cv . string , vol . Optional ( CONF_ICON ) : cv . icon , } , _cv_input_select ) } ) } , required = True , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ bind_hass def select_option ( hass , entity_id , option ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_SELECT_OPTION , { ATTR_ENTITY_ID : entity_id , ATTR_OPTION : option , } ) [EOL] [EOL] [EOL] @ bind_hass def select_next ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_SELECT_NEXT , { ATTR_ENTITY_ID : entity_id , } ) [EOL] [EOL] [EOL] @ bind_hass def select_previous ( hass , entity_id ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_SELECT_PREVIOUS , { ATTR_ENTITY_ID : entity_id , } ) [EOL] [EOL] [EOL] @ bind_hass def set_options ( hass , entity_id , options ) : [EOL] [docstring] [EOL] hass . services . call ( DOMAIN , SERVICE_SET_OPTIONS , { ATTR_ENTITY_ID : entity_id , ATTR_OPTIONS : options , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass ) [EOL] [EOL] entities = [ ] [EOL] [EOL] for object_id , cfg in config [ DOMAIN ] . items ( ) : [EOL] name = cfg . get ( CONF_NAME ) [EOL] options = cfg . get ( CONF_OPTIONS ) [EOL] initial = cfg . get ( CONF_INITIAL ) [EOL] icon = cfg . get ( CONF_ICON ) [EOL] entities . append ( InputSelect ( object_id , name , initial , options , icon ) ) [EOL] [EOL] if not entities : [EOL] return False [EOL] [EOL] @ asyncio . coroutine def async_select_option_service ( call ) : [EOL] [docstring] [EOL] target_inputs = component . async_extract_from_service ( call ) [EOL] [EOL] tasks = [ input_select . async_select_option ( call . data [ ATTR_OPTION ] ) for input_select in target_inputs ] [EOL] if tasks : [EOL] yield from asyncio . wait ( tasks , loop = hass . loop ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_SELECT_OPTION , async_select_option_service , schema = SERVICE_SELECT_OPTION_SCHEMA ) [EOL] [EOL] @ asyncio . coroutine def async_select_next_service ( call ) : [EOL] [docstring] [EOL] target_inputs = component . async_extract_from_service ( call ) [EOL] [EOL] tasks = [ input_select . async_offset_index ( [number] ) for input_select in target_inputs ] [EOL] if tasks : [EOL] yield from asyncio . wait ( tasks , loop = hass . loop ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_SELECT_NEXT , async_select_next_service , schema = SERVICE_SELECT_NEXT_SCHEMA ) [EOL] [EOL] @ asyncio . coroutine def async_select_previous_service ( call ) : [EOL] [docstring] [EOL] target_inputs = component . async_extract_from_service ( call ) [EOL] [EOL] tasks = [ input_select . async_offset_index ( - [number] ) for input_select in target_inputs ] [EOL] if tasks : [EOL] yield from asyncio . wait ( tasks , loop = hass . loop ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_SELECT_PREVIOUS , async_select_previous_service , schema = SERVICE_SELECT_PREVIOUS_SCHEMA ) [EOL] [EOL] @ asyncio . coroutine def async_set_options_service ( call ) : [EOL] [docstring] [EOL] target_inputs = component . async_extract_from_service ( call ) [EOL] [EOL] tasks = [ input_select . async_set_options ( call . data [ ATTR_OPTIONS ] ) for input_select in target_inputs ] [EOL] if tasks : [EOL] yield from asyncio . wait ( tasks , loop = hass . loop ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_OPTIONS , async_set_options_service , schema = SERVICE_SET_OPTIONS_SCHEMA ) [EOL] [EOL] yield from component . async_add_entities ( entities ) [EOL] return True [EOL] [EOL] [EOL] class InputSelect ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , object_id , name , initial , options , icon ) : [EOL] [docstring] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( object_id ) [EOL] self . _name = name [EOL] self . _current_option = initial [EOL] self . _options = options [EOL] self . _icon = icon [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] if self . _current_option is not None : [EOL] return [EOL] [EOL] state = yield from async_get_last_state ( self . hass , self . entity_id ) [EOL] if not state or state . state not in self . _options : [EOL] self . _current_option = self . _options [ [number] ] [EOL] else : [EOL] self . _current_option = state . state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _current_option [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_OPTIONS : self . _options , } [EOL] [EOL] @ asyncio . coroutine def async_select_option ( self , option ) : [EOL] [docstring] [EOL] if option not in self . _options : [EOL] _LOGGER . warning ( [string] , option , [string] . join ( self . _options ) ) [EOL] return [EOL] self . _current_option = option [EOL] yield from self . async_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_offset_index ( self , offset ) : [EOL] [docstring] [EOL] current_index = self . _options . index ( self . _current_option ) [EOL] new_index = ( current_index + offset ) % len ( self . _options ) [EOL] self . _current_option = self . _options [ new_index ] [EOL] yield from self . async_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_set_options ( self , options ) : [EOL] [docstring] [EOL] self . _current_option = options [ [number] ] [EOL] self . _options = options [EOL] yield from self . async_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import datetime [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] import threading [EOL] [docstring] [EOL] from datetime import datetime , timedelta [EOL] from logging import getLogger [EOL] from os . path import exists [EOL] from threading import Lock [EOL] import pickle [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import EVENT_HOMEASSISTANT_START , CONF_SCAN_INTERVAL [EOL] from homeassistant . helpers . event import track_time_interval [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = getLogger ( __name__ ) [EOL] [EOL] CONF_URLS = [string] [EOL] CONF_MAX_ENTRIES = [string] [EOL] [EOL] DEFAULT_MAX_ENTRIES = [number] [EOL] DEFAULT_SCAN_INTERVAL = timedelta ( hours = [number] ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] EVENT_FEEDREADER = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : { vol . Required ( CONF_URLS ) : vol . All ( cv . ensure_list , [ cv . url ] ) , vol . Optional ( CONF_SCAN_INTERVAL , default = DEFAULT_SCAN_INTERVAL ) : cv . time_period , vol . Optional ( CONF_MAX_ENTRIES , default = DEFAULT_MAX_ENTRIES ) : cv . positive_int } } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] urls = config . get ( DOMAIN ) [ CONF_URLS ] [EOL] scan_interval = config . get ( DOMAIN ) . get ( CONF_SCAN_INTERVAL ) [EOL] max_entries = config . get ( DOMAIN ) . get ( CONF_MAX_ENTRIES ) [EOL] data_file = hass . config . path ( [string] . format ( DOMAIN ) ) [EOL] storage = StoredData ( data_file ) [EOL] feeds = [ FeedManager ( url , scan_interval , max_entries , hass , storage ) for url in urls ] [EOL] return len ( feeds ) > [number] [EOL] [EOL] [EOL] class FeedManager : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , url , scan_interval , max_entries , hass , storage ) : [EOL] [docstring] [EOL] self . _url = url [EOL] self . _scan_interval = scan_interval [EOL] self . _max_entries = max_entries [EOL] self . _feed = None [EOL] self . _hass = hass [EOL] self . _firstrun = True [EOL] self . _storage = storage [EOL] self . _last_entry_timestamp = None [EOL] self . _last_update_successful = False [EOL] self . _has_published_parsed = False [EOL] self . _event_type = EVENT_FEEDREADER [EOL] self . _feed_id = url [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , lambda _ : self . _update ( ) ) [EOL] self . _init_regular_updates ( hass ) [EOL] [EOL] def _log_no_entries ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _url ) [EOL] [EOL] def _init_regular_updates ( self , hass ) : [EOL] [docstring] [EOL] track_time_interval ( hass , lambda now : self . _update ( ) , self . _scan_interval ) [EOL] [EOL] @ property def last_update_successful ( self ) : [EOL] [docstring] [EOL] return self . _last_update_successful [EOL] [EOL] def _update ( self ) : [EOL] [docstring] [EOL] import feedparser [EOL] _LOGGER . info ( [string] , self . _url ) [EOL] self . _feed = feedparser . parse ( self . _url , etag = None if not self . _feed [EOL] else self . _feed . get ( [string] ) , modified = None if not self . _feed [EOL] else self . _feed . get ( [string] ) ) [EOL] if not self . _feed : [EOL] _LOGGER . error ( [string] , self . _url ) [EOL] self . _last_update_successful = False [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . _feed . bozo != [number] : [EOL] _LOGGER . error ( [string] , self . _url , self . _feed . bozo_exception ) [EOL] [comment] [EOL] [comment] [EOL] if self . _feed . entries : [EOL] _LOGGER . debug ( [string] , len ( self . _feed . entries ) , self . _url ) [EOL] self . _filter_entries ( ) [EOL] self . _publish_new_entries ( ) [EOL] if self . _has_published_parsed : [EOL] self . _storage . put_timestamp ( self . _feed_id , self . _last_entry_timestamp ) [EOL] else : [EOL] self . _log_no_entries ( ) [EOL] self . _last_update_successful = True [EOL] _LOGGER . info ( [string] , self . _url ) [EOL] [EOL] def _filter_entries ( self ) : [EOL] [docstring] [EOL] if len ( self . _feed . entries ) > self . _max_entries : [EOL] _LOGGER . debug ( [string] [string] , self . _max_entries , self . _url ) [EOL] self . _feed . entries = self . _feed . entries [ [number] : self . _max_entries ] [EOL] [EOL] def _update_and_fire_entry ( self , entry ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if [string] in entry . keys ( ) : [EOL] self . _has_published_parsed = True [EOL] self . _last_entry_timestamp = max ( entry . published_parsed , self . _last_entry_timestamp ) [EOL] else : [EOL] self . _has_published_parsed = False [EOL] _LOGGER . debug ( [string] , entry . title ) [EOL] entry . update ( { [string] : self . _url } ) [EOL] self . _hass . bus . fire ( self . _event_type , entry ) [EOL] [EOL] def _publish_new_entries ( self ) : [EOL] [docstring] [EOL] new_entries = False [EOL] self . _last_entry_timestamp = self . _storage . get_timestamp ( self . _feed_id ) [EOL] if self . _last_entry_timestamp : [EOL] self . _firstrun = False [EOL] else : [EOL] [comment] [EOL] self . _last_entry_timestamp = datetime . utcfromtimestamp ( [number] ) . timetuple ( ) [EOL] for entry in self . _feed . entries : [EOL] if self . _firstrun or ( [string] in entry . keys ( ) and entry . published_parsed > self . _last_entry_timestamp ) : [EOL] self . _update_and_fire_entry ( entry ) [EOL] new_entries = True [EOL] else : [EOL] _LOGGER . debug ( [string] , entry . title ) [EOL] if not new_entries : [EOL] self . _log_no_entries ( ) [EOL] self . _firstrun = False [EOL] [EOL] [EOL] class StoredData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data_file ) : [EOL] [docstring] [EOL] self . _data_file = data_file [EOL] self . _lock = Lock ( ) [EOL] self . _cache_outdated = True [EOL] self . _data = { } [EOL] self . _fetch_data ( ) [EOL] [EOL] def _fetch_data ( self ) : [EOL] [docstring] [EOL] if self . _cache_outdated and exists ( self . _data_file ) : [EOL] try : [EOL] _LOGGER . debug ( [string] , self . _data_file ) [EOL] with self . _lock , open ( self . _data_file , [string] ) as myfile : [EOL] self . _data = pickle . load ( myfile ) or { } [EOL] self . _cache_outdated = False [EOL] except : [comment] [EOL] _LOGGER . error ( [string] , self . _data_file ) [EOL] [EOL] def get_timestamp ( self , feed_id ) : [EOL] [docstring] [EOL] self . _fetch_data ( ) [EOL] return self . _data . get ( feed_id ) [EOL] [EOL] def put_timestamp ( self , feed_id , timestamp ) : [EOL] [docstring] [EOL] self . _fetch_data ( ) [EOL] with self . _lock , open ( self . _data_file , [string] ) as myfile : [EOL] self . _data . update ( { feed_id : timestamp } ) [EOL] _LOGGER . debug ( [string] , feed_id , self . _data_file ) [EOL] try : [EOL] pickle . dump ( self . _data , myfile ) [EOL] except : [comment] [EOL] _LOGGER . error ( [string] , self . _data_file ) [EOL] self . _cache_outdated = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_ICON , CONF_URL ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import slugify [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ENTITIES = [string] [EOL] CONF_RELATIVE_URL_ERROR_MSG = [string] [EOL] CONF_RELATIVE_URL_REGEX = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] ENTITIES_SCHEMA = vol . Schema ( { vol . Required ( CONF_URL ) : vol . Any ( vol . Match ( CONF_RELATIVE_URL_REGEX , msg = CONF_RELATIVE_URL_ERROR_MSG ) , vol . Url ( ) ) , vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_ICON ) : cv . icon , } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_ENTITIES ) : [ ENTITIES_SCHEMA ] , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] links = config . get ( DOMAIN ) [EOL] [EOL] for link in links . get ( CONF_ENTITIES ) : [EOL] Link ( hass , link . get ( CONF_NAME ) , link . get ( CONF_URL ) , link . get ( CONF_ICON ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class Link ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , url , icon ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _name = name [EOL] self . _url = url [EOL] self . _icon = icon [EOL] self . entity_id = DOMAIN + [string] % slugify ( name ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _url [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import logging [EOL] import voluptuous as vol [EOL] from homeassistant . const import ( EVENT_HOMEASSISTANT_START , EVENT_HOMEASSISTANT_STOP ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_FOLDER = [string] [EOL] CONF_PATTERNS = [string] [EOL] DEFAULT_PATTERN = [string] [EOL] DOMAIN = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . All ( cv . ensure_list , [ vol . Schema ( { vol . Required ( CONF_FOLDER ) : cv . isdir , vol . Optional ( CONF_PATTERNS , default = [ DEFAULT_PATTERN ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) ] ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config [ DOMAIN ] [EOL] for watcher in conf : [EOL] path = watcher [ CONF_FOLDER ] [EOL] patterns = watcher [ CONF_PATTERNS ] [EOL] if not hass . config . is_allowed_path ( path ) : [EOL] _LOGGER . error ( [string] , path ) [EOL] return False [EOL] Watcher ( path , patterns , hass ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def create_event_handler ( patterns , hass ) : [EOL] [docstring] [EOL] from watchdog . events import PatternMatchingEventHandler [EOL] [EOL] class EventHandler ( PatternMatchingEventHandler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , patterns , hass ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( patterns ) [EOL] self . hass = hass [EOL] [EOL] def process ( self , event ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , event ) [EOL] if not event . is_directory : [EOL] folder , file_name = os . path . split ( event . src_path ) [EOL] self . hass . bus . fire ( DOMAIN , { [string] : event . event_type , [string] : event . src_path , [string] : file_name , [string] : folder , } ) [EOL] [EOL] def on_modified ( self , event ) : [EOL] [docstring] [EOL] self . process ( event ) [EOL] [EOL] def on_moved ( self , event ) : [EOL] [docstring] [EOL] self . process ( event ) [EOL] [EOL] def on_created ( self , event ) : [EOL] [docstring] [EOL] self . process ( event ) [EOL] [EOL] def on_deleted ( self , event ) : [EOL] [docstring] [EOL] self . process ( event ) [EOL] [EOL] return EventHandler ( patterns , hass ) [EOL] [EOL] [EOL] class Watcher ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , patterns , hass ) : [EOL] [docstring] [EOL] from watchdog . observers import Observer [EOL] self . _observer = Observer ( ) [EOL] self . _observer . schedule ( create_event_handler ( patterns , hass ) , path , recursive = True ) [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , self . startup ) [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , self . shutdown ) [EOL] [EOL] def startup ( self , event ) : [EOL] [docstring] [EOL] self . _observer . start ( ) [EOL] [EOL] def shutdown ( self , event ) : [EOL] [docstring] [EOL] self . _observer . stop ( ) [EOL] self . _observer . join ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import CONF_HOST [EOL] from homeassistant . helpers import discovery [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] LUTRON_CASETA_SMARTBRIDGE = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] CONF_KEYFILE = [string] [EOL] CONF_CERTFILE = [string] [EOL] CONF_CA_CERTS = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_KEYFILE ) : cv . string , vol . Required ( CONF_CERTFILE ) : cv . string , vol . Required ( CONF_CA_CERTS ) : cv . string } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] LUTRON_CASETA_COMPONENTS = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , base_config ) : [EOL] [docstring] [EOL] from pylutron_caseta . smartbridge import Smartbridge [EOL] [EOL] config = base_config . get ( DOMAIN ) [EOL] keyfile = hass . config . path ( config [ CONF_KEYFILE ] ) [EOL] certfile = hass . config . path ( config [ CONF_CERTFILE ] ) [EOL] ca_certs = hass . config . path ( config [ CONF_CA_CERTS ] ) [EOL] bridge = Smartbridge . create_tls ( hostname = config [ CONF_HOST ] , keyfile = keyfile , certfile = certfile , ca_certs = ca_certs ) [EOL] hass . data [ LUTRON_CASETA_SMARTBRIDGE ] = bridge [EOL] yield from bridge . connect ( ) [EOL] if not hass . data [ LUTRON_CASETA_SMARTBRIDGE ] . is_connected ( ) : [EOL] _LOGGER . error ( [string] , config [ CONF_HOST ] ) [EOL] return False [EOL] [EOL] _LOGGER . info ( [string] , config [ CONF_HOST ] ) [EOL] [EOL] for component in LUTRON_CASETA_COMPONENTS : [EOL] hass . async_create_task ( discovery . async_load_platform ( hass , component , DOMAIN , { } , config ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class LutronCasetaDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , bridge ) : [EOL] [docstring] [EOL] self . _device_id = device [ [string] ] [EOL] self . _device_type = device [ [string] ] [EOL] self . _device_name = device [ [string] ] [EOL] self . _device_zone = device [ [string] ] [EOL] self . _state = None [EOL] self . _smartbridge = bridge [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _smartbridge . add_subscriber ( self . _device_id , self . async_schedule_update_ha_state ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _device_name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { [string] : self . _device_id , [string] : self . _device_zone , } [EOL] return attr [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from homeassistant . components . fan import ( ENTITY_ID_FORMAT , FanEntity , SUPPORT_OSCILLATE , SUPPORT_SET_SPEED ) [EOL] from homeassistant . components . tuya import DATA_TUYA , TuyaDevice [EOL] from homeassistant . const import STATE_OFF [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] tuya = hass . data [ DATA_TUYA ] [EOL] dev_ids = discovery_info . get ( [string] ) [EOL] devices = [ ] [EOL] for dev_id in dev_ids : [EOL] device = tuya . get_device_by_id ( dev_id ) [EOL] if device is None : [EOL] continue [EOL] devices . append ( TuyaFanDevice ( device ) ) [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class TuyaFanDevice ( TuyaDevice , FanEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tuya ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( tuya ) [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( tuya . object_id ( ) ) [EOL] self . speeds = [ STATE_OFF ] [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] await super ( ) . async_added_to_hass ( ) [EOL] self . speeds . extend ( self . tuya . speed_list ( ) ) [EOL] [EOL] def set_speed ( self , speed ) : [EOL] [docstring] [EOL] if speed == STATE_OFF : [EOL] self . turn_off ( ) [EOL] else : [EOL] self . tuya . set_speed ( speed ) [EOL] [EOL] def turn_on ( self , speed = None , ** kwargs ) : [EOL] [docstring] [EOL] if speed is not None : [EOL] self . set_speed ( speed ) [EOL] else : [EOL] self . tuya . turn_on ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . tuya . turn_off ( ) [EOL] [EOL] def oscillate ( self , oscillating ) : [EOL] [docstring] [EOL] self . tuya . oscillate ( oscillating ) [EOL] [EOL] @ property def oscillating ( self ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_OSCILLATE == [number] : [EOL] return None [EOL] if self . speed == STATE_OFF : [EOL] return False [EOL] return self . tuya . oscillating ( ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . tuya . state ( ) [EOL] [EOL] @ property def speed ( self ) : [EOL] [docstring] [EOL] if self . is_on : [EOL] return self . tuya . speed ( ) [EOL] return STATE_OFF [EOL] [EOL] @ property def speed_list ( self ) : [EOL] [docstring] [EOL] return self . speeds [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] supports = SUPPORT_SET_SPEED [EOL] if self . tuya . support_oscillate ( ) : [EOL] supports = supports | SUPPORT_OSCILLATE [EOL] return supports [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from time import sleep [EOL] [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] from homeassistant . components . verisure import CONF_ALARM , CONF_CODE_DIGITS [EOL] from homeassistant . components . verisure import HUB as hub [EOL] from homeassistant . const import ( STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_UNKNOWN ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] alarms = [ ] [EOL] if int ( hub . config . get ( CONF_ALARM , [number] ) ) : [EOL] hub . update_overview ( ) [EOL] alarms . append ( VerisureAlarm ( ) ) [EOL] add_devices ( alarms ) [EOL] [EOL] [EOL] def set_arm_state ( state , code = None ) : [EOL] [docstring] [EOL] transaction_id = hub . session . set_arm_state ( code , state ) [ [string] ] [EOL] _LOGGER . info ( [string] , state ) [EOL] transaction = { } [EOL] while [string] not in transaction : [EOL] sleep ( [number] ) [EOL] transaction = hub . session . get_arm_state_transaction ( transaction_id ) [EOL] [comment] [EOL] hub . update_overview ( no_throttle = True ) [EOL] [EOL] [EOL] class VerisureAlarm ( alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_UNKNOWN [EOL] self . _digits = hub . config . get ( CONF_CODE_DIGITS ) [EOL] self . _changed_by = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( hub . session . installations [ [number] ] [ [string] ] ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def changed_by ( self ) : [EOL] [docstring] [EOL] return self . _changed_by [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] hub . update_overview ( ) [EOL] status = hub . get_first ( [string] ) [EOL] if status == [string] : [EOL] self . _state = STATE_ALARM_DISARMED [EOL] elif status == [string] : [EOL] self . _state = STATE_ALARM_ARMED_HOME [EOL] elif status == [string] : [EOL] self . _state = STATE_ALARM_ARMED_AWAY [EOL] elif status != [string] : [EOL] _LOGGER . error ( [string] , status ) [EOL] self . _changed_by = hub . get_first ( [string] ) [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] set_arm_state ( [string] , code ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] set_arm_state ( [string] , code ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] set_arm_state ( [string] , code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] from homeassistant . components . alarm_control_panel import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_PASSWORD , CONF_USERNAME , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_ARMED_NIGHT , STATE_ALARM_DISARMED , STATE_ALARM_ARMING , STATE_ALARM_DISARMING , STATE_UNKNOWN , CONF_NAME , STATE_ALARM_ARMED_CUSTOM_BYPASS ) [EOL] [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] total_connect = TotalConnect ( name , username , password ) [EOL] add_devices ( [ total_connect ] , True ) [EOL] [EOL] [EOL] class TotalConnect ( alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , username , password ) : [EOL] [docstring] [EOL] from total_connect_client import TotalConnectClient [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] self . _name = name [EOL] self . _username = username [EOL] self . _password = password [EOL] self . _state = STATE_UNKNOWN [EOL] self . _client = TotalConnectClient . TotalConnectClient ( username , password ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] status = self . _client . get_armed_status ( ) [EOL] [EOL] if status == self . _client . DISARMED : [EOL] state = STATE_ALARM_DISARMED [EOL] elif status == self . _client . ARMED_STAY : [EOL] state = STATE_ALARM_ARMED_HOME [EOL] elif status == self . _client . ARMED_AWAY : [EOL] state = STATE_ALARM_ARMED_AWAY [EOL] elif status == self . _client . ARMED_STAY_NIGHT : [EOL] state = STATE_ALARM_ARMED_NIGHT [EOL] elif status == self . _client . ARMED_CUSTOM_BYPASS : [EOL] state = STATE_ALARM_ARMED_CUSTOM_BYPASS [EOL] elif status == self . _client . ARMING : [EOL] state = STATE_ALARM_ARMING [EOL] elif status == self . _client . DISARMING : [EOL] state = STATE_ALARM_DISARMING [EOL] else : [EOL] state = STATE_UNKNOWN [EOL] [EOL] self . _state = state [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] self . _client . disarm ( ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] self . _client . arm_stay ( ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] self . _client . arm_away ( ) [EOL] [EOL] def alarm_arm_night ( self , code = None ) : [EOL] [docstring] [EOL] self . _client . arm_stay_night ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import datetime [EOL] from homeassistant . components . alarm_control_panel import manual [EOL] from homeassistant . const import ( STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_CUSTOM_BYPASS , STATE_ALARM_ARMED_HOME , STATE_ALARM_ARMED_NIGHT , STATE_ALARM_DISARMED , STATE_ALARM_TRIGGERED , CONF_DELAY_TIME , CONF_PENDING_TIME , CONF_TRIGGER_TIME ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] add_devices ( [ manual . ManualAlarm ( hass , [string] , [string] , None , False , { STATE_ALARM_ARMED_AWAY : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_ARMED_HOME : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_ARMED_NIGHT : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_DISARMED : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_ARMED_CUSTOM_BYPASS : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_TRIGGERED : { CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , } , } ) , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . components . notify import ( ATTR_TITLE , ATTR_TITLE_DEFAULT , PLATFORM_SCHEMA , BaseNotificationService ) [EOL] from homeassistant . const import CONF_FILENAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] CONF_TIMESTAMP = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_FILENAME ) : cv . string , vol . Optional ( CONF_TIMESTAMP , default = False ) : cv . boolean , } ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] filename = config [ CONF_FILENAME ] [EOL] timestamp = config [ CONF_TIMESTAMP ] [EOL] [EOL] return FileNotificationService ( hass , filename , timestamp ) [EOL] [EOL] [EOL] class FileNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , filename , add_timestamp ) : [EOL] [docstring] [EOL] self . filepath = os . path . join ( hass . config . config_dir , filename ) [EOL] self . add_timestamp = add_timestamp [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] with open ( self . filepath , [string] ) as file : [EOL] if os . stat ( self . filepath ) . st_size == [number] : [EOL] title = [string] . format ( kwargs . get ( ATTR_TITLE , ATTR_TITLE_DEFAULT ) , dt_util . utcnow ( ) . isoformat ( ) , [string] * [number] ) [EOL] file . write ( title ) [EOL] [EOL] if self . add_timestamp : [EOL] text = [string] . format ( dt_util . utcnow ( ) . isoformat ( ) , message ) [EOL] else : [EOL] text = [string] . format ( message ) [EOL] file . write ( text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any , Dict [EOL] import io [EOL] import logging [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] import io [EOL] import base64 [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . notify import ( ATTR_TITLE , ATTR_TITLE_DEFAULT , ATTR_DATA , BaseNotificationService , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import CONF_TIMEOUT [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_IP = [string] [EOL] CONF_DURATION = [string] [EOL] CONF_POSITION = [string] [EOL] CONF_TRANSPARENCY = [string] [EOL] CONF_COLOR = [string] [EOL] CONF_INTERRUPT = [string] [EOL] [EOL] DEFAULT_DURATION = [number] [EOL] DEFAULT_POSITION = [string] [EOL] DEFAULT_TRANSPARENCY = [string] [EOL] DEFAULT_COLOR = [string] [EOL] DEFAULT_INTERRUPT = False [EOL] DEFAULT_TIMEOUT = [number] [EOL] DEFAULT_ICON = ( [string] [string] ) [EOL] [EOL] ATTR_DURATION = [string] [EOL] ATTR_POSITION = [string] [EOL] ATTR_TRANSPARENCY = [string] [EOL] ATTR_COLOR = [string] [EOL] ATTR_BKGCOLOR = [string] [EOL] ATTR_INTERRUPT = [string] [EOL] [EOL] POSITIONS = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] TRANSPARENCIES = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] COLORS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_IP ) : cv . string , vol . Optional ( CONF_DURATION , default = DEFAULT_DURATION ) : vol . Coerce ( int ) , vol . Optional ( CONF_POSITION , default = DEFAULT_POSITION ) : vol . In ( POSITIONS . keys ( ) ) , vol . Optional ( CONF_TRANSPARENCY , default = DEFAULT_TRANSPARENCY ) : vol . In ( TRANSPARENCIES . keys ( ) ) , vol . Optional ( CONF_COLOR , default = DEFAULT_COLOR ) : vol . In ( COLORS . keys ( ) ) , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : vol . Coerce ( int ) , vol . Optional ( CONF_INTERRUPT , default = DEFAULT_INTERRUPT ) : cv . boolean , } ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] remoteip = config . get ( CONF_IP ) [EOL] duration = config . get ( CONF_DURATION ) [EOL] position = config . get ( CONF_POSITION ) [EOL] transparency = config . get ( CONF_TRANSPARENCY ) [EOL] color = config . get ( CONF_COLOR ) [EOL] interrupt = config . get ( CONF_INTERRUPT ) [EOL] timeout = config . get ( CONF_TIMEOUT ) [EOL] [EOL] return NFAndroidTVNotificationService ( remoteip , duration , position , transparency , color , interrupt , timeout ) [EOL] [EOL] [EOL] class NFAndroidTVNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , remoteip , duration , position , transparency , color , interrupt , timeout ) : [EOL] [docstring] [EOL] self . _target = [string] . format ( remoteip ) [EOL] self . _default_duration = duration [EOL] self . _default_position = position [EOL] self . _default_transparency = transparency [EOL] self . _default_color = color [EOL] self . _default_interrupt = interrupt [EOL] self . _timeout = timeout [EOL] self . _icon_file = io . BytesIO ( base64 . b64decode ( DEFAULT_ICON ) ) [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _target ) [EOL] [EOL] payload = dict ( filename = ( [string] , self . _icon_file , [string] , { [string] : [string] } ) , type = [string] , title = kwargs . get ( ATTR_TITLE , ATTR_TITLE_DEFAULT ) , msg = message , duration = [string] % self . _default_duration , position = [string] % POSITIONS . get ( self . _default_position ) , bkgcolor = [string] % COLORS . get ( self . _default_color ) , transparency = [string] % TRANSPARENCIES . get ( self . _default_transparency ) , offset = [string] , app = ATTR_TITLE_DEFAULT , force = [string] , interrupt = [string] % self . _default_interrupt , ) [EOL] [EOL] data = kwargs . get ( ATTR_DATA ) [EOL] if data : [EOL] if ATTR_DURATION in data : [EOL] duration = data . get ( ATTR_DURATION ) [EOL] try : [EOL] payload [ ATTR_DURATION ] = [string] % int ( duration ) [EOL] except ValueError : [EOL] _LOGGER . warning ( [string] , str ( duration ) ) [EOL] if ATTR_POSITION in data : [EOL] position = data . get ( ATTR_POSITION ) [EOL] if position in POSITIONS : [EOL] payload [ ATTR_POSITION ] = [string] % POSITIONS . get ( position ) [EOL] else : [EOL] _LOGGER . warning ( [string] , str ( position ) ) [EOL] if ATTR_TRANSPARENCY in data : [EOL] transparency = data . get ( ATTR_TRANSPARENCY ) [EOL] if transparency in TRANSPARENCIES : [EOL] payload [ ATTR_TRANSPARENCY ] = [string] % TRANSPARENCIES . get ( transparency ) [EOL] else : [EOL] _LOGGER . warning ( [string] , str ( transparency ) ) [EOL] if ATTR_COLOR in data : [EOL] color = data . get ( ATTR_COLOR ) [EOL] if color in COLORS : [EOL] payload [ ATTR_BKGCOLOR ] = [string] % COLORS . get ( color ) [EOL] else : [EOL] _LOGGER . warning ( [string] , str ( color ) ) [EOL] if ATTR_INTERRUPT in data : [EOL] interrupt = data . get ( ATTR_INTERRUPT ) [EOL] try : [EOL] payload [ ATTR_INTERRUPT ] = [string] % cv . boolean ( interrupt ) [EOL] except vol . Invalid : [EOL] _LOGGER . warning ( [string] , str ( interrupt ) ) [EOL] [EOL] try : [EOL] _LOGGER . debug ( [string] , str ( payload ) ) [EOL] response = requests . post ( self . _target , files = payload , timeout = self . _timeout ) [EOL] if response . status_code != [number] : [EOL] _LOGGER . error ( [string] , str ( response ) ) [EOL] except requests . exceptions . ConnectionError as err : [EOL] _LOGGER . error ( [string] , self . _target , str ( err ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , List , Dict [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import datetime , timedelta [EOL] [EOL] from homeassistant . components . weather import ( WeatherEntity , ATTR_FORECAST_CONDITION , ATTR_FORECAST_PRECIPITATION , ATTR_FORECAST_TEMP , ATTR_FORECAST_TEMP_LOW , ATTR_FORECAST_TIME ) [EOL] from homeassistant . const import ( TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] [EOL] CONDITION_CLASSES = { [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ [string] ] , [string] : [ ] , [string] : [ ] , [string] : [ [string] ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] add_devices ( [ DemoWeather ( [string] , [string] , [number] , [number] , [number] , [number] , TEMP_CELSIUS , [ [ [string] , [number] , [number] , [number] ] , [ [string] , [number] , [number] , [number] ] , [ [string] , [number] , [number] , [number] ] , [ [string] , [number] , [number] , [number] ] , [ [string] , [number] , [number] , [number] ] , [ [string] , [number] , [number] , [number] ] , [ [string] , [number] , [number] , [number] ] ] ) , DemoWeather ( [string] , [string] , - [number] , [number] , [number] , [number] , TEMP_FAHRENHEIT , [ [ [string] , [number] , - [number] , - [number] ] , [ [string] , [number] , - [number] , - [number] ] , [ [string] , [number] , - [number] , - [number] ] , [ [string] , [number] , - [number] , - [number] ] , [ [string] , [number] , - [number] , - [number] ] , [ [string] , [number] , - [number] , - [number] ] , [ [string] , [number] , - [number] , - [number] ] ] ) ] ) [EOL] [EOL] [EOL] class DemoWeather ( WeatherEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , condition , temperature , humidity , pressure , wind_speed , temperature_unit , forecast ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _condition = condition [EOL] self . _temperature = temperature [EOL] self . _temperature_unit = temperature_unit [EOL] self . _humidity = humidity [EOL] self . _pressure = pressure [EOL] self . _wind_speed = wind_speed [EOL] self . _forecast = forecast [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( [string] , self . _name ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def temperature ( self ) : [EOL] [docstring] [EOL] return self . _temperature [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return self . _temperature_unit [EOL] [EOL] @ property def humidity ( self ) : [EOL] [docstring] [EOL] return self . _humidity [EOL] [EOL] @ property def wind_speed ( self ) : [EOL] [docstring] [EOL] return self . _wind_speed [EOL] [EOL] @ property def pressure ( self ) : [EOL] [docstring] [EOL] return self . _pressure [EOL] [EOL] @ property def condition ( self ) : [EOL] [docstring] [EOL] return [ k for k , v in CONDITION_CLASSES . items ( ) if self . _condition . lower ( ) in v ] [ [number] ] [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def forecast ( self ) : [EOL] [docstring] [EOL] reftime = datetime . now ( ) . replace ( hour = [number] , minute = [number] ) [EOL] [EOL] forecast_data = [ ] [EOL] for entry in self . _forecast : [EOL] data_dict = { ATTR_FORECAST_TIME : reftime . isoformat ( ) , ATTR_FORECAST_CONDITION : entry [ [number] ] , ATTR_FORECAST_PRECIPITATION : entry [ [number] ] , ATTR_FORECAST_TEMP : entry [ [number] ] , ATTR_FORECAST_TEMP_LOW : entry [ [number] ] } [EOL] reftime = reftime + timedelta ( hours = [number] ) [EOL] forecast_data . append ( data_dict ) [EOL] [EOL] return forecast_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] import telnetlib [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] import telnetlib [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( ENTITY_ID_FORMAT , PLATFORM_SCHEMA , SwitchDevice ) [EOL] from homeassistant . const import ( CONF_COMMAND_OFF , CONF_COMMAND_ON , CONF_COMMAND_STATE , CONF_NAME , CONF_PORT , CONF_RESOURCE , CONF_SWITCHES , CONF_VALUE_TEMPLATE ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] SWITCH_SCHEMA = vol . Schema ( { vol . Required ( CONF_COMMAND_OFF ) : cv . string , vol . Required ( CONF_COMMAND_ON ) : cv . string , vol . Required ( CONF_RESOURCE ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_COMMAND_STATE ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SWITCHES ) : vol . Schema ( { cv . slug : SWITCH_SCHEMA } ) , } ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] devices = config . get ( CONF_SWITCHES , { } ) [EOL] switches = [ ] [EOL] [EOL] for object_id , device_config in devices . items ( ) : [EOL] value_template = device_config . get ( CONF_VALUE_TEMPLATE ) [EOL] [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] switches . append ( TelnetSwitch ( hass , object_id , device_config . get ( CONF_RESOURCE ) , device_config . get ( CONF_PORT ) , device_config . get ( CONF_NAME , object_id ) , device_config . get ( CONF_COMMAND_ON ) , device_config . get ( CONF_COMMAND_OFF ) , device_config . get ( CONF_COMMAND_STATE ) , value_template ) ) [EOL] [EOL] if not switches : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] add_devices ( switches ) [EOL] [EOL] [EOL] class TelnetSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , object_id , resource , port , friendly_name , command_on , command_off , command_state , value_template ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( object_id ) [EOL] self . _resource = resource [EOL] self . _port = port [EOL] self . _name = friendly_name [EOL] self . _state = False [EOL] self . _command_on = command_on [EOL] self . _command_off = command_off [EOL] self . _command_state = command_state [EOL] self . _value_template = value_template [EOL] [EOL] def _telnet_command ( self , command ) : [EOL] try : [EOL] telnet = telnetlib . Telnet ( self . _resource , self . _port ) [EOL] telnet . write ( command . encode ( [string] ) + [string] ) [EOL] response = telnet . read_until ( [string] , timeout = [number] ) [EOL] return response . decode ( [string] ) . strip ( ) [EOL] except IOError as error : [EOL] _LOGGER . error ( [string] , command , repr ( error ) ) [EOL] return None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return self . _command_state is not None [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return self . _command_state is None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] response = self . _telnet_command ( self . _command_state ) [EOL] if response : [EOL] rendered = self . _value_template . render_with_possible_json_value ( response ) [EOL] self . _state = rendered == [string] [EOL] else : [EOL] _LOGGER . warning ( [string] , self . _command_state ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _telnet_command ( self . _command_on ) [EOL] if self . assumed_state : [EOL] self . _state = True [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _telnet_command ( self . _command_off ) [EOL] if self . assumed_state : [EOL] self . _state = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Any , List , Callable [EOL] import builtins [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from typing import Callable [EOL] [EOL] from homeassistant . components . switch import SwitchDevice , DOMAIN [EOL] from homeassistant . components . isy994 import ( ISY994_NODES , ISY994_PROGRAMS , ISYDevice ) [EOL] from homeassistant . helpers . typing import ConfigType [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for node in hass . data [ ISY994_NODES ] [ DOMAIN ] : [EOL] if not node . dimmable : [EOL] devices . append ( ISYSwitchDevice ( node ) ) [EOL] [EOL] for name , status , actions in hass . data [ ISY994_PROGRAMS ] [ DOMAIN ] : [EOL] devices . append ( ISYSwitchProgram ( name , status , actions ) ) [EOL] [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class ISYSwitchDevice ( ISYDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . value ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _node . off ( ) : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _node . on ( ) : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] class ISYSwitchProgram ( ISYSwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , node , actions ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( node ) [EOL] self . _name = name [EOL] self . _actions = actions [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . value ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _actions . runThen ( ) : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _actions . runElse ( ) : [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . components . tahoma import ( DOMAIN as TAHOMA_DOMAIN , TahomaDevice ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] controller = hass . data [ TAHOMA_DOMAIN ] [ [string] ] [EOL] devices = [ ] [EOL] for switch in hass . data [ TAHOMA_DOMAIN ] [ [string] ] [ [string] ] : [EOL] devices . append ( TahomaSwitch ( switch , controller ) ) [EOL] add_devices ( devices , True ) [EOL] [EOL] [EOL] class TahomaSwitch ( TahomaDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] if self . tahoma_device . type == [string] : [EOL] return [string] [EOL] return None [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . toggle ( ) [EOL] [EOL] def toggle ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . apply_action ( [string] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . tellduslive import TelldusLiveEntity [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] add_devices ( TelldusLiveSwitch ( hass , switch ) for switch in discovery_info ) [EOL] [EOL] [EOL] class TelldusLiveSwitch ( TelldusLiveEntity , ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . device . is_on [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . device . turn_on ( ) [EOL] self . changed ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . device . turn_off ( ) [EOL] self . changed ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Literal , Union , List [EOL] import logging [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] import logging [EOL] import socket [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_PORT [EOL] from homeassistant . components . camera import Camera , PLATFORM_SCHEMA [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_NVR = [string] [EOL] CONF_KEY = [string] [EOL] CONF_PASSWORD = [string] [EOL] [EOL] DEFAULT_PASSWORD = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_NVR ) : cv . string , vol . Required ( CONF_KEY ) : cv . string , vol . Optional ( CONF_PASSWORD , default = DEFAULT_PASSWORD ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] addr = config [ CONF_NVR ] [EOL] key = config [ CONF_KEY ] [EOL] password = config [ CONF_PASSWORD ] [EOL] port = config [ CONF_PORT ] [EOL] [EOL] from uvcclient import nvr [EOL] try : [EOL] [comment] [EOL] nvrconn = nvr . UVCRemote ( addr , port , key ) [EOL] cameras = nvrconn . index ( ) [EOL] [EOL] identifier = [string] if nvrconn . server_version >= ( [number] , [number] , [number] ) else [string] [EOL] [comment] [EOL] [comment] [EOL] cameras = [ camera for camera in cameras if [string] not in nvrconn . get_camera ( camera [ identifier ] ) [ [string] ] ] [EOL] except nvr . NotAuthorized : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] except nvr . NvrError as ex : [EOL] _LOGGER . error ( [string] , str ( ex ) ) [EOL] raise PlatformNotReady [EOL] except requests . exceptions . ConnectionError as ex : [EOL] _LOGGER . error ( [string] , str ( ex ) ) [EOL] raise PlatformNotReady [EOL] [EOL] add_devices ( [ UnifiVideoCamera ( nvrconn , camera [ identifier ] , camera [ [string] ] , password ) for camera in cameras ] ) [EOL] return True [EOL] [EOL] [EOL] class UnifiVideoCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , nvr , uuid , name , password ) : [EOL] [docstring] [EOL] super ( UnifiVideoCamera , self ) . __init__ ( ) [EOL] self . _nvr = nvr [EOL] self . _uuid = uuid [EOL] self . _name = name [EOL] self . _password = password [EOL] self . is_streaming = False [EOL] self . _connect_addr = None [EOL] self . _camera = None [EOL] self . _motion_status = False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_recording ( self ) : [EOL] [docstring] [EOL] caminfo = self . _nvr . get_camera ( self . _uuid ) [EOL] return caminfo [ [string] ] [ [string] ] [EOL] [EOL] @ property def motion_detection_enabled ( self ) : [EOL] [docstring] [EOL] caminfo = self . _nvr . get_camera ( self . _uuid ) [EOL] return caminfo [ [string] ] [ [string] ] [EOL] [EOL] @ property def brand ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def model ( self ) : [EOL] [docstring] [EOL] caminfo = self . _nvr . get_camera ( self . _uuid ) [EOL] return caminfo [ [string] ] [EOL] [EOL] def _login ( self ) : [EOL] [docstring] [EOL] from uvcclient import camera as uvc_camera [EOL] [EOL] caminfo = self . _nvr . get_camera ( self . _uuid ) [EOL] if self . _connect_addr : [EOL] addrs = [ self . _connect_addr ] [EOL] else : [EOL] addrs = [ caminfo [ [string] ] , caminfo [ [string] ] ] [EOL] [EOL] if self . _nvr . server_version >= ( [number] , [number] , [number] ) : [EOL] client_cls = uvc_camera . UVCCameraClientV320 [EOL] else : [EOL] client_cls = uvc_camera . UVCCameraClient [EOL] [EOL] if caminfo [ [string] ] is None : [EOL] caminfo [ [string] ] = [string] [EOL] [EOL] camera = None [EOL] for addr in addrs : [EOL] try : [EOL] camera = client_cls ( addr , caminfo [ [string] ] , self . _password ) [EOL] camera . login ( ) [EOL] _LOGGER . debug ( [string] , dict ( name = self . _name , addr = addr ) ) [EOL] self . _connect_addr = addr [EOL] break [EOL] except socket . error : [EOL] pass [EOL] except uvc_camera . CameraConnectError : [EOL] pass [EOL] except uvc_camera . CameraAuthError : [EOL] pass [EOL] if not self . _connect_addr : [EOL] _LOGGER . error ( [string] ) [EOL] return None [EOL] [EOL] self . _camera = camera [EOL] return True [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] from uvcclient import camera as uvc_camera [EOL] if not self . _camera : [EOL] if not self . _login ( ) : [EOL] return [EOL] [EOL] def _get_image ( retry = True ) : [EOL] try : [EOL] return self . _camera . get_snapshot ( ) [EOL] except uvc_camera . CameraConnectError : [EOL] _LOGGER . error ( [string] ) [EOL] except uvc_camera . CameraAuthError : [EOL] if retry : [EOL] self . _login ( ) [EOL] return _get_image ( retry = False ) [EOL] _LOGGER . error ( [string] ) [EOL] raise [EOL] [EOL] return _get_image ( ) [EOL] [EOL] def set_motion_detection ( self , mode ) : [EOL] [docstring] [EOL] from uvcclient . nvr import NvrError [EOL] if mode is True : [EOL] set_mode = [string] [EOL] else : [EOL] set_mode = [string] [EOL] [EOL] try : [EOL] self . _nvr . set_recordmode ( self . _uuid , set_mode ) [EOL] self . _motion_status = mode [EOL] except NvrError as err : [EOL] _LOGGER . error ( [string] , set_mode ) [EOL] _LOGGER . debug ( err ) [EOL] [EOL] def enable_motion_detection ( self ) : [EOL] [docstring] [EOL] self . set_motion_detection ( True ) [EOL] [EOL] def disable_motion_detection ( self ) : [EOL] [docstring] [EOL] self . set_motion_detection ( False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import ftplib [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . camera import Camera , PLATFORM_SCHEMA [EOL] from homeassistant . components . ffmpeg import DATA_FFMPEG [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PATH , CONF_PASSWORD , CONF_PORT , CONF_USERNAME ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . aiohttp_client import async_aiohttp_proxy_stream [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_BRAND = [string] [EOL] DEFAULT_PATH = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_USERNAME = [string] [EOL] [EOL] CONF_FFMPEG_ARGUMENTS = [string] [EOL] CONF_MODEL = [string] [EOL] [EOL] MODEL_YI = [string] [EOL] MODEL_XIAOFANG = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_MODEL ) : vol . Any ( MODEL_YI , MODEL_XIAOFANG ) , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . string , vol . Optional ( CONF_PATH , default = DEFAULT_PATH ) : cv . string , vol . Optional ( CONF_USERNAME , default = DEFAULT_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_FFMPEG_ARGUMENTS ) : cv . string } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , config [ CONF_MODEL ] ) [EOL] async_add_devices ( [ XiaomiCamera ( hass , config ) ] ) [EOL] [EOL] [EOL] class XiaomiCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _extra_arguments = config . get ( CONF_FFMPEG_ARGUMENTS ) [EOL] self . _last_image = None [EOL] self . _last_url = None [EOL] self . _manager = hass . data [ DATA_FFMPEG ] [EOL] self . _name = config [ CONF_NAME ] [EOL] self . host = config [ CONF_HOST ] [EOL] self . _model = config [ CONF_MODEL ] [EOL] self . port = config [ CONF_PORT ] [EOL] self . path = config [ CONF_PATH ] [EOL] self . user = config [ CONF_USERNAME ] [EOL] self . passwd = config [ CONF_PASSWORD ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def brand ( self ) : [EOL] [docstring] [EOL] return DEFAULT_BRAND [EOL] [EOL] @ property def model ( self ) : [EOL] [docstring] [EOL] return self . _model [EOL] [EOL] def get_latest_video_url ( self ) : [EOL] [docstring] [EOL] from ftplib import FTP , error_perm [EOL] [EOL] ftp = FTP ( self . host ) [EOL] try : [EOL] ftp . login ( self . user , self . passwd ) [EOL] except error_perm as exc : [EOL] _LOGGER . error ( [string] , exc ) [EOL] return False [EOL] [EOL] try : [EOL] ftp . cwd ( self . path ) [EOL] except error_perm as exc : [EOL] _LOGGER . error ( [string] , self . path , exc ) [EOL] return False [EOL] [EOL] dirs = [ d for d in ftp . nlst ( ) if [string] not in d ] [EOL] if not dirs : [EOL] _LOGGER . warning ( [string] ) [EOL] return False [EOL] [EOL] first_dir = dirs [ - [number] ] [EOL] try : [EOL] ftp . cwd ( first_dir ) [EOL] except error_perm as exc : [EOL] _LOGGER . error ( [string] , first_dir , exc ) [EOL] return False [EOL] [EOL] if self . _model == MODEL_XIAOFANG : [EOL] dirs = [ d for d in ftp . nlst ( ) if [string] not in d ] [EOL] if not dirs : [EOL] _LOGGER . warning ( [string] ) [EOL] return False [EOL] [EOL] latest_dir = dirs [ - [number] ] [EOL] ftp . cwd ( latest_dir ) [EOL] [EOL] videos = [ v for v in ftp . nlst ( ) if [string] not in v ] [EOL] if not videos : [EOL] _LOGGER . info ( [string] , latest_dir ) [EOL] return False [EOL] [EOL] if self . _model == MODEL_XIAOFANG : [EOL] video = videos [ - [number] ] [EOL] else : [EOL] video = videos [ - [number] ] [EOL] [EOL] return [string] . format ( self . user , self . passwd , self . host , self . port , ftp . pwd ( ) , video ) [EOL] [EOL] async def async_camera_image ( self ) : [EOL] [docstring] [EOL] from haffmpeg import ImageFrame , IMAGE_JPEG [EOL] [EOL] url = await self . hass . async_add_job ( self . get_latest_video_url ) [EOL] if url != self . _last_url : [EOL] ffmpeg = ImageFrame ( self . _manager . binary , loop = self . hass . loop ) [EOL] self . _last_image = await asyncio . shield ( ffmpeg . get_image ( url , output_format = IMAGE_JPEG , extra_cmd = self . _extra_arguments ) , loop = self . hass . loop ) [EOL] self . _last_url = url [EOL] [EOL] return self . _last_image [EOL] [EOL] async def handle_async_mjpeg_stream ( self , request ) : [EOL] [docstring] [EOL] from haffmpeg import CameraMjpeg [EOL] [EOL] stream = CameraMjpeg ( self . _manager . binary , loop = self . hass . loop ) [EOL] await stream . open_camera ( self . _last_url , extra_cmd = self . _extra_arguments ) [EOL] [EOL] await async_aiohttp_proxy_stream ( self . hass , request , stream , [string] ) [EOL] await stream . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $ftplib.FTP$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] import requests [EOL] [EOL] from homeassistant . components . august import DATA_AUGUST , DEFAULT_TIMEOUT [EOL] from homeassistant . components . camera import Camera [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] data = hass . data [ DATA_AUGUST ] [EOL] devices = [ ] [EOL] [EOL] for doorbell in data . doorbells : [EOL] devices . append ( AugustCamera ( data , doorbell , DEFAULT_TIMEOUT ) ) [EOL] [EOL] add_devices ( devices , True ) [EOL] [EOL] [EOL] class AugustCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , doorbell , timeout ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _data = data [EOL] self . _doorbell = doorbell [EOL] self . _timeout = timeout [EOL] self . _image_url = None [EOL] self . _image_content = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _doorbell . device_name [EOL] [EOL] @ property def is_recording ( self ) : [EOL] [docstring] [EOL] return self . _doorbell . has_subscription [EOL] [EOL] @ property def motion_detection_enabled ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def brand ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def model ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] latest = self . _data . get_doorbell_detail ( self . _doorbell . device_id ) [EOL] [EOL] if self . _image_url is not latest . image_url : [EOL] self . _image_url = latest . image_url [EOL] self . _image_content = requests . get ( self . _image_url , timeout = self . _timeout ) . content [EOL] [EOL] return self . _image_content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Generator [EOL] import requests [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from contextlib import closing [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] import requests [EOL] from requests . auth import HTTPBasicAuth , HTTPDigestAuth [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_USERNAME , CONF_PASSWORD , CONF_AUTHENTICATION , HTTP_BASIC_AUTHENTICATION , HTTP_DIGEST_AUTHENTICATION ) [EOL] from homeassistant . components . camera import ( PLATFORM_SCHEMA , Camera ) [EOL] from homeassistant . helpers . aiohttp_client import ( async_get_clientsession , async_aiohttp_proxy_web ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_MJPEG_URL = [string] [EOL] CONF_STILL_IMAGE_URL = [string] [EOL] CONTENT_TYPE_HEADER = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MJPEG_URL ) : cv . url , vol . Optional ( CONF_STILL_IMAGE_URL ) : cv . url , vol . Optional ( CONF_AUTHENTICATION , default = HTTP_BASIC_AUTHENTICATION ) : vol . In ( [ HTTP_BASIC_AUTHENTICATION , HTTP_DIGEST_AUTHENTICATION ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_USERNAME ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info : [EOL] config = PLATFORM_SCHEMA ( discovery_info ) [EOL] async_add_devices ( [ MjpegCamera ( hass , config ) ] ) [EOL] [EOL] [EOL] def extract_image_from_mjpeg ( stream ) : [EOL] [docstring] [EOL] data = [string] [EOL] for chunk in stream : [EOL] data += chunk [EOL] jpg_start = data . find ( [string] ) [EOL] jpg_end = data . find ( [string] ) [EOL] if jpg_start != - [number] and jpg_end != - [number] : [EOL] jpg = data [ jpg_start : jpg_end + [number] ] [EOL] return jpg [EOL] [EOL] [EOL] class MjpegCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device_info ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _name = device_info . get ( CONF_NAME ) [EOL] self . _authentication = device_info . get ( CONF_AUTHENTICATION ) [EOL] self . _username = device_info . get ( CONF_USERNAME ) [EOL] self . _password = device_info . get ( CONF_PASSWORD ) [EOL] self . _mjpeg_url = device_info [ CONF_MJPEG_URL ] [EOL] self . _still_image_url = device_info . get ( CONF_STILL_IMAGE_URL ) [EOL] [EOL] self . _auth = None [EOL] if self . _username and self . _password : [EOL] if self . _authentication == HTTP_BASIC_AUTHENTICATION : [EOL] self . _auth = aiohttp . BasicAuth ( self . _username , password = self . _password ) [EOL] [EOL] @ asyncio . coroutine def async_camera_image ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _authentication == HTTP_DIGEST_AUTHENTICATION or self . _still_image_url is None : [EOL] image = yield from self . hass . async_add_job ( self . camera_image ) [EOL] return image [EOL] [EOL] websession = async_get_clientsession ( self . hass ) [EOL] try : [EOL] with async_timeout . timeout ( [number] , loop = self . hass . loop ) : [EOL] response = yield from websession . get ( self . _still_image_url , auth = self . _auth ) [EOL] [EOL] image = yield from response . read ( ) [EOL] return image [EOL] [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] except aiohttp . ClientError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] if self . _username and self . _password : [EOL] if self . _authentication == HTTP_DIGEST_AUTHENTICATION : [EOL] auth = HTTPDigestAuth ( self . _username , self . _password ) [EOL] else : [EOL] auth = HTTPBasicAuth ( self . _username , self . _password ) [EOL] req = requests . get ( self . _mjpeg_url , auth = auth , stream = True , timeout = [number] ) [EOL] else : [EOL] req = requests . get ( self . _mjpeg_url , stream = True , timeout = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with closing ( req ) as response : [EOL] return extract_image_from_mjpeg ( response . iter_content ( [number] ) ) [EOL] [EOL] async def handle_async_mjpeg_stream ( self , request ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _authentication == HTTP_DIGEST_AUTHENTICATION : [EOL] await super ( ) . handle_async_mjpeg_stream ( request ) [EOL] return [EOL] [EOL] [comment] [EOL] websession = async_get_clientsession ( self . hass ) [EOL] stream_coro = websession . get ( self . _mjpeg_url , auth = self . _auth ) [EOL] [EOL] return await async_aiohttp_proxy_web ( self . hass , request , stream_coro ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 $requests.auth.HTTPBasicAuth$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] [EOL] from homeassistant . components . camera import Camera , SUPPORT_ON_OFF [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] async_add_devices ( [ DemoCamera ( [string] ) ] ) [EOL] [EOL] [EOL] class DemoCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _name = name [EOL] self . _motion_status = False [EOL] self . is_streaming = True [EOL] self . _images_index = [number] [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] self . _images_index = ( self . _images_index + [number] ) % [number] [EOL] [EOL] image_path = os . path . join ( os . path . dirname ( __file__ ) , [string] . format ( self . _images_index ) ) [EOL] _LOGGER . debug ( [string] , image_path ) [EOL] with open ( image_path , [string] ) as file : [EOL] return file . read ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_ON_OFF [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . is_streaming [EOL] [EOL] @ property def motion_detection_enabled ( self ) : [EOL] [docstring] [EOL] return self . _motion_status [EOL] [EOL] def enable_motion_detection ( self ) : [EOL] [docstring] [EOL] self . _motion_status = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def disable_motion_detection ( self ) : [EOL] [docstring] [EOL] self . _motion_status = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . is_streaming = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . is_streaming = True [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , List , Dict [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . nest import ( DATA_NEST , DATA_NEST_CONFIG , CONF_SENSORS , NestSensorDevice ) [EOL] from homeassistant . const import ( TEMP_CELSIUS , TEMP_FAHRENHEIT , CONF_MONITORED_CONDITIONS , DEVICE_CLASS_TEMPERATURE , DEVICE_CLASS_HUMIDITY ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SENSOR_TYPES = [ [string] , [string] , [string] ] [EOL] [EOL] TEMP_SENSOR_TYPES = [ [string] , [string] ] [EOL] [EOL] PROTECT_SENSOR_TYPES = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] STRUCTURE_SENSOR_TYPES = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] STRUCTURE_CAMERA_SENSOR_TYPES = [ [string] ] [EOL] [EOL] _VALID_SENSOR_TYPES = SENSOR_TYPES + TEMP_SENSOR_TYPES + PROTECT_SENSOR_TYPES + STRUCTURE_SENSOR_TYPES + STRUCTURE_CAMERA_SENSOR_TYPES [EOL] [EOL] SENSOR_UNITS = { [string] : [string] } [EOL] [EOL] SENSOR_DEVICE_CLASSES = { [string] : DEVICE_CLASS_HUMIDITY } [EOL] [EOL] VARIABLE_NAME_MAPPING = { [string] : [string] , [string] : [string] } [EOL] [EOL] SENSOR_TYPES_DEPRECATED = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] DEPRECATED_WEATHER_VARS = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] _SENSOR_TYPES_DEPRECATED = SENSOR_TYPES_DEPRECATED + DEPRECATED_WEATHER_VARS [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry , async_add_devices ) : [EOL] [docstring] [EOL] nest = hass . data [ DATA_NEST ] [EOL] [EOL] discovery_info = hass . data . get ( DATA_NEST_CONFIG , { } ) . get ( CONF_SENSORS , { } ) [EOL] [EOL] [comment] [EOL] if discovery_info == { } : [EOL] conditions = _VALID_SENSOR_TYPES [EOL] else : [EOL] conditions = discovery_info . get ( CONF_MONITORED_CONDITIONS , { } ) [EOL] [EOL] for variable in conditions : [EOL] if variable in _SENSOR_TYPES_DEPRECATED : [EOL] if variable in DEPRECATED_WEATHER_VARS : [EOL] wstr = ( [string] [string] [string] % variable ) [EOL] else : [EOL] wstr = ( variable + [string] [string] [string] [string] ) [EOL] _LOGGER . error ( wstr ) [EOL] [EOL] def get_sensors ( ) : [EOL] [docstring] [EOL] all_sensors = [ ] [EOL] for structure in nest . structures ( ) : [EOL] all_sensors += [ NestBasicSensor ( structure , None , variable ) for variable in conditions if variable in STRUCTURE_SENSOR_TYPES ] [EOL] [EOL] for structure , device in nest . thermostats ( ) : [EOL] all_sensors += [ NestBasicSensor ( structure , device , variable ) for variable in conditions if variable in SENSOR_TYPES ] [EOL] all_sensors += [ NestTempSensor ( structure , device , variable ) for variable in conditions if variable in TEMP_SENSOR_TYPES ] [EOL] [EOL] for structure , device in nest . smoke_co_alarms ( ) : [EOL] all_sensors += [ NestBasicSensor ( structure , device , variable ) for variable in conditions if variable in PROTECT_SENSOR_TYPES ] [EOL] [EOL] structures_has_camera = { } [EOL] for structure , device in nest . cameras ( ) : [EOL] structures_has_camera [ structure ] = True [EOL] for structure in structures_has_camera : [EOL] all_sensors += [ NestBasicSensor ( structure , None , variable ) for variable in conditions if variable in STRUCTURE_CAMERA_SENSOR_TYPES ] [EOL] [EOL] return all_sensors [EOL] [EOL] async_add_devices ( await hass . async_add_job ( get_sensors ) , True ) [EOL] [EOL] [EOL] class NestBasicSensor ( NestSensorDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return SENSOR_DEVICE_CLASSES . get ( self . variable ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _unit = SENSOR_UNITS . get ( self . variable ) [EOL] [EOL] if self . variable in VARIABLE_NAME_MAPPING : [EOL] self . _state = getattr ( self . device , VARIABLE_NAME_MAPPING [ self . variable ] ) [EOL] elif self . variable in PROTECT_SENSOR_TYPES \ [EOL] and self . variable != [string] : [EOL] [comment] [EOL] state = getattr ( self . device , self . variable ) [EOL] self . _state = state . capitalize ( ) if state is not None else None [EOL] else : [EOL] self . _state = getattr ( self . device , self . variable ) [EOL] [EOL] [EOL] class NestTempSensor ( NestSensorDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_TEMPERATURE [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . device . temperature_scale == [string] : [EOL] self . _unit = TEMP_CELSIUS [EOL] else : [EOL] self . _unit = TEMP_FAHRENHEIT [EOL] [EOL] temp = getattr ( self . device , self . variable ) [EOL] if temp is None : [EOL] self . _state = None [EOL] [EOL] if isinstance ( temp , tuple ) : [EOL] low , high = temp [EOL] self . _state = [string] % ( int ( low ) , int ( high ) ) [EOL] else : [EOL] self . _state = round ( temp , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any , List , Dict [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] [EOL] from datetime import timedelta [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . tradfri import KEY_GATEWAY , KEY_API [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] gateway_id = discovery_info [ [string] ] [EOL] api = hass . data [ KEY_API ] [ gateway_id ] [EOL] gateway = hass . data [ KEY_GATEWAY ] [ gateway_id ] [EOL] [EOL] devices_command = gateway . get_devices ( ) [EOL] devices_commands = await api ( devices_command ) [EOL] all_devices = await api ( devices_commands ) [EOL] devices = [ dev for dev in all_devices if not dev . has_light_control ] [EOL] async_add_devices ( TradfriDevice ( device , api ) for device in devices ) [EOL] [EOL] [EOL] class TradfriDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , api ) : [EOL] [docstring] [EOL] self . _api = api [EOL] self . _device = None [EOL] self . _name = None [EOL] [EOL] self . _refresh ( device ) [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _async_start_observe ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] info = self . _device . device_info [EOL] attrs = { [string] : info . manufacturer , [string] : info . model_number , [string] : info . serial , [string] : info . firmware_version , [string] : info . power_source_str , [string] : info . battery_level } [EOL] return attrs [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . device_info . battery_level [EOL] [EOL] @ callback def _async_start_observe ( self , exc = None ) : [EOL] [docstring] [EOL] [comment] [EOL] from pytradfri . error import PytradfriError [EOL] if exc : [EOL] _LOGGER . warning ( [string] , self . _name , exc_info = exc ) [EOL] [EOL] try : [EOL] cmd = self . _device . observe ( callback = self . _observe_update , err_callback = self . _async_start_observe , duration = [number] ) [EOL] self . hass . async_add_job ( self . _api ( cmd ) ) [EOL] except PytradfriError as err : [EOL] _LOGGER . warning ( [string] , exc_info = err ) [EOL] self . _async_start_observe ( ) [EOL] [EOL] def _refresh ( self , device ) : [EOL] [docstring] [EOL] self . _device = device [EOL] self . _name = device . name [EOL] [EOL] def _observe_update ( self , tradfri_device ) : [EOL] [docstring] [EOL] self . _refresh ( tradfri_device ) [EOL] [EOL] self . hass . async_add_job ( self . async_update_ha_state ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import datetime [EOL] [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . components . toon as toon_main [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] STATE_ATTR_DEVICE_TYPE = [string] [EOL] STATE_ATTR_LAST_CONNECTED_CHANGE = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] _toon_main = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] sensor_items = [ ] [EOL] sensor_items . extend ( [ ToonSensor ( hass , [string] , [string] , [string] ) , ToonSensor ( hass , [string] , [string] , [string] ) , ] ) [EOL] [EOL] if _toon_main . gas : [EOL] sensor_items . extend ( [ ToonSensor ( hass , [string] , [string] , [string] ) , ToonSensor ( hass , [string] , [string] , [string] ) , ] ) [EOL] [EOL] for plug in _toon_main . toon . smartplugs : [EOL] sensor_items . extend ( [ FibaroSensor ( hass , [string] . format ( plug . name ) , plug . name , [string] , [string] ) , FibaroSensor ( hass , [string] . format ( plug . name ) , plug . name , [string] , [string] ) , ] ) [EOL] [EOL] if _toon_main . toon . solar . produced or _toon_main . solar : [EOL] sensor_items . extend ( [ SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , ] ) [EOL] [EOL] for smokedetector in _toon_main . toon . smokedetectors : [EOL] sensor_items . append ( FibaroSmokeDetector ( hass , [string] . format ( smokedetector . name ) , smokedetector . device_uuid , [string] , [string] ) ) [EOL] [EOL] add_devices ( sensor_items ) [EOL] [EOL] [EOL] class ToonSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , icon , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _icon = [string] . format ( icon ) [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . thermos = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . thermos . get_data ( self . name . lower ( ) ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . thermos . update ( ) [EOL] [EOL] [EOL] class FibaroSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , plug_name , icon , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _plug_name = plug_name [EOL] self . _state = None [EOL] self . _icon = [string] . format ( icon ) [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . toon = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] value = [string] . join ( self . name . lower ( ) . split ( [string] ) [ [number] : ] ) [EOL] return self . toon . get_data ( value , self . _plug_name ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . toon . update ( ) [EOL] [EOL] [EOL] class SolarSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _icon = [string] [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . toon = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . toon . get_data ( self . name . lower ( ) ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . toon . update ( ) [EOL] [EOL] [EOL] class FibaroSmokeDetector ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , uid , icon , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _uid = uid [EOL] self . _state = None [EOL] self . _icon = [string] . format ( icon ) [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . toon = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] value = datetime . datetime . fromtimestamp ( int ( self . toon . get_data ( [string] , self . name ) ) ) . strftime ( [string] ) [EOL] [EOL] return { STATE_ATTR_DEVICE_TYPE : self . toon . get_data ( [string] , self . name ) , STATE_ATTR_LAST_CONNECTED_CHANGE : value , } [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] value = self . name . lower ( ) . split ( [string] , [number] ) [ [number] ] [EOL] return self . toon . get_data ( value , self . name ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . toon . update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import DefaultDict , Any , List , Dict [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] from collections import defaultdict [EOL] import logging [EOL] [EOL] from homeassistant . components . usps import DATA_USPS [EOL] from homeassistant . const import ATTR_ATTRIBUTION , ATTR_DATE [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import slugify [EOL] from homeassistant . util . dt import now [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] STATUS_DELIVERED = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] usps = hass . data [ DATA_USPS ] [EOL] add_devices ( [ USPSPackageSensor ( usps ) , USPSMailSensor ( usps ) ] , True ) [EOL] [EOL] [EOL] class USPSPackageSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , usps ) : [EOL] [docstring] [EOL] self . _usps = usps [EOL] self . _name = self . _usps . name [EOL] self . _attributes = None [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _usps . update ( ) [EOL] status_counts = defaultdict ( int ) [EOL] for package in self . _usps . packages : [EOL] status = slugify ( package [ [string] ] ) [EOL] if status == STATUS_DELIVERED and package [ [string] ] < now ( ) . date ( ) : [EOL] continue [EOL] status_counts [ status ] += [number] [EOL] self . _attributes = { ATTR_ATTRIBUTION : self . _usps . attribution } [EOL] self . _attributes . update ( status_counts ) [EOL] self . _state = sum ( status_counts . values ( ) ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class USPSMailSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , usps ) : [EOL] [docstring] [EOL] self . _usps = usps [EOL] self . _name = self . _usps . name [EOL] self . _attributes = None [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _usps . update ( ) [EOL] if self . _usps . mail is not None : [EOL] self . _state = len ( self . _usps . mail ) [EOL] else : [EOL] self . _state = [number] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { } [EOL] attr [ ATTR_ATTRIBUTION ] = self . _usps . attribution [EOL] try : [EOL] attr [ ATTR_DATE ] = str ( self . _usps . mail [ [number] ] [ [string] ] ) [EOL] except IndexError : [EOL] pass [EOL] return attr [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import STATE_UNKNOWN [EOL] from homeassistant . const import CONF_MONITORED_CONDITIONS [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . components import zoneminder [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_INCLUDE_ARCHIVED = [string] [EOL] [EOL] DEFAULT_INCLUDE_ARCHIVED = False [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_INCLUDE_ARCHIVED , default = DEFAULT_INCLUDE_ARCHIVED ) : cv . boolean , vol . Optional ( CONF_MONITORED_CONDITIONS , default = [ [string] ] ) : vol . All ( cv . ensure_list , [ vol . In ( list ( SENSOR_TYPES ) ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] include_archived = config . get ( CONF_INCLUDE_ARCHIVED ) [EOL] [EOL] sensors = [ ] [EOL] [EOL] monitors = zoneminder . get_state ( [string] ) [EOL] for i in monitors [ [string] ] : [EOL] sensors . append ( ZMSensorMonitors ( int ( i [ [string] ] [ [string] ] ) , i [ [string] ] [ [string] ] ) ) [EOL] [EOL] for sensor in config [ CONF_MONITORED_CONDITIONS ] : [EOL] sensors . append ( ZMSensorEvents ( int ( i [ [string] ] [ [string] ] ) , i [ [string] ] [ [string] ] , include_archived , sensor ) ) [EOL] [EOL] add_devices ( sensors ) [EOL] [EOL] [EOL] class ZMSensorMonitors ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , monitor_id , monitor_name ) : [EOL] [docstring] [EOL] self . _monitor_id = monitor_id [EOL] self . _monitor_name = monitor_name [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _monitor_name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] monitor = zoneminder . get_state ( [string] . format ( self . _monitor_id ) ) [EOL] if monitor [ [string] ] [ [string] ] [ [string] ] is None : [EOL] self . _state = STATE_UNKNOWN [EOL] else : [EOL] self . _state = monitor [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] class ZMSensorEvents ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , monitor_id , monitor_name , include_archived , sensor_type ) : [EOL] [docstring] [EOL] self . _monitor_id = monitor_id [EOL] self . _monitor_name = monitor_name [EOL] self . _include_archived = include_archived [EOL] self . _type = sensor_type [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _monitor_name , self . _name ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] date_filter = [string] . format ( self . _type ) [EOL] if self . _type == [string] : [EOL] [comment] [EOL] [comment] [EOL] date_filter = [string] [EOL] [EOL] archived_filter = [string] [EOL] if self . _include_archived : [EOL] archived_filter = [string] [EOL] [EOL] event = zoneminder . get_state ( [string] . format ( date_filter , archived_filter ) ) [EOL] [EOL] try : [EOL] self . _state = event [ [string] ] [ str ( self . _monitor_id ) ] [EOL] except ( TypeError , KeyError ) : [EOL] self . _state = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Optional , Dict [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] import json [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_NAME , CONF_MONITORED_CONDITIONS ) [EOL] from homeassistant . util import Throttle [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . components . sensor . rest import RestData [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTRIBUTION = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] CONF_REGION_NAME = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] MONITORED_CONDITIONS = { [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_REGION_NAME ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( MONITORED_CONDITIONS ) ) : vol . All ( cv . ensure_list , [ vol . In ( MONITORED_CONDITIONS ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] region_name = config . get ( CONF_REGION_NAME ) [EOL] [EOL] api = DwdWeatherWarningsAPI ( region_name ) [EOL] [EOL] sensors = [ DwdWeatherWarningsSensor ( api , name , condition ) for condition in config [ CONF_MONITORED_CONDITIONS ] ] [EOL] [EOL] add_devices ( sensors , True ) [EOL] [EOL] [EOL] class DwdWeatherWarningsSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api , name , variable ) : [EOL] [docstring] [EOL] self . _api = api [EOL] self . _name = name [EOL] self . _var_id = variable [EOL] [EOL] variable_info = MONITORED_CONDITIONS [ variable ] [EOL] self . _var_name = variable_info [ [number] ] [EOL] self . _var_units = variable_info [ [number] ] [EOL] self . _var_icon = variable_info [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name , self . _var_name ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _var_icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _var_units [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] try : [EOL] return round ( self . _api . data [ self . _var_id ] , [number] ) [EOL] except TypeError : [EOL] return self . _api . data [ self . _var_id ] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] data = { ATTR_ATTRIBUTION : ATTRIBUTION , [string] : self . _api . region_name } [EOL] [EOL] if self . _api . region_id is not None : [EOL] data [ [string] ] = self . _api . region_id [EOL] [EOL] if self . _api . region_state is not None : [EOL] data [ [string] ] = self . _api . region_state [EOL] [EOL] if self . _api . data [ [string] ] is not None : [EOL] data [ [string] ] = dt_util . as_local ( dt_util . utc_from_timestamp ( self . _api . data [ [string] ] / [number] ) ) [EOL] [EOL] if self . _var_id == [string] : [EOL] prefix = [string] [EOL] elif self . _var_id == [string] : [EOL] prefix = [string] [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] data [ [string] ] = self . _api . data [ prefix + [string] ] [EOL] i = [number] [EOL] for event in self . _api . data [ prefix + [string] ] : [EOL] i = i + [number] [EOL] [EOL] data [ [string] . format ( i ) ] = event [ [string] ] [EOL] data [ [string] . format ( i ) ] = event [ [string] ] [EOL] data [ [string] . format ( i ) ] = event [ [string] ] [EOL] if event [ [string] ] : [EOL] data [ [string] . format ( i ) ] = event [ [string] ] [EOL] if event [ [string] ] : [EOL] data [ [string] . format ( i ) ] = event [ [string] ] [EOL] if event [ [string] ] : [EOL] data [ [string] . format ( i ) ] = event [ [string] ] [EOL] [EOL] if event [ [string] ] is not None : [EOL] data [ [string] . format ( i ) ] = dt_util . as_local ( dt_util . utc_from_timestamp ( event [ [string] ] / [number] ) ) [EOL] [EOL] if event [ [string] ] is not None : [EOL] data [ [string] . format ( i ) ] = dt_util . as_local ( dt_util . utc_from_timestamp ( event [ [string] ] / [number] ) ) [EOL] [EOL] return data [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _api . available [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _api . update ( ) [EOL] [EOL] [EOL] class DwdWeatherWarningsAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , region_name ) : [EOL] [docstring] [EOL] resource = [string] . format ( [string] , [string] , [string] , [string] ) [EOL] [EOL] self . _rest = RestData ( [string] , resource , None , None , None , True ) [EOL] self . region_name = region_name [EOL] self . region_id = None [EOL] self . region_state = None [EOL] self . data = None [EOL] self . available = True [EOL] self . update ( ) [EOL] [EOL] @ Throttle ( SCAN_INTERVAL ) def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _rest . update ( ) [EOL] [EOL] json_string = self . _rest . data [ [number] : len ( self . _rest . data ) - [number] ] [EOL] json_obj = json . loads ( json_string ) [EOL] [EOL] data = { [string] : json_obj [ [string] ] } [EOL] [EOL] for mykey , myvalue in { [string] : [string] , [string] : [string] } . items ( ) : [EOL] [EOL] _LOGGER . debug ( [string] , len ( json_obj [ myvalue ] ) , mykey ) [EOL] [EOL] data [ [string] . format ( mykey ) ] = [number] [EOL] my_warnings = [ ] [EOL] [EOL] if self . region_id is not None : [EOL] [comment] [EOL] if self . region_id in json_obj [ myvalue ] : [EOL] my_warnings = json_obj [ myvalue ] [ self . region_id ] [EOL] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] for key in json_obj [ myvalue ] : [EOL] my_region = json_obj [ myvalue ] [ key ] [ [number] ] [ [string] ] [EOL] if my_region != self . region_name : [EOL] continue [EOL] my_warnings = json_obj [ myvalue ] [ key ] [EOL] my_state = json_obj [ myvalue ] [ key ] [ [number] ] [ [string] ] [EOL] self . region_id = key [EOL] self . region_state = my_state [EOL] break [EOL] [EOL] [comment] [EOL] maxlevel = data [ [string] . format ( mykey ) ] [EOL] for event in my_warnings : [EOL] if event [ [string] ] >= maxlevel : [EOL] data [ [string] . format ( mykey ) ] = event [ [string] ] [EOL] [EOL] data [ [string] . format ( mykey ) ] = len ( my_warnings ) [EOL] data [ [string] . format ( mykey ) ] = my_warnings [EOL] [EOL] _LOGGER . debug ( [string] , len ( my_warnings ) , mykey ) [EOL] [EOL] self . data = data [EOL] self . available = True [EOL] except TypeError : [EOL] _LOGGER . error ( [string] ) [EOL] self . available = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 $typing.dict$ 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import List [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] from homeassistant . components . homematicip_cloud import ( HomematicipGenericDevice , DOMAIN as HMIPC_DOMAIN , HMIPC_HAPID ) [EOL] from homeassistant . const import ( TEMP_CELSIUS , DEVICE_CLASS_TEMPERATURE , DEVICE_CLASS_HUMIDITY , DEVICE_CLASS_ILLUMINANCE ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] ATTR_VALVE_STATE = [string] [EOL] ATTR_VALVE_POSITION = [string] [EOL] ATTR_TEMPERATURE = [string] [EOL] ATTR_TEMPERATURE_OFFSET = [string] [EOL] ATTR_HUMIDITY = [string] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_devices ) : [EOL] [docstring] [EOL] from homematicip . device import ( HeatingThermostat , TemperatureHumiditySensorWithoutDisplay , TemperatureHumiditySensorDisplay , MotionDetectorIndoor ) [EOL] [EOL] home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home [EOL] devices = [ HomematicipAccesspointStatus ( home ) ] [EOL] for device in home . devices : [EOL] if isinstance ( device , HeatingThermostat ) : [EOL] devices . append ( HomematicipHeatingThermostat ( home , device ) ) [EOL] if isinstance ( device , ( TemperatureHumiditySensorDisplay , TemperatureHumiditySensorWithoutDisplay ) ) : [EOL] devices . append ( HomematicipTemperatureSensor ( home , device ) ) [EOL] devices . append ( HomematicipHumiditySensor ( home , device ) ) [EOL] if isinstance ( device , MotionDetectorIndoor ) : [EOL] devices . append ( HomematicipIlluminanceSensor ( home , device ) ) [EOL] [EOL] if devices : [EOL] async_add_devices ( devices ) [EOL] [EOL] [EOL] class HomematicipAccesspointStatus ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , home ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _home . dutyCycle [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _home . connected [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipHeatingThermostat ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] from homematicip . base . enums import ValveState [EOL] [EOL] if super ( ) . icon : [EOL] return super ( ) . icon [EOL] if self . _device . valveState != ValveState . ADAPTION_DONE : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] from homematicip . base . enums import ValveState [EOL] [EOL] if self . _device . valveState != ValveState . ADAPTION_DONE : [EOL] return self . _device . valveState [EOL] return round ( self . _device . valvePosition * [number] ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipHumiditySensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_HUMIDITY [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . humidity [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipTemperatureSensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_TEMPERATURE [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . actualTemperature [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] [EOL] class HomematicipIlluminanceSensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_ILLUMINANCE [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . illumination [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import os [EOL] import asyncio [EOL] import logging [EOL] [EOL] from datetime import timedelta [EOL] [EOL] import re [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_SCAN_INTERVAL , CONF_FILE_PATH ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_JAILS = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_LOG = [string] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] STATE_CURRENT_BANS = [string] [EOL] STATE_ALL_BANS = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_JAILS ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) ) , vol . Optional ( CONF_FILE_PATH ) : cv . isfile , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] jails = config . get ( CONF_JAILS ) [EOL] scan_interval = config . get ( CONF_SCAN_INTERVAL ) [EOL] log_file = config . get ( CONF_FILE_PATH , DEFAULT_LOG ) [EOL] [EOL] device_list = [ ] [EOL] log_parser = BanLogParser ( scan_interval , log_file ) [EOL] for jail in jails : [EOL] device_list . append ( BanSensor ( name , jail , log_parser ) ) [EOL] [EOL] async_add_devices ( device_list , True ) [EOL] [EOL] [EOL] class BanSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , jail , log_parser ) : [EOL] [docstring] [EOL] self . _name = [string] . format ( name , jail ) [EOL] self . jail = jail [EOL] self . ban_dict = { STATE_CURRENT_BANS : [ ] , STATE_ALL_BANS : [ ] } [EOL] self . last_ban = None [EOL] self . log_parser = log_parser [EOL] self . log_parser . ip_regex [ self . jail ] = re . compile ( [string] . format ( re . escape ( self . jail ) ) ) [EOL] _LOGGER . debug ( [string] , self . jail ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] return self . ban_dict [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . last_ban [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . log_parser . timer ( ) : [EOL] self . log_parser . read_log ( self . jail ) [EOL] [EOL] if self . log_parser . data : [EOL] for entry in self . log_parser . data : [EOL] _LOGGER . debug ( entry ) [EOL] current_ip = entry [ [number] ] [EOL] if entry [ [number] ] == [string] : [EOL] if current_ip not in self . ban_dict [ STATE_CURRENT_BANS ] : [EOL] self . ban_dict [ STATE_CURRENT_BANS ] . append ( current_ip ) [EOL] if current_ip not in self . ban_dict [ STATE_ALL_BANS ] : [EOL] self . ban_dict [ STATE_ALL_BANS ] . append ( current_ip ) [EOL] if len ( self . ban_dict [ STATE_ALL_BANS ] ) > [number] : [EOL] self . ban_dict [ STATE_ALL_BANS ] . pop ( [number] ) [EOL] [EOL] elif entry [ [number] ] == [string] : [EOL] if current_ip in self . ban_dict [ STATE_CURRENT_BANS ] : [EOL] self . ban_dict [ STATE_CURRENT_BANS ] . remove ( current_ip ) [EOL] [EOL] if self . ban_dict [ STATE_CURRENT_BANS ] : [EOL] self . last_ban = self . ban_dict [ STATE_CURRENT_BANS ] [ - [number] ] [EOL] else : [EOL] self . last_ban = [string] [EOL] [EOL] [EOL] class BanLogParser : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interval , log_file ) : [EOL] [docstring] [EOL] self . interval = interval [EOL] self . log_file = log_file [EOL] self . data = list ( ) [EOL] self . last_update = dt_util . now ( ) [EOL] self . ip_regex = dict ( ) [EOL] [EOL] def timer ( self ) : [EOL] [docstring] [EOL] boundary = dt_util . now ( ) - self . interval [EOL] if boundary > self . last_update : [EOL] self . last_update = dt_util . now ( ) [EOL] return True [EOL] return False [EOL] [EOL] def read_log ( self , jail ) : [EOL] [docstring] [EOL] self . data = list ( ) [EOL] try : [EOL] with open ( self . log_file , [string] , encoding = [string] ) as file_data : [EOL] self . data = self . ip_regex [ jail ] . findall ( file_data . read ( ) ) [EOL] [EOL] except ( IndexError , FileNotFoundError , IsADirectoryError , UnboundLocalError ) : [EOL] _LOGGER . warning ( [string] , os . path . basename ( self . log_file ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , List , Dict [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import voluptuous as vol [EOL] from homeassistant . const import ( STATE_IDLE , EVENT_HOMEASSISTANT_STOP , CONF_NAME , CONF_DEVICE ) [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] DEFAULT_NAME = [string] [EOL] ICON = [string] [EOL] DEFAULT_DEVICE = [string] [EOL] [EOL] STATE_RING = [string] [EOL] STATE_CALLERID = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_DEVICE , default = DEFAULT_DEVICE ) : cv . string } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from basicmodem . basicmodem import BasicModem as bm [EOL] name = config . get ( CONF_NAME ) [EOL] port = config . get ( CONF_DEVICE ) [EOL] [EOL] modem = bm ( port ) [EOL] if modem . state == modem . STATE_FAILED : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] add_devices ( [ ModemCalleridSensor ( hass , name , port , modem ) ] ) [EOL] [EOL] [EOL] class ModemCalleridSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , port , modem ) : [EOL] [docstring] [EOL] self . _attributes = { [string] : [number] , [string] : [string] , [string] : [string] } [EOL] self . _name = name [EOL] self . port = port [EOL] self . modem = modem [EOL] self . _state = STATE_IDLE [EOL] modem . registercallback ( self . _incomingcallcallback ) [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , self . _stop_modem ) [EOL] [EOL] def set_state ( self , state ) : [EOL] [docstring] [EOL] self . _state = state [EOL] [EOL] def set_attributes ( self , attributes ) : [EOL] [docstring] [EOL] self . _attributes = attributes [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] def _stop_modem ( self , event ) : [EOL] [docstring] [EOL] if self . modem : [EOL] self . modem . close ( ) [EOL] self . modem = None [EOL] [EOL] def _incomingcallcallback ( self , newstate ) : [EOL] [docstring] [EOL] if newstate == self . modem . STATE_RING : [EOL] if self . state == self . modem . STATE_IDLE : [EOL] att = { [string] : self . modem . get_cidtime , [string] : [string] , [string] : [string] } [EOL] self . set_attributes ( att ) [EOL] self . _state = STATE_RING [EOL] self . schedule_update_ha_state ( ) [EOL] elif newstate == self . modem . STATE_CALLERID : [EOL] att = { [string] : self . modem . get_cidtime , [string] : self . modem . get_cidnumber , [string] : self . modem . get_cidname } [EOL] self . set_attributes ( att ) [EOL] self . _state = STATE_CALLERID [EOL] self . schedule_update_ha_state ( ) [EOL] elif newstate == self . modem . STATE_IDLE : [EOL] self . _state = STATE_IDLE [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] import threading [EOL] [docstring] [EOL] import logging [EOL] import threading [EOL] from uuid import UUID [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_MAC , CONF_NAME , EVENT_HOMEASSISTANT_STOP , STATE_UNKNOWN , TEMP_CELSIUS ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_DEVICE = [string] [EOL] ATTR_MODEL = [string] [EOL] [EOL] BLE_TEMP_HANDLE = [number] [EOL] BLE_TEMP_UUID = [string] [EOL] [EOL] CONNECT_LOCK = threading . Lock ( ) [EOL] CONNECT_TIMEOUT = [number] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] SKIP_HANDLE_LOOKUP = True [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MAC ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] mac = config . get ( CONF_MAC ) [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] mon = Monitor ( hass , mac , name ) [EOL] add_devices ( [ SkybeaconTemp ( name , mon ) ] ) [EOL] add_devices ( [ SkybeaconHumid ( name , mon ) ] ) [EOL] [EOL] def monitor_stop ( _service_or_event ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , name ) [EOL] mon . terminate ( ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , monitor_stop ) [EOL] mon . start ( ) [EOL] [EOL] [EOL] class SkybeaconHumid ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , mon ) : [EOL] [docstring] [EOL] self . mon = mon [EOL] self . _name = name [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . mon . data [ [string] ] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_DEVICE : [string] , ATTR_MODEL : [number] , } [EOL] [EOL] [EOL] class SkybeaconTemp ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , mon ) : [EOL] [docstring] [EOL] self . mon = mon [EOL] self . _name = name [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . mon . data [ [string] ] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_DEVICE : [string] , ATTR_MODEL : [number] , } [EOL] [EOL] [EOL] class Monitor ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , mac , name ) : [EOL] [docstring] [EOL] threading . Thread . __init__ ( self ) [EOL] self . daemon = False [EOL] self . hass = hass [EOL] self . mac = mac [EOL] self . name = name [EOL] self . data = { [string] : STATE_UNKNOWN , [string] : STATE_UNKNOWN } [EOL] self . keep_going = True [EOL] self . event = threading . Event ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] import pygatt [EOL] from pygatt . backends import Characteristic [EOL] from pygatt . exceptions import ( BLEError , NotConnectedError , NotificationTimeout ) [EOL] [EOL] cached_char = Characteristic ( BLE_TEMP_UUID , BLE_TEMP_HANDLE ) [EOL] adapter = pygatt . backends . GATTToolBackend ( ) [EOL] while True : [EOL] try : [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] [comment] [EOL] adapter . start ( reset_on_start = False ) [EOL] [comment] [EOL] with CONNECT_LOCK : [EOL] device = adapter . connect ( self . mac , CONNECT_TIMEOUT , pygatt . BLEAddressType . random ) [EOL] if SKIP_HANDLE_LOOKUP : [EOL] [comment] [EOL] [comment] [EOL] device . _characteristics [ UUID ( BLE_TEMP_UUID ) ] = cached_char [EOL] [comment] [EOL] device . char_write_handle ( [number] , bytearray ( [ [number] ] ) , False ) [EOL] device . subscribe ( BLE_TEMP_UUID , self . _update ) [EOL] _LOGGER . info ( [string] , self . name ) [EOL] while self . keep_going : [EOL] [comment] [EOL] device . char_read ( BLE_TEMP_UUID , timeout = CONNECT_TIMEOUT ) [EOL] self . event . wait ( [number] ) [EOL] break [EOL] except ( BLEError , NotConnectedError , NotificationTimeout ) as ex : [EOL] _LOGGER . error ( [string] , str ( ex ) ) [EOL] finally : [EOL] adapter . stop ( ) [EOL] [EOL] def _update ( self , handle , value ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , handle , self . name , value [ [number] ] , value [ [number] ] , value [ [number] ] ) [EOL] self . data [ [string] ] = float ( ( [string] % ( value [ [number] ] , value [ [number] ] ) ) ) [EOL] self . data [ [string] ] = value [ [number] ] [EOL] [EOL] def terminate ( self ) : [EOL] [docstring] [EOL] self . keep_going = False [EOL] self . event . set ( ) [EOL] self . join ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , List , Dict , Optional [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_USERNAME , CONF_NAME , CONF_PORT , CONF_MONITORED_VARIABLES , STATE_IDLE ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] _THROTTLED_REFRESH = None [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] DHT_UPLOAD = [number] [EOL] DHT_DOWNLOAD = [number] [EOL] SENSOR_TYPES = { [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Required ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_MONITORED_VARIABLES , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from deluge_client import DelugeRPCClient [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] deluge_api = DelugeRPCClient ( host , port , username , password ) [EOL] try : [EOL] deluge_api . connect ( ) [EOL] except ConnectionRefusedError : [EOL] _LOGGER . error ( [string] ) [EOL] raise PlatformNotReady [EOL] dev = [ ] [EOL] for variable in config [ CONF_MONITORED_VARIABLES ] : [EOL] dev . append ( DelugeSensor ( variable , deluge_api , name ) ) [EOL] [EOL] add_devices ( dev ) [EOL] [EOL] [EOL] class DelugeSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor_type , deluge_client , client_name ) : [EOL] [docstring] [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . client = deluge_client [EOL] self . type = sensor_type [EOL] self . client_name = client_name [EOL] self . _state = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . data = None [EOL] self . _available = False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from deluge_client import FailedToReconnectException [EOL] try : [EOL] self . data = self . client . call ( [string] , [ [string] , [string] , [string] , [string] ] ) [EOL] self . _available = True [EOL] except FailedToReconnectException : [EOL] _LOGGER . error ( [string] ) [EOL] self . _available = False [EOL] return [EOL] [EOL] upload = self . data [ [string] ] - self . data [ [string] ] [EOL] download = self . data [ [string] ] - self . data [ [string] ] [EOL] [EOL] if self . type == [string] : [EOL] if self . data : [EOL] if upload > [number] and download > [number] : [EOL] self . _state = [string] [EOL] elif upload > [number] and download == [number] : [EOL] self . _state = [string] [EOL] elif upload == [number] and download > [number] : [EOL] self . _state = [string] [EOL] else : [EOL] self . _state = STATE_IDLE [EOL] else : [EOL] self . _state = None [EOL] [EOL] if self . data : [EOL] if self . type == [string] : [EOL] kb_spd = float ( download ) [EOL] kb_spd = kb_spd / [number] [EOL] self . _state = round ( kb_spd , [number] if kb_spd < [number] else [number] ) [EOL] elif self . type == [string] : [EOL] kb_spd = float ( upload ) [EOL] kb_spd = kb_spd / [number] [EOL] self . _state = round ( kb_spd , [number] if kb_spd < [number] else [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import DOMAIN , PLATFORM_SCHEMA [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import track_time_change [EOL] from homeassistant . helpers . restore_state import async_get_last_state [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_SECOND = [string] [EOL] CONF_MINUTE = [string] [EOL] CONF_HOUR = [string] [EOL] CONF_DAY = [string] [EOL] CONF_MANUAL = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_SECOND , default = [ [number] ] ) : vol . All ( cv . ensure_list , [ vol . All ( vol . Coerce ( int ) , vol . Range ( [number] , [number] ) ) ] ) , vol . Optional ( CONF_MINUTE , default = [ [number] ] ) : vol . All ( cv . ensure_list , [ vol . All ( vol . Coerce ( int ) , vol . Range ( [number] , [number] ) ) ] ) , vol . Optional ( CONF_HOUR ) : vol . All ( cv . ensure_list , [ vol . All ( vol . Coerce ( int ) , vol . Range ( [number] , [number] ) ) ] ) , vol . Optional ( CONF_DAY ) : vol . All ( cv . ensure_list , [ vol . All ( vol . Coerce ( int ) , vol . Range ( [number] , [number] ) ) ] ) , vol . Optional ( CONF_MANUAL , default = False ) : cv . boolean , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] data = SpeedtestData ( hass , config ) [EOL] sensor = SpeedtestSensor ( data ) [EOL] add_devices ( [ sensor ] ) [EOL] [EOL] def update ( call = None ) : [EOL] [docstring] [EOL] data . update ( dt_util . now ( ) ) [EOL] sensor . update ( ) [EOL] [EOL] hass . services . register ( DOMAIN , [string] , update ) [EOL] [EOL] [EOL] class SpeedtestSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , speedtest_data ) : [EOL] [docstring] [EOL] self . _name = [string] [EOL] self . speedtest_client = speedtest_data [EOL] self . _state = None [EOL] self . _unit_of_measurement = [string] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] data = self . speedtest_client . data [EOL] if data is None : [EOL] return [EOL] [EOL] self . _state = data [ [string] ] [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] state = yield from async_get_last_state ( self . hass , self . entity_id ) [EOL] if not state : [EOL] return [EOL] self . _state = state . state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] [EOL] class SpeedtestData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] self . data = None [EOL] if not config . get ( CONF_MANUAL ) : [EOL] track_time_change ( hass , self . update , second = config . get ( CONF_SECOND ) , minute = config . get ( CONF_MINUTE ) , hour = config . get ( CONF_HOUR ) , day = config . get ( CONF_DAY ) ) [EOL] [EOL] def update ( self , now ) : [EOL] [docstring] [EOL] from fastdotcom import fast_com [EOL] _LOGGER . info ( [string] ) [EOL] self . data = { [string] : fast_com ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import math [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant import util [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import track_state_change [EOL] from homeassistant . const import ( ATTR_UNIT_OF_MEASUREMENT , TEMP_CELSIUS , TEMP_FAHRENHEIT , CONF_NAME ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_CRITICAL_TEMP = [string] [EOL] ATTR_DEWPOINT = [string] [EOL] [EOL] CONF_CALIBRATION_FACTOR = [string] [EOL] CONF_INDOOR_HUMIDITY = [string] [EOL] CONF_INDOOR_TEMP = [string] [EOL] CONF_OUTDOOR_TEMP = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MAGNUS_K2 = [number] [EOL] MAGNUS_K3 = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_INDOOR_TEMP ) : cv . entity_id , vol . Required ( CONF_OUTDOOR_TEMP ) : cv . entity_id , vol . Required ( CONF_INDOOR_HUMIDITY ) : cv . entity_id , vol . Optional ( CONF_CALIBRATION_FACTOR ) : vol . Coerce ( float ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME , DEFAULT_NAME ) [EOL] indoor_temp_sensor = config . get ( CONF_INDOOR_TEMP ) [EOL] outdoor_temp_sensor = config . get ( CONF_OUTDOOR_TEMP ) [EOL] indoor_humidity_sensor = config . get ( CONF_INDOOR_HUMIDITY ) [EOL] calib_factor = config . get ( CONF_CALIBRATION_FACTOR ) [EOL] [EOL] add_devices ( [ MoldIndicator ( hass , name , indoor_temp_sensor , outdoor_temp_sensor , indoor_humidity_sensor , calib_factor ) ] , True ) [EOL] [EOL] [EOL] class MoldIndicator ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , indoor_temp_sensor , outdoor_temp_sensor , indoor_humidity_sensor , calib_factor ) : [EOL] [docstring] [EOL] self . _state = None [EOL] self . _name = name [EOL] self . _indoor_temp_sensor = indoor_temp_sensor [EOL] self . _indoor_humidity_sensor = indoor_humidity_sensor [EOL] self . _outdoor_temp_sensor = outdoor_temp_sensor [EOL] self . _calib_factor = calib_factor [EOL] self . _is_metric = hass . config . units . is_metric [EOL] [EOL] self . _dewpoint = None [EOL] self . _indoor_temp = None [EOL] self . _outdoor_temp = None [EOL] self . _indoor_hum = None [EOL] self . _crit_temp = None [EOL] [EOL] track_state_change ( hass , indoor_temp_sensor , self . _sensor_changed ) [EOL] track_state_change ( hass , outdoor_temp_sensor , self . _sensor_changed ) [EOL] track_state_change ( hass , indoor_humidity_sensor , self . _sensor_changed ) [EOL] [EOL] [comment] [EOL] indoor_temp = hass . states . get ( indoor_temp_sensor ) [EOL] outdoor_temp = hass . states . get ( outdoor_temp_sensor ) [EOL] indoor_hum = hass . states . get ( indoor_humidity_sensor ) [EOL] [EOL] if indoor_temp : [EOL] self . _indoor_temp = MoldIndicator . _update_temp_sensor ( indoor_temp ) [EOL] [EOL] if outdoor_temp : [EOL] self . _outdoor_temp = MoldIndicator . _update_temp_sensor ( outdoor_temp ) [EOL] [EOL] if indoor_hum : [EOL] self . _indoor_hum = MoldIndicator . _update_hum_sensor ( indoor_hum ) [EOL] [EOL] @ staticmethod def _update_temp_sensor ( state ) : [EOL] [docstring] [EOL] unit = state . attributes . get ( ATTR_UNIT_OF_MEASUREMENT ) [EOL] temp = util . convert ( state . state , float ) [EOL] [EOL] if temp is None : [EOL] _LOGGER . error ( [string] , state . state ) [EOL] return None [EOL] [EOL] [comment] [EOL] if unit == TEMP_FAHRENHEIT : [EOL] return util . temperature . fahrenheit_to_celsius ( temp ) [EOL] if unit == TEMP_CELSIUS : [EOL] return temp [EOL] _LOGGER . error ( [string] [string] , unit , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] [EOL] return None [EOL] [EOL] @ staticmethod def _update_hum_sensor ( state ) : [EOL] [docstring] [EOL] unit = state . attributes . get ( ATTR_UNIT_OF_MEASUREMENT ) [EOL] hum = util . convert ( state . state , float ) [EOL] [EOL] if hum is None : [EOL] _LOGGER . error ( [string] , state . state ) [EOL] return None [EOL] [EOL] if unit != [string] : [EOL] _LOGGER . error ( [string] , unit , [string] ) [EOL] [EOL] if hum > [number] or hum < [number] : [EOL] _LOGGER . error ( [string] , hum , [string] ) [EOL] [EOL] return hum [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if None in ( self . _indoor_temp , self . _indoor_hum , self . _outdoor_temp ) : [EOL] return [EOL] [EOL] [comment] [EOL] self . _calc_dewpoint ( ) [EOL] self . _calc_moldindicator ( ) [EOL] [EOL] def _sensor_changed ( self , entity_id , old_state , new_state ) : [EOL] [docstring] [EOL] if new_state is None : [EOL] return [EOL] [EOL] if entity_id == self . _indoor_temp_sensor : [EOL] self . _indoor_temp = MoldIndicator . _update_temp_sensor ( new_state ) [EOL] elif entity_id == self . _outdoor_temp_sensor : [EOL] self . _outdoor_temp = MoldIndicator . _update_temp_sensor ( new_state ) [EOL] elif entity_id == self . _indoor_humidity_sensor : [EOL] self . _indoor_hum = MoldIndicator . _update_hum_sensor ( new_state ) [EOL] [EOL] self . update ( ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _calc_dewpoint ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] alpha = MAGNUS_K2 * self . _indoor_temp / ( MAGNUS_K3 + self . _indoor_temp ) [EOL] beta = MAGNUS_K2 * MAGNUS_K3 / ( MAGNUS_K3 + self . _indoor_temp ) [EOL] [EOL] if self . _indoor_hum == [number] : [EOL] self . _dewpoint = - [number] [comment] [EOL] else : [EOL] self . _dewpoint = MAGNUS_K3 * ( alpha + math . log ( self . _indoor_hum / [number] ) ) / ( beta - math . log ( self . _indoor_hum / [number] ) ) [EOL] _LOGGER . debug ( [string] , self . _dewpoint , TEMP_CELSIUS ) [EOL] [EOL] def _calc_moldindicator ( self ) : [EOL] [docstring] [EOL] if None in ( self . _dewpoint , self . _calib_factor ) or self . _calib_factor == [number] : [EOL] [EOL] _LOGGER . debug ( [string] [string] , self . _dewpoint , self . _calib_factor ) [EOL] self . _state = None [EOL] return [EOL] [EOL] [comment] [EOL] self . _crit_temp = self . _outdoor_temp + ( self . _indoor_temp - self . _outdoor_temp ) / self . _calib_factor [EOL] [EOL] _LOGGER . debug ( [string] , self . _crit_temp , TEMP_CELSIUS ) [EOL] [EOL] [comment] [EOL] alpha = MAGNUS_K2 * self . _crit_temp / ( MAGNUS_K3 + self . _crit_temp ) [EOL] beta = MAGNUS_K2 * MAGNUS_K3 / ( MAGNUS_K3 + self . _crit_temp ) [EOL] [EOL] crit_humidity = math . exp ( ( self . _dewpoint * beta - MAGNUS_K3 * alpha ) / ( self . _dewpoint + MAGNUS_K3 ) ) * [number] [EOL] [EOL] [comment] [EOL] if crit_humidity > [number] : [EOL] self . _state = [string] [EOL] elif crit_humidity < [number] : [EOL] self . _state = [string] [EOL] else : [EOL] self . _state = [string] . format ( int ( crit_humidity ) ) [EOL] [EOL] _LOGGER . debug ( [string] , self . _state ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _is_metric : [EOL] return { ATTR_DEWPOINT : self . _dewpoint , ATTR_CRITICAL_TEMP : self . _crit_temp , } [EOL] return { ATTR_DEWPOINT : util . temperature . celsius_to_fahrenheit ( self . _dewpoint ) , ATTR_CRITICAL_TEMP : util . temperature . celsius_to_fahrenheit ( self . _crit_temp ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . deconz . const import ( ATTR_DARK , ATTR_ON , CONF_ALLOW_CLIP_SENSOR , DOMAIN as DATA_DECONZ , DATA_DECONZ_ID , DATA_DECONZ_UNSUB ) [EOL] from homeassistant . const import ( ATTR_BATTERY_LEVEL , ATTR_VOLTAGE , DEVICE_CLASS_BATTERY ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import slugify [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] ATTR_CURRENT = [string] [EOL] ATTR_DAYLIGHT = [string] [EOL] ATTR_EVENT_ID = [string] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_devices ) : [EOL] [docstring] [EOL] @ callback def async_add_sensor ( sensors ) : [EOL] [docstring] [EOL] from pydeconz . sensor import DECONZ_SENSOR , SWITCH as DECONZ_REMOTE [EOL] entities = [ ] [EOL] allow_clip_sensor = config_entry . data . get ( CONF_ALLOW_CLIP_SENSOR , True ) [EOL] for sensor in sensors : [EOL] if sensor . type in DECONZ_SENSOR and not ( not allow_clip_sensor and sensor . type . startswith ( [string] ) ) : [EOL] if sensor . type in DECONZ_REMOTE : [EOL] if sensor . battery : [EOL] entities . append ( DeconzBattery ( sensor ) ) [EOL] else : [EOL] entities . append ( DeconzSensor ( sensor ) ) [EOL] async_add_devices ( entities , True ) [EOL] [EOL] hass . data [ DATA_DECONZ_UNSUB ] . append ( async_dispatcher_connect ( hass , [string] , async_add_sensor ) ) [EOL] [EOL] async_add_sensor ( hass . data [ DATA_DECONZ ] . sensors . values ( ) ) [EOL] [EOL] [EOL] class DeconzSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor ) : [EOL] [docstring] [EOL] self . _sensor = sensor [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _sensor . register_async_callback ( self . async_update_callback ) [EOL] self . hass . data [ DATA_DECONZ_ID ] [ self . entity_id ] = self . _sensor . deconz_id [EOL] [EOL] @ callback def async_update_callback ( self , reason ) : [EOL] [docstring] [EOL] if reason [ [string] ] or [string] in reason [ [string] ] or [string] in reason [ [string] ] or [string] in reason [ [string] ] : [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _sensor . state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _sensor . name [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _sensor . uniqueid [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _sensor . sensor_class [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _sensor . sensor_icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _sensor . sensor_unit [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _sensor . reachable [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] from pydeconz . sensor import LIGHTLEVEL [EOL] attr = { } [EOL] if self . _sensor . battery : [EOL] attr [ ATTR_BATTERY_LEVEL ] = self . _sensor . battery [EOL] if self . _sensor . on is not None : [EOL] attr [ ATTR_ON ] = self . _sensor . on [EOL] if self . _sensor . type in LIGHTLEVEL and self . _sensor . dark is not None : [EOL] attr [ ATTR_DARK ] = self . _sensor . dark [EOL] if self . unit_of_measurement == [string] : [EOL] attr [ ATTR_CURRENT ] = self . _sensor . current [EOL] attr [ ATTR_VOLTAGE ] = self . _sensor . voltage [EOL] if self . _sensor . sensor_class == [string] : [EOL] attr [ ATTR_DAYLIGHT ] = self . _sensor . daylight [EOL] return attr [EOL] [EOL] [EOL] class DeconzBattery ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] self . _device = device [EOL] self . _name = [string] . format ( self . _device . name , [string] ) [EOL] self . _unit_of_measurement = [string] [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _device . register_async_callback ( self . async_update_callback ) [EOL] self . hass . data [ DATA_DECONZ_ID ] [ self . entity_id ] = self . _device . deconz_id [EOL] [EOL] @ callback def async_update_callback ( self , reason ) : [EOL] [docstring] [EOL] if [string] in reason [ [string] ] : [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . battery [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _device . uniqueid [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_BATTERY [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { ATTR_EVENT_ID : slugify ( self . _device . name ) , } [EOL] return attr [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0
from typing import Any [EOL] import requests [EOL] import datetime [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_HOST , CONF_PORT [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . util . dt import utcnow [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] STATE_MIN_VALUE = [string] [EOL] STATE_MAX_VALUE = [string] [EOL] STATE_VALUE = [string] [EOL] STATE_OBJECT = [string] [EOL] CONF_INTERVAL = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] RETRY_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] OHM_VALUE = [string] [EOL] OHM_MIN = [string] [EOL] OHM_MAX = [string] [EOL] OHM_CHILDREN = [string] [EOL] OHM_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = [number] ) : cv . port } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] data = OpenHardwareMonitorData ( config , hass ) [EOL] add_devices ( data . devices , True ) [EOL] [EOL] [EOL] class OpenHardwareMonitorDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , name , path , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _data = data [EOL] self . path = path [EOL] self . attributes = { } [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] [EOL] self . value = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . value [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] return self . attributes [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _data . update ( ) [EOL] [EOL] array = self . _data . data [ OHM_CHILDREN ] [EOL] _attributes = { } [EOL] [EOL] for path_index in range ( [number] , len ( self . path ) ) : [EOL] path_number = self . path [ path_index ] [EOL] values = array [ path_number ] [EOL] [EOL] if path_index == len ( self . path ) - [number] : [EOL] self . value = values [ OHM_VALUE ] . split ( [string] ) [ [number] ] [EOL] _attributes . update ( { [string] : values [ OHM_NAME ] , STATE_MIN_VALUE : values [ OHM_MIN ] . split ( [string] ) [ [number] ] , STATE_MAX_VALUE : values [ OHM_MAX ] . split ( [string] ) [ [number] ] } ) [EOL] [EOL] self . attributes = _attributes [EOL] return [EOL] array = array [ path_number ] [ OHM_CHILDREN ] [EOL] _attributes . update ( { [string] % path_index : values [ OHM_NAME ] } ) [EOL] [EOL] [EOL] class OpenHardwareMonitorData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config , hass ) : [EOL] [docstring] [EOL] self . data = None [EOL] self . _config = config [EOL] self . _hass = hass [EOL] self . devices = [ ] [EOL] self . initialize ( utcnow ( ) ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] if self . data is None : [EOL] self . initialize ( utcnow ( ) ) [EOL] else : [EOL] self . refresh ( ) [EOL] [EOL] def refresh ( self ) : [EOL] [docstring] [EOL] data_url = [string] . format ( self . _config . get ( CONF_HOST ) , self . _config . get ( CONF_PORT ) ) [EOL] [EOL] try : [EOL] response = requests . get ( data_url , timeout = [number] ) [EOL] self . data = response . json ( ) [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def initialize ( self , now ) : [EOL] [docstring] [EOL] self . refresh ( ) [EOL] [EOL] if self . data is None : [EOL] return [EOL] [EOL] self . devices = self . parse_children ( self . data , [ ] , [ ] , [ ] ) [EOL] [EOL] def parse_children ( self , json , devices , path , names ) : [EOL] [docstring] [EOL] result = devices . copy ( ) [EOL] [EOL] if json [ OHM_CHILDREN ] : [EOL] for child_index in range ( [number] , len ( json [ OHM_CHILDREN ] ) ) : [EOL] child_path = path . copy ( ) [EOL] child_path . append ( child_index ) [EOL] [EOL] child_names = names . copy ( ) [EOL] if path : [EOL] child_names . append ( json [ OHM_NAME ] ) [EOL] [EOL] obj = json [ OHM_CHILDREN ] [ child_index ] [EOL] [EOL] added_devices = self . parse_children ( obj , devices , child_path , child_names ) [EOL] [EOL] result = result + added_devices [EOL] return result [EOL] [EOL] if json [ OHM_VALUE ] . find ( [string] ) == - [number] : [EOL] return result [EOL] [EOL] unit_of_measurement = json [ OHM_VALUE ] . split ( [string] ) [ [number] ] [EOL] child_names = names . copy ( ) [EOL] child_names . append ( json [ OHM_NAME ] ) [EOL] fullname = [string] . join ( child_names ) [EOL] [EOL] dev = OpenHardwareMonitorDevice ( self , fullname , path , unit_of_measurement ) [EOL] [EOL] result . append ( dev ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $homeassistant.components.sensor.openhardwaremonitor.OpenHardwareMonitorDevice$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $homeassistant.components.sensor.openhardwaremonitor.OpenHardwareMonitorDevice$ 0 0 0 $typing.Any$ 0
from typing import Type , Any , List , Dict [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] import copy [EOL] import logging [EOL] import socket [EOL] from collections import namedtuple [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . event import async_track_time_interval [EOL] from homeassistant . components . device_tracker import ( PLATFORM_SCHEMA , CONF_SCAN_INTERVAL , DEFAULT_SCAN_INTERVAL ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] FREEBOX_CONFIG_FILE = [string] [EOL] [EOL] PLATFORM_SCHEMA = vol . All ( PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PORT ) : cv . port } ) ) [EOL] [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] async def async_setup_scanner ( hass , config , async_see , discovery_info = None ) : [EOL] [docstring] [EOL] freebox_config = copy . deepcopy ( config ) [EOL] if discovery_info is not None : [EOL] freebox_config [ CONF_HOST ] = discovery_info [ [string] ] [ [string] ] [EOL] freebox_config [ CONF_PORT ] = discovery_info [ [string] ] [ [string] ] [EOL] _LOGGER . info ( [string] , freebox_config [ CONF_HOST ] , freebox_config [ CONF_PORT ] ) [EOL] [EOL] scanner = FreeboxDeviceScanner ( hass , freebox_config , async_see ) [EOL] interval = freebox_config . get ( CONF_SCAN_INTERVAL , DEFAULT_SCAN_INTERVAL ) [EOL] await scanner . async_start ( hass , interval ) [EOL] return True [EOL] [EOL] [EOL] Device = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def _build_device ( device_dict ) : [EOL] return Device ( device_dict [ [string] ] [ [string] ] , device_dict [ [string] ] , device_dict [ [string] ] [ [number] ] [ [string] ] ) [EOL] [EOL] [EOL] class FreeboxDeviceScanner : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config , async_see ) : [EOL] [docstring] [EOL] from aiofreepybox import Freepybox [EOL] [EOL] self . host = config [ CONF_HOST ] [EOL] self . port = config [ CONF_PORT ] [EOL] self . token_file = hass . config . path ( FREEBOX_CONFIG_FILE ) [EOL] self . async_see = async_see [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] app_desc = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : socket . gethostname ( ) } [EOL] [EOL] api_version = [string] [comment] [EOL] self . fbx = Freepybox ( app_desc = app_desc , token_file = self . token_file , api_version = api_version ) [EOL] [EOL] async def async_start ( self , hass , interval ) : [EOL] [docstring] [EOL] await self . async_update_info ( ) [EOL] interval = max ( interval , MIN_TIME_BETWEEN_SCANS ) [EOL] async_track_time_interval ( hass , self . async_update_info , interval ) [EOL] [EOL] async def async_update_info ( self , now = None ) : [EOL] [docstring] [EOL] from aiofreepybox . exceptions import HttpRequestError [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] await self . fbx . open ( self . host , self . port ) [EOL] try : [EOL] hosts = await self . fbx . lan . get_hosts_list ( ) [EOL] except HttpRequestError : [EOL] _LOGGER . exception ( [string] ) [EOL] else : [EOL] active_devices = [ _build_device ( device ) for device in hosts if device [ [string] ] ] [EOL] [EOL] if active_devices : [EOL] await asyncio . wait ( [ self . async_see ( mac = d . id , host_name = d . name ) for d in active_devices ] ) [EOL] [EOL] await self . fbx . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.device_tracker.freebox.Device]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.device_tracker.freebox.Device]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List , Dict [EOL] import builtins [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . components . bmw_connected_drive import DOMAIN as BMW_DOMAIN [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } [EOL] [EOL] SENSOR_TYPES_ELEC = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } [EOL] [EOL] SENSOR_TYPES_ELEC . update ( SENSOR_TYPES ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] accounts = hass . data [ BMW_DOMAIN ] [EOL] _LOGGER . debug ( [string] , [string] . join ( [ a . name for a in accounts ] ) ) [EOL] devices = [ ] [EOL] for account in accounts : [EOL] for vehicle in account . account . vehicles : [EOL] if vehicle . has_hv_battery : [EOL] _LOGGER . debug ( [string] ) [EOL] for key , value in sorted ( SENSOR_TYPES_ELEC . items ( ) ) : [EOL] device = BMWConnectedDriveSensor ( account , vehicle , key , value [ [number] ] , value [ [number] ] ) [EOL] devices . append ( device ) [EOL] elif vehicle . has_internal_combustion_engine : [EOL] _LOGGER . debug ( [string] ) [EOL] for key , value in sorted ( SENSOR_TYPES . items ( ) ) : [EOL] device = BMWConnectedDriveSensor ( account , vehicle , key , value [ [number] ] , value [ [number] ] ) [EOL] devices . append ( device ) [EOL] add_devices ( devices , True ) [EOL] [EOL] [EOL] class BMWConnectedDriveSensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , account , vehicle , attribute , sensor_name , device_class ) : [EOL] [docstring] [EOL] self . _account = account [EOL] self . _vehicle = vehicle [EOL] self . _attribute = attribute [EOL] self . _name = [string] . format ( self . _vehicle . name , self . _attribute ) [EOL] self . _unique_id = [string] . format ( self . _vehicle . vin , self . _attribute ) [EOL] self . _sensor_name = sensor_name [EOL] self . _device_class = device_class [EOL] self . _state = None [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _unique_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] vehicle_state = self . _vehicle . state [EOL] result = { [string] : self . _vehicle . name } [EOL] [EOL] if self . _attribute == [string] : [EOL] for lid in vehicle_state . lids : [EOL] result [ lid . name ] = lid . state . value [EOL] elif self . _attribute == [string] : [EOL] for window in vehicle_state . windows : [EOL] result [ window . name ] = window . state . value [EOL] elif self . _attribute == [string] : [EOL] result [ [string] ] = vehicle_state . door_lock_state . value [EOL] result [ [string] ] = vehicle_state . last_update_reason [EOL] elif self . _attribute == [string] : [EOL] result [ [string] ] = vehicle_state . parking_lights . value [EOL] elif self . _attribute == [string] : [EOL] for report in vehicle_state . condition_based_services : [EOL] result . update ( self . _format_cbs_report ( report ) ) [EOL] elif self . _attribute == [string] : [EOL] check_control_messages = vehicle_state . check_control_messages [EOL] if not check_control_messages : [EOL] result [ [string] ] = [string] [EOL] else : [EOL] result [ [string] ] = check_control_messages [EOL] elif self . _attribute == [string] : [EOL] result [ [string] ] = vehicle_state . charging_status . value [EOL] [comment] [EOL] result [ [string] ] = vehicle_state . _attributes [ [string] ] [EOL] if self . _attribute == [string] : [EOL] [comment] [EOL] result [ [string] ] = vehicle_state . _attributes [ [string] ] [EOL] [EOL] return sorted ( result . items ( ) ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from bimmer_connected . state import LockState [EOL] from bimmer_connected . state import ChargingState [EOL] vehicle_state = self . _vehicle . state [EOL] [EOL] [comment] [EOL] if self . _attribute == [string] : [EOL] _LOGGER . debug ( [string] , vehicle_state . all_lids_closed ) [EOL] self . _state = not vehicle_state . all_lids_closed [EOL] if self . _attribute == [string] : [EOL] self . _state = not vehicle_state . all_windows_closed [EOL] [comment] [EOL] if self . _attribute == [string] : [EOL] [comment] [EOL] self . _state = vehicle_state . door_lock_state not in [ LockState . LOCKED , LockState . SECURED ] [EOL] [comment] [EOL] if self . _attribute == [string] : [EOL] self . _state = vehicle_state . are_parking_lights_on [EOL] [comment] [EOL] if self . _attribute == [string] : [EOL] self . _state = not vehicle_state . are_all_cbs_ok [EOL] if self . _attribute == [string] : [EOL] self . _state = vehicle_state . has_check_control_messages [EOL] [comment] [EOL] if self . _attribute == [string] : [EOL] self . _state = vehicle_state . charging_status in [ ChargingState . CHARGING ] [EOL] [comment] [EOL] [comment] [EOL] if self . _attribute == [string] : [EOL] [comment] [EOL] self . _state = ( vehicle_state . _attributes [ [string] ] == [string] ) [EOL] [EOL] @ staticmethod def _format_cbs_report ( report ) : [EOL] result = { } [EOL] service_type = report . service_type . lower ( ) . replace ( [string] , [string] ) [EOL] result [ [string] . format ( service_type ) ] = report . state . value [EOL] if report . due_date is not None : [EOL] result [ [string] . format ( service_type ) ] = report . due_date . strftime ( [string] ) [EOL] if report . due_distance is not None : [EOL] result [ [string] . format ( service_type ) ] = [string] . format ( report . due_distance ) [EOL] return result [EOL] [EOL] def update_callback ( self ) : [EOL] [docstring] [EOL] self . schedule_update_ha_state ( True ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _account . add_update_listener ( self . update_callback ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import ( PLATFORM_SCHEMA , BinarySensorDevice ) [EOL] from homeassistant . components import rpi_pfio [EOL] from homeassistant . const import CONF_NAME , DEVICE_DEFAULT_NAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_INVERT_LOGIC = [string] [EOL] CONF_PORTS = [string] [EOL] CONF_SETTLE_TIME = [string] [EOL] [EOL] DEFAULT_INVERT_LOGIC = False [EOL] DEFAULT_SETTLE_TIME = [number] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PORT_SCHEMA = vol . Schema ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_SETTLE_TIME , default = DEFAULT_SETTLE_TIME ) : cv . positive_int , vol . Optional ( CONF_INVERT_LOGIC , default = DEFAULT_INVERT_LOGIC ) : cv . boolean , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_PORTS , default = { } ) : vol . Schema ( { cv . positive_int : PORT_SCHEMA , } ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] binary_sensors = [ ] [EOL] ports = config . get ( CONF_PORTS ) [EOL] for port , port_entity in ports . items ( ) : [EOL] name = port_entity . get ( CONF_NAME ) [EOL] settle_time = port_entity [ CONF_SETTLE_TIME ] / [number] [EOL] invert_logic = port_entity [ CONF_INVERT_LOGIC ] [EOL] [EOL] binary_sensors . append ( RPiPFIOBinarySensor ( hass , port , name , settle_time , invert_logic ) ) [EOL] add_devices ( binary_sensors , True ) [EOL] [EOL] rpi_pfio . activate_listener ( hass ) [EOL] [EOL] [EOL] class RPiPFIOBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , port , name , settle_time , invert_logic ) : [EOL] [docstring] [EOL] self . _port = port [EOL] self . _name = name or DEVICE_DEFAULT_NAME [EOL] self . _invert_logic = invert_logic [EOL] self . _state = None [EOL] [EOL] def read_pfio ( port ) : [EOL] [docstring] [EOL] self . _state = rpi_pfio . read_input ( self . _port ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] rpi_pfio . edge_detect ( hass , self . _port , read_pfio , settle_time ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state != self . _invert_logic [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _state = rpi_pfio . read_input ( self . _port ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . cover import ( CoverDevice , SUPPORT_OPEN , SUPPORT_CLOSE , SUPPORT_SET_POSITION , ATTR_POSITION ) [EOL] from homeassistant . components . lutron import ( LutronDevice , LUTRON_DEVICES , LUTRON_CONTROLLER ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] devs = [ ] [EOL] for ( area_name , device ) in hass . data [ LUTRON_DEVICES ] [ [string] ] : [EOL] dev = LutronCover ( area_name , device , hass . data [ LUTRON_CONTROLLER ] ) [EOL] devs . append ( dev ) [EOL] [EOL] add_devices ( devs , True ) [EOL] return True [EOL] [EOL] [EOL] class LutronCover ( LutronDevice , CoverDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_OPEN | SUPPORT_CLOSE | SUPPORT_SET_POSITION [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] return self . _lutron_device . last_level ( ) < [number] [EOL] [EOL] @ property def current_cover_position ( self ) : [EOL] [docstring] [EOL] return self . _lutron_device . last_level ( ) [EOL] [EOL] def close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _lutron_device . level = [number] [EOL] [EOL] def open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _lutron_device . level = [number] [EOL] [EOL] def set_cover_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_POSITION in kwargs : [EOL] position = kwargs [ ATTR_POSITION ] [EOL] self . _lutron_device . level = position [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] level = self . _lutron_device . level [EOL] _LOGGER . debug ( [string] , self . _lutron_device . id , level ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { } [EOL] attr [ [string] ] = self . _lutron_device . id [EOL] return attr [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import Any , Dict , Generator , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_HOST , CONF_PORT , CONF_TYPE , STATE_ON ) [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_EFFECT , ATTR_FLASH , ATTR_HS_COLOR , ATTR_TRANSITION , EFFECT_COLORLOOP , EFFECT_WHITE , FLASH_LONG , SUPPORT_BRIGHTNESS , SUPPORT_COLOR_TEMP , SUPPORT_EFFECT , SUPPORT_FLASH , SUPPORT_COLOR , SUPPORT_TRANSITION , Light , PLATFORM_SCHEMA ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util . color import ( color_temperature_mired_to_kelvin , color_hs_to_RGB ) [EOL] from homeassistant . helpers . restore_state import async_get_last_state [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_BRIDGES = [string] [EOL] CONF_GROUPS = [string] [EOL] CONF_NUMBER = [string] [EOL] CONF_VERSION = [string] [EOL] CONF_FADE = [string] [EOL] [EOL] DEFAULT_LED_TYPE = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_TRANSITION = [number] [EOL] DEFAULT_VERSION = [number] [EOL] DEFAULT_FADE = False [EOL] [EOL] LED_TYPE = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] EFFECT_NIGHT = [string] [EOL] [EOL] MIN_SATURATION = [number] [EOL] [EOL] WHITE = [ [number] , [number] ] [EOL] [EOL] SUPPORT_LIMITLESSLED_WHITE = ( SUPPORT_BRIGHTNESS | SUPPORT_COLOR_TEMP | SUPPORT_EFFECT | SUPPORT_TRANSITION ) [EOL] SUPPORT_LIMITLESSLED_DIMMER = ( SUPPORT_BRIGHTNESS | SUPPORT_TRANSITION ) [EOL] SUPPORT_LIMITLESSLED_RGB = ( SUPPORT_BRIGHTNESS | SUPPORT_EFFECT | SUPPORT_FLASH | SUPPORT_COLOR | SUPPORT_TRANSITION ) [EOL] SUPPORT_LIMITLESSLED_RGBWW = ( SUPPORT_BRIGHTNESS | SUPPORT_COLOR_TEMP | SUPPORT_EFFECT | SUPPORT_FLASH | SUPPORT_COLOR | SUPPORT_TRANSITION ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_BRIDGES ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_VERSION , default = DEFAULT_VERSION ) : cv . positive_int , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Required ( CONF_GROUPS ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_TYPE , default = DEFAULT_LED_TYPE ) : vol . In ( LED_TYPE ) , vol . Required ( CONF_NUMBER ) : cv . positive_int , vol . Optional ( CONF_FADE , default = DEFAULT_FADE ) : cv . boolean , } ] ) , } , ] ) , } ) [EOL] [EOL] [EOL] def rewrite_legacy ( config ) : [EOL] [docstring] [EOL] bridges = config . get ( CONF_BRIDGES , [ config ] ) [EOL] new_bridges = [ ] [EOL] for bridge_conf in bridges : [EOL] groups = [ ] [EOL] if [string] in bridge_conf : [EOL] groups = bridge_conf [ [string] ] [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] for i in range ( [number] , [number] ) : [EOL] name_key = [string] % i [EOL] if name_key in bridge_conf : [EOL] groups . append ( { [string] : i , [string] : bridge_conf . get ( [string] % i , DEFAULT_LED_TYPE ) , [string] : bridge_conf . get ( name_key ) } ) [EOL] new_bridges . append ( { [string] : bridge_conf . get ( CONF_HOST ) , [string] : bridge_conf . get ( CONF_VERSION ) , [string] : bridge_conf . get ( CONF_PORT ) , [string] : groups } ) [EOL] return { [string] : new_bridges } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from limitlessled . bridge import Bridge [EOL] [EOL] [comment] [EOL] [comment] [EOL] config = rewrite_legacy ( config ) [EOL] [EOL] [comment] [EOL] lights = [ ] [EOL] for bridge_conf in config . get ( CONF_BRIDGES ) : [EOL] bridge = Bridge ( bridge_conf . get ( CONF_HOST ) , port = bridge_conf . get ( CONF_PORT , DEFAULT_PORT ) , version = bridge_conf . get ( CONF_VERSION , DEFAULT_VERSION ) ) [EOL] for group_conf in bridge_conf . get ( CONF_GROUPS ) : [EOL] group = bridge . add_group ( group_conf . get ( CONF_NUMBER ) , group_conf . get ( CONF_NAME ) , group_conf . get ( CONF_TYPE , DEFAULT_LED_TYPE ) ) [EOL] lights . append ( LimitlessLEDGroup ( group , { [string] : group_conf [ CONF_FADE ] } ) ) [EOL] add_devices ( lights ) [EOL] [EOL] [EOL] def state ( new_state ) : [EOL] [docstring] [EOL] def decorator ( function ) : [EOL] [docstring] [EOL] [comment] [EOL] def wrapper ( self , ** kwargs ) : [EOL] [docstring] [EOL] from limitlessled . pipeline import Pipeline [EOL] pipeline = Pipeline ( ) [EOL] transition_time = DEFAULT_TRANSITION [EOL] if self . _effect == EFFECT_COLORLOOP : [EOL] self . group . stop ( ) [EOL] self . _effect = None [EOL] [comment] [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition_time = int ( kwargs [ ATTR_TRANSITION ] ) [EOL] [comment] [EOL] function ( self , transition_time , pipeline , ** kwargs ) [EOL] [comment] [EOL] self . _is_on = new_state [EOL] self . group . enqueue ( pipeline ) [EOL] self . schedule_update_ha_state ( ) [EOL] return wrapper [EOL] return decorator [EOL] [EOL] [EOL] class LimitlessLEDGroup ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , group , config ) : [EOL] [docstring] [EOL] from limitlessled . group . rgbw import RgbwGroup [EOL] from limitlessled . group . white import WhiteGroup [EOL] from limitlessled . group . dimmer import DimmerGroup [EOL] from limitlessled . group . rgbww import RgbwwGroup [EOL] if isinstance ( group , WhiteGroup ) : [EOL] self . _supported = SUPPORT_LIMITLESSLED_WHITE [EOL] self . _effect_list = [ EFFECT_NIGHT ] [EOL] elif isinstance ( group , DimmerGroup ) : [EOL] self . _supported = SUPPORT_LIMITLESSLED_DIMMER [EOL] self . _effect_list = [ ] [EOL] elif isinstance ( group , RgbwGroup ) : [EOL] self . _supported = SUPPORT_LIMITLESSLED_RGB [EOL] self . _effect_list = [ EFFECT_COLORLOOP , EFFECT_NIGHT , EFFECT_WHITE ] [EOL] elif isinstance ( group , RgbwwGroup ) : [EOL] self . _supported = SUPPORT_LIMITLESSLED_RGBWW [EOL] self . _effect_list = [ EFFECT_COLORLOOP , EFFECT_NIGHT , EFFECT_WHITE ] [EOL] [EOL] self . group = group [EOL] self . config = config [EOL] self . _is_on = False [EOL] self . _brightness = None [EOL] self . _temperature = None [EOL] self . _color = None [EOL] self . _effect = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] last_state = yield from async_get_last_state ( self . hass , self . entity_id ) [EOL] if last_state : [EOL] self . _is_on = ( last_state . state == STATE_ON ) [EOL] self . _brightness = last_state . attributes . get ( [string] ) [EOL] self . _temperature = last_state . attributes . get ( [string] ) [EOL] self . _color = last_state . attributes . get ( [string] ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . group . name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _is_on [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] if self . _effect == EFFECT_NIGHT : [EOL] return [number] [EOL] [EOL] return self . _brightness [EOL] [EOL] @ property def min_mireds ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] @ property def max_mireds ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] if self . hs_color is not None : [EOL] return None [EOL] return self . _temperature [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] if self . _effect == EFFECT_NIGHT : [EOL] return None [EOL] [EOL] if self . _color is None or self . _color [ [number] ] == [number] : [EOL] return None [EOL] [EOL] return self . _color [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported [EOL] [EOL] @ property def effect ( self ) : [EOL] [docstring] [EOL] return self . _effect [EOL] [EOL] @ property def effect_list ( self ) : [EOL] [docstring] [EOL] return self . _effect_list [EOL] [EOL] [comment] [EOL] @ state ( False ) def turn_off ( self , transition_time , pipeline , ** kwargs ) : [EOL] [docstring] [EOL] if self . config [ CONF_FADE ] : [EOL] pipeline . transition ( transition_time , brightness = [number] ) [EOL] pipeline . off ( ) [EOL] [EOL] [comment] [EOL] @ state ( True ) def turn_on ( self , transition_time , pipeline , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] if kwargs . get ( ATTR_EFFECT ) == EFFECT_NIGHT : [EOL] if EFFECT_NIGHT in self . _effect_list : [EOL] pipeline . night_light ( ) [EOL] self . _effect = EFFECT_NIGHT [EOL] return [EOL] [EOL] pipeline . on ( ) [EOL] [EOL] [comment] [EOL] args = { } [EOL] if self . config [ CONF_FADE ] and not self . is_on and self . _brightness : [EOL] args [ [string] ] = self . limitlessled_brightness ( ) [EOL] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] args [ [string] ] = self . limitlessled_brightness ( ) [EOL] [EOL] if ATTR_HS_COLOR in kwargs and self . _supported & SUPPORT_COLOR : [EOL] self . _color = kwargs [ ATTR_HS_COLOR ] [EOL] [comment] [EOL] if self . _color [ [number] ] < MIN_SATURATION : [EOL] pipeline . white ( ) [EOL] self . _color = WHITE [EOL] else : [EOL] args [ [string] ] = self . limitlessled_color ( ) [EOL] [EOL] if ATTR_COLOR_TEMP in kwargs : [EOL] if self . _supported & SUPPORT_COLOR : [EOL] pipeline . white ( ) [EOL] self . _color = WHITE [EOL] if self . _supported & SUPPORT_COLOR_TEMP : [EOL] self . _temperature = kwargs [ ATTR_COLOR_TEMP ] [EOL] args [ [string] ] = self . limitlessled_temperature ( ) [EOL] [EOL] if args : [EOL] pipeline . transition ( transition_time , ** args ) [EOL] [EOL] [comment] [EOL] if ATTR_FLASH in kwargs and self . _supported & SUPPORT_FLASH : [EOL] duration = [number] [EOL] if kwargs [ ATTR_FLASH ] == FLASH_LONG : [EOL] duration = [number] [EOL] pipeline . flash ( duration = duration ) [EOL] [EOL] [comment] [EOL] if ATTR_EFFECT in kwargs and self . _effect_list : [EOL] if kwargs [ ATTR_EFFECT ] == EFFECT_COLORLOOP : [EOL] from limitlessled . presets import COLORLOOP [EOL] self . _effect = EFFECT_COLORLOOP [EOL] pipeline . append ( COLORLOOP ) [EOL] if kwargs [ ATTR_EFFECT ] == EFFECT_WHITE : [EOL] pipeline . white ( ) [EOL] self . _color = WHITE [EOL] [EOL] def limitlessled_temperature ( self ) : [EOL] [docstring] [EOL] max_kelvin = color_temperature_mired_to_kelvin ( self . min_mireds ) [EOL] min_kelvin = color_temperature_mired_to_kelvin ( self . max_mireds ) [EOL] width = max_kelvin - min_kelvin [EOL] kelvin = color_temperature_mired_to_kelvin ( self . _temperature ) [EOL] temperature = ( kelvin - min_kelvin ) / width [EOL] return max ( [number] , min ( [number] , temperature ) ) [EOL] [EOL] def limitlessled_brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness / [number] [EOL] [EOL] def limitlessled_color ( self ) : [EOL] [docstring] [EOL] from limitlessled import Color [EOL] return Color ( * color_hs_to_RGB ( * tuple ( self . _color ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 $builtins.bool$ 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] [EOL] CONF_AUTOSETUP = [string] [EOL] CONF_INFO = [string] [EOL] CONF_XPATH = [string] [EOL] CONF_NODE = [string] [EOL] CONF_INVERTING = [string] [EOL] CONF_DIMMABLE = [string] [EOL] CONF_BINARY_SENSOR = [string] [EOL] CONF_LIGHT = [string] [EOL] CONF_SENSOR = [string] [EOL] CONF_SWITCH = [string] [EOL] [EOL] ATTR_IHC_ID = [string] [EOL] ATTR_VALUE = [string] [EOL] [EOL] SERVICE_SET_RUNTIME_VALUE_BOOL = [string] [EOL] SERVICE_SET_RUNTIME_VALUE_INT = [string] [EOL] SERVICE_SET_RUNTIME_VALUE_FLOAT = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components import remote [EOL] from homeassistant . const import ( DEVICE_DEFAULT_NAME , CONF_NAME , CONF_MAC , CONF_HOST , CONF_PORT , CONF_DEVICES ) [EOL] from homeassistant . components . remote import PLATFORM_SCHEMA [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_PORT = [number] [EOL] CONNECT_TIMEOUT = [number] [EOL] [EOL] CONF_MODADDR = [string] [EOL] CONF_CONNADDR = [string] [EOL] CONF_COMMANDS = [string] [EOL] CONF_DATA = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MAC ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Required ( CONF_DEVICES ) : vol . All ( cv . ensure_list , [ { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_MODADDR ) : vol . Coerce ( int ) , vol . Required ( CONF_CONNADDR ) : vol . Coerce ( int ) , vol . Required ( CONF_COMMANDS ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_DATA ) : cv . string } ] ) } ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import pyitachip2ir [EOL] itachip2ir = pyitachip2ir . ITachIP2IR ( config . get ( CONF_MAC ) , config . get ( CONF_HOST ) , int ( config . get ( CONF_PORT ) ) ) [EOL] [EOL] if not itachip2ir . ready ( CONNECT_TIMEOUT ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] devices = [ ] [EOL] for data in config . get ( CONF_DEVICES ) : [EOL] name = data . get ( CONF_NAME ) [EOL] modaddr = int ( data . get ( CONF_MODADDR , [number] ) ) [EOL] connaddr = int ( data . get ( CONF_CONNADDR , [number] ) ) [EOL] cmddatas = [string] [EOL] for cmd in data . get ( CONF_COMMANDS ) : [EOL] cmdname = cmd [ CONF_NAME ] . strip ( ) [EOL] if not cmdname : [EOL] cmdname = [string] [EOL] cmddata = cmd [ CONF_DATA ] . strip ( ) [EOL] if not cmddata : [EOL] cmddata = [string] [EOL] cmddatas += [string] . format ( cmdname , cmddata ) [EOL] itachip2ir . addDevice ( name , modaddr , connaddr , cmddatas ) [EOL] devices . append ( ITachIP2IRRemote ( itachip2ir , name ) ) [EOL] add_devices ( devices , True ) [EOL] return True [EOL] [EOL] [EOL] class ITachIP2IRRemote ( remote . RemoteDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , itachip2ir , name ) : [EOL] [docstring] [EOL] self . itachip2ir = itachip2ir [EOL] self . _power = False [EOL] self . _name = name or DEVICE_DEFAULT_NAME [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _power [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _power = True [EOL] self . itachip2ir . send ( self . _name , [string] , [number] ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _power = False [EOL] self . itachip2ir . send ( self . _name , [string] , [number] ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def send_command ( self , command , ** kwargs ) : [EOL] [docstring] [EOL] for single_command in command : [EOL] self . itachip2ir . send ( self . _name , single_command , [number] ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . itachip2ir . update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from unittest . mock import patch , mock_open [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . helpers import entity_registry [EOL] [EOL] from tests . common import mock_registry [EOL] [EOL] [EOL] YAML__OPEN_PATH = [string] [EOL] [EOL] [EOL] @ pytest . fixture def registry ( hass ) : [EOL] [docstring] [EOL] return mock_registry ( hass ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_or_create_returns_same_entry ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] entry2 = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] [EOL] assert len ( registry . entities ) == [number] [EOL] assert entry is entry2 [EOL] assert entry . entity_id == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_or_create_suggested_object_id ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] , suggested_object_id = [string] ) [EOL] [EOL] assert entry . entity_id == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_or_create_suggested_object_id_conflict_register ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] , suggested_object_id = [string] ) [EOL] entry2 = registry . async_get_or_create ( [string] , [string] , [string] , suggested_object_id = [string] ) [EOL] [EOL] assert entry . entity_id == [string] [EOL] assert entry2 . entity_id == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_or_create_suggested_object_id_conflict_existing ( hass , registry ) : [EOL] [docstring] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry . entity_id == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_create_triggers_save ( hass , registry ) : [EOL] [docstring] [EOL] with patch . object ( hass . loop , [string] ) as mock_call_later : [EOL] registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] [EOL] assert len ( mock_call_later . mock_calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_save_timer_reset_on_subsequent_save ( hass , registry ) : [EOL] [docstring] [EOL] with patch . object ( hass . loop , [string] ) as mock_call_later : [EOL] registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] [EOL] assert len ( mock_call_later . mock_calls ) == [number] [EOL] [EOL] with patch . object ( hass . loop , [string] ) as mock_call_later_2 : [EOL] registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] [EOL] assert len ( mock_call_later ( ) . cancel . mock_calls ) == [number] [EOL] assert len ( mock_call_later_2 . mock_calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_loading_saving_data ( hass , registry ) : [EOL] [docstring] [EOL] orig_entry1 = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] orig_entry2 = registry . async_get_or_create ( [string] , [string] , [string] , config_entry_id = [string] ) [EOL] [EOL] assert len ( registry . entities ) == [number] [EOL] [EOL] with patch ( YAML__OPEN_PATH , mock_open ( ) , create = True ) as mock_write : [EOL] yield from registry . _async_save ( ) [EOL] [EOL] [comment] [EOL] written = mock_write . mock_calls [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] [comment] [EOL] registry2 = entity_registry . EntityRegistry ( hass ) [EOL] [EOL] with patch ( [string] , return_value = True ) , patch ( YAML__OPEN_PATH , mock_open ( read_data = written ) , create = True ) : [EOL] yield from registry2 . _async_load ( ) [EOL] [EOL] [comment] [EOL] assert list ( registry . entities ) == list ( registry2 . entities ) [EOL] new_entry1 = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] new_entry2 = registry . async_get_or_create ( [string] , [string] , [string] , config_entry_id = [string] ) [EOL] [EOL] assert orig_entry1 == new_entry1 [EOL] assert orig_entry2 == new_entry2 [EOL] [EOL] [EOL] @ asyncio . coroutine def test_generate_entity_considers_registered_entities ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry . entity_id == [string] [EOL] assert registry . async_generate_entity_id ( [string] , [string] ) == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_generate_entity_considers_existing_entities ( hass , registry ) : [EOL] [docstring] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] assert registry . async_generate_entity_id ( [string] , [string] ) == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_is_registered ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert registry . async_is_registered ( entry . entity_id ) [EOL] assert not registry . async_is_registered ( [string] ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_loading_extra_values ( hass ) : [EOL] [docstring] [EOL] written = [string] [EOL] [EOL] registry = entity_registry . EntityRegistry ( hass ) [EOL] [EOL] with patch ( [string] , return_value = True ) , patch ( YAML__OPEN_PATH , mock_open ( read_data = written ) , create = True ) : [EOL] yield from registry . _async_load ( ) [EOL] [EOL] entry_with_name = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] entry_without_name = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry_with_name . name == [string] [EOL] assert entry_without_name . name is None [EOL] assert not entry_with_name . disabled [EOL] [EOL] entry_disabled_hass = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] entry_disabled_user = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry_disabled_hass . disabled [EOL] assert entry_disabled_hass . disabled_by == entity_registry . DISABLED_HASS [EOL] assert entry_disabled_user . disabled [EOL] assert entry_disabled_user . disabled_by == entity_registry . DISABLED_USER [EOL] [EOL] [EOL] @ asyncio . coroutine def test_async_get_entity_id ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] ) [EOL] assert entry . entity_id == [string] [EOL] assert registry . async_get_entity_id ( [string] , [string] , [string] ) == [string] [EOL] assert registry . async_get_entity_id ( [string] , [string] , [string] ) is None [EOL] [EOL] [EOL] async def test_updating_config_entry_id ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( [string] , [string] , [string] , config_entry_id = [string] ) [EOL] entry2 = registry . async_get_or_create ( [string] , [string] , [string] , config_entry_id = [string] ) [EOL] assert entry . entity_id == entry2 . entity_id [EOL] assert entry2 . config_entry_id == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from tests . common import get_test_home_assistant , MockDependency [EOL] [EOL] from homeassistant . components import melissa [EOL] [EOL] VALID_CONFIG = { [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] [EOL] class TestMelissa ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . config = VALID_CONFIG [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ MockDependency ( [string] ) def test_setup ( self , mocked_melissa ) : [EOL] [docstring] [EOL] melissa . setup ( self . hass , self . config ) [EOL] [EOL] mocked_melissa . Melissa . assert_called_with ( username = [string] , password = [string] ) [EOL] self . assertIn ( melissa . DATA_MELISSA , self . hass . data ) [EOL] self . assertIsInstance ( self . hass . data [ melissa . DATA_MELISSA ] , type ( mocked_melissa . Melissa ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import unittest [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from tests . common import init_recorder_component , get_test_home_assistant [EOL] [EOL] [EOL] class TestGraph ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_component ( self ) : [EOL] [docstring] [EOL] self . init_recorder ( ) [EOL] config = { [string] : { } , [string] : { [string] : { [string] : [string] , } } } [EOL] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , config ) ) [EOL] self . assertEqual ( dict ( self . hass . states . get ( [string] ) . attributes ) , { [string] : [ [string] ] , [string] : [string] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] def init_recorder ( self ) : [EOL] [docstring] [EOL] init_recorder_component ( self . hass ) [EOL] self . hass . start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] from homeassistant . components import dyson [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] def _get_dyson_account_device_available ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( ) [EOL] device . serial = [string] [EOL] device . connect = mock . Mock ( return_value = True ) [EOL] device . auto_connect = mock . Mock ( return_value = True ) [EOL] return device [EOL] [EOL] [EOL] def _get_dyson_account_device_not_available ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( ) [EOL] device . serial = [string] [EOL] device . connect = mock . Mock ( return_value = False ) [EOL] device . auto_connect = mock . Mock ( return_value = False ) [EOL] return device [EOL] [EOL] [EOL] def _get_dyson_account_device_error ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( ) [EOL] device . serial = [string] [EOL] device . connect = mock . Mock ( side_effect = OSError ( [string] ) ) [EOL] return device [EOL] [EOL] [EOL] class DysonTest ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ mock . patch ( [string] , return_value = False ) def test_dyson_login_failed ( self , mocked_login ) : [EOL] [docstring] [EOL] dyson . setup ( self . hass , { dyson . DOMAIN : { dyson . CONF_USERNAME : [string] , dyson . CONF_PASSWORD : [string] , dyson . CONF_LANGUAGE : [string] } } ) [EOL] self . assertEqual ( mocked_login . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] , return_value = [ ] ) @ mock . patch ( [string] , return_value = True ) def test_dyson_login ( self , mocked_login , mocked_devices ) : [EOL] [docstring] [EOL] dyson . setup ( self . hass , { dyson . DOMAIN : { dyson . CONF_USERNAME : [string] , dyson . CONF_PASSWORD : [string] , dyson . CONF_LANGUAGE : [string] } } ) [EOL] self . assertEqual ( mocked_login . call_count , [number] ) [EOL] self . assertEqual ( mocked_devices . call_count , [number] ) [EOL] self . assertEqual ( len ( self . hass . data [ dyson . DYSON_DEVICES ] ) , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , return_value = [ _get_dyson_account_device_available ( ) ] ) @ mock . patch ( [string] , return_value = True ) def test_dyson_custom_conf ( self , mocked_login , mocked_devices , mocked_discovery ) : [EOL] [docstring] [EOL] dyson . setup ( self . hass , { dyson . DOMAIN : { dyson . CONF_USERNAME : [string] , dyson . CONF_PASSWORD : [string] , dyson . CONF_LANGUAGE : [string] , dyson . CONF_DEVICES : [ { [string] : [string] , [string] : [string] } ] } } ) [EOL] self . assertEqual ( mocked_login . call_count , [number] ) [EOL] self . assertEqual ( mocked_devices . call_count , [number] ) [EOL] self . assertEqual ( len ( self . hass . data [ dyson . DYSON_DEVICES ] ) , [number] ) [EOL] self . assertEqual ( mocked_discovery . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] , return_value = [ _get_dyson_account_device_not_available ( ) ] ) @ mock . patch ( [string] , return_value = True ) def test_dyson_custom_conf_device_not_available ( self , mocked_login , mocked_devices ) : [EOL] [docstring] [EOL] dyson . setup ( self . hass , { dyson . DOMAIN : { dyson . CONF_USERNAME : [string] , dyson . CONF_PASSWORD : [string] , dyson . CONF_LANGUAGE : [string] , dyson . CONF_DEVICES : [ { [string] : [string] , [string] : [string] } ] } } ) [EOL] self . assertEqual ( mocked_login . call_count , [number] ) [EOL] self . assertEqual ( mocked_devices . call_count , [number] ) [EOL] self . assertEqual ( len ( self . hass . data [ dyson . DYSON_DEVICES ] ) , [number] ) [EOL] [EOL] @ mock . patch ( [string] , return_value = [ _get_dyson_account_device_error ( ) ] ) @ mock . patch ( [string] , return_value = True ) def test_dyson_custom_conf_device_error ( self , mocked_login , mocked_devices ) : [EOL] [docstring] [EOL] dyson . setup ( self . hass , { dyson . DOMAIN : { dyson . CONF_USERNAME : [string] , dyson . CONF_PASSWORD : [string] , dyson . CONF_LANGUAGE : [string] , dyson . CONF_DEVICES : [ { [string] : [string] , [string] : [string] } ] } } ) [EOL] self . assertEqual ( mocked_login . call_count , [number] ) [EOL] self . assertEqual ( mocked_devices . call_count , [number] ) [EOL] self . assertEqual ( len ( self . hass . data [ dyson . DYSON_DEVICES ] ) , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , return_value = [ _get_dyson_account_device_available ( ) ] ) @ mock . patch ( [string] , return_value = True ) def test_dyson_custom_conf_with_unknown_device ( self , mocked_login , mocked_devices , mocked_discovery ) : [EOL] [docstring] [EOL] dyson . setup ( self . hass , { dyson . DOMAIN : { dyson . CONF_USERNAME : [string] , dyson . CONF_PASSWORD : [string] , dyson . CONF_LANGUAGE : [string] , dyson . CONF_DEVICES : [ { [string] : [string] , [string] : [string] } ] } } ) [EOL] self . assertEqual ( mocked_login . call_count , [number] ) [EOL] self . assertEqual ( mocked_devices . call_count , [number] ) [EOL] self . assertEqual ( len ( self . hass . data [ dyson . DYSON_DEVICES ] ) , [number] ) [EOL] self . assertEqual ( mocked_discovery . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] , return_value = [ _get_dyson_account_device_available ( ) ] ) @ mock . patch ( [string] , return_value = True ) def test_dyson_discovery ( self , mocked_login , mocked_devices , mocked_discovery ) : [EOL] [docstring] [EOL] dyson . setup ( self . hass , { dyson . DOMAIN : { dyson . CONF_USERNAME : [string] , dyson . CONF_PASSWORD : [string] , dyson . CONF_LANGUAGE : [string] , dyson . CONF_TIMEOUT : [number] , dyson . CONF_RETRY : [number] } } ) [EOL] self . assertEqual ( mocked_login . call_count , [number] ) [EOL] self . assertEqual ( mocked_devices . call_count , [number] ) [EOL] self . assertEqual ( len ( self . hass . data [ dyson . DYSON_DEVICES ] ) , [number] ) [EOL] self . assertEqual ( mocked_discovery . call_count , [number] ) [EOL] [EOL] @ mock . patch ( [string] , return_value = [ _get_dyson_account_device_not_available ( ) ] ) @ mock . patch ( [string] , return_value = True ) def test_dyson_discovery_device_not_available ( self , mocked_login , mocked_devices ) : [EOL] [docstring] [EOL] dyson . setup ( self . hass , { dyson . DOMAIN : { dyson . CONF_USERNAME : [string] , dyson . CONF_PASSWORD : [string] , dyson . CONF_LANGUAGE : [string] , dyson . CONF_TIMEOUT : [number] , dyson . CONF_RETRY : [number] } } ) [EOL] self . assertEqual ( mocked_login . call_count , [number] ) [EOL] self . assertEqual ( mocked_devices . call_count , [number] ) [EOL] self . assertEqual ( len ( self . hass . data [ dyson . DYSON_DEVICES ] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , List , Dict [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import time [EOL] from datetime import timedelta [EOL] [EOL] import unittest [EOL] from genericpath import exists [EOL] from logging import getLogger [EOL] from os import remove [EOL] from unittest import mock [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . components import feedreader [EOL] from homeassistant . components . feedreader import CONF_URLS , FeedManager , StoredData , EVENT_FEEDREADER , DEFAULT_SCAN_INTERVAL , CONF_MAX_ENTRIES , DEFAULT_MAX_ENTRIES [EOL] from homeassistant . const import EVENT_HOMEASSISTANT_START , CONF_SCAN_INTERVAL [EOL] from homeassistant . core import callback [EOL] from homeassistant . setup import setup_component [EOL] from tests . common import get_test_home_assistant , load_fixture [EOL] [EOL] _LOGGER = getLogger ( __name__ ) [EOL] [EOL] URL = [string] [EOL] VALID_CONFIG_1 = { feedreader . DOMAIN : { CONF_URLS : [ URL ] } } [EOL] VALID_CONFIG_2 = { feedreader . DOMAIN : { CONF_URLS : [ URL ] , CONF_SCAN_INTERVAL : [number] } } [EOL] VALID_CONFIG_3 = { feedreader . DOMAIN : { CONF_URLS : [ URL ] , CONF_MAX_ENTRIES : [number] } } [EOL] [EOL] [EOL] class TestFeedreaderComponent ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [comment] [EOL] data_file = self . hass . config . path ( [string] . format ( [string] ) ) [EOL] if exists ( data_file ) : [EOL] remove ( data_file ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_one_feed ( self ) : [EOL] [docstring] [EOL] with patch ( [string] [string] ) as track_method : [EOL] self . assertTrue ( setup_component ( self . hass , feedreader . DOMAIN , VALID_CONFIG_1 ) ) [EOL] track_method . assert_called_once_with ( self . hass , mock . ANY , DEFAULT_SCAN_INTERVAL ) [EOL] [EOL] def test_setup_scan_interval ( self ) : [EOL] [docstring] [EOL] with patch ( [string] [string] ) as track_method : [EOL] self . assertTrue ( setup_component ( self . hass , feedreader . DOMAIN , VALID_CONFIG_2 ) ) [EOL] track_method . assert_called_once_with ( self . hass , mock . ANY , timedelta ( seconds = [number] ) ) [EOL] [EOL] def test_setup_max_entries ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , feedreader . DOMAIN , VALID_CONFIG_3 ) ) [EOL] [EOL] def setup_manager ( self , feed_data , max_entries = DEFAULT_MAX_ENTRIES ) : [EOL] [docstring] [EOL] events = [ ] [EOL] [EOL] @ callback def record_event ( event ) : [EOL] [docstring] [EOL] events . append ( event ) [EOL] [EOL] self . hass . bus . listen ( EVENT_FEEDREADER , record_event ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] data_file = self . hass . config . path ( [string] . format ( feedreader . DOMAIN ) ) [EOL] storage = StoredData ( data_file ) [EOL] with patch ( [string] [string] ) as track_method : [EOL] manager = FeedManager ( feed_data , DEFAULT_SCAN_INTERVAL , max_entries , self . hass , storage ) [EOL] [comment] [EOL] [comment] [EOL] track_method . assert_called_once_with ( self . hass , mock . ANY , DEFAULT_SCAN_INTERVAL ) [EOL] [comment] [EOL] self . hass . bus . fire ( EVENT_HOMEASSISTANT_START ) [EOL] [comment] [EOL] self . hass . block_till_done ( ) [EOL] return manager , events [EOL] [EOL] def test_feed ( self ) : [EOL] [docstring] [EOL] feed_data = load_fixture ( [string] ) [EOL] manager , events = self . setup_manager ( feed_data ) [EOL] assert len ( events ) == [number] [EOL] assert events [ [number] ] . data . title == [string] [EOL] assert events [ [number] ] . data . description == [string] [EOL] assert events [ [number] ] . data . link == [string] [EOL] assert events [ [number] ] . data . id == [string] [EOL] assert events [ [number] ] . data . published_parsed . tm_year == [number] [EOL] assert events [ [number] ] . data . published_parsed . tm_mon == [number] [EOL] assert events [ [number] ] . data . published_parsed . tm_mday == [number] [EOL] assert events [ [number] ] . data . published_parsed . tm_hour == [number] [EOL] assert events [ [number] ] . data . published_parsed . tm_min == [number] [EOL] assert manager . last_update_successful is True [EOL] [EOL] def test_feed_updates ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] feed_data = load_fixture ( [string] ) [EOL] manager , events = self . setup_manager ( feed_data ) [EOL] assert len ( events ) == [number] [EOL] [comment] [EOL] feed_data2 = load_fixture ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] with patch ( [string] [string] , return_value = time . struct_time ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) ) : [EOL] manager2 , events2 = self . setup_manager ( feed_data2 ) [EOL] assert len ( events2 ) == [number] [EOL] [comment] [EOL] feed_data3 = load_fixture ( [string] ) [EOL] with patch ( [string] [string] , return_value = time . struct_time ( ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) ) ) : [EOL] manager3 , events3 = self . setup_manager ( feed_data3 ) [EOL] assert len ( events3 ) == [number] [EOL] [EOL] def test_feed_default_max_length ( self ) : [EOL] [docstring] [EOL] feed_data = load_fixture ( [string] ) [EOL] manager , events = self . setup_manager ( feed_data ) [EOL] assert len ( events ) == [number] [EOL] [EOL] def test_feed_max_length ( self ) : [EOL] [docstring] [EOL] feed_data = load_fixture ( [string] ) [EOL] manager , events = self . setup_manager ( feed_data , max_entries = [number] ) [EOL] assert len ( events ) == [number] [EOL] [EOL] def test_feed_without_publication_date ( self ) : [EOL] [docstring] [EOL] feed_data = load_fixture ( [string] ) [EOL] manager , events = self . setup_manager ( feed_data ) [EOL] assert len ( events ) == [number] [EOL] [EOL] def test_feed_invalid_data ( self ) : [EOL] [docstring] [EOL] feed_data = [string] [EOL] manager , events = self . setup_manager ( feed_data ) [EOL] assert len ( events ) == [number] [EOL] assert manager . last_update_successful is True [EOL] [EOL] @ mock . patch ( [string] , return_value = None ) def test_feed_parsing_failed ( self , mock_parse ) : [EOL] [docstring] [EOL] data_file = self . hass . config . path ( [string] . format ( feedreader . DOMAIN ) ) [EOL] storage = StoredData ( data_file ) [EOL] manager = FeedManager ( [string] , DEFAULT_SCAN_INTERVAL , DEFAULT_MAX_ENTRIES , self . hass , storage ) [EOL] [comment] [EOL] self . hass . bus . fire ( EVENT_HOMEASSISTANT_START ) [EOL] [comment] [EOL] self . hass . block_till_done ( ) [EOL] assert manager . last_update_successful is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.feedreader.StoredData$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.feedreader.FeedManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.feedreader.StoredData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.feedreader.FeedManager$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.feedreader.StoredData$ 0 0 0 $typing.Any$ 0 0 $homeassistant.components.feedreader.FeedManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.feedreader.StoredData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.feedreader.FeedManager$ 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] import unittest [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . setup import setup_component [EOL] import homeassistant . components . automation as automation [EOL] [EOL] from tests . common import get_test_home_assistant , mock_component [EOL] [EOL] [EOL] [comment] [EOL] class TestAutomationEvent ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] mock_component ( self . hass , [string] ) [EOL] self . calls = [ ] [EOL] [EOL] @ callback def record_call ( service ) : [EOL] [docstring] [EOL] self . calls . append ( service ) [EOL] [EOL] self . hass . services . register ( [string] , [string] , record_call ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_if_fires_on_event ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] automation . turn_off ( self . hass ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_event_extra_data ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] , { [string] : [string] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] automation . turn_off ( self . hass ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_event_with_data ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] } } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] , { [string] : [string] , [string] : [string] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_event_with_empty_data_config ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : { } } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] , { [string] : [string] , [string] : [string] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_event_with_nested_data ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] } } } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] , { [string] : { [string] : [string] , [string] : [string] } } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_fires_if_event_data_not_matches ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] } } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] , { [string] : [string] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] [EOL] import homeassistant . components . http as http [EOL] [EOL] [EOL] class TestView ( http . HomeAssistantView ) : [EOL] [docstring] [EOL] [EOL] name = [string] [EOL] url = [string] [EOL] [EOL] async def get ( self , request ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] async def test_registering_view_while_running ( hass , aiohttp_client , aiohttp_unused_port ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , http . DOMAIN , { http . DOMAIN : { http . CONF_SERVER_PORT : aiohttp_unused_port ( ) , } } ) [EOL] [EOL] await hass . async_start ( ) [EOL] [comment] [EOL] hass . http . register_view ( TestView ) [EOL] [EOL] [EOL] async def test_api_base_url_with_domain ( hass ) : [EOL] [docstring] [EOL] result = await async_setup_component ( hass , [string] , { [string] : { [string] : [string] } } ) [EOL] assert result [EOL] assert hass . config . api . base_url == [string] [EOL] [EOL] [EOL] async def test_api_base_url_with_ip ( hass ) : [EOL] [docstring] [EOL] result = await async_setup_component ( hass , [string] , { [string] : { [string] : [string] } } ) [EOL] assert result [EOL] assert hass . config . api . base_url == [string] [EOL] [EOL] [EOL] async def test_api_base_url_with_ip_port ( hass ) : [EOL] [docstring] [EOL] result = await async_setup_component ( hass , [string] , { [string] : { [string] : [string] } } ) [EOL] assert result [EOL] assert hass . config . api . base_url == [string] [EOL] [EOL] [EOL] async def test_api_no_base_url ( hass ) : [EOL] [docstring] [EOL] result = await async_setup_component ( hass , [string] , { [string] : { } } ) [EOL] assert result [EOL] assert hass . config . api . base_url == [string] [EOL] [EOL] [EOL] async def test_not_log_password ( hass , aiohttp_client , caplog ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , [string] , { [string] : { http . CONF_API_PASSWORD : [string] } } ) [EOL] client = await aiohttp_client ( hass . http . app ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . INFO ) [EOL] [EOL] resp = await client . get ( [string] , params = { [string] : [string] } ) [EOL] [EOL] assert resp . status == [number] [EOL] logs = caplog . text [EOL] [EOL] [comment] [EOL] assert [string] in logs [EOL] assert [string] not in logs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Union , List , Dict [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . components import sensor [EOL] from homeassistant . setup import setup_component [EOL] from tests . common import ( get_test_home_assistant , assert_setup_component , MockDependency ) [EOL] [EOL] VALID_CONFIG = { [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] , } [EOL] [EOL] [EOL] class MockPrice ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , price , fuel_type , last_updated , price_unit , station_code ) : [EOL] [docstring] [EOL] self . price = price [EOL] self . fuel_type = fuel_type [EOL] self . last_updated = last_updated [EOL] self . price_unit = price_unit [EOL] self . station_code = station_code [EOL] [EOL] [EOL] class MockStation ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , code ) : [EOL] [docstring] [EOL] self . name = name [EOL] self . code = code [EOL] [EOL] [EOL] class MockGetReferenceDataResponse ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , stations ) : [EOL] [docstring] [EOL] self . stations = stations [EOL] [EOL] [EOL] class FuelCheckClientMock ( ) : [EOL] [docstring] [EOL] [EOL] def get_fuel_prices_for_station ( self , station ) : [EOL] [docstring] [EOL] return [ MockPrice ( price = [number] , fuel_type = [string] , last_updated = None , price_unit = None , station_code = [number] ) , MockPrice ( price = [number] , fuel_type = [string] , last_updated = None , price_unit = None , station_code = [number] ) ] [EOL] [EOL] def get_reference_data ( self ) : [EOL] [docstring] [EOL] return MockGetReferenceDataResponse ( stations = [ MockStation ( code = [number] , name = [string] ) ] ) [EOL] [EOL] [EOL] class TestNSWFuelStation ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . config = VALID_CONFIG [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = FuelCheckClientMock ) def test_setup ( self , mock_nsw_fuel ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , sensor . DOMAIN ) : [EOL] self . assertTrue ( setup_component ( self . hass , sensor . DOMAIN , { [string] : VALID_CONFIG } ) ) [EOL] [EOL] fake_entities = [ [string] , [string] ] [EOL] [EOL] for entity_id in fake_entities : [EOL] state = self . hass . states . get ( [string] . format ( entity_id ) ) [EOL] self . assertIsNotNone ( state ) [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = FuelCheckClientMock ) def test_sensor_values ( self , mock_nsw_fuel ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , sensor . DOMAIN , { [string] : VALID_CONFIG } ) ) [EOL] [EOL] self . assertEqual ( [string] , self . hass . states . get ( [string] ) . state ) [EOL] self . assertEqual ( [string] , self . hass . states . get ( [string] ) . state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Type , Any , Union , Dict [EOL] import typing [EOL] import datetime [EOL] import tests [EOL] [docstring] [EOL] import os [EOL] from datetime import timedelta [EOL] import unittest [EOL] from unittest import mock [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components import device_tracker [EOL] from homeassistant . components . device_tracker import ( CONF_CONSIDER_HOME , CONF_TRACK_NEW , CONF_AWAY_HIDE , CONF_NEW_DEVICE_DEFAULTS ) [EOL] from homeassistant . components . device_tracker . unifi_direct import ( DOMAIN , CONF_PORT , PLATFORM_SCHEMA , _response_to_json , get_scanner ) [EOL] from homeassistant . const import ( CONF_PLATFORM , CONF_PASSWORD , CONF_USERNAME , CONF_HOST ) [EOL] [EOL] from tests . common import ( get_test_home_assistant , assert_setup_component , mock_component , load_fixture ) [EOL] [EOL] [EOL] class TestComponentsDeviceTrackerUnifiDirect ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] hass = None [EOL] scanner_path = [string] + [string] [EOL] [EOL] def setup_method ( self , _ ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] mock_component ( self . hass , [string] ) [EOL] [EOL] def teardown_method ( self , _ ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] try : [EOL] os . remove ( self . hass . config . path ( device_tracker . YAML_DEVICES ) ) [EOL] except FileNotFoundError : [EOL] pass [EOL] [EOL] @ mock . patch ( scanner_path , return_value = mock . MagicMock ( ) ) def test_get_scanner ( self , unifi_mock ) : [EOL] [docstring] [EOL] conf_dict = { DOMAIN : { CONF_PLATFORM : [string] , CONF_HOST : [string] , CONF_USERNAME : [string] , CONF_PASSWORD : [string] , CONF_TRACK_NEW : True , CONF_CONSIDER_HOME : timedelta ( seconds = [number] ) , CONF_NEW_DEVICE_DEFAULTS : { CONF_TRACK_NEW : True , CONF_AWAY_HIDE : False } } } [EOL] [EOL] with assert_setup_component ( [number] , DOMAIN ) : [EOL] assert setup_component ( self . hass , DOMAIN , conf_dict ) [EOL] [EOL] conf_dict [ DOMAIN ] [ CONF_PORT ] = [number] [EOL] self . assertEqual ( unifi_mock . call_args , mock . call ( conf_dict [ DOMAIN ] ) ) [EOL] [EOL] @ patch ( [string] ) def test_get_device_name ( self , mock_ssh ) : [EOL] [docstring] [EOL] conf_dict = { DOMAIN : { CONF_PLATFORM : [string] , CONF_HOST : [string] , CONF_USERNAME : [string] , CONF_PASSWORD : [string] , CONF_PORT : [number] , CONF_TRACK_NEW : True , CONF_CONSIDER_HOME : timedelta ( seconds = [number] ) } } [EOL] mock_ssh . return_value . before = load_fixture ( [string] ) [EOL] scanner = get_scanner ( self . hass , conf_dict ) [EOL] devices = scanner . scan_devices ( ) [EOL] self . assertEqual ( [number] , len ( devices ) ) [EOL] self . assertEqual ( [string] , scanner . get_device_name ( [string] ) ) [EOL] self . assertEqual ( [string] , scanner . get_device_name ( [string] ) ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_failed_to_log_in ( self , mock_login , mock_logout ) : [EOL] [docstring] [EOL] from pexpect import exceptions [EOL] [EOL] conf_dict = { DOMAIN : { CONF_PLATFORM : [string] , CONF_HOST : [string] , CONF_USERNAME : [string] , CONF_PASSWORD : [string] , CONF_PORT : [number] , CONF_TRACK_NEW : True , CONF_CONSIDER_HOME : timedelta ( seconds = [number] ) } } [EOL] [EOL] mock_login . side_effect = exceptions . EOF ( [string] ) [EOL] scanner = get_scanner ( self . hass , conf_dict ) [EOL] self . assertFalse ( scanner ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] , autospec = True ) @ patch ( [string] ) @ patch ( [string] ) def test_to_get_update ( self , mock_sendline , mock_prompt , mock_login , mock_logout ) : [EOL] [docstring] [EOL] conf_dict = { DOMAIN : { CONF_PLATFORM : [string] , CONF_HOST : [string] , CONF_USERNAME : [string] , CONF_PASSWORD : [string] , CONF_PORT : [number] , CONF_TRACK_NEW : True , CONF_CONSIDER_HOME : timedelta ( seconds = [number] ) } } [EOL] [EOL] scanner = get_scanner ( self . hass , conf_dict ) [EOL] [comment] [EOL] mock_prompt . side_effect = AssertionError ( [string] ) [EOL] devices = scanner . _get_update ( ) [comment] [EOL] self . assertTrue ( devices is None ) [EOL] [EOL] def test_good_response_parses ( self ) : [EOL] [docstring] [EOL] response = _response_to_json ( load_fixture ( [string] ) ) [EOL] self . assertTrue ( response != { } ) [EOL] [EOL] def test_bad_response_returns_none ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( _response_to_json ( [string] ) == { } ) [EOL] [EOL] [EOL] def test_config_error ( ) : [EOL] [docstring] [EOL] with pytest . raises ( vol . Invalid ) : [EOL] PLATFORM_SCHEMA ( { CONF_PASSWORD : [string] , CONF_PLATFORM : DOMAIN , CONF_HOST : [string] , [string] : [number] , } ) [EOL] with pytest . raises ( vol . Invalid ) : [EOL] PLATFORM_SCHEMA ( { CONF_USERNAME : [string] , CONF_PLATFORM : DOMAIN , CONF_HOST : [string] , [string] : [number] , } ) [EOL] with pytest . raises ( vol . Invalid ) : [EOL] PLATFORM_SCHEMA ( { CONF_PLATFORM : DOMAIN , CONF_USERNAME : [string] , CONF_PASSWORD : [string] , CONF_HOST : [string] , [string] : [string] , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[typing.Dict[unknown,builtins.bool],builtins.bool,datetime.timedelta,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[typing.Dict[unknown,builtins.bool],builtins.bool,datetime.timedelta,builtins.str]]]$ 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[typing.Dict[unknown,builtins.bool],builtins.bool,datetime.timedelta,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[typing.Dict[unknown,builtins.bool],builtins.bool,datetime.timedelta,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[datetime.timedelta,builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[datetime.timedelta,builtins.int,builtins.str]]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[datetime.timedelta,builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[datetime.timedelta,builtins.int,builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[datetime.timedelta,builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Dict[unknown,typing.Union[datetime.timedelta,builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0