[docstring] [EOL] try : [EOL] from setuptools import setup [EOL] except ImportError : [EOL] from distutils . core import setup [EOL] [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , keywords = [string] , author = [string] , author_email = [string] , url = [string] , license = [string] , packages = [ [string] ] , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import components [EOL] from . . import components as c [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass class C1 ( c . Component ) : [EOL] val = ... [EOL] [EOL] def tree ( self ) : [EOL] z = [ ] [EOL] z += c . Tag ( [string] , content = c . Text ( [string] ) ) [EOL] z += C2 ( self . val ) [EOL] return z [EOL] [EOL] [EOL] @ dataclass class C2 ( c . Component ) : [EOL] val = ... [EOL] [EOL] def tree ( self ) : [EOL] z = [ ] [EOL] with c . Tag ( [string] , { [string] : [string] } ) . into ( z ) : [EOL] z += c . Text ( self . val ) [EOL] return z [EOL] [EOL] [EOL] def test_components ( ) : [EOL] html = C1 ( [string] ) . render ( ) [EOL] assert [string] == html [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $components.Nodes$ 0 0 0 0 0 $components.Nodes$ 0 0 0 0 $components.Nodes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.Nodes$ 0 0 0 0 0 0 0 0 0 $components.Nodes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $components.Nodes$ 0 0 0 0 0 $components.Nodes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $components.Nodes$ 0 0 0 $components.Nodes$ 0 0 0 0 0 0 0 0 0 0 0 $components.Nodes$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Iterator , ClassVar , Iterable , Dict , Type , Any [EOL] import typing [EOL] import builtins [EOL] import hsweb [EOL] import asyncio [EOL] from contextlib import contextmanager [EOL] from dataclasses import dataclass , field [EOL] import html [EOL] import re [EOL] from typing import ClassVar , Dict , Iterable , Iterator , Type [EOL] from typing_extensions import Protocol [EOL] [EOL] [EOL] class InvalidTag ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Node : [EOL] async def arender ( self ) : [EOL] return self . render ( ) [EOL] [EOL] def render ( self ) : [EOL] return [string] [EOL] [EOL] def __iter__ ( self ) : [EOL] yield self [EOL] [EOL] [EOL] Nodes = Iterable [ Node ] [EOL] [EOL] [EOL] @ dataclass class Text ( Node ) : [EOL] text = ... [EOL] [EOL] def render ( self ) : [EOL] return html . escape ( self . text ) [EOL] [EOL] [EOL] @ dataclass class Tag ( Node ) : [EOL] tag_name = ... [EOL] attrs = field ( default_factory = dict ) [EOL] content = field ( default_factory = list ) [EOL] [EOL] def __post_init__ ( self ) : [EOL] _assert_valid_tag ( self . tag_name ) [EOL] for key in self . attrs : [EOL] _assert_valid_tag ( key ) [EOL] [EOL] async def arender ( self ) : [EOL] rendered = await asyncio . gather ( * [ node . arender ( ) for node in self . content ] ) [EOL] inner = [string] . join ( rendered ) [EOL] return f"{ self . open_tag ( ) }{ inner } [string] { self . tag_name } [string] " [EOL] [EOL] def render ( self ) : [EOL] inner = [string] . join ( node . render ( ) for node in self . content ) [EOL] return f"{ self . open_tag ( ) }{ inner } [string] { self . tag_name } [string] " [EOL] [EOL] def open_tag ( self ) : [EOL] attrs = [string] . join ( f'{ key } [string] { html . escape ( value ) } [string] ' for key , value in self . attrs . items ( ) ) [EOL] attrs = f" [string] { attrs }" if attrs else [string] [EOL] return f" [string] { self . tag_name }{ attrs } [string] " [EOL] [EOL] @ contextmanager def into ( self , z ) : [EOL] z += _EnterTag ( self ) [EOL] yield [EOL] z += _LeaveTag ( self ) [EOL] [EOL] [EOL] @ dataclass class _EnterTag ( Node ) : [EOL] tag = ... [EOL] [EOL] def render ( self ) : [EOL] return self . tag . open_tag ( ) [EOL] [EOL] [EOL] @ dataclass class _LeaveTag ( Node ) : [EOL] tag = ... [EOL] [EOL] def render ( self ) : [EOL] return f" [string] { self . tag . tag_name } [string] " [EOL] [EOL] [EOL] class SelfClosingTag ( Node ) : [EOL] tag_name = ... [EOL] attrs = field ( default_factory = dict ) [EOL] [EOL] def __post_init__ ( self ) : [EOL] _assert_valid_tag ( self . tag_name ) [EOL] for key in self . attrs : [EOL] _assert_valid_tag ( key ) [EOL] [EOL] def render ( self ) : [EOL] attrs = [string] . join ( f'{ key } [string] { html . escape ( value ) } [string] ' for key , value in self . attrs . items ( ) ) [EOL] attrs = f" [string] { attrs }" if attrs else [string] [EOL] return f" [string] { self . tag_name }{ attrs } [string] " [EOL] [EOL] [EOL] class _TagCallable ( Protocol ) : [EOL] def __call__ ( self , content = [ ] , ** attrs ) : [EOL] pass [EOL] [EOL] [EOL] _ATTR_MAPPING = { [string] : [string] } [EOL] [EOL] [EOL] def _make_tag ( tag_name ) : [EOL] def inner ( content = [ ] , ** attrs ) : [EOL] attrs = { _ATTR_MAPPING . get ( k , k ) : v for k , v in attrs . items ( ) } [EOL] return Tag ( tag_name , attrs , content ) [EOL] [EOL] return inner [EOL] [EOL] [EOL] Div = _make_tag ( [string] ) [EOL] Span = _make_tag ( [string] ) [EOL] OL = _make_tag ( [string] ) [EOL] UL = _make_tag ( [string] ) [EOL] LI = _make_tag ( [string] ) [EOL] P = _make_tag ( [string] ) [EOL] B = _make_tag ( [string] ) [EOL] I = _make_tag ( [string] ) [EOL] A = _make_tag ( [string] ) [EOL] Table = _make_tag ( [string] ) [EOL] TR = _make_tag ( [string] ) [EOL] TH = _make_tag ( [string] ) [EOL] TD = _make_tag ( [string] ) [EOL] H1 = _make_tag ( [string] ) [EOL] H2 = _make_tag ( [string] ) [EOL] H3 = _make_tag ( [string] ) [EOL] H4 = _make_tag ( [string] ) [EOL] H5 = _make_tag ( [string] ) [EOL] DL = _make_tag ( [string] ) [EOL] DT = _make_tag ( [string] ) [EOL] DD = _make_tag ( [string] ) [EOL] [EOL] [EOL] class Component ( Node ) : [EOL] wrapper_tag = Div [EOL] [EOL] async def atree ( self ) : [EOL] return self . tree ( ) [EOL] [EOL] def tree ( self ) : [EOL] return [ ] [EOL] [EOL] async def arender ( self ) : [EOL] z = [ ] [EOL] with self . wrapper_tag ( ) . into ( z ) : [EOL] z += await self . atree ( ) [EOL] rendered = await asyncio . gather ( * [ node . arender ( ) for node in z ] ) [EOL] return [string] . join ( rendered ) [EOL] [EOL] def render ( self ) : [EOL] return [string] . join ( node . render ( ) for node in self . tree ( ) ) [EOL] [EOL] [EOL] def _assert_valid_tag ( tag ) : [EOL] if not re . match ( [string] , tag ) : [EOL] raise InvalidTag ( tag ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Nodes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $Nodes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Nodes$ 0 0 0 $Nodes$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Nodes$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Iterator , Iterable , Callable , TypeVar , Dict , Type , List , Any [EOL] import typing [EOL] import taxonomy [EOL] import builtins [EOL] import builtins [EOL] import enum [EOL] import functools [EOL] import sys [EOL] from typing import ( TYPE_CHECKING , Any , Callable , Dict , Iterable , Iterator , List , MutableMapping , Tuple , Type , TypeVar , ) [EOL] [EOL] BASIC_TYPES = ( int , str , float , bool , list ) [EOL] [EOL] [EOL] class _ADTMember : [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] self . called = False [EOL] [EOL] def __call__ ( self , * , tag , ** kwargs ) : [EOL] self . tag = tag [EOL] self . kwargs = kwargs [EOL] self . called = True [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . name } [string] { self . called } [string] " [EOL] [EOL] [EOL] class _ADTNamespace ( MutableMapping [ str , Any ] ) : [EOL] def __init__ ( self , globals_dict ) : [EOL] self . _globals = globals_dict [EOL] self . _mapping = { } [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] if key in self . _mapping : [EOL] return self . _mapping [ key ] [EOL] elif key in self . _globals : [EOL] return self . _globals [ key ] [EOL] elif hasattr ( builtins , key ) : [EOL] return getattr ( builtins , key ) [EOL] elif key . startswith ( [string] ) : [EOL] raise KeyError ( key ) [EOL] member = _ADTMember ( key ) [EOL] self . _mapping [ key ] = member [EOL] return member [EOL] [EOL] def __contains__ ( self , key ) : [EOL] return key in self . _mapping [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] self . _mapping [ key ] = value [EOL] [EOL] def __delitem__ ( self , key ) : [EOL] del self . _mapping [ key ] [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . _mapping ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _mapping ) [EOL] [EOL] [EOL] def _adt_member_eq ( self , other ) : [EOL] if not isinstance ( other , self . _adt_cls ) : [EOL] return NotImplemented [EOL] if not isinstance ( other , type ( self ) ) : [EOL] return False [EOL] for attr in self . _attributes . keys ( ) : [EOL] if getattr ( self , attr ) != getattr ( other , attr ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def _none_safe_lt ( left , right ) : [EOL] if left is None : [EOL] return right is not None [EOL] elif right is None : [EOL] return False [EOL] else : [EOL] return left < right [EOL] [EOL] [EOL] def _adt_member_lt ( self , other ) : [EOL] if not isinstance ( other , self . _adt_cls ) : [EOL] return NotImplemented [EOL] if not isinstance ( other , type ( self ) ) : [EOL] return type ( self ) . __name__ < type ( other ) . __name__ [EOL] for attr in self . _attributes . keys ( ) : [EOL] left_attr = getattr ( self , attr ) [EOL] right_attr = getattr ( other , attr ) [EOL] if left_attr == right_attr : [EOL] continue [EOL] return _none_safe_lt ( left_attr , right_attr ) [EOL] return False [EOL] [EOL] [EOL] def _adt_member_hash ( self ) : [EOL] return hash ( ( type ( self ) , tuple ( getattr ( self , attr ) for attr in self . _attributes ) ) ) [EOL] [EOL] [EOL] class _ADTMeta ( type ) : [EOL] @ classmethod def __prepare__ ( mcs , name , bases ) : [comment] [EOL] return _ADTNamespace ( sys . _getframe ( [number] ) . f_globals ) [EOL] [EOL] def __new__ ( mcs , name , bases , ns ) : [EOL] if [string] in ns and ns [ [string] ] : [EOL] return super ( ) . __new__ ( mcs , name , bases , ns ) [EOL] members = { } [EOL] for key , value in list ( ns . items ( ) ) : [EOL] if isinstance ( value , _ADTMember ) : [EOL] members [ key ] = value [EOL] del ns [ key ] [EOL] new_cls = super ( ) . __new__ ( mcs , name , bases , dict ( ns . items ( ) , _members = tuple ( members . keys ( ) ) ) ) [EOL] new_cls . _tag_to_member = { } [comment] [EOL] if name in members and not members [ name ] . called : [EOL] del members [ name ] [EOL] has_self_cls = True [EOL] else : [EOL] has_self_cls = False [EOL] for member in members . values ( ) : [EOL] if not member . called : [EOL] raise TypeError ( f" [string] { member }" ) [EOL] has_args = bool ( member . kwargs ) [EOL] attrs = { } [EOL] member_ns = { [string] : attrs , [string] : member . tag , [string] : has_args , [string] : True , [string] : new_cls , [string] : _adt_member_eq , [string] : _adt_member_lt , [string] : _adt_member_hash , } [EOL] if has_args : [EOL] for key , value in member . kwargs . items ( ) : [EOL] if value in BASIC_TYPES : [EOL] attrs [ key ] = value [EOL] elif isinstance ( value , type ) and issubclass ( value , enum . IntEnum ) : [EOL] attrs [ key ] = value [EOL] elif ( isinstance ( value , type ) [EOL] and hasattr ( value , [string] ) [EOL] and hasattr ( value , [string] ) ) : [EOL] attrs [ key ] = value [EOL] elif ( has_self_cls [EOL] and isinstance ( value , _ADTMember ) [EOL] and value . name == name ) : [EOL] attrs [ key ] = new_cls [EOL] else : [EOL] raise TypeError ( f" [string] { value }" ) [EOL] lines = [string] . join ( f" [string] { attr } [string] { attr } [string] " for attr in member . kwargs . keys ( ) ) [EOL] code = ( f' [string] { [string] . join ( member . kwargs . keys ( ) ) } [string] { lines }' ) [EOL] new_ns = { } [EOL] exec ( code , { } , new_ns ) [EOL] member_ns [ [string] ] = new_ns [ [string] ] [EOL] member_cls = functools . total_ordering ( type ( member . name , ( new_cls , ) , member_ns ) ) [EOL] if not has_args : [EOL] cls_obj = member_cls [EOL] member_cls = cls_obj ( ) [EOL] [EOL] def make_init ( member_cls ) : [EOL] def __init__ ( self ) : [EOL] raise TypeError ( f" [string] { member_cls }" ) [EOL] [EOL] return __init__ [EOL] [EOL] cls_obj . __init__ = make_init ( member_cls ) [EOL] new_cls . _tag_to_member [ member . tag ] = member_cls [comment] [EOL] setattr ( new_cls , member . name , member_cls ) [EOL] return new_cls [EOL] [EOL] [EOL] _ADTT = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] if TYPE_CHECKING : [EOL] [EOL] class _ADTBase ( Any ) : [EOL] pass [EOL] [EOL] [EOL] else : [EOL] [EOL] class _ADTBase : [EOL] pass [EOL] [EOL] [EOL] class ADT ( _ADTBase , metaclass = _ADTMeta ) : [EOL] _attributes = ... [EOL] _has_args = ... [EOL] _tag = ... [EOL] _tag_to_member = ... [EOL] [EOL] def _get_attributes ( self ) : [EOL] for attr in self . _attributes . keys ( ) : [EOL] yield getattr ( self , attr ) [EOL] [EOL] def serialize ( self ) : [EOL] if self . _has_args : [EOL] args = [ ] [EOL] for value in self . _get_attributes ( ) : [EOL] if hasattr ( value , [string] ) : [EOL] args . append ( value . serialize ( ) ) [EOL] elif isinstance ( value , enum . IntEnum ) : [EOL] args . append ( value . value ) [EOL] else : [EOL] args . append ( value ) [EOL] return [ self . _tag , * args ] [EOL] else : [EOL] return [ self . _tag ] [EOL] [EOL] @ classmethod def unserialize ( cls , value ) : [EOL] tag = value [ [number] ] [EOL] member_cls = cls . _tag_to_member [ tag ] [EOL] if member_cls . _has_args : [EOL] args = [ ] [EOL] for arg_type , serialized in zip ( member_cls . _attributes . values ( ) , value [ [number] : ] ) : [EOL] if hasattr ( arg_type , [string] ) : [EOL] if serialized is None : [EOL] args . append ( None ) [EOL] else : [EOL] args . append ( arg_type . unserialize ( serialized ) ) [EOL] elif isinstance ( arg_type , type ) and issubclass ( arg_type , enum . IntEnum ) : [EOL] args . append ( arg_type ( serialized ) ) [EOL] else : [EOL] args . append ( serialized ) [EOL] return member_cls ( * args ) [EOL] else : [EOL] return member_cls [comment] [EOL] [EOL] def __repr__ ( self ) : [EOL] member_name = type ( self ) . __name__ [EOL] if not self . _has_args : [EOL] return member_name [EOL] else : [EOL] args = [string] . join ( map ( repr , self . _get_attributes ( ) ) ) [EOL] return f"{ member_name } [string] { args } [string] " [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.int,typing.Type[typing.Any]]$ 0 0 0 0 0 $typing.Iterable[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ADTT$ 0 $typing.Type[_ADTT]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Type[typing.Any]$ 0 $typing.Type[_ADTT]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0
import builtins [EOL] import enum [EOL] [EOL] from . adt import ADT [EOL] [EOL] LEAF = [number] [EOL] NODE = [number] [EOL] TAG = [number] [EOL] [EOL] [EOL] class SomeEnum ( enum . IntEnum ) : [EOL] foo = [number] [EOL] bar = [number] [EOL] [EOL] [EOL] class Tree ( ADT ) : [EOL] Leaf ( tag = LEAF ) [comment] [EOL] Node ( left = Tree , right = Tree , tag = NODE ) [comment] [EOL] Tag ( val = SomeEnum , tag = TAG ) [comment] [EOL] [EOL] def __repr__ ( self ) : [EOL] if self is Tree . Leaf : [EOL] return [string] [EOL] elif isinstance ( self , Tree . Node ) : [EOL] return f" [string] { self . left } [string] { self . right } [string] " [EOL] elif isinstance ( self , Tree . Tag ) : [EOL] return f" [string] { self . val . value } [string] " [EOL] else : [EOL] assert False , f" [string] { self }" [EOL] [EOL] [EOL] def test_repr ( ) : [EOL] assert repr ( Tree . Leaf ) == [string] [EOL] assert repr ( Tree . Node ( Tree . Leaf , Tree . Leaf ) ) == [string] [EOL] assert repr ( Tree . Tag ( SomeEnum . foo ) ) == [string] [EOL] [EOL] [EOL] def test_serialize ( ) : [EOL] assert Tree . unserialize ( Tree . Leaf . serialize ( ) ) is Tree . Leaf [EOL] assert Tree . unserialize ( Tree . Node ( Tree . Leaf , Tree . Leaf ) . serialize ( ) ) == Tree . Node ( Tree . Leaf , Tree . Leaf ) [EOL] assert Tree . unserialize ( Tree . Tag ( SomeEnum . foo ) . serialize ( ) ) == Tree . Tag ( SomeEnum . foo ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import NoReturn , Mapping [EOL] import typing [EOL] import pathlib [EOL] import configparser [EOL] import mypy_extensions [EOL] import builtins [EOL] import configparser [EOL] import json [EOL] import os [EOL] import socket [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Mapping , NamedTuple [EOL] [EOL] from mypy_extensions import NoReturn [EOL] [EOL] [EOL] class Options ( NamedTuple ) : [EOL] new_path = Path ( ) [EOL] library_path = Path ( ) [EOL] data_path = Path ( ) [EOL] parserdata_path = Path ( ) [EOL] db_filename = Path ( ) [EOL] derived_data_filename = Path ( ) [EOL] [EOL] db_server = [string] [EOL] db_username = [string] [EOL] db_password = [string] [EOL] db_name = [string] [EOL] use_sqlite = True [EOL] [EOL] googlekey = [string] [EOL] googlecus = [string] [EOL] crossrefid = [string] [EOL] [EOL] paleobiodb_cookie = { } [EOL] [EOL] @ property def burst_path ( self ) : [EOL] return self . new_path / [string] [EOL] [EOL] [EOL] def error ( message ) : [EOL] print ( message , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def parse_path ( section , key , base_path , * , required = False ) : [EOL] if key not in section : [EOL] if required : [EOL] error ( f" [string] { key }" ) [EOL] else : [EOL] return base_path [EOL] else : [EOL] raw_path = section [ key ] [EOL] path = Path ( raw_path ) . expanduser ( ) [EOL] if not path . is_absolute ( ) : [EOL] path = base_path / path [EOL] return path [EOL] [EOL] [EOL] def parse_config_file ( filename ) : [EOL] parser = configparser . ConfigParser ( ) [EOL] parser . read ( filename ) [EOL] try : [EOL] section = parser [ [string] ] [EOL] except KeyError : [EOL] error ( f' [string] { filename } [string] ' ) [EOL] else : [EOL] base_path = filename . parent [EOL] db_filename = parse_path ( section , [string] , base_path ) [EOL] [comment] [EOL] if [string] in socket . gethostname ( ) . lower ( ) : [EOL] db_filename = db_filename . parent / [string] [EOL] return Options ( new_path = parse_path ( section , [string] , base_path ) , library_path = parse_path ( section , [string] , base_path , required = True ) , data_path = parse_path ( section , [string] , base_path ) , parserdata_path = parse_path ( section , [string] , base_path ) , derived_data_filename = parse_path ( section , [string] , base_path ) , db_filename = db_filename , db_server = section . get ( [string] , [string] ) , db_username = section . get ( [string] , [string] ) , db_password = section . get ( [string] , [string] ) , db_name = section . get ( [string] , [string] ) , use_sqlite = section . getboolean ( [string] ) , googlekey = section . get ( [string] , [string] ) , googlecus = section . get ( [string] , [string] ) , crossrefid = section . get ( [string] , [string] ) , paleobiodb_cookie = ( json . loads ( section [ [string] ] ) [EOL] if [string] in section [EOL] else { } ) , ) [EOL] [EOL] [EOL] def get_options ( ) : [EOL] if [string] in os . environ : [EOL] config_file = Path ( os . environ [ [string] ] ) [EOL] else : [EOL] config_file = Path ( __file__ ) . parent . parent / [string] [EOL] return parse_config_file ( config_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Mapping[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mypy_extensions.NoReturn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Options$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Options$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Tuple , Iterator , Union , Literal , Mapping , Optional , Sequence , Iterable , TypeVar , Dict , Match , List , Set , Any [EOL] import constants [EOL] import typing [EOL] import taxonomy [EOL] import builtins [EOL] import typing_extensions [EOL] import datetime [EOL] [docstring] [EOL] [EOL] from contextlib import contextmanager [EOL] import datetime [EOL] import json [EOL] import re [EOL] import time [EOL] from typing import Dict , Iterable , Iterator , Mapping , Optional , Sequence , Tuple , TypeVar [EOL] import unicodedata [EOL] [EOL] from . import constants [EOL] from . constants import Group , Rank [EOL] [EOL] SPECIES_RANKS = [ Rank . subspecies , Rank . species , Rank . species_group ] [EOL] GENUS_RANKS = [ Rank . subgenus , Rank . genus ] [EOL] FAMILY_RANKS = [ Rank . infratribe , Rank . subtribe , Rank . tribe , Rank . subfamily , Rank . family , Rank . superfamily , Rank . hyperfamily , ] [EOL] HIGH_RANKS = [ Rank . root , [number] , Rank . division , Rank . parvorder , Rank . infraorder , Rank . suborder , Rank . order , Rank . superorder , Rank . subcohort , Rank . cohort , Rank . supercohort , Rank . infraclass , Rank . subclass , Rank . class_ , Rank . superclass , Rank . infraphylum , Rank . subphylum , Rank . phylum , Rank . superphylum , Rank . infrakingdom , Rank . subkingdom , Rank . kingdom , Rank . superkingdom , Rank . domain , Rank . unranked , ] [EOL] SUFFIXES = { Rank . infratribe : [string] , Rank . subtribe : [string] , Rank . tribe : [string] , Rank . subfamily : [string] , Rank . family : [string] , Rank . superfamily : [string] , Rank . hyperfamily : [string] , } [EOL] VALID_SUFFIXES = set ( SUFFIXES . values ( ) ) [EOL] [EOL] _RANKS = { [string] : Rank . root , [string] : Rank . root , [string] : Rank . class_ , [string] : Rank . class_ , [string] : Rank . subclass , [string] : Rank . subclass , [string] : Rank . infraclass , [string] : Rank . infraclass , [string] : [number] , [string] : [number] , [string] : [number] , [string] : Rank . supercohort , [string] : Rank . supercohort , [string] : Rank . supercohort , [string] : Rank . cohort , [string] : Rank . cohort , [string] : Rank . subcohort , [string] : [number] , [string] : [number] , [string] : Rank . superorder , [string] : Rank . superorder , [string] : Rank . superorder , [string] : [number] , [string] : Rank . order , [string] : Rank . order , [string] : Rank . suborder , [string] : Rank . suborder , [string] : Rank . infraorder , [string] : Rank . infraorder , [string] : Rank . parvorder , [string] : Rank . parvorder , [string] : Rank . superfamily , [string] : Rank . superfamily , [string] : Rank . superfamily , [string] : [number] , [string] : Rank . family , [string] : Rank . family , [string] : Rank . subfamily , [string] : Rank . subfamily , [string] : [number] , [string] : Rank . tribe , [string] : Rank . tribe , [string] : Rank . subtribe , [string] : Rank . subtribe , [string] : Rank . infratribe , [string] : Rank . division , [string] : Rank . genus , [string] : Rank . subgenus , } [EOL] LATLONG = re . compile ( [string] , re . VERBOSE , ) [EOL] [EOL] [EOL] def group_of_rank ( rank ) : [EOL] if rank in SPECIES_RANKS : [EOL] return Group . species [EOL] elif rank in GENUS_RANKS : [EOL] return Group . genus [EOL] elif rank in FAMILY_RANKS or rank == [number] or rank == [number] : [EOL] return Group . family [EOL] elif rank in HIGH_RANKS or rank > Rank . hyperfamily : [EOL] return Group . high [EOL] else : [EOL] raise ValueError ( [string] + str ( rank ) ) [EOL] [EOL] [EOL] def name_with_suffixes_removed ( name ) : [EOL] suffixes = list ( SUFFIXES . values ( ) ) + [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] for suffix in suffixes : [EOL] if name . endswith ( suffix ) : [EOL] yield re . sub ( [string] % suffix , [string] , name ) [EOL] [EOL] [EOL] def suffix_of_rank ( rank ) : [EOL] return SUFFIXES [ rank ] [EOL] [EOL] [EOL] def rank_of_string ( s ) : [EOL] try : [EOL] return _RANKS [ s ] [comment] [EOL] except KeyError : [EOL] raise ValueError ( [string] + s ) [EOL] [EOL] [EOL] def root_name_of_name ( s , rank ) : [EOL] if rank == Rank . species or rank == Rank . subspecies : [EOL] return s . split ( ) [ - [number] ] [EOL] elif group_of_rank ( rank ) == Group . family : [EOL] return strip_rank ( s , rank ) [EOL] else : [EOL] return s [EOL] [EOL] [EOL] def strip_rank ( name , rank , quiet = False ) : [EOL] def strip_of_suffix ( name , suffix ) : [EOL] if re . search ( suffix + [string] , name ) : [EOL] return re . sub ( suffix + [string] , [string] , name ) [EOL] else : [EOL] return None [EOL] [EOL] expected_suffix = suffix_of_rank ( rank ) [EOL] try : [EOL] res = strip_of_suffix ( name , expected_suffix ) [EOL] except KeyError : [EOL] res = None [EOL] if res is None : [EOL] if not quiet : [EOL] print ( f" [string] { expected_suffix } [string] { name }" ) [EOL] for suffix in SUFFIXES . values ( ) : [EOL] res = strip_of_suffix ( name , suffix ) [EOL] if res is not None : [EOL] return res [EOL] return name [EOL] else : [EOL] return res [EOL] [EOL] [EOL] def spg_of_species ( species ) : [EOL] [docstring] [EOL] return re . sub ( [string] , [string] , species ) [EOL] [EOL] [EOL] def species_of_subspecies ( ssp ) : [EOL] return re . sub ( [string] , [string] , ssp ) [EOL] [EOL] [EOL] def is_nominate_subspecies ( ssp ) : [EOL] parts = re . sub ( [string] , [string] , ssp ) . split ( [string] ) [EOL] if len ( parts ) != [number] : [EOL] print ( parts ) [EOL] raise Exception ( [string] + ssp ) [EOL] return parts [ [number] ] == parts [ [number] ] [EOL] [EOL] [EOL] def genus_name_of_name ( name ) : [EOL] if name . lower ( ) . startswith ( [string] ) : [EOL] return name . split ( ) [ [number] ] [EOL] return name . split ( ) [ [number] ] . replace ( [string] , [string] ) [EOL] [EOL] [EOL] _T1 = TypeVar ( [string] ) [EOL] _T2 = TypeVar ( [string] ) [EOL] [EOL] [EOL] def remove_null ( d ) : [EOL] out = { } [EOL] for k , v in d . items ( ) : [EOL] if v is not None : [EOL] out [ k ] = v [EOL] return out [EOL] [EOL] [EOL] def fix_data ( data ) : [EOL] if data : [EOL] data = json . dumps ( remove_null ( json . loads ( data ) ) ) [EOL] if data == [string] : [EOL] return None [EOL] else : [EOL] return data [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def convert_gender ( name , gender ) : [EOL] name = _canonicalize_gender ( name ) [EOL] if gender == constants . GrammaticalGender . masculine : [EOL] return name [EOL] elif gender == constants . GrammaticalGender . feminine : [EOL] [comment] [EOL] if name . endswith ( [string] ) : [EOL] return re . sub ( [string] , [string] , name ) [EOL] elif name . endswith ( [string] ) : [EOL] return name + [string] [EOL] else : [EOL] return name [EOL] elif gender == constants . GrammaticalGender . neuter : [EOL] [comment] [EOL] if name . endswith ( [string] ) : [EOL] return re . sub ( [string] , [string] , name ) [EOL] elif name . endswith ( [string] ) : [EOL] return re . sub ( [string] , [string] , name ) [EOL] else : [EOL] return name [EOL] else : [EOL] raise ValueError ( f" [string] { gender }" ) [EOL] [EOL] [EOL] def _canonicalize_gender ( name ) : [EOL] if name . endswith ( [string] ) : [EOL] return re . sub ( [string] , [string] , name ) [EOL] elif name . endswith ( [string] ) : [EOL] return name [ : - [number] ] [EOL] elif name . endswith ( [string] ) : [EOL] [comment] [EOL] return re . sub ( [string] , [string] , name ) [EOL] elif name . endswith ( [string] ) : [EOL] [comment] [EOL] return re . sub ( [string] , [string] , name ) [EOL] else : [EOL] return name [EOL] [EOL] [EOL] def standardize_date ( date ) : [EOL] [docstring] [EOL] if date in ( [string] , [string] , [string] ) : [EOL] return None [EOL] date = re . sub ( [string] , [string] , date ) [EOL] date = re . sub ( [string] , [string] , date ) [EOL] date = re . sub ( [string] , [string] , date , ) [EOL] if re . match ( [string] , date ) : [EOL] [comment] [EOL] return date [EOL] match = re . match ( [string] , date ) [EOL] if match : [EOL] return match . group ( [number] ) [EOL] date_month_formats = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] for fmt in date_month_formats : [EOL] try : [EOL] dt = datetime . datetime . strptime ( date , fmt ) [EOL] except ValueError : [EOL] pass [EOL] else : [EOL] return dt . strftime ( [string] ) [EOL] dmy_formats = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] for fmt in dmy_formats : [EOL] try : [EOL] dt = datetime . datetime . strptime ( date , fmt ) [EOL] except ValueError : [EOL] pass [EOL] else : [EOL] return dt . strftime ( [string] ) [EOL] raise ValueError ( date ) [EOL] [EOL] [EOL] COORDINATE_RGX = re . compile ( [string] , re . VERBOSE , ) [EOL] [EOL] [EOL] class InvalidCoordinates ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def standardize_coordinates ( text , * , is_latitude ) : [EOL] text = re . sub ( [string] , [string] , text ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = re . sub ( [string] , [string] , text ) [EOL] text = re . sub ( [string] , [string] , text ) [EOL] text = re . sub ( [string] , [string] , text ) [EOL] [EOL] match = COORDINATE_RGX . match ( text ) [EOL] if not match : [EOL] raise InvalidCoordinates ( f" [string] { text !r}" ) [EOL] [EOL] degrees = match . group ( [string] ) [EOL] minutes = match . group ( [string] ) [EOL] seconds = match . group ( [string] ) [EOL] direction = match . group ( [string] ) [EOL] [EOL] if [string] in degrees and minutes : [EOL] raise InvalidCoordinates ( [string] ) [EOL] if float ( degrees ) > ( [number] if is_latitude else [number] ) : [EOL] raise InvalidCoordinates ( f" [string] { degrees }" ) [EOL] [EOL] if minutes : [EOL] if [string] in minutes and seconds : [EOL] raise InvalidCoordinates ( [string] ) [EOL] if float ( minutes ) > [number] : [EOL] raise InvalidCoordinates ( f" [string] { minutes }" ) [EOL] [EOL] if seconds : [EOL] if float ( seconds ) > [number] : [EOL] raise InvalidCoordinates ( f" [string] { seconds }" ) [EOL] [EOL] if is_latitude : [EOL] if direction not in ( [string] , [string] ) : [EOL] raise InvalidCoordinates ( f" [string] { direction }" ) [EOL] else : [EOL] if direction not in ( [string] , [string] ) : [EOL] raise InvalidCoordinates ( f" [string] { direction }" ) [EOL] return text [EOL] [EOL] [EOL] def extract_coordinates ( text ) : [EOL] [docstring] [EOL] match = LATLONG . search ( text ) [EOL] if match : [EOL] try : [EOL] latitude = standardize_coordinates ( match . group ( [string] ) , is_latitude = True ) [EOL] except InvalidCoordinates : [EOL] return None [EOL] try : [EOL] longitude = standardize_coordinates ( match . group ( [string] ) , is_latitude = False ) [EOL] except InvalidCoordinates : [EOL] return None [EOL] return latitude , longitude [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def clean_text ( text ) : [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = re . sub ( [string] , [string] , text ) [EOL] text = re . sub ( [string] , [string] , text ) [EOL] return text [EOL] [EOL] [EOL] def unsplit_authors ( authors ) : [EOL] if len ( authors ) > [number] : [EOL] return [string] . join ( [ [string] . join ( authors [ : - [number] ] ) , authors [ - [number] ] ] ) [EOL] else : [EOL] return authors [ [number] ] [EOL] [EOL] [EOL] class TimeHolder : [EOL] def __init__ ( self , label ) : [EOL] self . label = label [EOL] self . time = [number] [EOL] [EOL] [EOL] @ contextmanager def timer ( label ) : [EOL] th = TimeHolder ( label ) [EOL] start_time = time . time ( ) [EOL] try : [EOL] yield th [EOL] finally : [EOL] end_time = time . time ( ) [EOL] taken = end_time - start_time [EOL] print ( f"{ label } [string] { taken : [string] } [string] " ) [EOL] th . time = taken [EOL] [EOL] [EOL] TABLE = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] NEED_Y = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] [EOL] def romanize_russian ( cyrillic ) : [EOL] [docstring] [EOL] out = [ ] [EOL] for i , c in enumerate ( cyrillic ) : [EOL] is_upper = c . isupper ( ) [EOL] c = c . lower ( ) [EOL] if c in TABLE : [EOL] new_c = TABLE [ c ] [EOL] elif c in ( [string] , [string] ) : [EOL] vowel = [string] if c == [string] else [string] [EOL] if i == [number] or cyrillic [ i - [number] ] in NEED_Y : [EOL] new_c = f" [string] { vowel }" [EOL] else : [EOL] new_c = vowel [EOL] else : [EOL] new_c = c [EOL] if is_upper : [EOL] new_c = f"{ new_c [ [number] ] . upper ( ) }{ new_c [ [number] : ] }" [EOL] out . append ( new_c ) [EOL] return [string] . join ( out ) [EOL] [EOL] [EOL] def extract_sources ( text ) : [EOL] for source in re . findall ( [string] , text ) : [EOL] yield source [ [number] : - [number] ] [EOL] [EOL] [EOL] def _clean_up_word ( word ) : [EOL] if word in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] return [string] [EOL] return word . rstrip ( [string] ) [EOL] [EOL] [EOL] def simplify_string ( text ) : [EOL] text = re . sub ( [string] , [string] , text ) [EOL] text = clean_string ( text ) . lower ( ) [EOL] text = [string] . join ( _clean_up_word ( word ) for word in text . split ( ) ) [EOL] return text [EOL] [EOL] [EOL] def clean_string ( text ) : [EOL] text = unicodedata . normalize ( [string] , text ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = text . replace ( [string] , [string] ) [EOL] text = re . sub ( [string] , [string] , text ) [EOL] text = re . sub ( [string] , [string] , text ) [EOL] text = re . sub ( [string] , [string] , text ) [EOL] return text . strip ( ) [EOL] [EOL] [EOL] def to_int ( string ) : [EOL] [docstring] [EOL] if string is None : [EOL] return [number] [EOL] match = re . match ( [string] , string ) [EOL] if match : [EOL] return int ( match . group ( [number] ) ) [EOL] else : [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import typing [EOL] import taxonomy [EOL] import itertools [EOL] [EOL] from . constants import NomenclatureStatus [EOL] [EOL] [EOL] def test_hierarchy ( ) : [EOL] all_statuses = set ( NomenclatureStatus ) [EOL] in_hierarchy = set ( itertools . chain . from_iterable ( NomenclatureStatus . hierarchy ( ) ) ) [EOL] difference = all_statuses - in_hierarchy [EOL] assert ( not difference ) , f'{ [string] . join ( v . name for v in difference ) } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Set , List [EOL] import typing [EOL] import taxonomy [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import enum [EOL] from typing import List [EOL] [EOL] [EOL] class RequirednessLevel ( enum . IntEnum ) : [EOL] required = [number] [EOL] optional = [number] [EOL] disallowed = [number] [EOL] [EOL] [EOL] class GrammaticalGender ( enum . IntEnum ) : [EOL] masculine = [number] [EOL] feminine = [number] [EOL] neuter = [number] [EOL] [EOL] [EOL] class AgeClass ( enum . IntEnum ) : [EOL] extant = [number] [EOL] holocene = [number] [EOL] fossil = [number] [EOL] ichno = [number] [EOL] removed = [number] [comment] [EOL] track = [number] [EOL] egg = [number] [EOL] coprolite = [number] [EOL] burrow = [number] [EOL] bite_trace = [number] [EOL] [EOL] def get_symbol ( self ) : [EOL] return { self . extant : [string] , self . holocene : [string] , self . fossil : [string] , self . ichno : [string] , self . removed : [string] , self . track : [string] , self . egg : [string] , self . coprolite : [string] , self . burrow : [string] , self . bite_trace : [string] , } [ self ] [EOL] [EOL] [EOL] class Status ( enum . IntEnum ) : [EOL] valid = [number] [EOL] synonym = [number] [EOL] [comment] [EOL] dubious = [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] nomen_dubium = [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] species_inquirenda = [number] [EOL] [comment] [EOL] [comment] [EOL] spurious = [number] [EOL] [comment] [EOL] removed = [number] [EOL] [EOL] [EOL] class NomenclatureStatus ( enum . IntEnum ) : [EOL] available = [number] [EOL] nomen_nudum = [number] [comment] [EOL] fully_suppressed = [number] [comment] [EOL] not_based_on_a_generic_name = [number] [comment] [EOL] infrasubspecific = [number] [comment] [EOL] unpublished = [number] [comment] [EOL] incorrect_subsequent_spelling = [number] [EOL] unjustified_emendation = [number] [comment] [EOL] before_1758 = [number] [comment] [EOL] hypothetical_concept = [number] [comment] [EOL] teratological = [number] [comment] [EOL] hybrid_as_such = [number] [comment] [EOL] informal = [number] [comment] [EOL] [comment] [EOL] work_of_extant = [number] [EOL] zoological_formula = [number] [comment] [EOL] [comment] [EOL] unlisted = [number] [EOL] not_latin_alphabet = [number] [comment] [EOL] [comment] [EOL] inconsistently_binominal = [number] [EOL] not_used_as_valid = [number] [comment] [EOL] not_used_as_genus_plural = [number] [comment] [EOL] based_on_a_suppressed_name = [number] [comment] [EOL] not_published_with_a_generic_name = [number] [comment] [EOL] multiple_words = [number] [comment] [EOL] [comment] [EOL] no_type_specified = [number] [EOL] [comment] [EOL] anonymous_authorship = [number] [EOL] conditional = [number] [comment] [EOL] [comment] [EOL] variety_or_form = [number] [EOL] [comment] [EOL] not_explicitly_new = [number] [EOL] [comment] [EOL] mandatory_change = [number] [EOL] [comment] [EOL] ites_name = [number] [EOL] [comment] [EOL] hybrid_name = [number] [EOL] [comment] [EOL] art_13_nomen_oblitum = [number] [EOL] variant = [number] [comment] [EOL] justified_emendation = [number] [comment] [EOL] preoccupied = [number] [comment] [EOL] [comment] [EOL] based_on_homonym = [number] [EOL] partially_suppressed = [number] [comment] [EOL] [comment] [EOL] nomen_novum = [number] [EOL] [comment] [EOL] incorrect_original_spelling = [number] [EOL] type_not_treated_as_valid = [number] [comment] [EOL] [comment] [EOL] reranking = [number] [EOL] [comment] [EOL] subsequent_usage = [number] [EOL] not_intended_as_a_scientific_name = [number] [comment] [EOL] collective_group = [number] [EOL] [comment] [EOL] not_nominative_singular = [number] [EOL] [comment] [EOL] as_emended = [number] [EOL] [EOL] def requires_type ( self ) : [EOL] [docstring] [EOL] return self in REQUIRES_TYPE [EOL] [EOL] def can_preoccupy ( self ) : [EOL] [docstring] [EOL] return self in { NomenclatureStatus . available , NomenclatureStatus . unjustified_emendation , NomenclatureStatus . hybrid_name , NomenclatureStatus . variant , NomenclatureStatus . justified_emendation , NomenclatureStatus . preoccupied , NomenclatureStatus . partially_suppressed , NomenclatureStatus . nomen_novum , NomenclatureStatus . as_emended , } [EOL] [EOL] def requires_name_complex ( self ) : [EOL] return self not in { NomenclatureStatus . nomen_nudum , NomenclatureStatus . incorrect_subsequent_spelling , NomenclatureStatus . incorrect_original_spelling , NomenclatureStatus . inconsistently_binominal , NomenclatureStatus . not_latin_alphabet , NomenclatureStatus . not_intended_as_a_scientific_name , NomenclatureStatus . zoological_formula , NomenclatureStatus . informal , NomenclatureStatus . subsequent_usage , NomenclatureStatus . not_nominative_singular , NomenclatureStatus . before_1758 , NomenclatureStatus . not_used_as_valid , NomenclatureStatus . not_published_with_a_generic_name , } [EOL] [EOL] def permissive_corrected_original_name ( self ) : [EOL] [docstring] [EOL] return self in { NomenclatureStatus . not_published_with_a_generic_name , NomenclatureStatus . informal , NomenclatureStatus . not_intended_as_a_scientific_name , NomenclatureStatus . not_nominative_singular , } [EOL] [EOL] @ classmethod def hierarchy ( cls ) : [EOL] [docstring] [EOL] return [ [ cls . fully_suppressed , cls . partially_suppressed ] , [ cls . unlisted ] , [ cls . unpublished , cls . before_1758 , cls . inconsistently_binominal ] , [ cls . not_based_on_a_generic_name , cls . infrasubspecific , cls . hypothetical_concept , cls . teratological , cls . hybrid_as_such , cls . informal , cls . work_of_extant , cls . zoological_formula , cls . not_latin_alphabet , cls . not_used_as_valid , cls . not_used_as_genus_plural , cls . not_published_with_a_generic_name , cls . multiple_words , cls . no_type_specified , cls . anonymous_authorship , cls . conditional , cls . variety_or_form , cls . not_explicitly_new , cls . ites_name , cls . based_on_homonym , cls . based_on_a_suppressed_name , cls . type_not_treated_as_valid , cls . subsequent_usage , cls . not_intended_as_a_scientific_name , cls . not_nominative_singular , ] , [ cls . incorrect_subsequent_spelling , cls . incorrect_original_spelling ] , [ cls . nomen_nudum ] , [ cls . unjustified_emendation , cls . justified_emendation , cls . mandatory_change , cls . art_13_nomen_oblitum , cls . reranking , ] , [ cls . variant ] , [ cls . hybrid_name ] , [ cls . nomen_novum ] , [ cls . collective_group ] , [ cls . as_emended ] , [ cls . preoccupied ] , [ cls . available ] , ] [EOL] [EOL] [EOL] REQUIRES_TYPE = { NomenclatureStatus . available , NomenclatureStatus . hybrid_name , NomenclatureStatus . art_13_nomen_oblitum , NomenclatureStatus . preoccupied , NomenclatureStatus . reranking , NomenclatureStatus . as_emended , } [EOL] [EOL] [EOL] class EmendationJustification ( enum . IntEnum ) : [EOL] [comment] [EOL] inadvertent_error = [number] [EOL] [comment] [EOL] removal_of_mark = [number] [EOL] [comment] [EOL] incorrect_family_group_name = [number] [EOL] [comment] [EOL] prevailing_usage = [number] [EOL] [comment] [EOL] conserved_by_the_commission = [number] [EOL] [EOL] [EOL] class Group ( enum . IntEnum ) : [EOL] species = [number] [EOL] genus = [number] [EOL] family = [number] [EOL] high = [number] [EOL] [EOL] [EOL] class Rank ( enum . IntEnum ) : [EOL] subspecies = [number] [EOL] species = [number] [EOL] species_group = [number] [EOL] subgenus = [number] [EOL] genus = [number] [EOL] division = [number] [EOL] infratribe = [number] [EOL] subtribe = [number] [EOL] tribe = [number] [EOL] subfamily = [number] [EOL] family = [number] [EOL] superfamily = [number] [EOL] hyperfamily = [number] [EOL] parvorder = [number] [EOL] infraorder = [number] [EOL] suborder = [number] [EOL] order = [number] [EOL] superorder = [number] [EOL] subcohort = [number] [EOL] cohort = [number] [EOL] supercohort = [number] [EOL] infraclass = [number] [EOL] subclass = [number] [EOL] class_ = [number] [EOL] superclass = [number] [EOL] infraphylum = [number] [EOL] subphylum = [number] [EOL] phylum = [number] [EOL] superphylum = [number] [EOL] infrakingdom = [number] [EOL] subkingdom = [number] [EOL] kingdom = [number] [EOL] superkingdom = [number] [EOL] domain = [number] [EOL] root = [number] [EOL] unranked = [number] [EOL] informal = [number] [EOL] [EOL] [EOL] class RegionKind ( enum . IntEnum ) : [EOL] continent = [number] [EOL] country = [number] [EOL] subnational = [number] [comment] [EOL] planet = [number] [EOL] other = [number] [EOL] county = [number] [EOL] [EOL] [EOL] class PeriodSystem ( enum . IntEnum ) : [EOL] gts = [number] [comment] [EOL] nalma = [number] [comment] [EOL] elma = [number] [comment] [EOL] alma = [number] [comment] [EOL] salma = [number] [comment] [EOL] lithostratigraphy = [number] [comment] [EOL] aulma = [number] [comment] [EOL] local_biostratigraphy = [number] [comment] [EOL] [EOL] [EOL] class PeriodRank ( enum . IntEnum ) : [EOL] age = [number] [EOL] epoch = [number] [EOL] period = [number] [EOL] era = [number] [EOL] eon = [number] [EOL] bed = [number] [EOL] member = [number] [EOL] formation = [number] [EOL] group = [number] [EOL] supergroup = [number] [EOL] other_lithostratigraphy = [number] [EOL] other_chronostratigraphy = [number] [EOL] subage = [number] [comment] [EOL] biozone = [number] [comment] [EOL] subgroup = [number] [EOL] zonation = [number] [comment] [EOL] [EOL] [EOL] SYSTEM_TO_ALLOWED_RANKS = { PeriodSystem . gts : { PeriodRank . age , PeriodRank . epoch , PeriodRank . period , PeriodRank . era , PeriodRank . eon , PeriodRank . other_chronostratigraphy , } , PeriodSystem . nalma : { PeriodRank . age , PeriodRank . subage , PeriodRank . biozone } , PeriodSystem . elma : { PeriodRank . age , PeriodRank . biozone } , PeriodSystem . alma : { PeriodRank . age , PeriodRank . subage } , PeriodSystem . salma : { PeriodRank . age , PeriodRank . subage } , PeriodSystem . aulma : { PeriodRank . age } , PeriodSystem . lithostratigraphy : { PeriodRank . bed , PeriodRank . member , PeriodRank . formation , PeriodRank . subgroup , PeriodRank . group , PeriodRank . supergroup , PeriodRank . other_lithostratigraphy , } , PeriodSystem . local_biostratigraphy : { PeriodRank . zonation , PeriodRank . age , PeriodRank . subage , PeriodRank . biozone , } , } [EOL] [EOL] [EOL] class OccurrenceStatus ( enum . IntEnum ) : [EOL] valid = [number] [EOL] rejected = [number] [comment] [EOL] occurrence_dubious = [number] [comment] [EOL] introduced = [number] [comment] [EOL] extirpated = [number] [comment] [EOL] vagrant = [number] [comment] [EOL] classification_dubious = [number] [comment] [EOL] [EOL] [EOL] class SourceLanguage ( enum . IntEnum ) : [EOL] latin = [number] [EOL] greek = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] other = [number] [EOL] [EOL] english = [number] [EOL] french = [number] [EOL] german = [number] [EOL] spanish = [number] [EOL] portuguese = [number] [EOL] russian = [number] [EOL] arabic = [number] [EOL] chinese = [number] [EOL] mongolian = [number] [EOL] [EOL] [EOL] class GenderArticle ( enum . IntEnum ) : [EOL] art30_1_1 = [number] [comment] [EOL] art30_1_2 = [number] [comment] [EOL] art30_1_3 = [number] [comment] [EOL] art30_1_4_2 = [number] [comment] [EOL] art30_1_4_3 = [number] [comment] [EOL] art30_1_4_4 = [number] [comment] [EOL] art30_1_4_5 = [number] [comment] [EOL] art30_2_1 = [number] [comment] [EOL] art30_2_2 = [number] [comment] [EOL] art30_2_3 = [number] [comment] [EOL] art30_2_4 = [number] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] bad_transliteration = [number] [EOL] [comment] [EOL] unknown_obvious_stem = [number] [EOL] [comment] [EOL] [comment] [EOL] stem_expressly_set = [number] [EOL] [EOL] [EOL] class SpeciesNameKind ( enum . IntEnum ) : [EOL] adjective = [number] [comment] [EOL] noun_in_apposition = [number] [comment] [EOL] genitive = [number] [comment] [EOL] [comment] [EOL] genitive_adjective = [number] [EOL] non_latin = [number] [comment] [EOL] ambiguous_noun = [number] [comment] [EOL] [EOL] [comment] [EOL] patronym_masculine = [number] [comment] [EOL] patronym_feminine = [number] [comment] [EOL] patronym_masculine_plural = [number] [comment] [EOL] patronym_feminine_plural = [number] [comment] [EOL] patronym_latin = [number] [comment] [EOL] [EOL] [comment] [EOL] unknown = [number] [EOL] [EOL] def is_single_complex ( self ) : [EOL] return self not in { SpeciesNameKind . adjective , SpeciesNameKind . ambiguous_noun } [EOL] [EOL] [EOL] class TypeSpeciesDesignation ( enum . IntEnum ) : [EOL] [comment] [EOL] [EOL] [comment] [EOL] original_designation = [number] [EOL] monotypy = [number] [comment] [EOL] absolute_tautonymy = [number] [comment] [EOL] linnaean_tautonymy = [number] [comment] [EOL] subsequent_monotypy = [number] [comment] [EOL] subsequent_designation = [number] [comment] [EOL] [comment] [EOL] implicit = [number] [EOL] [comment] [EOL] misidentification = [number] [EOL] designated_by_the_commission = [number] [comment] [EOL] undesignated = [number] [comment] [EOL] [EOL] def requires_tag ( self ) : [EOL] return self in { TypeSpeciesDesignation . subsequent_designation , TypeSpeciesDesignation . designated_by_the_commission , TypeSpeciesDesignation . undesignated , } [EOL] [EOL] [EOL] class SpeciesGroupType ( enum . IntEnum ) : [EOL] holotype = [number] [EOL] lectotype = [number] [EOL] neotype = [number] [EOL] syntypes = [number] [EOL] [comment] [EOL] nonexistent = [number] [EOL] [EOL] [EOL] class SpecimenGender ( enum . IntEnum ) : [EOL] male = [number] [EOL] female = [number] [EOL] hermaphrodite = [number] [EOL] unknown = [number] [EOL] [EOL] [EOL] class SpecimenAge ( enum . IntEnum ) : [EOL] embryo = [number] [EOL] juvenile = [number] [EOL] subadult = [number] [EOL] adult = [number] [EOL] larva = [number] [EOL] [EOL] [EOL] class SpecimenOrgan ( enum . IntEnum ) : [EOL] [comment] [EOL] skin = [number] [EOL] skull = [number] [EOL] postcranial_skeleton = [number] [EOL] mandible = [number] [EOL] tooth = [number] [EOL] in_alcohol = [number] [EOL] other = [number] [EOL] maxilla = [number] [EOL] [EOL] [EOL] class AltitudeUnit ( enum . IntEnum ) : [EOL] m = [number] [EOL] ft = [number] [EOL] [EOL] [EOL] class CommentKind ( enum . IntEnum ) : [EOL] taxonomy = [number] [EOL] nomenclature = [number] [EOL] type_locality = [number] [EOL] type_specimen = [number] [EOL] availability = [number] [EOL] distribution = [number] [EOL] etymology = [number] [EOL] other = [number] [EOL] structured_quote = [number] [EOL] type_species = [number] [EOL] homonymy = [number] [EOL] spelling = [number] [EOL] authorship = [number] [EOL] automatic_change = [number] [EOL] removal = [number] [EOL] contents = [number] [EOL] definition = [number] [EOL] removed = [number] [EOL] [EOL] [EOL] class ArticleType ( enum . IntEnum ) : [EOL] ERROR = [number] [EOL] CHAPTER = [number] [EOL] BOOK = [number] [EOL] THESIS = [number] [comment] [EOL] WEB = [number] [EOL] MISCELLANEOUS = [number] [EOL] SUPPLEMENT = [number] [comment] [EOL] JOURNAL = [number] [EOL] REDIRECT = [number] [EOL] [EOL] [EOL] class ArticleKind ( enum . IntEnum ) : [EOL] electronic = [number] [comment] [EOL] physical = [number] [comment] [EOL] no_copy = [number] [comment] [EOL] part = [number] [comment] [EOL] redirect = [number] [comment] [EOL] removed = [number] [comment] [EOL] reference = [number] [comment] [EOL] [EOL] [EOL] class ArticleCommentKind ( enum . IntEnum ) : [EOL] dating = [number] [EOL] contents = [number] [EOL] authorship = [number] [EOL] location = [number] [comment] [EOL] other = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Union , Optional , Type , List , Callable [EOL] import constants [EOL] import typing [EOL] import taxonomy [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import collections [EOL] import re [EOL] from typing import Callable , List , Optional , Tuple , Union [EOL] [EOL] from . constants import GrammaticalGender [EOL] [EOL] detection_result = collections . namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def _rep ( pattern , replacement ) : [EOL] return lambda name : re . sub ( [string] % pattern , replacement , name ) [EOL] [EOL] [EOL] _endings = [ ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True , ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True , ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True , ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True , ) , ( [string] , lambda n : n + [string] , GrammaticalGender . masculine , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . masculine , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . masculine , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . masculine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True , ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True , ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True , ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . feminine , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , [string] , GrammaticalGender . feminine , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . neuter , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . neuter , True ) , ( [string] , _rep ( [string] , [string] ) , GrammaticalGender . neuter , True ) , ( [string] , [string] , GrammaticalGender . neuter , True ) , ( [string] , [string] , GrammaticalGender . neuter , True ) , ( [string] , [string] , GrammaticalGender . neuter , True ) , ( [string] , [string] , GrammaticalGender . neuter , True ) , ( [string] , [string] , GrammaticalGender . neuter , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . neuter , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . neuter , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . neuter , True ) , ( [string] , [string] , GrammaticalGender . neuter , True ) , ( [string] , [string] , GrammaticalGender . neuter , True ) , ( [string] , lambda n : n + [string] , GrammaticalGender . neuter , True ) , ( [string] , [string] , GrammaticalGender . neuter , True ) , ( [string] , [string] , GrammaticalGender . neuter , True ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def _remove_ending ( name , end ) : [EOL] assert name . endswith ( end ) [EOL] return re . sub ( [string] % end , [string] , name ) [EOL] [EOL] [EOL] def detect_stem_and_gender ( name ) : [EOL] for ending , to_stem , gender , confidence in _endings : [EOL] if name . lower ( ) . endswith ( ending ) : [EOL] if callable ( to_stem ) : [EOL] stem = to_stem ( name ) [EOL] else : [EOL] stem = _remove_ending ( name , to_stem ) [EOL] return detection_result ( stem , gender , confidence ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[taxonomy.db.detection.detection_result]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.str,typing.Callable[[builtins.str],builtins.str]],constants.GrammaticalGender,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[detection_result]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.str,typing.Callable[[builtins.str],builtins.str]],constants.GrammaticalGender,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[taxonomy.db.detection.detection_result]$ 0 0 0 0 0 0 0 0 0 0 0
	0