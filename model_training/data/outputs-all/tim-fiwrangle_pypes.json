from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from typing import Iterable , Callable , Sequence , Dict , Mapping , List , TypeVar , Optional , Tuple , Any [EOL] import builtins [EOL] import typing [EOL] import pipeline [EOL] from __future__ import annotations [EOL] from dataclasses import dataclass , field [EOL] from typing import ( Type , Optional , Union , TypeVar , overload , Generic , Mapping , Sequence , Callable , Any , List , Iterable , Dict , Tuple , ) [EOL] [EOL] from . pipeline import Transformation , Pipeline [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] K = TypeVar ( [string] ) [EOL] V = TypeVar ( [string] ) [EOL] [EOL] [EOL] @ dataclass class Id ( Transformation , Generic [ V ] ) : [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return data [EOL] [EOL] [EOL] @ dataclass class Constant ( Transformation , Generic [ V ] ) : [EOL] value = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return self . value [EOL] [EOL] [EOL] @ dataclass class Cast ( Transformation , Generic [ K , V ] ) : [EOL] func = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return self . func ( data ) [comment] [EOL] [EOL] [EOL] @ dataclass class Custom ( Transformation , Generic [ K , V ] ) : [EOL] func = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return self . func ( pipeline , data , args , kwargs ) [comment] [EOL] [EOL] [EOL] @ dataclass class Default ( Transformation , Generic [ V , K ] ) : [EOL] value = ... [EOL] cond = bool [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return data if self . cond ( data ) else self . value [comment] [EOL] [EOL] [EOL] @ dataclass class Get ( Transformation , Generic [ K ] ) : [EOL] key = ... [EOL] default = None [EOL] [EOL] @ overload def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] @ overload def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] try : [EOL] return data [ self . key ] [EOL] except ( IndexError , KeyError ) : [EOL] if self . default is not None : [EOL] return self . default [EOL] raise [EOL] [EOL] [EOL] @ dataclass class Attr ( Transformation ) : [EOL] attr = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return getattr ( data , self . attr ) [EOL] [EOL] [EOL] @ dataclass class Filter ( Transformation , Generic [ V ] ) : [EOL] func = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return [ val for val in data if self . func ( data ) ] [comment] [EOL] [EOL] [EOL] @ dataclass class Map ( Transformation , Generic [ K , V ] ) : [EOL] func = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return [ self . func ( val ) for val in data ] [comment] [EOL] [EOL] [EOL] @ dataclass class ForEach ( Transformation ) : [EOL] transformation = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return [ self . transformation ( pipeline , datapoint , * args , ** kwargs ) for datapoint in data ] [EOL] [EOL] [EOL] @ dataclass class Flatten ( Transformation ) : [EOL] depth = [number] [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] result = data [EOL] for _ in range ( self . depth ) : [EOL] result = sum ( result , [ ] ) [EOL] return result [comment] [EOL] [EOL] [EOL] @ dataclass class Gather ( Transformation , Generic [ K ] ) : [EOL] keys = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return { key : data [ key ] for key in self . keys } [EOL] [EOL] [EOL] @ dataclass class FoldInKeys ( Transformation ) : [EOL] name = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return [ { self . name : key , ** datapoint } for key , datapoint in data . items ( ) ] [EOL] [EOL] [EOL] @ dataclass class FoldInValue ( Transformation ) : [EOL] key = ... [EOL] name = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return { key : { self . name : data [ self . key ] , ** datapoint } for key , datapoint in data . items ( ) if key != self . key } [EOL] [EOL] [EOL] @ dataclass class GetKeys ( Transformation ) : [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return list ( data . keys ( ) ) [EOL] [EOL] [EOL] @ dataclass class GetValues ( Transformation ) : [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return list ( data . values ( ) ) [EOL] [EOL] [EOL] @ dataclass class If ( Transformation , Generic [ V ] ) : [EOL] cond = ... [EOL] then = ... [EOL] else_ = None [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] if self . cond ( data ) : [comment] [EOL] return self . then ( pipeline , data , * args , ** kwargs ) [EOL] elif self . else_ is not None : [EOL] return self . else_ ( pipeline , data , * args , ** kwargs ) [EOL] else : [EOL] return None [EOL] [EOL] [EOL] @ dataclass class Create ( Transformation , Generic [ V ] ) : [EOL] model = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return pipeline . create ( self . model , data , * args , ** kwargs ) [EOL] [EOL] [EOL] @ dataclass class CreateMultiple ( Transformation , Generic [ V ] ) : [EOL] model = ... [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return list ( pipeline . create_multiple ( self . model , data , * args , ** kwargs ) ) [EOL] [EOL] [EOL] @ dataclass class GetOrCreate ( Transformation , Generic [ V ] ) : [EOL] model = ... [EOL] match_targets = None [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return pipeline . get_or_create ( self . model , data , * args , match_targets = self . match_targets , ** kwargs ) [EOL] [EOL] [EOL] @ dataclass class GetOrCreateMultiple ( Transformation , Generic [ V ] ) : [EOL] model = ... [EOL] match_targets = None [EOL] [EOL] def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return list ( pipeline . get_or_create_multiple ( self . model , data , * args , match_targets = self . match_targets , ** kwargs ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 $pipeline.Pipeline$ 0 $V$ 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 0 0 $V$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[K],V]$ 0 0 0 0 0 $V$ 0 0 0 $pipeline.Pipeline$ 0 $K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[pipeline.Pipeline,K,typing.Tuple,typing.Dict],V]$ 0 0 0 0 0 $V$ 0 0 0 $pipeline.Pipeline$ 0 $K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 $K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 $typing.Callable[[K],builtins.bool]$ 0 0 0 0 0 $V$ 0 0 0 $pipeline.Pipeline$ 0 $K$ 0 0 0 0 0 0 0 0 0 0 $K$ 0 0 0 0 0 $K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $K$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[V],builtins.bool]$ 0 0 0 0 0 $typing.List[V]$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Iterable[V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[V]$ 0 0 0 0 0 $typing.Iterable[V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[V],K]$ 0 0 0 0 0 $typing.List[K]$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Iterable[V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.Transformation$ 0 0 0 0 0 $typing.List$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Sequence[typing.Sequence]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Sequence[typing.Sequence]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[K]$ 0 0 0 0 0 $typing.Dict[K,V]$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Mapping]$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Mapping[typing.Any,typing.Mapping]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Mapping]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Mapping$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[K]$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[V]$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[V],builtins.bool]$ 0 0 0 $pipeline.Transformation$ 0 0 0 $typing.Optional[pipeline.Transformation]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $pipeline.Pipeline$ 0 $V$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 $V$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 $V$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[V]$ 0 0 0 0 0 $V$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[V]$ 0 0 0 0 0 $typing.List[V]$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[V]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.Tuple[V,builtins.bool]$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[V]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.List[typing.Tuple[V,builtins.bool]]$ 0 0 0 $pipeline.Pipeline$ 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.Pipeline$ 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Callable , Sequence , Dict , Iterator , List , Type , TypeVar , Optional , Awaitable , Any [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] from dataclasses import dataclass , field , fields [EOL] from typing import ( Dict , Type , Generic , TypeVar , Any , Sequence , Iterator , List , Tuple , Optional , Callable , Awaitable , ) [EOL] [EOL] from wrangle_pypes . pipeline import TransformationException , Transformation , Chain [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] M = TypeVar ( [string] , covariant = True ) [EOL] [EOL] [EOL] @ dataclass class AsyncPipeline ( Generic [ M ] ) : [EOL] transformations = field ( default_factory = dict ) [EOL] lookup = None [EOL] [EOL] async def create ( self , model , data , * args , ** kwargs ) : [EOL] [docstring] [EOL] return await model ( ** self . build_kwargs ( model , data , * args , ** kwargs ) ) [EOL] [EOL] async def create_multiple ( self , model , data , * args , ** kwargs ) : [EOL] [docstring] [EOL] return ( await self . create ( model , datapoint , * args , ** kwargs ) for datapoint in data ) [EOL] [EOL] async def get_or_create ( self , model , data , match_targets , * args , lookup = None , ** kwargs , ) : [EOL] [docstring] [EOL] lookup = lookup or getattr ( self , [string] ) [EOL] if lookup is None : [EOL] raise NameError ( [string] ) [EOL] [EOL] if not match_targets : [EOL] lookup_kwargs = await self . build_kwargs ( model , data , * args , ** kwargs ) [EOL] else : [EOL] lookup_kwargs = { key : await self . build_kwarg ( model , key , data , * args , ** kwargs ) for key in match_targets } [EOL] [EOL] instance = await lookup ( model , lookup_kwargs ) [EOL] if not instance : [EOL] if not match_targets : [EOL] build_kwargs = await self . build_kwargs ( model , data , * args , ** kwargs ) [EOL] return model ( ** build_kwargs ) , True [comment] [EOL] return instance , False [EOL] [EOL] async def get_or_create_multiple ( self , model , data , match_targets , * args , lookup = None , ** kwargs , ) : [EOL] [docstring] [EOL] return ( await self . get_or_create ( model , datapoint , match_targets , * args , lookup = lookup , ** kwargs ) for datapoint in data ) [EOL] [EOL] async def build_kwargs ( self , model , data , * args , ** kwargs ) : [EOL] [docstring] [EOL] return { name : await self . build_kwarg ( model , name , data , * args , ** kwargs ) for name , transformation in self . transformations [ model ] . items ( ) } [EOL] [EOL] async def build_kwarg ( self , model , kwarg , data , * args , ** kwargs ) : [EOL] [docstring] [EOL] try : [EOL] return await self . transformations [ model ] [ kwarg ] ( self , data , * args , ** kwargs ) [EOL] except TransformationException as e : [EOL] e_type , transformation , * e_args = e . args [EOL] raise e_type ( f" [string] { model . __name__ } [string] { kwarg } [string] { transformation . __name__ } [string] { e_args [ [number] ] }" , * e_args [ [number] : ] , ) [EOL] [EOL] [EOL] @ dataclass class AsyncTransformation : [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] raise NotImplementedError [EOL] [EOL] async def __call__ ( self , pipeline , data , * args , ** kwargs ) : [EOL] try : [EOL] return await self . apply ( pipeline , data , * args , ** kwargs ) [EOL] except Exception as e : [EOL] if isinstance ( e , TransformationException ) : [EOL] raise e [EOL] raise TransformationException ( type ( e ) , type ( self ) , * e . args ) [EOL] [EOL] def __or__ ( self , other ) : [EOL] return AsyncChain ( ) | self | other [EOL] [EOL] [EOL] @ dataclass class AsyncChain ( AsyncTransformation ) : [EOL] transformations = field ( init = False , default_factory = list ) [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] val = data [EOL] for transformation in self . transformations : [EOL] val = await transformation ( pipeline , val , * args , ** kwargs ) [EOL] return val [EOL] [EOL] def __or__ ( self , other ) : [EOL] self . transformations . append ( other ) [EOL] return self [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Type[M],typing.Dict[builtins.str,AsyncTransformation]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Callable[[typing.Type,typing.Dict],typing.Awaitable[M]]]$ 0 0 0 0 0 0 $typing.Awaitable[M]$ 0 0 0 $typing.Type[M]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 0 0 0 0 $typing.Type[M]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Awaitable[M]]$ 0 0 0 $typing.Type[M]$ 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 $typing.Tuple[M,builtins.bool]$ 0 0 0 $typing.Type[M]$ 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Type[M]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Type[M]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Type[M]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[M,builtins.bool]]$ 0 0 0 $typing.Type[M]$ 0 $typing.Sequence[typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Optional[typing.Callable[[typing.Type,typing.Dict],typing.Awaitable[M]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Optional[typing.Callable[[typing.Type,typing.Dict],typing.Awaitable[M]]]$ 0 $typing.Optional[typing.Callable[[typing.Type,typing.Dict],typing.Awaitable[M]]]$ 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Type[M]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Type[M]$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $AsyncPipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $AsyncPipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AsyncPipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AsyncChain$ 0 0 0 $AsyncTransformation$ 0 0 0 0 0 0 0 0 0 0 $AsyncTransformation$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[AsyncTransformation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $AsyncPipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $AsyncPipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $AsyncChain$ 0 0 0 $AsyncTransformation$ 0 0 0 0 0 0 0 0 0 $AsyncTransformation$ 0 0 0 0 0 0
from typing import Iterable , Callable , Sequence , Dict , Mapping , List , TypeVar , Optional , Tuple , Any [EOL] import builtins [EOL] import typing [EOL] import pipeline [EOL] [docstring] [EOL] from __future__ import annotations [EOL] from dataclasses import dataclass , field [EOL] from typing import ( Type , Optional , Union , TypeVar , overload , Generic , Mapping , Sequence , Callable , Any , List , Iterable , Dict , Tuple , ) [EOL] [EOL] from . pipeline import AsyncTransformation , AsyncPipeline [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] K = TypeVar ( [string] ) [EOL] V = TypeVar ( [string] ) [EOL] [EOL] [EOL] @ dataclass class Id ( AsyncTransformation , Generic [ V ] ) : [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return data [EOL] [EOL] [EOL] @ dataclass class Constant ( AsyncTransformation , Generic [ V ] ) : [EOL] value = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return self . value [EOL] [EOL] [EOL] @ dataclass class Custom ( AsyncTransformation , Generic [ K , V ] ) : [EOL] func = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return self . func ( data ) [comment] [EOL] [EOL] [EOL] @ dataclass class Default ( AsyncTransformation , Generic [ V , K ] ) : [EOL] value = ... [EOL] cond = bool [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return data if self . cond ( data ) else self . value [comment] [EOL] [EOL] [EOL] @ dataclass class Get ( AsyncTransformation , Generic [ K ] ) : [EOL] key = ... [EOL] default = None [EOL] [EOL] @ overload async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] @ overload async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] try : [EOL] return data [ self . key ] [EOL] except ( IndexError , KeyError ) : [EOL] if self . default is not None : [EOL] return self . default [EOL] raise [EOL] [EOL] [EOL] @ dataclass class Attr ( AsyncTransformation ) : [EOL] attr = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return getattr ( data , self . attr ) [EOL] [EOL] [EOL] @ dataclass class Filter ( AsyncTransformation , Generic [ V ] ) : [EOL] func = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return [ val for val in data if self . func ( data ) ] [comment] [EOL] [EOL] [EOL] @ dataclass class Map ( AsyncTransformation , Generic [ K , V ] ) : [EOL] func = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return [ self . func ( val ) for val in data ] [comment] [EOL] [EOL] [EOL] @ dataclass class ForEach ( AsyncTransformation ) : [EOL] transformation = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return [ self . transformation ( pipeline , datapoint , * args , ** kwargs ) for datapoint in data ] [EOL] [EOL] [EOL] @ dataclass class Flatten ( AsyncTransformation ) : [EOL] depth = [number] [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] result = data [EOL] for _ in range ( self . depth ) : [EOL] result = sum ( result , [ ] ) [EOL] return result [comment] [EOL] [EOL] [EOL] @ dataclass class Gather ( AsyncTransformation , Generic [ K ] ) : [EOL] keys = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return { key : data [ key ] for key in self . keys } [EOL] [EOL] [EOL] @ dataclass class FoldInKeys ( AsyncTransformation ) : [EOL] name = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return [ { self . name : key , ** datapoint } for key , datapoint in data . items ( ) ] [EOL] [EOL] [EOL] @ dataclass class FoldInValue ( AsyncTransformation ) : [EOL] key = ... [EOL] name = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return { key : { self . name : data [ self . key ] , ** datapoint } for key , datapoint in data . items ( ) if key != self . key } [EOL] [EOL] [EOL] @ dataclass class GetKeys ( AsyncTransformation ) : [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return list ( data . keys ( ) ) [EOL] [EOL] [EOL] @ dataclass class GetValues ( AsyncTransformation ) : [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return list ( data . values ( ) ) [EOL] [EOL] [EOL] @ dataclass class If ( AsyncTransformation , Generic [ V ] ) : [EOL] cond = ... [EOL] then = ... [EOL] else_ = None [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] if self . cond ( data ) : [comment] [EOL] return self . then ( pipeline , data , * args , ** kwargs ) [EOL] elif self . else_ is not None : [EOL] return self . else_ ( pipeline , data , * args , ** kwargs ) [EOL] else : [EOL] return None [EOL] [EOL] [EOL] @ dataclass class Create ( AsyncTransformation , Generic [ V ] ) : [EOL] model = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return await pipeline . create ( self . model , data , * args , ** kwargs ) [EOL] [EOL] [EOL] @ dataclass class CreateMultiple ( AsyncTransformation , Generic [ V ] ) : [EOL] model = ... [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return list ( await pipeline . create_multiple ( self . model , data , * args , ** kwargs ) ) [EOL] [EOL] [EOL] @ dataclass class GetOrCreate ( AsyncTransformation , Generic [ V ] ) : [EOL] model = ... [EOL] match_targets = None [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return await pipeline . get_or_create ( self . model , data , self . match_targets , * args , ** kwargs ) [EOL] [EOL] [EOL] @ dataclass class GetOrCreateMultiple ( AsyncTransformation , Generic [ V ] ) : [EOL] model = ... [EOL] match_targets = None [EOL] [EOL] async def apply ( self , pipeline , data , * args , ** kwargs ) : [EOL] return list ( await pipeline . get_or_create_multiple ( self . model , data , self . match_targets , * args , ** kwargs ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 $pipeline.AsyncPipeline$ 0 $V$ 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 0 0 0 $V$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[K],V]$ 0 0 0 0 0 0 $V$ 0 0 0 $pipeline.AsyncPipeline$ 0 $K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 $typing.Callable[[K],builtins.bool]$ 0 0 0 0 0 0 $V$ 0 0 0 $pipeline.AsyncPipeline$ 0 $K$ 0 0 0 0 0 0 0 0 0 0 $K$ 0 0 0 0 0 $K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $K$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[V],builtins.bool]$ 0 0 0 0 0 0 $typing.List[V]$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Iterable[V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[V]$ 0 0 0 0 0 $typing.Iterable[V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[V],K]$ 0 0 0 0 0 0 $typing.List[K]$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Iterable[V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncTransformation$ 0 0 0 0 0 0 $typing.List$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Sequence[typing.Sequence]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Sequence[typing.Sequence]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[K]$ 0 0 0 0 0 0 $typing.Dict[K,V]$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Mapping]$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Mapping[typing.Any,typing.Mapping]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Mapping]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[K]$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[V]$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[V],builtins.bool]$ 0 0 0 $pipeline.AsyncTransformation$ 0 0 0 $typing.Optional[pipeline.AsyncTransformation]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pipeline.AsyncPipeline$ 0 $V$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $V$ 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 $V$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 $V$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[V]$ 0 0 0 0 0 0 $V$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[V]$ 0 0 0 0 0 0 $typing.List[V]$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[V]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.Tuple[V,builtins.bool]$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[V]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[V,builtins.bool]]$ 0 0 0 $pipeline.AsyncPipeline$ 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pipeline.AsyncPipeline$ 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0