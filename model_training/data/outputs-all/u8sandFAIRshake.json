[comment] [EOL] [EOL] from app . ioc import injector [EOL] from app . types import App [EOL] [EOL] injector . get ( App ) . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from injector import Injector , singleton [EOL] [EOL] injector = Injector ( ) [EOL] injector . binder . bind ( Injector , to = injector , scope = singleton ) [EOL] [EOL] from . util . annotations import func_to_annotations , annotations_to_str , annotation_subset [EOL] from dataclasses import dataclass [EOL] [EOL] def model ( mod ) : [EOL] [docstring] [EOL] assert mod . __doc__ , [string] % (mod) [EOL] return dataclass ( mod ) [EOL] [EOL] def interface ( iface ) : [EOL] [docstring] [EOL] assert iface . __doc__ , [string] % (iface) [EOL] for attr in dir ( iface ) : [EOL] if callable ( attr ) : [EOL] assert attr . __doc__ , [string] % (iface) [EOL] def not_constructable ( self ) : [EOL] raise Exception ( [string] % ( iface . __name__ ) ) [EOL] iface . __init__ = not_constructable [EOL] return iface [EOL] [EOL] def implements ( iface ) : [EOL] [docstring] [EOL] def implements_decorator ( impl ) : [EOL] try : [EOL] setattr ( impl , [string] , iface . __doc__ ) [EOL] except : [EOL] pass [EOL] for attr in dir ( iface ) : [EOL] if attr . startswith ( [string] ) : [EOL] continue [EOL] iface_attr = getattr ( iface , attr , None ) [EOL] impl_attr = getattr ( impl , attr , None ) [EOL] assert impl_attr is not None , [string] % ( impl . __name__ , iface . __name__ , attr ) [EOL] [EOL] if callable ( impl_attr ) : [EOL] assert annotation_subset ( iface_attr , impl_attr ) , [string] % ( impl . __name__ , iface . __name__ , attr , ) [EOL] [EOL] try : [EOL] setattr ( impl_attr , [string] , iface_attr . __doc__ ) [EOL] except : [EOL] pass [EOL] injector . binder . bind ( iface , to = impl , scope = singleton ) [EOL] return impl [EOL] return implements_decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import os [EOL] from . util . importer import walk_directory [EOL] walk_directory ( os . path . dirname ( __file__ ) , [string] , __package__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , TypeVar [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import ( Any , Dict , Generator , Generic , List , NewType , Optional , Tuple , Type , TypeVar , ) [EOL] [EOL] UUID = NewType ( [string] , str ) [EOL] HTML = NewType ( [string] , str ) [EOL] ContentType = NewType ( [string] , str ) [EOL] Timestamp = NewType ( [string] , str ) [EOL] [comment] [EOL] T = TypeVar ( [string] ) [EOL] [EOL] class HTTPResponse ( Generic [ T ] ) : [EOL] pass [EOL] [EOL] Interface = NewType ( [string] , object ) [EOL] Implementation = NewType ( [string] , object ) [EOL] Model = NewType ( [string] , object ) [EOL] [EOL] from injector import Key , MappingKey , SequenceKey [EOL] [EOL] API = Key ( [string] ) [EOL] APISpec = Key ( [string] ) [EOL] App = Key ( [string] ) [EOL] Apps = MappingKey ( [string] ) [EOL] CommandLine = Key ( [string] ) [EOL] Config = Key ( [string] ) [EOL] Defaults = Key ( [string] ) [EOL] Environment = Key ( [string] ) [EOL] FlaskApp = Key ( [string] ) [EOL] OIDC = Key ( [string] ) [EOL] SQLAlchemy = Key ( [string] ) [EOL] SQLAlchemyBase = SequenceKey ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
	0
	0
[EOL] import builtins [EOL] def answer_value ( value ) : [EOL] try : [EOL] return float ( value ) [EOL] except : [EOL] return [number] if value != [string] else [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import math as m [EOL] [EOL] def nearest_sq ( n ) : [EOL] [docstring] [EOL] return m . ceil ( m . sqrt ( n ) ) [EOL] [EOL] def linearize ( x1 , y1 , x2 , y2 , val ) : [EOL] [docstring] [EOL] return val * ( y2 - y1 ) / ( x2 - x1 ) [EOL] [EOL] def build_insignia_svg ( scores ) : [EOL] [docstring] [EOL] scores_sq = nearest_sq ( len ( scores ) ) [EOL] for i , score in enumerate ( scores ) : [EOL] summary_sq = nearest_sq ( len ( score . summaries ) ) [EOL] for j , summary in enumerate ( score . summaries ) : [EOL] yield [string] . format ( x = ( i % ( scores_sq * summary_sq ) ) / ( scores_sq * summary_sq ) , y = m . ceil ( i % ( scores_sq * summary_sq ) ) / ( scores_sq * summary_sq ) , width = [number] / ( scores_sq * summary_sq ) , height = [number] / ( scores_sq * summary_sq ) , fill = linearize ( [number] , [number] , [number] , [number] , score . average ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from . util import build_insignia_svg [EOL] [EOL] kinds = { } [EOL] def register_kind ( kind ) : [EOL] def register_kind_decorator ( func ) : [EOL] global kinds [EOL] kinds [ kind ] = func [EOL] return func [EOL] return register_kind_decorator [EOL] [EOL] @ register_kind ( [string] ) def application_json ( scores ) : [EOL] return ( scores , [number] , ) [EOL] [EOL] @ register_kind ( [string] ) def text_html ( scores ) : [EOL] return ( [string] % ( [string] . join ( build_insignia_svg ( scores ) ) ) , [number] , ) [EOL] [EOL] @ register_kind ( [string] ) def unknown_kind ( scores ) : [EOL] return ( [string] , [number] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Optional , List , Mapping , Pattern , Tuple , Any , Dict [EOL] import typing [EOL] import builtins [EOL] import re [EOL] import json [EOL] from typing import ( Optional , Any , List , Tuple , Mapping , ) [EOL] [EOL] def json_with_fallback ( s ) : [EOL] if s is None : [EOL] return True [EOL] try : [EOL] return json . loads ( s ) [EOL] except : [EOL] return s [EOL] [EOL] kwarg_re = re . compile ( [string] ) [EOL] [EOL] def parse ( args ) : [EOL] kargs = [ ] [EOL] kwargs = { } [EOL] [EOL] for arg in args : [EOL] m = kwarg_re . match ( arg ) [EOL] if m : [EOL] kwargs [ m . group ( [string] ) ] = json_with_fallback ( m . group ( [string] ) ) [EOL] else : [EOL] kargs . append ( json_with_fallback ( arg ) ) [EOL] [EOL] return ( kargs , kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.str],typing.Mapping[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from . generate_spec import generate_spec [EOL] from swagger_stub import swagger_stub [EOL] from bravado . client import SwaggerClient [EOL] [EOL] def MockAPISwagger ( api ) : [EOL] [docstring] [EOL] mock_url = [string] . format ( api . __name__ ) [EOL] [comment] [EOL] spec = generate_spec ( doc . __doc__ , { api . __name__ : api } ) [EOL] spec [ [string] ] = mock_url [EOL] [comment] [EOL] swagger_stub ( [ ( spec , mock_url ) ] ) [EOL] [comment] [EOL] return SwaggerClient . from_url ( mock_url ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import logging [EOL] from importlib import import_module [EOL] [EOL] def walk_directory ( parent_dir , mod_dir , package ) : [EOL] [docstring] [EOL] for root , dirs , files in os . walk ( os . path . join ( parent_dir , mod_dir ) ) : [EOL] [comment] [EOL] dirs_rm = [ d for d in dirs if d . startswith ( [string] ) ] [EOL] for f in files : [EOL] [comment] [EOL] if f . endswith ( [string] ) : [EOL] cmd = os . path . splitext ( f ) [ [number] ] [EOL] [comment] [EOL] entity_mod = [string] + os . path . relpath ( os . path . join ( root , cmd , ) , parent_dir , ) . replace ( os . path . sep , [string] , ) [EOL] logging . debug ( [string] % (entity_mod) ) [EOL] import_module ( entity_mod , package ) [EOL] [comment] [EOL] for d in dirs_rm : [EOL] dirs . remove ( d ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import functools [EOL] [EOL] def deep_getattr ( obj , attr ) : [EOL] [docstring] [EOL] return functools . reduce ( getattr , attr . split ( [string] ) , obj ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , Iterator [EOL] import typing [EOL] from typing import Any , Iterable [EOL] [EOL] def first ( iterable ) : [EOL] return next ( iter ( iterable ) ) [EOL] [EOL] def first_and_only ( iterable ) : [EOL] [docstring] [EOL] try : [EOL] it = iter ( iterable ) [EOL] val = next ( it ) [EOL] try : [EOL] next ( it ) [EOL] raise Exception ( [string] ) [EOL] except StopIteration : [EOL] return val [EOL] except StopIteration : [EOL] raise Exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def filter_none_kwargs ( __ = { } , ** kwargs ) : [EOL] return dict ( { k : v for k , v in __ . items ( ) if v is not None } , ** ( { } if kwargs == { } else filter_none_kwargs ( kwargs ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Match [EOL] import typing [EOL] import re [EOL] from . deep_getattr import deep_getattr [EOL] from connexion . resolver import Resolver [EOL] [EOL] class RestyResolverEx ( Resolver ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , default_module_name , collection_endpoint_name = [string] , ** kwargs ) : [EOL] [docstring] [EOL] Resolver . __init__ ( self , ** kwargs ) [EOL] self . default_module_name = default_module_name [EOL] self . collection_endpoint_name = collection_endpoint_name [EOL] [EOL] def resolve_operation_id ( self , operation ) : [EOL] [docstring] [EOL] if operation . operation . get ( [string] ) : [EOL] return Resolver . resolve_operation_id ( self , operation ) [EOL] [EOL] return self . resolve_operation_id_using_rest_semantics ( operation ) [EOL] [EOL] def resolve_operation_id_using_rest_semantics ( self , operation ) : [EOL] [docstring] [EOL] path_match = re . search ( [string] , operation . path ) [EOL] [EOL] def get_controller_name ( ) : [EOL] x_router_controller = operation . operation . get ( [string] ) [EOL] [EOL] name = self . default_module_name [EOL] resource_name = path_match . group ( [string] ) [EOL] [EOL] if x_router_controller : [EOL] name = x_router_controller [EOL] [EOL] elif resource_name : [EOL] resource_controller_name = resource_name . replace ( [string] , [string] ) [EOL] name += [string] + resource_controller_name [EOL] [EOL] return name [EOL] [EOL] def get_function_name ( ) : [EOL] method = operation . method [EOL] [EOL] is_collection_endpoint = method . lower ( ) == [string] \ [EOL] and path_match . group ( [string] ) \ [EOL] and not path_match . group ( [string] ) [EOL] [EOL] return self . collection_endpoint_name if is_collection_endpoint else method . lower ( ) [EOL] [EOL] return [string] . format ( get_controller_name ( ) , get_function_name ( ) ) [EOL] [EOL] class ModuleResolver ( RestyResolverEx ) : [EOL] def __init__ ( self , module , collection_endpoint_name = [string] ) : [EOL] [docstring] [EOL] RestyResolverEx . __init__ ( self , default_module_name = module . __name__ , collection_endpoint_name = collection_endpoint_name , function_resolver = self . get_function_from_name , ) [EOL] self . module = module [EOL] [EOL] def get_function_from_name ( self , function_name ) : [EOL] [docstring] [EOL] if function_name is None : [EOL] raise ValueError ( [string] ) [EOL] function_name_parts = function_name . split ( [string] ) [EOL] assert function_name_parts [ [number] ] == self . module . __name__ [EOL] return deep_getattr ( self . module , [string] . join ( function_name_parts [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
def bind ( func , * kargs , ** kwargs ) : [EOL] [docstring] [EOL] def bind_wrapper ( * kargs_ , ** kwargs_ ) : [EOL] return func ( * kargs_ , * kargs , ** kwargs , ** kwargs_ ) [EOL] bind_wrapper . __name__ = func . __name__ [EOL] return bind_wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Pattern [EOL] import typing [EOL] import re [EOL] import yaml [EOL] from . deep_getattr import deep_getattr [EOL] from . first_and_only import first [EOL] [EOL] space_re = re . compile ( [string] ) [EOL] spec_ptr = re . compile ( [string] ) [EOL] [EOL] def yml_to_json ( doc ) : [EOL] [docstring] [EOL] spaces = len ( space_re . match ( first ( line for line in doc . splitlines ( ) if line . strip ( ) != [string] ) ) . group ( [number] ) ) [EOL] [EOL] return yaml . load ( [string] . join ( line [ spaces : ] for line in doc . splitlines ( ) ) ) [EOL] [EOL] def json_to_yml ( obj ) : [EOL] [docstring] [EOL] return yaml . dump ( obj , default_flow_style = False ) [EOL] [EOL] def docs_of ( objs ) : [EOL] return { name : obj . __doc__ for name , obj in objs . items ( ) } [EOL] [EOL] def generate_spec ( obj , objs = [ ] ) : [EOL] [docstring] [EOL] doc = obj . __doc__ [EOL] docs = { } [EOL] objs . append ( obj ) [EOL] objs_dict = { obj . __name__ : obj for obj in objs } [EOL] for ref in spec_ptr . finditer ( doc ) : [EOL] assert ref . group ( [string] ) in objs_dict . keys ( ) , ref [EOL] if ref . group ( [string] ) is not None : [EOL] attr = deep_getattr ( objs_dict [ ref . group ( [string] ) ] , ref . group ( [string] ) . replace ( [string] , [string] ) ) [EOL] docs [ ref . group ( [string] ) + [string] + ref . group ( [string] ) ] = generate_spec ( attr , objs ) [EOL] else : [EOL] docs [ ref . group ( [string] ) ] = generate_spec ( objs_dict [ ref . group ( [string] ) ] , objs ) [EOL] return yml_to_json ( doc . format ( ** docs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Type , Dict [EOL] import typing [EOL] import inspect [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import inspect [EOL] from typing import Callable , Dict , Type [EOL] [EOL] def func_to_annotations ( func ) : [EOL] argspec = inspect . getfullargspec ( func ) [EOL] [EOL] return dict ( { k : None for k in argspec . args } , ** argspec . annotations ) [EOL] [EOL] def annotations_to_str ( annotations ) : [EOL] return [string] % ( [string] . join ( [string] % ( str ( key ) , repr ( val ) ) for key , val in annotations . items ( ) if key != [string] ) , repr ( annotations [ [string] ] ) , ) [EOL] [EOL] def annotation_subset ( iface , impl ) : [EOL] iface_annotations = func_to_annotations ( iface ) [EOL] impl_annotations = func_to_annotations ( impl ) [EOL] for k , v in impl_annotations . items ( ) : [EOL] if iface_annotations . get ( k , None ) is not None : [EOL] if v is not None and v is not iface_annotations [ k ] : [EOL] return False [EOL] del iface_annotations [ k ] [EOL] return iface_annotations == { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import uuid [EOL] [EOL] def generate_uuid ( ) : [EOL] return str ( uuid . uuid4 ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import builtins [EOL] import types [EOL] import typing [EOL] from . . ioc import interface , model [EOL] from . . types import HTTPResponse , List , Optional , Timestamp , UUID [EOL] from . . util . generate_spec import generate_spec [EOL] [EOL] @ model class DigitalObjectModel : [EOL] [docstring] [EOL] id = ... [EOL] url = ... [EOL] user = None [EOL] name = None [EOL] description = None [EOL] image = None [EOL] tags = None [EOL] timestamp = None [EOL] [EOL] @ interface class RepositoryAPI : [EOL] [docstring] [EOL] [EOL] @ staticmethod def get ( id = None , tags = None , user = None , name = None , url = None , timestamp = None , skip = None , limit = None , ) : [EOL] [docstring] [EOL] raise NotImplemented [EOL] [EOL] @ staticmethod def post ( body ) : [EOL] [docstring] [EOL] raise NotImplemented [EOL] [EOL] RepositorySpec = generate_spec ( RepositoryAPI , [ DigitalObjectModel ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.UUID$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import types [EOL] from . . ioc import interface , model [EOL] from . . types import UUID , Timestamp , ContentType , HTTPResponse , Any [EOL] from . . util . generate_spec import generate_spec [EOL] [EOL] @ model class ScoreModel : [EOL] [docstring] [EOL] object = ... [EOL] criterion = ... [EOL] average = ... [EOL] timestamp = ... [EOL] [EOL] @ interface class ScoreAPI : [EOL] [docstring] [EOL] [EOL] @ staticmethod def get ( object = None , kind = None , ) : [EOL] [docstring] [EOL] raise NotImplemented [EOL] [EOL] ScoreSpec = generate_spec ( ScoreAPI , [ ScoreModel ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.UUID$ 0 0 0 $types.UUID$ 0 0 0 $builtins.float$ 0 0 0 $types.Timestamp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] import types [EOL] from . . ioc import interface , model [EOL] from . . types import HTTPResponse , UUID , Timestamp , Optional , List [EOL] from . . util . generate_spec import generate_spec [EOL] [EOL] @ model class CriterionModel : [EOL] [docstring] [EOL] id = ... [EOL] name = ... [EOL] kind = ... [EOL] [EOL] @ model class RubricModel : [EOL] [docstring] [EOL] id = ... [EOL] user = ... [EOL] name = ... [EOL] criteria = ... [EOL] description = None [EOL] tags = None [EOL] timestamp = None [EOL] [EOL] @ interface class RubricAPI : [EOL] [docstring] [EOL] [EOL] @ staticmethod def get ( id = None , user = None , object = None , timestamp = None , skip = None , limit = None , ) : [EOL] [docstring] [EOL] raise NotImplemented [EOL] [EOL] @ staticmethod def post ( body ) : [EOL] [docstring] [EOL] raise NotImplemented [EOL] [EOL] RubricSpec = generate_spec ( RubricAPI , [ RubricModel , CriterionModel ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.UUID$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $types.UUID$ 0 0 0 $types.UUID$ 0 0 0 $builtins.str$ 0 0 0 $types.List[CriterionModel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def test_app ( ) : [EOL] import app [EOL] from app . ioc import injector [EOL] from app . types import App [EOL] injector . get ( App ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from app . util . importer import walk_directory [EOL] [EOL] def test_walk_directory ( ) : [EOL] walk_directory ( os . path . dirname ( __name__ ) , [string] , __package__ ) [EOL] from test_importer import register [EOL] assert sum ( register ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from app . util . command_line_parse import parse [EOL] [EOL] def test_parse ( ) : [EOL] assert parse ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) == ( [ [string] , [number] , True , ] , { [string] : [string] , [string] : [ [string] , [string] ] , [string] : False , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from app . util . annotations import func_to_annotations , annotations_to_str , annotation_subset [EOL] [EOL] def test_func_to_annotations ( ) : [EOL] def test_func ( a , b , c ) : [EOL] pass [EOL] [EOL] assert func_to_annotations ( test_func ) == { [string] : int , [string] : str , [string] : float , [string] : str , } [EOL] [EOL] def test_func_partial_annotations ( ) : [EOL] def test_func ( a , b , c ) : [EOL] pass [EOL] [EOL] assert func_to_annotations ( test_func ) == { [string] : None , [string] : str , [string] : float , [string] : str , } [EOL] [EOL] def test_annotations_to_str ( ) : [EOL] import re [EOL] from collections import OrderedDict [EOL] desc = annotations_to_str ( OrderedDict ( [ ( [string] , str , ) , ( [string] , int , ) , ( [string] , str , ) , ( [string] , float , ) , ] ) ) [EOL] assert re . match ( [string] , desc , ) is not None , desc [EOL] [EOL] def test_annotation_subset ( ) : [EOL] def test_func_iface ( a , b , c ) : [EOL] pass [EOL] [EOL] def test_func_impl ( a , b , c , d ) : [EOL] pass [EOL] [EOL] def test_func_bad_impl ( a , b , c , d ) : [EOL] pass [EOL] [EOL] assert annotation_subset ( test_func_iface , test_func_impl ) , [string] [EOL] assert not annotation_subset ( test_func_iface , test_func_bad_impl ) , [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import app [EOL] import json [EOL] import connexion [EOL] from app . types import HTTPResponse [EOL] from app . util . generate_spec import generate_spec , json_to_yml [EOL] from app . util . module_resolver import ModuleResolver [EOL] [EOL] class TestAPI : [EOL] [docstring] [EOL] def get ( a ) : [EOL] [docstring] [EOL] return a , [number] [EOL] [EOL] class test : [EOL] def post ( a ) : [EOL] [docstring] [EOL] return a , [number] [EOL] [EOL] def test_module_resolver ( ) : [EOL] spec = generate_spec ( TestAPI ) [EOL] flask_app = connexion . FlaskApp ( TestAPI . __name__ ) [EOL] flask_app . add_api ( spec , resolver = ModuleResolver ( TestAPI ) ) [EOL] [EOL] with flask_app . app . test_client ( ) as client : [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] , response . status_code [EOL] data = json . loads ( response . data . decode ( ) ) [EOL] assert data == [string] , data [EOL] [EOL] response = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert response . status_code == [number] , response . status_code [EOL] data = json . loads ( response . data . decode ( ) ) [EOL] assert data == { [string] : [string] } , data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from app . util . bind import bind [EOL] [EOL] def test_bind ( ) : [EOL] def test_func ( * kargs , ** kwargs ) : [EOL] return sum ( kargs ) + sum ( kwargs . values ( ) ) [EOL] bound_func = bind ( test_func , [number] , [number] , a = [number] , b = [number] ) [EOL] assert bound_func ( [number] , c = [number] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from app . util . first_and_only import first , first_and_only [EOL] [EOL] def test_first ( ) : [EOL] assert first ( [ [number] , [number] ] ) == [number] [EOL] [EOL] def test_first_and_only ( ) : [EOL] assert first_and_only ( [ [number] ] ) == [number] [EOL] [EOL] try : [EOL] first_and_only ( [ ] ) [EOL] assert [string] [EOL] except : [EOL] pass [EOL] [EOL] try : [EOL] first_and_only ( [ [number] , [number] ] ) [EOL] assert [string] [EOL] except : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from app . util . generate_spec import generate_spec [EOL] [EOL] def test_generate_spec ( ) : [EOL] class T : [EOL] [docstring] [EOL] def k ( ) : [EOL] [docstring] [EOL] pass [EOL] class l : [EOL] def j ( ) : [EOL] [docstring] [EOL] pass [EOL] assert generate_spec ( T ) == { [string] : { [string] : { [string] : { [string] : { [string] : [string] , } , } , } , } , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from app . util . filter_none_kwargs import filter_none_kwargs [EOL] [EOL] def test_filter_none_kwargs ( ) : [EOL] assert filter_none_kwargs ( a = None , b = [string] ) == { [string] : [string] } [EOL] assert filter_none_kwargs ( { [string] : None , [string] : [string] } , d = None , e = [string] ) == { [string] : [string] , [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] register = [ ]	0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0
from . import register [EOL] register . append ( [number] )	0 0 0 0 0 0 0 0 0 0 0
from . import register [EOL] register . append ( [number] )	0 0 0 0 0 0 0 0 0 0 0