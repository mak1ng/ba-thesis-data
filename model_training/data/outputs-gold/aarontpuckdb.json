from typing import Any , Dict [EOL] import typing [EOL] import pathlib [EOL] import json [EOL] import os [EOL] import pathlib [EOL] import pytest [EOL] [EOL] from puckdb import parsers [EOL] [EOL] game_data_path = pathlib . Path ( __file__ ) . parent . joinpath ( [string] ) [EOL] game_2016_id = [number] [EOL] with game_data_path . joinpath ( f' [string] { game_2016_id } [string] ' ) . open ( [string] ) as f : [EOL] game_2016 = json . load ( f ) [EOL] [EOL] [EOL] class TestParsers : [EOL] def test_game ( self ) : [EOL] game = parsers . game ( game_2016_id , [number] , game_2016 ) [EOL] assert game [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] import aiohttp [EOL] import aiohttp [EOL] import pytest [EOL] from datetime import datetime [EOL] [EOL] from puckdb . extern import nhl [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) async def session ( event_loop ) : [EOL] async with aiohttp . ClientSession ( loop = event_loop ) as client_session : [EOL] yield client_session [EOL] [EOL] [EOL] class TestNhl : [EOL] @ pytest . mark . asyncio async def test_get_teams ( self , session ) : [EOL] teams = await nhl . get_teams ( session ) [EOL] assert len ( teams ) >= [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_schedule_games ( self , session ) : [EOL] date = datetime ( [number] , [number] , [number] ) [EOL] games = await nhl . get_schedule_games ( date , date , session ) [EOL] assert len ( games ) == [number] [EOL] assert [string] in games [ [number] ] [EOL] assert games [ [number] ] [ [string] ] == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_live_data ( self , session ) : [EOL] live = await nhl . get_live_data ( [number] , session ) [EOL] assert [string] in live [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] assert live [ [string] ] [ [string] ] [ [string] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import puckdb [EOL] import typing [EOL] import datetime [EOL] from datetime import datetime [EOL] [EOL] import pytest [EOL] [EOL] from puckdb import query [EOL] [EOL] @ pytest . mark . skip ( [string] ) class TestGameQuery : [EOL] def test_one_season_range ( self ) : [EOL] from_date = datetime ( [number] , [number] , [number] ) [EOL] to_date = datetime ( [number] , [number] , [number] ) [EOL] game_query = query . GameQuery ( from_date = from_date , to_date = to_date ) [EOL] seasons = game_query . by_season ( ) [EOL] assert len ( seasons ) == [number] [EOL] assert seasons [ [number] ] == [string] [EOL] [EOL] def test_season_before_range ( self ) : [EOL] from_date = datetime ( [number] , [number] , [number] ) [EOL] to_date = datetime ( [number] , [number] , [number] ) [EOL] game_query = query . GameQuery ( from_date = from_date , to_date = to_date ) [EOL] seasons = game_query . by_season ( ) [EOL] assert len ( seasons ) == [number] [EOL] assert seasons [ [number] ] == [string] [EOL] assert seasons [ [number] ] == [string] [EOL] [EOL] def test_season_after_range ( self ) : [EOL] from_date = datetime ( [number] , [number] , [number] ) [EOL] to_date = datetime ( [number] , [number] , [number] ) [EOL] game_query = query . GameQuery ( from_date = from_date , to_date = to_date ) [EOL] seasons = game_query . by_season ( ) [EOL] assert len ( seasons ) == [number] [EOL] assert seasons [ [number] ] == [string] [EOL] assert seasons [ [number] ] == [string] [EOL] [EOL] def test_season_min ( self ) : [EOL] to_date = datetime ( [number] , [number] , [number] ) [EOL] game_query = query . GameQuery ( to_date = to_date ) [EOL] seasons = game_query . by_season ( ) [EOL] assert len ( seasons ) >= [number] [EOL] [EOL] def test_season_max ( self ) : [EOL] from_date = datetime ( [number] , [number] , [number] ) [EOL] game_query = query . GameQuery ( from_date = from_date ) [EOL] seasons = game_query . by_season ( ) [EOL] assert len ( seasons ) >= [number] [EOL] [EOL] def test_days ( self ) : [EOL] from_date = datetime ( [number] , [number] , [number] ) [EOL] to_date = datetime ( [number] , [number] , [number] ) [EOL] game_query = query . GameQuery ( from_date = from_date , to_date = to_date ) [EOL] days = game_query . intervals [EOL] assert len ( days ) == [number] [EOL] assert days [ [number] ] . start == datetime ( [number] , [number] , [number] ) [EOL] assert days [ [number] ] . end == datetime ( [number] , [number] , [number] ) [EOL] [EOL] def test_weeks ( self ) : [EOL] from_date = datetime ( [number] , [number] , [number] ) [EOL] to_date = datetime ( [number] , [number] , [number] ) [EOL] game_query = query . GameQuery ( from_date = from_date , to_date = to_date ) [EOL] weeks = game_query . intervals [EOL] assert len ( weeks ) == [number] [EOL] assert weeks [ [number] ] . start == datetime ( [number] , [number] , [number] ) [EOL] assert weeks [ [number] ] . end == datetime ( [number] , [number] , [number] ) [EOL] [EOL] def test_months ( self ) : [EOL] from_date = datetime ( [number] , [number] , [number] ) [EOL] to_date = datetime ( [number] , [number] , [number] ) [EOL] game_query = query . GameQuery ( from_date = from_date , to_date = to_date ) [EOL] months = game_query . intervals [EOL] assert len ( months ) == [number] [EOL] assert months [ [number] ] . start == datetime ( [number] , [number] , [number] ) [EOL] assert months [ [number] ] . end == datetime ( [number] , [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 $typing.Any$ 0 $puckdb.query.GameQuery$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 $typing.Any$ 0 $puckdb.query.GameQuery$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 $typing.Any$ 0 $puckdb.query.GameQuery$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 $typing.Any$ 0 $puckdb.query.GameQuery$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 $typing.Any$ 0 $puckdb.query.GameQuery$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 $datetime.datetime.datetime$ 0 0 0 0 $puckdb.query.GameQuery$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import asyncio [EOL] import asyncpg [EOL] import datetime [EOL] import asyncio [EOL] import os [EOL] from datetime import datetime [EOL] [EOL] import pytest [EOL] import sqlalchemy as sa [EOL] from asyncpg . pool import Pool [EOL] [EOL] from puckdb import db , fetch [EOL] from puckdb . db import get_connection_str , metadata [EOL] [EOL] db_name = os . getenv ( [string] , os . getenv ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) async def pool ( ) : [EOL] return await db . get_pool ( database = db_name ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def database ( event_loop , pool ) : [EOL] engine = sa . create_engine ( get_connection_str ( db_name ) ) [EOL] metadata . drop_all ( engine ) [EOL] metadata . create_all ( engine ) [EOL] yield engine [EOL] metadata . drop_all ( engine ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) async def database_teams ( event_loop , database , pool ) : [EOL] await fetch . get_teams ( pool = pool ) [EOL] yield database [EOL] [EOL] [EOL] class TestFetch : [EOL] @ pytest . mark . asyncio async def test_get_games ( self , database_teams , pool ) : [EOL] date = datetime ( [number] , [number] , [number] ) [EOL] games = await fetch . get_games ( from_date = date , to_date = date , pool = pool ) [EOL] assert games is not None [EOL] assert len ( games ) == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_game ( self , database_teams , pool ) : [EOL] live = await fetch . get_game ( [number] , pool = pool ) [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [string] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_playoff_game ( self , database_teams , pool ) : [EOL] live = await fetch . get_game ( [number] , pool = pool ) [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [string] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] assert live [ [string] ] == [number] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_teams ( self , database , pool ) : [EOL] teams = await fetch . get_teams ( pool = pool ) [EOL] assert teams is not None [EOL] assert len ( teams ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
	0
from typing import Optional , List [EOL] import sqlalchemy [EOL] import typing [EOL] import builtins [EOL] import asyncpg [EOL] from abc import abstractmethod [EOL] from typing import List , Optional [EOL] [EOL] import sqlalchemy as sa [EOL] from asyncpg . pool import Pool [EOL] [EOL] from . db import event_tbl , game_tbl , player_tbl , team_tbl , upsert [EOL] [EOL] [EOL] class IdQuery : [EOL] def __init__ ( self , conn , tbl ) : [EOL] self . conn = conn [EOL] self . tbl = tbl [EOL] [EOL] async def get ( self , entity_id ) : [EOL] return await self . conn . fetchrow ( self . tbl . select ( ) . where ( self . tbl . c . id == entity_id ) ) [EOL] [EOL] async def get_all ( self , ids ) : [EOL] if ids : [EOL] return await self . conn . fetch ( self . tbl . select ( self . tbl . c . id . in_ ( ids ) ) ) [EOL] return await self . conn . fetch ( self . tbl . select ( ) ) [EOL] [EOL] @ abstractmethod async def insert ( self , data ) : [EOL] pass [EOL] [EOL] [EOL] class TeamQuery ( IdQuery ) : [EOL] def __init__ ( self , conn ) : [EOL] super ( ) . __init__ ( conn , team_tbl ) [EOL] [EOL] async def insert ( self , data ) : [EOL] return await self . conn . fetchrow ( upsert ( self . tbl , data , True ) ) [EOL] [EOL] [EOL] class GameQuery ( IdQuery ) : [EOL] def __init__ ( self , conn ) : [EOL] super ( ) . __init__ ( conn , game_tbl ) [EOL] [EOL] async def insert ( self , data ) : [EOL] return await self . conn . fetchrow ( upsert ( self . tbl , data , True ) ) [EOL] [EOL] [EOL] class PlayerQuery ( IdQuery ) : [EOL] def __init__ ( self , conn ) : [EOL] super ( ) . __init__ ( conn , player_tbl ) [EOL] [EOL] async def insert ( self , data ) : [EOL] return await self . conn . fetchrow ( upsert ( self . tbl , data , True ) ) [EOL] [EOL] [EOL] class EventQuery ( IdQuery ) : [EOL] def __init__ ( self , conn ) : [EOL] super ( ) . __init__ ( conn , event_tbl ) [EOL] [EOL] async def insert ( self , data ) : [EOL] return await self . conn . fetchrow ( upsert ( self . tbl , data , False ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $asyncpg.pool.Pool$ 0 0 0 0 0 0 0 0 0 $asyncpg.pool.Pool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $asyncpg.pool.Pool$ 0 0 0 0 0 0 0 0 0 $asyncpg.pool.Pool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $asyncpg.pool.Pool$ 0 0 0 0 0 0 0 0 0 $asyncpg.pool.Pool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $asyncpg.pool.Pool$ 0 0 0 0 0 0 0 0 0 $asyncpg.pool.Pool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] import os [EOL] import os . path [EOL] import sys [EOL] from datetime import datetime [EOL] [EOL] import asyncpg . exceptions [EOL] import click [EOL] import click_datetime [EOL] from alembic . command import upgrade [EOL] from alembic . config import Config [EOL] [EOL] from puckdb import db , fetch , server [EOL] [EOL] DATE_PARAM = click_datetime . Datetime ( format = [string] ) [EOL] [EOL] [EOL] def abort_if_false ( ctx , _ , value ) : [EOL] if not value : [EOL] ctx . abort ( ) [EOL] [EOL] [EOL] def _setup ( ) : [EOL] loop . run_until_complete ( db . setup ( ) ) [EOL] [EOL] [EOL] @ click . command ( help = [string] ) def init ( ) : [EOL] loc = os . path . realpath ( os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) ) ) [EOL] config = Config ( os . path . join ( loc , [string] ) ) [EOL] upgrade ( config , [string] ) [EOL] teams ( ) [EOL] [EOL] [EOL] @ click . command ( help = [string] ) def teams ( ) : [EOL] loop . run_until_complete ( fetch . get_teams ( ) ) [EOL] [EOL] [EOL] @ click . command ( help = [string] ) @ click . option ( [string] , is_flag = True , callback = abort_if_false , expose_value = False , prompt = [string] ) def drop ( ) : [EOL] db . drop ( ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , type = DATE_PARAM , default = datetime ( [number] , [number] , [number] ) ) @ click . option ( [string] , type = DATE_PARAM , default = datetime . now ( ) ) def get ( from_date , to_date ) : [EOL] try : [EOL] games = loop . run_until_complete ( fetch . get_games ( from_date = from_date , to_date = to_date ) ) [EOL] click . echo ( f' [string] { len ( games ) } [string] ' ) [EOL] if games : [EOL] click . echo ( f' [string] { games [ [number] ] [ [string] ] }' ) [EOL] click . echo ( f' [string] { games [ - [number] ] [ [string] ] }' ) [EOL] except asyncpg . exceptions . UndefinedTableError : [EOL] click . echo ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] @ click . command ( ) def serve ( ) : [EOL] server . run ( loop ) [EOL] [EOL] [EOL] @ click . group ( ) @ click . version_option ( ) def main ( ) : [EOL] if not os . getenv ( [string] ) : [EOL] click . echo ( [string] ) [EOL] sys . exit ( [number] ) [EOL] _setup ( ) [EOL] [EOL] [EOL] main . add_command ( get ) [EOL] main . add_command ( init ) [EOL] main . add_command ( teams ) [EOL] main . add_command ( drop ) [EOL] main . add_command ( serve ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import builtins [EOL] import enum [EOL] import enum [EOL] from typing import Type [EOL] [EOL] [EOL] class PlayerPosition ( enum . Enum ) : [EOL] center = [number] [EOL] left_wing = [number] [EOL] right_wing = [number] [EOL] defenseman = [number] [EOL] goalie = [number] [EOL] [EOL] [EOL] class PlayerHandedness ( enum . Enum ) : [EOL] left = [number] [EOL] right = [number] [EOL] [EOL] [EOL] class GameState ( enum . Enum ) : [EOL] not_started = - [number] [EOL] in_progress = [number] [EOL] finished = [number] [EOL] [EOL] [EOL] class GameType ( enum . Enum ) : [EOL] unknown = - [number] [EOL] regular = [number] [EOL] playoff = [number] [EOL] allstar = [number] [EOL] [EOL] [EOL] class EventType ( enum . Enum ) : [EOL] blocked_shot = [number] [EOL] challenge = [number] [EOL] faceoff = [number] [EOL] giveaway = [number] [EOL] goal = [number] [EOL] hit = [number] [EOL] missed_shot = [number] [EOL] penalty = [number] [EOL] shot = [number] [EOL] stop = [number] [EOL] takeaway = [number] [EOL] [EOL] [EOL] class ShotType ( enum . Enum ) : [EOL] backhand = [number] [EOL] deflected = [number] [EOL] slap = [number] [EOL] snap = [number] [EOL] tip = [number] [EOL] wrap_around = [number] [EOL] wrist = [number] [EOL] [EOL] [EOL] def parse_enum ( check_enum , type_str ) : [EOL] for e in check_enum : [EOL] if e . name == type_str . lower ( ) : [EOL] return e [EOL] raise ValueError ( f' [string] { type_str } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import asyncio [EOL] [EOL] try : [EOL] import uvloop [EOL] [EOL] asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ( ) ) [EOL] except ImportError : [EOL] pass [EOL] [EOL] __title__ = [string] [EOL] __author__ = [string] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
import aiohttp [EOL] from aiohttp import web [EOL] [EOL] from . views import index , game [EOL] [EOL] [EOL] def setup_routes ( app ) : [EOL] app . router . add_get ( [string] , index ) [EOL] app . router . add_get ( [string] , game . index , name = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] [EOL] from aiohttp import web [EOL] [EOL] from . routes import setup_routes [EOL] from . . db import get_pool [EOL] [EOL] [EOL] async def init ( ) : [EOL] app = web . Application ( ) [EOL] app [ [string] ] = await get_pool ( ) [EOL] setup_routes ( app ) [EOL] return app [EOL] [EOL] [EOL] def run ( loop = asyncio . get_event_loop ( ) ) : [EOL] app = loop . run_until_complete ( init ( ) ) [EOL] web . run_app ( app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from aiohttp import web [EOL] [EOL] [EOL] async def index ( ) : [EOL] return web . Response ( text = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from aiohttp import web [EOL] [EOL] [EOL] async def index ( ) : [EOL] return web . Response ( text = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] import aiohttp [EOL] import itertools [EOL] import ujson [EOL] from datetime import datetime [EOL] [EOL] import aiohttp [EOL] [EOL] _HEADERS = { [string] : [string] [string] } [EOL] [EOL] _BASE_URL = [string] [EOL] [EOL] [EOL] async def get_teams ( session ) : [EOL] teams = await _get ( _BASE_URL + [string] , session ) [EOL] return teams [ [string] ] [EOL] [EOL] [EOL] async def get_team ( team_id , session ) : [EOL] teams = await _get ( _BASE_URL + f' [string] { team_id }' , session ) [EOL] return teams [ [string] ] [ [number] ] [EOL] [EOL] [EOL] async def get_schedule_games ( from_date , to_date , session ) : [EOL] url = f' [string] { from_date . strftime ( [string] ) } [string] { to_date . strftime ( [string] ) }' [string] [EOL] schedule = await _get ( _BASE_URL + url , session ) [EOL] return list ( itertools . chain . from_iterable ( [ day [ [string] ] for day in schedule [ [string] ] ] ) ) [EOL] [EOL] [EOL] async def get_live_data ( game_id , session ) : [EOL] url = f' [string] { game_id } [string] ' [EOL] return await _get ( _BASE_URL + url , session ) [EOL] [EOL] [EOL] async def _get ( url , session ) : [EOL] async with session . get ( url , headers = _HEADERS ) as response : [EOL] assert response . status == [number] [EOL] return await response . json ( loads = ujson . loads ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0