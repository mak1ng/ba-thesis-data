import builtins [EOL] from typing import Literal , Union , Optional , Dict [EOL] import typing [EOL] import typing_extensions [EOL] import logging [EOL] import os [EOL] [EOL] DEBUG = os . getenv ( [string] ) == [string] [EOL] APPLICATION_ROOT = os . getenv ( [string] , [string] ) [EOL] HOST = os . getenv ( [string] ) [EOL] PORT = int ( os . getenv ( [string] , [string] ) ) [EOL] [EOL] DB_CONTAINER = os . getenv ( [string] , [string] ) [EOL] POSTGRES = { [string] : os . getenv ( [string] , [string] ) , [string] : os . getenv ( [string] , [string] ) , [string] : os . getenv ( [string] , DB_CONTAINER ) , [string] : os . getenv ( [string] , [number] ) , [string] : os . getenv ( [string] , [string] ) , } [EOL] DB_URI = [string] % POSTGRES [EOL] [EOL] logging . basicConfig ( filename = os . getenv ( [string] , [string] ) , level = logging . DEBUG , format = [string] , datefmt = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import flask [EOL] from flask import Flask [EOL] from flask . blueprints import Blueprint [EOL] from flasgger import Swagger [EOL] [EOL] import config [EOL] from models import db [EOL] import routes [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] server = Flask ( __name__ ) [EOL] [EOL] server . config [ [string] ] = { [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : lambda rule : True } ] , [string] : [string] } [EOL] [EOL] Swagger ( server ) [EOL] [EOL] server . debug = config . DEBUG [EOL] server . config [ [string] ] = config . DB_URI [EOL] db . init_app ( server ) [EOL] db . app = server [EOL] [EOL] for blueprint in vars ( routes ) . values ( ) : [EOL] if isinstance ( blueprint , Blueprint ) : [EOL] server . register_blueprint ( blueprint , url_prefix = config . APPLICATION_ROOT ) [EOL] [EOL] if __name__ == [string] : [EOL] server . run ( host = config . HOST , port = config . PORT ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import flask [EOL] from flask import Flask [EOL] from flask_script import Manager [EOL] from flask_migrate import Migrate , MigrateCommand [EOL] [EOL] import config [EOL] from models import db [EOL] [EOL] server = Flask ( __name__ ) [EOL] server . debug = config . DEBUG [EOL] server . config [ [string] ] = config . DB_URI [EOL] db . init_app ( server ) [EOL] [EOL] migrate = Migrate ( server , db ) [EOL] manager = Manager ( server ) [EOL] manager . add_command ( [string] , MigrateCommand ) [EOL] [EOL] if __name__ == [string] : [EOL] manager . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from . user import UserResource [EOL]	0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from flasgger import swag_from [EOL] from flask_restful import Resource [EOL] from flask_restful . reqparse import Argument [EOL] from flask . json import jsonify [EOL] [EOL] from repositories import UserRepository [EOL] from util import parse_params [EOL] [EOL] [EOL] class UserResource ( Resource ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod @ swag_from ( [string] ) def get ( last_name , first_name ) : [EOL] [docstring] [EOL] user = UserRepository . get ( last_name = last_name , first_name = first_name ) [EOL] return jsonify ( { [string] : user . json } ) [EOL] [EOL] @ staticmethod @ parse_params ( Argument ( [string] , location = [string] , required = True , help = [string] ) , ) @ swag_from ( [string] ) def post ( last_name , first_name , age ) : [EOL] [docstring] [EOL] user = UserRepository . create ( last_name = last_name , first_name = first_name , age = age ) [EOL] return jsonify ( { [string] : user . json } ) [EOL] [EOL] @ staticmethod @ parse_params ( Argument ( [string] , location = [string] , required = True , help = [string] ) , ) @ swag_from ( [string] ) def put ( last_name , first_name , age ) : [EOL] [docstring] [EOL] repository = UserRepository ( ) [EOL] user = repository . update ( last_name = last_name , first_name = first_name , age = age ) [EOL] return jsonify ( { [string] : user . json } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from functools import wraps [EOL] from flask_restful import reqparse [EOL] [EOL] [EOL] def parse_params ( * arguments ) : [EOL] [docstring] [EOL] def parse ( func ) : [EOL] [docstring] [EOL] @ wraps ( func ) def resource_verb ( * args , ** kwargs ) : [EOL] [docstring] [EOL] parser = reqparse . RequestParser ( ) [EOL] for argument in arguments : [EOL] parser . add_argument ( argument ) [EOL] kwargs . update ( parser . parse_args ( ) ) [EOL] return func ( * args , ** kwargs ) [EOL] return resource_verb [EOL] return parse [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . parse_params import parse_params [EOL]	0 0 0 0 0 0
from . user import USER_BLUEPRINT [EOL]	0 0 0 0 0 0
import flask [EOL] [docstring] [EOL] from flask import Blueprint [EOL] from flask_restful import Api [EOL] [EOL] from resources import UserResource [EOL] [EOL] [EOL] USER_BLUEPRINT = Blueprint ( [string] , __name__ ) [EOL] Api ( USER_BLUEPRINT ) . add_resource ( UserResource , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0
from . user import UserRepository [EOL]	0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from models import User [EOL] [EOL] [EOL] class UserRepository : [EOL] [docstring] [EOL] [EOL] @ staticmethod def get ( last_name , first_name ) : [EOL] [docstring] [EOL] return User . query . filter_by ( last_name = last_name , first_name = first_name ) . one ( ) [EOL] [EOL] def update ( self , last_name , first_name , age ) : [EOL] [docstring] [EOL] user = self . get ( last_name , first_name ) [EOL] user . age = age [EOL] [EOL] return user . save ( ) [EOL] [EOL] @ staticmethod def create ( last_name , first_name , age ) : [EOL] [docstring] [EOL] user = User ( last_name = last_name , first_name = first_name , age = age ) [EOL] [EOL] return user . save ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from datetime import datetime [EOL] from weakref import WeakValueDictionary [EOL] from sqlalchemy import inspect [EOL] from sqlalchemy . orm import aliased [EOL] [EOL] from . import db [EOL] [EOL] [EOL] class MetaBaseModel ( db . Model . __class__ ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( cls , * args ) : [EOL] super ( ) . __init__ ( * args ) [EOL] cls . aliases = WeakValueDictionary ( ) [EOL] [EOL] def __getitem__ ( cls , key ) : [EOL] try : [EOL] alias = cls . aliases [ key ] [EOL] except KeyError : [EOL] alias = aliased ( cls ) [EOL] cls . aliases [ key ] = alias [EOL] return alias [EOL] [EOL] [EOL] class BaseModel ( ) : [EOL] [docstring] [EOL] [EOL] print_filter = ( ) [EOL] to_json_filter = ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return [string] % ( self . __class__ . __name__ , { column : value for column , value in self . _to_dict ( ) . items ( ) if column not in self . print_filter } ) [EOL] [EOL] @ property def json ( self ) : [EOL] [docstring] [EOL] return { column : value [EOL] if not isinstance ( value , datetime ) else value . strftime ( [string] ) for column , value in self . _to_dict ( ) . items ( ) if column not in self . to_json_filter } [EOL] [EOL] def _to_dict ( self ) : [EOL] [docstring] [EOL] return { column . key : getattr ( self , column . key ) for column in inspect ( self . __class__ ) . attrs } [EOL] [EOL] def save ( self ) : [EOL] db . session . add ( self ) [EOL] db . session . commit ( ) [EOL] return self [EOL] [EOL] def delete ( self ) : [EOL] db . session . delete ( self ) [EOL] db . session . commit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import src [EOL] [docstring] [EOL] from . import db [EOL] from . abc import BaseModel , MetaBaseModel [EOL] [EOL] [EOL] class User ( db . Model , BaseModel , metaclass = MetaBaseModel ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] [EOL] first_name = db . Column ( db . String ( [number] ) , primary_key = True ) [EOL] last_name = db . Column ( db . String ( [number] ) , primary_key = True ) [EOL] age = db . Column ( db . Integer , nullable = True ) [EOL] [EOL] def __init__ ( self , first_name , last_name , age = None ) : [EOL] [docstring] [EOL] self . first_name = first_name [EOL] self . last_name = last_name [EOL] self . age = age [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Type[src.models.user.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.models.user.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.models.user.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from flask_sqlalchemy import SQLAlchemy [EOL] db = SQLAlchemy ( ) [EOL] [EOL] from . user import User [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] revision = [string] [EOL] down_revision = None [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] import json [EOL] import warnings [EOL] [EOL] from server import server [EOL] [EOL] [EOL] class TestSwagger ( unittest . TestCase ) : [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . client = server . test_client ( ) [EOL] [EOL] def test_get_spec ( self ) : [EOL] [docstring] [EOL] [EOL] with warnings . catch_warnings ( ) : [EOL] warnings . filterwarnings ( [string] , message = [string] ) [EOL] response = self . client . get ( [string] ) [EOL] self . assertEqual ( response . status_code , [number] ) [EOL] [EOL] def test_swagger_is_not_empty ( self ) : [EOL] [docstring] [EOL] [EOL] with warnings . catch_warnings ( ) : [EOL] warnings . filterwarnings ( [string] , message = [string] ) [EOL] response = self . client . get ( [string] ) [EOL] response_json = json . loads ( response . data . decode ( [string] ) ) [EOL] self . assertTrue ( response_json [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any , Literal , Union , List , Dict [EOL] import typing [EOL] import typing_extensions [EOL] import json [EOL] import unittest [EOL] import warnings [EOL] [EOL] from server import server [EOL] [EOL] [EOL] class TestSwaggerCoverage ( unittest . TestCase ) : [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . client = server . test_client ( ) [EOL] cls . BANNED_RULES = [ [string] , [string] , [string] ] [EOL] cls . THRESHOLD = [number] [EOL] [EOL] def test_swagger_coverage ( self ) : [EOL] [docstring] [EOL] [EOL] self . color_print ( [string] , [string] ) [EOL] [EOL] swagger_specs = self . retrieve_swagger_specs ( ) [EOL] rules = self . filter_rules ( self . client . application . url_map . iter_rules ( ) ) [EOL] [EOL] ( covered_methods , methods_total ) = self . retrieve_covered_methods_number ( rules , swagger_specs ) [EOL] coverage = int ( [number] * covered_methods / methods_total ) [EOL] [EOL] end_color = [string] if coverage == [number] else [string] [EOL] self . color_print ( end_color , [string] % ( str ( covered_methods ) , str ( methods_total ) ) ) [EOL] [EOL] self . assertTrue ( coverage >= self . THRESHOLD ) [EOL] [EOL] def retrieve_swagger_specs ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] with warnings . catch_warnings ( ) : [EOL] warnings . filterwarnings ( [string] , message = [string] ) [EOL] response = self . client . get ( [string] ) [EOL] response_json = json . loads ( response . data . decode ( [string] ) ) [EOL] swagger_specs = response_json [ [string] ] [EOL] [EOL] return swagger_specs [EOL] [EOL] def retrieve_covered_methods_number ( self , rules , swagger_specs ) : [EOL] [docstring] [EOL] methods_total = [number] [EOL] covered_methods = [number] [EOL] for rule in rules : [EOL] methods = self . filter_methods ( rule . methods ) [EOL] parsed_rule = self . format_rule ( rule ) [EOL] for method in methods : [EOL] methods_total += [number] [EOL] try : [EOL] swagger_specs [ parsed_rule ] [ method . lower ( ) ] [EOL] covered_methods += [number] [EOL] except KeyError : [EOL] self . color_print ( [string] , [string] % ( method , parsed_rule ) ) [EOL] continue [EOL] [EOL] return ( covered_methods , methods_total ) [EOL] [EOL] @ staticmethod def filter_methods ( methods ) : [EOL] [docstring] [EOL] return [ method for method in methods if method not in [ [string] , [string] ] ] [EOL] [EOL] @ staticmethod def format_rule ( rule ) : [EOL] [docstring] [EOL] return ( str ( rule ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] [EOL] def filter_rules ( self , rules ) : [EOL] [docstring] [EOL] return [ rule for rule in rules if not self . is_banned_rule ( rule ) ] [EOL] [EOL] def is_banned_rule ( self , rule ) : [EOL] [docstring] [EOL] return any ( banned_rule in str ( rule ) for banned_rule in self . BANNED_RULES ) [EOL] [EOL] @ staticmethod def color_print ( color , message ) : [EOL] [docstring] [EOL] colors = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] print ( colors [ color ] + message + colors [ [string] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] import json [EOL] [EOL] from server import server [EOL] from models . abc import db [EOL] from models import User [EOL] from repositories import UserRepository [EOL] [EOL] [EOL] class TestUser ( unittest . TestCase ) : [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . client = server . test_client ( ) [EOL] [EOL] def setUp ( self ) : [EOL] db . create_all ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] db . session . remove ( ) [EOL] db . drop_all ( ) [EOL] [EOL] def test_get ( self ) : [EOL] [docstring] [EOL] UserRepository . create ( first_name = [string] , last_name = [string] , age = [number] ) [EOL] response = self . client . get ( [string] ) [EOL] [EOL] self . assertEqual ( response . status_code , [number] ) [EOL] response_json = json . loads ( response . data . decode ( [string] ) ) [EOL] self . assertEqual ( response_json , { [string] : { [string] : [number] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] def test_create ( self ) : [EOL] [docstring] [EOL] response = self . client . post ( [string] , content_type = [string] , data = json . dumps ( { [string] : [number] } ) ) [EOL] [EOL] self . assertEqual ( response . status_code , [number] ) [EOL] response_json = json . loads ( response . data . decode ( [string] ) ) [EOL] self . assertEqual ( response_json , { [string] : { [string] : [number] , [string] : [string] , [string] : [string] } } ) [EOL] self . assertEqual ( User . query . count ( ) , [number] ) [EOL] [EOL] def test_update ( self ) : [EOL] [docstring] [EOL] UserRepository . create ( first_name = [string] , last_name = [string] , age = [number] ) [EOL] response = self . client . put ( [string] , content_type = [string] , data = json . dumps ( { [string] : [number] } ) ) [EOL] [EOL] self . assertEqual ( response . status_code , [number] ) [EOL] response_json = json . loads ( response . data . decode ( [string] ) ) [EOL] self . assertEqual ( response_json , { [string] : { [string] : [number] , [string] : [string] , [string] : [string] } } ) [EOL] user = UserRepository . get ( first_name = [string] , last_name = [string] ) [EOL] self . assertEqual ( user . age , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0