[docstring] [EOL]	0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import regenmaschine [EOL] [docstring] [EOL] [comment] [EOL] import asyncio [EOL] import datetime [EOL] [EOL] from aiohttp import ClientSession [EOL] [EOL] from regenmaschine import Client [EOL] from regenmaschine . errors import RainMachineError [EOL] [EOL] [EOL] async def main ( ) : [EOL] [docstring] [EOL] async with ClientSession ( ) as session : [EOL] try : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( [string] , [string] ) [EOL] [EOL] for controller in client . controllers . values ( ) : [EOL] print ( [string] ) [EOL] print ( f" [string] { controller . name }" ) [EOL] print ( f" [string] { controller . mac }" ) [EOL] print ( f" [string] { controller . api_version }" ) [EOL] print ( f" [string] { controller . software_version }" ) [EOL] print ( f" [string] { controller . hardware_version }" ) [EOL] [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] data = await controller . diagnostics . current ( ) [EOL] print ( f" [string] { data [ [string] ] }" ) [EOL] print ( f" [string] { data [ [string] ] }" ) [EOL] [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] for parser in await controller . parsers . current ( ) : [EOL] print ( parser [ [string] ] ) [EOL] [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] for program in await controller . programs . all ( include_inactive = True ) : [EOL] print ( f" [string] { program [ [string] ] } [string] { program [ [string] ] }" ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] program_1 = await controller . programs . get ( [number] ) [EOL] print ( f" [string] { program_1 [ [string] ] }" ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] for program in await controller . programs . next ( ) : [EOL] print ( f" [string] { program [ [string] ] } [string] { program [ [string] ] }" ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] for program in await controller . programs . running ( ) : [EOL] print ( f" [string] { program [ [string] ] }" ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( await controller . programs . start ( [number] ) ) [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( await controller . programs . stop ( [number] ) ) [EOL] [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] name = await controller . provisioning . device_name [EOL] print ( f" [string] { name }" ) [EOL] settings = await controller . provisioning . settings ( ) [EOL] print ( f" [string] { settings [ [string] ] [ [string] ] }" ) [EOL] print ( f" [string] { settings [ [string] ] [ [string] ] }" ) [EOL] wifi = await controller . provisioning . wifi ( ) [EOL] print ( f" [string] { wifi [ [string] ] }" ) [EOL] [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] current = await controller . restrictions . current ( ) [EOL] print ( f" [string] { current [ [string] ] }" ) [EOL] universal = await controller . restrictions . universal ( ) [EOL] print ( f" [string] { universal [ [string] ] }" ) [EOL] print ( [string] ) [EOL] for restriction in await controller . restrictions . hourly ( ) : [EOL] print ( restriction [ [string] ] ) [EOL] raindelay = await controller . restrictions . raindelay ( ) [EOL] print ( f" [string] { raindelay [ [string] ] }" ) [EOL] [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] today = await controller . stats . on_date ( date = datetime . date . today ( ) ) [EOL] print ( f" [string] { today [ [string] ] }" ) [EOL] for day in await controller . stats . upcoming ( details = True ) : [EOL] print ( f"{ day [ [string] ] } [string] { day [ [string] ] }" ) [EOL] [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] for day in await controller . watering . log ( date = datetime . date . today ( ) ) : [EOL] print ( f"{ day [ [string] ] } [string] { day [ [string] ] }" ) [EOL] queue = await controller . watering . queue ( ) [EOL] print ( f" [string] { queue }" ) [EOL] [EOL] print ( [string] ) [EOL] for watering_run in await controller . watering . runs ( date = datetime . date . today ( ) ) : [EOL] print ( f"{ watering_run [ [string] ] } [string] { watering_run [ [string] ] } [string] " ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( await controller . watering . pause_all ( [number] ) ) [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( await controller . watering . unpause_all ( ) ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( await controller . watering . stop_all ( ) ) [EOL] [EOL] [comment] [EOL] print ( ) [EOL] print ( [string] ) [EOL] for zone in await controller . zones . all ( details = True ) : [EOL] print ( f" [string] { zone [ [string] ] } [string] { zone [ [string] ] } [string] { zone [ [string] ] } [string] " ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] zone_1 = await controller . zones . get ( [number] , details = True ) [EOL] print ( f" [string] { zone_1 [ [string] ] } [string] { zone_1 [ [string] ] } [string] " ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( await controller . zones . start ( [number] , [number] ) ) [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( await controller . zones . stop ( [number] ) ) [EOL] except RainMachineError as err : [EOL] print ( err ) [EOL] [EOL] [EOL] asyncio . run ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import os [EOL] [EOL] TEST_ACCESS_TOKEN = [string] [EOL] TEST_API_VERSION = [string] [EOL] TEST_EMAIL = [string] [EOL] TEST_HOST = [string] [EOL] TEST_HW_VERSION = [number] [EOL] TEST_MAC = [string] [EOL] TEST_NAME = [string] [EOL] TEST_PASSWORD = [string] [EOL] TEST_PORT = [number] [EOL] TEST_SPRINKLER_ID = [string] [EOL] TEST_SW_VERSION = [string] [EOL] TEST_TOTP_CODE = [number] [EOL] TEST_URL = f" [string] { TEST_HOST } [string] { TEST_PORT }" [EOL] [EOL] [EOL] def load_fixture ( filename ) : [EOL] [docstring] [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , [string] , filename ) [EOL] with open ( path , encoding = [string] ) as fptr : [EOL] return fptr . read ( ) [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import sys [EOL] [EOL] if sys . version_info [ : [number] ] < ( [number] , [number] ) : [EOL] from asynctest . mock import * [comment] [EOL] [EOL] AsyncMock = CoroutineMock [comment] [EOL] else : [EOL] from unittest . mock import * [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import regenmaschine [EOL] import datetime [EOL] [docstring] [EOL] from datetime import date [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] [EOL] from regenmaschine import Client [EOL] [EOL] from . common import TEST_HOST , TEST_PASSWORD , TEST_PORT , load_fixture [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_stats ( aresponses , authenticated_local_client ) : [EOL] [docstring] [EOL] async with authenticated_local_client : [EOL] today = date . today ( ) [EOL] today_str = today . strftime ( [string] ) [EOL] [EOL] authenticated_local_client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , f" [string] { today_str }" , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] authenticated_local_client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , port = TEST_PORT , ssl = False ) [EOL] controller = next ( iter ( client . controllers . values ( ) ) ) [EOL] [EOL] data = await controller . stats . on_date ( today ) [EOL] assert data [ [string] ] == [number] [EOL] [EOL] data = await controller . stats . upcoming ( details = True ) [EOL] assert len ( data [ [number] ] [ [string] ] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import regenmaschine [EOL] import datetime [EOL] [docstring] [EOL] [comment] [EOL] import asyncio [EOL] from datetime import datetime , timedelta [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] [EOL] from regenmaschine import Client [EOL] from regenmaschine . errors import RequestError , TokenExpiredError [EOL] [EOL] import tests . async_mock as mock [EOL] from tests . common import ( TEST_ACCESS_TOKEN , TEST_API_VERSION , TEST_EMAIL , TEST_HOST , TEST_HW_VERSION , TEST_MAC , TEST_NAME , TEST_PASSWORD , TEST_PORT , TEST_SW_VERSION , load_fixture , ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_legacy_login ( authenticated_local_client ) : [EOL] [docstring] [EOL] async with authenticated_local_client : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , port = TEST_PORT , ssl = False ) [EOL] controller = next ( iter ( client . controllers . values ( ) ) ) [EOL] [EOL] assert controller . _access_token == TEST_ACCESS_TOKEN [EOL] assert controller . api_version == TEST_API_VERSION [EOL] assert controller . hardware_version == TEST_HW_VERSION [EOL] assert controller . mac == TEST_MAC [EOL] assert controller . name == TEST_NAME [EOL] assert controller . software_version == TEST_SW_VERSION [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_load_local ( authenticated_local_client ) : [EOL] [docstring] [EOL] async with authenticated_local_client : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , TEST_PORT , False ) [EOL] [EOL] assert len ( client . controllers ) == [number] [EOL] [EOL] controller = client . controllers [ TEST_MAC ] [EOL] assert controller . _access_token == TEST_ACCESS_TOKEN [EOL] assert controller . api_version == TEST_API_VERSION [EOL] assert controller . hardware_version == TEST_HW_VERSION [EOL] assert controller . mac == TEST_MAC [EOL] assert controller . name == TEST_NAME [EOL] assert controller . software_version == TEST_SW_VERSION [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_load_local_skip ( aresponses , authenticated_local_client ) : [EOL] [docstring] [EOL] authenticated_local_client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] authenticated_local_client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] async with authenticated_local_client : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , TEST_PORT , True ) [EOL] controller = client . controllers [ TEST_MAC ] [EOL] [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , TEST_PORT , True ) [EOL] assert len ( client . controllers ) == [number] [EOL] assert client . controllers [ TEST_MAC ] == controller [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_load_local_failure ( aresponses ) : [EOL] [docstring] [EOL] aresponses . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] with pytest . raises ( RequestError ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , TEST_PORT , False ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_load_remote ( authenticated_remote_client , event_loop ) : [EOL] [docstring] [EOL] async with authenticated_remote_client : [EOL] async with aiohttp . ClientSession ( loop = event_loop ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_remote ( TEST_EMAIL , TEST_PASSWORD ) [EOL] [EOL] assert len ( client . controllers ) == [number] [EOL] [EOL] controller = client . controllers [ TEST_MAC ] [EOL] assert controller . _access_token == TEST_ACCESS_TOKEN [EOL] assert controller . api_version == TEST_API_VERSION [EOL] assert controller . hardware_version == TEST_HW_VERSION [EOL] assert controller . mac == TEST_MAC [EOL] assert controller . name == TEST_NAME [EOL] assert controller . software_version == TEST_SW_VERSION [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_load_remote_skip ( aresponses , authenticated_remote_client ) : [EOL] [docstring] [EOL] authenticated_remote_client . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] authenticated_remote_client . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] async with authenticated_remote_client : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_remote ( TEST_EMAIL , TEST_PASSWORD , True ) [EOL] controller = client . controllers [ TEST_MAC ] [EOL] [EOL] await client . load_remote ( TEST_EMAIL , TEST_PASSWORD , True ) [EOL] assert len ( client . controllers ) == [number] [EOL] assert client . controllers [ TEST_MAC ] == controller [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_load_remote_failure ( aresponses ) : [EOL] [docstring] [EOL] aresponses . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] with pytest . raises ( RequestError ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_remote ( TEST_EMAIL , TEST_PASSWORD ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_remote_error_known ( aresponses ) : [EOL] [docstring] [EOL] aresponses . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] with pytest . raises ( RequestError ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_remote ( TEST_EMAIL , TEST_PASSWORD ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_remote_error_http_body ( aresponses ) : [EOL] [docstring] [EOL] aresponses . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] with pytest . raises ( RequestError ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_remote ( TEST_EMAIL , TEST_PASSWORD ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_remote_error_unknown ( aresponses ) : [EOL] [docstring] [EOL] aresponses . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] with pytest . raises ( RequestError ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_remote ( TEST_EMAIL , TEST_PASSWORD ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_request_timeout ( authenticated_local_client ) : [comment] [EOL] [docstring] [EOL] [EOL] async def long_running_login ( * args , ** kwargs ) : [comment] [EOL] [docstring] [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] with mock . patch . object ( aiohttp . ClientResponse , [string] , long_running_login ) : [EOL] async with authenticated_local_client : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] with pytest . raises ( RequestError ) : [EOL] client = Client ( session = session , request_timeout = [number] ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , port = TEST_PORT , ssl = False ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_token_expired_exception ( authenticated_local_client ) : [EOL] [docstring] [EOL] async with authenticated_local_client : [EOL] with pytest . raises ( TokenExpiredError ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , port = TEST_PORT , ssl = False ) [EOL] controller = next ( iter ( client . controllers . values ( ) ) ) [EOL] [EOL] controller . _access_token_expiration = datetime . now ( ) - timedelta ( hours = [number] ) [EOL] await controller . _request ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import regenmaschine [EOL] [docstring] [EOL] import aiohttp [EOL] import pytest [EOL] [EOL] from regenmaschine import Client [EOL] [EOL] from . common import TEST_HOST , TEST_PASSWORD , TEST_PORT , load_fixture [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_restrictions_current ( aresponses , authenticated_local_client ) : [EOL] [docstring] [EOL] async with authenticated_local_client : [EOL] authenticated_local_client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , port = TEST_PORT , ssl = False ) [EOL] controller = next ( iter ( client . controllers . values ( ) ) ) [EOL] [EOL] data = await controller . restrictions . current ( ) [EOL] assert data [ [string] ] is False [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_restrictions_global ( aresponses , authenticated_local_client ) : [EOL] [docstring] [EOL] async with authenticated_local_client : [EOL] authenticated_local_client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , port = TEST_PORT , ssl = False ) [EOL] controller = next ( iter ( client . controllers . values ( ) ) ) [EOL] [EOL] data = await controller . restrictions . universal ( ) [EOL] assert data [ [string] ] == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_restrictions_hourly ( aresponses , authenticated_local_client ) : [EOL] [docstring] [EOL] async with authenticated_local_client : [EOL] authenticated_local_client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , port = TEST_PORT , ssl = False ) [EOL] controller = next ( iter ( client . controllers . values ( ) ) ) [EOL] [EOL] data = await controller . restrictions . hourly ( ) [EOL] assert not data [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_restrictions_raindelay ( aresponses , authenticated_local_client ) : [EOL] [docstring] [EOL] async with authenticated_local_client : [EOL] authenticated_local_client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] client = Client ( session = session ) [EOL] await client . load_local ( TEST_HOST , TEST_PASSWORD , port = TEST_PORT , ssl = False ) [EOL] controller = next ( iter ( client . controllers . values ( ) ) ) [EOL] [EOL] data = await controller . restrictions . raindelay ( ) [EOL] assert data [ [string] ] == - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import aresponses [EOL] import pytest [EOL] [EOL] from . common import TEST_HOST , TEST_PORT , TEST_SPRINKLER_ID , load_fixture [EOL] [EOL] [EOL] @ pytest . fixture ( ) def authenticated_local_client ( ) : [EOL] [docstring] [EOL] client = aresponses . ResponsesMockServer ( ) [EOL] client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] client . add ( f"{ TEST_HOST } [string] { TEST_PORT }" , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] return client [EOL] [EOL] [EOL] @ pytest . fixture ( ) def authenticated_remote_client ( ) : [EOL] [docstring] [EOL] client = aresponses . ResponsesMockServer ( ) [EOL] client . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] client . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] client . add ( [string] , [string] , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] client . add ( [string] , f" [string] { TEST_SPRINKLER_ID } [string] " , [string] , aresponses . Response ( text = load_fixture ( [string] ) , status = [number] ) , ) [EOL] [EOL] return client [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Callable , Awaitable [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] [docstring] [EOL] import datetime [EOL] from typing import Awaitable , Callable [EOL] [EOL] [EOL] class Stats : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , request ) : [EOL] [docstring] [EOL] self . _request = request [EOL] [EOL] async def on_date ( self , date ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , f" [string] { date . strftime ( [string] ) }" ) [EOL] [EOL] async def upcoming ( self , details = False ) : [EOL] [docstring] [EOL] endpoint = [string] [EOL] key = [string] [EOL] if details : [EOL] endpoint += [string] [EOL] key = [string] [EOL] data = await self . _request ( [string] , endpoint ) [EOL] return data [ key ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 $builtins.dict$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 $builtins.str$ 0 0
from typing import Callable , Awaitable [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Awaitable , Callable [EOL] [EOL] [EOL] class Program : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , request ) : [EOL] [docstring] [EOL] self . _request = request [EOL] [EOL] async def _post ( self , program_id = None , json = None ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , f" [string] { program_id }" , json = json ) [EOL] [EOL] async def all ( self , include_inactive = False ) : [EOL] [docstring] [EOL] data = await self . _request ( [string] , [string] ) [EOL] return [ p for p in data [ [string] ] if include_inactive or p [ [string] ] ] [EOL] [EOL] async def disable ( self , program_id ) : [EOL] [docstring] [EOL] return await self . _post ( program_id , { [string] : False } ) [EOL] [EOL] async def enable ( self , program_id ) : [EOL] [docstring] [EOL] return await self . _post ( program_id , { [string] : True } ) [EOL] [EOL] async def get ( self , program_id ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , f" [string] { program_id }" ) [EOL] [EOL] async def next ( self ) : [EOL] [docstring] [EOL] data = await self . _request ( [string] , [string] ) [EOL] return data [ [string] ] [EOL] [EOL] async def running ( self ) : [EOL] [docstring] [EOL] data = await self . _request ( [string] , [string] ) [EOL] return data [ [string] ] [EOL] [EOL] async def start ( self , program_id ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , f" [string] { program_id } [string] " ) [EOL] [EOL] async def stop ( self , program_id ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , f" [string] { program_id } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 $builtins.list$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] class RainMachineError ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class RequestError ( RainMachineError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class TokenExpiredError ( RainMachineError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] ERROR_CODES = { [number] : [string] } [EOL] [EOL] [EOL] def raise_remote_error ( error_code ) : [EOL] [docstring] [EOL] try : [EOL] error = next ( ( v for k , v in ERROR_CODES . items ( ) if k == error_code ) ) [EOL] raise RequestError ( error ) [EOL] except StopIteration : [EOL] raise RequestError ( f" [string] { error_code }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Callable , Awaitable [EOL] import typing [EOL] import regenmaschine [EOL] import builtins [EOL] import datetime [EOL] [docstring] [EOL] [comment] [EOL] from datetime import datetime , timedelta [EOL] from typing import Awaitable , Callable , Optional [EOL] [EOL] from regenmaschine . api import API [EOL] from regenmaschine . diagnostics import Diagnostics [EOL] from regenmaschine . parser import Parser [EOL] from regenmaschine . program import Program [EOL] from regenmaschine . provision import Provision [EOL] from regenmaschine . restriction import Restriction [EOL] from regenmaschine . stats import Stats [EOL] from regenmaschine . watering import Watering [EOL] from regenmaschine . zone import Zone [EOL] [EOL] URL_BASE_LOCAL = [string] [EOL] URL_BASE_REMOTE = [string] [EOL] [EOL] [EOL] class Controller : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , request ) : [EOL] [docstring] [EOL] self . _access_token = None [EOL] self . _access_token_expiration = None [EOL] self . _client_request = request [EOL] self . _host = None [EOL] self . _ssl = True [EOL] self . api_version = None [EOL] self . hardware_version = None [EOL] self . mac = None [EOL] self . name = None [EOL] self . software_version = None [EOL] [EOL] [comment] [EOL] self . api = API ( self . _request ) [EOL] self . diagnostics = Diagnostics ( self . _request ) [EOL] self . parsers = Parser ( self . _request ) [EOL] self . programs = Program ( self . _request ) [EOL] self . provisioning = Provision ( self . _request ) [EOL] self . restrictions = Restriction ( self . _request ) [EOL] self . stats = Stats ( self . _request ) [EOL] self . watering = Watering ( self . _request ) [EOL] self . zones = Zone ( self . _request ) [EOL] [EOL] async def _request ( self , method , endpoint , * , headers = None , params = None , json = None , ssl = True , ) : [EOL] [docstring] [EOL] return await self . _client_request ( method , f"{ self . _host } [string] { endpoint }" , access_token = self . _access_token , access_token_expiration = self . _access_token_expiration , headers = headers , params = params , json = json , ssl = ssl , ) [EOL] [EOL] [EOL] class LocalController ( Controller ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , request , host , port , ssl ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( request ) [EOL] [EOL] self . _host = URL_BASE_LOCAL . format ( host , port ) [EOL] self . _ssl = ssl [EOL] [EOL] async def login ( self , password ) : [EOL] [docstring] [EOL] auth_resp = await self . _client_request ( [string] , f"{ self . _host } [string] " , json = { [string] : password , [string] : [number] } ) [EOL] [EOL] self . _access_token = auth_resp [ [string] ] [EOL] self . _access_token_expiration = datetime . now ( ) + timedelta ( seconds = int ( auth_resp [ [string] ] ) - [number] ) [EOL] [EOL] [EOL] class RemoteController ( Controller ) : [EOL] [docstring] [EOL] [EOL] async def login ( self , stage_1_access_token , sprinkler_id , password ) : [EOL] [docstring] [EOL] auth_resp = await self . _client_request ( [string] , [string] , access_token = stage_1_access_token , json = { [string] : sprinkler_id , [string] : password } , ) [EOL] [EOL] self . _access_token = auth_resp [ [string] ] [EOL] self . _host = URL_BASE_REMOTE . format ( sprinkler_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $regenmaschine.api.API$ 0 0 0 0 0 0 0 0 0 0 $regenmaschine.diagnostics.Diagnostics$ 0 0 0 0 0 0 0 0 0 0 $regenmaschine.parser.Parser$ 0 0 0 0 0 0 0 0 0 0 $regenmaschine.program.Program$ 0 0 0 0 0 0 0 0 0 0 $regenmaschine.provision.Provision$ 0 0 0 0 0 0 0 0 0 0 $regenmaschine.restriction.Restriction$ 0 0 0 0 0 0 0 0 0 0 $regenmaschine.stats.Stats$ 0 0 0 0 0 0 0 0 0 0 $regenmaschine.watering.Watering$ 0 0 0 0 0 0 0 0 0 0 $regenmaschine.zone.Zone$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.dict]$ 0 0 0 $typing.Optional[builtins.dict]$ 0 0 0 $typing.Optional[builtins.dict]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.dict]$ 0 $typing.Optional[builtins.dict]$ 0 $typing.Optional[builtins.dict]$ 0 $typing.Optional[builtins.dict]$ 0 $typing.Optional[builtins.dict]$ 0 $typing.Optional[builtins.dict]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
[docstring] [EOL] from . client import Client [comment] [EOL]	0 0 0 0 0 0 0 0 0
from typing import Callable , Awaitable [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] [docstring] [EOL] import datetime [EOL] from typing import Awaitable , Callable [EOL] [EOL] [EOL] class Watering : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , request ) : [EOL] [docstring] [EOL] self . _request = request [EOL] [EOL] async def log ( self , date = None , days = None , details = False ) : [EOL] [docstring] [EOL] endpoint = [string] [EOL] if details : [EOL] endpoint += [string] [EOL] [EOL] if date and days : [EOL] endpoint = f"{ endpoint } [string] { date . strftime ( [string] ) } [string] { days }" [EOL] [EOL] data = await self . _request ( [string] , endpoint ) [EOL] return data [ [string] ] [ [string] ] [EOL] [EOL] async def pause_all ( self , seconds ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , [string] , json = { [string] : seconds } ) [EOL] [EOL] async def queue ( self ) : [EOL] [docstring] [EOL] data = await self . _request ( [string] , [string] ) [EOL] return data [ [string] ] [EOL] [EOL] async def runs ( self , date = None , days = None ) : [EOL] [docstring] [EOL] endpoint = [string] [EOL] [EOL] if date and days : [EOL] endpoint = f"{ endpoint } [string] { date . strftime ( [string] ) } [string] { days }" [EOL] [EOL] data = await self . _request ( [string] , endpoint ) [EOL] return data [ [string] ] [EOL] [EOL] async def stop_all ( self ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , [string] ) [EOL] [EOL] async def unpause_all ( self ) : [EOL] [docstring] [EOL] return await self . pause_all ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 $builtins.list$ 0 0 0 $datetime.date$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 $datetime.date$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 $datetime.date$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $datetime.date$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Awaitable [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Awaitable , Callable [EOL] [EOL] [EOL] class Zone : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , request ) : [EOL] [docstring] [EOL] self . _request = request [EOL] [EOL] async def _post ( self , zone_id = None , json = None ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , f" [string] { zone_id } [string] " , json = json ) [EOL] [EOL] async def all ( self , * , details = False , include_inactive = False ) : [EOL] [docstring] [EOL] endpoint = [string] [EOL] if details : [EOL] endpoint += [string] [EOL] data = await self . _request ( [string] , endpoint ) [EOL] return [ z for z in data [ [string] ] if include_inactive or z [ [string] ] ] [EOL] [EOL] async def disable ( self , zone_id ) : [EOL] [docstring] [EOL] return await self . _post ( zone_id , { [string] : False } ) [EOL] [EOL] async def enable ( self , zone_id ) : [EOL] [docstring] [EOL] return await self . _post ( zone_id , { [string] : True } ) [EOL] [EOL] async def get ( self , zone_id , * , details = False ) : [EOL] [docstring] [EOL] endpoint = f" [string] { zone_id }" [EOL] if details : [EOL] endpoint += [string] [EOL] return await self . _request ( [string] , endpoint ) [EOL] [EOL] async def start ( self , zone_id , time ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , f" [string] { zone_id } [string] " , json = { [string] : time } ) [EOL] [EOL] async def stop ( self , zone_id ) : [EOL] [docstring] [EOL] return await self . _request ( [string] , f" [string] { zone_id } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 0 0 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 $typing.Callable[...,typing.Awaitable[builtins.dict]]$ 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0