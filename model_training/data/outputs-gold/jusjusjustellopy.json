[EOL] import builtins [EOL] from typing import Any [EOL] import tellopy [EOL] import typing [EOL] import argparse [EOL] import argparse [EOL] from time import sleep [EOL] import socket [EOL] [EOL] import matplotlib . pyplot as plt [EOL] import matplotlib . patches as patches [EOL] [EOL] [comment] [EOL] from tellopy . communications . config import Config [EOL] Config . drone_ip = [string] [EOL] Config . controller_port = [number] [EOL] Config . socket_config = socket . SOCK_STREAM [EOL] [EOL] from tellopy . speech import HotwordDetector [EOL] from tellopy . speech2sdk import Speech2sdk [EOL] from tellopy . communications . control import Control [EOL] [EOL] from tellopy . yolo . utils import prepare_tensor_for_imshow [EOL] from tellopy . yolo . detector import Detector [EOL] [EOL] Detector . weights_path = [string] [EOL] Detector . config_path = [string] [EOL] [EOL] detector = Detector ( ) [EOL] detector . conf_thres = [number] [EOL] detector . eval = True [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] speech_control = Speech2sdk ( args . test ) [EOL] speech_control . run_hotword_detector ( ) [EOL] [EOL] while True : [EOL] if hasattr ( speech_control , [string] ) and speech_control . video . frame is not None : [EOL] video = speech_control . video [EOL] break [EOL] sleep ( [number] ) [EOL] [EOL] plt . ion ( ) [EOL] fig , ax = plt . subplots ( [number] ) [EOL] plt . show ( block = False ) [EOL] img_obj = None [EOL] [EOL] while True : [EOL] x = video . frame [EOL] t = detector . prepare ( x ) [EOL] detections = detector ( t [ None , ... ] ) [EOL] img = prepare_tensor_for_imshow ( t ) [EOL] [comment] [EOL] if img_obj is None : [EOL] img_obj = ax . imshow ( img ) [EOL] else : [EOL] img_obj . set_data ( img ) [EOL] [EOL] for patch in ax . patches : [EOL] patch . remove ( ) [EOL] for text in ax . texts : [EOL] text . remove ( ) [EOL] [EOL] for detection in detections : [EOL] if detection is None : [EOL] continue [EOL] for det in detection : [EOL] x1 , y1 , x2 , y2 , conf , cls_conf , cls_pred = det . numpy ( ) [EOL] description = [string] % ( detector . classes [ int ( cls_pred ) ] , conf , cls_conf ) [EOL] bbox = patches . Rectangle ( ( x1 , y1 ) , x2 - x1 , y2 - y1 , linewidth = [number] , edgecolor = [string] , facecolor = [string] ) [EOL] [comment] [EOL] ax . add_patch ( bbox ) [EOL] [comment] [EOL] plt . text ( x1 , y1 , s = description , color = [string] , fontsize = [number] , verticalalignment = [string] , bbox = { [string] : [string] , [string] : [number] } ) [EOL] [EOL] fig . canvas . draw ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $tellopy.speech2sdk.Speech2sdk$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $tellopy.speech2sdk.Speech2sdk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tellopy.speech2sdk.Speech2sdk$ 0 0 0 0 $tellopy.speech2sdk.Speech2sdk$ 0 0 0 0 0 0 0 0 0 0 0 $tellopy.speech2sdk.Speech2sdk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import builtins [EOL] from typing import Any , Dict , Type , List [EOL] import tellopy [EOL] import typing [EOL] import logging [EOL] from terminaltables import AsciiTable [EOL] from PyQt5 . QtCore import QDateTime , Qt , QTimer [EOL] from PyQt5 . QtWidgets import QApplication , QDialog , QGridLayout , QPushButton [EOL] [EOL] [EOL] _inv_key_map = { val : key for key , val in Qt . __dict__ . items ( ) if key . startswith ( [string] ) } [EOL] [EOL] [EOL] class Keyboard : [EOL] [EOL] logger = logging . getLogger ( name = [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . registry = { } [EOL] [EOL] def register ( self , key , method ) : [EOL] key = [string] + key . upper ( ) [EOL] key = Qt . __dict__ [ key ] if isinstance ( key , str ) else key [EOL] assert key not in self . registry , [string] % ( key , self . registry . keys ( ) ) [EOL] self . registry [ key ] = method [EOL] [EOL] def keyPressEvent ( self , key ) : [EOL] try : [EOL] self . registry [ key ] ( ) [EOL] except : [EOL] self . logger . info ( [string] % ( key , self . registry . keys ( ) ) ) [EOL] [EOL] def registry_table ( self ) : [EOL] T = [ [ [string] , [string] ] ] [EOL] for key , method in self . registry . items ( ) : [EOL] T . append ( [ _inv_key_map . get ( key , key ) [ [number] : ] . lower ( ) , method . __name__ ] ) [EOL] return AsciiTable ( T ) . table [EOL] [EOL] def __str__ ( self ) : [EOL] s = [string] [EOL] s += self . registry_table ( ) [EOL] return s [EOL] [EOL] [EOL] [EOL] [EOL] class ButtonControl ( QDialog ) : [EOL] [EOL] _move_distance = [number] [EOL] _rotate_angle = [number] [EOL] [EOL] def __init__ ( self , control , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . keyboard = Keyboard ( ) [EOL] self . device = control [EOL] button_grid = self . create_button_grid ( ) [EOL] self . setLayout ( button_grid ) [EOL] [EOL] def keyPressEvent ( self , event ) : [EOL] super ( ) . keyPressEvent ( event ) [EOL] self . keyboard . keyPressEvent ( event . key ( ) ) [EOL] [EOL] def move_left ( self , * args , ** kwargs ) : [EOL] self . device . move_left ( self . _move_distance ) [EOL] [EOL] def move_right ( self , * args , ** kwargs ) : [EOL] self . device . move_right ( self . _move_distance ) [EOL] [EOL] def move_forward ( self , * args , ** kwargs ) : [EOL] self . device . move_forward ( self . _move_distance ) [EOL] [EOL] def move_backward ( self , * args , ** kwargs ) : [EOL] self . device . move_backward ( self . _move_distance ) [EOL] [EOL] def move_up ( self , * args , ** kwargs ) : [EOL] self . device . move_up ( self . _move_distance ) [EOL] [EOL] def move_down ( self , * args , ** kwargs ) : [EOL] self . device . move_down ( self . _move_distance ) [EOL] [EOL] def rotate_cw ( self , * args , ** kwargs ) : [EOL] self . device . rotate_cw ( self . _rotate_angle ) [EOL] [EOL] def rotate_ccw ( self , * args , ** kwargs ) : [EOL] self . device . rotate_ccw ( self . _rotate_angle ) [EOL] [EOL] def create_button_grid ( self ) : [EOL] button_grid = QGridLayout ( ) [EOL] [EOL] T = QPushButton ( [string] ) [EOL] La = QPushButton ( [string] ) [EOL] [EOL] L = QPushButton ( [string] ) [EOL] R = QPushButton ( [string] ) [EOL] F = QPushButton ( [string] ) [EOL] B = QPushButton ( [string] ) [EOL] [EOL] U = QPushButton ( [string] ) [EOL] D = QPushButton ( [string] ) [EOL] [EOL] CW = QPushButton ( [string] ) [EOL] CCW = QPushButton ( [string] ) [EOL] [EOL] La . clicked . connect ( self . device . land ) [EOL] self . keyboard . register ( [string] , self . device . land ) [EOL] T . clicked . connect ( self . device . takeoff ) [EOL] self . keyboard . register ( [string] , self . device . takeoff ) [EOL] [EOL] L . clicked . connect ( self . move_left ) [EOL] self . keyboard . register ( [string] , self . move_right ) [EOL] R . clicked . connect ( self . move_right ) [EOL] self . keyboard . register ( [string] , self . move_left ) [EOL] F . clicked . connect ( self . move_forward ) [EOL] self . keyboard . register ( [string] , self . move_forward ) [EOL] B . clicked . connect ( self . move_backward ) [EOL] self . keyboard . register ( [string] , self . move_backward ) [EOL] [EOL] U . clicked . connect ( self . move_up ) [EOL] self . keyboard . register ( [string] , self . move_up ) [EOL] D . clicked . connect ( self . move_down ) [EOL] self . keyboard . register ( [string] , self . move_down ) [EOL] [EOL] CW . clicked . connect ( self . rotate_cw ) [EOL] self . keyboard . register ( [string] , self . rotate_cw ) [EOL] CCW . clicked . connect ( self . rotate_ccw ) [EOL] self . keyboard . register ( [string] , self . rotate_ccw ) [EOL] [EOL] button_grid . addWidget ( T , [number] , [number] ) [EOL] button_grid . addWidget ( La , [number] , [number] ) [EOL] [EOL] button_grid . addWidget ( L , [number] , [number] ) [EOL] button_grid . addWidget ( F , [number] , [number] ) [EOL] button_grid . addWidget ( R , [number] , [number] ) [EOL] button_grid . addWidget ( B , [number] , [number] ) [EOL] [EOL] button_grid . addWidget ( U , [number] , [number] ) [EOL] button_grid . addWidget ( D , [number] , [number] ) [EOL] [EOL] button_grid . addWidget ( CW , [number] , [number] ) [EOL] button_grid . addWidget ( CCW , [number] , [number] ) [EOL] [EOL] return button_grid [EOL] [EOL] def show ( self ) : [EOL] super ( ) . show ( ) [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] from . mock import Mock [EOL] from . control import CommandControl [EOL] [EOL] try : [EOL] control = CommandControl ( ) [EOL] except : [EOL] print ( [string] ) [EOL] control = Mock ( ) [EOL] [EOL] [EOL] app = QApplication ( [ ] ) [EOL] buttons = ButtonControl ( control ) [EOL] buttons . show ( ) [EOL] print ( buttons . keyboard ) [EOL] app . exec_ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tellopy.__main__.Keyboard$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any , Dict [EOL] import typing [EOL] import argparse [EOL] from threading import Thread [EOL] [EOL] from tellopy . speech import HotwordDetector [EOL] from tellopy . communications . control import Control [EOL] from tellopy . communications . video import Video [EOL] from tellopy . communications . config import Config [EOL] [EOL] class Speech2sdk : [EOL] [EOL] cmd_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] def __init__ ( self , test = False ) : [EOL] self . initialize_control ( test ) [EOL] self . actions = { [string] : self . init_video , } [EOL] [EOL] def initialize_control ( self , test ) : [EOL] self . control = None if test else Control ( ) . init ( ) [EOL] [EOL] def init_video ( self ) : [EOL] self . video = Video ( [string] % ( Config . drone_ip , Config . video_port ) ) [EOL] self . video . start ( timeout = [number] , blocking = False ) [EOL] [EOL] def send_command ( self , txt ) : [EOL] txt = txt . lower ( ) . replace ( [string] , [string] ) [EOL] txt = self . cmd_map . get ( txt , txt ) [EOL] byts = txt . encode ( [string] ) [EOL] self . actions . get ( byts , lambda : None ) ( ) [EOL] if self . control is None : [EOL] return [string] [EOL] else : [EOL] return self . control . send ( byts ) [EOL] [EOL] def run_hotword_detector ( self ) : [EOL] self . speech = HotwordDetector ( lambda x : self . send_command ( x ) ) [EOL] self . speech . start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from . import yolo [EOL]	0 0 0 0 0 0
[EOL] from typing import Any , Callable , Dict , Type , Tuple [EOL] import builtins [EOL] import tellopy [EOL] import typing [EOL] import re [EOL] import socket [EOL] from threading import Thread [EOL] from subprocess import check_output [EOL] [EOL] from typing import Tuple , List , Dict , Any , Callable [EOL] [EOL] [comment] [EOL] from . config import Config [EOL] Config . drone_ip = [string] [EOL] Config . control_port = [number] [EOL] [EOL] class TelloProtocol : [EOL] [EOL] def __init__ ( self , conn ) : [EOL] self . conn = conn [EOL] self . data = [string] [EOL] [EOL] def send ( self , txt ) : [EOL] self . conn . sendall ( txt ) [EOL] [EOL] def recv ( self ) : [EOL] return self . conn . recvfrom ( [number] ) [EOL] [EOL] [EOL] class MockTello ( Thread ) : [EOL] [EOL] HOST = Config . drone_ip [EOL] PORT = Config . control_port [EOL] cmd_with_params_re = re . compile ( [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( target = self . listen ) [EOL] self . deamon = True [EOL] self . drone_initialized = False [EOL] self . stream_is_on = False [EOL] [comment] [EOL] self . actions = { [string] : self . init_tello , [string] : self . streamon } [EOL] [EOL] @ classmethod def addr ( cls ) : [EOL] return ( cls . HOST , cls . PORT ) [EOL] [EOL] def socket ( self ) : [EOL] return socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] [EOL] def listen ( self ) : [EOL] with self . socket ( ) as sock : [EOL] sock . bind ( self . addr ( ) ) [EOL] sock . listen ( ) [EOL] while True : [EOL] conn , addr = sock . accept ( ) [EOL] self . serve ( conn , addr ) [EOL] [EOL] def streamon ( self ) : [EOL] if not self . drone_initialized or self . stream_is_on : [EOL] return Config . ERROR [EOL] [EOL] def ffmpeg_stream ( ) : [EOL] check_output ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] % ( Config . drone_ip , Config . video_port ) ] ) [EOL] [EOL] self . video = Thread ( target = ffmpeg_stream ) [EOL] self . video . daemon = True [EOL] self . video . start ( ) [EOL] return Config . OK [EOL] [EOL] def init_tello ( self ) : [EOL] [docstring] [EOL] if self . drone_initialized : [EOL] return Config . ERROR [EOL] else : [EOL] self . drone_initialized = True [EOL] print ( [string] ) [EOL] return Config . OK [EOL] [EOL] def match_cmd_with_params ( self , msg ) : [EOL] matches = self . cmd_with_params_re . match ( msg ) [EOL] assert matches is not None [EOL] match = matches . group ( ) [EOL] assert len ( match ) == len ( msg ) [EOL] cmd , val = match . split ( [string] ) [EOL] return cmd , int ( val ) [EOL] [EOL] def process ( self , msg ) : [EOL] [docstring] [EOL] try : [EOL] msg_str = msg . decode ( [string] ) . rstrip ( [string] ) . rstrip ( [string] ) [EOL] except UnicodeDecodeError : [EOL] raise BrokenPipeError [EOL] try : [EOL] print ( [string] , msg_str ) [EOL] return self . actions [ msg_str ] ( ) [EOL] except KeyError : [EOL] print ( [string] , msg_str ) [EOL] [comment] [EOL] try : [EOL] cmd , val = self . match_cmd_with_params ( msg_str ) [EOL] return self . actions [ cmd ] ( int ( val ) ) [EOL] except ( AttributeError , AssertionError ) as err : [EOL] print ( err ) [EOL] return Config . ERROR [EOL] [EOL] def _serve ( self , conn ) : [EOL] while True : [EOL] try : [EOL] msg , addr = conn . recvfrom ( [number] ) [EOL] response = self . process ( msg ) [EOL] conn . sendall ( response ) [EOL] except BrokenPipeError : [EOL] raise ConnectionResetError ( [string] ) [EOL] [EOL] def serve ( self , conn , addr ) : [EOL] try : [EOL] with conn : [EOL] print ( [string] , addr ) [EOL] self . _serve ( conn ) [EOL] except ConnectionResetError as e : [EOL] print ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Callable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import tellopy [EOL] from time import sleep , time [EOL] from . abort_timer import AbortTimer [EOL] import pytest [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_abort_timer ( waiting_time ) : [EOL] t0 = time ( ) [EOL] timer = AbortTimer ( waiting_time ) [EOL] sleep ( waiting_time / [number] ) [EOL] assert timer . abort == False , [string] % ( time ( ) - t0 ) [EOL] sleep ( waiting_time / [number] ) [EOL] assert timer . abort == True , [string] % ( time ( ) - t0 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from typing import Any , Type , Tuple , List [EOL] import threading [EOL] import tellopy [EOL] import builtins [EOL] import socket [EOL] import typing [EOL] import socket [EOL] from threading import Thread [EOL] [EOL] from . config import Config [EOL] from . abort_timer import AbortTimer [EOL] [EOL] class Control : [EOL] [EOL] valid_commands = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] drone_addr = ( Config . drone_ip , Config . control_port ) [EOL] response_timeout = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] self . initialized = False [EOL] self . sock = socket . socket ( socket . AF_INET , Config . socket_config ) [EOL] [EOL] @ staticmethod def get_my_own_ip ( ) : [EOL] dummy_host = ( Config . drone_ip , Config . controller_port ) [EOL] with socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) as sock : [EOL] sock . connect ( dummy_host ) [EOL] ip = sock . getsockname ( ) [ [number] ] [EOL] assert ip . startswith ( Config . drone_ip [ : [number] ] ) , [string] % ip [EOL] return ip [EOL] [EOL] def init ( self ) : [EOL] addr = ( self . get_my_own_ip ( ) , Config . controller_port ) [EOL] print ( [string] , addr , [string] , self . drone_addr ) [EOL] try : [EOL] self . sock . bind ( addr ) [EOL] self . sock . connect ( self . drone_addr ) [EOL] except OSError as e : [EOL] msg = [string] % addr + str ( e ) [EOL] raise OSError ( msg ) [EOL] response = self . send ( [string] ) [EOL] self . initialized = response == Config . OK [EOL] return self [EOL] [EOL] def wait_for_response ( self ) : [EOL] [EOL] def listen ( ) : [EOL] while True : [EOL] try : [EOL] self . _response , ip = self . sock . recvfrom ( [number] ) [EOL] break [EOL] except Exception as e : [EOL] print ( [string] % e ) [EOL] self . _response = Config . ERROR [EOL] break [EOL] [EOL] receiver = Thread ( target = listen ) [EOL] receiver . deamon = True [EOL] self . _response = None [EOL] receiver . start ( ) [EOL] receiver . join ( self . response_timeout ) [EOL] [comment] [EOL] return Config . TIMEOUT if receiver . isAlive ( ) else self . _response [EOL] [EOL] def check_command ( self , cmd ) : [EOL] assert self . initialized or cmd == [string] [EOL] assert cmd in self . valid_commands , [string] % ( cmd , self . valid_commands ) [EOL] [EOL] def send ( self , cmd ) : [EOL] self . check_command ( cmd ) [EOL] self . sock . sendall ( cmd ) [EOL] response = self . wait_for_response ( ) [EOL] print ( self . drone_addr , [string] % cmd , response ) [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0
[EOL] import tellopy [EOL] import pytest [EOL] import numpy as np [EOL] from . video import Video [EOL] [EOL] def test_video ( ) : [EOL] video = Video ( [string] ) [EOL] assert video . running == False [EOL] video . start ( ) [EOL] assert video . running == True [EOL] f = video . frame [EOL] assert isinstance ( f , np . ndarray ) and f . shape [ [number] ] == [number] , str ( f ) [EOL] video . stop ( ) [EOL] assert video . running == False [EOL] video . start ( ) [EOL] assert video . running == True [EOL] f = video . frame [EOL] assert isinstance ( f , np . ndarray ) and f . shape [ [number] ] == [number] , str ( f ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import builtins [EOL] from typing import Any [EOL] import numpy [EOL] import tellopy [EOL] import typing [EOL] import av [EOL] import numpy as np [EOL] from time import sleep [EOL] from threading import Thread [EOL] from . abort_timer import AbortTimer [EOL] [EOL] def tensor_to_image ( t ) : [EOL] img = t . numpy ( ) [EOL] img = img . transpose ( [number] , [number] , [number] ) [EOL] img = img * [number] [EOL] return img . astype ( np . uint8 ) [EOL] [EOL] class Video : [EOL] [EOL] def __init__ ( self , url ) : [EOL] self . stop_signal_received = False [EOL] self . _frame = None [EOL] self . url = url [EOL] [EOL] @ property def container ( self ) : [EOL] try : [EOL] return self . _container [EOL] except AttributeError : [EOL] self . _container = av . open ( self . url ) [EOL] return self . container [EOL] [EOL] @ staticmethod def _image_to_numpy ( image ) : [EOL] byts = image . tobytes ( ) [EOL] img = np . frombuffer ( byts , dtype = [string] ) [EOL] img . shape = ( image . size [ [number] ] , image . size [ [number] ] , [number] ) [EOL] return img [EOL] [EOL] @ property def frame ( self ) : [EOL] try : [EOL] return self . _image_to_numpy ( self . _frame . to_image ( ) ) [EOL] except AttributeError : [EOL] return None [EOL] [EOL] def _read_frames_from_container ( self ) : [EOL] for self . _frame in self . container . decode ( video = [number] ) : [EOL] if self . stop_signal_received : [EOL] break [EOL] [EOL] def start ( self , timeout = [number] , blocking = True ) : [EOL] self . thread = Thread ( target = self . _read_frames_from_container ) [EOL] self . thread . daemon = True [EOL] self . stop_signal_received = False [EOL] self . thread . start ( ) [EOL] if blocking : [EOL] timer = AbortTimer ( timeout ) [EOL] while not timer . abort : [EOL] if self . frame is None : [EOL] sleep ( [number] ) [EOL] else : [EOL] break [EOL] else : [EOL] raise IOError [EOL] [EOL] def stop ( self ) : [EOL] self . stop_signal_received = True [EOL] self . thread . join ( ) [EOL] del self . thread [EOL] [EOL] @ property def running ( self ) : [EOL] return hasattr ( self , [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tellopy.communications.abort_timer.AbortTimer$ 0 0 0 0 0 0 0 0 $tellopy.communications.abort_timer.AbortTimer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Type [EOL] import builtins [EOL] import tellopy [EOL] import typing [EOL] import socket [EOL] [EOL] class Config : [EOL] [comment] [EOL] [comment] [EOL] drone_ip = [string] [EOL] control_port = [number] [EOL] controller_port = [number] [EOL] video_port = [number] [EOL] [comment] [EOL] [comment] [EOL] socket_config = socket . SOCK_DGRAM [EOL] [comment] [EOL] OK = [string] [EOL] ERROR = [string] [EOL] TIMEOUT = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0
[EOL] from threading import Timer [EOL] [EOL] class AbortTimer ( Timer ) : [EOL] [EOL] def __init__ ( self , timeout ) : [EOL] super ( ) . __init__ ( timeout , self . set_abort ) [EOL] self . abort = False [EOL] self . start ( ) [EOL] [EOL] def set_abort ( self ) : [EOL] self . abort = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Any [EOL] import typing [EOL] import torch [EOL] [EOL] [EOL] def check_cuda ( ) : [EOL] return torch . cuda . is_available ( ) [EOL] [EOL] [EOL] CUDA_AVAILABLE = check_cuda ( ) [EOL] [EOL] [EOL] def init_seeds ( seed = [number] ) : [EOL] torch . manual_seed ( seed ) [EOL] if CUDA_AVAILABLE : [EOL] torch . cuda . manual_seed ( seed ) [EOL] torch . cuda . manual_seed_all ( seed ) [EOL] [comment] [EOL] [EOL] [EOL] def select_device ( force_cpu = False ) : [EOL] if force_cpu : [EOL] device = torch . device ( [string] ) [EOL] else : [EOL] device = torch . device ( [string] if CUDA_AVAILABLE else [string] ) [EOL] return device [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any , Dict , List , Tuple [EOL] import io [EOL] import typing [EOL] import os [EOL] import onnx [EOL] from onnx import onnx_pb [EOL] from onnx_coreml import convert [EOL] import glob [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def main ( ) : [EOL] os . system ( [string] ) [EOL] files = glob . glob ( [string] ) + glob . glob ( [string] ) [EOL] [EOL] for f in files : [EOL] [comment] [EOL] name = [string] + f . split ( [string] ) [ - [number] ] . replace ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] model = onnx . load ( f ) [EOL] [EOL] [comment] [EOL] print ( onnx . checker . check_model ( model ) ) [EOL] [EOL] [comment] [EOL] print ( onnx . helper . printable_graph ( model . graph ) ) [EOL] [EOL] model_file = open ( f , [string] ) [EOL] model_proto = onnx_pb . ModelProto ( ) [EOL] model_proto . ParseFromString ( model_file . read ( ) ) [EOL] yolov3_model = convert ( model_proto , image_input_names = [ [string] ] , preprocessing_args = { [string] : [number] / [number] } ) [EOL] [EOL] [comment] [EOL] import coremltools [EOL] [EOL] spec = yolov3_model . get_spec ( ) [EOL] for i in range ( [number] ) : [EOL] spec . description . output [ i ] . type . multiArrayType . dataType = coremltools . proto . FeatureTypes_pb2 . ArrayFeatureType . ArrayDataType . Value ( [string] ) [EOL] [EOL] spec = coremltools . utils . convert_neural_network_spec_weights_to_fp16 ( spec ) [EOL] yolov3_model = coremltools . models . MLModel ( spec ) [EOL] [EOL] name_out0 = spec . description . output [ [number] ] . name [EOL] name_out1 = spec . description . output [ [number] ] . name [EOL] [EOL] num_classes = [number] [EOL] num_anchors = [number] [comment] [EOL] spec . description . output [ [number] ] . type . multiArrayType . shape . append ( num_anchors ) [EOL] spec . description . output [ [number] ] . type . multiArrayType . shape . append ( num_classes ) [EOL] [comment] [EOL] [EOL] spec . description . output [ [number] ] . type . multiArrayType . shape . append ( num_anchors ) [EOL] spec . description . output [ [number] ] . type . multiArrayType . shape . append ( [number] ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] spec . neuralNetwork . preprocessing [ [number] ] . featureName = [string] [EOL] [EOL] yolov3_model . save ( name + [string] ) [EOL] [comment] [EOL] print ( spec . description ) [EOL] [EOL] [comment] [EOL] from PIL import Image [EOL] img = Image . open ( [string] ) [EOL] out = yolov3_model . predict ( { [string] : img } , useCPUOnly = True ) [EOL] print ( out [ name_out0 ] . shape , out [ name_out1 ] . shape ) [EOL] [EOL] [comment] [EOL] import numpy as np [EOL] [EOL] nms_spec = coremltools . proto . Model_pb2 . Model ( ) [EOL] nms_spec . specificationVersion = [number] [EOL] [EOL] for i in range ( [number] ) : [EOL] decoder_output = yolov3_model . _spec . description . output [ i ] . SerializeToString ( ) [EOL] [EOL] nms_spec . description . input . add ( ) [EOL] nms_spec . description . input [ i ] . ParseFromString ( decoder_output ) [EOL] [EOL] nms_spec . description . output . add ( ) [EOL] nms_spec . description . output [ i ] . ParseFromString ( decoder_output ) [EOL] [EOL] nms_spec . description . output [ [number] ] . name = [string] [EOL] nms_spec . description . output [ [number] ] . name = [string] [EOL] [EOL] output_sizes = [ num_classes , [number] ] [EOL] for i in range ( [number] ) : [EOL] ma_type = nms_spec . description . output [ i ] . type . multiArrayType [EOL] ma_type . shapeRange . sizeRanges . add ( ) [EOL] ma_type . shapeRange . sizeRanges [ [number] ] . lowerBound = [number] [EOL] ma_type . shapeRange . sizeRanges [ [number] ] . upperBound = - [number] [EOL] ma_type . shapeRange . sizeRanges . add ( ) [EOL] ma_type . shapeRange . sizeRanges [ [number] ] . lowerBound = output_sizes [ i ] [EOL] ma_type . shapeRange . sizeRanges [ [number] ] . upperBound = output_sizes [ i ] [EOL] del ma_type . shape [ : ] [EOL] [EOL] nms = nms_spec . nonMaximumSuppression [EOL] nms . confidenceInputFeatureName = name_out0 [comment] [EOL] nms . coordinatesInputFeatureName = name_out1 [comment] [EOL] nms . confidenceOutputFeatureName = [string] [EOL] nms . coordinatesOutputFeatureName = [string] [EOL] nms . iouThresholdInputFeatureName = [string] [EOL] nms . confidenceThresholdInputFeatureName = [string] [EOL] [EOL] nms . iouThreshold = [number] [EOL] nms . confidenceThreshold = [number] [EOL] nms . pickTop . perClass = True [EOL] [EOL] labels = np . loadtxt ( [string] , dtype = str , delimiter = [string] ) [EOL] nms . stringClassLabels . vector . extend ( labels ) [EOL] [EOL] nms_model = coremltools . models . MLModel ( nms_spec ) [EOL] nms_model . save ( name + [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from coremltools . models import datatypes [EOL] [comment] [EOL] from coremltools . models . pipeline import Pipeline [EOL] [EOL] input_features = [ ( [string] , datatypes . Array ( [number] , [number] , [number] ) ) , ( [string] , datatypes . Double ( ) ) , ( [string] , datatypes . Double ( ) ) ] [EOL] [EOL] output_features = [ [string] , [string] ] [EOL] [EOL] pipeline = Pipeline ( input_features , output_features ) [EOL] [EOL] [comment] [EOL] yolov3_output = yolov3_model . _spec . description . output [EOL] yolov3_output [ [number] ] . type . multiArrayType . shape [ : ] = [ num_anchors , num_classes , [number] ] [EOL] yolov3_output [ [number] ] . type . multiArrayType . shape [ : ] = [ num_anchors , [number] , [number] ] [EOL] [EOL] nms_input = nms_model . _spec . description . input [EOL] for i in range ( [number] ) : [EOL] nms_input [ i ] . type . multiArrayType . shape [ : ] = yolov3_output [ i ] . type . multiArrayType . shape [ : ] [EOL] [EOL] [comment] [EOL] pipeline . add_model ( yolov3_model ) [EOL] [EOL] pipeline . add_model ( nms_model ) [EOL] [EOL] [comment] [EOL] pipeline . spec . description . input [ [number] ] . ParseFromString ( yolov3_model . _spec . description . input [ [number] ] . SerializeToString ( ) ) [EOL] pipeline . spec . description . output [ [number] ] . ParseFromString ( nms_model . _spec . description . output [ [number] ] . SerializeToString ( ) ) [EOL] pipeline . spec . description . output [ [number] ] . ParseFromString ( nms_model . _spec . description . output [ [number] ] . SerializeToString ( ) ) [EOL] [EOL] [comment] [EOL] pipeline . spec . description . metadata . versionString = [string] [EOL] pipeline . spec . description . metadata . shortDescription = [string] [EOL] pipeline . spec . description . metadata . author = [string] [EOL] pipeline . spec . description . metadata . license = [string] [EOL] [EOL] user_defined_metadata = { [string] : [string] . join ( labels ) , [string] : str ( nms . iouThreshold ) , [string] : str ( nms . confidenceThreshold ) } [EOL] pipeline . spec . description . metadata . userDefined . update ( user_defined_metadata ) [EOL] [EOL] [comment] [EOL] pipeline . spec . specificationVersion = [number] [EOL] final_model = coremltools . models . MLModel ( pipeline . spec ) [EOL] final_model . save ( ( name + [string] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from typing import Any , List [EOL] import builtins [EOL] import numpy [EOL] import torch [EOL] import typing [EOL] import torch [EOL] import random [EOL] import numpy as np [EOL] import torch . nn . functional as F [EOL] [EOL] from . import torch_utils [EOL] [EOL] from typing import List [EOL] [EOL] [comment] [EOL] torch . set_printoptions ( linewidth = [number] , precision = [number] , profile = [string] ) [EOL] [comment] [EOL] np . set_printoptions ( linewidth = [number] , formatter = { [string] : [string] . format } ) [EOL] [EOL] [EOL] def prepare_tensor_for_imshow ( t ) : [EOL] img = t . numpy ( ) [EOL] img = img . transpose ( [number] , [number] , [number] ) [EOL] img = img * [number] [EOL] return img . astype ( np . uint8 ) [EOL] [EOL] [EOL] def init_seeds ( seed = [number] ) : [EOL] random . seed ( seed ) [EOL] np . random . seed ( seed ) [EOL] torch_utils . init_seeds ( seed = seed ) [EOL] [EOL] [EOL] def load_classes ( path ) : [EOL] [docstring] [EOL] names = open ( path , [string] ) . read ( ) . split ( [string] ) [EOL] [comment] [EOL] return list ( filter ( None , names ) ) [EOL] [EOL] [EOL] def model_info ( model ) : [comment] [EOL] n_p = sum ( x . numel ( ) for x in model . parameters ( ) ) [comment] [EOL] n_g = sum ( x . numel ( ) for x in model . parameters ( ) if x . requires_grad ) [comment] [EOL] print ( [string] % ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) ) [EOL] for i , ( name , p ) in enumerate ( model . named_parameters ( ) ) : [EOL] name = name . replace ( [string] , [string] ) [EOL] print ( [string] % ( i , name , p . requires_grad , p . numel ( ) , list ( p . shape ) , p . mean ( ) , p . std ( ) ) ) [EOL] print ( [string] % ( i + [number] , n_p , n_g ) ) [EOL] [EOL] [EOL] def class_weights ( ) : [comment] [EOL] weights = [number] / torch . FloatTensor ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] weights /= weights . sum ( ) [EOL] return weights [EOL] [EOL] [EOL] def weights_init_normal ( m ) : [EOL] classname = m . __class__ . __name__ [EOL] if classname . find ( [string] ) != - [number] : [EOL] torch . nn . init . normal_ ( m . weight . data , [number] , [number] ) [EOL] elif classname . find ( [string] ) != - [number] : [EOL] torch . nn . init . normal_ ( m . weight . data , [number] , [number] ) [EOL] torch . nn . init . constant_ ( m . bias . data , [number] ) [EOL] [EOL] [EOL] def xyxy2xywh ( x ) : [comment] [EOL] y = torch . zeros ( x . shape ) if x . dtype is torch . float32 else np . zeros ( x . shape ) [EOL] y [ : , [number] ] = ( x [ : , [number] ] + x [ : , [number] ] ) / [number] [EOL] y [ : , [number] ] = ( x [ : , [number] ] + x [ : , [number] ] ) / [number] [EOL] y [ : , [number] ] = x [ : , [number] ] - x [ : , [number] ] [EOL] y [ : , [number] ] = x [ : , [number] ] - x [ : , [number] ] [EOL] return y [EOL] [EOL] [EOL] def xywh2xyxy ( x ) : [comment] [EOL] y = torch . zeros ( x . shape ) if x . dtype is torch . float32 else np . zeros ( x . shape ) [EOL] y [ : , [number] ] = ( x [ : , [number] ] - x [ : , [number] ] / [number] ) [EOL] y [ : , [number] ] = ( x [ : , [number] ] - x [ : , [number] ] / [number] ) [EOL] y [ : , [number] ] = ( x [ : , [number] ] + x [ : , [number] ] / [number] ) [EOL] y [ : , [number] ] = ( x [ : , [number] ] + x [ : , [number] ] / [number] ) [EOL] return y [EOL] [EOL] [EOL] def ap_per_class ( tp , conf , pred_cls , target_cls ) : [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] tp , conf , pred_cls , target_cls = np . array ( tp ) , np . array ( conf ) , np . array ( pred_cls ) , np . array ( target_cls ) [EOL] [EOL] [comment] [EOL] i = np . argsort ( - conf ) [EOL] tp , conf , pred_cls = tp [ i ] , conf [ i ] , pred_cls [ i ] [EOL] [EOL] [comment] [EOL] unique_classes = np . unique ( np . concatenate ( ( pred_cls , target_cls ) , [number] ) ) [EOL] [EOL] [comment] [EOL] ap , p , r = [ ] , [ ] , [ ] [EOL] for c in unique_classes : [EOL] i = pred_cls == c [EOL] n_gt = sum ( target_cls == c ) [comment] [EOL] n_p = sum ( i ) [comment] [EOL] [EOL] if ( n_p == [number] ) and ( n_gt == [number] ) : [EOL] continue [EOL] elif ( n_p == [number] ) or ( n_gt == [number] ) : [EOL] ap . append ( [number] ) [EOL] r . append ( [number] ) [EOL] p . append ( [number] ) [EOL] else : [EOL] [comment] [EOL] fpc = np . cumsum ( [number] - tp [ i ] ) [EOL] tpc = np . cumsum ( tp [ i ] ) [EOL] [EOL] [comment] [EOL] recall_curve = tpc / ( n_gt + [number] ) [EOL] r . append ( tpc [ - [number] ] / ( n_gt + [number] ) ) [EOL] [EOL] [comment] [EOL] precision_curve = tpc / ( tpc + fpc ) [EOL] p . append ( tpc [ - [number] ] / ( tpc [ - [number] ] + fpc [ - [number] ] ) ) [EOL] [EOL] [comment] [EOL] ap . append ( compute_ap ( recall_curve , precision_curve ) ) [EOL] [EOL] return np . array ( ap ) , unique_classes . astype ( [string] ) , np . array ( r ) , np . array ( p ) [EOL] [EOL] [EOL] def compute_ap ( recall , precision ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] mrec = np . concatenate ( ( [ [number] ] , recall , [ [number] ] ) ) [EOL] mpre = np . concatenate ( ( [ [number] ] , precision , [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] for i in range ( mpre . size - [number] , [number] , - [number] ) : [EOL] mpre [ i - [number] ] = np . maximum ( mpre [ i - [number] ] , mpre [ i ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] i = np . where ( mrec [ [number] : ] != mrec [ : - [number] ] ) [ [number] ] [EOL] [EOL] [comment] [EOL] ap = np . sum ( ( mrec [ i + [number] ] - mrec [ i ] ) * mpre [ i + [number] ] ) [EOL] return ap [EOL] [EOL] [EOL] def bbox_iou ( box1 , box2 , x1y1x2y2 = True ) : [EOL] [docstring] [EOL] if x1y1x2y2 : [EOL] [comment] [EOL] b1_x1 , b1_y1 , b1_x2 , b1_y2 = box1 [ : , [number] ] , box1 [ : , [number] ] , box1 [ : , [number] ] , box1 [ : , [number] ] [EOL] b2_x1 , b2_y1 , b2_x2 , b2_y2 = box2 [ : , [number] ] , box2 [ : , [number] ] , box2 [ : , [number] ] , box2 [ : , [number] ] [EOL] else : [EOL] [comment] [EOL] b1_x1 , b1_x2 = box1 [ : , [number] ] - box1 [ : , [number] ] / [number] , box1 [ : , [number] ] + box1 [ : , [number] ] / [number] [EOL] b1_y1 , b1_y2 = box1 [ : , [number] ] - box1 [ : , [number] ] / [number] , box1 [ : , [number] ] + box1 [ : , [number] ] / [number] [EOL] b2_x1 , b2_x2 = box2 [ : , [number] ] - box2 [ : , [number] ] / [number] , box2 [ : , [number] ] + box2 [ : , [number] ] / [number] [EOL] b2_y1 , b2_y2 = box2 [ : , [number] ] - box2 [ : , [number] ] / [number] , box2 [ : , [number] ] + box2 [ : , [number] ] / [number] [EOL] [EOL] [comment] [EOL] inter_rect_x1 = torch . max ( b1_x1 , b2_x1 ) [EOL] inter_rect_y1 = torch . max ( b1_y1 , b2_y1 ) [EOL] inter_rect_x2 = torch . min ( b1_x2 , b2_x2 ) [EOL] inter_rect_y2 = torch . min ( b1_y2 , b2_y2 ) [EOL] [comment] [EOL] inter_area = torch . clamp ( inter_rect_x2 - inter_rect_x1 , [number] ) * torch . clamp ( inter_rect_y2 - inter_rect_y1 , [number] ) [EOL] [comment] [EOL] b1_area = ( b1_x2 - b1_x1 ) * ( b1_y2 - b1_y1 ) [EOL] b2_area = ( b2_x2 - b2_x1 ) * ( b2_y2 - b2_y1 ) [EOL] [EOL] return inter_area / ( b1_area + b2_area - inter_area + [number] ) [EOL] [EOL] [EOL] def build_targets ( pred_boxes , pred_conf , pred_cls , target , anchor_wh , nA , nC , nG , batch_report ) : [EOL] [docstring] [EOL] nB = len ( target ) [comment] [EOL] nT = [ len ( x ) for x in target ] [comment] [EOL] tx = torch . zeros ( nB , nA , nG , nG ) [comment] [EOL] ty = torch . zeros ( nB , nA , nG , nG ) [EOL] tw = torch . zeros ( nB , nA , nG , nG ) [EOL] th = torch . zeros ( nB , nA , nG , nG ) [EOL] tconf = torch . ByteTensor ( nB , nA , nG , nG ) . fill_ ( [number] ) [EOL] tcls = torch . ByteTensor ( nB , nA , nG , nG , nC ) . fill_ ( [number] ) [comment] [EOL] TP = torch . ByteTensor ( nB , max ( nT ) ) . fill_ ( [number] ) [EOL] FP = torch . ByteTensor ( nB , max ( nT ) ) . fill_ ( [number] ) [EOL] FN = torch . ByteTensor ( nB , max ( nT ) ) . fill_ ( [number] ) [EOL] TC = torch . ShortTensor ( nB , max ( nT ) ) . fill_ ( - [number] ) [comment] [EOL] [EOL] for b in range ( nB ) : [EOL] nTb = nT [ b ] [comment] [EOL] if nTb == [number] : [EOL] continue [EOL] t = target [ b ] [EOL] [EOL] [comment] [EOL] TC [ b , : nTb ] , gx , gy , gw , gh = t [ : , [number] ] . long ( ) , t [ : , [number] ] * nG , t [ : , [number] ] * nG , t [ : , [number] ] * nG , t [ : , [number] ] * nG [EOL] [comment] [EOL] gi = torch . clamp ( gx . long ( ) , min = [number] , max = nG - [number] ) [EOL] gj = torch . clamp ( gy . long ( ) , min = [number] , max = nG - [number] ) [EOL] [EOL] [comment] [EOL] box1 = t [ : , [number] : [number] ] * nG [EOL] box2 = anchor_wh . unsqueeze ( [number] ) [EOL] inter_area = torch . min ( box1 , box2 ) . prod ( [number] ) [EOL] iou = inter_area / ( gw * gh + box2 . prod ( [number] ) - inter_area + [number] ) [EOL] [EOL] [comment] [EOL] iou_best , a = iou . max ( [number] ) [comment] [EOL] [EOL] [comment] [EOL] if nTb > [number] : [EOL] iou_order = torch . argsort ( - iou_best ) [comment] [EOL] [EOL] [comment] [EOL] u = torch . cat ( ( gi , gj , a ) , [number] ) . view ( [number] , - [number] ) [EOL] _ , first_unique = np . unique ( u [ : , iou_order ] , axis = [number] , return_index = True ) [comment] [EOL] [comment] [EOL] [EOL] i = iou_order [ first_unique ] [EOL] [comment] [EOL] i = i [ iou_best [ i ] > [number] ] [EOL] if len ( i ) == [number] : [EOL] continue [EOL] [EOL] a , gj , gi , t = a [ i ] , gj [ i ] , gi [ i ] , t [ i ] [EOL] if len ( t . shape ) == [number] : [EOL] t = t . view ( [number] , [number] ) [EOL] else : [EOL] if iou_best < [number] : [EOL] continue [EOL] i = [number] [EOL] [EOL] tc , gx , gy , gw , gh = t [ : , [number] ] . long ( ) , t [ : , [number] ] * nG , t [ : , [number] ] * nG , t [ : , [number] ] * nG , t [ : , [number] ] * nG [EOL] [EOL] [comment] [EOL] tx [ b , a , gj , gi ] = gx - gi . float ( ) [EOL] ty [ b , a , gj , gi ] = gy - gj . float ( ) [EOL] [EOL] [comment] [EOL] tw [ b , a , gj , gi ] = torch . log ( gw / anchor_wh [ a , [number] ] ) [EOL] th [ b , a , gj , gi ] = torch . log ( gh / anchor_wh [ a , [number] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] tcls [ b , a , gj , gi , tc ] = [number] [EOL] tconf [ b , a , gj , gi ] = [number] [EOL] [EOL] if batch_report : [EOL] [comment] [EOL] tb = torch . cat ( ( gx - gw / [number] , gy - gh / [number] , gx + gw / [number] , gy + gh / [number] ) ) . view ( [number] , - [number] ) . t ( ) [comment] [EOL] pcls = torch . argmax ( pred_cls [ b , a , gj , gi ] , [number] ) . cpu ( ) [EOL] pconf = torch . sigmoid ( pred_conf [ b , a , gj , gi ] ) . cpu ( ) [EOL] iou_pred = bbox_iou ( tb , pred_boxes [ b , a , gj , gi ] . cpu ( ) ) [EOL] [EOL] TP [ b , i ] = ( pconf > [number] ) & ( iou_pred > [number] ) & ( pcls == tc ) [EOL] FP [ b , i ] = ( pconf > [number] ) & ( TP [ b , i ] == [number] ) [comment] [EOL] FN [ b , i ] = pconf <= [number] [comment] [EOL] [EOL] return tx , ty , tw , th , tconf , tcls , TP , FP , FN , TC [EOL] [EOL] [EOL] def non_max_suppression ( prediction , conf_thres = [number] , nms_thres = [number] ) : [EOL] [docstring] [EOL] [EOL] output = [ None for _ in range ( len ( prediction ) ) ] [EOL] for image_i , pred in enumerate ( prediction ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] cross_class_nms = False [EOL] if cross_class_nms : [EOL] a = pred . clone ( ) [EOL] _ , indices = torch . sort ( - a [ : , [number] ] , [number] ) [comment] [EOL] a = a [ indices ] [EOL] radius = [number] [comment] [EOL] for i in range ( len ( a ) ) : [EOL] if i >= len ( a ) - [number] : [EOL] break [EOL] [EOL] close = ( torch . abs ( a [ i , [number] ] - a [ i + [number] : , [number] ] ) < radius ) & ( torch . abs ( a [ i , [number] ] - a [ i + [number] : , [number] ] ) < radius ) [EOL] close = close . nonzero ( ) [EOL] [EOL] if len ( close ) > [number] : [EOL] close = close + i + [number] [EOL] iou = bbox_iou ( a [ i : i + [number] , : [number] ] , a [ close . squeeze ( ) , : [number] ] . reshape ( - [number] , [number] ) , x1y1x2y2 = False ) [EOL] bad = close [ iou > nms_thres ] [EOL] [EOL] if len ( bad ) > [number] : [EOL] mask = torch . ones ( len ( a ) ) . type ( torch . ByteTensor ) [EOL] mask [ bad ] = [number] [EOL] a = a [ mask ] [EOL] pred = a [EOL] [EOL] class_prob , class_pred = torch . max ( F . softmax ( pred [ : , [number] : ] , [number] ) , [number] ) [EOL] [comment] [EOL] v = ( ( pred [ : , [number] ] > conf_thres ) & ( class_prob > [number] ) ) [EOL] v = v . nonzero ( ) . squeeze ( ) [EOL] if len ( v . shape ) == [number] : [EOL] v = v . unsqueeze ( [number] ) [EOL] [EOL] pred = pred [ v ] [EOL] class_prob = class_prob [ v ] [EOL] class_pred = class_pred [ v ] [EOL] [EOL] [comment] [EOL] nP = pred . shape [ [number] ] [EOL] if not nP : [EOL] continue [EOL] [EOL] [comment] [EOL] pred [ : , : [number] ] = xywh2xyxy ( pred [ : , : [number] ] ) [EOL] [EOL] [comment] [EOL] detections = torch . cat ( ( pred [ : , : [number] ] , class_prob . float ( ) . unsqueeze ( [number] ) , class_pred . float ( ) . unsqueeze ( [number] ) ) , [number] ) [EOL] [comment] [EOL] unique_labels = detections [ : , - [number] ] . cpu ( ) . unique ( ) [EOL] if prediction . is_cuda : [EOL] unique_labels = unique_labels . cuda ( prediction . device ) [EOL] [EOL] nms_style = [string] [comment] [EOL] for c in unique_labels : [EOL] [comment] [EOL] det_class = detections [ detections [ : , - [number] ] == c ] [EOL] [comment] [EOL] _ , conf_sort_index = torch . sort ( det_class [ : , [number] ] , descending = True ) [EOL] det_class = det_class [ conf_sort_index ] [EOL] [comment] [EOL] det_max = [ ] [EOL] [EOL] if nms_style == [string] : [comment] [EOL] while det_class . shape [ [number] ] : [EOL] [comment] [EOL] det_max . append ( det_class [ [number] ] . unsqueeze ( [number] ) ) [EOL] [comment] [EOL] if len ( det_class ) == [number] : [EOL] break [EOL] [comment] [EOL] ious = bbox_iou ( det_max [ - [number] ] , det_class [ [number] : ] ) [EOL] [EOL] [comment] [EOL] det_class = det_class [ [number] : ] [ ious < nms_thres ] [EOL] [EOL] elif nms_style == [string] : [comment] [EOL] while det_class . shape [ [number] ] : [EOL] if len ( det_class ) == [number] : [EOL] break [EOL] [EOL] ious = bbox_iou ( det_class [ : [number] ] , det_class [ [number] : ] ) [EOL] [EOL] if ious . max ( ) > [number] : [EOL] det_max . append ( det_class [ [number] ] . unsqueeze ( [number] ) ) [EOL] [EOL] [comment] [EOL] det_class = det_class [ [number] : ] [ ious < nms_thres ] [EOL] [EOL] if len ( det_max ) > [number] : [EOL] det_max = torch . cat ( det_max ) . data [EOL] [comment] [EOL] output [ image_i ] = det_max if output [ image_i ] is None else torch . cat ( ( output [ image_i ] , det_max ) ) [EOL] [EOL] return output [EOL] [EOL] [EOL] def strip_optimizer_from_checkpoint ( filename = [string] ) : [EOL] [docstring] [EOL] [EOL] import torch [EOL] a = torch . load ( filename , map_location = [string] ) [EOL] a [ [string] ] = [ ] [EOL] torch . save ( a , filename . replace ( [string] , [string] ) ) [EOL] [EOL] [EOL] def coco_class_count ( path = [string] ) : [EOL] [docstring] [EOL] import glob [EOL] [EOL] nC = [number] [comment] [EOL] x = np . zeros ( nC , dtype = [string] ) [EOL] files = sorted ( glob . glob ( [string] % path ) ) [EOL] for i , file in enumerate ( files ) : [EOL] labels = np . loadtxt ( file , dtype = np . float32 ) . reshape ( - [number] , [number] ) [EOL] x += np . bincount ( labels [ : , [number] ] . astype ( [string] ) , minlength = nC ) [EOL] print ( i , len ( files ) ) [EOL] [EOL] [EOL] def plot_results ( ) : [EOL] [docstring] [EOL] import glob [EOL] import numpy as np [EOL] import matplotlib . pyplot as plt [EOL] [comment] [EOL] [EOL] plt . figure ( figsize = ( [number] , [number] ) ) [EOL] s = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] files = sorted ( glob . glob ( [string] ) ) [EOL] for f in files : [EOL] results = np . loadtxt ( f , usecols = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) . T [comment] [EOL] n = results . shape [ [number] ] [EOL] for i in range ( [number] ) : [EOL] plt . subplot ( [number] , [number] , i + [number] ) [EOL] plt . plot ( range ( [number] , n ) , results [ i , [number] : ] , marker = [string] , label = f ) [EOL] plt . title ( s [ i ] ) [EOL] if i == [number] : [EOL] plt . legend ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $torch.FloatTensor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any , Dict , List [EOL] import builtins [EOL] import typing [EOL] import io [EOL] from typing import Dict , Any [EOL] [EOL] def parse_model_config ( path ) : [EOL] [docstring] [EOL] file = open ( path , [string] ) [EOL] lines = file . read ( ) . split ( [string] ) [EOL] lines = [ x for x in lines if x and not x . startswith ( [string] ) ] [EOL] lines = [ x . rstrip ( ) . lstrip ( ) for x in lines ] [comment] [EOL] module_defs = [ ] [EOL] for line in lines : [EOL] if line . startswith ( [string] ) : [comment] [EOL] module_defs . append ( { } ) [EOL] module_defs [ - [number] ] [ [string] ] = line [ [number] : - [number] ] . rstrip ( ) [EOL] if module_defs [ - [number] ] [ [string] ] == [string] : [EOL] module_defs [ - [number] ] [ [string] ] = [number] [EOL] else : [EOL] key , value = line . split ( [string] ) [EOL] value = value . strip ( ) [EOL] module_defs [ - [number] ] [ key . rstrip ( ) ] = value . strip ( ) [EOL] [EOL] return module_defs [EOL] [EOL] def parse_data_config ( path ) : [EOL] [docstring] [EOL] options = dict ( ) [EOL] options [ [string] ] = [string] [EOL] options [ [string] ] = [string] [EOL] with open ( path , [string] ) as fp : [EOL] for line in fp . readlines ( ) : [EOL] line = line . strip ( ) [EOL] if line == [string] or line . startswith ( [string] ) : [EOL] continue [EOL] key , value = line . split ( [string] ) [EOL] options [ key . strip ( ) ] = value . strip ( ) [EOL] return options [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from . hotword_detector import HotwordDetector [EOL]	0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , Tuple , List [EOL] import tellopy [EOL] import typing [EOL] from os . path import join , dirname , basename [EOL] import sys [EOL] from glob import glob [EOL] import struct [EOL] import argparse [EOL] import platform [EOL] from threading import Thread [EOL] from datetime import datetime [EOL] [EOL] import pyaudio [EOL] import soundfile [EOL] import numpy as np [EOL] [EOL] from . porcupine import Porcupine [EOL] [EOL] [EOL] class HotwordDetector ( Thread ) : [EOL] [docstring] [EOL] [EOL] keyword_file_dir = join ( dirname ( __file__ ) , [string] ) [EOL] [EOL] def __init__ ( self , callback , sensitivities = [number] , input_device_index = None ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . deamon = True [EOL] self . input_device_index = input_device_index [EOL] self . callback = callback [EOL] self . keyword_file_paths = glob ( join ( self . keyword_file_dir , [string] ) ) [EOL] if isinstance ( sensitivities , float ) : [EOL] self . sensitivities = [ sensitivities ] * len ( self . keyword_file_paths ) [EOL] else : [EOL] assert len ( self . sensitivities ) == len ( self . keyword_file_paths ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] keyword_names = [ basename ( x ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . split ( [string] ) [ [number] ] for x in self . keyword_file_paths ] [EOL] [EOL] print ( [string] ) [EOL] for keyword_name , sensitivity in zip ( keyword_names , self . sensitivities ) : [EOL] print ( [string] % ( keyword_name , sensitivity ) ) [EOL] [EOL] pa = None [EOL] porcupine = None [EOL] audio_stream = None [EOL] try : [EOL] porcupine = Porcupine ( keyword_file_paths = self . keyword_file_paths , sensitivities = self . sensitivities ) [EOL] [EOL] pa = pyaudio . PyAudio ( ) [EOL] audio_stream = pa . open ( rate = porcupine . sample_rate , channels = [number] , format = pyaudio . paInt16 , input = True , frames_per_buffer = porcupine . frame_length , input_device_index = self . input_device_index ) [EOL] [EOL] while True : [EOL] pcm = audio_stream . read ( porcupine . frame_length ) [EOL] pcm = struct . unpack_from ( [string] * porcupine . frame_length , pcm ) [EOL] [EOL] result = porcupine . process ( pcm ) [EOL] if result >= [number] : [EOL] self . callback ( keyword_names [ result ] ) [EOL] [EOL] except KeyboardInterrupt : [EOL] print ( [string] ) [EOL] finally : [EOL] if porcupine is not None : [EOL] porcupine . delete ( ) [EOL] [EOL] if audio_stream is not None : [EOL] audio_stream . close ( ) [EOL] [EOL] if pa is not None : [EOL] pa . terminate ( ) [EOL] [EOL] _AUDIO_DEVICE_INFO_KEYS = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] @ classmethod def show_audio_devices_info ( cls ) : [EOL] [docstring] [EOL] pa = pyaudio . PyAudio ( ) [EOL] for i in range ( pa . get_device_count ( ) ) : [EOL] info = pa . get_device_info_by_index ( i ) [EOL] print ( [string] . join ( [string] % ( k , str ( info [ k ] ) ) for k in cls . _AUDIO_DEVICE_INFO_KEYS ) ) [EOL] pa . terminate ( ) [EOL] [EOL] def _default_library_path ( ) : [EOL] return join ( dirname ( __file__ ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $tellopy.speech.porcupine.porcupine.Porcupine$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $tellopy.speech.porcupine.porcupine.Porcupine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $tellopy.speech.porcupine.porcupine.Porcupine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tellopy.speech.porcupine.porcupine.Porcupine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 $typing.Any$ 0 0 0 $tellopy.speech.porcupine.porcupine.Porcupine$ 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 $tellopy.speech.porcupine.porcupine.Porcupine$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Any$ 0 $tellopy.speech.porcupine.porcupine.Porcupine$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tellopy.speech.porcupine.porcupine.Porcupine$ 0 0 0 0 0 $tellopy.speech.porcupine.porcupine.Porcupine$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from . porcupine import Porcupine [EOL]	0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import pickle [EOL] import numpy as np [EOL] [EOL] class PickleProtocol : [EOL] [EOL] def __init__ ( self , conn ) : [EOL] self . conn = conn [EOL] self . data = [string] [EOL] [EOL] def send ( self , obj ) : [EOL] msg = pickle . dumps ( obj ) [EOL] msg = self . prefix_length ( msg ) [EOL] self . conn . sendall ( msg ) [EOL] [EOL] def recv ( self ) : [EOL] byts = self . read_bytes ( [number] ) [EOL] num_bytes = np . frombuffer ( byts , count = [number] , dtype = np . uint64 ) [ [number] ] [EOL] msg = self . read_bytes ( num_bytes ) [EOL] obj = pickle . loads ( msg ) [EOL] return obj [EOL] [EOL] @ staticmethod def prefix_length ( msg ) : [EOL] return np . uint64 ( len ( msg ) ) . tobytes ( ) + msg [EOL] [EOL] def _recv ( self ) : [EOL] self . data += self . conn . recv ( [number] ) [EOL] [EOL] def read_bytes ( self , n ) : [EOL] while len ( self . data ) < n : [EOL] self . _recv ( ) [EOL] byts = self . data [ : n ] [EOL] self . data = self . data [ n : ] [EOL] return byts [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0
[EOL] import tellopy [EOL] import socket [EOL] from . server import Server [EOL] from . pickle_protocol import PickleProtocol [EOL] [EOL] [EOL] class Client : [EOL] [EOL] def socket ( self ) : [EOL] return socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] [EOL] def connect ( self , sock ) : [EOL] sock . connect ( Server . addr ( ) ) [EOL] [EOL] @ classmethod def send ( cls , sock , obj ) : [EOL] protocol = PickleProtocol ( sock ) [EOL] protocol . send ( obj ) [EOL] return protocol . recv ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tellopy.server.pickle_protocol.PickleProtocol$ 0 0 0 0 0 0 $tellopy.server.pickle_protocol.PickleProtocol$ 0 0 0 0 0 0 0 $tellopy.server.pickle_protocol.PickleProtocol$ 0 0 0 0 0
	0
[EOL] from typing import Any [EOL] import tellopy [EOL] import typing [EOL] import pickle [EOL] import socket [EOL] import numpy as np [EOL] from . pickle_protocol import PickleProtocol [EOL] [EOL] [EOL] class Server : [EOL] [EOL] HOST = [string] [comment] [EOL] PORT = [number] [comment] [EOL] [EOL] @ classmethod def addr ( self ) : [EOL] return ( self . HOST , self . PORT ) [EOL] [EOL] def socket ( self ) : [EOL] return socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] [EOL] def listen ( self ) : [EOL] with self . socket ( ) as sock : [EOL] sock . bind ( self . addr ( ) ) [EOL] sock . listen ( ) [EOL] while True : [EOL] conn , addr = sock . accept ( ) [EOL] self . serve ( conn , addr ) [EOL] [EOL] def _serve ( self , conn ) : [EOL] with conn : [EOL] protocol = PickleProtocol ( conn ) [EOL] while True : [EOL] obj = protocol . recv ( ) [EOL] print ( [string] , obj ) [EOL] protocol . send ( obj ) [EOL] [EOL] def serve ( self , conn , addr ) : [EOL] try : [EOL] print ( [string] , addr ) [EOL] self . _serve ( conn ) [EOL] except ConnectionResetError as e : [EOL] print ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tellopy.server.pickle_protocol.PickleProtocol$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $tellopy.server.pickle_protocol.PickleProtocol$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $tellopy.server.pickle_protocol.PickleProtocol$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import tellopy [EOL] from . server import Server [EOL] [EOL] if __name__ == [string] : [EOL] s = Server ( ) [EOL] s . listen ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tellopy.server.server.Server$ 0 0 0 0 0 $tellopy.server.server.Server$ 0 0 0 0 0