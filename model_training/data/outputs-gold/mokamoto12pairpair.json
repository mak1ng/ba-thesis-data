import logging [EOL] [EOL] from src . interfaces . grpc . pairpair import serve [EOL] [EOL] if __name__ == [string] : [EOL] logging . basicConfig ( ) [EOL] serve ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import fire [EOL] [EOL] from src . interfaces . cli . pairpair import PairPair [EOL] [EOL] if __name__ == [string] : [EOL] fire . Fire ( PairPair ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import List [EOL] import typing [EOL] import src [EOL] from unittest import TestCase [EOL] [EOL] from src . domain . model . pair . history import EvaluationService [EOL] from src . domain . model . pair . pair import Member , Members , Pair , Pairs , PairTree [EOL] [EOL] [EOL] class PairTest ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . m1 = Member ( [string] ) [EOL] self . m2 = Member ( [string] ) [EOL] [EOL] def test_equals ( self ) : [EOL] self . assertEqual ( Pair ( self . m1 , self . m2 ) , Pair ( self . m1 , self . m2 ) ) [EOL] [EOL] def test_equals2 ( self ) : [EOL] self . assertEqual ( Pair ( self . m2 , self . m1 ) , Pair ( self . m1 , self . m2 ) ) [EOL] [EOL] def test_equals3 ( self ) : [EOL] self . assertEqual ( Pair ( self . m2 , None ) , Pair ( self . m2 , None ) ) [EOL] [EOL] [EOL] class PairsTest ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . pairs = Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) [EOL] [EOL] self . one_pairs = Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) ] ) [EOL] [EOL] self . empty_pairs = Pairs ( [ ] ) [EOL] [EOL] def test_getitem__pairs ( self ) : [EOL] self . assertEqual ( self . pairs [ [number] ] , Pair ( Member ( [string] ) , None ) ) [EOL] [EOL] def test_tail__pairs ( self ) : [EOL] self . assertEqual ( self . pairs . tail ( ) , Pairs ( [ Pair ( Member ( [string] ) , None ) ] ) ) [EOL] [EOL] def test_tail__one_pairs ( self ) : [EOL] self . assertEqual ( self . one_pairs . tail ( ) , Pairs ( [ ] ) ) [EOL] [EOL] def test_tail__empty_pairs ( self ) : [EOL] self . assertEqual ( self . one_pairs . tail ( ) , Pairs ( [ ] ) ) [EOL] [EOL] def test_in__pairs ( self ) : [EOL] self . assertTrue ( Pair ( Member ( [string] ) , None ) in self . pairs ) [EOL] [EOL] def test_have_same__pairs ( self ) : [EOL] self . assertTrue ( self . pairs . have_same ( Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ) ) [EOL] [EOL] def test_have_same__pairs2 ( self ) : [EOL] self . assertTrue ( not self . pairs . have_same ( Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ) ) [EOL] [EOL] [EOL] class PairTreeTest ( TestCase ) : [EOL] def test_fold ( self ) : [EOL] tree = PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) [EOL] self . assertEqual ( [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] , tree . fold ( ) ) [EOL] [EOL] def test_fold2 ( self ) : [EOL] tree = PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) ] ) [EOL] self . assertEqual ( [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] , tree . fold ( ) ) [EOL] [EOL] [EOL] class MembersTest ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . members = Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) [EOL] self . single_members = Members ( [ Member ( [string] ) ] ) [EOL] [EOL] def test_select_first_pairs ( self ) : [EOL] self . assertEqual ( self . members . select_first_pairs ( ) , [ ( Pair ( Member ( [string] ) , Member ( [string] ) ) , Members ( [ Member ( [string] ) ] ) ) , ( Pair ( Member ( [string] ) , Member ( [string] ) ) , Members ( [ Member ( [string] ) ] ) ) , ( Pair ( Member ( [string] ) , Member ( [string] ) ) , Members ( [ Member ( [string] ) ] ) ) ] ) [EOL] [EOL] def test_select_first_pairs_with_single_members ( self ) : [EOL] self . assertEqual ( self . single_members . select_first_pairs ( ) , [ ( Pair ( Member ( [string] ) , None ) , Members ( [ ] ) ) ] ) [EOL] [EOL] def test_combinations ( self ) : [EOL] self . assertEqual ( self . members . combinations ( ) , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) ] ) [EOL] [EOL] def test_possible_pair ( self ) : [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class EvaluationServiceTest ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . last_pairs3 = Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) [EOL] self . members3 = Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) [EOL] [EOL] self . last_pairs5 = Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) [EOL] self . members5 = Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) [EOL] [EOL] def test_filter ( self ) : [EOL] tree = self . members3 . combinations ( ) [EOL] filtered_tree = EvaluationService ( ) . pair_must_have_only_either_member_of_last_pair ( self . last_pairs3 , tree ) [EOL] self . assertEqual ( filtered_tree , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) ] ) [EOL] [EOL] def test_filter2 ( self ) : [EOL] tree = self . members5 . combinations ( ) [EOL] filtered_tree = EvaluationService ( ) . pair_must_have_only_either_member_of_last_pair ( self . last_pairs5 , tree ) [EOL] self . assertEqual ( filtered_tree , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) , PairTree ( Pair ( Member ( [string] ) , Member ( [string] ) ) , [ PairTree ( Pair ( Member ( [string] ) , None ) , [ ] ) ] ) ] ) ] ) [EOL] [EOL] def test_filter_and_empty ( self ) : [EOL] members = Members ( [ Member ( [string] ) , Member ( [string] ) ] ) [EOL] tree = members . combinations ( ) [EOL] filtered = EvaluationService ( ) . pair_must_have_only_either_member_of_last_pair ( Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) ] ) , tree ) [EOL] self . assertEqual ( filtered , [ ] ) [EOL] [EOL] def test_position_filter ( self ) : [EOL] history = [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] [EOL] tree = self . members3 . combinations ( ) [EOL] possible_pairs = PairTree . possible_pairs ( tree ) [EOL] filtered_tree = EvaluationService ( ) . member_is_must_not_in_same_position_at_three_times ( history , possible_pairs ) [EOL] self . assertEqual ( filtered_tree , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL] [EOL] def test_filter_same_pair ( self ) : [EOL] history = [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] [EOL] pairs = PairTree . possible_pairs ( self . members3 . combinations ( ) ) [EOL] filtered_pairs = EvaluationService ( ) . pair_should_not_exist_same_pair_in_near_history ( history , pairs ) [EOL] self . assertEqual ( filtered_pairs , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL] [EOL] def test_filter_same_pair2 ( self ) : [EOL] history = [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] [EOL] pairs = PairTree . possible_pairs ( self . members3 . combinations ( ) ) [EOL] filtered_pairs = EvaluationService ( ) . pair_should_not_exist_same_pair_in_near_history ( history , pairs ) [EOL] self . assertEqual ( filtered_pairs , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL] [EOL] def test_filter_same_pair3 ( self ) : [EOL] history = [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] [EOL] tree = self . members5 . combinations ( ) [EOL] s = EvaluationService ( ) [EOL] filtered_pairs = s . pair_should_not_exist_same_pair_in_near_history ( history , PairTree . possible_pairs ( s . pair_must_have_only_either_member_of_last_pair ( history [ - [number] ] , tree ) ) ) [EOL] self . assertEqual ( filtered_pairs , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL] [EOL] def test_evaluate ( self ) : [EOL] last_pairs = Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) [EOL] members = Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) [EOL] pairs = EvaluationService ( ) . evaluate ( [ last_pairs ] , members ) [EOL] self . assertEqual ( pairs , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , ] ) [EOL] [EOL] def test_evaluate_twice ( self ) : [EOL] history = [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] [EOL] members = Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) [EOL] pairs = EvaluationService ( ) . evaluate ( history , members ) [EOL] self . assertEqual ( pairs , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL] [EOL] def test_evaluate_three_times ( self ) : [EOL] history = [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] [EOL] members = Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) [EOL] pairs = EvaluationService ( ) . evaluate ( history , members ) [EOL] self . assertEqual ( pairs , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL] [EOL] def test_evaluate_four_times ( self ) : [EOL] history = [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] [EOL] members = Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) [EOL] pairs = EvaluationService ( ) . evaluate ( history , members ) [EOL] self . assertEqual ( pairs , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL] [EOL] def test_evaluate_five_times ( self ) : [EOL] history = [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] [EOL] members = Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) [EOL] pairs = EvaluationService ( ) . evaluate ( history , members ) [EOL] self . assertEqual ( pairs , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Member$ 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Member$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.PairTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.PairTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.PairTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.PairTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.EvaluationService$ 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $src.domain.model.pair.history.EvaluationService$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 $src.domain.model.pair.history.EvaluationService$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import List [EOL] import typing [EOL] import src [EOL] from unittest import TestCase [EOL] [EOL] from src . application . usecase . pair . pair import ( NextPairsByHistory , SavePairsHistory ) [EOL] from src . domain . model . pair . history import ( EvaluationService , PairsHistory , PairsHistoryId ) [EOL] from src . domain . model . pair . pair import Member , Members , Pair , Pairs [EOL] from src . infrastructure . persistence . pair . inmemory import InMemoryPairsHistoryRepository [EOL] [EOL] [EOL] class NextPairsByHistoryTest ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . repository = InMemoryPairsHistoryRepository ( ) [EOL] self . use_case = NextPairsByHistory ( self . repository , EvaluationService ( ) ) [EOL] [EOL] def test_run ( self ) : [EOL] pairs_list = self . use_case . run ( Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) ) [EOL] self . assertEqual ( pairs_list , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL] [EOL] def test_run_with_history ( self ) : [EOL] self . repository . save ( PairsHistory ( PairsHistoryId ( [string] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ) ) [EOL] [EOL] pairs_list = self . use_case . run ( Members ( [ Member ( [string] ) , Member ( [string] ) , Member ( [string] ) ] ) ) [EOL] self . assertEqual ( pairs_list , [ Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) , Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) ] ) [EOL] [EOL] [EOL] class SavePairsHistoryTest ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . repository = InMemoryPairsHistoryRepository ( ) [EOL] self . use_case = SavePairsHistory ( self . repository ) [EOL] [EOL] def test_run ( self ) : [EOL] save_pairs = Pairs ( [ Pair ( Member ( [string] ) , Member ( [string] ) ) , Pair ( Member ( [string] ) , None ) ] ) [EOL] self . use_case . run ( save_pairs ) [EOL] [EOL] self . assertEqual ( [ history . pairs for history in self . repository . list ] , [ save_pairs ] ) [EOL] self . assertEqual ( [ history . identity for history in self . repository . list ] , [ PairsHistoryId ( [string] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.infrastructure.persistence.pair.inmemory.InMemoryPairsHistoryRepository$ 0 0 0 0 0 0 0 $src.application.usecase.pair.pair.NextPairsByHistory$ 0 0 0 0 0 $src.infrastructure.persistence.pair.inmemory.InMemoryPairsHistoryRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.infrastructure.persistence.pair.inmemory.InMemoryPairsHistoryRepository$ 0 0 0 0 0 0 0 $src.application.usecase.pair.pair.SavePairsHistory$ 0 0 0 0 0 $src.infrastructure.persistence.pair.inmemory.InMemoryPairsHistoryRepository$ 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import src [EOL] from typing import List [EOL] [EOL] from src . domain . model . pair . pair import Members , Pairs [EOL] from src . registry . usecase import next_pairs_by_history , save_pairs_history [EOL] [EOL] [EOL] class PairPair : [EOL] def save ( self , * history ) : [EOL] [docstring] [EOL] [EOL] pairs = Pairs . from_list2 ( [ list ( h ) for h in history ] ) [EOL] save_pairs_history ( ) . run ( pairs ) [EOL] return str ( pairs ) [EOL] [EOL] def next ( self , * members ) : [EOL] [docstring] [EOL] [EOL] pairs_list = next_pairs_by_history ( ) . run ( Members . from_list ( list ( members ) ) ) [EOL] return pairs_list [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0
from typing import Any , List [EOL] import typing [EOL] import src [EOL] import resources [EOL] import time [EOL] from concurrent import futures [EOL] from typing import List [EOL] [EOL] import grpc [EOL] [EOL] from resources . protobuf import pair_pb2 , pair_pb2_grpc [EOL] from resources . protobuf . pair_pb2_grpc import PairServiceServicer [EOL] from src . domain . model . pair . pair import Members , Pairs [EOL] from src . infrastructure . serialize . protobuf . pair import ProtoBufPairSerializer [EOL] from src . registry . usecase import next_pairs_by_history , save_pairs_history [EOL] [EOL] [EOL] class PairService ( PairServiceServicer ) : [EOL] def SavePairsHistory ( self , request , context ) : [EOL] pairs = ProtoBufPairSerializer ( ) . load_pairs ( request ) [EOL] save_pairs_history ( ) . run ( pairs ) [EOL] return request [EOL] [EOL] def NextPairsByHistory ( self , request , context ) : [EOL] serializer = ProtoBufPairSerializer ( ) [EOL] members = serializer . load_members ( request ) [EOL] pairs_list = next_pairs_by_history ( ) . run ( members ) [EOL] return serializer . dump_possible_pairs ( pairs_list ) [EOL] [EOL] [EOL] def serve ( ) : [EOL] server = grpc . server ( futures . ThreadPoolExecutor ( max_workers = [number] ) ) [EOL] pair_pb2_grpc . add_PairServiceServicer_to_server ( PairService ( ) , server ) [EOL] server . add_insecure_port ( [string] ) [EOL] server . start ( ) [EOL] try : [EOL] while True : [EOL] time . sleep ( [number] * [number] * [number] ) [EOL] except KeyboardInterrupt : [EOL] server . stop ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Pairs$ 0 0 0 $resources.protobuf.pair_pb2.Pairs$ 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Pairs$ 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 $resources.protobuf.pair_pb2.Pairs$ 0 0 0 $resources.protobuf.pair_pb2.PossiblePairs$ 0 0 0 $resources.protobuf.pair_pb2.Members$ 0 0 0 0 0 $src.infrastructure.serialize.protobuf.pair.ProtoBufPairSerializer$ 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 $src.infrastructure.serialize.protobuf.pair.ProtoBufPairSerializer$ 0 0 0 $resources.protobuf.pair_pb2.Members$ 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 $src.infrastructure.serialize.protobuf.pair.ProtoBufPairSerializer$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import src [EOL] from src . domain . model . pair . history import ( EvaluationService , PairsHistoryRepository ) [EOL] from src . infrastructure . persistence . pair . sqlite3 import Sqlite3PairsHistoryRepository [EOL] [EOL] [EOL] def evaluation_service ( ) : [EOL] return EvaluationService ( ) [EOL] [EOL] [EOL] def pairs_history_repository ( ) : [EOL] return Sqlite3PairsHistoryRepository ( ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.EvaluationService$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistoryRepository$ 0 0 0 0 0 0 0 0 0 0 0
import src [EOL] from src . application . usecase . pair . pair import ( NextPairsByHistory , SavePairsHistory ) [EOL] from src . registry . domain import evaluation_service , pairs_history_repository [EOL] [EOL] [EOL] def next_pairs_by_history ( ) : [EOL] return NextPairsByHistory ( pairs_history_repository ( ) , evaluation_service ( ) ) [EOL] [EOL] [EOL] def save_pairs_history ( ) : [EOL] return SavePairsHistory ( pairs_history_repository ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.application.usecase.pair.pair.NextPairsByHistory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.application.usecase.pair.pair.SavePairsHistory$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import src [EOL] from typing import List [EOL] [EOL] from src . domain . model . pair . history import ( EvaluationService , PairsHistory , PairsHistoryRepository ) [EOL] from src . domain . model . pair . pair import Members , Pairs [EOL] [EOL] [EOL] class NextPairsByHistory : [EOL] pairs_repository = ... [EOL] evaluation_service = ... [EOL] [EOL] def __init__ ( self , pairs_repository , evaluation_service ) : [EOL] self . pairs_repository = pairs_repository [EOL] self . evaluation_service = evaluation_service [EOL] [EOL] def run ( self , members ) : [EOL] histories = self . pairs_repository . load ( ) [EOL] return self . evaluation_service . evaluate ( [ history . pairs for history in histories ] , members ) [EOL] [EOL] [EOL] class SavePairsHistory : [EOL] pairs_repository = ... [EOL] [EOL] def __init__ ( self , pairs_repository ) : [EOL] self . pairs_repository = pairs_repository [EOL] [EOL] def run ( self , pairs ) : [EOL] history_id = self . pairs_repository . next_identity ( ) [EOL] pairs_history = PairsHistory ( history_id , pairs ) [EOL] self . pairs_repository . save ( pairs_history ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistoryRepository$ 0 0 0 $src.domain.model.pair.history.EvaluationService$ 0 0 0 0 0 $None$ 0 0 0 $src.domain.model.pair.history.PairsHistoryRepository$ 0 $src.domain.model.pair.history.EvaluationService$ 0 0 0 0 0 $src.domain.model.pair.history.PairsHistoryRepository$ 0 $src.domain.model.pair.history.PairsHistoryRepository$ 0 0 0 $src.domain.model.pair.history.EvaluationService$ 0 $src.domain.model.pair.history.EvaluationService$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 $typing.List[src.domain.model.pair.history.PairsHistory]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.history.PairsHistory]$ 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistoryRepository$ 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistoryRepository$ 0 0 0 0 0 $src.domain.model.pair.history.PairsHistoryRepository$ 0 $src.domain.model.pair.history.PairsHistoryRepository$ 0 0 0 $None$ 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 $src.domain.model.pair.history.PairsHistoryId$ 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistory$ 0 0 0 $src.domain.model.pair.history.PairsHistoryId$ 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistory$ 0 0
from typing import List [EOL] import typing [EOL] import src [EOL] import resources [EOL] from typing import List [EOL] [EOL] from resources . protobuf import pair_pb2 [EOL] from src . domain . model . pair . pair import Member , Members , Pair , Pairs [EOL] [EOL] [EOL] class ProtoBufPairSerializer : [EOL] def load_member ( self , message ) : [EOL] return Member ( message . name ) [EOL] [EOL] def load_pair ( self , message ) : [EOL] return Pair ( self . load_member ( message . first ) , self . load_member ( message . second ) [EOL] if message . second is not None else None ) [EOL] [EOL] def load_pairs ( self , message ) : [EOL] return Pairs ( [ self . load_pair ( pair ) for pair in message . pairs ] ) [EOL] [EOL] def load_members ( self , message ) : [EOL] return Members ( [ self . load_member ( m ) for m in message . members ] ) [EOL] [EOL] def dump_member ( self , member ) : [EOL] return pair_pb2 . Member ( name = member . name ) [EOL] [EOL] def dump_pair ( self , pair ) : [EOL] return pair_pb2 . Pair ( first = self . dump_member ( pair . first ) , second = self . dump_member ( pair . second ) [EOL] if pair . second is not None else None ) [EOL] [EOL] def dump_pairs ( self , pairs ) : [EOL] return pair_pb2 . Pairs ( pairs = [ self . dump_pair ( pair ) for pair in pairs . list ] ) [EOL] [EOL] def dump_possible_pairs ( self , pairs_list ) : [EOL] return pair_pb2 . PossiblePairs ( pairs_list = [ self . dump_pairs ( pairs ) for pairs in pairs_list ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Member$ 0 0 0 $resources.protobuf.pair_pb2.Member$ 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Member$ 0 0 0 0 0 0 $src.domain.model.pair.pair.Pair$ 0 0 0 $resources.protobuf.pair_pb2.Pair$ 0 0 0 0 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Pair$ 0 0 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Pair$ 0 0 0 0 0 $resources.protobuf.pair_pb2.Pair$ 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 $resources.protobuf.pair_pb2.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Pairs$ 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Member.s$ 0 0 0 $resources.protobuf.pair_pb2.Members$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Members$ 0 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Member$ 0 0 0 $src.domain.model.pair.pair.Member$ 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Member$ 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Pair$ 0 0 0 $src.domain.model.pair.pair.Pair$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pair$ 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pair$ 0 0 0 0 0 $src.domain.model.pair.pair.Pair$ 0 0 0 0 0 0 0 0 0 0 0 $resources.protobuf.pair_pb2.Pairs$ 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 $resources.protobuf.pair_pb2.PossiblePairs$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0
from typing import List [EOL] import typing [EOL] import src [EOL] from typing import List [EOL] [EOL] from src . domain . model . pair . history import ( PairsHistory , PairsHistoryId , PairsHistoryRepository ) [EOL] [EOL] [EOL] class InMemoryPairsHistoryRepository ( PairsHistoryRepository ) : [EOL] cnt = ... [EOL] list = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . cnt = [number] [EOL] self . list = [ ] [EOL] [EOL] def next_identity ( self ) : [EOL] identity = PairsHistoryId ( str ( self . cnt ) ) [EOL] self . cnt += [number] [EOL] return identity [EOL] [EOL] def load ( self ) : [EOL] return self . list [EOL] [EOL] def save ( self , pairs_history ) : [EOL] self . list . append ( pairs_history ) [EOL] [EOL] def flush ( self ) : [EOL] self . list = [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[src.domain.model.pair.history.PairsHistory]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[src.domain.model.pair.history.PairsHistory]$ 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistory.Id$ 0 0 0 0 0 $src.domain.model.pair.history.PairsHistoryId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistoryId$ 0 0 0 $typing.List[src.domain.model.pair.history.PairsHistory]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $src.domain.model.pair.history.PairsHistory$ 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistory$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.history.PairsHistory]$ 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import src [EOL] import json [EOL] import sqlite3 [EOL] from datetime import datetime [EOL] from typing import List [EOL] from uuid import uuid4 [EOL] [EOL] from src . domain . model . pair . history import ( PairsHistory , PairsHistoryId , PairsHistoryRepository ) [EOL] from src . domain . model . pair . pair import Pairs [EOL] [EOL] [EOL] class Sqlite3PairsHistoryRepository ( PairsHistoryRepository ) : [EOL] db_name = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] self . conn = sqlite3 . connect ( self . db_name ) [EOL] self . cursor = self . conn . cursor ( ) [EOL] [EOL] def __del__ ( self ) : [EOL] self . conn . close ( ) [EOL] [EOL] def next_identity ( self ) : [EOL] return PairsHistoryId ( uuid4 ( ) . hex ) [EOL] [EOL] def save ( self , pairs_history ) : [EOL] self . cursor . execute ( [string] , ( pairs_history . identity . value , json . dumps ( pairs_history . pairs . to_list ( ) ) , str ( datetime . now ( ) ) ) ) [EOL] self . conn . commit ( ) [comment] [EOL] [EOL] def load ( self ) : [EOL] return [ PairsHistory ( PairsHistoryId ( l [ [number] ] ) , Pairs . from_list ( json . loads ( l [ [number] ] ) ) ) for l in list ( self . cursor . execute ( [string] ) ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistory.Id$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $src.domain.model.pair.history.PairsHistory$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistory$ 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.history.PairsHistory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.history.PairsHistory]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Optional , List , Tuple , Dict , Iterator [EOL] import typing [EOL] import builtins [EOL] import src [EOL] from itertools import combinations [EOL] from typing import Dict , Iterator , List , Optional , Tuple [EOL] [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass class Member : [EOL] name = ... [EOL] [EOL] [EOL] @ dataclass class Pair : [EOL] first = ... [EOL] second = ... [EOL] [EOL] def __contains__ ( self , item ) : [EOL] if not isinstance ( item , Member ) : [EOL] return False [EOL] return self . first == item or self . second == item [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Pair ) : [EOL] return False [EOL] return ( self . first == other . first and self . second == other . second ) or ( self . first == other . second and self . second == other . first ) [EOL] [EOL] def only_has_either ( self , other ) : [EOL] return ( self . first == other . first and self . second != other . second ) or ( self . first == other . second and self . second != other . first ) or ( self . second == other . first and self . first != other . second ) or ( self . second == other . second and self . first != other . first ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . first . name , [string] : self . second . name if self . second is not None else None } [EOL] [EOL] @ staticmethod def from_dict ( data ) : [EOL] if data [ [string] ] is None : [EOL] raise RuntimeError ( ) [EOL] [EOL] return Pair ( Member ( data [ [string] ] ) , Member ( data [ [string] ] ) if data [ [string] ] is not None else None ) [EOL] [EOL] [EOL] @ dataclass class Pairs : [EOL] list = ... [EOL] [EOL] def __iter__ ( self ) : [EOL] yield from self . list [EOL] [EOL] def __getitem__ ( self , item ) : [EOL] return self . list [ item ] [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . list ) [EOL] [EOL] def __contains__ ( self , item ) : [EOL] if not isinstance ( item , Pair ) : [EOL] return False [EOL] return item in self . list [EOL] [EOL] def tail ( self ) : [EOL] return Pairs ( self . list [ [number] : ] ) [EOL] [EOL] def prepend ( self , pair ) : [EOL] return Pairs ( [ pair , * self . list ] ) [EOL] [EOL] def merge ( self , other ) : [EOL] return Pairs ( self . list + other . list ) [EOL] [EOL] def have_same ( self , other ) : [EOL] return any ( map ( lambda self_pair , other_pair : self_pair == other_pair , self , other ) ) [EOL] [EOL] def to_list ( self ) : [EOL] return [ pair . to_dict ( ) for pair in self . list ] [EOL] [EOL] @ staticmethod def from_list ( list ) : [EOL] return Pairs ( [ Pair . from_dict ( d ) for d in list ] ) [EOL] [EOL] @ staticmethod def from_list2 ( data ) : [EOL] return Pairs ( [ Pair ( Member ( l [ [number] ] ) , Member ( l [ [number] ] ) if len ( l ) == [number] else None ) for l in data ] ) [EOL] [EOL] [EOL] @ dataclass class PairTree : [EOL] pair = ... [EOL] remainder = ... [EOL] [EOL] def fold ( self ) : [EOL] if not self . remainder : [EOL] return [ Pairs ( [ self . pair ] ) ] [EOL] [EOL] return [ pairs . prepend ( self . pair ) for pair_tree in self . remainder for pairs in pair_tree . fold ( ) ] [EOL] [EOL] @ staticmethod def possible_pairs ( trees ) : [EOL] return [ pairs for pair_tree in trees for pairs in pair_tree . fold ( ) ] [EOL] [EOL] [EOL] @ dataclass class Members : [EOL] list = ... [EOL] [EOL] def __iter__ ( self ) : [EOL] yield from self . list [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . list ) [EOL] [EOL] def remaining_members ( self , pair ) : [EOL] return Members ( [ member for member in self if member not in pair ] ) [EOL] [EOL] def select_first_pairs ( self ) : [EOL] if len ( self ) == [number] : [EOL] return [ ( None , Members ( [ ] ) ) ] [EOL] elif len ( self ) == [number] : [EOL] return [ ( Pair ( self . list [ [number] ] , None ) , Members ( [ ] ) ) ] [EOL] first_pairs = [ Pair ( a , b ) for a , b in combinations ( self , [number] ) ] [EOL] return [ ( pair , self . remaining_members ( pair ) ) for pair in first_pairs ] [EOL] [EOL] def combinations ( self ) : [EOL] [docstring] [EOL] return [ PairTree ( pair , remaining_members . combinations ( ) ) for pair , remaining_members in self . select_first_pairs ( ) if pair is not None ] [EOL] [EOL] def possible_pair ( self ) : [EOL] pass [EOL] [EOL] @ staticmethod def from_list ( data ) : [EOL] return Members ( [ Member ( l ) for l in data ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $Member$ 0 0 0 $typing.Optional[Member]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[Member]$ 0 0 0 0 0 0 0 $typing.Optional[Member]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Member]$ 0 0 0 0 0 $typing.Optional[Member]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $'Pair'$ 0 0 0 0 0 0 0 0 0 $'Pair'$ 0 0 0 0 0 0 0 $'Pair'$ 0 0 0 0 0 0 0 0 0 $'Pair'$ 0 0 0 0 0 0 0 $'Pair'$ 0 0 0 0 0 0 0 0 0 $'Pair'$ 0 0 0 0 0 0 0 $'Pair'$ 0 0 0 0 0 0 0 0 0 $'Pair'$ 0 0 0 0 0 0 0 $'Pair'$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Pair'$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Pair]$ 0 0 0 0 0 $typing.Iterator[Pair]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Pair$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $Pair$ 0 0 0 0 0 0 0 $Pair$ 0 0 0 0 0 0 0 0 0 $Pair$ 0 0 0 0 0 0 0 $'Pairs'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Pairs'$ 0 0 0 $Pair$ 0 0 0 0 0 0 0 $Pair$ 0 0 0 0 0 0 0 0 0 0 $'Pairs'$ 0 0 0 $'Pairs'$ 0 0 0 0 0 0 0 0 0 0 $'Pairs'$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $'Pairs'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Pairs'$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Pairs'$ 0 $typing.List[typing.Dict[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 $'Pairs'$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $Pair$ 0 0 0 $typing.List['PairTree']$ 0 0 0 0 0 $typing.List[Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Pairs]$ 0 $typing.List['PairTree']$ 0 0 0 0 0 0 0 0 0 $typing.List['PairTree']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Member]$ 0 0 0 0 0 $typing.Iterator[Member]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Members'$ 0 0 0 $Pair$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Pair$ 0 0 0 0 0 $typing.List[typing.Tuple[typing.Optional[Pair],'Members']]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pair]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pair]$ 0 0 0 0 $typing.List[PairTree]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 $'Members'$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import src [EOL] from abc import ABC , abstractmethod [EOL] from typing import List [EOL] [EOL] from dataclasses import dataclass [EOL] from src . domain . model . pair . pair import Members , Pairs , PairTree [EOL] [EOL] [EOL] @ dataclass class PairsHistoryId : [EOL] value = ... [EOL] [EOL] [EOL] class PairsHistory : [EOL] identity = ... [EOL] pairs = ... [EOL] [EOL] def __init__ ( self , identity , pairs ) : [EOL] self . identity = identity [EOL] self . pairs = pairs [EOL] [EOL] [EOL] class PairsHistoryRepository ( ABC ) : [EOL] @ abstractmethod def next_identity ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def save ( self , pairs_history ) : [EOL] pass [EOL] [EOL] @ abstractmethod def load ( self ) : [EOL] pass [EOL] [EOL] [EOL] class EvaluationService : [EOL] def evaluate ( self , history , members ) : [EOL] if not history : [EOL] return PairTree . possible_pairs ( members . combinations ( ) ) [EOL] [EOL] filtered_pair_trees = self . pair_must_have_only_either_member_of_last_pair ( history [ - [number] ] , members . combinations ( ) ) [EOL] [EOL] if not filtered_pair_trees : [EOL] filtered_pair_trees = members . combinations ( ) [EOL] [EOL] possible_pairs = PairTree . possible_pairs ( filtered_pair_trees ) [EOL] [EOL] possible_pairs = self . member_is_must_not_in_same_position_at_three_times ( history , possible_pairs ) [EOL] [EOL] good_pairs = possible_pairs [EOL] for i in range ( [number] , len ( history ) + [number] ) : [EOL] tmp = self . pair_should_not_exist_same_pair_in_near_history ( history [ - i : ] , possible_pairs ) [EOL] if not tmp : [EOL] break [EOL] else : [EOL] good_pairs = tmp [EOL] [EOL] return good_pairs [EOL] [EOL] def pair_must_have_only_either_member_of_last_pair ( self , last_pairs , pair_trees ) : [EOL] if not last_pairs : [EOL] return pair_trees [EOL] [EOL] return [ PairTree ( tree . pair , self . pair_must_have_only_either_member_of_last_pair ( last_pairs . tail ( ) , tree . remainder ) ) for tree in pair_trees if tree . pair . only_has_either ( last_pairs [ [number] ] ) and ( not last_pairs . tail ( ) or ( last_pairs . tail ( ) and self . pair_must_have_only_either_member_of_last_pair ( last_pairs . tail ( ) , tree . remainder ) ) ) ] [EOL] [EOL] def member_is_must_not_in_same_position_at_three_times ( self , history , possible_pairs ) : [EOL] if len ( history ) < [number] : [EOL] return possible_pairs [EOL] [EOL] def member_in_same_position_at_three_times ( pairs ) : [EOL] return any ( map ( lambda old_pair1 , old_pair2 , current_pair : ( current_pair . first in old_pair1 and current_pair . first in old_pair2 ) or ( current_pair . second in old_pair1 and current_pair . second in old_pair2 ) , history [ - [number] ] , history [ - [number] ] , pairs ) ) [EOL] [EOL] return [ pairs for pairs in possible_pairs if not member_in_same_position_at_three_times ( pairs ) ] [EOL] [EOL] def pair_should_not_exist_same_pair_in_near_history ( self , history , possible_pairs ) : [EOL] [EOL] return [ pairs for pairs in possible_pairs if all ( not pairs . have_same ( old_pairs ) for old_pairs in history ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $PairsHistoryId$ 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 $None$ 0 0 0 $src.domain.model.pair.history.PairsHistoryId$ 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 $src.domain.model.pair.history.PairsHistoryId$ 0 $src.domain.model.pair.history.PairsHistoryId$ 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $PairsHistoryId$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $PairsHistory$ 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 $src.domain.model.pair.pair.Members$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.PairTree]$ 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $builtins.bool$ 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.domain.model.pair.pair.Pairs$ 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[src.domain.model.pair.pair.Pairs]$ 0 0 0
	0
import sqlite3 [EOL] import sqlite3 [EOL] [EOL] db_name = [string] [EOL] [EOL] [EOL] def create_pairs_table ( cur ) : [EOL] cur . execute ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] connect = sqlite3 . connect ( db_name ) [EOL] cursor = connect . cursor ( ) [EOL] try : [EOL] create_pairs_table ( cursor ) [EOL] [EOL] connect . commit ( ) [EOL] except Exception as e : [EOL] connect . rollback ( ) [EOL] print ( e ) [EOL] finally : [EOL] connect . close ( ) [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Connection$ 0 0 0 $sqlite3.dbapi2.Connection$ 0 $builtins.str$ 0 0 $sqlite3.dbapi2.Cursor$ 0 $sqlite3.dbapi2.Connection$ 0 $sqlite3.dbapi2.Cursor$ 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 0 $sqlite3.dbapi2.Connection$ 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Connection$ 0 0 0 0 0