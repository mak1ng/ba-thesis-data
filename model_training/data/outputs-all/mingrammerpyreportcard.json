class Config : [EOL] try : [EOL] from config_secret import SecretConfig [EOL] SECRET_KEY = SecretConfig . SECRET_KEY [EOL] [comment] [EOL] MONGO_DBNAME = SecretConfig . MONGO_DBNAME [EOL] MONGO_HOST = SecretConfig . MONGO_HOST [EOL] MONGO_PORT = SecretConfig . MONGO_PORT [EOL] MONGO_URI = [string] . format ( MONGO_HOST , MONGO_PORT , MONGO_DBNAME ) [EOL] except ImportError : [EOL] SECRET_KEY = [string] [EOL] [comment] [EOL] MONGO_DBNAME = [string] [EOL] MONGO_HOST = [string] [EOL] MONGO_PORT = [number] [EOL] MONGO_URI = [string] . format ( MONGO_HOST , MONGO_PORT , MONGO_DBNAME ) [EOL] [EOL] [comment] [EOL] CLONE_TMP_DIR = [string] [EOL] CLONE_TIMEOUT = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0
[comment] [EOL] import argparse [EOL] from argparse import ArgumentParser [EOL] [EOL] from app import app [EOL] [EOL] if __name__ == [string] : [EOL] parser = ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = False , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = False , help = [string] , ) [EOL] arguments = parser . parse_args ( ) [EOL] app . run ( ** vars ( arguments ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0
	0
[docstring] [EOL] ERROR_CLONE_TIMEOUT_EXPIRED = [string] [EOL] ERROR_CLONE_FAILED = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import os [EOL] import shutil [EOL] import unittest [EOL] [EOL] from config import Config [EOL] from db . collection import get_repo_collection [EOL] from vcs . repository import cache , clear , clone , create_repository , is_cached , parse_url [EOL] [EOL] [EOL] class RepositoryTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . repositories = get_repo_collection ( ) [EOL] self . repo = create_repository ( [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . repositories . delete_one ( { [string] : self . repo . url } ) [EOL] if os . path . isdir ( Config . CLONE_TMP_DIR ) : [EOL] cloned_path = os . path . join ( Config . CLONE_TMP_DIR , self . repo . name ) [EOL] if os . path . isdir ( cloned_path ) : [EOL] shutil . rmtree ( cloned_path ) [EOL] else : [EOL] shutil . rmtree ( Config . CLONE_TMP_DIR ) [EOL] [EOL] def test_parse_url ( self ) : [EOL] testcases = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } ] [EOL] for tc in testcases : [EOL] username , name = parse_url ( tc [ [string] ] ) [EOL] self . assertEqual ( name , tc [ [string] ] ) [EOL] self . assertEqual ( username , tc [ [string] ] ) [EOL] [EOL] def test_parse_url_fail ( self ) : [EOL] testcases = [ [string] , [string] ] [EOL] for tc in testcases : [EOL] with self . assertRaises ( Exception ) : [EOL] parse_url ( tc ) [EOL] [EOL] def test_create_repository ( self ) : [EOL] testcases = [ { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , } ] [EOL] for tc in testcases : [EOL] repo = create_repository ( tc [ [string] ] ) [EOL] self . assertEqual ( repo . url , tc [ [string] ] ) [EOL] self . assertEqual ( repo . name , tc [ [string] ] ) [EOL] self . assertEqual ( repo . username , tc [ [string] ] ) [EOL] [EOL] def test_cache ( self ) : [EOL] cache ( self . repo ) [EOL] repo_doc = self . repositories . find_one ( { [string] : self . repo . url } ) [EOL] self . assertEqual ( repo_doc [ [string] ] , self . repo . url ) [EOL] self . assertEqual ( repo_doc [ [string] ] , self . repo . name ) [EOL] self . assertEqual ( repo_doc [ [string] ] , self . repo . username ) [EOL] self . assertNotEqual ( repo_doc [ [string] ] , None ) [EOL] [EOL] def test_is_cache ( self ) : [EOL] self . assertEqual ( is_cached ( self . repo ) , False ) [EOL] cache ( self . repo ) [EOL] self . assertEqual ( is_cached ( self . repo ) , True ) [EOL] [EOL] def test_clone ( self ) : [EOL] cloned_path = clone ( self . repo ) [EOL] self . assertEqual ( cloned_path , os . path . join ( Config . CLONE_TMP_DIR , self . repo . name ) ) [EOL] [EOL] def test_clone_fail ( self ) : [EOL] self . repo . url = [string] [EOL] with self . assertRaises ( Exception ) : [EOL] clone ( self . repo . url ) [EOL] [EOL] def test_clear ( self ) : [EOL] parent_dir = [string] [EOL] child_dir = [string] [EOL] os . mkdir ( parent_dir ) [EOL] os . mkdir ( os . path . join ( parent_dir , child_dir ) ) [EOL] clear ( parent_dir ) [EOL] self . assertEqual ( os . path . isdir ( parent_dir ) , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from pymongo import MongoClient [EOL] [EOL] from config import Config [EOL] [EOL] [EOL] def get_repo_collection ( ) : [EOL] [docstring] [EOL] client = MongoClient ( Config . MONGO_HOST , Config . MONGO_PORT ) [EOL] db = client [ Config . MONGO_DBNAME ] [EOL] repositories = db [ [string] ] [EOL] return repositories [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import argparse [EOL] from argparse import ArgumentParser [EOL] [EOL] from analyzer import analyze [EOL] from cli . formatting import format_results [EOL] [EOL] if __name__ == [string] : [EOL] parser = ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , default = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = False , help = [string] ) [EOL] arguments = parser . parse_args ( ) [EOL] path = arguments . directory [EOL] results = analyze ( path ) [EOL] print ( format_results ( results , verbose = arguments . verbose ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0
from typing import Any , List , Tuple , Generator [EOL] import typing [EOL] [docstring] [EOL] [EOL] INDENT_PREFIX = [string] [EOL] [EOL] [EOL] def format_results ( results , verbose = False ) : [EOL] [docstring] [EOL] text = [string] [string] % ( results [ [string] ] , results [ [string] ] [ [string] ] , ) [EOL] [EOL] lines = [ text ] [EOL] for key , result in sorted ( results . items ( ) ) : [EOL] if key in { [string] , [string] } : [EOL] continue [EOL] [EOL] score = result . get ( [string] ) [EOL] if score is None : [EOL] if next ( iter ( result . values ( ) ) ) : [EOL] score = [number] [EOL] else : [EOL] score = [number] [EOL] [EOL] lines . append ( [string] % ( key , score ) ) [EOL] [EOL] if verbose : [EOL] error_list = result . get ( [string] , tuple ( ) ) [EOL] sorted_errors = ( ( err [ [string] ] , int ( err [ [string] ] ) , err [ [string] ] . strip ( ) ) for err in error_list ) [EOL] previous_filename = None [EOL] for filename , line_nb , msg in sorted_errors : [EOL] if filename != previous_filename : [EOL] lines . append ( [string] % ( INDENT_PREFIX , filename ) ) [EOL] previous_filename = filename [EOL] lines . append ( [string] % ( INDENT_PREFIX , INDENT_PREFIX , line_nb , msg ) ) [EOL] [EOL] return [string] . join ( lines ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import flask [EOL] import typing [EOL] from flask import Flask [EOL] from flask_pymongo import PyMongo [EOL] from config import Config [EOL] [EOL] app = Flask ( __name__ ) [EOL] app . config . from_object ( Config ) [EOL] [EOL] [comment] [EOL] mongo = PyMongo ( app ) [EOL] [EOL] from . report . views import * [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from flask import flash , redirect , render_template , request , url_for [EOL] [EOL] from analyzer import analyze [EOL] from app import app , mongo [EOL] from vcs . repository import ( cache , clear , clone , create_repository , is_cached , parse_url ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def index ( ) : [EOL] return render_template ( [string] ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def about ( ) : [EOL] return render_template ( [string] ) [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def check ( ) : [EOL] url = request . form [ [string] ] [EOL] try : [EOL] parse_url ( url ) [EOL] return redirect ( url_for ( [string] , repo_url = url ) ) [EOL] except ValueError : [EOL] flash ( [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def report ( repo_url ) : [EOL] repo = create_repository ( repo_url ) [EOL] if repo is None : [EOL] flash ( [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] if is_cached ( repo ) : [EOL] results = mongo . db . repositories . find_one ( { [string] : repo . url } ) [EOL] else : [EOL] path = clone ( repo ) [EOL] [EOL] results = analyze ( path ) [EOL] repo . save_analysis_results ( results ) [EOL] [EOL] cache ( repo ) [EOL] clear ( path ) [EOL] [EOL] results = repo . to_document ( ) [EOL] return render_template ( [string] , report = results ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import os [EOL] [EOL] from analyzer . report import Grade [EOL] [EOL] [EOL] class ReadmeAnalyzer ( Grade ) : [EOL] [docstring] [EOL] [EOL] README_PATTERN = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] weight = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] self . has_readme = False [EOL] [EOL] def calculate_score ( self ) : [EOL] [docstring] [EOL] self . score = [number] if self . has_readme else [number] [EOL] [EOL] def run ( self , path ) : [EOL] [docstring] [EOL] for _ , _ , filenames in os . walk ( path ) : [EOL] for filename in filenames : [EOL] if filename . lower ( ) in self . README_PATTERN : [EOL] self . has_readme = True [EOL] return [EOL] [EOL] def to_document ( self ) : [EOL] [docstring] [EOL] return { [string] : { [string] : self . has_readme } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Dict [EOL] import subprocess [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import subprocess [EOL] [EOL] from analyzer . report import Grade [EOL] [EOL] [EOL] class LintError : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , location , line , message ) : [EOL] self . location = location [EOL] self . line = line [EOL] self . message = message [EOL] [EOL] def to_document ( self ) : [EOL] [docstring] [EOL] return { [string] : self . location , [string] : self . line , [string] : self . message } [EOL] [EOL] [EOL] class LintAnalyzer ( Grade ) : [EOL] [docstring] [EOL] document_name = [string] [EOL] message_column = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] self . lint_error_list = [ ] [EOL] [EOL] def _parse_lint_message ( self , line ) : [EOL] [docstring] [EOL] tokenized_by_colon = line . split ( [string] ) [EOL] location = tokenized_by_colon [ [number] ] [EOL] if location . startswith ( [string] ) : [EOL] location = location [ [number] : ] [EOL] line = tokenized_by_colon [ [number] ] [EOL] message = tokenized_by_colon [ self . message_column : ] [EOL] return location , line , [string] . join ( message ) [EOL] [EOL] def _save_lint_results ( self , output ) : [EOL] [docstring] [EOL] if output : [EOL] for line in output . decode ( ) . split ( [string] ) [ : - [number] ] : [EOL] self . lint_error_list . append ( LintError ( * self . _parse_lint_message ( line ) ) ) [EOL] [EOL] def calculate_score ( self , total_line_count ) : [EOL] [docstring] [EOL] self . score = int ( [number] * ( ( total_line_count - len ( self . lint_error_list ) ) / total_line_count ) ) [EOL] [EOL] def to_document ( self ) : [EOL] [docstring] [EOL] error_list = [ err . to_document ( ) for err in self . lint_error_list ] [EOL] document = { self . document_name : { [string] : error_list , [string] : self . score } } [EOL] return document [EOL] [EOL] [EOL] class PEP8LintAnalyzer ( LintAnalyzer ) : [EOL] [docstring] [EOL] document_name = [string] [EOL] weight = [number] [EOL] message_column = [number] [EOL] [EOL] def run ( self , path ) : [EOL] [docstring] [EOL] proc = subprocess . Popen ( [ [string] , [string] ] , stdout = subprocess . PIPE , cwd = path ) [EOL] output , _ = proc . communicate ( ) [EOL] self . _save_lint_results ( output ) [EOL] [EOL] [EOL] class PyflakesLintAnalyzer ( LintAnalyzer ) : [EOL] [docstring] [EOL] document_name = [string] [EOL] weight = [number] [EOL] [EOL] def run ( self , path ) : [EOL] [docstring] [EOL] proc = subprocess . Popen ( [ [string] , [string] ] , stdout = subprocess . PIPE , cwd = path ) [EOL] output , _ = proc . communicate ( ) [EOL] self . _save_lint_results ( output ) [EOL] [EOL] [EOL] class MyPyAnalyser ( LintAnalyzer ) : [EOL] [docstring] [EOL] document_name = [string] [EOL] weight = [number] [EOL] [EOL] def run ( self , path ) : [EOL] [docstring] [EOL] cmd = [ [string] , [string] , [string] ] [EOL] for folder , _ , filenames in os . walk ( path ) : [EOL] for filename in filenames : [EOL] if filename . lower ( ) . endswith ( [string] ) : [EOL] cmd . append ( [string] . join ( ( folder , filename ) ) ) [EOL] [EOL] proc = subprocess . Popen ( cmd , stdout = subprocess . PIPE , cwd = path ) [EOL] output , _ = proc . communicate ( ) [EOL] self . _save_lint_results ( output ) [EOL] [EOL] [EOL] class CountAnalyzer : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . file_count = [number] [EOL] self . total_line_count = [number] [EOL] self . average_line_count = [number] [EOL] [EOL] def _count_files ( self , path ) : [EOL] [docstring] [EOL] proc = subprocess . Popen ( [ [string] , [string] , [string] , [string] ] , stdout = subprocess . PIPE , cwd = path ) [EOL] output = subprocess . check_output ( [ [string] , [string] ] , stdin = proc . stdout ) [EOL] file_count = int ( output . decode ( ) . split ( ) [ [number] ] ) [EOL] return file_count [EOL] [EOL] def _count_lines ( self , path ) : [EOL] [docstring] [EOL] proc = subprocess . Popen ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , stdout = subprocess . PIPE , cwd = path ) [EOL] output = subprocess . check_output ( [ [string] , [string] ] , stdin = proc . stdout ) [EOL] line_count = int ( output . decode ( ) . split ( ) [ [number] ] ) [EOL] return line_count [EOL] [EOL] def run ( self , path ) : [EOL] [docstring] [EOL] self . file_count = self . _count_files ( path ) [EOL] self . total_line_count = self . _count_lines ( path ) [EOL] self . average_line_count = round ( self . total_line_count / self . file_count ) [EOL] [EOL] def to_document ( self ) : [EOL] [docstring] [EOL] return { [string] : { [string] : self . file_count , [string] : self . total_line_count , [string] : self . average_line_count } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class Grade : [EOL] [docstring] [EOL] weight = [number] [EOL] score = [number] [EOL] [EOL] def get_weighted_score ( self ) : [EOL] [docstring] [EOL] return self . score * self . weight [EOL] [EOL] [EOL] def calculate_report_grade ( * results ) : [EOL] [docstring] [EOL] total_score = [number] [EOL] [EOL] for result in results : [EOL] total_score += result . get_weighted_score ( ) [EOL] [EOL] if total_score > [number] : [EOL] return [string] [EOL] elif total_score > [number] : [EOL] return [string] [EOL] elif total_score > [number] : [EOL] return [string] [EOL] elif total_score > [number] : [EOL] return [string] [EOL] elif total_score > [number] : [EOL] return [string] [EOL] elif total_score > [number] : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Tuple , Type [EOL] import typing [EOL] import analyzer [EOL] [docstring] [EOL] [EOL] from analyzer . code import ( CountAnalyzer , PEP8LintAnalyzer , PyflakesLintAnalyzer , MyPyAnalyser , ) [EOL] from analyzer . license import LicenseAnalyzer [EOL] from analyzer . readme import ReadmeAnalyzer [EOL] from analyzer . report import calculate_report_grade [EOL] [EOL] [EOL] ANALYSER_CLASSES = ( MyPyAnalyser , PEP8LintAnalyzer , PyflakesLintAnalyzer , ) [EOL] [EOL] DOC_ANALYSER_CLASSES = ( LicenseAnalyzer , ReadmeAnalyzer , ) [EOL] [EOL] [EOL] def analyze ( path ) : [EOL] [docstring] [EOL] count_analyzer = CountAnalyzer ( ) [EOL] count_analyzer . run ( path ) [EOL] line_count = count_analyzer . total_line_count [EOL] [EOL] results = count_analyzer . to_document ( ) [EOL] analyzers = [ ] [EOL] [EOL] for analyzer_class in ANALYSER_CLASSES : [EOL] analyzer = analyzer_class ( ) [EOL] analyzers . append ( analyzer ) [EOL] analyzer . run ( path ) [EOL] analyzer . calculate_score ( line_count ) [EOL] results . update ( analyzer . to_document ( ) ) [EOL] [EOL] for analyzer_class in DOC_ANALYSER_CLASSES : [EOL] analyzer = analyzer_class ( ) [EOL] analyzers . append ( analyzer ) [EOL] analyzer . run ( path ) [EOL] analyzer . calculate_score ( ) [EOL] results . update ( analyzer . to_document ( ) ) [EOL] [EOL] results [ [string] ] = calculate_report_grade ( * analyzers ) [EOL] [EOL] return results [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0