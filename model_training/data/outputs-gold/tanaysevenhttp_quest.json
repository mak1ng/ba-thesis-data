import flask [EOL] import os [EOL] [EOL] from flask import Flask [EOL] [EOL] from http_quest . config import CONFIG [EOL] from http_quest . ext import bcrypt , db , jwt , mail , migrate , babel [EOL] from http_quest . product_quiz . view import products_view [EOL] from http_quest . quiz . view import quiz_view [EOL] from http_quest . user . user import authenticate , identity [EOL] from http_quest . user . view import user_view [EOL] from http_quest . view import root_view [EOL] [EOL] app = Flask ( __name__ . split ( [string] ) [ [number] ] , template_folder = [string] ) [EOL] [EOL] app . config . from_object ( CONFIG ) [EOL] [EOL] [comment] [EOL] db . init_app ( app ) [EOL] migrate . init_app ( app ) [EOL] [EOL] [comment] [EOL] jwt . identity_handler ( identity ) [EOL] jwt . authentication_handler ( authenticate ) [EOL] jwt . init_app ( app ) [EOL] [EOL] mail . init_app ( app ) [EOL] [EOL] bcrypt . init_app ( app ) [EOL] [EOL] babel . init_app ( app ) [EOL] [EOL] app . register_blueprint ( products_view ) [EOL] app . register_blueprint ( user_view ) [EOL] app . register_blueprint ( root_view ) [EOL] app . register_blueprint ( quiz_view ) [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 $flask.Flask$ 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0
	0
from typing import Type , Union [EOL] import fakes [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] from typing import Union [EOL] [EOL] [EOL] class FakeDatetime : [EOL] _datetime = ... [EOL] [EOL] @ staticmethod def set_next_dattime ( date_value ) : [EOL] FakeDatetime . _datetime = date_value [EOL] [EOL] @ staticmethod def now ( ) : [EOL] return FakeDatetime . _datetime [EOL] [EOL] [EOL] class FakeRandom : [EOL] _rand_range = [ ] [EOL] [EOL] @ staticmethod def append_next_randrange ( rand_range = [number] ) : [EOL] if type ( rand_range ) is int : [EOL] FakeRandom . _rand_range . append ( rand_range ) [EOL] elif type ( rand_range ) is list : [EOL] FakeRandom . _rand_range . extend ( rand_range ) [EOL] [EOL] @ staticmethod def reset ( ) : [EOL] FakeRandom . _rand_range = [ ] [EOL] [EOL] @ staticmethod def randrange ( * args , ** kwargs ) : [EOL] return FakeRandom . _rand_range . pop ( [number] ) [EOL] [EOL] [EOL] class FakeBcrypt : [EOL] def generate_password_hash ( self , x , ** kwargs ) : [EOL] return x . encode ( ) [EOL] [EOL] def check_password_hash ( self , x , y ) : [EOL] return x == y	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] from behave import given , when , then [EOL] from selenium import webdriver [EOL] [EOL] [EOL] class WebDriver : [EOL] DOWNLOAD_DIR = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] headless = bool ( os . environ . get ( [string] ) ) [EOL] self . options = webdriver . ChromeOptions ( ) [EOL] self . options . add_argument ( [string] ) [EOL] if headless : [EOL] self . options . add_argument ( [string] ) [EOL] self . options . add_argument ( [string] ) [EOL] self . options . add_argument ( [string] ) [EOL] self . options . add_experimental_option ( [string] , { [string] : self . DOWNLOAD_DIR , [string] : False , [string] : True , [string] : True } ) [EOL] self . driver = webdriver . Chrome ( chrome_options = self . options ) [EOL] self . driver . implicitly_wait ( [number] ) [EOL] [EOL] def close ( self ) : [EOL] self . driver . quit ( ) [EOL] [EOL] def login ( self ) : [EOL] self . driver . get ( [string] ) [EOL] [EOL] [EOL] @ given ( [string] ) def step_impl ( context ) : [EOL] pass [EOL] [EOL] [EOL] @ when ( [string] ) def step_impl ( context , number ) : [EOL] assert number > [number] or number == [number] [EOL] context . tests_count = number [EOL] [EOL] [EOL] @ when ( [string] ) def step_impl ( context ) : [EOL] context . webbrowser = WebDriver ( ) [EOL] context . webbrowser . login ( ) [EOL] context . webbrowser . close ( ) [EOL] [EOL] [EOL] @ then ( [string] ) def step_impl ( context ) : [EOL] assert context . failed is False [EOL] assert context . tests_count >= [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import os [EOL] import random [EOL] from functools import wraps [EOL] [EOL] from flask import request , jsonify , render_template [EOL] from jsonschema import validate , ValidationError [EOL] [EOL] from http_quest . config import CONFIG [EOL] [EOL] [EOL] def fetch_locale_from_request_else_use_default ( ) : [EOL] return ( request and request . headers . get ( [string] ) and request . headers . get ( [string] ) . split ( [string] ) [ [number] ] or CONFIG . LOCALE ) [EOL] [EOL] [EOL] def get_translation_for ( strings , key ) : [EOL] return strings . get ( fetch_locale_from_request_else_use_default ( ) ) . get ( key ) [EOL] [EOL] [EOL] def load_template ( template_name , args ) : [EOL] return render_template ( fetch_locale_from_request_else_use_default ( ) + [string] + template_name , ** args ) [EOL] [EOL] [EOL] def validate_json ( schema ) : [EOL] def decorator ( f ) : [EOL] @ wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] try : [EOL] validate ( instance = request . json , schema = schema ) [EOL] except ValidationError as e : [EOL] return jsonify ( { [string] : f' [string] { str ( e ) }' } ) , [number] [EOL] else : [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] return decorated_function [EOL] [EOL] return decorator [EOL] [EOL] [EOL] class RandomWrapper : [EOL] def randrange ( self , start , stop , step = [number] ) : [EOL] return random . randrange ( start , stop , step ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import flask [EOL] import typing [EOL] from flask import Blueprint , jsonify [EOL] from flask . templating import render_template [EOL] from flask_babel import gettext as _ [EOL] [EOL] root_view = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ root_view . route ( [string] , methods = ( [string] , ) ) def health_get ( ) : [EOL] data = { [string] : _ ( [string] ) } [EOL] return jsonify ( data ) [EOL] [EOL] [EOL] @ root_view . route ( [string] , methods = ( [string] , ) ) def admin_get_index ( ) : [EOL] return render_template ( [string] ) [EOL] [EOL] [EOL] @ root_view . route ( [string] , methods = ( [string] , ) ) def admin_get ( url_path ) : [EOL] return render_template ( [string] + url_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type , Dict , Union [EOL] import http_quest [EOL] import typing [EOL] import os [EOL] [EOL] [EOL] class Config ( object ) : [EOL] DEBUG = False [EOL] TESTING = False [EOL] SQLALCHEMY_DATABASE_URI = os . environ . get ( [string] , [string] ) [EOL] SQLALCHEMY_TRACK_MODIFICATIONS = False [EOL] LOCALE = os . environ . get ( [string] , [string] ) [EOL] JWT_AUTH_USERNAME_KEY = [string] [EOL] JWT_AUTH_PASSWORD_KEY = [string] [EOL] JWT_AUTH_URL_RULE = [string] [EOL] SECRET_KEY = [string] [EOL] MAIL_DEFAULT_SENDER = [string] [EOL] SUPPORTED_LANGUAGES = { [string] : [string] , [string] : [string] } [EOL] BABEL_DEFAULT_LOCALE = [string] [EOL] BABEL_DEFAULT_TIMEZONE = [string] [EOL] [EOL] [EOL] class DevelopmentConfig ( Config ) : [EOL] FLASK_DEBUG = True [EOL] MAIL_SERVER = [string] [EOL] MAIL_PORT = [string] [EOL] MAIL_SUPPRESS_SEND = False [EOL] [EOL] [EOL] class TestConfig ( Config ) : [EOL] SQLALCHEMY_DATABASE_URI = os . environ . get ( [string] , [string] , ) [EOL] FLASK_DEBUG = True [EOL] TESTING = True [EOL] MAIL_SUPPRESS_SEND = True [EOL] [EOL] [EOL] class ProdConfig ( Config ) : [EOL] SQLALCHEMY_DATABASE_URI = os . environ . get ( [string] , [string] , ) [EOL] FLASK_DEBUG = False [EOL] TESTING = False [EOL] MAIL_SERVER = [string] [EOL] MAIL_PORT = [string] [EOL] MAIL_SUPPRESS_SEND = False [EOL] [EOL] [EOL] CONFIG = { [string] : TestConfig , [string] : DevelopmentConfig , [string] : ProdConfig , } [ os . environ . get ( [string] , [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import flask_bcrypt [EOL] import flask_sqlalchemy [EOL] import flask_migrate [EOL] import flask_babel [EOL] import flask_mail [EOL] from flask_babel import Babel [EOL] from flask_bcrypt import Bcrypt [EOL] from flask_jwt import JWT [EOL] from flask_mail import Mail [EOL] from flask_migrate import Migrate [EOL] from flask_sqlalchemy import SQLAlchemy [EOL] [EOL] db = SQLAlchemy ( ) [EOL] jwt = JWT ( ) [EOL] migrate = Migrate ( db = db ) [EOL] mail = Mail ( ) [EOL] bcrypt = Bcrypt ( ) [EOL] babel = Babel ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask_sqlalchemy.SQLAlchemy$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $flask_migrate.Migrate$ 0 0 0 $flask_sqlalchemy.SQLAlchemy$ 0 $flask_sqlalchemy.SQLAlchemy$ 0 0 $flask_mail.Mail$ 0 0 0 0 0 $flask_bcrypt.Bcrypt$ 0 0 0 0 0 $flask_babel.Babel$ 0 0 0 0 0
class Container : [EOL] pass [EOL]	0 0 0 0 0 0
	0
from typing import Dict , List , Union [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] from datetime import timedelta [EOL] from json import JSONEncoder [EOL] from typing import Dict , List , Union [EOL] [EOL] from http_quest . di import container [EOL] from http_quest . utilities import RandomWrapper [EOL] [EOL] [EOL] name_with_categories = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Product : [EOL] def __init__ ( self , name , category , price , start_date , end_date ) : [EOL] [EOL] self . name = name [EOL] self . category = category [EOL] self . price = price [EOL] self . start_date = start_date [EOL] self . end_date = end_date [EOL] self . datetime_ = container . datetime [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . name , [string] : self . price , [string] : self . start_date . isoformat ( ) , [string] : self . end_date . isoformat ( ) , } [EOL] [EOL] def is_active ( self ) : [EOL] return self . start_date <= self . datetime_ . now ( ) <= self . end_date [EOL] [EOL] @ classmethod def solution_count ( cls , product_list ) : [EOL] return { [string] : len ( product_list ) } [EOL] [EOL] @ classmethod def solution_active_count ( cls , product_list ) : [EOL] active_count = len ( [ x for x in product_list if x . is_active ( ) ] ) [EOL] return { [string] : active_count } [EOL] [EOL] @ classmethod def solution_active_date_count_categories ( cls , product_list ) : [EOL] result = { x . category : [number] for x in product_list } [EOL] for key in result . keys ( ) : [EOL] result [ key ] += [number] [EOL] return result [EOL] [EOL] @ classmethod def solution_total_value_for_active_date ( cls , product_list ) : [EOL] return { [string] : sum ( [ x . price for x in product_list if x . is_active ( ) ] ) } [EOL] [EOL] @ staticmethod def fn_for_solution ( problem_number ) : [EOL] try : [EOL] return [ Product . solution_count , Product . solution_active_count , Product . solution_active_date_count_categories , Product . solution_total_value_for_active_date , ] [ problem_number ] [EOL] except IndexError : [EOL] return None [EOL] [EOL] [EOL] class ProductFactory : [EOL] def __init__ ( self ) : [EOL] self . _random = container . random [EOL] self . _datetime = container . datetime [EOL] [EOL] def new_product ( self , id_ ) : [EOL] name = list ( name_with_categories . keys ( ) ) [ id_ ] [EOL] return Product ( name , name_with_categories [ name ] , self . _random . randrange ( [number] , [number] ) , self . _datetime . now ( ) - timedelta ( days = self . _random . randrange ( [number] , [number] ) ) , self . _datetime . now ( ) + timedelta ( days = self . _random . randrange ( [number] , [number] ) ) , ) [EOL] [EOL] [EOL] [EOL] [EOL] class ProductCollection : [EOL] @ staticmethod def generate_products ( count ) : [EOL] product_factory = ProductFactory ( ) [EOL] return [ product_factory . new_product ( x ) for x in range ( count ) ] [EOL] [EOL] @ staticmethod def to_dict ( products ) : [EOL] return [ product . to_dict ( ) for product in products ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.List['Product']$ 0 0 0 0 0 0 0 0 0 $typing.List['Product']$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.List['Product']$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List['Product']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.List['Product']$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List['Product']$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.List['Product']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List['Product']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union['function',None]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Product$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Product]$ 0 $builtins.int$ 0 0 0 $ProductFactory$ 0 0 0 0 0 0 0 $ProductFactory$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.dict]$ 0 $typing.List['Product']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List['Product']$ 0 0
	0
from typing import Tuple , Union , Any [EOL] import http_quest [EOL] import typing [EOL] import builtins [EOL] import uuid [EOL] from typing import Tuple , Union [EOL] [EOL] from flask_babel import gettext as _ [EOL] from flask_mail import Message [EOL] [EOL] from http_quest . di import container [EOL] from http_quest . ext import mail [EOL] from http_quest . user . model import User [EOL] from http_quest . user . repo import UserRepo [EOL] from http_quest . utilities import load_template [EOL] [EOL] [EOL] def authenticate ( email , password ) : [EOL] user = UserRepo . fetch_user_by_email ( email ) [EOL] if user is None : [EOL] return None [EOL] password_matches = container . bcrypt . check_password_hash ( user . password , password ) [EOL] return user if password_matches else None [EOL] [EOL] [EOL] def update_password_for_token ( reset_token , password ) : [EOL] user = UserRepo . fetch_user_by_reset_token ( reset_token ) [EOL] if user is not None : [EOL] user . password = container . bcrypt . generate_password_hash ( password ) . decode ( ) [EOL] user . password_reset_token = None [EOL] UserRepo . save_and_reload ( user ) [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def create_user ( email , password = None ) : [EOL] hashed_password , success = _generate_hashed_password_if_user_email_does_not_exist ( email , password ) [EOL] if not success : [EOL] return success [EOL] user = UserRepo . add ( User ( email = email , password = hashed_password ) ) [EOL] _reset_password_for_user ( user ) [EOL] return True [EOL] [EOL] [EOL] def _generate_hashed_password_if_user_email_does_not_exist ( email , password ) : [EOL] success = True [EOL] hashed_password = None [EOL] existing_user = UserRepo . fetch_user_by_email ( email ) [EOL] if existing_user is not None : [EOL] success = False [EOL] if password is not None : [EOL] hashed_password = container . bcrypt . generate_password_hash ( password ) . decode ( ) [EOL] return hashed_password , success [EOL] [EOL] [EOL] def identity ( payload ) : [EOL] return UserRepo . fetch_by_id ( payload . get ( [string] ) ) [EOL] [EOL] [EOL] def reset_password_for_user_having_email ( email ) : [EOL] user = UserRepo . load_user_for_email ( email ) [EOL] if user is None : [EOL] return { [string] : _ ( [string] ) } , False [EOL] _reset_password_for_user ( user ) [EOL] return { [string] : _ ( [string] ) } , True [EOL] [EOL] [EOL] def _reset_password_for_user ( user ) : [EOL] token = _create_password_reset_token ( user ) [EOL] msg = Message ( _ ( [string] ) , recipients = [ user . email ] , body = load_template ( [string] , { [string] : token } ) , ) [EOL] mail . send ( msg ) [EOL] [EOL] [EOL] def _create_password_reset_token ( user ) : [EOL] token = str ( uuid . uuid4 ( ) ) [EOL] UserRepo . add_password_reset_token_to_user ( user , token ) [EOL] return token [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.dict,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , List , Union [EOL] import typing [EOL] new_password_schema = { [string] : [string] , [string] : [ [string] ] , [string] : { [string] : { [string] : [string] } , } , [string] : False , } [EOL] [EOL] create_new_schema = { [string] : [string] , [string] : [ [string] ] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : False , } [EOL] [EOL] password_reset_schema = { [string] : [string] , [string] : [ [string] ] , [string] : { [string] : { [string] : [string] } , } , [string] : False , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import flask [EOL] import typing [EOL] import builtins [EOL] from flask import jsonify , Blueprint , request [EOL] from flask_jwt import jwt_required [EOL] from flask_babel import gettext as _ [EOL] [EOL] from http_quest . user . schema import new_password_schema , create_new_schema , password_reset_schema [EOL] from http_quest . user . user import reset_password_for_user_having_email , create_user , update_password_for_token [EOL] from http_quest . utilities import validate_json [EOL] [EOL] user_view = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ user_view . route ( [string] , methods = ( [string] , ) ) def login_get ( ) : [EOL] data = { [string] : _ ( [string] ) , [string] : { [string] : _ ( [string] ) , [string] : _ ( [string] ) } } [EOL] return jsonify ( data ) [EOL] [EOL] [EOL] @ user_view . route ( [string] , methods = ( [string] , ) ) @ validate_json ( password_reset_schema ) def password_reset ( ) : [EOL] message , success = reset_password_for_user_having_email ( request . json . get ( [string] ) ) [EOL] if not success : [EOL] return jsonify ( message ) , [number] [EOL] return jsonify ( message ) [EOL] [EOL] [EOL] @ user_view . route ( [string] , methods = ( [string] , ) ) @ jwt_required ( ) @ validate_json ( create_new_schema ) def create_new ( ) : [EOL] success_data = { [string] : _ ( [string] ) , } [EOL] success = create_user ( request . json . get ( [string] ) , request . json . get ( [string] ) ) [EOL] if success : [EOL] return jsonify ( success_data ) [EOL] return jsonify ( { [string] : _ ( [string] ) } ) , [number] [EOL] [EOL] [EOL] @ user_view . route ( [string] , methods = ( [string] , ) ) @ validate_json ( new_password_schema ) def new_password ( reset_token ) : [EOL] success_response = { [string] : _ ( [string] ) } [EOL] success = update_password_for_token ( reset_token , request . json . get ( [string] ) ) [EOL] if success : [EOL] return jsonify ( success_response ) , [number] [EOL] return jsonify ( { [string] : _ ( [string] ) } ) , [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any [EOL] import http_quest [EOL] import typing [EOL] import builtins [EOL] from typing import Union , Any [EOL] [EOL] from http_quest . ext import db [EOL] from http_quest . user . model import User [EOL] [EOL] [EOL] class UserRepo : [EOL] @ staticmethod def add ( user ) : [EOL] db . session . add ( user ) [EOL] db . session . commit ( ) [EOL] return user [EOL] [EOL] @ staticmethod def fetch_user_by_email ( email ) : [EOL] return db . session . query ( User ) . filter ( User . email == email ) . one_or_none ( ) [EOL] [EOL] @ staticmethod def fetch_by_id ( id_ ) : [EOL] return db . session . query ( User ) . filter ( User . id == id_ ) . one_or_none ( ) [EOL] [EOL] @ staticmethod def add_password_reset_token_to_user ( user , token ) : [EOL] user . password_reset_token = token [EOL] db . session . add ( user ) [EOL] db . session . commit ( ) [EOL] [EOL] @ staticmethod def save_and_reload ( obj ) : [EOL] db . session . add ( obj ) [EOL] db . session . commit ( ) [EOL] db . session . refresh ( obj ) [EOL] [EOL] @ staticmethod def load_user_for_email ( email ) : [EOL] return db . session . query ( User ) . filter ( User . email == email ) . one_or_none ( ) [EOL] [EOL] @ staticmethod def fetch_user_by_reset_token ( reset_token ) : [EOL] return db . session . query ( User ) . filter ( User . password_reset_token == reset_token ) . one_or_none ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $http_quest.user.model.User$ 0 $http_quest.user.model.User$ 0 0 0 0 0 0 0 0 0 $http_quest.user.model.User$ 0 0 0 0 0 0 0 0 0 0 0 $http_quest.user.model.User$ 0 0 0 0 0 $typing.Union[http_quest.user.model.User,None]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[http_quest.user.model.User,None]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $http_quest.user.model.User$ 0 $builtins.str$ 0 0 0 $http_quest.user.model.User$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $http_quest.user.model.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $http_quest.user.model.User$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $http_quest.user.model.User$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import Dict , List , Union [EOL] import typing [EOL] new_candidate_token_schema = { [string] : [string] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : False , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Union , Any [EOL] import http_quest [EOL] import typing [EOL] import builtins [EOL] from typing import Union [EOL] [EOL] from sqlalchemy import desc , join [EOL] [EOL] from http_quest . ext import db [EOL] from http_quest . quiz . model import Candidate , SequentialQuiz , QuestionStatus [EOL] [EOL] [EOL] class CandidateRepo : [EOL] @ staticmethod def add ( candidate ) : [EOL] db . session . add ( candidate ) [EOL] db . session . commit ( ) [EOL] return candidate [EOL] [EOL] @ staticmethod def fetch_candidate_by_token ( token ) : [EOL] return db . session . query ( Candidate ) . filter ( Candidate . token == token ) . one_or_none ( ) [EOL] [EOL] [EOL] class QuizRepo : [EOL] @ staticmethod def fetch_latest_answer_by_candidate ( candidate ) : [EOL] result = db . session . query ( Candidate , SequentialQuiz ) . select_from ( join ( Candidate , SequentialQuiz , SequentialQuiz . candidate_id == Candidate . id ) ) . filter ( Candidate . id == candidate . id ) . order_by ( desc ( SequentialQuiz . problem_number ) ) . limit ( [number] ) . one_or_none ( ) [EOL] return None if result is None else result [ [number] ] [EOL] [EOL] @ staticmethod def add_or_update_problem_input_output ( input_ , output , candidate , problem_number ) : [EOL] quiz_repo = QuizRepo . fetch_latest_answer_by_candidate ( candidate ) [EOL] if quiz_repo is None or quiz_repo . problem_number + [number] == problem_number : [EOL] db . session . add ( SequentialQuiz ( candidate_id = candidate . id , problem_number = problem_number , input = input_ , output = output , attempts = [number] , status = str ( QuestionStatus . PENDING ) , ) ) [EOL] else : [EOL] quiz_repo . input = input_ [EOL] quiz_repo . output = output [EOL] quiz_repo . attempts += [number] [EOL] quiz_repo . status = str ( QuestionStatus . PENDING ) , [EOL] db . session . add ( quiz_repo ) [EOL] db . session . commit ( ) [EOL] [EOL] @ staticmethod def set_status_to ( status , question_attempt ) : [EOL] question_attempt . status = str ( status ) [EOL] db . session . add ( question_attempt ) [EOL] db . session . commit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import flask [EOL] import typing [EOL] from flask import Blueprint , jsonify [EOL] from flask_jwt import jwt_required [EOL] from flask_babel import gettext as _ [EOL] [EOL] from http_quest . quiz . model import QuizType [EOL] from http_quest . quiz . quiz import create_new_candidate_token [EOL] from http_quest . quiz . schema import new_candidate_token_schema [EOL] from http_quest . utilities import validate_json [EOL] [EOL] quiz_view = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ quiz_view . route ( [string] , methods = ( [string] , ) ) @ validate_json ( new_candidate_token_schema ) @ jwt_required ( ) def create_candidate_token ( ) : [EOL] response = { [string] : _ ( [string] ) } [EOL] create_new_candidate_token ( ) [EOL] return jsonify ( response ) , [number] [EOL] [EOL] [EOL] @ quiz_view . route ( [string] , methods = ( [string] , ) ) @ jwt_required ( ) def list_quiz_types ( ) : [EOL] response = { [string] : [ str ( type_ ) for type_ in QuizType ] } [EOL] return jsonify ( response ) , [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import http_quest [EOL] import typing [EOL] import builtins [EOL] from enum import Enum [EOL] [EOL] from sqlalchemy . dialects . postgresql import JSONB [EOL] [EOL] from http_quest . ext import db [EOL] [EOL] [EOL] class CandidateStatus ( Enum ) : [EOL] ACTIVE = [string] [EOL] EXPIRED = [string] [EOL] [EOL] def __str__ ( self ) : [EOL] return self . value [EOL] [EOL] [EOL] class QuestionStatus ( Enum ) : [EOL] PENDING = [string] [EOL] CORRECT = [string] [EOL] WRONG = [string] [EOL] TIME_EXPIRED = [string] [EOL] [EOL] def __str__ ( self ) : [EOL] return self . value [EOL] [EOL] [EOL] class QuizType ( Enum ) : [EOL] SEQUENTIAL = [string] [EOL] [EOL] def __str__ ( self ) : [EOL] return self . value [EOL] [EOL] [EOL] class Candidate ( db . Model ) : [EOL] id = db . Column ( db . Integer , primary_key = True , autoincrement = True ) [EOL] email = db . Column ( db . String ( [number] ) ) [EOL] name = db . Column ( db . String ( [number] ) ) [EOL] created_at = db . Column ( db . DateTime ) [EOL] token = db . Column ( db . String ( [number] ) , unique = True ) [EOL] quiz_type = db . Column ( db . String ( [number] ) , nullable = False ) [EOL] quiz_name = db . Column ( db . String ( [number] ) , nullable = False ) [EOL] status = db . Column ( db . String ( [number] ) ) [EOL] created_by = db . Column ( db . Integer , db . ForeignKey ( [string] ) ) [EOL] [EOL] [EOL] class SequentialQuiz ( db . Model ) : [EOL] id = db . Column ( db . Integer , primary_key = True , autoincrement = True ) [EOL] candidate_id = db . Column ( db . Integer , db . ForeignKey ( [string] ) ) [EOL] problem_number = db . Column ( db . Integer ) [EOL] input = db . Column ( JSONB ) [EOL] output = db . Column ( JSONB ) [EOL] attempts = db . Column ( db . Integer , default = [number] ) [EOL] status = db . Column ( db . String ( [number] ) ) [EOL] [EOL] def pending ( self , problem_no ) : [EOL] return self . problem_number == problem_no and self . status == str ( QuestionStatus . PENDING ) [EOL] [EOL] def pending_or_wrong ( self , problem_no ) : [EOL] return self . problem_number == problem_no \ [EOL] and ( self . status == str ( QuestionStatus . PENDING ) or self . status == str ( QuestionStatus . WRONG ) ) [EOL] [EOL] def has_been_solved ( self , problem_no ) : [EOL] return self . problem_number == problem_no and self . status == str ( QuestionStatus . CORRECT ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
import http_quest [EOL] import builtins [EOL] import uuid [EOL] from datetime import datetime [EOL] from functools import wraps [EOL] [EOL] from flask import request , jsonify , url_for , g [EOL] from flask_jwt import current_identity [EOL] from flask_mail import Message [EOL] from flask_babel import gettext as _ [EOL] [EOL] from http_quest . ext import mail [EOL] from http_quest . quiz . model import Candidate , CandidateStatus [EOL] from http_quest . quiz . repo import CandidateRepo [EOL] from http_quest . user . model import User [EOL] from http_quest . utilities import load_template [EOL] [EOL] [EOL] def create_new_candidate_token ( ) : [EOL] user = current_identity [EOL] token = str ( uuid . uuid4 ( ) ) [EOL] candidate = Candidate ( email = request . json . get ( [string] ) , name = request . json . get ( [string] ) , created_at = datetime . now ( ) , token = token , quiz_type = request . json . get ( [string] ) , quiz_name = request . json . get ( [string] ) , status = str ( CandidateStatus . ACTIVE ) , created_by = user . id , ) [EOL] candidate = CandidateRepo . add ( candidate ) [EOL] mail . send ( Message ( _ ( [string] ) , recipients = [ user . email , candidate . email ] , body = load_template ( [string] , { [string] : token , [string] : candidate . name , [string] : url_for ( candidate . quiz_name + [string] ) , } ) , ) ) [EOL] [EOL] [EOL] def candidate_token_required ( quiz_type , quiz_name ) : [EOL] def decorator ( f ) : [EOL] @ wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] candidate = CandidateRepo . fetch_candidate_by_token ( request . headers . get ( [string] ) ) [EOL] if candidate . quiz_type == quiz_type and candidate . quiz_name == quiz_name : [EOL] g . candidate = candidate [EOL] return f ( * args , ** kwargs ) [EOL] return jsonify ( { [string] : [string] } ) , [number] [EOL] [EOL] return decorated_function [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import sqlalchemy as sa [EOL] from alembic import op [EOL] [EOL] [comment] [EOL] [EOL] revision = [string] [EOL] down_revision = [string] [EOL] branch_labels = None [EOL] depends_on = None [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] [comment] [EOL] op . batch_alter_table ( [string] , sa . Column ( [string] , sa . String ( length = [number] ) , nullable = True ) ) [EOL] [comment] [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] [comment] [EOL] op . batch_alter_table ( [string] , sa . Column ( [string] , sa . Binary ( length = [number] ) , nullable = True ) ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
import uuid [EOL] [EOL] from http_quest . user . repo import UserRepo [EOL] from test . base import DatabaseTest [EOL] [EOL] [EOL] class TestUserRepo ( DatabaseTest ) : [EOL] [EOL] def test_authenticate_should_return_correct_user_if_user_exists ( self ) : [EOL] expected_user = UserRepo . add ( self . new_user ( ) ) [EOL] actual_user = UserRepo . fetch_user_by_email ( [string] ) [EOL] assert expected_user == actual_user [EOL] [EOL] def test_authenticate_should_return_none_if_user_enters_wrong_email ( self ) : [EOL] _ = UserRepo . add ( self . new_user ( ) ) [EOL] actual_user = UserRepo . fetch_user_by_email ( [string] ) [EOL] assert actual_user is None [EOL] [EOL] def test_identity_should_return_user_when_given_a_user_id ( self ) : [EOL] expected_user = UserRepo . add ( self . new_user ( ) ) [EOL] actual_user = UserRepo . fetch_by_id ( expected_user . id ) [EOL] assert actual_user == expected_user [EOL] [EOL] def test_identity_should_return_none_when_given_invalid_user_id ( self ) : [EOL] _ = UserRepo . add ( self . new_user ( ) ) [EOL] actual_user = UserRepo . fetch_by_id ( [number] ) [EOL] assert actual_user is None [EOL] [EOL] def test_a_new_token_should_be_stored_and_retrieved_for_a_user ( self ) : [EOL] user = UserRepo . add ( self . new_user ( ) ) [EOL] token = str ( uuid . uuid4 ( ) ) [EOL] UserRepo . add_password_reset_token_to_user ( user , token ) [EOL] UserRepo . save_and_reload ( user ) [EOL] assert user . password_reset_token == token [EOL] [EOL] def test_load_user_for_email_should_return_a_user_if_it_exists ( self ) : [EOL] expected_user = UserRepo . add ( self . new_user ( ) ) [EOL] actual_user = UserRepo . load_user_for_email ( expected_user . email ) [EOL] assert expected_user == actual_user [EOL] [EOL] def test_load_user_for_email_should_not_return_a_user_if_it_does_not_exist ( self ) : [EOL] fetched_user = UserRepo . load_user_for_email ( [string] ) [EOL] assert fetched_user is None [EOL] [EOL] def test_fetch_user_by_reset_token_should_return_the_correct_user ( self ) : [EOL] UserRepo . add ( self . new_user ( [string] ) ) [EOL] expected_user = UserRepo . add ( self . new_user ( ) ) [EOL] UserRepo . add ( self . new_user ( [string] ) ) [EOL] token = str ( uuid . uuid4 ( ) ) [EOL] expected_user . password_reset_token = token [EOL] UserRepo . save_and_reload ( expected_user ) [EOL] actual_user = UserRepo . fetch_user_by_reset_token ( token ) [EOL] assert actual_user == expected_user [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from flask import json [EOL] [EOL] from http_quest . user . repo import UserRepo [EOL] from test . base import ApiTestBase [EOL] [EOL] [EOL] class TestAuthApi ( ApiTestBase ) : [EOL] [EOL] def test_that_get_at_login_returns_login_details ( self ) : [EOL] response = self . app_test . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert [string] in json . loads ( response . data ) [EOL] assert [string] in json . loads ( response . data ) [EOL] [EOL] def test_that_invalid_login_of_admin_with_invalid_email_fails ( self ) : [EOL] request_payload = { [string] : [string] , [string] : [string] } [EOL] response = self . app_test . post_json ( url = [string] , body = request_payload ) [EOL] assert response . status_code == [number] [EOL] assert json . loads ( response . data ) == { [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] [EOL] def test_that_correct_login_of_admin_returns_auth_token ( self ) : [EOL] UserRepo . add ( self . new_user ( ) ) [EOL] request_payload = { [string] : [string] , [string] : [string] } [EOL] response = self . app_test . post_json ( url = [string] , body = request_payload ) [EOL] assert response . status_code == [number] [EOL] assert [string] in json . loads ( response . data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
	0
	0
from typing import Dict , Any [EOL] import typing [EOL] from flask import json [EOL] from flask_babel import gettext as _ [EOL] [EOL] from http_quest . user . repo import UserRepo [EOL] from http_quest . user . user import create_user [EOL] from test . base import ApiTestBase [EOL] [EOL] [EOL] class TestLoginApi ( ApiTestBase ) : [EOL] [EOL] def test_that_correct_post_to_reset_password_succeeds ( self ) : [EOL] user = self . create_user ( ) [EOL] request_payload = { [string] : user . email } [EOL] response = self . app_test . post_json ( url = [string] , body = request_payload ) [EOL] self . assert_response_ok_and_has_message ( response ) [EOL] subject = _ ( [string] ) [EOL] self . assert_has_one_mail_with_subject ( subject ) [EOL] [EOL] def test_that_invalid_email_sent_to_reset_password_fails ( self ) : [EOL] request_payload = { [string] : [string] } [EOL] response = self . app_test . post_json ( url = [string] , body = request_payload ) [EOL] assert response . status_code == [number] [EOL] assert [string] in json . loads ( response . data ) [EOL] [EOL] def test_that_on_sending_invalid_json_create_other_user_fails ( self ) : [EOL] token = self . request_login_token ( self . app_test , self . create_user ( ) ) [EOL] response = self . app_test . post_json ( url = [string] , body = { } , headers = { [string] : token } , ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_that_a_user_who_had_logged_in_can_create_other_users_successfully ( self ) : [EOL] token = self . request_login_token ( self . app_test , self . create_user ( ) ) [EOL] response = self . app_test . post_json ( url = [string] , body = { [string] : [string] } , headers = { [string] : token } , ) [EOL] assert response . status_code == [number] [EOL] assert [string] in json . loads ( response . data ) [EOL] self . assert_has_one_mail_with_subject_and_recipients ( subject = _ ( [string] ) , recipients = [ [string] ] , ) [EOL] expected_user = UserRepo . fetch_user_by_email ( [string] ) [EOL] assert expected_user is not None [EOL] [EOL] def test_that_new_user_should_not_be_created_if_it_already_exists ( self ) : [EOL] token = self . request_login_token ( self . app_test , self . create_user ( ) ) [EOL] create_user ( [string] , [string] ) [EOL] response = self . app_test . post_json ( url = [string] , body = { [string] : [string] } , headers = { [string] : token } , ) [EOL] assert response . status_code == [number] [EOL] assert [string] in json . loads ( response . data ) [EOL] [EOL] def test_that_an_existing_user_who_has_reset_password_can_set_a_new_one ( self ) : [EOL] user = self . create_user ( ) [EOL] self . app_test . post_json ( url = [string] , body = { [string] : user . email } , ) [EOL] password_reset_token = self . mail_body_extract_token ( ) [EOL] response = self . app_test . post_json ( url = [string] + password_reset_token , body = { [string] : [string] } ) [EOL] self . assert_response_ok_and_has_message ( response ) [EOL] response = self . request_login ( self . app_test , user , [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] def test_that_an_existing_user_who_has_not_reset_password_can_not_set_a_new_one ( self ) : [EOL] self . create_user ( ) [EOL] response = self . app_test . post_json ( url = [string] + [string] , body = { [string] : [string] } ) [EOL] assert response . status_code == [number] [EOL] assert [string] in json . loads ( response . data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Dict , Optional , Any [EOL] import http_quest [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] from datetime import datetime [EOL] [EOL] import pytest [EOL] from flask import json , Response [EOL] [EOL] from http_quest . product_quiz . problem_statements import Product [EOL] from http_quest . quiz . repo import QuizRepo [EOL] from test . base import ApiTestBase [EOL] from fakes import FakeRandom , FakeDatetime [EOL] [EOL] [EOL] class TestProductApi ( ApiTestBase ) : [EOL] @ pytest . fixture ( autouse = True ) def setup_random ( self ) : [EOL] FakeRandom . reset ( ) [EOL] self . init_faker_for_input_api_call ( ) [EOL] [EOL] def init_faker_for_input_api_call ( self ) : [EOL] self . input_range = [number] [EOL] FakeRandom . append_next_randrange ( self . input_range ) [EOL] self . price = [number] [EOL] self . start_date_delta = [number] [EOL] self . end_date_delta = [number] [EOL] self . datetime_now = datetime ( year = [number] , month = [number] , day = [number] ) [EOL] self . add_product_parameters_to_fakers ( ) [EOL] self . add_product_parameters_to_fakers ( ) [EOL] [EOL] def add_product_parameters_to_fakers ( self ) : [EOL] FakeRandom . append_next_randrange ( [ self . price , self . start_date_delta , self . end_date_delta ] ) [EOL] FakeDatetime . set_next_dattime ( self . datetime_now ) [EOL] [EOL] def answer_first_question ( self , answer_correct_solution = True ) : [EOL] self . candidate_token = self . create_candidate ( ) [EOL] self . response_for_input ( problem_number = [number] , auth_token = self . candidate_token ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] solution = { } if not answer_correct_solution else problem_input_output . output [EOL] response = self . response_for_output ( [number] , auth_token = self . candidate_token , body = solution ) [EOL] return response [EOL] [EOL] def answer_second_question ( self , answer_correct_solution = True ) : [EOL] self . app_test . get ( [string] , headers = { [string] : self . candidate_token } ) [EOL] self . init_faker_for_input_api_call ( ) [EOL] self . response_for_input ( problem_number = [number] , auth_token = self . candidate_token ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] solution = { } if not answer_correct_solution else problem_input_output . output [EOL] response = self . response_for_output ( [number] , auth_token = self . candidate_token , body = solution ) [EOL] return response [EOL] [EOL] def answer_third_question ( self , answer_correct_solution = True ) : [EOL] self . app_test . get ( [string] , headers = { [string] : self . candidate_token } ) [EOL] self . init_faker_for_input_api_call ( ) [EOL] self . response_for_input ( problem_number = [number] , auth_token = self . candidate_token ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] solution = { } if not answer_correct_solution else problem_input_output . output [EOL] response = self . response_for_output ( [number] , auth_token = self . candidate_token , body = solution ) [EOL] return response [EOL] [EOL] def answer_fourth_question ( self , answer_correct_solution = True ) : [EOL] self . app_test . get ( [string] , headers = { [string] : self . candidate_token } ) [EOL] self . init_faker_for_input_api_call ( ) [EOL] self . response_for_input ( problem_number = [number] , auth_token = self . candidate_token ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] solution = { } if not answer_correct_solution else problem_input_output . output [EOL] response = self . response_for_output ( [number] , auth_token = self . candidate_token , body = solution ) [EOL] return response [EOL] [EOL] def test_that_the_get_at_root_of_products_returns_correct_value ( self ) : [EOL] response = self . app_test . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert [string] in json . loads ( response . data ) [EOL] [EOL] def test_that_the_get_at_problem_statement_shows_the_first_problem_when_none_are_yet_answered ( self ) : [EOL] token = self . create_candidate ( ) [EOL] response = self . app_test . get ( [string] , headers = { [string] : token } ) [EOL] assert response . status_code == [number] [EOL] assert [string] in json . loads ( response . data ) [EOL] assert [string] in response . data . decode ( ) [EOL] input_response = self . response_for_input ( problem_number = [number] , auth_token = token ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert input_response . status_code == [number] [EOL] assert problem_input_output . input == json . loads ( input_response . data ) [EOL] [EOL] def test_answer_to_first_problem_if_correct_should_be_reflected_in_the_db ( self ) : [EOL] response = self . answer_first_question ( ) [EOL] assert response . status_code == [number] [EOL] assert [string] in response . data . decode ( ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert problem_input_output . has_been_solved ( [number] ) [EOL] [EOL] def test_answer_to_first_problem_if_wrong_should_be_return_appropriate_response ( self ) : [EOL] response = self . answer_first_question ( answer_correct_solution = False ) [EOL] assert response . status_code == [number] [EOL] assert [string] in response . data . decode ( ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert not problem_input_output . has_been_solved ( [number] ) [EOL] [EOL] def test_answer_to_the_first_problem_if_wrong_should_ask_to_fetch_new_input ( self ) : [EOL] self . answer_first_question ( answer_correct_solution = False ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] solution = Product . solution_count ( problem_input_output . input ) [EOL] response = self . response_for_output ( [number] , auth_token = self . candidate_token , body = solution ) [EOL] assert [string] in response . data . decode ( ) [EOL] [EOL] def test_that_the_get_problem_statement_after_answering_first_problem_shows_second_problem ( self ) : [EOL] self . answer_first_question ( ) [EOL] response = self . app_test . get ( [string] , headers = { [string] : self . candidate_token } ) [EOL] assert response . status_code == [number] [EOL] assert [string] in json . loads ( response . data ) [EOL] assert [string] in response . data . decode ( ) [EOL] self . init_faker_for_input_api_call ( ) [EOL] input_response = self . response_for_input ( problem_number = [number] , auth_token = self . candidate_token ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert input_response . status_code == [number] [EOL] assert problem_input_output . input == json . loads ( input_response . data ) [EOL] [EOL] def test_answer_to_second_problem_if_correct_should_be_reflected_in_the_db ( self ) : [EOL] self . answer_first_question ( ) [EOL] response = self . answer_second_question ( ) [EOL] assert response . status_code == [number] [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert problem_input_output . has_been_solved ( [number] ) [EOL] [EOL] def test_answer_to_second_problem_if_wrong_should_be_return_appropriate_response ( self ) : [EOL] self . answer_first_question ( ) [EOL] response = self . answer_second_question ( answer_correct_solution = False ) [EOL] assert response . status_code == [number] [EOL] assert [string] in response . data . decode ( ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert not problem_input_output . has_been_solved ( [number] ) [EOL] [EOL] def test_that_the_get_problem_statement_after_answering_second_problem_shows_third_problem ( self ) : [EOL] self . answer_first_question ( ) [EOL] self . answer_second_question ( ) [EOL] response = self . app_test . get ( [string] , headers = { [string] : self . candidate_token } ) [EOL] assert [string] in json . loads ( response . data ) [EOL] assert [string] in response . data . decode ( ) [EOL] self . init_faker_for_input_api_call ( ) [EOL] input_response = self . response_for_input ( problem_number = [number] , auth_token = self . candidate_token ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert input_response . status_code == [number] [EOL] assert problem_input_output . input == json . loads ( input_response . data ) [EOL] [EOL] def test_answer_to_third_problem_if_correct_should_be_reflected_in_the_db ( self ) : [EOL] self . answer_first_question ( ) [EOL] self . answer_second_question ( ) [EOL] response = self . answer_third_question ( ) [EOL] assert response . status_code == [number] [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert problem_input_output . has_been_solved ( [number] ) [EOL] [EOL] def test_answer_to_third_problem_if_wrong_should_be_return_appropriate_response ( self ) : [EOL] self . answer_first_question ( ) [EOL] self . answer_second_question ( ) [EOL] response = self . answer_third_question ( answer_correct_solution = False ) [EOL] assert response . status_code == [number] [EOL] assert [string] in response . data . decode ( ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert not problem_input_output . has_been_solved ( [number] ) [EOL] [EOL] def test_that_the_get_problem_statement_after_answering_third_problem_shows_fourth_problem ( self ) : [EOL] self . answer_first_question ( ) [EOL] self . answer_second_question ( ) [EOL] self . answer_third_question ( ) [EOL] response = self . app_test . get ( [string] , headers = { [string] : self . candidate_token } ) [EOL] assert [string] in json . loads ( response . data ) [EOL] assert [string] in response . data . decode ( ) [EOL] self . init_faker_for_input_api_call ( ) [EOL] input_response = self . response_for_input ( problem_number = [number] , auth_token = self . candidate_token ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert input_response . status_code == [number] [EOL] assert problem_input_output . input == json . loads ( input_response . data ) [EOL] [EOL] def test_answer_to_fourth_problem_if_correct_should_be_reflected_in_the_db ( self ) : [EOL] self . answer_first_question ( ) [EOL] self . answer_second_question ( ) [EOL] self . answer_third_question ( ) [EOL] response = self . answer_fourth_question ( ) [EOL] assert response . status_code == [number] [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert problem_input_output . has_been_solved ( [number] ) [EOL] [EOL] def test_answer_to_fourth_problem_if_wrong_should_be_return_appropriate_response ( self ) : [EOL] self . answer_first_question ( ) [EOL] self . answer_second_question ( ) [EOL] self . answer_third_question ( ) [EOL] response = self . answer_fourth_question ( answer_correct_solution = False ) [EOL] assert response . status_code == [number] [EOL] assert [string] in response . data . decode ( ) [EOL] problem_input_output = QuizRepo . fetch_latest_answer_by_candidate ( self . candidate ) [EOL] assert not problem_input_output . has_been_solved ( [number] ) [EOL] [EOL] def test_that_the_get_problem_statement_after_answering_fourth_problem_shows_completion ( self ) : [EOL] self . answer_first_question ( ) [EOL] self . answer_second_question ( ) [EOL] self . answer_third_question ( ) [EOL] self . answer_fourth_question ( ) [EOL] response = self . app_test . get ( [string] , headers = { [string] : self . candidate_token } ) [EOL] assert [string] in json . loads ( response . data ) [EOL] assert [string] in response . data . decode ( ) [EOL] [EOL] def response_for_input ( self , problem_number , auth_token ) : [EOL] return self . app_test . get ( [string] . format ( problem_number ) , headers = { [string] : auth_token } , ) [EOL] [EOL] def response_for_output ( self , problem_number , auth_token , body ) : [EOL] return self . app_test . post_json ( [string] . format ( problem_number ) , headers = { [string] : auth_token } , body = body , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.SequentialQuiz]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Dict , Optional , Any [EOL] import http_quest [EOL] import typing [EOL] from flask import json [EOL] from flask_babel import gettext as _ [EOL] [EOL] from http_quest . quiz . model import QuizType [EOL] from http_quest . quiz . repo import CandidateRepo [EOL] from test . base import ApiTestBase [EOL] [EOL] [EOL] class TestQuizApi ( ApiTestBase ) : [EOL] def test_creation_of_new_candidate_token_should_successfully_send_emails_to_two_recipients ( self ) : [EOL] user = self . create_user ( ) [EOL] token = self . request_login_token ( self . app_test , user ) [EOL] body = self . sample_quiz_creation_body ( ) [EOL] headers = { [string] : token } [EOL] response = self . app_test . post_json ( url = [string] , body = body , headers = headers ) [EOL] assert response . status_code == [number] [EOL] self . assert_has_one_mail_with_subject_and_recipients ( _ ( [string] ) , [ body . get ( [string] ) , user . email ] ) [EOL] candidate_token = self . mail_body_extract_token ( ) [EOL] candidate = CandidateRepo . fetch_candidate_by_token ( candidate_token ) [EOL] assert candidate . email == [string] [EOL] [EOL] def test_list_quiz_type_returns_list_of_all_quizzes ( self ) : [EOL] token = self . request_login_token ( self . app_test , self . create_user ( ) ) [EOL] headers = { [string] : token } [EOL] response = self . app_test . get ( [string] , headers = headers ) [EOL] assert response . status_code == [number] [EOL] response_json = json . loads ( response . data ) [EOL] assert response_json . get ( [string] ) == [ str ( type_ ) for type_ in QuizType ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[http_quest.quiz.model.Candidate]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import http_quest [EOL] import typing [EOL] from datetime import datetime , timedelta [EOL] [EOL] import pytest [EOL] [EOL] from http_quest . product_quiz . problem_statements import name_with_categories , ProductCollection , Product , ProductFactory [EOL] from fakes import FakeRandom , FakeDatetime [EOL] [EOL] [EOL] class TestProduct : [EOL] @ pytest . fixture ( autouse = True ) def setup ( self ) : [EOL] self . product_list = [ Product ( [string] , [string] , [number] , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) , Product ( [string] , [string] , [number] , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) , Product ( [string] , [string] , [number] , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) , Product ( [string] , [string] , [number] , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) , ] [EOL] FakeDatetime . set_next_dattime ( datetime ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_product_returns_the_correct_count_for_the_solution_1 ( self ) : [EOL] assert Product . solution_count ( self . product_list ) == { [string] : [number] } [EOL] [EOL] def test_product_returns_the_correct_count_for_the_solution_2 ( self ) : [EOL] assert Product . solution_active_count ( self . product_list ) == { [string] : [number] } [EOL] [EOL] def test_product_returns_the_correct_count_for_the_solution_3 ( self ) : [EOL] assert Product . solution_active_date_count_categories ( self . product_list ) == { [string] : [number] , [string] : [number] } [EOL] [EOL] def test_product_returns_the_correct_count_for_the_solution_4 ( self ) : [EOL] assert Product . solution_total_value_for_active_date ( self . product_list ) == { [string] : [number] } [EOL] [EOL] [EOL] class TestProductCollection : [EOL] @ pytest . fixture ( autouse = True ) def setup ( self ) : [EOL] FakeRandom . reset ( ) [EOL] self . product_factory = ProductFactory ( ) [EOL] self . datetime_now = datetime ( year = [number] , month = [number] , day = [number] ) [EOL] [EOL] def test_product_is_generated_correctly ( self ) : [EOL] self . add_one_product_to_fakers ( ) [EOL] product = self . product_factory . new_product ( [number] ) [EOL] assert product . price == [number] [EOL] assert product . start_date == datetime ( year = [number] , month = [number] , day = [number] ) [EOL] assert product . end_date == datetime ( year = [number] , month = [number] , day = [number] ) [EOL] selected_key = list ( name_with_categories . keys ( ) ) [ [number] ] [EOL] assert product . name == selected_key [EOL] assert product . category == name_with_categories [ selected_key ] [EOL] [EOL] def test_product_collection_is_generated_correctly ( self ) : [EOL] self . add_three_products_to_fakers ( ) [EOL] products = ProductCollection . generate_products ( [number] ) [EOL] assert len ( products ) == [number] [EOL] self . setup_current_product1 ( ) [EOL] self . assert_product ( products , self . id ) [EOL] self . setup_current_product2 ( ) [EOL] self . assert_product ( products , self . id ) [EOL] self . setup_current_product3 ( ) [EOL] self . assert_product ( products , self . id ) [EOL] [EOL] def setup_current_product1 ( self ) : [EOL] self . id = [number] [EOL] self . price = [number] [EOL] self . start_date_delta = [number] [EOL] self . end_date_delta = [number] [EOL] [EOL] def setup_current_product2 ( self ) : [EOL] self . id = [number] [EOL] self . price = [number] [EOL] self . start_date_delta = [number] [EOL] self . end_date_delta = [number] [EOL] [EOL] def setup_current_product3 ( self ) : [EOL] self . id = [number] [EOL] self . price = [number] [EOL] self . start_date_delta = [number] [EOL] self . end_date_delta = [number] [EOL] [EOL] def add_one_product_to_fakers ( self ) : [EOL] self . setup_current_product1 ( ) [EOL] self . add_product_parameters_to_fakers ( ) [EOL] [EOL] def add_three_products_to_fakers ( self ) : [EOL] self . add_one_product_to_fakers ( ) [EOL] self . setup_current_product2 ( ) [EOL] self . add_product_parameters_to_fakers ( ) [EOL] self . setup_current_product3 ( ) [EOL] self . add_product_parameters_to_fakers ( ) [EOL] [EOL] def add_product_parameters_to_fakers ( self ) : [EOL] FakeRandom . append_next_randrange ( [ self . price , self . start_date_delta , self . end_date_delta ] ) [EOL] FakeDatetime . set_next_dattime ( self . datetime_now ) [EOL] [EOL] def assert_product ( self , products , id_ ) : [EOL] product = products [ id_ ] [EOL] assert product . price == self . price [EOL] assert product . start_date == self . datetime_now - timedelta ( self . start_date_delta ) [EOL] assert product . end_date == self . datetime_now + timedelta ( self . end_date_delta ) [EOL] selected_key = list ( name_with_categories . keys ( ) ) [ id_ ] [EOL] assert product . name == selected_key [EOL] assert product . category == name_with_categories [ selected_key ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[http_quest.product_quiz.problem_statements.Product]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[http_quest.product_quiz.problem_statements.Product]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[http_quest.product_quiz.problem_statements.Product]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[http_quest.product_quiz.problem_statements.Product]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[http_quest.product_quiz.problem_statements.Product]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0