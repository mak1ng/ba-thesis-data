from setuptools import setup , find_packages [EOL] from registers . core import __version__ [EOL] [EOL] [EOL] setup ( name = [string] , version = __version__ , license = [string] , packages = find_packages ( ) , package_data = { [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , } , include_package_data = True , python_requires = [string] , install_requires = [ [string] , [string] , [string] , ] , entry_points = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] import click [EOL] from . import commands [EOL] from . core import __version__ [EOL] [EOL] [EOL] @ click . group ( ) @ click . version_option ( prog_name = click . style ( [string] , fg = [string] ) , version = __version__ ) def cli ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] cli . add_command ( commands . blob_group ) [EOL] cli . add_command ( commands . build_command ) [EOL] cli . add_command ( commands . context_group ) [EOL] cli . add_command ( commands . init_command ) [EOL] cli . add_command ( commands . patch_group ) [EOL] cli . add_command ( commands . record_group ) [EOL] cli . add_command ( commands . schema_group ) [EOL] cli . add_command ( commands . value_group ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any , Union [EOL] import schema [EOL] import registers [EOL] import hash [EOL] import rsf [EOL] import typing [EOL] import builtins [EOL] import blob [EOL] [docstring] [EOL] [EOL] from typing import List , cast , Union [EOL] from datetime import datetime [EOL] from . entry import Entry , Scope [EOL] from . blob import Blob [EOL] from . hash import Hash [EOL] from . schema import Schema [EOL] from . rsf import Command , Action , assert_root_hash , add_item , append_entry [EOL] from . core import format_timestamp [EOL] [EOL] [EOL] class Patch : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , schema , data , timestamp = None ) : [EOL] [EOL] self . _schema = schema [EOL] [EOL] if not data : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if isinstance ( data [ [number] ] , Blob ) : [EOL] self . _timestamp = timestamp or format_timestamp ( datetime . utcnow ( ) ) [EOL] blobs = cast ( List [ Blob ] , data ) [EOL] self . _commands = collect ( schema . primary_key , blobs , self . _timestamp ) [EOL] [EOL] elif isinstance ( data [ [number] ] , Command ) : [EOL] self . _commands = cast ( List [ Command ] , data ) [EOL] self . _timestamp = [ cast ( Entry , cmd . value ) . timestamp for cmd in self . _commands if cmd . action == Action . AppendEntry ] [ [number] ] [EOL] [EOL] @ property def commands ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _commands [EOL] [EOL] @ property def schema ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _schema [EOL] [EOL] @ property def timestamp ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _timestamp [EOL] [EOL] def add ( self , blob ) : [EOL] [docstring] [EOL] [EOL] self . _commands . extend ( collect ( self . _schema . primary_key , [ blob ] , self . _timestamp ) ) [EOL] [EOL] def seal ( self , start , end ) : [EOL] [docstring] [EOL] [EOL] self . _commands . insert ( [number] , assert_root_hash ( start ) ) [EOL] self . _commands . append ( assert_root_hash ( end ) ) [EOL] [EOL] def is_sealed ( self ) : [EOL] [docstring] [EOL] [EOL] return ( self . _commands [ [number] ] . action == Action . AssertRootHash and self . _commands [ - [number] ] . action == Action . AssertRootHash ) [EOL] [EOL] [EOL] def collect ( primary_key , blobs , timestamp ) : [EOL] [docstring] [EOL] [EOL] commands = [ ] [EOL] [EOL] for blob in blobs : [EOL] key = cast ( str , blob . get ( primary_key ) ) [EOL] entry = Entry ( key , Scope . User , timestamp , blob . digest ( ) ) [EOL] commands . append ( add_item ( blob ) ) [EOL] commands . append ( append_entry ( entry ) ) [EOL] [EOL] return commands [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Patch.schema.Schema$ 0 $typing.Union[typing.List[blob.Blob],typing.List[rsf.Command]]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $registers.schema.Schema$ 0 $Patch.schema.Schema$ 0 0 0 0 $typing.Union[typing.List[blob.Blob],typing.List[rsf.Command]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[blob.Blob],typing.List[rsf.Command]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[registers.blob.Blob]$ 0 0 0 0 0 0 0 0 $typing.Union[typing.List[blob.Blob],typing.List[rsf.Command]]$ 0 0 0 0 0 0 0 0 $Patch.schema.Schema$ 0 0 0 $typing.List[registers.blob.Blob]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[blob.Blob],typing.List[rsf.Command]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[blob.Blob],typing.List[rsf.Command]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $blob.Blob$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $blob.Blob$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hash.Hash$ 0 $hash.Hash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hash.Hash$ 0 0 0 0 0 0 0 0 0 0 0 $hash.Hash$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rsf.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any , Type , List , Tuple , Callable [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from hashlib import sha256 [EOL] from typing import List , Callable , Optional , Tuple [EOL] [EOL] [EOL] Leaf = bytes [EOL] Digest = bytes [EOL] Level = List [ Digest ] [EOL] [EOL] [EOL] class Tree : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , leaves ) : [EOL] self . _hash_fun = sha256 [EOL] self . _leaves = leaves [EOL] self . _levels = build_levels ( self . _leaves , self . _hash_fun ) [EOL] self . _height = len ( self . _levels ) [EOL] [EOL] @ property def root_hash ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _levels [ - [number] ] [ [number] ] [EOL] [EOL] @ property def leaves ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _leaves [EOL] [EOL] @ property def levels ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _levels [EOL] [EOL] @ property def height ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _height [EOL] [EOL] @ property def width ( self ) : [EOL] [docstring] [EOL] [EOL] return len ( self . _leaves ) [EOL] [EOL] [EOL] def build_levels ( leaves , fun ) : [EOL] [docstring] [EOL] [EOL] levels = [ [ hash_leaf ( leaf , fun ) for leaf in leaves ] ] [EOL] [EOL] if not leaves : [EOL] return [ [ hash_empty ( fun ) ] ] [EOL] [EOL] if len ( leaves ) == [number] : [EOL] return levels [EOL] [EOL] while True : [EOL] idx = len ( levels ) [EOL] [EOL] levels . append ( build_level ( levels [ idx - [number] ] , fun ) ) [EOL] [EOL] if len ( levels [ idx ] ) == [number] : [EOL] break [EOL] [EOL] return levels [EOL] [EOL] [EOL] def build_level ( level , fun ) : [EOL] [docstring] [EOL] [EOL] next_level = [ ] [EOL] [EOL] if not level : [EOL] return [ hash_empty ( fun ) ] [EOL] [EOL] if len ( level ) == [number] : [EOL] return level [EOL] [EOL] for left , right in zip ( level [ [number] : : [number] ] , level [ [number] : : [number] ] ) : [EOL] next_level . append ( hash_node ( left , right , fun ) ) [EOL] [EOL] if len ( level ) % [number] == [number] : [EOL] next_level . append ( level [ - [number] ] ) [EOL] [EOL] return next_level [EOL] [EOL] [EOL] def hash_node ( left , right , fun ) : [EOL] [docstring] [EOL] [EOL] hasher = fun ( [string] ) [EOL] hasher . update ( left + right ) [EOL] [EOL] return hasher . digest ( ) [EOL] [EOL] [EOL] def hash_leaf ( leaf , fun ) : [EOL] [docstring] [EOL] [EOL] hasher = fun ( [string] ) [EOL] hasher . update ( leaf ) [EOL] [EOL] return hasher . digest ( ) [EOL] [EOL] [EOL] def hash_empty ( fun ) : [EOL] [docstring] [EOL] [EOL] return fun ( [string] ) . digest ( ) [EOL] [EOL] [EOL] def path ( tree , node_index , level = [number] ) : [EOL] [docstring] [EOL] [EOL] audit_path = [ ] [EOL] [EOL] snapshot = tree . width [EOL] [EOL] if snapshot == [number] : [EOL] return audit_path [EOL] [EOL] last_node_index = ( snapshot - [number] ) >> level [EOL] [EOL] is_last_level = level >= len ( tree . levels ) [EOL] node_overflow = node_index > last_node_index [EOL] [EOL] if is_last_level or node_overflow : [EOL] return audit_path [EOL] [EOL] [comment] [EOL] while last_node_index > [number] : [EOL] ( segment , node_index , last_node_index , level ) = path_segment ( tree , node_index , last_node_index , level ) [EOL] [EOL] if segment : [EOL] audit_path . append ( segment ) [EOL] [EOL] return audit_path [EOL] [EOL] [EOL] def path_segment ( tree , node_index , last_node_index , level ) : [EOL] [docstring] [EOL] [EOL] segment = None [EOL] sib = sibling ( node_index ) [EOL] [EOL] if sib <= last_node_index : [EOL] segment = tree . levels [ level ] [ sib ] [EOL] [EOL] [comment] [EOL] [EOL] node_index = parent ( node_index ) [EOL] last_node_index = parent ( last_node_index ) [EOL] level = level + [number] [EOL] [EOL] return ( segment , node_index , last_node_index , level ) [EOL] [EOL] [EOL] def sibling ( node_index ) : [EOL] [docstring] [EOL] [EOL] return node_index - [number] if is_right_child ( node_index ) else node_index + [number] [EOL] [EOL] [EOL] def is_right_child ( node_index ) : [EOL] [docstring] [EOL] [EOL] return node_index % [number] == [number] [EOL] [EOL] [EOL] def parent ( node_index ) : [EOL] [docstring] [EOL] [EOL] return node_index // [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Leaf]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 $typing.List[Leaf]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Digest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Leaf]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Level]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Level]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Level$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Digest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Digest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Digest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Digest]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[Digest],builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] class Hash : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , algorithm , digest ) : [EOL] self . _algorithm = algorithm [EOL] self . _digest = digest [EOL] [EOL] def __hash__ ( self ) : [EOL] return int ( self . _digest , [number] ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . digest == other . digest and self . algorithm == other . algorithm ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . _algorithm } [string] { self . _digest }" [EOL] [EOL] @ property def algorithm ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _algorithm [EOL] [EOL] @ property def digest ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _digest [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class RegistersException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class OrphanEntry ( RegistersException ) : [EOL] [docstring] [EOL] def __init__ ( self , entry ) : [EOL] message = f" [string] { entry . position } [string] { entry . key } [string] { entry . blob_hash } [string] " [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class InsertException ( RegistersException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AttributeAlreadyExists ( RegistersException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class MissingIdentifier ( RegistersException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InconsistentRecord ( RegistersException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ValidationError ( RegistersException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class MissingEntryKey ( RegistersException ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] message = f" [string] " [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class MissingAttributeIdentifier ( RegistersException ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] message = f" [string] " [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class UnknownAttribute ( ValidationError ) : [EOL] [docstring] [EOL] def __init__ ( self , attr , value ) : [EOL] message = f" [string] { attr } [string] { value } [string] " [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class MissingPrimaryKey ( ValidationError ) : [EOL] [docstring] [EOL] def __init__ ( self , pk , value ) : [EOL] message = f" [string] { pk } [string] { value } [string] " [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class CardinalityMismatch ( ValidationError ) : [EOL] [docstring] [EOL] def __init__ ( self , attr , card , value ) : [EOL] message = f" [string] { attr } [string] { value } [string] { card } [string] " [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class DuplicatedEntry ( ValidationError ) : [EOL] [docstring] [EOL] def __init__ ( self , key , blob ) : [EOL] message = ( f" [string] { key } [string] " f" [string] { blob . to_json ( ) } [string] " ) [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class InconsistentLog ( ValidationError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , expected , actual , size ) : [EOL] message = ( f" [string] { size } [string] " f" [string] { expected }" f" [string] " f" [string] { actual }" ) [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class RepresentationError ( ValidationError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , attr , value , datatype ) : [EOL] message = f" [string] { attr } [string] { value } [string] { datatype } [string] " [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class InvalidValue ( ValidationError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , datatype , value ) : [EOL] self . _datatype = value [EOL] self . _value = value [EOL] [EOL] message = f" [string] { value } [string] { datatype } [string] " [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] @ property def datatype ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _datatype [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _value [EOL] [EOL] [EOL] class InvalidKey ( ValidationError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] message = f" [string] { value } [string] " [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class InvalidCurieValue ( InvalidValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( [string] , value ) [EOL] [EOL] [EOL] class InvalidDatetimeValue ( InvalidValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( [string] , value ) [EOL] [EOL] [EOL] class InvalidNameValue ( InvalidValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( [string] , value ) [EOL] [EOL] [EOL] class InvalidHashValue ( InvalidValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( [string] , value ) [EOL] [EOL] [EOL] class InvalidIntegerValue ( InvalidValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( [string] , value ) [EOL] [EOL] [EOL] class InvalidPeriodValue ( InvalidValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( [string] , value ) [EOL] [EOL] [EOL] class InvalidTimestampValue ( InvalidValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( [string] , value ) [EOL] [EOL] [EOL] class InvalidUrlValue ( InvalidValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( [string] , value ) [EOL] [EOL] [EOL] class CommandError ( RegistersException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , List , Optional , Any [EOL] import registers [EOL] import typing [EOL] import builtins [EOL] import blob [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List , Optional , cast [EOL] import json [EOL] from enum import Enum [EOL] from . exceptions import AttributeAlreadyExists , MissingAttributeIdentifier [EOL] from . blob import Blob [EOL] [EOL] [EOL] DATATYPES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class Cardinality ( Enum ) : [EOL] [docstring] [EOL] [EOL] One = [string] [EOL] Many = [string] [EOL] [EOL] [EOL] class Datatype ( Enum ) : [EOL] [docstring] [EOL] [EOL] Curie = [string] [EOL] Datetime = [string] [EOL] Name = [string] [EOL] Hash = [string] [EOL] Integer = [string] [EOL] Period = [string] [EOL] String = [string] [EOL] Text = [string] [EOL] Timestamp = [string] [EOL] Url = [string] [EOL] [EOL] [EOL] class Attribute : [EOL] [docstring] [EOL] def __init__ ( self , uid , datatype , cardinality , description = None ) : [EOL] if not isinstance ( uid , str ) : [EOL] raise MissingAttributeIdentifier ( ) [EOL] [EOL] self . _uid = uid [EOL] self . _datatype = datatype [EOL] self . _cardinality = cardinality [EOL] self . _description = description [EOL] [EOL] @ staticmethod def headers ( ) : [EOL] [docstring] [EOL] [EOL] return [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . uid == other . uid and self . datatype == other . datatype and self . cardinality == other . cardinality ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . to_json ( ) [EOL] [EOL] def __iter__ ( self ) : [EOL] for item in self . to_dict ( ) . items ( ) : [EOL] yield item [EOL] [EOL] def to_dict ( self ) : [EOL] [docstring] [EOL] [EOL] data = { [string] : self . _uid , [string] : self . _datatype . value , [string] : self . _cardinality . value } [EOL] [EOL] if self . _description : [EOL] data [ [string] ] = self . _description [EOL] [EOL] return data [EOL] [EOL] def to_json ( self ) : [EOL] [docstring] [EOL] [EOL] return json . dumps ( dict ( self ) , separators = ( [string] , [string] ) , ensure_ascii = False ) [EOL] [EOL] def to_blob ( self ) : [EOL] [docstring] [EOL] [EOL] return Blob ( self . to_dict ( ) ) [EOL] [EOL] @ property def uid ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _uid [EOL] [EOL] @ property def datatype ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _datatype [EOL] [EOL] @ property def cardinality ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _cardinality [EOL] [EOL] [EOL] def attribute ( blob ) : [EOL] [docstring] [EOL] uid = cast ( str , blob . get ( [string] ) ) [EOL] datatype = Datatype ( blob . get ( [string] ) ) [EOL] cardinality = Cardinality ( blob . get ( [string] ) ) [EOL] description = cast ( Optional [ str ] , blob . get ( [string] ) ) [EOL] [EOL] return Attribute ( uid , datatype , cardinality , description ) [EOL] [EOL] [EOL] class Schema : [EOL] [docstring] [EOL] def __init__ ( self , primary_key_id , attrs = None ) : [EOL] self . _primary_key = primary_key_id [EOL] self . _attrs = attrs or [ ] [EOL] [EOL] @ property def attributes ( self ) : [EOL] [docstring] [EOL] return self . _attrs [EOL] [EOL] @ property def primary_key ( self ) : [EOL] [docstring] [EOL] return self . _primary_key [EOL] [EOL] def is_ready ( self ) : [EOL] [docstring] [EOL] return ( len ( self . _attrs ) > [number] and self . get ( self . _primary_key ) is not None ) [EOL] [EOL] def insert ( self , attr ) : [EOL] [docstring] [EOL] [EOL] if attr . uid in [ at . uid for at in self . _attrs ] : [EOL] raise AttributeAlreadyExists ( attr ) [EOL] [EOL] self . _attrs . append ( attr ) [EOL] [EOL] def get ( self , uid ) : [EOL] [docstring] [EOL] for attr in self . _attrs : [EOL] if attr . uid == uid : [EOL] return attr [EOL] [EOL] return None [EOL] [EOL] def to_dict ( self ) : [EOL] [docstring] [EOL] [EOL] return { [string] : self . _primary_key , [string] : [ attr . to_dict ( ) for attr in self . _attrs ] } [EOL] [EOL] [EOL] def string ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . String , Cardinality . One , description ) [EOL] [EOL] [EOL] def string_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . String , Cardinality . Many , description ) [EOL] [EOL] [EOL] def integer ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Integer , Cardinality . One , description ) [EOL] [EOL] [EOL] def integer_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Integer , Cardinality . Many , description ) [EOL] [EOL] [EOL] def curie ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Curie , Cardinality . One , description ) [EOL] [EOL] [EOL] def curie_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Curie , Cardinality . Many , description ) [EOL] [EOL] [EOL] def datetime ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Datetime , Cardinality . One , description ) [EOL] [EOL] [EOL] def datetime_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Datetime , Cardinality . Many , description ) [EOL] [EOL] [EOL] def name ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Name , Cardinality . One , description ) [EOL] [EOL] [EOL] def name_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Name , Cardinality . Many , description ) [EOL] [EOL] [EOL] def hash ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Hash , Cardinality . One , description ) [EOL] [EOL] [EOL] def hash_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Hash , Cardinality . Many , description ) [EOL] [EOL] [EOL] def period ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Period , Cardinality . One , description ) [EOL] [EOL] [EOL] def period_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Period , Cardinality . Many , description ) [EOL] [EOL] [EOL] def text ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Text , Cardinality . One , description ) [EOL] [EOL] [EOL] def text_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Text , Cardinality . Many , description ) [EOL] [EOL] [EOL] def timestamp ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Timestamp , Cardinality . One , description ) [EOL] [EOL] [EOL] def timestamp_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Timestamp , Cardinality . Many , description ) [EOL] [EOL] [EOL] def url ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Url , Cardinality . One , description ) [EOL] [EOL] [EOL] def url_set ( uid , description = None ) : [EOL] [docstring] [EOL] [EOL] return Attribute ( uid , Datatype . Url , Cardinality . Many , description ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $Datatype$ 0 $Cardinality$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $registers.schema.Datatype$ 0 $Datatype$ 0 0 0 $registers.schema.Cardinality$ 0 $Cardinality$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Datatype$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Cardinality$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[Attribute]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[Attribute]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 $typing.Optional[Attribute]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Attribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any , Union , List , Pattern , Dict [EOL] import schema [EOL] import registers [EOL] import typing [EOL] import builtins [EOL] import urllib [EOL] [docstring] [EOL] [EOL] import re [EOL] from urllib . parse import urlparse [EOL] from typing import Dict , Union , List , cast [EOL] from . schema import Schema , Cardinality , Datatype , Attribute [EOL] from . exceptions import ( MissingPrimaryKey , CardinalityMismatch , RepresentationError , UnknownAttribute , InvalidCurieValue , InvalidDatetimeValue , InvalidNameValue , InvalidHashValue , InvalidIntegerValue , InvalidPeriodValue , InvalidTimestampValue , InvalidUrlValue ) [EOL] [EOL] [EOL] def validate ( data , schema ) : [EOL] [docstring] [EOL] [EOL] if data . get ( schema . primary_key ) is None : [EOL] raise MissingPrimaryKey ( schema . primary_key , data ) [EOL] [EOL] for key , value in data . items ( ) : [EOL] attr = schema . get ( key ) [EOL] [EOL] if attr is None : [EOL] raise UnknownAttribute ( key , value ) [EOL] [EOL] if value is None : [EOL] continue [EOL] [EOL] if isinstance ( value , List ) : [EOL] if attr . cardinality is not Cardinality . Many : [EOL] raise CardinalityMismatch ( key , attr . cardinality . value , value ) [EOL] [EOL] for token in value : [EOL] validate_value ( token , attr ) [EOL] [EOL] else : [EOL] if attr . cardinality is not Cardinality . One : [EOL] raise CardinalityMismatch ( key , attr . cardinality . value , value ) [EOL] [EOL] validate_value ( value , attr ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def validate_value ( value , attr ) : [EOL] [docstring] [EOL] [EOL] if not isinstance ( value , str ) : [EOL] raise RepresentationError ( attr . uid , value , attr . datatype . value ) [EOL] [EOL] validate_value_datatype ( value , attr . datatype ) [EOL] [EOL] [EOL] CURIE_RE = re . compile ( [string] ) [EOL] DATETIME_RE = re . compile ( [string] ) [comment] [EOL] NAME_RE = re . compile ( [string] ) [EOL] KEY_RE = re . compile ( [string] ) [EOL] KEY_CONSECUTIVE_RE = re . compile ( [string] ) [EOL] HASH_RE = re . compile ( [string] ) [EOL] INTEGER_RE = re . compile ( [string] ) [EOL] PERIOD_RE = re . compile ( [string] ) [EOL] TIMESTAMP_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] def validate_value_datatype ( value , datatype ) : [EOL] [docstring] [EOL] [EOL] if datatype is Datatype . Curie and not validate_curie ( value ) : [EOL] raise InvalidCurieValue ( value ) [EOL] [EOL] if datatype is Datatype . Datetime and not validate_datetime ( value ) : [EOL] raise InvalidDatetimeValue ( value ) [EOL] [EOL] if datatype is Datatype . Name and not validate_name ( value ) : [EOL] raise InvalidNameValue ( value ) [EOL] [EOL] if datatype is Datatype . Hash and not validate_hash ( value ) : [EOL] raise InvalidHashValue ( value ) [EOL] [EOL] if datatype is Datatype . Integer and not validate_integer ( value ) : [EOL] raise InvalidIntegerValue ( value ) [EOL] [EOL] if datatype is Datatype . Period and not validate_period ( value ) : [EOL] raise InvalidPeriodValue ( value ) [EOL] [EOL] if datatype is Datatype . Timestamp and not validate_timestamp ( value ) : [EOL] raise InvalidTimestampValue ( value ) [EOL] [EOL] if datatype is Datatype . Url and not validate_url ( value ) : [EOL] raise InvalidUrlValue ( value ) [EOL] [EOL] [comment] [EOL] return True [EOL] [EOL] [EOL] def validate_key ( key ) : [EOL] [docstring] [EOL] [EOL] return cast ( bool , KEY_RE . match ( key ) and not KEY_CONSECUTIVE_RE . match ( key ) ) [EOL] [EOL] [EOL] def validate_curie ( value ) : [EOL] [docstring] [EOL] [EOL] return cast ( bool , CURIE_RE . match ( value ) ) [EOL] [EOL] [EOL] def validate_datetime ( value ) : [EOL] [docstring] [EOL] [EOL] return cast ( bool , DATETIME_RE . match ( value ) ) [EOL] [EOL] [EOL] def validate_name ( value ) : [EOL] [docstring] [EOL] [EOL] return cast ( bool , NAME_RE . match ( value ) ) [EOL] [EOL] [EOL] def validate_hash ( value ) : [EOL] [docstring] [EOL] [EOL] return cast ( bool , HASH_RE . match ( value ) ) [EOL] [EOL] [EOL] def validate_integer ( value ) : [EOL] [docstring] [EOL] [EOL] return cast ( bool , INTEGER_RE . match ( value ) ) [EOL] [EOL] [EOL] def validate_period ( value ) : [EOL] [docstring] [EOL] [EOL] if value . find ( [string] ) != - [number] : [EOL] start , end = value . split ( [string] ) [EOL] [EOL] return _is_valid_period_part ( start ) and _is_valid_period_part ( end ) [EOL] [EOL] return _is_valid_duration ( value ) [EOL] [EOL] [EOL] def validate_timestamp ( value ) : [EOL] [docstring] [EOL] [EOL] return cast ( bool , TIMESTAMP_RE . match ( value ) ) [EOL] [EOL] [EOL] def validate_url ( value ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] result = urlparse ( value ) [EOL] is_known_scheme = result . scheme in [ [string] , [string] ] [EOL] has_hostname = result . hostname and result . hostname . find ( [string] ) != - [number] [EOL] [EOL] return cast ( bool , is_known_scheme and has_hostname ) [EOL] [EOL] except ValueError : [EOL] return False [EOL] [EOL] [EOL] def validate_string ( _value ) : [EOL] [docstring] [EOL] [EOL] return True [EOL] [EOL] [EOL] def validate_text ( _value ) : [EOL] [docstring] [EOL] [EOL] return True [EOL] [EOL] [EOL] def _is_valid_duration ( value ) : [EOL] return ( PERIOD_RE . match ( value ) is not None [EOL] and value != [string] [EOL] and not value . endswith ( [string] ) ) [EOL] [EOL] [EOL] def _is_valid_period_part ( value ) : [EOL] return DATETIME_RE . match ( value ) or _is_valid_duration ( value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Optional , Any , Union , List , Dict [EOL] import typing [EOL] import hash [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Dict , Union , List , Optional [EOL] from hashlib import sha256 [EOL] import json [EOL] from . hash import Hash [EOL] [EOL] [EOL] Value = Union [ str , List [ str ] ] [EOL] [EOL] [EOL] class Blob : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data ) : [EOL] self . _data = data [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . digest ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . digest ( ) == other . digest ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . to_json ( ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( sorted ( self . _data . items ( ) ) ) [EOL] [EOL] def digest ( self ) : [EOL] [docstring] [EOL] [EOL] buffer = self . to_json ( ) . encode ( [string] ) [EOL] [EOL] return Hash ( [string] , sha256 ( buffer ) . hexdigest ( ) ) [EOL] [EOL] def to_json ( self ) : [EOL] [docstring] [EOL] [EOL] return json . dumps ( self . _data , sort_keys = True , separators = ( [string] , [string] ) , ensure_ascii = False ) [EOL] [EOL] def to_dict ( self ) : [EOL] [docstring] [EOL] [EOL] return { k : v for k , v in sorted ( self . _data . items ( ) ) } [EOL] [EOL] def get ( self , key ) : [EOL] [docstring] [EOL] return self . _data . get ( key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Value]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 $typing.Dict[builtins.str,Value]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hash.Hash$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Value]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [EOL] import Record [EOL] from typing import Dict , List , Optional , Any [EOL] import schema [EOL] import registers [EOL] import entry [EOL] import typing [EOL] import builtins [EOL] import blob [EOL] [docstring] [EOL] [EOL] from typing import Optional , Any , Dict , List [EOL] import json [EOL] from . entry import Entry [EOL] from . blob import Blob , Value [EOL] from . schema import Schema [EOL] from . exceptions import InconsistentRecord [EOL] [EOL] [EOL] class Record : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , entry , blob ) : [EOL] if entry . blob_hash != blob . digest ( ) : [EOL] raise InconsistentRecord ( ( entry . key , entry . blob_hash ) ) [EOL] [EOL] self . _entry = entry [EOL] self . _blob = blob [EOL] [EOL] @ staticmethod def headers ( schema ) : [EOL] [docstring] [EOL] [EOL] headers = Entry . headers ( ) [EOL] headers . extend ( [ attr . uid for attr in schema . attributes ] ) [EOL] [EOL] return [ header for header in headers if header != [string] ] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . _entry , self . _blob ) == ( other . entry , other . blob ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . to_json ( ) [EOL] [EOL] def to_json ( self ) : [EOL] [docstring] [EOL] [EOL] return json . dumps ( { self . _entry . key : self . to_dict ( ) } , separators = ( [string] , [string] ) , ensure_ascii = False ) [EOL] [EOL] def to_dict ( self ) : [EOL] [docstring] [EOL] [EOL] data = self . _entry . to_dict ( ) [EOL] del data [ [string] ] [EOL] data [ [string] ] = [ self . _blob . to_dict ( ) ] [EOL] [EOL] return data [EOL] [EOL] @ property def entry ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _entry [EOL] [EOL] @ property def blob ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _blob [EOL] [EOL] def get ( self , key ) : [EOL] [docstring] [EOL] [EOL] return self . _blob . get ( key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Record.blob.Blob$ 0 0 0 0 0 0 0 0 $Record.blob.Blob$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $registers.entry.Entry$ 0 0 0 0 0 $registers.blob.Blob$ 0 $Record.blob.Blob$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $schema.Schema$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $schema.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $Record.entry.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Record.blob.Blob$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Record.blob.Value]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [EOL] from typing import Optional , Any , Union , Type , List , Tuple , Dict [EOL] import registers [EOL] import hash [EOL] import entry [EOL] import rsf [EOL] import typing [EOL] import builtins [EOL] import exceptions [EOL] import record [EOL] import blob [EOL] [docstring] [EOL] [EOL] from typing import List , Dict , Union , Optional , cast , Tuple [EOL] from . rsf . parser import Command , Action [EOL] from . exceptions import ( OrphanEntry , InsertException , DuplicatedEntry , ValidationError , InconsistentLog ) [EOL] from . blob import Blob [EOL] from . hash import Hash [EOL] from . record import Record [EOL] from . entry import Entry , Scope [EOL] from . import merkle [EOL] [EOL] [EOL] class Log : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , entries = None , blobs = None ) : [EOL] self . _entries = entries or [ ] [EOL] self . _blobs = blobs or { } [EOL] self . _size = len ( self . _entries ) [EOL] self . _digest = merkle . Tree ( self . byte_entries ( ) ) . root_hash [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . digest ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . digest ( ) == other . digest ( ) [EOL] [EOL] def digest ( self ) : [EOL] [docstring] [EOL] [EOL] return Hash ( [string] , self . _digest . hex ( ) ) [EOL] [EOL] def byte_entries ( self ) : [EOL] [docstring] [EOL] [EOL] return [ entry . bytes ( ) for entry in self . _entries ] [EOL] [EOL] @ property def blobs ( self ) : [EOL] [docstring] [EOL] return self . _blobs [EOL] [EOL] @ property def entries ( self ) : [EOL] [docstring] [EOL] return self . _entries [EOL] [EOL] @ property def size ( self ) : [EOL] [docstring] [EOL] return self . _size [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return self . _size == [number] [EOL] [EOL] def snapshot ( self , size = None ) : [EOL] [docstring] [EOL] [EOL] records = { } [EOL] [EOL] for entry in self . _entries [ : size ] : [EOL] records [ entry . key ] = Record ( entry , self . _blobs [ entry . blob_hash ] ) [EOL] [EOL] return records [EOL] [EOL] def trail ( self , key , size = None ) : [EOL] [docstring] [EOL] return [ entry for entry in self . _entries [ : size ] if entry . key == key ] [EOL] [EOL] def stats ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _size , [string] : len ( self . _blobs ) } [EOL] [EOL] def insert ( self , obj ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( obj , Entry ) : [EOL] self . _size = self . size + [number] [EOL] obj . set_position ( self . _size ) [EOL] self . _entries . append ( obj ) [EOL] self . _digest = merkle . Tree ( self . byte_entries ( ) ) . root_hash [EOL] [EOL] elif isinstance ( obj , Blob ) : [EOL] self . _blobs [ obj . digest ( ) ] = obj [EOL] [EOL] else : [EOL] msg = [string] . format ( type ( obj ) ) [comment] [EOL] raise InsertException ( msg ) [EOL] [EOL] def find ( self , key ) : [EOL] [docstring] [EOL] [EOL] return self . snapshot ( ) . get ( key ) [EOL] [EOL] [EOL] def collect ( commands , log = None , metalog = None , relaxed = False , progress = None ) : [EOL] [docstring] [EOL] data = log or Log ( ) [EOL] metadata = metalog or Log ( ) [EOL] blobs = { ** data . blobs , ** metadata . blobs } [EOL] errors = [ ] [EOL] [EOL] for command in commands : [EOL] _collect_command ( command , data , metadata , blobs , errors , relaxed ) [EOL] [EOL] if progress : [EOL] progress ( ) [EOL] [EOL] return { [string] : data , [string] : metadata , [string] : errors } [EOL] [EOL] [EOL] def slice ( log , start_position ) : [EOL] [docstring] [EOL] [EOL] commands = [ ] [EOL] [EOL] for entry in log . entries [ start_position : ] : [EOL] commands . append ( Command ( Action . AddItem , log . blobs [ entry . blob_hash ] ) ) [EOL] commands . append ( Command ( Action . AppendEntry , entry ) ) [EOL] [EOL] return commands [EOL] [EOL] [EOL] def _collect_command ( command , data , metadata , blobs , errors , relaxed ) : [EOL] if command . action == Action . AssertRootHash : [EOL] digest = cast ( Hash , command . value ) [EOL] [EOL] if digest != data . digest ( ) : [EOL] raise InconsistentLog ( digest , data . digest ( ) , data . size ) [EOL] [EOL] elif command . action == Action . AddItem : [EOL] blobs [ command . value . digest ( ) ] = cast ( Blob , command . value ) [EOL] [EOL] elif command . action == Action . AppendEntry : [EOL] entry = cast ( Entry , command . value ) [EOL] blob = blobs . get ( entry . blob_hash ) [EOL] [EOL] if blob is None : [EOL] raise OrphanEntry ( entry ) [EOL] [EOL] if entry . scope == Scope . System : [EOL] metadata . insert ( blob ) [EOL] record = metadata . snapshot ( ) . get ( entry . key ) [EOL] ( _ , err ) = _collect_entry ( entry , record ) [EOL] [EOL] if err and not relaxed : [EOL] errors . append ( err ) [EOL] else : [EOL] metadata . insert ( entry ) [EOL] else : [EOL] data . insert ( blob ) [EOL] record = data . snapshot ( ) . get ( entry . key ) [EOL] ( _ , err ) = _collect_entry ( entry , record ) [EOL] [EOL] if err and not relaxed : [EOL] errors . append ( err ) [EOL] else : [EOL] data . insert ( entry ) [EOL] [EOL] [EOL] Result = Tuple [ Optional [ Entry ] , Optional [ ValidationError ] ] [EOL] [EOL] [EOL] def _collect_entry ( entry , record ) : [EOL] if record and record . blob . digest ( ) == entry . blob_hash : [EOL] return ( None , DuplicatedEntry ( entry . key , record . blob ) ) [EOL] [EOL] return ( entry , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[entry.Entry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,record.Record]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.List[entry.Entry]$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[entry.Entry,blob.Blob]$ 0 0 0 0 0 0 0 0 0 $typing.Union[entry.Entry,blob.Blob]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[entry.Entry,blob.Blob]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[entry.Entry,blob.Blob]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[entry.Entry,blob.Blob]$ 0 0 0 0 0 0 0 0 0 $typing.Union[entry.Entry,blob.Blob]$ 0 0 0 0 0 0 $typing.Union[entry.Entry,blob.Blob]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[entry.Entry,blob.Blob]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[record.Record]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , List , Optional , Callable [EOL] import schema [EOL] import registers [EOL] import patch [EOL] import entry [EOL] import rsf [EOL] import log [EOL] import typing [EOL] import builtins [EOL] import exceptions [EOL] import record [EOL] [docstring] [EOL] [EOL] from typing import List , Dict , Optional , Callable , cast [EOL] from . rsf . parser import Command [EOL] from . log import Log , collect [EOL] from . schema import Schema , attribute [EOL] from . exceptions import MissingIdentifier , ValidationError [EOL] from . entry import Entry [EOL] from . record import Record [EOL] from . patch import Patch [EOL] [EOL] [EOL] class Register : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , commands = None , progress = None ) : [EOL] self . _log = Log ( ) [EOL] self . _metalog = Log ( ) [EOL] self . _commands = [ ] [EOL] self . _uid = None [EOL] self . _update_date = None [EOL] [EOL] if commands is not None : [EOL] self . _load_commands ( commands , progress ) [EOL] [EOL] def _load_commands ( self , commands , progress ) : [EOL] [docstring] [EOL] [EOL] if commands : [EOL] pair = collect ( commands , relaxed = True , progress = progress ) [EOL] [EOL] self . _commands = commands [EOL] self . _log = cast ( Log , pair [ [string] ] ) [EOL] self . _metalog = cast ( Log , pair [ [string] ] ) [EOL] self . _collect_basic_metadata ( ) [EOL] [EOL] def _collect_basic_metadata ( self ) : [EOL] name_blob = self . _metalog . find ( [string] ) [EOL] if name_blob : [EOL] self . _uid = name_blob . get ( [string] ) [EOL] self . _collect_update_date ( ) [EOL] [EOL] def _collect_update_date ( self ) : [EOL] if not self . _log . is_empty ( ) : [EOL] self . _update_date = self . _log . entries [ - [number] ] . timestamp [EOL] elif not self . _metalog . is_empty ( ) : [EOL] self . _update_date = self . _metalog . entries [ - [number] ] . timestamp [EOL] [EOL] def apply ( self , patch ) : [EOL] [docstring] [EOL] pair = collect ( patch . commands , self . _log , self . _metalog ) [EOL] self . _log = cast ( Log , pair [ [string] ] ) [EOL] self . _metalog = cast ( Log , pair [ [string] ] ) [EOL] [EOL] self . _apply_commands ( patch . commands ) [EOL] self . _collect_update_date ( ) [EOL] [EOL] return cast ( List [ ValidationError ] , pair [ [string] ] ) [EOL] [EOL] def _apply_commands ( self , cmds ) : [EOL] [docstring] [EOL] [EOL] if self . _commands [ - [number] ] == cmds [ [number] ] : [EOL] self . _commands . extend ( cmds [ [number] : ] ) [EOL] else : [EOL] self . _commands . extend ( cmds ) [EOL] [EOL] def stats ( self ) : [EOL] [docstring] [EOL] [EOL] return { [string] : self . _log . stats ( ) , [string] : self . _metalog . stats ( ) } [EOL] [EOL] @ property def uid ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _uid [EOL] [EOL] @ property def commands ( self ) : [EOL] [docstring] [EOL] return self . _commands [EOL] [EOL] @ property def log ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _log [EOL] [EOL] @ property def metalog ( self ) : [EOL] [docstring] [EOL] return self . _metalog [EOL] [EOL] def records ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _log . snapshot ( ) [EOL] [EOL] def record ( self , key ) : [EOL] [docstring] [EOL] [EOL] return self . _log . find ( key ) [EOL] [EOL] def trail ( self , key ) : [EOL] [docstring] [EOL] [EOL] return self . _log . trail ( key ) [EOL] [EOL] def schema ( self ) : [EOL] [docstring] [EOL] [EOL] if self . _uid is None : [EOL] raise MissingIdentifier ( [string] ) [EOL] [EOL] attrs = [ attribute ( value ) for key , value in self . _metalog . snapshot ( ) . items ( ) if key . startswith ( [string] ) ] [EOL] [EOL] return Schema ( self . _uid , attrs ) [EOL] [EOL] def context ( self ) : [EOL] [docstring] [EOL] [EOL] if self . _uid is None : [EOL] raise MissingIdentifier ( ( [string] [string] ) ) [EOL] [EOL] result = { [string] : len ( self . records ( ) ) , [string] : self . _log . size , [string] : self . _update_date } [EOL] [EOL] fname = f" [string] { self . _uid }" [EOL] [EOL] if self . _metalog . find ( fname ) is not None : [EOL] result [ [string] ] = ( self . _metalog . find ( fname ) . blob . to_dict ( ) ) [EOL] [EOL] if self . _metalog . find ( [string] ) is not None : [EOL] result [ [string] ] = ( self . _metalog . find ( [string] ) . blob . get ( [string] ) ) [EOL] [EOL] return result [EOL] [EOL] def title ( self ) : [EOL] [docstring] [EOL] record = cast ( Record , self . _metalog . find ( [string] ) ) [EOL] [EOL] return cast ( Optional [ str ] , record . blob . get ( [string] ) ) [EOL] [EOL] def description ( self ) : [EOL] [docstring] [EOL] key = f" [string] { self . uid }" [EOL] record = cast ( Record , self . _metalog . find ( key ) ) [EOL] [EOL] return cast ( Optional [ str ] , record . blob . to_dict ( ) . get ( [string] ) ) [EOL] [EOL] def is_ready ( self ) : [EOL] [docstring] [EOL] return self . _uid is not None and self . schema ( ) . is_ready ( ) [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return self . _log . is_empty ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $registers.record.Record$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $registers.record.Record$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $registers.record.Record$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $registers.record.Record$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import TextIO , Optional , Any , Type , List , Dict [EOL] import schema [EOL] import registers [EOL] import typing [EOL] import builtins [EOL] import _csv [EOL] import blob [EOL] [docstring] [EOL] [EOL] from typing import List , NewType , Dict , cast , Optional , TextIO [EOL] import csv [EOL] from io import StringIO [EOL] from . blob import Blob , Value [EOL] from . entry import Entry [EOL] from . record import Record [EOL] from . schema import Cardinality , Schema [EOL] from . exceptions import RegistersException , UnknownAttribute , InvalidKey [EOL] from . validator import validate , validate_key [EOL] [EOL] [EOL] Row = NewType ( [string] , List [ str ] ) [EOL] [EOL] [EOL] def serialise ( stream , obj , headers ) : [EOL] [docstring] [EOL] [EOL] writer = csv . writer ( stream ) [EOL] writer . writerow ( headers ) [EOL] [EOL] if isinstance ( obj , List ) : [EOL] for element in obj : [EOL] row = serialise_object ( element , headers = headers ) [EOL] writer . writerow ( row ) [EOL] [EOL] elif isinstance ( obj , Dict ) : [EOL] for element in obj . values ( ) : [EOL] row = serialise_object ( element , headers = headers ) [EOL] writer . writerow ( row ) [EOL] [EOL] else : [EOL] row = serialise_object ( obj , headers = headers ) [EOL] writer . writerow ( row ) [EOL] [EOL] [EOL] def serialise_object ( obj , headers = None ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( obj , Blob ) : [EOL] if headers is None : [EOL] raise RegistersException ( [string] ) [EOL] [EOL] return cast ( Row , [ obj . get ( header ) for header in headers ] ) [EOL] [EOL] if isinstance ( obj , Entry ) : [EOL] return cast ( Row , [ str ( obj . position ) , str ( obj . position ) , obj . timestamp , obj . key , str ( obj . blob_hash ) ] ) [EOL] [EOL] if isinstance ( obj , Record ) : [EOL] if headers is None : [EOL] raise RegistersException ( [string] ) [EOL] [EOL] headers = [ header for header in headers if header not in Entry . headers ( ) ] [EOL] [EOL] result = serialise_object ( obj . entry ) [ : - [number] ] [EOL] result . extend ( serialise_object ( obj . blob , headers ) ) [EOL] [EOL] return cast ( Row , result ) [EOL] [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def serialise_value ( value ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( value , List ) : [EOL] return [string] . join ( [ quote_value ( v ) for v in value ] ) [EOL] [EOL] return value [EOL] [EOL] [EOL] def quote_value ( value ) : [EOL] [docstring] [EOL] [EOL] if value . find ( [string] ) != - [number] : [EOL] return f' [string] { value } [string] ' [EOL] [EOL] return value [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def deserialise ( buffer , schema ) : [EOL] [docstring] [EOL] [EOL] dialect = csv . Sniffer ( ) . sniff ( buffer . read ( [number] ) ) [EOL] buffer . seek ( [number] ) [EOL] [EOL] return [ coerce ( row , schema ) for row in csv . DictReader ( buffer , dialect = dialect ) ] [EOL] [EOL] [EOL] def deserialise_value ( token , cardinality ) : [EOL] [docstring] [EOL] [EOL] if token is None or token . strip ( ) == [string] : [EOL] return None [EOL] [EOL] if cardinality == Cardinality . Many : [EOL] return [ value . strip ( ) for value in split_token ( token ) if value . strip ( ) != [string] ] [EOL] [EOL] return token . strip ( ) [EOL] [EOL] [EOL] def split_token ( token ) : [EOL] [docstring] [EOL] stream = csv . reader ( StringIO ( token ) , delimiter = [string] ) [EOL] [EOL] return next ( stream ) [EOL] [EOL] [EOL] def coerce ( data , schema ) : [EOL] [docstring] [EOL] [EOL] clean_data = { } [EOL] [EOL] for key , value in data . items ( ) : [EOL] if value is None or value . strip ( ) in [ [string] , [string] ] : [EOL] continue [EOL] [EOL] key = key . strip ( ) [EOL] attr = schema . get ( key ) [EOL] [EOL] if attr is None : [EOL] raise UnknownAttribute ( key , value ) [EOL] [EOL] if key == schema . primary_key and not validate_key ( value ) : [EOL] raise InvalidKey ( value ) [EOL] [EOL] clean_data [ key ] = cast ( Value , deserialise_value ( value , attr . cardinality ) ) [EOL] [EOL] validate ( clean_data , schema ) [EOL] [EOL] return Blob ( clean_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Row$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[blob.Blob]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[blob.Value]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $blob.Blob$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from . blob import Blob , Value [EOL] from . entry import Entry , Scope [EOL] from . hash import Hash [EOL] from . log import Log [EOL] from . record import Record [EOL] from . register import Register [EOL] from . schema import Schema , Attribute , attribute , Datatype , Cardinality [EOL] from . patch import Patch [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] EMPTY_ROOT_HASH = [string] [comment] [EOL] SHA256_PREFIX = [string] [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] def format_timestamp ( datetime ) : [EOL] [docstring] [EOL] [EOL] return f"{ datetime . isoformat ( timespec = [string] ) } [string] " [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class UnknownCommand ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UnexpectedEntry ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UnexpectedBlob ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AppendEntryCommandException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AddItemCommandException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AssertRootHashCommandException ( Exception ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import TextIO , Union , List [EOL] import core [EOL] import hash [EOL] import entry [EOL] import typing [EOL] import builtins [EOL] import blob [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List , TextIO , Union [EOL] import json [EOL] from . . blob import Blob [EOL] from . . entry import Entry , Scope [EOL] from . . hash import Hash [EOL] from . exceptions import ( UnknownCommand , AppendEntryCommandException , AddItemCommandException , AssertRootHashCommandException ) [EOL] from . core import Action , Command [EOL] [EOL] [EOL] def load ( original ) : [EOL] [docstring] [EOL] [EOL] return parse ( original . splitlines ( ) ) [EOL] [EOL] [EOL] def parse ( patch_lines ) : [EOL] [docstring] [EOL] [EOL] return [ parse_command ( token ) for token in patch_lines ] [EOL] [EOL] [EOL] def parse_command ( original ) : [EOL] [docstring] [EOL] try : [EOL] action , rest = original . split ( [string] , [number] ) [EOL] except ValueError : [EOL] raise UnknownCommand ( original ) [EOL] [EOL] if action == Action . AddItem . value : [EOL] try : [EOL] return Command ( Action . AddItem , parse_blob ( rest ) ) [EOL] except ValueError : [EOL] raise AddItemCommandException ( original ) [EOL] [EOL] elif action == Action . AppendEntry . value : [EOL] try : [EOL] return Command ( Action . AppendEntry , parse_entry ( rest ) ) [EOL] except ValueError : [EOL] raise AppendEntryCommandException ( original ) [EOL] [EOL] elif action == Action . AssertRootHash . value : [EOL] try : [EOL] return Command ( Action . AssertRootHash , parse_hash ( rest ) ) [EOL] except ValueError : [EOL] raise AssertRootHashCommandException ( original ) [EOL] [EOL] else : [EOL] raise UnknownCommand ( original ) [EOL] [EOL] [EOL] def parse_blob ( original ) : [EOL] [docstring] [EOL] [EOL] return Blob ( json . loads ( original . strip ( ) ) ) [EOL] [EOL] [EOL] def parse_entry ( original ) : [EOL] [docstring] [EOL] [EOL] scope , key , timestamp , blob_hash = original . strip ( ) . split ( [string] ) [EOL] [EOL] return Entry ( key , Scope ( scope ) , timestamp , parse_hash ( blob_hash ) ) [EOL] [EOL] [EOL] def parse_hash ( original ) : [EOL] [docstring] [EOL] [EOL] algorithm , digest = original . strip ( ) . split ( [string] ) [EOL] [EOL] return Hash ( algorithm , digest ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[core.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[core.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $blob.Blob$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $entry.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hash.Hash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import core [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List [EOL] from . core import ( Action , Command , assert_root_hash , add_item , append_entry ) [EOL] from . parser import parse , load [comment] [EOL] [EOL] [EOL] def read ( filepath ) : [EOL] [docstring] [EOL] [EOL] with open ( filepath , [string] ) as handle : [EOL] return parse ( handle ) [EOL] [EOL] [EOL] def dump ( commands ) : [EOL] [docstring] [EOL] [EOL] return [string] . join ( [ str ( command ) for command in commands ] ) + [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[core.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any , Union [EOL] import registers [EOL] import hash [EOL] import entry [EOL] import typing [EOL] import blob [EOL] [docstring] [EOL] [EOL] from typing import Union [EOL] from enum import Enum [EOL] from . . blob import Blob [EOL] from . . entry import Entry [EOL] from . . hash import Hash [EOL] [EOL] [EOL] Value = Union [ Blob , Entry , Hash ] [EOL] [EOL] [EOL] class Action ( Enum ) : [EOL] [docstring] [EOL] [EOL] AddItem = [string] [EOL] AppendEntry = [string] [EOL] AssertRootHash = [string] [EOL] [EOL] [EOL] class Command : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , action , value ) : [EOL] self . _action = action [EOL] self . _value = value [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . _action == other . action and self . _value == other . value ) [EOL] [EOL] def __repr__ ( self ) : [EOL] tokens = [ ] [EOL] [EOL] if isinstance ( self . _value , Blob ) : [EOL] tokens = [ self . _action . value , self . _value ] [EOL] [EOL] if isinstance ( self . _value , Entry ) : [EOL] tokens = [ self . _action . value , self . _value . scope . value , self . _value . key , self . _value . timestamp , self . _value . blob_hash ] [EOL] [EOL] if isinstance ( self . _value , Hash ) : [EOL] tokens = [ self . _action . value , self . _value ] [EOL] [EOL] return [string] . join ( [ str ( x ) for x in tokens ] ) [EOL] [EOL] @ property def action ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _action [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] [EOL] return self . _value [EOL] [EOL] [EOL] def assert_root_hash ( root_hash ) : [EOL] [docstring] [EOL] [EOL] return Command ( Action . AssertRootHash , root_hash ) [EOL] [EOL] [EOL] def add_item ( blob ) : [EOL] [docstring] [EOL] [EOL] return Command ( Action . AddItem , blob ) [EOL] [EOL] [EOL] def append_entry ( entry ) : [EOL] [docstring] [EOL] [EOL] return Command ( Action . AppendEntry , entry ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Action$ 0 $Value$ 0 0 0 0 0 $registers.rsf.core.Action$ 0 $Action$ 0 0 0 $typing.Union[registers.blob.Blob,registers.entry.Entry,registers.hash.Hash]$ 0 $Value$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $Action$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Value$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from . import utils [EOL] from . build import build_command [EOL] from . init import init_command [EOL] from . record import record_group [EOL] from . blob import blob_group [EOL] from . context import context_group [EOL] from . patch import patch_group [EOL] from . schema import schema_group [EOL] from . value import value_group [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , List , Any , Union [EOL] import csv [EOL] import registers [EOL] import io [EOL] import rsf [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import csv [EOL] import json [EOL] from datetime import datetime [EOL] from typing import List , cast [EOL] from io import StringIO [EOL] import click [EOL] from . . import rsf , Register , Entry , Scope , Blob , Patch , Record [EOL] from . . exceptions import RegistersException [EOL] from . . core import format_timestamp [EOL] from . import utils [EOL] [EOL] [EOL] @ click . group ( name = [string] ) def context_group ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ context_group . command ( name = [string] ) @ click . argument ( [string] , type = click . Path ( exists = False ) ) @ click . option ( [string] , [string] , type = click . Choice ( [ [string] , [string] ] ) ) def show_command ( rsf_file , output_format ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] context = register . context ( ) [EOL] [EOL] if output_format == [string] : [EOL] click . echo ( json . dumps ( context ) ) [EOL] [EOL] else : [EOL] context [ [string] ] = register . uid [EOL] [EOL] if context . get ( [string] ) : [EOL] register_record = context [ [string] ] [EOL] [EOL] context [ [string] ] = [string] . join ( register_record [ [string] ] ) [EOL] context [ [string] ] = register_record [ [string] ] [EOL] [EOL] del context [ [string] ] [EOL] [EOL] if output_format == [string] : [EOL] stream = StringIO ( ) [EOL] [EOL] writer = csv . DictWriter ( stream , fieldnames = context . keys ( ) ) [EOL] writer . writeheader ( ) [EOL] writer . writerow ( context ) [EOL] [EOL] stream . seek ( [number] ) [EOL] click . echo ( stream . read ( ) ) [EOL] [EOL] else : [EOL] for key , value in context . items ( ) : [EOL] click . secho ( f"{ key } [string] " , fg = [string] , bold = True ) [EOL] click . echo ( f" [string] { value } [string] " ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] @ context_group . command ( name = [string] ) @ click . argument ( [string] , type = click . Choice ( [ [string] , [string] , [string] ] ) ) @ click . argument ( [string] ) @ click . option ( [string] , default = format_timestamp ( datetime . utcnow ( ) ) , help = ( [string] [string] ) ) @ click . option ( [string] , [string] , required = True , type = click . Path ( exists = True ) , help = [string] ) @ click . option ( [string] , [string] , is_flag = True , help = [string] ) def create_command ( key , value , rsf_file , timestamp , apply_flag ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] patch = create_patch ( key , value , timestamp , register ) [EOL] [EOL] if apply_flag : [EOL] register . apply ( patch ) [EOL] [EOL] with open ( rsf_file , [string] ) as stream : [EOL] stream . writelines ( [ f"{ cmd } [string] " for cmd in patch . commands ] ) [EOL] [EOL] msg = f" [string] { len ( cmds ) } [string] { rsf_file }" [EOL] [EOL] utils . success ( msg ) [EOL] [EOL] else : [EOL] for obj in patch . commands : [EOL] click . echo ( obj ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] def create_patch ( key , value , timestamp , register ) : [EOL] [docstring] [EOL] [EOL] if key == [string] : [EOL] cmds = context_patch ( [string] , value , timestamp ) [EOL] [EOL] elif key == [string] : [EOL] cmds = context_patch ( [string] , value , timestamp ) [EOL] [EOL] elif key == [string] : [EOL] cmds = description_patch ( value , timestamp , register ) [EOL] [EOL] else : [EOL] raise RegistersException ( f" [string] { key } [string] " ) [EOL] [EOL] return Patch ( register . schema ( ) , cmds ) [EOL] [EOL] [EOL] def description_patch ( value , timestamp , register ) : [EOL] [docstring] [EOL] [EOL] key = f" [string] { register . uid }" [EOL] data = cast ( Record , register . metalog . find ( key ) ) . blob . to_dict ( ) [EOL] data [ [string] ] = value [EOL] [EOL] blob = Blob ( data ) [EOL] entry = Entry ( key , Scope . System , timestamp , blob . digest ( ) ) [EOL] [EOL] return [ rsf . add_item ( blob ) , rsf . append_entry ( entry ) ] [EOL] [EOL] [EOL] def context_patch ( key , value , timestamp ) : [EOL] [docstring] [EOL] [EOL] blob = Blob ( { key : value } ) [EOL] entry = Entry ( key , Scope . System , timestamp , blob . digest ( ) ) [EOL] [EOL] return [ rsf . add_item ( blob ) , rsf . append_entry ( entry ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rsf.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rsf.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Optional , Any [EOL] import csv [EOL] import registers [EOL] import io [EOL] import rsf [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import csv [EOL] from datetime import datetime [EOL] from typing import List [EOL] from io import StringIO [EOL] import click [EOL] from . . import rsf , Register , Entry , Scope , Blob , Patch , Attribute [EOL] from . . exceptions import RegistersException , UnknownAttribute [EOL] from . . core import format_timestamp [EOL] from . import utils [EOL] [EOL] [EOL] @ click . group ( name = [string] ) def schema_group ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ schema_group . command ( name = [string] ) @ click . argument ( [string] , type = click . Path ( exists = False ) ) @ click . option ( [string] , [string] , type = click . Choice ( [ [string] , [string] ] ) ) def show_command ( rsf_file , output_format ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] schema = register . schema ( ) [EOL] [EOL] if output_format == [string] : [EOL] stream = StringIO ( ) [EOL] utils . serialise_json ( schema , stream ) [EOL] stream . seek ( [number] ) [EOL] click . echo ( stream . read ( ) ) [EOL] [EOL] elif output_format == [string] : [EOL] stream = StringIO ( ) [EOL] headers = Attribute . headers ( ) [EOL] headers . append ( [string] ) [EOL] [EOL] writer = csv . DictWriter ( stream , fieldnames = headers ) [EOL] writer . writeheader ( ) [EOL] [EOL] attributes = schema . attributes [EOL] [EOL] for attr in attributes : [EOL] data = attr . to_dict ( ) [EOL] data [ [string] ] = str ( attr . uid == schema . primary_key ) . lower ( ) [EOL] writer . writerow ( data ) [EOL] [EOL] stream . seek ( [number] ) [EOL] [EOL] click . echo ( stream . read ( ) ) [EOL] [EOL] else : [EOL] for attr in schema . attributes : [EOL] is_primary_key = attr . uid == schema . primary_key [EOL] display_attr ( attr , is_primary_key ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] @ schema_group . command ( name = [string] ) @ click . argument ( [string] ) @ click . argument ( [string] ) @ click . option ( [string] , default = format_timestamp ( datetime . utcnow ( ) ) , help = ( [string] [string] ) ) @ click . option ( [string] , [string] , required = True , type = click . Path ( exists = True ) , help = [string] ) @ click . option ( [string] , [string] , is_flag = True , help = [string] ) def create_command ( attr_id , value , rsf_file , timestamp , apply_flag ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] cmds = patch_attr ( attr_id , value , timestamp , register ) [EOL] [EOL] if apply_flag : [EOL] patch = Patch ( register . schema ( ) , cmds ) [EOL] register . apply ( patch ) [EOL] [EOL] with open ( rsf_file , [string] ) as stream : [EOL] stream . writelines ( [ f"{ cmd } [string] " for cmd in patch . commands ] ) [EOL] [EOL] msg = f" [string] { len ( cmds ) } [string] { rsf_file }" [EOL] [EOL] utils . success ( msg ) [EOL] [EOL] else : [EOL] for obj in cmds : [EOL] click . echo ( obj ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] def display_attr ( attr , is_primary_key ) : [EOL] [docstring] [EOL] [EOL] if is_primary_key : [EOL] pk_label = [string] [EOL] else : [EOL] pk_label = [string] [EOL] [EOL] click . secho ( f"{ attr . uid }{ pk_label }" , fg = [string] ) [EOL] [EOL] for ( key , value ) in [ ( key , value ) for key , value in attr if key != [string] ] : [EOL] svalue = click . style ( value , fg = [string] ) [EOL] click . secho ( f" [string] { key } [string] { svalue }" , fg = [string] ) [EOL] [EOL] [EOL] def patch_attr ( uid , value , timestamp , register ) : [EOL] [docstring] [EOL] [EOL] attr = register . schema ( ) . get ( uid ) [EOL] [EOL] if attr is None : [EOL] raise UnknownAttribute ( uid , [string] ) [EOL] [EOL] data = attr . to_dict ( ) [EOL] data [ [string] ] = value [EOL] [EOL] blob = Blob ( data ) [EOL] entry = Entry ( f" [string] { uid }" , Scope . System , timestamp , blob . digest ( ) ) [EOL] [EOL] return [ rsf . add_item ( blob ) , rsf . append_entry ( entry ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rsf.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import registers [EOL] import typing [EOL] import rsf [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] from hashlib import sha256 [EOL] from datetime import datetime [EOL] from typing import List [EOL] import click [EOL] from . import utils [EOL] from . . import ( rsf , schema , merkle , Hash , Blob , Entry , Scope , Attribute , Datatype , Cardinality ) [EOL] from . . core import format_timestamp [EOL] from . . exceptions import RegistersException [EOL] [EOL] [EOL] @ click . command ( name = [string] ) @ click . argument ( [string] ) @ click . option ( [string] , [string] , required = True , type = click . Path ( exists = False ) , help = ( [string] [string] ) ) def init_command ( name , rsf_file ) : [EOL] [docstring] [EOL] [EOL] if os . path . exists ( rsf_file ) : [EOL] raise click . UsageError ( [string] ) [EOL] [EOL] try : [EOL] commands = init_patch ( name ) [EOL] [EOL] with click . open_file ( rsf_file , [string] , [string] ) as stream : [EOL] stream . write ( rsf . dump ( commands ) ) [EOL] [EOL] fname = click . style ( click . format_filename ( rsf_file ) , fg = [string] ) [EOL] click . echo ( f" [string] { fname }" ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] def init_patch ( name ) : [EOL] [docstring] [EOL] [EOL] timestamp = format_timestamp ( datetime . utcnow ( ) ) [EOL] [EOL] uid = Blob ( { [string] : name } ) [EOL] uid_entry = Entry ( [string] , Scope . System , timestamp , uid . digest ( ) ) [EOL] [EOL] commands = [ rsf . assert_root_hash ( Hash ( [string] , merkle . hash_empty ( sha256 ) . hex ( ) ) ) , rsf . add_item ( uid ) , rsf . append_entry ( uid_entry ) , ] [EOL] [EOL] attributes = gather_attributes ( name , timestamp ) [EOL] [EOL] commands . extend ( attributes ) [EOL] [EOL] return commands [EOL] [EOL] [EOL] def gather_attributes ( name , timestamp ) : [EOL] [docstring] [EOL] [EOL] cmds = [ ] [EOL] [EOL] primary_key = schema . string ( name ) . to_blob ( ) [EOL] primary_key_entry = Entry ( f" [string] { name }" , Scope . System , timestamp , primary_key . digest ( ) ) [EOL] [EOL] cmds . append ( rsf . add_item ( primary_key ) ) [EOL] cmds . append ( rsf . append_entry ( primary_key_entry ) ) [EOL] [EOL] click . echo ( f" [string] { name } [string] " ) [EOL] [EOL] while True : [EOL] if click . confirm ( [string] ) : [EOL] uid = click . prompt ( [string] , type = str ) [EOL] datatype = click . prompt ( [string] , type = click . Choice ( schema . DATATYPES ) ) [EOL] cardinality = click . prompt ( [string] , type = click . Choice ( [ [string] , [string] ] ) ) [EOL] description = click . prompt ( [string] , type = str ) [EOL] [EOL] attr = Attribute ( uid , Datatype ( datatype ) , Cardinality ( cardinality ) , description ) [EOL] blob = attr . to_blob ( ) [EOL] entry = Entry ( f" [string] { uid }" , Scope . System , timestamp , blob . digest ( ) ) [EOL] cmds . append ( rsf . add_item ( blob ) ) [EOL] cmds . append ( rsf . append_entry ( entry ) ) [EOL] else : [EOL] break [EOL] [EOL] return cmds [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rsf.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rsf.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import registers [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from datetime import datetime [EOL] import click [EOL] from . . import rsf , xsv , Register , Patch [EOL] from . . exceptions import RegistersException [EOL] from . . core import format_timestamp [EOL] from . import utils [EOL] [EOL] [EOL] @ click . group ( name = [string] ) def patch_group ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ patch_group . command ( name = [string] ) @ click . argument ( [string] ) @ click . option ( [string] , default = format_timestamp ( datetime . utcnow ( ) ) , help = [string] ) @ click . option ( [string] , [string] , required = True , type = click . Path ( exists = True ) , help = [string] ) @ click . option ( [string] , [string] , is_flag = True , help = [string] ) def create_command ( xsv_file , rsf_file , timestamp , apply_flag ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] patch = create ( xsv_file , rsf_file , timestamp , apply_flag = apply_flag ) [EOL] [EOL] if apply_flag : [EOL] number = len ( patch . commands ) [EOL] msg = f" [string] { number } [string] { rsf_file }" [EOL] [EOL] utils . success ( msg ) [EOL] [EOL] else : [EOL] for command in patch . commands : [EOL] click . echo ( command ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] @ patch_group . command ( name = [string] ) @ click . argument ( [string] ) @ click . option ( [string] , [string] , required = True , type = click . Path ( exists = True ) , help = [string] ) def apply_command ( patch_file , rsf_file ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] patch = apply ( patch_file , rsf_file ) [EOL] number = len ( patch . commands ) [EOL] msg = f" [string] { number } [string] { rsf_file }" [EOL] [EOL] utils . success ( msg ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] def create ( xsv_file , rsf_file , timestamp , apply_flag = False ) : [EOL] [docstring] [EOL] [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] schema = register . schema ( ) [EOL] [EOL] with open ( xsv_file , [string] , newline = [string] ) as handle : [EOL] blobs = xsv . deserialise ( handle , schema ) [EOL] patch = Patch ( schema , blobs , timestamp ) [EOL] start_root_hash = register . log . digest ( ) [EOL] [EOL] errors = register . apply ( patch ) [EOL] [EOL] if errors : [EOL] utils . error ( errors ) [EOL] [EOL] end_root_hash = register . log . digest ( ) [EOL] patch . seal ( start_root_hash , end_root_hash ) [EOL] [EOL] if apply_flag : [EOL] return _apply ( patch , rsf_file ) [EOL] [EOL] return patch [EOL] [EOL] [EOL] def apply ( patch_file , rsf_file ) : [EOL] [docstring] [EOL] [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] schema = register . schema ( ) [EOL] [EOL] patch_cmds = rsf . read ( patch_file ) [EOL] patch = Patch ( schema , patch_cmds ) [EOL] errors = register . apply ( patch ) [EOL] [EOL] if errors : [EOL] utils . error ( errors ) [EOL] [EOL] return _apply ( patch , rsf_file ) [EOL] [EOL] [EOL] def _apply ( patch , rsf_file ) : [EOL] [docstring] [EOL] [EOL] if patch . is_sealed ( ) : [EOL] cmds = patch . commands [ [number] : ] [EOL] else : [EOL] cmds = patch . commands [EOL] [EOL] with open ( rsf_file , [string] ) as handle : [EOL] handle . writelines ( [ f"{ cmd } [string] " for cmd in cmds ] ) [EOL] [EOL] return patch [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Patch$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Patch$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Patch$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] import click [EOL] from . . import validator , schema , Datatype [EOL] from . . exceptions import RegistersException [EOL] from . import utils [EOL] [EOL] [EOL] @ click . group ( name = [string] ) def value_group ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ value_group . command ( name = [string] ) @ click . argument ( [string] ) @ click . option ( [string] , [string] , required = True , type = click . Choice ( schema . DATATYPES ) , help = [string] ) def validate_command ( token , datatype ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] validator . validate_value_datatype ( token , Datatype ( datatype ) ) [EOL] [EOL] msg = f" [string] { token } [string] { datatype } [string] " [EOL] [EOL] utils . success ( msg ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import click [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import json [EOL] from typing import List [EOL] from pathlib import Path [EOL] import click [EOL] from . . import xsv , Register , Blob , Entry , Record , Hash , Schema , Attribute [EOL] from . . exceptions import CommandError [EOL] [EOL] [EOL] def error ( message ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( message , List ) : [EOL] for element in message : [EOL] click . secho ( str ( element ) , fg = [string] , bold = True , err = True ) [EOL] else : [EOL] click . secho ( message , fg = [string] , bold = True , err = True ) [EOL] [EOL] exit ( [number] ) [EOL] [EOL] [EOL] def note ( message ) : [EOL] [docstring] [EOL] [EOL] click . secho ( message , fg = [string] , bold = True ) [EOL] [EOL] [EOL] def success ( message ) : [EOL] [docstring] [EOL] [EOL] click . secho ( message , fg = [string] , bold = True ) [EOL] [EOL] [EOL] def check_readiness ( register ) : [EOL] [docstring] [EOL] [EOL] if not register . is_ready ( ) : [EOL] msg = [string] [EOL] raise CommandError ( msg ) [EOL] [EOL] [EOL] def serialise_json ( obj , stream , compact = False ) : [EOL] [docstring] [EOL] [EOL] if compact : [EOL] json . dump ( obj , stream , ensure_ascii = False , separators = ( [string] , [string] ) , cls = JsonEncoder ) [EOL] [EOL] else : [EOL] json . dump ( obj , stream , ensure_ascii = False , indent = [number] , cls = JsonEncoder ) [EOL] [EOL] [EOL] class JsonEncoder ( json . JSONEncoder ) : [EOL] [docstring] [EOL] [EOL] def default ( self , obj ) : [comment] [EOL] if isinstance ( obj , Hash ) : [EOL] return repr ( obj ) [EOL] [EOL] if isinstance ( obj , Record ) : [EOL] return { obj . entry . key : obj . to_dict ( ) } [EOL] [EOL] if isinstance ( obj , ( Blob , Entry , Record , Schema , Attribute ) ) : [EOL] return obj . to_dict ( ) [EOL] [EOL] return json . JSONEncoder . default ( self , obj ) [EOL] [EOL] [EOL] def progressbar ( iterable , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] tpl = click . style ( [string] , fg = [string] ) [EOL] bar = click . progressbar ( iterable , show_eta = False , show_percent = True , bar_template = tpl , ** kwargs ) [EOL] [EOL] bar . short_limit = [number] [EOL] [EOL] return bar [EOL] [EOL] [EOL] def write_csv_resource ( path , obj , headers ) : [EOL] [docstring] [EOL] [EOL] with open ( f"{ path } [string] " , [string] ) as stream : [EOL] xsv . serialise ( stream , obj , headers ) [EOL] [EOL] [EOL] def write_json_resource ( path , obj ) : [EOL] [docstring] [EOL] [EOL] with open ( f"{ path } [string] " , [string] ) as stream : [EOL] serialise_json ( obj , stream ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , List , Optional [EOL] import io [EOL] import registers [EOL] import typing [EOL] [docstring] [EOL] [EOL] from io import StringIO [EOL] import click [EOL] from . . import rsf , xsv , Register , Record [EOL] from . . exceptions import RegistersException [EOL] from . import utils [EOL] [EOL] [EOL] @ click . group ( name = [string] ) def record_group ( ) : [EOL] [docstring] [comment] [EOL] [EOL] [EOL] @ record_group . command ( name = [string] ) @ click . option ( [string] , [string] , type = click . Choice ( [ [string] , [string] ] ) ) @ click . argument ( [string] , type = click . Path ( exists = False ) ) def list_command ( rsf_file , output_format ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] records = register . records ( ) [EOL] [EOL] if not records : [EOL] return [EOL] [EOL] if output_format == [string] : [EOL] stream = StringIO ( ) [EOL] utils . serialise_json ( records , stream ) [EOL] [EOL] stream . seek ( [number] ) [EOL] [EOL] click . echo ( stream . read ( ) ) [EOL] [EOL] elif output_format == [string] : [EOL] stream = StringIO ( ) [EOL] headers = Record . headers ( register . schema ( ) ) [EOL] [EOL] xsv . serialise ( stream , records , headers ) [EOL] [EOL] stream . seek ( [number] ) [EOL] [EOL] click . echo ( stream . read ( ) ) [EOL] [EOL] else : [EOL] for record in records . values ( ) : [EOL] click . echo ( record . blob ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] @ record_group . command ( name = [string] ) @ click . option ( [string] , [string] , type = click . Choice ( [ [string] , [string] ] ) ) @ click . option ( [string] , [string] , required = True , type = click . Path ( exists = False ) ) @ click . argument ( [string] , type = click . Path ( exists = False ) ) def show_command ( key , rsf_file , output_format ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] records = register . records ( ) [EOL] [EOL] if not records : [EOL] return [EOL] [EOL] record = records . get ( key ) [EOL] [EOL] if not record : [EOL] return [EOL] [EOL] if output_format == [string] : [EOL] stream = StringIO ( ) [EOL] utils . serialise_json ( record , stream ) [EOL] [EOL] stream . seek ( [number] ) [EOL] [EOL] click . echo ( stream . read ( ) ) [EOL] [EOL] elif output_format == [string] : [EOL] stream = StringIO ( ) [EOL] headers = Record . headers ( register . schema ( ) ) [EOL] [EOL] xsv . serialise ( stream , record , headers ) [EOL] [EOL] stream . seek ( [number] ) [EOL] [EOL] click . echo ( stream . read ( ) ) [EOL] [EOL] else : [EOL] for ( attr , value ) in record . blob : [EOL] click . secho ( f"{ attr } [string] " , fg = [string] ) [EOL] click . echo ( f" [string] { value }" ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Union , IO , List , Dict [EOL] import registers [EOL] import pathlib [EOL] import jinja2 [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import json [EOL] import shutil [EOL] from zipfile import ZipFile [EOL] from pathlib import Path [EOL] from typing import List , Union , Dict , cast , IO [EOL] import pkg_resources [EOL] import yaml [EOL] import click [EOL] from jinja2 import Environment , PackageLoader [EOL] from . . import rsf , Register , Entry , Record , Cardinality [EOL] from . . exceptions import RegistersException [EOL] from . import utils [EOL] from . utils import error [EOL] [EOL] [EOL] @ click . command ( name = [string] ) @ click . argument ( [string] , type = click . Path ( exists = True ) , nargs = - [number] , required = True ) @ click . option ( [string] , type = click . Choice ( [ [string] , [string] , [string] ] ) , help = [string] ) def build_command ( rsf_files , target ) : [EOL] for rsf_file in rsf_files : [EOL] build_register ( rsf_file , target ) [EOL] [EOL] [EOL] def build_register ( rsf_file , target ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] cmds = rsf . read ( rsf_file ) [EOL] [EOL] with utils . progressbar ( range ( [number] , len ( cmds ) ) , label = [string] ) as bar : [EOL] register = Register ( cmds , lambda : bar . update ( [number] ) ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] build_path = Path ( f" [string] { register . uid }" ) [EOL] [EOL] if build_path . exists ( ) : [EOL] shutil . rmtree ( build_path ) [EOL] [EOL] build_path . mkdir ( parents = True ) [EOL] [EOL] if target == [string] : [EOL] build_target_resource ( [string] , [string] , build_path ) [EOL] [EOL] if target == [string] : [EOL] build_docker ( build_path ) [EOL] [EOL] if target == [string] : [EOL] build_cloudfoundry ( build_path , register ) [EOL] [EOL] if target in [ [string] , [string] ] : [EOL] build_path = build_path . joinpath ( [string] ) [EOL] build_path . mkdir ( ) [EOL] [EOL] build_blobs ( build_path . joinpath ( [string] ) , register ) [EOL] build_entries ( build_path . joinpath ( [string] ) , register ) [EOL] build_records ( build_path . joinpath ( [string] ) , register ) [EOL] build_commands ( build_path , register ) [EOL] build_context ( build_path . joinpath ( [string] ) , register ) [EOL] build_archive ( build_path , register ) [EOL] build_openapi ( build_path , register ) [EOL] [EOL] click . secho ( [string] . format ( register . uid , target ) , fg = [string] , bold = True ) [EOL] [EOL] except RegistersException as err : [EOL] error ( str ( err ) ) [EOL] [EOL] [EOL] def build_blobs ( path , register ) : [EOL] [docstring] [EOL] [EOL] if path . exists ( ) : [EOL] path . rmdir ( ) [EOL] path . mkdir ( ) [EOL] [EOL] sch = register . schema ( ) [EOL] headers = [ attr . uid for attr in sch . attributes ] [EOL] collection = register . log . blobs [EOL] [EOL] write_resource ( path . joinpath ( [string] ) , { repr ( k ) : v for k , v in collection . items ( ) } , headers ) [EOL] [EOL] with utils . progressbar ( collection . items ( ) , label = [string] ) as bar : [EOL] [EOL] for key , blob in bar : [EOL] write_resource ( path . joinpath ( repr ( key ) ) , blob , headers ) [EOL] [EOL] [EOL] def build_entries ( path , register ) : [EOL] [docstring] [EOL] [EOL] if path . exists ( ) : [EOL] path . rmdir ( ) [EOL] [EOL] path . mkdir ( ) [EOL] [EOL] headers = Entry . headers ( ) [EOL] collection = register . log . entries [EOL] [EOL] write_resource ( path . joinpath ( [string] ) , collection , headers ) [EOL] [EOL] with utils . progressbar ( collection , label = [string] ) as bar : [EOL] for entry in bar : [EOL] write_resource ( path . joinpath ( repr ( entry . position ) ) , [ entry ] , headers ) [EOL] [EOL] [EOL] def build_records ( path , register ) : [EOL] [docstring] [EOL] [EOL] if path . exists ( ) : [EOL] path . rmdir ( ) [EOL] [EOL] path . mkdir ( ) [EOL] [EOL] sch = register . schema ( ) [EOL] headers = Record . headers ( sch ) [EOL] collection = register . records ( ) [EOL] [EOL] write_resource ( path . joinpath ( [string] ) , collection , headers ) [EOL] [EOL] with utils . progressbar ( collection . items ( ) , label = [string] ) as bar : [EOL] for key , record in bar : [EOL] write_resource ( path . joinpath ( key ) , record , headers ) [EOL] [EOL] build_record_trail ( path . joinpath ( key ) , register . trail ( key ) ) [EOL] [EOL] [EOL] def build_record_trail ( path , trail ) : [EOL] [docstring] [EOL] [EOL] if path . exists ( ) : [EOL] path . rmdir ( ) [EOL] [EOL] path . mkdir ( ) [EOL] path = path . joinpath ( [string] ) [EOL] [EOL] write_resource ( path , trail , headers = Entry . headers ( ) ) [EOL] [EOL] [EOL] def build_commands ( path , register ) : [EOL] [docstring] [EOL] with open ( f"{ path } [string] " , [string] ) as stream : [EOL] stream . write ( rsf . dump ( register . commands ) ) [EOL] [EOL] [EOL] def build_context ( path , register ) : [EOL] [docstring] [EOL] [EOL] context = register . context ( ) [EOL] [EOL] utils . write_json_resource ( path , context ) [EOL] [EOL] [EOL] def build_archive ( path , register ) : [EOL] [docstring] [EOL] [EOL] with ZipFile ( f"{ path } [string] " , [string] ) as archive : [EOL] archive . write ( f"{ path } [string] " , f"{ register . uid } [string] " ) [EOL] archive . write ( f"{ path } [string] " , f"{ register . uid } [string] " ) [EOL] archive . write ( f"{ path } [string] " , f"{ register . uid } [string] " ) [EOL] archive . write ( f"{ path } [string] " , f"{ register . uid } [string] " ) [EOL] [EOL] [EOL] def build_openapi ( path , register ) : [EOL] [docstring] [EOL] [EOL] openapi = json . loads ( pkg_resources . resource_string ( [string] , [string] ) ) [comment] [EOL] [EOL] openapi [ [string] ] [ [string] ] = register . title ( ) or register . uid [EOL] [EOL] if register . description ( ) : [EOL] openapi [ [string] ] [ [string] ] = register . description ( ) [EOL] [EOL] item_props = { } [EOL] [EOL] for attribute in register . schema ( ) . attributes : [EOL] item_props [ attribute . uid ] = _attr_schema ( attribute ) [EOL] [EOL] openapi [ [string] ] [ [string] ] [ [string] ] [ [string] ] = item_props [EOL] [EOL] with open ( path . joinpath ( [string] ) , [string] ) as handle : [EOL] handle . write ( json . dumps ( openapi ) ) [EOL] [EOL] [EOL] def build_cloudfoundry ( path , register ) : [EOL] [docstring] [EOL] [EOL] build_target_resource ( [string] , [string] , path ) [EOL] build_target_resource ( [string] , [string] , path ) [EOL] build_target_resource ( [string] , [string] , path ) [EOL] build_lua_resources ( path ) [EOL] [EOL] with open ( path . joinpath ( [string] ) , [string] ) as handle : [EOL] env = Environment ( loader = PackageLoader ( [string] , [string] ) , autoescape = True ) [EOL] template = env . get_template ( [string] ) [EOL] handle . write ( template . render ( port = [string] ) ) [EOL] [EOL] with open ( path . joinpath ( [string] ) , [string] ) as handle : [EOL] filename = [string] [EOL] stream = cast ( IO [ str ] , pkg_resources . resource_stream ( [string] , filename ) ) [EOL] manifest = yaml . safe_load ( stream ) [EOL] manifest [ [string] ] [ [number] ] [ [string] ] = register . uid [EOL] [EOL] handle . write ( yaml . dump ( manifest ) ) [EOL] [EOL] [EOL] def build_docker ( path ) : [EOL] [docstring] [EOL] [EOL] build_target_resource ( [string] , [string] , path ) [EOL] build_target_resource ( [string] , [string] , path ) [EOL] build_target_resource ( [string] , [string] , path ) [EOL] build_lua_resources ( path ) [EOL] [EOL] with open ( path . joinpath ( [string] ) , [string] ) as handle : [EOL] env = Environment ( loader = PackageLoader ( [string] , [string] ) , autoescape = True ) [EOL] template = env . get_template ( [string] ) [EOL] handle . write ( template . render ( port = [number] ) ) [EOL] [EOL] [EOL] def build_lua_resources ( path ) : [EOL] [docstring] [EOL] [EOL] path . joinpath ( [string] ) . mkdir ( ) [EOL] [EOL] build_target_resource ( [string] , [string] , path ) [EOL] build_target_resource ( [string] , [string] , path ) [EOL] build_target_resource ( [string] , [string] , path ) [EOL] [EOL] [EOL] def build_target_resource ( name , target , path ) : [EOL] [docstring] [EOL] [EOL] with open ( path . joinpath ( name ) , [string] ) as handle : [EOL] resource = pkg_resources . resource_string ( [string] , f" [string] { target } [string] { name }" ) [EOL] handle . write ( resource ) [EOL] [EOL] [EOL] def _attr_schema ( attribute ) : [EOL] if attribute . cardinality == Cardinality . One : [EOL] return { [string] : [string] } [EOL] [EOL] return { [string] : [string] , [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def write_resource ( path , obj , headers ) : [EOL] [docstring] [EOL] [EOL] utils . write_csv_resource ( path , obj , headers ) [EOL] utils . write_json_resource ( path , obj ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import io [EOL] import registers [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] from io import StringIO [EOL] import click [EOL] from . . import rsf , xsv , Register , Blob , validator [EOL] from . . exceptions import RegistersException [EOL] from . import utils [EOL] [EOL] [EOL] @ click . group ( name = [string] ) def blob_group ( ) : [EOL] [docstring] [comment] [EOL] [EOL] [EOL] @ blob_group . command ( name = [string] ) @ click . argument ( [string] , type = click . Path ( exists = True ) ) @ click . option ( [string] , [string] , type = click . Choice ( [ [string] , [string] ] ) ) def list_command ( rsf_file , output_format ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] if output_format : [EOL] stream = StringIO ( ) [EOL] list_blobs ( rsf_file , output_format , stream ) [EOL] [EOL] click . echo ( stream . read ( ) ) [EOL] [EOL] else : [EOL] result = list_blobs ( rsf_file ) [EOL] [EOL] for blob in result : [EOL] click . echo ( repr ( blob ) ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] @ blob_group . command ( name = [string] ) @ click . argument ( [string] ) @ click . option ( [string] , [string] , required = True , type = click . Path ( exists = True ) , help = [string] ) def validate_blob ( blob , rsf_file ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] [EOL] schema = register . schema ( ) [EOL] [EOL] data = json . loads ( blob ) [EOL] validator . validate ( data , schema ) [EOL] [EOL] blob = Blob ( data ) [EOL] [EOL] msg = f" [string] { blob } [string] { register . uid } [string] " [EOL] [EOL] utils . success ( msg ) [EOL] [EOL] except json . decoder . JSONDecodeError : [EOL] utils . error ( [string] ) [EOL] [EOL] except RegistersException as err : [EOL] utils . error ( str ( err ) ) [EOL] [EOL] [EOL] def list_blobs ( rsf_file , output_format = None , stream = None ) : [EOL] [docstring] [EOL] [EOL] cmds = rsf . read ( rsf_file ) [EOL] register = Register ( cmds ) [EOL] [EOL] utils . check_readiness ( register ) [EOL] blobs = register . log . blobs [EOL] [EOL] if output_format == [string] : [EOL] schema = register . schema ( ) [EOL] headers = [ attr . uid for attr in schema . attributes ] [EOL] xsv . serialise ( stream , blobs , headers ) [EOL] [EOL] stream . seek ( [number] ) [EOL] [EOL] return None [EOL] [EOL] if output_format == [string] : [EOL] utils . serialise_json ( { repr ( k ) : v for k , v in blobs . items ( ) } , stream ) [EOL] [EOL] stream . seek ( [number] ) [EOL] [EOL] return None [EOL] [EOL] return blobs . values ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import registers [EOL] import typing [EOL] from registers . entry import Entry , Scope [EOL] from registers . hash import Hash [EOL] [EOL] [EOL] def test_json_repr ( ) : [EOL] entry = Entry ( [string] , Scope . User , [string] , Hash ( [string] , [string] ) , [number] ) [EOL] expected = [string] [comment] [EOL] actual = entry . to_json ( ) [EOL] [EOL] assert actual == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import registers [EOL] import typing [EOL] import pytest [EOL] from registers import rsf , xsv , schema , Schema , Blob , Register [EOL] from registers . exceptions import InvalidKey [EOL] from io import StringIO [EOL] [EOL] [EOL] @ pytest . fixture def isa_register ( ) : [EOL] filename = [string] [EOL] with open ( filename , [string] ) as handle : [EOL] commands = rsf . parse ( handle . readlines ( ) ) [EOL] register = Register ( commands ) [EOL] [EOL] return register [EOL] [EOL] [EOL] @ pytest . fixture def isa_tsv_patch ( isa_register ) : [EOL] filename = [string] [EOL] with open ( filename , [string] , newline = [string] ) as handle : [EOL] return xsv . deserialise ( handle , isa_register . schema ( ) ) [EOL] [EOL] [EOL] def test_serialise_value ( ) : [EOL] assert xsv . serialise_value ( [string] ) == [string] [EOL] assert xsv . serialise_value ( [ [string] ] ) == [string] [EOL] assert xsv . serialise_value ( [ [string] , [string] ] ) == [string] [EOL] [EOL] [EOL] def test_deserialise_tsv ( ) : [EOL] tsv = [string] [EOL] sch = Schema ( [string] , [ schema . string ( [string] ) , schema . integer ( [string] ) , schema . integer ( [string] ) ] ) [EOL] expected = [ Blob ( { [string] : [string] , [string] : [string] , [string] : [string] } ) , Blob ( { [string] : [string] , [string] : [string] , [string] : [string] } ) , Blob ( { [string] : [string] , [string] : [string] , [string] : [string] } ) , ] [EOL] [EOL] actual = xsv . deserialise ( StringIO ( tsv ) , sch ) [EOL] [EOL] assert actual == expected [EOL] [EOL] [EOL] def test_deserialise_isa_tsv_patch ( isa_tsv_patch ) : [EOL] size = len ( isa_tsv_patch ) [EOL] assert size == [number] [EOL] [EOL] [EOL] def test_deserialise_isa_tsv_patch_item ( isa_tsv_patch ) : [EOL] item = isa_tsv_patch [ [number] ] [EOL] [EOL] assert isinstance ( item , Blob ) [EOL] [EOL] [EOL] def test_coerce_wrong_key ( ) : [EOL] sch = Schema ( [string] , [ schema . string ( [string] ) , schema . integer ( [string] ) , schema . integer ( [string] ) ] ) [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] with pytest . raises ( InvalidKey ) : [EOL] xsv . coerce ( data , sch ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import registers [EOL] import typing [EOL] import pytest [EOL] from registers . log import collect [EOL] from registers . rsf import parse [EOL] [EOL] [EOL] @ pytest . fixture def country_rsf ( ) : [EOL] with open ( [string] , [string] ) as handle : [EOL] return handle . readlines ( ) [EOL] [EOL] [EOL] def test_collect ( ) : [EOL] commands = parse ( [string] . splitlines ( ) ) [comment] [EOL] actual = collect ( commands ) [EOL] [EOL] assert actual [ [string] ] . stats ( ) == { [string] : [number] , [string] : [number] } [EOL] assert actual [ [string] ] . stats ( ) == { [string] : [number] , [string] : [number] } [EOL] [EOL] [EOL] def test_collect_country ( country_rsf ) : [EOL] actual = collect ( parse ( country_rsf ) , relaxed = True ) [EOL] [EOL] assert actual [ [string] ] . stats ( ) == { [string] : [number] , [string] : [number] } [EOL] assert actual [ [string] ] . stats ( ) == { [string] : [number] , [string] : [number] } [comment] [EOL] [EOL] [EOL] def test_collect_duplicate ( ) : [EOL] commands = [string] . strip ( ) . splitlines ( ) [comment] [EOL] result = collect ( parse ( commands ) ) [EOL] actual = result [ [string] ] [EOL] [EOL] assert len ( actual ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Union , List , Dict [EOL] import registers [EOL] import typing [EOL] import pytest [EOL] from registers . validator import ( validate , validate_value_datatype , validate_key ) [EOL] from registers . schema import Schema , Cardinality , Datatype , Attribute [EOL] from registers . exceptions import ( MissingPrimaryKey , CardinalityMismatch , RepresentationError , UnknownAttribute , InvalidCurieValue , InvalidDatetimeValue , InvalidNameValue , InvalidHashValue , InvalidIntegerValue , InvalidPeriodValue , InvalidTimestampValue , InvalidUrlValue ) [EOL] [EOL] [EOL] def test_valid_string ( ) : [EOL] data = { [string] : [string] , [string] : [string] } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . String , Cardinality . One ) ] ) [EOL] [EOL] assert validate ( data , schema ) [EOL] [EOL] [EOL] def test_valid_n_string ( ) : [EOL] data = { [string] : [string] , [string] : [ [string] ] } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . String , Cardinality . Many ) ] ) [EOL] [EOL] assert validate ( data , schema ) [EOL] [EOL] [EOL] def test_missing_pk ( ) : [EOL] data = { [string] : [string] } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . String , Cardinality . One ) ] ) [EOL] [EOL] with pytest . raises ( MissingPrimaryKey ) : [EOL] validate ( data , schema ) [EOL] [EOL] [EOL] def test_unexpected_attribute ( ) : [EOL] data = { [string] : [string] , [string] : [string] } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) ] ) [EOL] [EOL] with pytest . raises ( UnknownAttribute ) : [EOL] validate ( data , schema ) [EOL] [EOL] [EOL] def test_cardinality_n_mismatch ( ) : [EOL] data = { [string] : [string] , [string] : [string] } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . String , Cardinality . Many ) ] ) [EOL] [EOL] with pytest . raises ( CardinalityMismatch ) : [EOL] validate ( data , schema ) [EOL] [EOL] [EOL] def test_cardinality_1_mismatch ( ) : [EOL] data = { [string] : [string] , [string] : [ [string] ] } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . String , Cardinality . One ) ] ) [EOL] [EOL] with pytest . raises ( CardinalityMismatch ) : [EOL] validate ( data , schema ) [EOL] [EOL] [EOL] def test_representation_error_number ( ) : [EOL] data = { [string] : [string] , [string] : [number] } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . Integer , Cardinality . One ) ] ) [EOL] [EOL] with pytest . raises ( RepresentationError ) : [EOL] validate ( data , schema ) [EOL] [EOL] [EOL] def test_representation_error_bool ( ) : [EOL] data = { [string] : [string] , [string] : True } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . Integer , Cardinality . One ) ] ) [EOL] [EOL] with pytest . raises ( RepresentationError ) : [EOL] validate ( data , schema ) [EOL] [EOL] [EOL] def test_representation_error_dict ( ) : [EOL] data = { [string] : [string] , [string] : { } } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . Integer , Cardinality . One ) ] ) [EOL] [EOL] with pytest . raises ( RepresentationError ) : [EOL] validate ( data , schema ) [EOL] [EOL] [EOL] def test_representation_error_n_number ( ) : [EOL] data = { [string] : [string] , [string] : [ [number] ] } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . Integer , Cardinality . Many ) ] ) [EOL] [EOL] with pytest . raises ( RepresentationError ) : [EOL] validate ( data , schema ) [EOL] [EOL] [EOL] def test_nully ( ) : [EOL] data = { [string] : [string] , [string] : None } [EOL] [EOL] schema = Schema ( [string] , [ Attribute ( [string] , Datatype . String , Cardinality . One ) , Attribute ( [string] , Datatype . Integer , Cardinality . One ) ] ) [EOL] [EOL] assert validate ( data , schema ) [EOL] [EOL] [EOL] def test_curie_value ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . Curie ) [EOL] assert validate_value_datatype ( [string] , Datatype . Curie ) [EOL] assert validate_value_datatype ( [string] , Datatype . Curie ) [EOL] assert validate_value_datatype ( [string] , Datatype . Curie ) [EOL] assert validate_value_datatype ( [string] , Datatype . Curie ) [EOL] assert validate_value_datatype ( [string] , Datatype . Curie ) [EOL] [EOL] [EOL] def test_invalid_curie_value ( ) : [EOL] with pytest . raises ( InvalidCurieValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Curie ) [EOL] [EOL] with pytest . raises ( InvalidCurieValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Curie ) [EOL] [EOL] [EOL] def test_integer_value ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . Integer ) [EOL] assert validate_value_datatype ( [string] , Datatype . Integer ) [EOL] assert validate_value_datatype ( [string] , Datatype . Integer ) [EOL] assert validate_value_datatype ( [string] , Datatype . Integer ) [EOL] [EOL] [EOL] def test_invalid_integer_value ( ) : [EOL] with pytest . raises ( InvalidIntegerValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Integer ) [EOL] [EOL] [EOL] def test_string_value ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . String ) [EOL] [EOL] [EOL] def test_datetime_value ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . Datetime ) [EOL] assert validate_value_datatype ( [string] , Datatype . Datetime ) [EOL] assert validate_value_datatype ( [string] , Datatype . Datetime ) [EOL] assert validate_value_datatype ( [string] , Datatype . Datetime ) [EOL] assert validate_value_datatype ( [string] , Datatype . Datetime ) [EOL] assert validate_value_datatype ( [string] , Datatype . Datetime ) [EOL] [EOL] [EOL] def test_invalid_datetime_value ( ) : [EOL] with pytest . raises ( InvalidDatetimeValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Datetime ) [EOL] [EOL] with pytest . raises ( InvalidDatetimeValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Datetime ) [EOL] [EOL] [EOL] def test_timestamp_value ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . Datetime ) [EOL] [EOL] [EOL] def test_invalid_timestamp_value ( ) : [EOL] with pytest . raises ( InvalidTimestampValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Timestamp ) [EOL] [EOL] with pytest . raises ( InvalidTimestampValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Timestamp ) [EOL] [EOL] [EOL] def test_period_value ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] [EOL] [EOL] def test_period_datetime_duration ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] assert validate_value_datatype ( [string] , Datatype . Period ) [EOL] [EOL] [EOL] def test_invalid_period_value ( ) : [EOL] with pytest . raises ( InvalidPeriodValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Period ) [EOL] [EOL] with pytest . raises ( InvalidPeriodValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Period ) [EOL] [EOL] with pytest . raises ( InvalidPeriodValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Period ) [EOL] [EOL] with pytest . raises ( InvalidPeriodValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Period ) [EOL] [EOL] with pytest . raises ( InvalidPeriodValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Period ) [EOL] [EOL] with pytest . raises ( InvalidPeriodValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Period ) [EOL] [EOL] with pytest . raises ( InvalidPeriodValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Period ) [EOL] [EOL] [EOL] def test_url_value ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . Url ) [EOL] [EOL] [EOL] def test_invalid_url_value ( ) : [EOL] with pytest . raises ( InvalidUrlValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Url ) [EOL] [EOL] with pytest . raises ( InvalidUrlValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Url ) [EOL] [EOL] [EOL] def test_hash_value ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . Hash ) [comment] [EOL] [EOL] [EOL] def test_invalid_hash_value ( ) : [EOL] with pytest . raises ( InvalidHashValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Hash ) [EOL] [EOL] with pytest . raises ( InvalidHashValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Hash ) [EOL] [EOL] [EOL] def test_name_value ( ) : [EOL] assert validate_value_datatype ( [string] , Datatype . Name ) [EOL] [EOL] [EOL] def test_invalid_name_value ( ) : [EOL] with pytest . raises ( InvalidNameValue ) : [EOL] validate_value_datatype ( [string] , Datatype . Name ) [EOL] [EOL] [EOL] def test_key_value ( ) : [EOL] assert validate_key ( [string] ) [EOL] assert validate_key ( [string] ) [EOL] assert validate_key ( [string] ) [EOL] assert validate_key ( [string] ) [EOL] assert validate_key ( [string] ) [EOL] assert validate_key ( [string] ) [EOL] assert validate_key ( [string] ) [EOL] assert validate_key ( [string] ) [EOL] [EOL] [EOL] def test_invalid_key_value ( ) : [EOL] assert not validate_key ( [string] ) [EOL] assert not validate_key ( [string] ) [EOL] assert not validate_key ( [string] ) [EOL] assert not validate_key ( [string] ) [EOL] assert not validate_key ( [string] ) [EOL] assert not validate_key ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import registers [EOL] import typing [EOL] from math import ceil [EOL] from hashlib import sha256 [EOL] import pytest [EOL] from registers import rsf , merkle , Register , Entry , Scope [EOL] [EOL] [EOL] def expected_height ( n ) : [EOL] if n in [ [number] , [number] ] : [EOL] return [number] [EOL] [EOL] return ceil ( ( n / [number] ) + [number] ) [EOL] [EOL] [EOL] def test_empty ( ) : [EOL] tree = merkle . Tree ( [ ] ) [EOL] [EOL] assert tree . root_hash == merkle . hash_empty ( sha256 ) [EOL] [EOL] [EOL] def test_even_tree ( ) : [EOL] tree = merkle . Tree ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] assert tree . root_hash . hex ( ) == ( [string] [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ ] , [number] ) , ( [ [string] ] , [number] ) , ( [ [string] , [string] ] , [number] ) , ( [ [string] , [string] , [string] ] , [number] ) , ( [ [string] , [string] , [string] , [string] ] , [number] ) , ( [ [string] , [string] , [string] , [string] , [string] ] , [number] ) ] ) def test_tree_height ( test_input , expected ) : [EOL] tree = merkle . Tree ( test_input ) [EOL] [EOL] assert tree . height == expected_height ( len ( test_input ) ) [EOL] assert tree . height == expected [EOL] [EOL] [EOL] LEAVES = [ bytes ( [ ] ) , bytes ( [ [number] ] ) , bytes ( [ [number] ] ) , bytes ( [ [number] , [number] ] ) , bytes ( [ [number] , [number] ] ) , bytes ( [ [number] , [number] , [number] , [number] ] ) , bytes ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) , bytes ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( LEAVES [ [number] : [number] ] , [number] , [string] ) , ( LEAVES [ [number] : [number] ] , [number] , [string] ) , ( LEAVES [ [number] : [number] ] , [number] , [string] ) , ( LEAVES [ [number] : [number] ] , [number] , [string] ) , ( LEAVES [ [number] : [number] ] , [number] , [string] ) , ( LEAVES [ [number] : [number] ] , [number] , [string] ) , ( LEAVES [ [number] : [number] ] , [number] , [string] ) , ( LEAVES , [number] , [string] ) ] ) def test_root_hash ( test_input , height , expected ) : [EOL] tree = merkle . Tree ( test_input ) [EOL] [EOL] assert tree . root_hash . hex ( ) == expected [EOL] assert tree . height == height [EOL] [EOL] [EOL] def test_entry_root_hash ( ) : [EOL] entry = Entry ( [string] , Scope . User , [string] , [string] , [number] ) [EOL] [EOL] tree = merkle . Tree ( [ entry . bytes ( ) ] ) [EOL] expected = tree . root_hash . hex ( ) [EOL] [EOL] assert expected == [string] [comment] [EOL] [EOL] [EOL] @ pytest . fixture def country_register ( ) : [EOL] commands = rsf . read ( [string] ) [EOL] register = Register ( commands ) [EOL] [EOL] return register [EOL] [EOL] [EOL] def test_register_consistency ( country_register ) : [EOL] leaves = [ entry . bytes ( ) for entry in country_register . log . entries ] [EOL] [EOL] tree = merkle . Tree ( leaves ) [EOL] actual = tree . root_hash . hex ( ) [EOL] expected = ( [string] [string] ) [EOL] [EOL] assert actual == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ [number] , [number] , [ ] ] , [ [number] , [number] , [ ] ] , [ [number] , [number] , [ [string] ] ] , [ [number] , [number] , [ [string] , [string] , [string] ] ] , [ [number] , [number] , [ [string] , [string] , [string] ] ] , [ [number] , [number] , [ [string] ] ] , [ [number] , [number] , [ [string] , [string] , [string] ] ] ] ) def test_audit_path ( idx , size , expected ) : [EOL] tree = merkle . Tree ( LEAVES [ : size ] ) [EOL] actual = [ digest . hex ( ) for digest in merkle . path ( tree , idx ) ] [EOL] [EOL] assert actual == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import registers [EOL] import typing [EOL] from registers import rsf [EOL] [EOL] [EOL] def test_serde ( ) : [EOL] with open ( [string] , [string] ) as file : [EOL] expected = file . read ( ) [EOL] commands = rsf . read ( [string] ) [EOL] actual = rsf . dump ( commands ) [EOL] [EOL] assert actual == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import registers [EOL] from registers import Blob , Hash [EOL] [EOL] [EOL] def test_digest ( ) : [EOL] [docstring] [EOL] [EOL] blob = Blob ( { [string] : [string] } ) [EOL] expected = Hash ( [string] , [string] ) [EOL] [EOL] assert blob . digest ( ) == expected [EOL] [EOL] [EOL] def test_utf8_digest ( ) : [EOL] blob = Blob ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] expected = Hash ( [string] , [string] ) [EOL] [EOL] assert blob . digest ( ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import registers [EOL] import typing [EOL] import pytest [EOL] from registers import ( rsf , Register , Attribute , Hash , Entry , Scope , Blob , Record , Patch ) [EOL] from registers . rsf import parse [EOL] [EOL] [EOL] @ pytest . fixture def country_rsf ( ) : [EOL] with open ( [string] , [string] ) as handle : [EOL] return handle . readlines ( ) [EOL] [EOL] [EOL] @ pytest . fixture def country_register ( ) : [EOL] commands = rsf . read ( [string] ) [EOL] register = Register ( commands ) [EOL] [EOL] return register [EOL] [EOL] [EOL] def test_load_commands ( ) : [EOL] commands = parse ( [string] . splitlines ( ) ) [comment] [EOL] actual = Register ( commands ) [EOL] [EOL] assert actual . stats ( ) == { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] } } [EOL] [EOL] [EOL] def test_collect_country ( country_register ) : [EOL] assert country_register . stats ( ) == { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] } } [EOL] [EOL] [EOL] def test_empty_records ( ) : [EOL] register = Register ( ) [EOL] records = register . records ( ) [EOL] actual = len ( records ) [EOL] [EOL] assert actual == [number] [EOL] [EOL] [EOL] def test_country_records ( country_register ) : [EOL] records = country_register . records ( ) [EOL] actual = len ( records ) [EOL] [EOL] assert actual == [number] [EOL] [EOL] [EOL] def test_country_schema ( country_register ) : [EOL] schema = country_register . schema ( ) [EOL] [EOL] assert schema . primary_key == [string] [EOL] assert len ( schema . attributes ) == [number] [EOL] assert isinstance ( schema . attributes [ [number] ] , Attribute ) [EOL] [EOL] [EOL] def test_trail ( country_register ) : [EOL] key = [string] [EOL] expected = [ Entry ( key , Scope . User , [string] , Hash ( [string] , [string] ) , [number] ) ] [EOL] [EOL] actual = country_register . trail ( key ) [EOL] [EOL] assert actual == expected [EOL] [EOL] [EOL] def test_record ( country_register ) : [EOL] entry = Entry ( [string] , Scope . User , [string] , Hash ( [string] , [string] ) , [number] ) [EOL] blob = Blob ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] expected = Record ( entry , blob ) [EOL] actual = country_register . record ( [string] ) [EOL] [EOL] assert actual == expected [EOL] [EOL] [EOL] def test_patch_country ( country_register ) : [EOL] blobs = [ Blob ( { [string] : [string] , [string] : [string] , [string] : [string] , } ) ] [EOL] timestamp = [string] [EOL] patch = Patch ( country_register . schema ( ) , blobs , timestamp ) [EOL] country_register . apply ( patch ) [EOL] records = len ( country_register . records ( ) ) [EOL] [EOL] assert records == [number] [EOL] assert country_register . stats ( ) == { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import registers [EOL] from registers . blob import Blob [EOL] from registers . entry import Entry , Scope [EOL] from registers . hash import Hash [EOL] from registers . record import Record [EOL] [EOL] [EOL] def test_json_repr ( ) : [EOL] entry = Entry ( [string] , Scope . User , [string] , Hash ( [string] , [string] ) , [number] ) [EOL] blob = Blob ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] record = Record ( entry , blob ) [EOL] expected = [string] [comment] [EOL] actual = record . to_json ( ) [EOL] [EOL] assert actual == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import registers [EOL] import typing [EOL] import pytest [EOL] from registers import ( rsf , xsv , schema , Register , Schema , Blob , Entry , Scope , Patch , Hash ) [EOL] [EOL] [EOL] @ pytest . fixture def fec_register ( ) : [EOL] filename = [string] [EOL] commands = rsf . read ( filename ) [EOL] register = Register ( commands ) [EOL] [EOL] return register [EOL] [EOL] [EOL] @ pytest . fixture def fec_old_patch ( ) : [EOL] [docstring] [EOL] with open ( [string] ) as handle : [EOL] return handle . read ( ) . splitlines ( ) [EOL] [EOL] [EOL] def test_patch ( ) : [EOL] sch = Schema ( [string] , [ schema . string ( [string] ) , schema . integer ( [string] ) , schema . integer ( [string] ) ] ) [EOL] blobs = [ Blob ( { [string] : [string] , [string] : [string] , [string] : [string] } ) , Blob ( { [string] : [string] , [string] : [string] , [string] : [string] } ) , Blob ( { [string] : [string] , [string] : [string] , [string] : [string] } ) , ] [EOL] timestamp = [string] [EOL] patch = Patch ( sch , blobs , timestamp ) [EOL] expected = [ rsf . Command ( rsf . Action . AddItem , Blob ( { [string] : [string] , [string] : [string] , [string] : [string] } ) ) , rsf . Command ( rsf . Action . AppendEntry , Entry ( [string] , Scope . User , timestamp , Hash ( [string] , [string] ) ) ) , rsf . Command ( rsf . Action . AddItem , Blob ( { [string] : [string] , [string] : [string] , [string] : [string] } ) ) , rsf . Command ( rsf . Action . AppendEntry , Entry ( [string] , Scope . User , timestamp , Hash ( [string] , [string] ) ) ) , rsf . Command ( rsf . Action . AddItem , Blob ( { [string] : [string] , [string] : [string] , [string] : [string] } ) ) , rsf . Command ( rsf . Action . AppendEntry , Entry ( [string] , Scope . User , timestamp , Hash ( [string] , [string] ) ) ) ] [EOL] [EOL] assert patch . commands == expected [EOL] [EOL] [EOL] def test_regression_fec_patch ( fec_register , fec_old_patch ) : [EOL] sch = fec_register . schema ( ) [EOL] timestamp = [string] [EOL] fec_patch_filename = [string] [EOL] [EOL] with open ( fec_patch_filename , [string] , newline = [string] ) as handle : [EOL] blobs = xsv . deserialise ( handle , sch ) [EOL] patch = Patch ( sch , blobs , timestamp ) [EOL] [EOL] fec_register . apply ( patch ) [EOL] [EOL] for old , new in zip ( fec_old_patch , patch . commands ) : [EOL] assert old == repr ( new ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import io [EOL] import registers [EOL] import typing [EOL] import pytest [EOL] import io [EOL] from registers . rsf . core import Action [EOL] from registers . rsf . parser import load , parse , parse_command [EOL] from registers import Blob , Entry , Scope , Hash [EOL] from registers . rsf . exceptions import ( AppendEntryCommandException , AddItemCommandException , AssertRootHashCommandException ) [EOL] [EOL] [EOL] def test_parse ( ) : [EOL] commands = io . StringIO ( [string] ) [comment] [EOL] actual = parse ( commands ) [EOL] [EOL] assert len ( actual ) == [number] [EOL] [EOL] [EOL] def test_load ( ) : [EOL] commands = [string] [comment] [EOL] actual = load ( commands ) [EOL] [EOL] assert len ( actual ) == [number] [EOL] [EOL] [EOL] def test_parse_add_item_command ( ) : [EOL] expected = Blob ( { [string] : [string] } ) [EOL] command = [string] [EOL] actual = parse_command ( command ) [EOL] [EOL] assert actual . action == Action . AddItem [EOL] assert actual . value == expected [EOL] [EOL] [EOL] def test_unexpected_add_item_command ( ) : [EOL] command = [string] [EOL] [EOL] with pytest . raises ( AddItemCommandException ) : [EOL] parse_command ( command ) [EOL] [EOL] [EOL] def test_parse_append_entry_command ( ) : [EOL] expected = Entry ( [string] , Scope . System , [string] , Hash ( [string] , [string] ) ) [EOL] command = [string] [comment] [EOL] actual = parse_command ( command ) [EOL] [EOL] assert actual . action == Action . AppendEntry [EOL] assert actual . value == expected [EOL] [EOL] [EOL] def test_unexpected_append_entry_command ( ) : [EOL] command = [string] [EOL] [EOL] with pytest . raises ( AppendEntryCommandException ) : [EOL] parse_command ( command ) [EOL] [EOL] [EOL] def test_parse_assert_root_command ( ) : [EOL] expected = Hash ( [string] , [string] ) [EOL] command = [string] [comment] [EOL] actual = parse_command ( command ) [EOL] [EOL] assert actual . action == Action . AssertRootHash [EOL] assert actual . value == expected [EOL] [EOL] [EOL] def test_unexpected_assert_root_command ( ) : [EOL] command = [string] [EOL] [EOL] with pytest . raises ( AssertRootHashCommandException ) : [EOL] parse_command ( command ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import registers [EOL] from registers . rsf . core import Command , Action [EOL] from registers import Blob , Entry , Scope , Hash [EOL] [EOL] [EOL] def test_serialize_add_item_command ( ) : [EOL] expected = [string] [EOL] value = Blob ( { [string] : [string] } ) [EOL] command = Command ( Action . AddItem , value ) [EOL] [EOL] assert str ( command ) == expected [EOL] [EOL] [EOL] def test_serialize_append_entry_command ( ) : [EOL] expected = [string] [comment] [EOL] value = Entry ( [string] , Scope . System , [string] , Hash ( [string] , [string] ) ) [EOL] command = Command ( Action . AppendEntry , value ) [EOL] [EOL] assert str ( command ) == expected [EOL] [EOL] [EOL] def test_serialize_assert_root_hash_command ( ) : [EOL] expected = [string] [comment] [EOL] value = Hash ( [string] , [string] ) [EOL] command = Command ( Action . AssertRootHash , value ) [EOL] [EOL] assert str ( command ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import click [EOL] from click . testing import CliRunner [EOL] from registers import commands [EOL] [EOL] [EOL] def test_patch_create ( ) : [EOL] register_filename = [string] [EOL] tsv_filename = [string] [EOL] timestamp = [string] [EOL] expected = [string] . lstrip ( ) [comment] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( commands . patch . create_command , [ [string] , register_filename , [string] , timestamp , tsv_filename ] ) [EOL] [EOL] assert result . exit_code == [number] [EOL] assert result . output == expected [EOL] [EOL] [EOL] def test_patch_create_apply ( ) : [EOL] orig_rsf = [string] [EOL] orig_tsv = [string] [EOL] timestamp = [string] [EOL] runner = CliRunner ( ) [EOL] [EOL] with open ( orig_rsf , [string] ) as handler_rsf , open ( orig_tsv , [string] ) as handler_tsv : [comment] [EOL] register_filename = [string] [EOL] tsv_filename = [string] [EOL] expected = f" [string] { register_filename } [string] " [EOL] [EOL] with runner . isolated_filesystem ( ) : [EOL] with open ( register_filename , [string] ) as handler : [EOL] handler . write ( handler_rsf . read ( ) ) [EOL] [EOL] with open ( tsv_filename , [string] ) as handler : [EOL] handler . write ( handler_tsv . read ( ) ) [EOL] [EOL] result = runner . invoke ( commands . patch . create_command , [ [string] , register_filename , [string] , timestamp , [string] , tsv_filename ] ) [EOL] [EOL] assert result . exit_code == [number] [EOL] assert result . output == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import io [EOL] import registers [EOL] from io import StringIO [EOL] from registers import Blob , Entry , Hash , Scope , Record [EOL] from registers . commands import utils [EOL] [EOL] [EOL] def test_record_json ( ) : [EOL] entry = Entry ( [string] , Scope . User , [string] , Hash ( [string] , [string] ) , [number] ) [EOL] blob = Blob ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] record = Record ( entry , blob ) [EOL] expected = ( [string] [string] [string] [string] [string] [string] ) [EOL] stream = StringIO ( ) [EOL] utils . serialise_json ( record , stream , compact = True ) [EOL] stream . seek ( [number] ) [EOL] actual = stream . read ( ) [EOL] [EOL] assert actual == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0