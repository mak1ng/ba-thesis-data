from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from graph import Graph [EOL] from vertex import Vertex [EOL] from edge import Edge [EOL] [EOL] [EOL] class TestGraph ( unittest . TestCase ) : [EOL] def test_add_vertex ( self ) : [EOL] g = Graph ( ) [EOL] v = Vertex ( [number] ) [EOL] g . add_vertex ( v ) [EOL] [EOL] self . assertFalse ( g . is_empty ( ) ) [EOL] self . assertEqual ( g . get_vertex ( [number] ) , v ) [EOL] [EOL] def test_add_edge ( self ) : [EOL] g = Graph ( ) [EOL] [EOL] v1 = Vertex ( [number] ) [EOL] v2 = Vertex ( [number] ) [EOL] [EOL] g . add_vertex ( v1 ) [EOL] self . assertEqual ( g . get_vertex ( [number] ) , v1 ) [EOL] self . assertNotEqual ( g . get_vertex ( [number] ) , v2 ) [EOL] [EOL] e = Edge ( v1 , v2 , [number] ) [EOL] g . add_edge ( e ) [EOL] self . assertTrue ( g . get_edges ( ) . is_empty ( ) ) [EOL] [EOL] g . add_vertex ( v2 ) [EOL] g . add_edge ( e ) [EOL] self . assertFalse ( g . get_edges ( ) . is_empty ( ) ) [EOL] [EOL] def test_remove_vertex ( self ) : [EOL] g = Graph ( ) [EOL] [EOL] v1 = Vertex ( [number] ) [EOL] v2 = Vertex ( [number] ) [EOL] v3 = Vertex ( [number] ) [EOL] [EOL] g . add_vertex ( v1 ) [EOL] g . add_vertex ( v2 ) [EOL] g . add_vertex ( v3 ) [EOL] [EOL] self . assertFalse ( g . is_empty ( ) ) [EOL] [EOL] vertices = g . get_vertices ( ) [EOL] num_vertices = [number] [EOL] vertices . to_first ( ) [EOL] while vertices . has_access ( ) : [EOL] num_vertices += [number] [EOL] vertices . next ( ) [EOL] self . assertEqual ( num_vertices , [number] ) [EOL] [EOL] g . remove_vertex ( v1 ) [EOL] vertices = g . get_vertices ( ) [EOL] num_vertices = [number] [EOL] vertices . to_first ( ) [EOL] while vertices . has_access ( ) : [EOL] num_vertices += [number] [EOL] vertices . next ( ) [EOL] self . assertEqual ( num_vertices , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import vertex [EOL] import builtins [EOL] from typing import List [EOL] from vertex import Vertex [EOL] [EOL] [EOL] class Edge ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , p_vertex , p_another_vertex , p_weight ) : [EOL] [docstring] [EOL] self . __vertices = [ ] [EOL] self . __vertices . append ( p_vertex ) [EOL] self . __vertices . append ( p_another_vertex ) [EOL] self . __weight = p_weight [EOL] self . __mark = False [EOL] [EOL] def get_vertices ( self ) : [EOL] [docstring] [EOL] return self . __vertices . copy ( ) [EOL] [EOL] def get_weight ( self ) : [EOL] [docstring] [EOL] return self . __weight [EOL] [EOL] def set_weight ( self , p_weight ) : [EOL] [docstring] [EOL] self . __weight = p_weight [EOL] [EOL] def is_marked ( self ) : [EOL] [docstring] [EOL] return self . __mark [EOL] [EOL] def set_mark ( self , p_mark ) : [EOL] [docstring] [EOL] self . __mark = p_mark [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vertex.Vertex$ 0 $vertex.Vertex$ 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.List[vertex.Vertex]$ 0 0 0 0 0 0 $typing.List[vertex.Vertex]$ 0 0 0 $vertex.Vertex$ 0 0 0 0 $typing.List[vertex.Vertex]$ 0 0 0 $vertex.Vertex$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0
import builtins [EOL] class Vertex ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , p_id ) : [EOL] [docstring] [EOL] self . __id = p_id [EOL] self . __mark = False [EOL] [EOL] def get_id ( self ) : [EOL] [docstring] [EOL] return self . __id [EOL] [EOL] def is_marked ( self ) : [EOL] [docstring] [EOL] return self . __mark [EOL] [EOL] def set_mark ( self , p_mark ) : [EOL] [docstring] [EOL] self . __mark = p_mark [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0
from typing import Optional , Any , List [EOL] import typing [EOL] import edge [EOL] import vertex [EOL] import list [EOL] import builtins [EOL] from typing import Optional [EOL] from list import List [EOL] from vertex import Vertex [EOL] from edge import Edge [EOL] [EOL] [EOL] class Graph ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . __vertices = List [ Vertex ] ( ) [EOL] self . __edges = List [ Edge ] ( ) [EOL] [EOL] def get_vertices ( self ) : [EOL] [docstring] [EOL] result = List [ Vertex ] ( ) [EOL] self . __vertices . to_first ( ) [EOL] while self . __vertices . has_access ( ) : [EOL] result . append ( self . __vertices . get_content ( ) ) [EOL] self . __vertices . next ( ) [EOL] [EOL] result . to_first ( ) [EOL] return result [EOL] [EOL] def get_edges ( self , p_vertex = None ) : [EOL] [docstring] [EOL] result = List [ Edge ] ( ) [EOL] [EOL] self . __edges . to_first ( ) [EOL] while self . __edges . has_access ( ) : [EOL] vertex_pair = self . __edges . get_content ( ) . get_vertices ( ) [EOL] [EOL] if p_vertex is None : [EOL] result . append ( self . __edges . get_content ( ) ) [EOL] elif vertex_pair [ [number] ] == p_vertex : [EOL] result . append ( self . __edges . get_content ( ) ) [EOL] elif vertex_pair [ [number] ] == p_vertex : [EOL] result . append ( self . __edges . get_content ( ) ) [EOL] [EOL] self . __edges . next ( ) [EOL] [EOL] return result [EOL] [EOL] def get_vertex ( self , p_id ) : [EOL] [docstring] [EOL] result = None [EOL] self . __vertices . to_first ( ) [EOL] while self . __vertices . has_access ( ) and result is None : [EOL] if self . __vertices . get_content ( ) . get_id ( ) == p_id : [EOL] result = self . __vertices . get_content ( ) [EOL] self . __vertices . next ( ) [EOL] [EOL] return result [EOL] [EOL] def add_vertex ( self , p_vertex ) : [EOL] [docstring] [EOL] if p_vertex is not None and p_vertex . get_id ( ) is not None : [EOL] free_id = True [EOL] self . __vertices . to_first ( ) [EOL] while self . __vertices . has_access ( ) and free_id : [EOL] if self . __vertices . get_content ( ) . get_id ( ) == p_vertex . get_id ( ) : [EOL] free_id = False [EOL] self . __vertices . next ( ) [EOL] [EOL] if free_id : [EOL] self . __vertices . append ( p_vertex ) [EOL] [EOL] def add_edge ( self , p_edge ) : [EOL] [docstring] [EOL] if p_edge is not None : [EOL] vertex_pair = p_edge . get_vertices ( ) [EOL] [EOL] if vertex_pair [ [number] ] is not None and vertex_pair [ [number] ] is not None and self . get_vertex ( vertex_pair [ [number] ] . get_id ( ) ) == vertex_pair [ [number] ] and self . get_vertex ( vertex_pair [ [number] ] . get_id ( ) ) == vertex_pair [ [number] ] and self . get_edge ( vertex_pair [ [number] ] , vertex_pair [ [number] ] ) is None and vertex_pair [ [number] ] is not vertex_pair [ [number] ] : [EOL] self . __edges . append ( p_edge ) [EOL] [EOL] def remove_vertex ( self , p_vertex ) : [EOL] [docstring] [EOL] self . __edges . to_first ( ) [EOL] while self . __edges . has_access ( ) : [EOL] akt = self . __edges . get_content ( ) . get_vertices ( ) [EOL] if akt [ [number] ] == p_vertex or akt [ [number] ] == p_vertex : [EOL] self . __edges . remove ( ) [EOL] else : [EOL] self . __edges . next ( ) [EOL] [EOL] self . __vertices . to_first ( ) [EOL] while self . __vertices . has_access ( ) and self . __vertices . get_content ( ) is not p_vertex : [EOL] self . __vertices . next ( ) [EOL] [EOL] if self . __vertices . has_access ( ) : [EOL] self . __vertices . remove ( ) [EOL] [EOL] def remove_edge ( self , p_edge ) : [EOL] [docstring] [EOL] self . __edges . to_first ( ) [EOL] while self . __edges . has_access ( ) : [EOL] if self . __edges . get_content ( ) == p_edge : [EOL] self . __edges . remove ( ) [EOL] else : [EOL] self . __edges . next ( ) [EOL] [EOL] def set_all_vertex_marks ( self , p_mark ) : [EOL] [docstring] [EOL] self . __vertices . to_first ( ) [EOL] [EOL] while self . __vertices . has_access ( ) : [EOL] self . __vertices . get_content ( ) . set_mark ( p_mark ) [EOL] self . __vertices . next ( ) [EOL] [EOL] def set_all_edge_marks ( self , p_mark ) : [EOL] [docstring] [EOL] self . __edges . to_first ( ) [EOL] [EOL] while self . __edges . has_access ( ) : [EOL] self . __edges . get_content ( ) . set_mark ( p_mark ) [EOL] self . __edges . next ( ) [EOL] [EOL] def all_vertices_marked ( self ) : [EOL] [docstring] [EOL] result = True [EOL] self . __vertices . to_first ( ) [EOL] while self . __vertices . has_access ( ) : [EOL] if not self . __vertices . get_content ( ) . is_marked ( ) : [EOL] result = False [EOL] self . __vertices . next ( ) [EOL] return result [EOL] [EOL] def all_edges_marked ( self ) : [EOL] [docstring] [EOL] result = True [EOL] self . __edges . to_first ( ) [EOL] while self . __edges . has_access ( ) : [EOL] if not self . __edges . get_content ( ) . is_marked ( ) : [EOL] result = False [EOL] self . __edges . next ( ) [EOL] return result [EOL] [EOL] def get_neighbours ( self , p_vertex ) : [EOL] [docstring] [EOL] result = List [ Vertex ] ( ) [EOL] [EOL] self . __edges . to_first ( ) [EOL] while self . __edges . has_access ( ) : [EOL] vertex_pair = self . __edges . get_content ( ) . get_vertices ( ) [EOL] [EOL] if vertex_pair [ [number] ] == p_vertex : [EOL] result . append ( vertex_pair [ [number] ] ) [EOL] elif vertex_pair [ [number] ] == p_vertex : [EOL] result . append ( vertex_pair [ [number] ] ) [EOL] [EOL] self . __edges . next ( ) [EOL] [EOL] return result [EOL] [EOL] def get_edge ( self , p_vertex , p_another_vertex ) : [EOL] [docstring] [EOL] result = None [EOL] [EOL] self . __edges . to_first ( ) [EOL] while self . __edges . has_access ( ) and result is None : [EOL] vertex_pair = self . __edges . get_content ( ) . get_vertices ( ) [EOL] if ( vertex_pair [ [number] ] == p_vertex and vertex_pair [ [number] ] == p_another_vertex ) or ( vertex_pair [ [number] ] == p_another_vertex and vertex_pair [ [number] ] == p_vertex ) : [EOL] result = self . __edges . get_content ( ) [EOL] [EOL] self . __edges . next ( ) [EOL] [EOL] return result [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return self . __vertices . is_empty ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $list.List[vertex.Vertex]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $list.List[edge.Edge]$ 0 0 0 $vertex.Vertex$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vertex.Vertex$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[vertex.Vertex]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $vertex.Vertex$ 0 0 0 0 0 0 $vertex.Vertex$ 0 0 0 0 $vertex.Vertex$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vertex.Vertex$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $vertex.Vertex$ 0 0 0 0 0 0 0 0 $edge.Edge$ 0 0 0 0 0 0 $edge.Edge$ 0 0 0 0 0 $typing.Any$ 0 $edge.Edge$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $edge.Edge$ 0 0 0 0 0 0 0 0 $vertex.Vertex$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vertex.Vertex$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $edge.Edge$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $edge.Edge$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $list.List[vertex.Vertex]$ 0 0 0 $vertex.Vertex$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[edge.Edge]$ 0 0 0 $vertex.Vertex$ 0 $vertex.Vertex$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 0 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 $typing.Any$ 0 0 0 0 $vertex.Vertex$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from binary_tree import BinaryTree [EOL] [EOL] [EOL] class TestBinaryTree ( unittest . TestCase ) : [EOL] [EOL] def test_init_none ( self ) : [EOL] bt = BinaryTree ( ) [EOL] [EOL] self . assertTrue ( bt . is_empty ( ) ) [EOL] [EOL] def test_init_content ( self ) : [EOL] [EOL] bt = BinaryTree ( [number] ) [EOL] [EOL] self . assertFalse ( bt . is_empty ( ) ) [EOL] self . assertEqual ( bt . get_content ( ) , [number] ) [EOL] [EOL] def test_init_r_tree ( self ) : [EOL] r_bt = BinaryTree ( [number] ) [EOL] bt = BinaryTree ( [number] , right_tree = r_bt ) [EOL] [EOL] self . assertFalse ( bt . is_empty ( ) ) [EOL] self . assertEqual ( bt . get_right_tree ( ) , r_bt ) [EOL] [EOL] def test_init_l_tree ( self ) : [EOL] l_bt = BinaryTree ( [number] ) [EOL] bt = BinaryTree ( [number] , left_tree = l_bt ) [EOL] [EOL] self . assertFalse ( bt . is_empty ( ) ) [EOL] self . assertEqual ( bt . get_left_tree ( ) , l_bt ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , TypeVar [EOL] import typing [EOL] import comparable_content [EOL] import builtins [EOL] from typing import Generic , TypeVar , Optional [EOL] from comparable_content import ComparableContent [EOL] [EOL] ContentType = TypeVar ( [string] ) [EOL] [EOL] [EOL] class BinarySearchTree ( Generic [ ContentType ] ) : [EOL] [docstring] [EOL] [EOL] class BSTNode ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , p_content ) : [EOL] [docstring] [EOL] self . _content = p_content [EOL] self . _left = BinarySearchTree ( ) [EOL] self . _right = BinarySearchTree ( ) [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . __node = None [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return self . __node is None [EOL] [EOL] def insert ( self , p_content ) : [EOL] [docstring] [EOL] if p_content is not None : [EOL] if self . is_empty ( ) : [EOL] self . __node = BinarySearchTree . BSTNode ( p_content ) [EOL] elif p_content . is_less ( self . __node . _content ) : [EOL] self . __node . _left . insert ( p_content ) [EOL] elif p_content . is_greater ( self . __node . _content ) : [EOL] self . __node . _right . insert ( p_content ) [EOL] [EOL] def get_content ( self ) : [EOL] [docstring] [EOL] if self . is_empty ( ) or self . __node is None : [EOL] return None [EOL] else : [EOL] return self . __node . _content [EOL] [EOL] def get_left_tree ( self ) : [EOL] [docstring] [EOL] if self . is_empty ( ) : [EOL] return None [EOL] else : [EOL] return self . __node . _left [EOL] [EOL] def get_right_tree ( self ) : [EOL] [docstring] [EOL] if self . is_empty ( ) : [EOL] return None [EOL] else : [EOL] return self . __node . _right [EOL] [EOL] def remove ( self , p_content ) : [EOL] [docstring] [EOL] if self . is_empty ( ) or p_content is None : [EOL] return [EOL] [EOL] if p_content . is_less ( self . __node . _content ) : [EOL] self . __node . _left . remove ( p_content ) [EOL] elif p_content . is_greater ( self . __node . _content ) : [EOL] self . __node . _right . remove ( p_content ) [EOL] else : [EOL] if self . __node . _left . is_empty ( ) : [EOL] if self . __node . _right . is_empty ( ) : [EOL] self . __node = None [EOL] else : [EOL] self . __node = self . __get_node_of_right_successor ( ) [EOL] elif self . __node . _right . is_empty ( ) : [EOL] self . __node = self . __get_node_of_left_successor ( ) [EOL] else : [EOL] if self . __get_node_of_right_successor ( ) . _left . is_empty ( ) : [EOL] self . __node . _content = self . __get_node_of_right_successor ( ) . _content [EOL] self . __node . _right = self . __get_node_of_right_successor ( ) . _right [EOL] else : [EOL] previous = self . __node . _right . __ancestor_of_small_right ( ) [EOL] smallest = previous . __node . _left [EOL] self . __node . _content = smallest . __node . _content [EOL] previous . remove ( smallest . __node . _content ) [EOL] [EOL] def search ( self , p_content ) : [EOL] [docstring] [EOL] if self . is_empty ( ) or p_content is None : [EOL] return None [EOL] [EOL] content = self . get_content ( ) [EOL] if content is None : [EOL] return None [EOL] [EOL] if p_content . is_less ( content ) : [EOL] tree = self . get_left_tree ( ) [EOL] if tree : [EOL] return tree . search ( p_content ) [EOL] else : [EOL] return None [EOL] elif p_content . is_greater ( content ) : [EOL] tree = self . get_right_tree ( ) [EOL] if tree : [EOL] return tree . search ( p_content ) [EOL] else : [EOL] return None [EOL] elif p_content . is_equal ( content ) : [EOL] return content [EOL] else : [EOL] return None [EOL] [EOL] def __ancestor_of_small_right ( self ) : [EOL] [docstring] [EOL] if self . __get_node_of_left_successor ( ) . _left . is_empty ( ) : [EOL] return self [EOL] else : [EOL] return self . __node . _left . __ancestor_of_small_right [EOL] [EOL] def __get_node_of_left_successor ( self ) : [EOL] return self . __node . _left . __node [EOL] [EOL] def __get_node_of_right_successor ( self ) : [EOL] return self . __node . _right . __node [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent$ 0 0 0 0 0 0 0 $comparable_content.ComparableContent$ 0 $comparable_content.ComparableContent$ 0 0 0 $'BinarySearchTree'$ 0 0 0 0 0 0 0 $'BinarySearchTree'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 $typing.Optional[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['BinarySearchTree']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['BinarySearchTree']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ContentType]$ 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 $comparable_content.ComparableContent[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from binary_search_tree import BinarySearchTree [EOL] from comparable_content import ComparableContent [EOL] [EOL] [EOL] class ComparableInt ( ComparableContent ) : [EOL] [EOL] def __init__ ( self , i ) : [EOL] self . i = i [EOL] [EOL] def is_greater ( self , ci ) : [EOL] return self . i > ci . i [EOL] [EOL] def is_less ( self , ci ) : [EOL] return self . i < ci . i [EOL] [EOL] def is_equal ( self , ci ) : [EOL] return self . i == ci . i [EOL] [EOL] [EOL] class TestBinarySearchTree ( unittest . TestCase ) : [EOL] [EOL] def test_init ( self ) : [EOL] bt = BinarySearchTree ( ) [EOL] [EOL] self . assertTrue ( bt . is_empty ( ) ) [EOL] [EOL] def test ( self ) : [EOL] bt = BinarySearchTree ( ) [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] self . assertFalse ( bt . is_empty ( ) ) [EOL] [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] self . assertEqual ( bt . get_content ( ) . i , [number] ) [EOL] self . assertEqual ( bt . get_left_tree ( ) . get_content ( ) . i , [number] ) [EOL] self . assertEqual ( bt . get_right_tree ( ) . get_content ( ) . i , [number] ) [EOL] [EOL] bt . remove ( ComparableInt ( [number] ) ) [EOL] self . assertEqual ( bt . get_content ( ) . i , [number] ) [EOL] self . assertEqual ( bt . get_left_tree ( ) . get_content ( ) . i , [number] ) [EOL] self . assertEqual ( bt . get_right_tree ( ) . get_content ( ) , None ) [EOL] [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] bt . insert ( ComparableInt ( [number] ) ) [EOL] [EOL] self . assertEqual ( bt . search ( ComparableInt ( [number] ) ) . i , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar [EOL] import typing [EOL] import builtins [EOL] from typing import Generic , TypeVar [EOL] import abc [EOL] [EOL] ContentType = TypeVar ( [string] ) [EOL] [EOL] [EOL] class ComparableContent ( Generic [ ContentType ] , abc . ABC ) : [EOL] [docstring] [EOL] @ abc . abstractmethod def is_greater ( self , p_content ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ abc . abstractmethod def is_equal ( self , p_content ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ abc . abstractmethod def is_less ( self , p_content ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $ContentType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $ContentType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $ContentType$ 0 0 0 0 0 0 0
from typing import Optional , TypeVar [EOL] import typing [EOL] import builtins [EOL] from typing import Generic , TypeVar , Optional [EOL] [EOL] ContentType = TypeVar ( [string] ) [EOL] [EOL] [EOL] class BinaryTree ( Generic [ ContentType ] ) : [EOL] [docstring] [EOL] [EOL] class BTNode ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , p_content ) : [EOL] [docstring] [EOL] self . _content = p_content [EOL] self . _left = BinaryTree ( ) [EOL] self . _right = BinaryTree ( ) [EOL] [EOL] def __init__ ( self , p_content = None , left_tree = None , right_tree = None ) : [EOL] [docstring] [EOL] self . __node = None [EOL] [EOL] if p_content is not None : [EOL] self . __node = BinaryTree . BTNode ( p_content ) [EOL] [EOL] if left_tree is not None : [EOL] self . __node . _left = left_tree [EOL] [EOL] if right_tree is not None : [EOL] self . __node . _right = right_tree [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return self . __node is None [EOL] [EOL] def set_content ( self , p_content ) : [EOL] [docstring] [EOL] if p_content is not None : [EOL] if self . is_empty ( ) : [EOL] self . __node = BinaryTree . BTNode ( p_content ) [EOL] self . __node . _left = BinaryTree ( ) [EOL] self . __node . _right = BinaryTree ( ) [EOL] if self . __node is not None : [EOL] self . __node . _content = p_content [EOL] [EOL] def get_content ( self ) : [EOL] [docstring] [EOL] if self . is_empty ( ) : [EOL] return None [EOL] elif self . __node is not None : [EOL] return self . __node . _content [EOL] return None [EOL] [EOL] def set_left_tree ( self , p_tree ) : [EOL] [docstring] [EOL] if not self . is_empty ( ) and p_tree is not None and self . __node is not None : [EOL] self . __node . _left = p_tree [EOL] [EOL] def set_right_tree ( self , p_tree ) : [EOL] [docstring] [EOL] if not self . is_empty ( ) and p_tree is not None and self . __node is not None : [EOL] self . __node . _right = p_tree [EOL] [EOL] def get_left_tree ( self ) : [EOL] [docstring] [EOL] if not self . is_empty ( ) and self . __node is not None : [EOL] return self . __node . _left [EOL] else : [EOL] return None [EOL] [EOL] def get_right_tree ( self ) : [EOL] [docstring] [EOL] if not self . is_empty ( ) and self . __node is not None : [EOL] return self . __node . _right [EOL] else : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['BinaryTree']$ 0 0 0 0 0 0 0 $typing.Optional['BinaryTree']$ 0 0 0 0 0 0 0 0 0 0 0 $ContentType$ 0 0 0 $'BinaryTree'$ 0 0 0 $'BinaryTree'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ContentType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ContentType$ 0 0 0 0 $'BinaryTree'$ 0 0 0 0 0 0 0 0 0 0 0 $'BinaryTree'$ 0 0 0 $'BinaryTree'$ 0 0 0 0 0 0 0 0 0 0 0 $'BinaryTree'$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ContentType$ 0 0 0 0 0 0 $ContentType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ContentType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ContentType$ 0 0 0 $typing.Optional[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'BinaryTree'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $'BinaryTree'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'BinaryTree'$ 0 0 0 0 0 0 0 $'BinaryTree'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $'BinaryTree'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'BinaryTree'$ 0 0 0 $typing.Optional['BinaryTree']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['BinaryTree']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import queue [EOL] import unittest [EOL] [EOL] from queue import Queue [EOL] [EOL] [EOL] class TestQueueNode ( unittest . TestCase ) : [EOL] def test_init ( self ) : [EOL] queue = Queue ( ) [EOL] [EOL] queue_node = queue . QueueNode ( [number] ) [EOL] [EOL] self . assertEqual ( queue_node . _QueueNode__content , [number] ) [EOL] [EOL] def test_next ( self ) : [EOL] queue = Queue ( ) [EOL] [EOL] queue_node = queue . QueueNode ( [number] ) [EOL] next_queue_node = queue . QueueNode ( [number] ) [EOL] [EOL] self . assertEqual ( queue_node . get_next ( ) , None ) [EOL] [EOL] queue_node . set_next ( next_queue_node ) [EOL] [EOL] self . assertEqual ( queue_node . get_next ( ) , next_queue_node ) [EOL] self . assertEqual ( next_queue_node . get_next ( ) , None ) [EOL] [EOL] def test_content ( self ) : [EOL] queue = Queue ( ) [EOL] [EOL] queue_node = queue . QueueNode ( [number] ) [EOL] [EOL] self . assertEqual ( queue_node . get_content ( ) , [number] ) [EOL] [EOL] [EOL] class TestQueue ( unittest . TestCase ) : [EOL] [EOL] def test ( self ) : [EOL] queue = Queue ( ) [EOL] [EOL] self . assertTrue ( queue . is_empty ( ) ) [EOL] [EOL] queue . enqueue ( [number] ) [EOL] [EOL] self . assertFalse ( queue . is_empty ( ) ) [EOL] [EOL] self . assertEqual ( queue . front ( ) , [number] ) [EOL] [EOL] queue . enqueue ( [number] ) [EOL] [EOL] self . assertEqual ( queue . front ( ) , [number] ) [EOL] [EOL] queue . dequeue ( ) [EOL] [EOL] self . assertEqual ( queue . front ( ) , [number] ) [EOL] [EOL] queue . dequeue ( ) [EOL] [EOL] self . assertEqual ( queue . front ( ) , None ) [EOL] [EOL] queue . dequeue ( ) [EOL] [EOL] self . assertEqual ( queue . front ( ) , None ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , TypeVar [EOL] import typing [EOL] import builtins [EOL] from typing import TypeVar , Generic , Optional [EOL] [EOL] ContentType = TypeVar ( [string] ) [EOL] [EOL] [EOL] class Queue ( Generic [ ContentType ] ) : [EOL] [docstring] [EOL] [EOL] class QueueNode ( ) : [EOL] [EOL] def __init__ ( self , p_content ) : [EOL] [docstring] [EOL] self . __content = p_content [EOL] self . __next_node = None [EOL] [EOL] def get_next ( self ) : [EOL] [docstring] [EOL] return self . __next_node [EOL] [EOL] def set_next ( self , p_next ) : [EOL] [docstring] [EOL] self . __next_node = p_next [EOL] [EOL] def get_content ( self ) : [EOL] [docstring] [EOL] return self . __content [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . __head = None [EOL] self . __tail = None [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return self . __head is None [EOL] [EOL] def enqueue ( self , p_content ) : [EOL] [docstring] [EOL] if p_content is not None : [EOL] new_node = Queue . QueueNode ( p_content ) [EOL] if self . is_empty ( ) : [EOL] self . __head = new_node [EOL] self . __tail = new_node [EOL] else : [EOL] self . __tail . set_next ( new_node ) [EOL] self . __tail = new_node [EOL] [EOL] def dequeue ( self ) : [EOL] [docstring] [EOL] if not self . is_empty ( ) : [EOL] self . __head = self . __head . get_next ( ) [EOL] if self . is_empty ( ) : [EOL] self . __head = None [EOL] self . __tail = None [EOL] [EOL] def front ( self ) : [EOL] [docstring] [EOL] if self . is_empty ( ) : [EOL] return None [EOL] else : [EOL] return self . __head . get_content ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['Queue.QueueNode']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Queue.QueueNode'$ 0 0 0 0 0 0 0 0 0 $'Queue.QueueNode'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ContentType$ 0 0 0 0 0 0 $ContentType$ 0 0 0 0 0 0 0 0 0 0 0 $ContentType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , TypeVar [EOL] import typing [EOL] import builtins [EOL] from typing import TypeVar , Generic , Optional [EOL] [EOL] ContentType = TypeVar ( [string] ) [EOL] [EOL] [EOL] class Stack ( Generic [ ContentType ] ) : [EOL] [docstring] [EOL] [EOL] class StackNode ( ) : [EOL] [EOL] def __init__ ( self , p_content ) : [EOL] [docstring] [EOL] self . __content = p_content [EOL] self . __next_node = None [EOL] [EOL] def get_next ( self ) : [EOL] [docstring] [EOL] return self . __next_node [EOL] [EOL] def set_next ( self , p_next ) : [EOL] [docstring] [EOL] self . __next_node = p_next [EOL] [EOL] def get_content ( self ) : [EOL] [docstring] [EOL] return self . __content [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . __head = None [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return self . __head is None [EOL] [EOL] def push ( self , p_content ) : [EOL] [docstring] [EOL] if ( p_content is not None ) : [EOL] node = Stack . StackNode ( p_content ) [EOL] node . set_next ( self . __head ) [EOL] self . __head = node [EOL] [EOL] def pop ( self ) : [EOL] [docstring] [EOL] if not self . is_empty ( ) : [EOL] self . __head = self . __head . get_next ( ) [EOL] [EOL] def top ( self ) : [EOL] [docstring] [EOL] if not self . is_empty ( ) : [EOL] return self . __head . get_content ( ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['Stack.StackNode']$ 0 0 0 0 0 $'Optional[Stack.StackNode]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Stack.StackNode'$ 0 0 0 0 0 0 0 0 0 $'Stack.StackNode'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ContentType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List , TypeVar [EOL] import typing [EOL] from typing import TypeVar , Generic , Optional [EOL] [EOL] ContentType = TypeVar ( [string] ) [EOL] [EOL] [EOL] class List ( Generic [ ContentType ] ) : [EOL] [docstring] [EOL] [EOL] class ListNode ( ) : [EOL] [EOL] def __init__ ( self , p_content ) : [EOL] [docstring] [EOL] self . __content = p_content [EOL] self . __next = None [EOL] [EOL] def get_content ( self ) : [EOL] [docstring] [EOL] return self . __content [EOL] [EOL] def set_content ( self , p_content ) : [EOL] [docstring] [EOL] self . __content = p_content [EOL] [EOL] def get_next_node ( self ) : [EOL] [docstring] [EOL] return self . __next [EOL] [EOL] def set_next_node ( self , p_next ) : [EOL] [docstring] [EOL] self . __next = p_next [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _first = None [EOL] self . _last = None [EOL] self . _current = None [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] return self . _first is None [EOL] [EOL] def has_access ( self ) : [EOL] [docstring] [EOL] return self . _current is not None [EOL] [EOL] def next ( self ) : [EOL] [docstring] [EOL] if self . has_access ( ) : [EOL] self . _current = self . _current . get_next_node ( ) [EOL] [EOL] def to_first ( self ) : [EOL] [docstring] [EOL] if not self . is_empty ( ) : [EOL] self . _current = self . _first [EOL] [EOL] def to_last ( self ) : [EOL] [docstring] [EOL] if not self . is_empty ( ) : [EOL] self . _current = self . _last [EOL] [EOL] def get_content ( self ) : [EOL] [docstring] [EOL] if self . has_access ( ) : [EOL] return self . _current . get_content ( ) [EOL] else : [EOL] return None [EOL] [EOL] def set_content ( self , p_content ) : [EOL] [docstring] [EOL] if p_content is not None and self . has_access ( ) : [EOL] self . _current . set_content ( p_content ) [EOL] [EOL] def insert ( self , p_content ) : [EOL] [docstring] [EOL] if p_content is not None : [EOL] if self . has_access ( ) : [EOL] new_node = List . ListNode ( p_content ) [EOL] [EOL] if self . _current is not self . _first : [EOL] previous = self . get_previous ( self . _current ) [EOL] if previous is not None : [EOL] new_node . set_next_node ( previous . get_next_node ( ) ) [EOL] previous . set_next_node ( new_node ) [EOL] else : [EOL] new_node . set_next_node ( self . _first ) [EOL] self . _first = new_node [EOL] else : [EOL] if self . is_empty ( ) : [EOL] new_node = List . ListNode ( p_content ) [EOL] [EOL] self . _first = new_node [EOL] self . _last = new_node [EOL] [EOL] def append ( self , p_content ) : [EOL] [docstring] [EOL] if p_content is not None : [EOL] if self . is_empty ( ) : [EOL] self . insert ( p_content ) [EOL] else : [EOL] new_node = List . ListNode ( p_content ) [EOL] [EOL] self . _last . set_next_node ( new_node ) [EOL] self . _last = new_node [EOL] [EOL] def concat ( self , p_list ) : [EOL] [docstring] [EOL] if p_list is not self and p_list is not None and not p_list . is_empty ( ) : [EOL] if self . is_empty ( ) : [EOL] self . _first = p_list . _first [EOL] self . _last = p_list . _last [EOL] else : [EOL] self . _last . set_next_node ( p_list . _first ) [EOL] self . _last = p_list . _last [EOL] [EOL] p_list . _first = None [EOL] p_list . _last = None [EOL] p_list . _current = None [EOL] [EOL] def remove ( self ) : [EOL] [docstring] [EOL] if self . has_access ( ) and not self . is_empty ( ) : [EOL] if self . _current is self . _first : [EOL] self . _first = self . _first . get_next_node ( ) [EOL] else : [EOL] previous = self . get_previous ( self . _current ) [EOL] if self . _current is self . _last : [EOL] self . _last = previous [EOL] previous . set_next_node ( self . _current . get_next_node ( ) ) [EOL] [EOL] temp = self . _current . get_next_node ( ) [EOL] self . _current . set_content ( None ) [EOL] self . _current . set_next_node ( None ) [EOL] self . _current = temp [EOL] [EOL] if self . is_empty ( ) : [EOL] self . _last = None [EOL] [EOL] def get_previous ( self , p_node ) : [EOL] [docstring] [EOL] if p_node is not None and p_node is not self . _first and not self . is_empty ( ) : [EOL] temp = self . _first [EOL] while temp is not None and temp . next is not p_node : [EOL] temp = temp . get_next_node ( ) [EOL] return temp [EOL] else : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from list import List [EOL] [EOL] [EOL] class TestListNode ( unittest . TestCase ) : [EOL] def test_init ( self ) : [EOL] list = List ( ) [EOL] [EOL] list_node = list . ListNode ( [number] ) [EOL] [EOL] self . assertEqual ( list_node . _ListNode__content , [number] ) [EOL] [EOL] def test_next ( self ) : [EOL] list = List ( ) [EOL] [EOL] list_node = list . ListNode ( [number] ) [EOL] next_list_node = list . ListNode ( [number] ) [EOL] [EOL] self . assertEqual ( list_node . get_next_node ( ) , None ) [EOL] [EOL] list_node . set_next_node ( next_list_node ) [EOL] [EOL] self . assertEqual ( list_node . get_next_node ( ) , next_list_node ) [EOL] self . assertEqual ( next_list_node . get_next_node ( ) , None ) [EOL] [EOL] def test_content ( self ) : [EOL] list = List ( ) [EOL] [EOL] list_node = list . ListNode ( [number] ) [EOL] [EOL] self . assertEqual ( list_node . get_content ( ) , [number] ) [EOL] [EOL] [EOL] class Testlist ( unittest . TestCase ) : [EOL] [EOL] def test ( self ) : [EOL] list = List ( ) [EOL] self . assertTrue ( list . is_empty ( ) ) [EOL] self . assertFalse ( list . has_access ( ) ) [EOL] [EOL] list . insert ( [number] ) [EOL] self . assertFalse ( list . is_empty ( ) ) [EOL] self . assertFalse ( list . has_access ( ) ) [EOL] [EOL] list . to_first ( ) [EOL] self . assertTrue ( list . has_access ( ) ) [EOL] self . assertEqual ( list . get_content ( ) , [number] ) [EOL] [EOL] list . set_content ( [number] ) [EOL] self . assertTrue ( list . has_access ( ) ) [EOL] self . assertEqual ( list . get_content ( ) , [number] ) [EOL] [EOL] list . append ( [number] ) [EOL] self . assertTrue ( list . has_access ( ) ) [EOL] self . assertEqual ( list . get_content ( ) , [number] ) [EOL] [EOL] list . to_last ( ) [EOL] self . assertTrue ( list . has_access ( ) ) [EOL] self . assertEqual ( list . get_content ( ) , [number] ) [EOL] [EOL] list . next ( ) [EOL] self . assertFalse ( list . has_access ( ) ) [EOL] self . assertEqual ( list . get_content ( ) , None ) [EOL] [EOL] list . to_first ( ) [EOL] list . remove ( ) [EOL] self . assertTrue ( list . has_access ( ) ) [EOL] self . assertEqual ( list . get_content ( ) , [number] ) [EOL] [EOL] def test_concat ( self ) : [EOL] list1 = List ( ) [EOL] list1 . append ( [number] ) [EOL] list1 . append ( [number] ) [EOL] list1 . append ( [number] ) [EOL] [EOL] list2 = List ( ) [EOL] list2 . append ( [number] ) [EOL] list2 . append ( [number] ) [EOL] list2 . append ( [number] ) [EOL] [EOL] list1 . concat ( list2 ) [EOL] [EOL] list1 . to_first ( ) [EOL] for i in range ( [number] , [number] ) : [EOL] self . assertEqual ( list1 . get_content ( ) , i ) [EOL] list1 . next ( ) [EOL] [EOL] self . assertTrue ( list2 . is_empty ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[list]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[list]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from stack import Stack [EOL] [EOL] [EOL] class TestStackNode ( unittest . TestCase ) : [EOL] def test_init ( self ) : [EOL] stack = Stack ( ) [EOL] [EOL] stack_node = stack . StackNode ( [number] ) [EOL] [EOL] self . assertEqual ( stack_node . _StackNode__content , [number] ) [EOL] [EOL] def test_next ( self ) : [EOL] stack = Stack ( ) [EOL] [EOL] stack_node = stack . StackNode ( [number] ) [EOL] next_stack_node = stack . StackNode ( [number] ) [EOL] [EOL] self . assertEqual ( stack_node . get_next ( ) , None ) [EOL] [EOL] stack_node . set_next ( next_stack_node ) [EOL] [EOL] self . assertEqual ( stack_node . get_next ( ) , next_stack_node ) [EOL] self . assertEqual ( next_stack_node . get_next ( ) , None ) [EOL] [EOL] def test_content ( self ) : [EOL] stack = Stack ( ) [EOL] [EOL] stack_node = stack . StackNode ( [number] ) [EOL] [EOL] self . assertEqual ( stack_node . get_content ( ) , [number] ) [EOL] [EOL] [EOL] class TestStack ( unittest . TestCase ) : [EOL] [EOL] def test ( self ) : [EOL] stack = Stack [ str ] ( ) [EOL] self . assertTrue ( stack . is_empty ( ) ) [EOL] [EOL] stack . push ( [number] ) [EOL] self . assertFalse ( stack . is_empty ( ) ) [EOL] [EOL] self . assertEqual ( stack . top ( ) , [number] ) [EOL] [EOL] stack . push ( [number] ) [EOL] [EOL] self . assertEqual ( stack . top ( ) , [number] ) [EOL] [EOL] stack . pop ( ) [EOL] [EOL] self . assertEqual ( stack . top ( ) , [number] ) [EOL] [EOL] stack . pop ( ) [EOL] [EOL] self . assertEqual ( stack . top ( ) , None ) [EOL] [EOL] stack . pop ( ) [EOL] [EOL] self . assertEqual ( stack . top ( ) , None ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import builtins [EOL] import socket [EOL] from typing import Optional [EOL] [EOL] [EOL] class Connection ( ) : [EOL] [EOL] def __init__ ( self , p_server_ip , p_server_port ) : [EOL] self . __socket = None [EOL] [EOL] try : [EOL] self . __socket = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] self . __socket . setblocking ( False ) [EOL] self . __socket . connect_ex ( ( p_server_ip , p_server_port ) ) [EOL] except Exception : [EOL] pass [EOL] [EOL] def receive ( self ) : [EOL] if self . __socket is None : [EOL] return None [EOL] [EOL] line = [string] [EOL] while True : [EOL] try : [EOL] part = self . __socket . recv ( [number] ) [EOL] if not part : [EOL] break [EOL] [EOL] if part != [string] : [EOL] line += part [EOL] elif part == [string] : [EOL] break [EOL] except BlockingIOError : [EOL] continue [EOL] except Exception : [EOL] return None [EOL] return line . decode ( [string] ) [EOL] [EOL] def send ( self , p_message ) : [EOL] if self . __socket is None : [EOL] return [EOL] [EOL] try : [EOL] self . __socket . sendall ( p_message . encode ( [string] ) ) [EOL] except Exception : [EOL] pass [EOL] [EOL] def close ( self ) : [EOL] if self . __socket is not None : [EOL] try : [EOL] self . __socket . close ( ) [EOL] except Exception : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from client import Client [EOL] from time import sleep [EOL] [EOL] [EOL] class MyClient ( Client ) : [EOL] messages = [ ] [EOL] [EOL] def process_message ( self , p_message ) : [EOL] if p_message is not None : [EOL] MyClient . messages . append ( p_message ) [EOL] [EOL] [EOL] class TestClient ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . client = MyClient ( [string] , [number] ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . client . close ( ) [EOL] [EOL] def test_client ( self ) : [EOL] sleep ( [number] ) [EOL] self . assertTrue ( self . client . is_connected ( ) ) [EOL] self . client . send ( [string] ) [EOL] self . client . send ( [string] ) [EOL] self . client . send ( [string] ) [EOL] self . client . send ( [string] ) [EOL] self . assertTrue ( self . client . is_connected ( ) ) [EOL] sleep ( [number] ) [EOL] self . assertEqual ( [string] , MyClient . messages [ [number] ] ) [EOL] self . assertEqual ( [string] , MyClient . messages [ [number] ] ) [EOL] self . assertEqual ( [string] , MyClient . messages [ [number] ] ) [EOL] self . assertEqual ( [string] , MyClient . messages [ [number] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import threading [EOL] import queue [EOL] import socket [EOL] import builtins [EOL] import socket [EOL] import errno [EOL] from queue import Queue , Empty [EOL] from typing import Optional [EOL] from abc import ABC , abstractmethod [EOL] from threading import Thread [EOL] [EOL] [EOL] class Client ( ABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , p_ip , p_port ) : [EOL] super ( ) . __init__ ( ) [EOL] self . __socket = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] self . __socket . connect ( ( p_ip , p_port ) ) [EOL] self . __socket . setblocking ( False ) [EOL] self . __send_buffer = Queue ( ) [EOL] self . __receive_buffer = Queue ( ) [EOL] self . __message_buffer = [string] [EOL] self . __active = True [EOL] [EOL] t = Thread ( target = self . __run ) [EOL] t . start ( ) [EOL] [EOL] def __receive_to_buffer ( self ) : [EOL] try : [EOL] message_part = self . __socket . recv ( [number] ) [EOL] if message_part == [string] : [EOL] self . __receive_buffer . put ( self . __message_buffer ) [EOL] self . __message_buffer = [string] [EOL] else : [EOL] self . __message_buffer += message_part [EOL] except Exception : [EOL] pass [EOL] [EOL] def __send_from_buffer ( self ) : [EOL] try : [EOL] message = self . __send_buffer . get ( block = False ) [EOL] if message is not None : [EOL] try : [EOL] print ( f" [string] { message }" ) [EOL] self . __socket . sendall ( message ) [EOL] except Exception : [EOL] self . __send_buffer . put ( message ) [EOL] except Empty : [EOL] pass [EOL] [EOL] def __run ( self ) : [EOL] while self . __active : [EOL] try : [EOL] [comment] [EOL] self . __send_from_buffer ( ) [EOL] [EOL] [comment] [EOL] self . __receive_to_buffer ( ) [EOL] [EOL] try : [EOL] message = self . __receive_buffer . get ( block = False ) [EOL] if not message : [EOL] self . close ( ) [EOL] print ( [string] ) [EOL] [EOL] print ( f" [string] { message }" ) [EOL] self . process_message ( message . decode ( [string] ) ) [EOL] except Empty : [EOL] pass [EOL] except IOError as e : [EOL] if e . errno != errno . EAGAIN and e . errno != errno . EWOULDBLOCK : [EOL] self . __active = False [EOL] print ( [string] ) [EOL] [EOL] def close ( self ) : [EOL] try : [EOL] self . __active = False [EOL] self . __socket . close ( ) [EOL] except Exception : [EOL] self . __active = False [EOL] [EOL] def is_connected ( self ) : [EOL] return self . __active [EOL] [EOL] def send ( self , p_message ) : [EOL] self . __send_buffer . put ( p_message . encode ( [string] ) ) [EOL] [EOL] @ abstractmethod def process_message ( self , p_message ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 $queue.Queue[builtins.bytes]$ 0 0 0 0 0 0 0 $queue.Queue[builtins.bytes]$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import threading [EOL] import socket [EOL] import queue [EOL] import builtins [EOL] import socket [EOL] from typing import Optional , Dict [EOL] from abc import ABC , abstractmethod [EOL] from threading import Thread [EOL] import select [EOL] from queue import Queue , Empty [EOL] [EOL] [EOL] class Server ( ABC ) : [EOL] [EOL] class ClientHandler ( ) : [EOL] def __init__ ( self , socket , p_ip , p_port ) : [EOL] self . __socket = socket [EOL] self . __ip = p_ip [EOL] self . __port = p_port [EOL] self . __send_buffer = Queue ( ) [EOL] [EOL] @ property def ip ( self ) : [EOL] return self . __ip [EOL] [EOL] @ property def port ( self ) : [EOL] return self . __port [EOL] [EOL] def close ( self ) : [EOL] try : [EOL] self . __socket . close ( ) [EOL] except Exception : [EOL] pass [EOL] [EOL] def receive ( self ) : [EOL] message = [string] [EOL] while True : [EOL] try : [EOL] message_part = self . __socket . recv ( [number] ) [EOL] if message_part == [string] or message_part == [string] : [EOL] return message . decode ( [string] ) [EOL] else : [EOL] message += message_part [EOL] except Exception as e : [EOL] return None [EOL] [EOL] def send ( self , p_message ) : [EOL] print ( f" [string] { self . ip } [string] { self . port } [string] { p_message }" ) [EOL] self . __send_buffer . put ( p_message . encode ( [string] ) ) [EOL] [EOL] def send_from_buffer ( self ) : [EOL] try : [EOL] message = self . __send_buffer . get ( block = False ) [EOL] if message is not None : [EOL] try : [EOL] self . __socket . sendall ( message + [string] ) [EOL] except Exception as e : [EOL] self . __send_buffer . put ( message ) [EOL] except Empty : [EOL] pass [EOL] [EOL] def __init__ ( self , p_port ) : [EOL] super ( ) . __init__ ( ) [EOL] self . __socket = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] self . __socket . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] self . __socket . bind ( ( [string] , p_port ) ) [EOL] self . __socket . listen ( ) [EOL] self . __active = True [EOL] self . __clients = { } [EOL] [EOL] self . __t = Thread ( target = self . __run ) [EOL] self . __t . start ( ) [EOL] [EOL] def __run ( self ) : [EOL] while self . __active : [EOL] sockets = [ self . __socket ] + list ( self . __clients . keys ( ) ) [EOL] read_sockets , _ , exception_sockets = select . select ( sockets , [ ] , sockets ) [EOL] [EOL] for notified_socket in read_sockets : [EOL] if notified_socket == self . __socket : [EOL] [EOL] client_socket , client_address = self . __socket . accept ( ) [EOL] [EOL] self . __clients [ client_socket ] = Server . ClientHandler ( client_socket , client_address [ [number] ] , client_address [ [number] ] ) [EOL] self . process_new_connection ( client_address [ [number] ] , client_address [ [number] ] ) [EOL] print ( f" [string] { client_address [ [number] ] } [string] { client_address [ [number] ] }" ) [EOL] [EOL] else : [EOL] client = self . __clients [ notified_socket ] [EOL] [EOL] client . send_from_buffer ( ) [EOL] [EOL] message = client . receive ( ) [EOL] if not message : [EOL] del self . __clients [ notified_socket ] [EOL] client . close ( ) [EOL] continue [EOL] [EOL] self . process_message ( client_address [ [number] ] , client_address [ [number] ] , message ) [EOL] print ( f" [string] { client_address [ [number] ] } [string] { message }" ) [EOL] [EOL] for notified_socket in exception_sockets : [EOL] del self . __clients [ notified_socket ] [EOL] [EOL] def close ( self ) : [EOL] print ( [string] ) [EOL] self . __active = False [EOL] [EOL] for client_handler in self . __clients . values ( ) : [EOL] self . process_closing_connection ( client_handler . ip , client_handler . port ) [EOL] client_handler . close ( ) [EOL] [EOL] try : [EOL] self . __socket . close ( ) [EOL] except Exception : [EOL] pass [EOL] [EOL] def is_open ( self ) : [EOL] return self . __active [EOL] [EOL] def is_connected_to ( self , p_client_ip , p_client_port ) : [EOL] return self . __find_client_handler ( p_client_ip , p_client_port ) is not None [EOL] [EOL] def send ( self , p_client_ip , p_client_port , p_message ) : [EOL] client_handler = self . __find_client_handler ( p_client_ip , p_client_port ) [EOL] client_handler . send ( p_message ) [EOL] [EOL] def send_to_all ( self , p_message ) : [EOL] for client_handler in self . __clients . values ( ) : [EOL] client_handler . send ( p_message ) [EOL] [EOL] def close_connection ( self , p_client_ip , p_client_port ) : [EOL] client_handler = self . __find_client_handler ( p_client_ip , p_client_port ) [EOL] client_handler . close ( ) [EOL] [EOL] @ abstractmethod def process_message ( self , p_client_ip , p_client_port , process_message ) : [EOL] pass [EOL] [EOL] @ abstractmethod def process_new_connection ( self , p_client_ip , p_client_port ) : [EOL] pass [EOL] [EOL] @ abstractmethod def process_closing_connection ( self , p_client_ip , p_client_port ) : [EOL] pass [EOL] [EOL] def __find_client_handler ( self , p_client_ip , p_client_port ) : [EOL] for client_handler in self . __clients . values ( ) : [EOL] if client_handler . ip == p_client_ip and client_handler . port == p_client_port : [EOL] return client_handler [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.Queue[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[socket.socket,'Server.ClientHandler']$ 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[socket.socket]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[socket.socket]$ 0 0 0 0 $typing.List[socket.socket]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] [EOL] [EOL] async def handle_echo ( reader , writer ) : [EOL] while True : [EOL] data = await reader . readline ( ) [EOL] if not data : [EOL] continue [EOL] message = data . decode ( ) [EOL] addr = writer . get_extra_info ( [string] ) [EOL] [EOL] print ( f" [string] { message !r} [string] { addr !r}" ) [EOL] [EOL] print ( f" [string] { message !r}" ) [EOL] writer . write ( data ) [EOL] await writer . drain ( ) [EOL] [EOL] print ( [string] ) [EOL] writer . close ( ) [EOL] [EOL] [EOL] async def main ( ) : [EOL] server = await asyncio . start_server ( handle_echo , [string] , [number] ) [EOL] [EOL] addr = server . sockets [ [number] ] . getsockname ( ) [EOL] print ( f' [string] { addr }' ) [EOL] [EOL] async with server : [EOL] await server . serve_forever ( ) [EOL] [EOL] if __name__ == [string] : [EOL] asyncio . run ( main ( ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] from connection import Connection [EOL] from time import sleep [EOL] import random [EOL] import string [EOL] [EOL] [EOL] def randomString ( stringLength = [number] ) : [EOL] [docstring] [EOL] letters = string . ascii_lowercase [EOL] return [string] . join ( random . choice ( letters ) for i in range ( stringLength ) ) [EOL] [EOL] [EOL] class TestConnection ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . connection = Connection ( [string] , [number] ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . connection . close ( ) [EOL] [EOL] def test ( self ) : [EOL] [EOL] s = randomString ( [number] ) [EOL] s += [string] [EOL] self . connection . send ( s ) [EOL] sleep ( [number] ) [EOL] r = self . connection . receive ( ) [EOL] self . assertEqual ( r + [string] , s ) [EOL] [EOL] def test_umlate ( self ) : [EOL] s = [string] [EOL] self . connection . send ( s ) [EOL] sleep ( [number] ) [EOL] r = self . connection . receive ( ) [EOL] self . assertEqual ( r + [string] , s ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from time import sleep [EOL] from server import Server [EOL] from client import Client [EOL] [EOL] [EOL] class MyServer ( Server ) : [EOL] [EOL] messages = [ ] [EOL] [EOL] def process_new_connection ( self , p_client_ip , p_client_port ) : [EOL] self . send ( p_client_ip , p_client_port , [string] ) [EOL] [EOL] def process_message ( self , p_client_ip , p_client_port , p_message ) : [EOL] print ( p_message ) [EOL] MyServer . messages . append ( p_message ) [EOL] self . send ( p_client_ip , p_client_port , p_message ) [EOL] [EOL] def process_closing_connection ( self , p_client_ip , p_client_port ) : [EOL] self . send ( p_client_ip , p_client_port , [string] ) [EOL] [EOL] [EOL] class MyClient ( Client ) : [EOL] messages = [ ] [EOL] [EOL] def process_message ( self , p_message ) : [EOL] MyClient . messages . append ( p_message ) [EOL] [EOL] [EOL] class TestServer ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . server = MyServer ( [number] ) [EOL] sleep ( [number] ) [EOL] self . client = MyClient ( [string] , [number] ) [EOL] sleep ( [number] ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . server . close ( ) [EOL] self . client . close ( ) [EOL] [EOL] def test ( self ) : [EOL] self . assertTrue ( self . server . is_open ( ) ) [EOL] self . assertTrue ( self . client . is_connected ( ) ) [EOL] self . assertEqual ( MyClient . messages [ [number] ] , [string] ) [EOL] self . assertTrue ( self . client . is_connected ( ) ) [EOL] self . client . send ( [string] ) [EOL] self . client . send ( [string] ) [EOL] [EOL] sleep ( [number] ) [EOL] self . assertEqual ( MyServer . messages [ [number] ] , [string] ) [EOL] self . assertEqual ( MyServer . messages [ [number] ] , [string] ) [EOL] [comment] [EOL] sleep ( [number] ) [EOL] self . assertEqual ( MyClient . messages [ [number] ] , [string] ) [EOL] self . assertEqual ( MyClient . messages [ [number] ] , [string] ) [EOL] self . server . close ( ) [EOL] sleep ( [number] ) [EOL] self . assertEqual ( MyClient . messages [ [number] ] , [string] ) [EOL] self . client . close ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] class QueryResult ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , p_data , p_column_names , p_column_types ) : [EOL] self . __data = p_data [EOL] self . __column_names = p_column_names [EOL] self . __column_types = p_column_types [EOL] [EOL] def get_data ( self ) : [EOL] [docstring] [EOL] return self . __data [EOL] [EOL] def get_column_names ( self ) : [EOL] [docstring] [EOL] return self . __column_names [EOL] [EOL] def get_column_types ( self ) : [EOL] [docstring] [EOL] return self . __column_types [EOL] [EOL] def get_row_count ( self ) : [EOL] [docstring] [EOL] if self . __data is not None : [EOL] return len ( self . __data ) [EOL] else : [EOL] return [number] [EOL] [EOL] def get_column_count ( self ) : [EOL] [docstring] [EOL] if self . __data is not None and len ( self . __data ) > [number] and self . __data [ [number] ] is not None : [EOL] return len ( self . __data [ [number] ] ) [EOL] else : [EOL] return [number] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Tuple , Union , Any [EOL] import typing [EOL] import unittest [EOL] from database_connector import DatabaseConnector [EOL] [EOL] [EOL] class TestDatabaseConnector ( unittest . TestCase ) : [EOL] def test ( self ) : [EOL] database = DatabaseConnector ( [string] , [string] , [string] , [string] , [string] ) [EOL] database . execute_statement ( [string] ) [EOL] database . execute_statement ( [string] ) [EOL] database . execute_statement ( [string] ) [EOL] database . execute_statement ( [string] ) [EOL] [EOL] column_names = [ [string] , [string] ] [EOL] column_type = [ int , str ] [EOL] data = [ ( [number] , [string] ) ] [EOL] result = database . get_current_query_result ( ) [EOL] self . assertEqual ( result . get_column_names ( ) , column_names ) [EOL] self . assertEqual ( result . get_column_types ( ) , column_type ) [EOL] self . assertSequenceEqual ( result . get_data ( ) [ [number] ] , data [ [number] ] ) [EOL] [EOL] self . assertIsNone ( database . get_error_message ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Type[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Type[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] import pyodbc [EOL] from typing import Optional [EOL] from query_result import QueryResult [EOL] [EOL] [EOL] class DatabaseConnector ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , p_ip , p_port , p_database , p_username , p_password ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] try : [EOL] self . _connection = pyodbc . connect ( f' [string] { p_ip } [string] { p_database } [string] { p_username } [string] { p_password }' ) [EOL] except Exception as e : [EOL] self . _message = str ( e ) [EOL] [EOL] def execute_statement ( self , p_sql_statement ) : [EOL] [docstring] [EOL] self . _current_query_result = None [EOL] self . _message = None [EOL] [EOL] if self . _connection is None : [EOL] self . __message = [string] [EOL] return [EOL] [EOL] try : [EOL] cursor = self . _connection . cursor ( ) [EOL] [EOL] if cursor . execute ( p_sql_statement ) : [EOL] result_column_names = [ ] [EOL] result_colum_types = [ ] [EOL] result_data = cursor . fetchall ( ) [EOL] [EOL] for column in cursor . description : [EOL] result_column_names . append ( column [ [number] ] ) [EOL] result_colum_types . append ( column [ [number] ] ) [EOL] [EOL] self . _current_query_result = QueryResult ( result_data , result_column_names , result_colum_types ) [EOL] [EOL] cursor . close ( ) [EOL] [EOL] except Exception as e : [EOL] self . _message = str ( e ) [EOL] [EOL] def get_current_query_result ( self ) : [EOL] [docstring] [EOL] return self . _current_query_result [EOL] [EOL] def get_error_message ( self ) : [EOL] [docstring] [EOL] return self . _message [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _connection . close ( ) [EOL] except Exception as e : [EOL] self . _message = str ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0