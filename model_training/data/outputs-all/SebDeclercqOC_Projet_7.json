[comment] [EOL] import app [EOL] import builtins [EOL] [docstring] [EOL] import click [EOL] from app import app [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , prompt = [string] , help = [string] ) def grandpy ( query ) : [EOL] [docstring] [EOL] try : [EOL] my_app = app . App ( ) [EOL] click . echo ( my_app . search ( query ) ) [EOL] except Exception as e : [EOL] click . echo ( f' [string] { e } [string] ' ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] grandpy ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import website [EOL] import flask [EOL] [docstring] [EOL] from flask import Flask [EOL] from website import website [EOL] [EOL] [EOL] def create_app ( ) : [EOL] [docstring] [EOL] site = website . Website ( ) [EOL] return site . app [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] create_app ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Optional , List [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] import app [EOL] import flask_bootstrap [EOL] [docstring] [EOL] from typing import List , Optional [EOL] import html [EOL] import random [EOL] import os [EOL] from flask import Flask , jsonify , Response , render_template , request [EOL] from flask_bootstrap import Bootstrap [EOL] from app import app [EOL] from dataclasses import asdict [EOL] [EOL] [EOL] class Website : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . app = Flask ( __name__ ) [EOL] self . bootstrap = Bootstrap ( self . app ) [EOL] self . wrong_query_answers_file = [string] [EOL] self . _get_wrong_query_answers ( ) [EOL] self . _define_routes ( ) [EOL] self . grandpy = app . App ( ) [EOL] [EOL] def _get_wrong_query_answers ( self ) : [EOL] file = os . path . join ( os . path . dirname ( __file__ ) , self . wrong_query_answers_file ) [EOL] with open ( file , encoding = [string] ) as answers : [EOL] self . wrong_query_answers = answers . readlines ( ) [EOL] return self . wrong_query_answers [EOL] [EOL] def _define_routes ( self ) : [EOL] [docstring] [EOL] @ self . app . route ( [string] , methods = [ [string] ] ) def index ( ) : [EOL] return render_template ( [string] , google_public_api_key = os . environ . get ( [string] ) ) [EOL] [EOL] @ self . app . route ( [string] , methods = [ [string] ] ) def ask_grandpy ( ) : [EOL] query = request . form [ [string] ] [EOL] app_resp = self . grandpy . search ( query ) [EOL] if app_resp : [EOL] app_resp . summary = html . escape ( app_resp . summary , quote = False ) [EOL] app_resp . title = html . escape ( app_resp . title , quote = False ) [EOL] return jsonify ( asdict ( app_resp ) ) , [number] [EOL] else : [EOL] answer = random . choice ( self . wrong_query_answers ) . rstrip ( ) [EOL] return jsonify ( { [string] : html . escape ( answer , quote = False ) } ) , [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List , Dict , Optional [EOL] import builtins [EOL] import googlemaps [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] from typing import Any , Dict , List , Optional [EOL] import googlemaps [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass class Position : [EOL] [docstring] [EOL] latitude = ... [EOL] longitude = ... [EOL] [EOL] [EOL] class GoogleMaps : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . client = googlemaps . Client ( key = os . environ . get ( [string] ) ) [EOL] [EOL] def geocode ( self , query ) : [comment] [EOL] [docstring] [EOL] result = self . client . geocode ( query ) [EOL] if result : [EOL] position = result [ [number] ] [ [string] ] [ [string] ] [EOL] return Position ( position [ [string] ] , position [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import List [EOL] import app [EOL] import builtins [EOL] import mediawiki [EOL] import typing [EOL] [docstring] [EOL] from typing import List , Optional [EOL] import mediawiki [EOL] from app import google_maps [EOL] [EOL] [EOL] class Wikipedia : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . client = mediawiki . MediaWiki ( lang = [string] ) [EOL] [EOL] def geosearch ( self , position ) : [EOL] [docstring] [EOL] return self . client . geosearch ( str ( position . latitude ) , str ( position . longitude ) , results = [number] ) [EOL] [EOL] def page_search ( self , title ) : [EOL] [docstring] [EOL] try : [EOL] page = self . client . page ( title ) [EOL] except mediawiki . exceptions . PageError : [EOL] page = None [EOL] return page [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $mediawiki.MediaWiki$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $app.google_maps.Position$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app.google_maps.Position$ 0 0 0 0 0 0 $app.google_maps.Position$ 0 0 0 0 0 0 0 0 0 0 0 $mediawiki.MediaWikiPage$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0
[comment] [EOL] from typing import List [EOL] import nltk [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List [EOL] import re [EOL] from nltk . stem import snowball [EOL] import requests [EOL] [EOL] [EOL] class Parser : [EOL] [docstring] [EOL] FRENCH_STOP_WORDS_DB = [string] [comment] [EOL] LOCALIZATION_VERB_STEMS = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] with requests . get ( self . FRENCH_STOP_WORDS_DB ) as stop_words_db : [EOL] self . stop_words = stop_words_db . json ( ) [EOL] self . stop_words . extend ( [ [string] , [string] ] ) [EOL] self . stemmer = snowball . FrenchStemmer ( ) [EOL] [EOL] def split_words ( self , sentence ) : [comment] [EOL] [docstring] [EOL] list_of_words = re . split ( [string] , sentence . lower ( ) ) [EOL] return [ s for s in list_of_words if s ] [EOL] [EOL] def remove_stop_words ( self , list_of_words ) : [EOL] [docstring] [EOL] return [ s for s in list_of_words if s not in self . stop_words ] [EOL] [EOL] def clean_sentence ( self , sentence ) : [EOL] [docstring] [EOL] list_of_words = self . split_words ( sentence ) [EOL] return [string] . join ( self . remove_stop_words ( list_of_words ) ) [EOL] [EOL] def find_useful_info ( self , sentence ) : [EOL] [docstring] [EOL] search_sentence = [string] [EOL] tokens = sentence . split ( ) [EOL] for token in tokens : [EOL] stem = self . stemmer . stem ( token ) [EOL] if stem in self . LOCALIZATION_VERB_STEMS : [EOL] idx = tokens . index ( token ) [EOL] search_sentence = [string] . join ( tokens [ idx + [number] : ] ) [EOL] break [EOL] if not search_sentence : [EOL] search_sentence = sentence [EOL] return search_sentence [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $nltk.stem.snowball.FrenchStemmer$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0
	0
	0
[comment] [EOL] from typing import Tuple , Any , Dict , Sequence [EOL] import typing [EOL] import website [EOL] import flask [EOL] import builtins [EOL] [docstring] [EOL] from typing import Any , Dict , Sequence , Tuple [EOL] import json [EOL] import pytest [EOL] from flask import Response , testing [EOL] from website import website [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def client ( ) : [EOL] [docstring] [EOL] test_website = website . Website ( ) [EOL] with test_website . app . app_context ( ) : [EOL] yield test_website . app . test_client ( ) [EOL] [EOL] [EOL] class Params : [EOL] searches = ( ( [string] , [number] , { [string] : [string] , [string] : { [string] : [number] , [string] : [number] } , [string] : [string] , [string] : [string] } ) , ( [string] , [number] , { [string] : [string] , [string] : { [string] : [number] , [string] : [number] } , [string] : [string] , [string] : [string] } ) , ( [string] , [number] , { [string] : [string] } ) , ) [EOL] [EOL] [EOL] class TestWebsite : [EOL] @ pytest . mark . parametrize ( [string] , Params . searches ) def test_ask_grandpy ( self , query , expected_code , dict_resp , client ) : [EOL] [docstring] [EOL] r = client . post ( [string] , data = { [string] : query } ) [EOL] assert r . status_code == expected_code [EOL] r_content = r . get_json ( ) [EOL] if r . status_code == [number] : [EOL] r_content [ [string] ] = r_content [ [string] ] [ : [number] ] [EOL] assert dict_resp == r_content [EOL] else : [EOL] assert [string] in r_content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Tuple[builtins.str,builtins.int,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $flask.testing.FlaskClient$ 0 0 0 0 0 $flask.Response$ 0 $flask.testing.FlaskClient$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $flask.Response$ 0 0 0 $builtins.int$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $flask.Response$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0
	0
[comment] [EOL] from typing import Tuple , List , Any , Optional , Sequence [EOL] import unittest [EOL] import typing [EOL] import app [EOL] import builtins [EOL] [docstring] [EOL] from typing import Any , List , Optional , Sequence , Tuple [EOL] from unittest import mock [EOL] import mediawiki [EOL] import pytest [EOL] from app import google_maps , wikipedia [EOL] [EOL] [EOL] @ pytest . fixture def wiki ( monkeypatch ) : [EOL] [docstring] [EOL] wiki_mock = mock . Mock ( ) [EOL] wiki_mock . return_value = None [EOL] monkeypatch . setattr ( [string] , wiki_mock ) [EOL] return wikipedia . Wikipedia ( ) [EOL] [EOL] [EOL] class Params : [EOL] [docstring] [EOL] geosearch = ( ( google_maps . Position ( [number] , [number] ) , [ [string] , [string] , [string] , ] ) , ( google_maps . Position ( [number] , [number] ) , [ [string] , [string] , [string] , ] ) , ( google_maps . Position ( [number] , [number] ) , [ [string] , [string] ] ) , ( google_maps . Position ( [number] , [number] ) , [ [string] , [string] , [string] ] ) , ( google_maps . Position ( [number] , [number] ) , [ [string] , [string] , [string] [string] ] ) , ( google_maps . Position ( [number] , [number] ) , [ ] ) , ) [EOL] page_search = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , None ) , ) [EOL] [EOL] [EOL] class TestWikipedia : [EOL] [docstring] [EOL] @ pytest . mark . parametrize ( [string] , Params . geosearch ) def test_wikipedia_geosearch ( self , position , expected_list , wiki , monkeypatch ) : [EOL] [docstring] [EOL] geosearch_mock = mock . Mock ( ) [EOL] geosearch_mock . return_value = expected_list [EOL] monkeypatch . setattr ( [string] , geosearch_mock ) [EOL] list_results = wiki . geosearch ( position ) [EOL] assert list_results == expected_list [EOL] [EOL] @ pytest . mark . parametrize ( [string] , Params . page_search ) def test_wikipedia_get_page ( self , title , summary_50_char , wiki , monkeypatch ) : [EOL] [docstring] [EOL] page_mock = mock . Mock ( ) [EOL] page_mock . return_value = None [EOL] [comment] [EOL] monkeypatch . setattr ( [string] , page_mock ) [EOL] page_search_mock = mock . Mock ( ) [EOL] if summary_50_char is not None : [EOL] [comment] [EOL] summary_mock = mock . PropertyMock ( ) [EOL] summary_mock . return_value = summary_50_char [EOL] monkeypatch . setattr ( [string] , summary_mock ) [EOL] page_search_mock . return_value = mediawiki . MediaWikiPage ( ) [EOL] else : [EOL] page_search_mock . return_value = None [EOL] [comment] [EOL] monkeypatch . setattr ( [string] , page_search_mock ) [EOL] page = wiki . page_search ( title ) [EOL] if summary_50_char is not None : [EOL] assert isinstance ( page , mediawiki . MediaWikiPage ) [EOL] assert page . summary [ : [number] ] == summary_50_char [EOL] else : [EOL] assert page is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.PropertyMock$ 0 0 0 0 0 0 0 $unittest.mock.PropertyMock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.PropertyMock$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] import website [EOL] import flask [EOL] [docstring] [EOL] import pytest [EOL] from flask import Response , testing [EOL] from website import website [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def client ( ) : [EOL] [docstring] [EOL] test_website = website . Website ( ) [EOL] with test_website . app . app_context ( ) : [EOL] yield test_website . app . test_client ( ) [EOL] [EOL] [EOL] class TestWebsite : [EOL] [docstring] [EOL] def test_index ( self , client ) : [EOL] [docstring] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . headers [ [string] ] == [string] [EOL] text_excerpt = [string] [EOL] assert text_excerpt in r . get_data ( ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $flask.testing.FlaskClient$ 0 0 0 0 0 $flask.Response$ 0 $flask.testing.FlaskClient$ 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , Tuple , Any , Sequence [EOL] import unittest [EOL] import typing [EOL] import app [EOL] import builtins [EOL] [docstring] [EOL] from typing import Any , Optional , Sequence , Tuple [EOL] from unittest import mock [EOL] import pytest [EOL] from app import google_maps [EOL] [EOL] [EOL] class Params : [EOL] [docstring] [EOL] api_queries_and_results = ( ( [string] , ( [number] , [number] ) ) , ( [string] , ( [number] , [number] ) ) , ( [string] , ( [number] , [number] ) ) , ( [string] , ( [number] , [number] ) ) , ( [string] , ( [number] , [number] ) ) , ( [string] , None ) , ) [EOL] [EOL] [EOL] class TestGoogleMaps : [EOL] [docstring] [EOL] @ pytest . mark . parametrize ( [string] , Params . api_queries_and_results ) def test_search_geocode ( self , search_terms , position , monkeypatch ) : [EOL] [docstring] [EOL] client_mock = mock . Mock ( ) [EOL] client_mock . return_value = None [EOL] monkeypatch . setattr ( [string] , client_mock ) [EOL] api_mock = mock . Mock ( ) [EOL] if position is not None : [EOL] api_mock . return_value = [ { [string] : { [string] : { [string] : position [ [number] ] , [string] : position [ [number] ] } } } ] [EOL] else : [EOL] api_mock . return_value = None [EOL] monkeypatch . setattr ( [string] , api_mock ) [EOL] googlemaps = google_maps . GoogleMaps ( ) [EOL] result = googlemaps . geocode ( search_terms ) [EOL] if position is not None : [EOL] assert isinstance ( result , google_maps . Position ) [EOL] assert result == google_maps . Position ( * position ) [EOL] else : [EOL] assert result is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Tuple[builtins.str,typing.Optional[typing.Tuple[builtins.float,builtins.float]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float]]$ 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float]]$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float]]$ 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 $app.google_maps.GoogleMaps$ 0 0 0 0 0 0 0 $typing.Optional[app.google_maps.Position]$ 0 $app.google_maps.GoogleMaps$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float]]$ 0 0 0 0 0 0 0 0 $typing.Optional[app.google_maps.Position]$ 0 0 0 0 0 0 0 $typing.Optional[app.google_maps.Position]$ 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.float,builtins.float]]$ 0 0 0 0 0 0 $typing.Optional[app.google_maps.Position]$ 0 0 0