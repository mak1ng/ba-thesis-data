[docstring] [EOL] [EOL] import setuptools [EOL] import os [EOL] import sphinx . setup_command [EOL] [EOL] [comment] [EOL] PROJECT_AUTHOR = [string] [EOL] PROJECT_AUTHOR_EMAIL = [string] [EOL] PROJECT_COPYRIGHT = [string] . format ( PROJECT_AUTHOR ) [EOL] PROJECT_VERSION = [string] [EOL] [EOL] [EOL] def read_long_description ( ) : [EOL] [docstring] [EOL] path = os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , [string] ) [EOL] with open ( path , encoding = [string] ) as input_file : [EOL] text = input_file . read ( ) [EOL] return text [EOL] [EOL] [EOL] setuptools . setup ( author = PROJECT_AUTHOR , author_email = PROJECT_AUTHOR_EMAIL , classifiers = [ [string] , [string] , [string] , [string] , [string] , ] , cmdclass = { [string] : sphinx . setup_command . BuildDoc , } , command_options = { [string] : { [string] : ( [string] , PROJECT_COPYRIGHT ) , [string] : ( [string] , True ) , [string] : ( [string] , [string] ) , [string] : ( [string] , PROJECT_VERSION ) , [string] : ( [string] , PROJECT_VERSION ) , [string] : ( [string] , True ) , } , } , data_files = [ ] , description = [string] , entry_points = { [string] : [ [string] ] } , extras_require = { } , include_package_data = True , install_requires = [ [string] , ] , keywords = [string] , license = [string] , long_description = read_long_description ( ) , name = [string] , packages = [ [string] , ] , package_data = { } , setup_requires = [ [string] , [string] , ] , tests_require = [ [string] , [string] , [string] , [string] , [string] , ] , test_suite = [string] , url = [string] , version = PROJECT_VERSION , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Dict , Tuple , List , Any [EOL] import typing [EOL] author = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ ] [EOL] [EOL] [comment] [EOL] pygments_style = None [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] nitpick_ignore = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] autodoc_default_options = { [string] : None , [string] : None , } [EOL] [EOL] [comment] [EOL] autoclass_content = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Type , BinaryIO , Callable , Any , Tuple , Dict [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import rudi_dire_insp [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import collections [EOL] import enum [EOL] import hashlib [EOL] import logging [EOL] import typing [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import rudi_dire_insp . exceptions as my_exceptions [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] Hashes = collections . namedtuple ( [string] , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] class _HashAlgorithm ( enum . Enum ) : [EOL] [docstring] [EOL] [EOL] MD5 = ( [number] , lambda : hashlib . md5 ( ) ) [EOL] [docstring] [EOL] [EOL] SHA1 = ( [number] , lambda : hashlib . sha1 ( ) ) [EOL] [docstring] [EOL] [EOL] SHA256 = ( [number] , lambda : hashlib . sha256 ( ) ) [EOL] [docstring] [EOL] [EOL] SHA384 = ( [number] , lambda : hashlib . sha384 ( ) ) [EOL] [docstring] [EOL] [EOL] SHA512 = ( [number] , lambda : hashlib . sha512 ( ) ) [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ordinal , digest_constructor ) : [EOL] [docstring] [EOL] [EOL] self . _ordinal = ordinal [EOL] self . _digest_constructor = digest_constructor [EOL] [EOL] def _new_digest ( self ) : [EOL] [docstring] [EOL] digest = self . _digest_constructor ( ) [EOL] return digest [EOL] [EOL] @ staticmethod def calculate_hashes ( stream ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [comment] [EOL] digests = { } [EOL] for digest_enum in _HashAlgorithm : [EOL] [comment] [EOL] digests [ digest_enum ] = digest_enum . _new_digest ( ) [EOL] [EOL] [comment] [EOL] num_read = [number] [EOL] try : [EOL] while True : [EOL] buffer = stream . read ( ) [EOL] if buffer : [EOL] num_read += len ( buffer ) [EOL] for digest in digests . values ( ) : [EOL] digest . update ( buffer ) [EOL] else : [EOL] break [EOL] except Exception as error : [EOL] raise my_exceptions . HashError ( [string] ) from error [EOL] [EOL] [comment] [EOL] hashes_params = { } [EOL] for digest_enum , digest in digests . items ( ) : [EOL] hashes_params [ digest_enum . name . lower ( ) ] = digest . hexdigest ( ) [EOL] hashes = Hashes ( ** hashes_params ) [EOL] [EOL] if _LOGGER . isEnabledFor ( logging . DEBUG ) : [EOL] _LOGGER . debug ( [string] , str ( hashes ) ) [EOL] _LOGGER . debug ( [string] , num_read ) [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] return hashes , num_read [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Callable$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[Hashes,builtins.int]$ 0 $typing.BinaryIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $typing.BinaryIO$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rudi_dire_insp.hashing.Hashes$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rudi_dire_insp.hashing.Hashes$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $rudi_dire_insp.hashing.Hashes$ 0 $builtins.int$ 0
from typing import Union , BinaryIO , Any , TextIO , Dict [EOL] import typing [EOL] import argparse [EOL] import codecs [EOL] import logging [EOL] import builtins [EOL] import rudi_dire_insp [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import argparse [EOL] import codecs [EOL] import json [EOL] import logging [EOL] import sys [EOL] import typing [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import rudi_dire_insp . core as my_core [EOL] import rudi_dire_insp . manifests as my_manifests [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] _DEFAULT_LOG_LEVEL = logging . WARNING [EOL] _LOGGING_STREAM = sys . stderr [EOL] [EOL] [EOL] def _parse_cli_args ( ) : [EOL] [docstring] [EOL] [comment] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] [comment] [EOL] log_level_group = parser . add_mutually_exclusive_group ( ) [EOL] log_level_group . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] log_level_group . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] [comment] [EOL] parser . add_argument ( [string] , [string] , type = str , default = [string] , dest = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] [comment] [EOL] parsed_args = parser . parse_args ( ) [EOL] return parsed_args [EOL] [EOL] [EOL] def _convert_to_json_text ( manifest ) : [EOL] [docstring] [EOL] [comment] [EOL] data = { [string] : manifest . relative_path , [string] : manifest . raw_manifest . size , [string] : manifest . raw_manifest . hashes . _asdict ( ) , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] json_text = json . dumps ( data , sort_keys = True ) [EOL] return json_text [EOL] [EOL] [EOL] def _run_inspection ( input_path , output_buffer ) : [EOL] [docstring] [EOL] writer = codecs . getwriter ( [string] ) ( output_buffer ) [EOL] inspector = my_core . DirectoryInspector ( ) [EOL] counter = [number] [EOL] for manifest in inspector . inspect ( input_path ) : [EOL] _LOGGER . debug ( [string] , str ( manifest ) ) [EOL] json_text = _convert_to_json_text ( manifest ) [EOL] writer . write ( json_text ) [EOL] writer . write ( [string] ) [EOL] counter += [number] [EOL] _LOGGER . info ( [string] , str ( input_path ) , counter ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [comment] [EOL] parsed_args = _parse_cli_args ( ) [EOL] [EOL] [comment] [EOL] if parsed_args . debug : [EOL] log_level = logging . DEBUG [EOL] elif parsed_args . verbose : [EOL] log_level = logging . INFO [EOL] else : [EOL] log_level = None [EOL] if log_level : [EOL] logging . basicConfig ( level = log_level , stream = _LOGGING_STREAM ) [EOL] [EOL] [comment] [EOL] if parsed_args . output_path == [string] : [EOL] _run_inspection ( parsed_args . input_path , sys . stdout . buffer ) [EOL] else : [EOL] with open ( parsed_args . output_path , [string] ) as output_file : [EOL] _run_inspection ( parsed_args . input_path , output_file ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] logging . basicConfig ( level = _DEFAULT_LOG_LEVEL , stream = _LOGGING_STREAM ) [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import rudi_dire_insp [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import copy [EOL] import logging [EOL] import typing [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import rudi_dire_insp . hashing as my_hashing [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] class RawBytesManifest : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hashes , size ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _size = int ( size ) [EOL] self . _hashes = hashes [EOL] [EOL] @ property def hashes ( self ) : [EOL] [docstring] [EOL] return copy . copy ( self . _hashes ) [EOL] [EOL] @ property def size ( self ) : [EOL] [docstring] [EOL] return self . _size [EOL] [EOL] def __repr__ ( self ) : [EOL] class_name = type ( self ) . __name__ [EOL] return [string] . format ( class_name , self . _hashes , self . _size ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . __repr__ ( ) [EOL] [EOL] [EOL] [comment] [EOL] class FileManifest : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , relative_path , raw_manifest ) : [EOL] [docstring] [EOL] self . _relative_path = relative_path [EOL] [EOL] [comment] [EOL] self . _raw_manifest = raw_manifest [EOL] [EOL] @ property def relative_path ( self ) : [EOL] [docstring] [EOL] return self . _relative_path [EOL] [EOL] @ property def raw_manifest ( self ) : [EOL] [docstring] [EOL] return self . _raw_manifest [EOL] [EOL] def __repr__ ( self ) : [EOL] class_name = type ( self ) . __name__ [EOL] return [string] . format ( class_name , self . _relative_path , self . _raw_manifest ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . __repr__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rudi_dire_insp.hashing.Hashes$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $rudi_dire_insp.hashing.Hashes$ 0 $rudi_dire_insp.hashing.Hashes$ 0 0 0 0 0 $rudi_dire_insp.hashing.Hashes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 $RawBytesManifest$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 $rudi_dire_insp.manifests.RawBytesManifest$ 0 $RawBytesManifest$ 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RawBytesManifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Iterable , BinaryIO [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import rudi_dire_insp [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] import os [EOL] import typing [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import rudi_dire_insp . exceptions as my_exceptions [EOL] import rudi_dire_insp . hashing as my_hashing [EOL] import rudi_dire_insp . manifests as my_manifests [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def _raise_if_bad_root_directory ( path ) : [EOL] [docstring] [EOL] if not os . path . exists ( path ) : [EOL] raise my_exceptions . DirInspectionError ( [string] . format ( path ) ) [EOL] if not os . path . isdir ( path ) : [EOL] raise my_exceptions . DirInspectionError ( [string] . format ( path ) ) [EOL] [EOL] [EOL] [comment] [EOL] class _FileInspector : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , root_dir_path ) : [EOL] [docstring] [EOL] _raise_if_bad_root_directory ( root_dir_path ) [EOL] self . _root_dir_path = root_dir_path [EOL] self . _real_root_dir_path = os . path . realpath ( self . _root_dir_path ) [EOL] [EOL] def _raise_if_not_sub_path ( self , path ) : [EOL] [docstring] [EOL] real_path = os . path . realpath ( path ) [EOL] if not real_path . startswith ( self . _real_root_dir_path ) : [EOL] raise my_exceptions . FileInspectionError ( [string] . format ( self . _root_dir_path , path ) ) [EOL] [EOL] def _inspect_stream ( self , stream ) : [EOL] [docstring] [EOL] [comment] [EOL] ( hashes , size ) = my_hashing . _HashAlgorithm . calculate_hashes ( stream ) [EOL] manifest = my_manifests . RawBytesManifest ( hashes , size ) [EOL] [EOL] if _LOGGER . isEnabledFor ( logging . DEBUG ) : [EOL] _LOGGER . debug ( [string] , str ( manifest ) ) [EOL] return manifest [EOL] [EOL] def inspect ( self , path ) : [EOL] [docstring] [EOL] [comment] [EOL] abs_path = os . path . abspath ( path ) [EOL] if not os . path . exists ( abs_path ) : [EOL] raise my_exceptions . FileInspectionError ( [string] . format ( abs_path ) ) [EOL] if not os . path . isfile ( abs_path ) : [EOL] raise my_exceptions . FileInspectionError ( [string] . format ( abs_path ) ) [EOL] self . _raise_if_not_sub_path ( path ) [EOL] [EOL] [comment] [EOL] with open ( abs_path , [string] ) as input_file : [EOL] raw_manifest = self . _inspect_stream ( input_file ) [EOL] relative_path = os . path . relpath ( abs_path , self . _root_dir_path ) [EOL] rel_path_as_tuple = os . path . split ( relative_path ) [EOL] file_manifest = my_manifests . FileManifest ( rel_path_as_tuple , raw_manifest ) [EOL] [EOL] if _LOGGER . isEnabledFor ( logging . DEBUG ) : [EOL] _LOGGER . debug ( [string] , abs_path , str ( file_manifest ) ) [EOL] [EOL] return file_manifest [EOL] [EOL] [EOL] [comment] [EOL] class DirectoryInspector : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] def inspect ( self , path ) : [EOL] [docstring] [EOL] [comment] [EOL] _raise_if_bad_root_directory ( path ) [EOL] [EOL] [comment] [EOL] file_inspector = _FileInspector ( path ) [EOL] [EOL] [comment] [EOL] abs_path = os . path . abspath ( path ) [EOL] for dir_path , _ , file_names in os . walk ( abs_path ) : [EOL] for file_name in file_names : [EOL] file_path = os . path . join ( dir_path , file_name ) [EOL] file_manifest = file_inspector . inspect ( file_path ) [EOL] yield file_manifest [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $rudi_dire_insp.manifests.RawBytesManifest$ 0 0 0 $typing.BinaryIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.BinaryIO$ 0 0 $rudi_dire_insp.manifests.RawBytesManifest$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $rudi_dire_insp.manifests.RawBytesManifest$ 0 0 0 0 $rudi_dire_insp.manifests.RawBytesManifest$ 0 0 0 $rudi_dire_insp.manifests.FileManifest$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $rudi_dire_insp.manifests.RawBytesManifest$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $rudi_dire_insp.manifests.FileManifest$ 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $rudi_dire_insp.manifests.RawBytesManifest$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 $rudi_dire_insp.manifests.FileManifest$ 0 0 0 0 0 $rudi_dire_insp.manifests.FileManifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[rudi_dire_insp.manifests.FileManifest]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $rudi_dire_insp.core._FileInspector$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $rudi_dire_insp.manifests.FileManifest$ 0 $rudi_dire_insp.core._FileInspector$ 0 0 0 $builtins.str$ 0 0 0 $rudi_dire_insp.manifests.FileManifest$ 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] [EOL] class RudiDireInspException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class DirInspectionError ( RudiDireInspException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class FileInspectionError ( RudiDireInspException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HashError ( RudiDireInspException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import pytest [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
	0
import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import pytest [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import io [EOL] import logging [EOL] import hashlib [EOL] import builtins [EOL] import rudi_dire_insp [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import hashlib [EOL] import io [EOL] import logging [EOL] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [comment] [EOL] import rudi_dire_insp . exceptions as my_exceptions [EOL] import rudi_dire_insp . hashing as my_hashing [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] pytestmark = pytest . mark . unit [EOL] [EOL] [EOL] def test_digest_error ( ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] test_stream = [string] [EOL] [EOL] with pytest . raises ( my_exceptions . HashError ) : [EOL] my_hashing . _HashAlgorithm . calculate_hashes ( test_stream ) [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] def _calculate_hash_hex ( algorithm_name , data ) : [EOL] [docstring] [EOL] [EOL] digest = hashlib . new ( algorithm_name ) [EOL] digest . update ( data ) [EOL] return digest . hexdigest ( ) [EOL] [EOL] [EOL] def test_which_algorithm ( ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [comment] [EOL] test_data = [string] [EOL] expected_hashes_kwargs = { algorithm_name : _calculate_hash_hex ( algorithm_name , test_data ) for algorithm_name in [ [string] , [string] , [string] , [string] , [string] ] } [EOL] expected_hashes = my_hashing . Hashes ( ** expected_hashes_kwargs ) [EOL] expected_size = len ( test_data ) [EOL] [EOL] [comment] [EOL] test_stream = io . BytesIO ( test_data ) [EOL] ( hashes , size ) = my_hashing . _HashAlgorithm . calculate_hashes ( test_stream ) [EOL] [EOL] [comment] [EOL] assert expected_hashes == hashes [EOL] assert expected_size == size [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import rudi_dire_insp [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import hashlib [EOL] import io [EOL] import logging [EOL] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [comment] [EOL] import rudi_dire_insp . exceptions as my_exceptions [EOL] import rudi_dire_insp . core as my_core [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] pytestmark = pytest . mark . unit [EOL] [EOL] [EOL] def test_w_missing_root_dir ( tmp_path ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] root_dir_path = tmp_path / [string] [EOL] [EOL] with pytest . raises ( my_exceptions . DirInspectionError ) as error_1 : [EOL] my_core . _FileInspector ( str ( root_dir_path ) ) [EOL] assert [string] in str ( error_1 ) [EOL] [EOL] dir_inspector = my_core . DirectoryInspector ( ) [EOL] with pytest . raises ( my_exceptions . DirInspectionError ) as error_2 : [EOL] for _ in dir_inspector . inspect ( str ( root_dir_path ) ) : [EOL] pass [EOL] assert [string] in str ( error_2 ) [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] def test_w_non_dir_root_dir ( tmp_path ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] root_dir_path = tmp_path / [string] [EOL] root_dir_path . write_text ( [string] ) [EOL] [EOL] with pytest . raises ( my_exceptions . DirInspectionError ) as error_1 : [EOL] my_core . _FileInspector ( str ( root_dir_path ) ) [EOL] assert [string] in str ( error_1 ) [EOL] [EOL] dir_inspector = my_core . DirectoryInspector ( ) [EOL] with pytest . raises ( my_exceptions . DirInspectionError ) as error_2 : [EOL] for _ in dir_inspector . inspect ( str ( root_dir_path ) ) : [EOL] pass [EOL] assert [string] in str ( error_2 ) [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] def test_w_invalid_sub_dir ( tmp_path ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] dir_not_under_root_path = tmp_path / [string] [EOL] dir_not_under_root_path . mkdir ( ) [EOL] root_dir_path = tmp_path / [string] [EOL] root_dir_path . mkdir ( ) [EOL] file_path = dir_not_under_root_path / [string] [EOL] file_path . write_text ( [string] ) [EOL] [EOL] inspector = my_core . _FileInspector ( str ( root_dir_path ) ) [EOL] [EOL] with pytest . raises ( my_exceptions . FileInspectionError ) as error_1 : [EOL] inspector . inspect ( str ( file_path ) ) [EOL] assert [string] in str ( error_1 ) [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] def test_w_missing_file ( tmp_path ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] root_dir_path = tmp_path / [string] [EOL] root_dir_path . mkdir ( ) [EOL] file_path = root_dir_path / [string] [EOL] [EOL] inspector = my_core . _FileInspector ( str ( root_dir_path ) ) [EOL] [EOL] with pytest . raises ( my_exceptions . FileInspectionError ) as error_1 : [EOL] inspector . inspect ( str ( file_path ) ) [EOL] assert [string] in str ( error_1 ) [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] def test_w_file_thats_not_a_file ( tmp_path ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] root_dir_path = tmp_path / [string] [EOL] root_dir_path . mkdir ( ) [EOL] file_path = root_dir_path / [string] [EOL] file_path . mkdir ( ) [EOL] [EOL] inspector = my_core . _FileInspector ( str ( root_dir_path ) ) [EOL] [EOL] with pytest . raises ( my_exceptions . FileInspectionError ) as error_1 : [EOL] inspector . inspect ( str ( file_path ) ) [EOL] assert [string] in str ( error_1 ) [EOL] _LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import pytest [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
from typing import Tuple , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import logging [EOL] import rudi_dire_insp [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import copy [EOL] import io [EOL] import logging [EOL] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [comment] [EOL] import rudi_dire_insp . exceptions as my_exceptions [EOL] import rudi_dire_insp . hashing as my_hashing [EOL] import rudi_dire_insp . manifests as my_manifests [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] pytestmark = pytest . mark . unit [EOL] [EOL] [EOL] def test_rb_manifest_props ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] test_data = [string] [EOL] ( expected_hashes , expected_size ) = my_hashing . _HashAlgorithm . calculate_hashes ( io . BytesIO ( test_data ) ) [EOL] ( input_hashes , input_size ) = my_hashing . _HashAlgorithm . calculate_hashes ( io . BytesIO ( test_data ) ) [EOL] assert expected_hashes == input_hashes [EOL] assert expected_size == input_size [EOL] [EOL] [comment] [EOL] manifest = my_manifests . RawBytesManifest ( input_hashes , input_size ) [EOL] assert expected_hashes == manifest . hashes [EOL] assert id ( expected_hashes ) != id ( manifest . hashes ) [EOL] assert expected_size == manifest . size [EOL] [EOL] [EOL] def test_file_manifest_props ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] test_data = [string] [EOL] test_data_size = len ( test_data ) [EOL] expected_raw_manifest = my_manifests . RawBytesManifest ( my_hashing . _HashAlgorithm . calculate_hashes ( io . BytesIO ( test_data ) ) , test_data_size ) [EOL] input_raw_manifest = my_manifests . RawBytesManifest ( my_hashing . _HashAlgorithm . calculate_hashes ( io . BytesIO ( test_data ) ) , test_data_size ) [EOL] assert str ( expected_raw_manifest ) == str ( input_raw_manifest ) [EOL] [EOL] expected_path = ( [string] , [string] , [string] ) [EOL] input_path = copy . deepcopy ( expected_path ) [EOL] [EOL] [comment] [EOL] manifest = my_manifests . FileManifest ( input_path , input_raw_manifest ) [EOL] assert expected_path == manifest . relative_path [EOL] assert str ( expected_raw_manifest ) == str ( manifest . raw_manifest ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import pytest [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import rudi_dire_insp [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] import os [EOL] [EOL] [comment] [EOL] import pytest [EOL] import testfixtures [EOL] [EOL] [comment] [EOL] import rudi_dire_insp . exceptions as my_exceptions [EOL] import rudi_dire_insp . core as my_core [EOL] import rudi_dire_insp . manifests as my_manifests [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] pytestmark = pytest . mark . integration [EOL] [EOL] [EOL] def test_file ( tmp_path ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] sub_dir_path = tmp_path / [string] [EOL] sub_dir_path . mkdir ( ) [EOL] file_path = sub_dir_path / [string] [EOL] file_path . write_text ( [string] ) [EOL] file_path_str = str ( file_path ) [EOL] [EOL] _LOGGER . debug ( [string] , file_path_str ) [EOL] assert os . path . exists ( file_path_str ) [EOL] [EOL] [comment] [EOL] last_manifest = None [EOL] for count in range ( [number] , [number] ) : [EOL] _LOGGER . debug ( [string] , str ( file_path_str ) , count ) [EOL] inspector = my_core . _FileInspector ( root_dir_path = str ( tmp_path ) ) [EOL] manifest = inspector . inspect ( file_path_str ) [EOL] assert isinstance ( manifest , my_manifests . FileManifest ) [EOL] if last_manifest is not None : [EOL] for attr_name in [ [string] , [string] , [string] ] : [EOL] testfixtures . compare ( getattr ( last_manifest , attr_name , None ) , getattr ( manifest , attr_name , None ) ) [EOL] last_manifest = manifest [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] def test_directory ( tmp_path ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] sub_dir_path = tmp_path / [string] [EOL] sub_dir_path . mkdir ( ) [EOL] [EOL] file_names = [ [string] , [string] ] [EOL] for file_name in file_names : [EOL] file_path = sub_dir_path / file_name [EOL] file_path . write_text ( [string] . format ( file_name ) ) [EOL] [EOL] inspector = my_core . DirectoryInspector ( ) [EOL] root_dir_path = str ( tmp_path ) [EOL] counter = [number] [EOL] for manifest in inspector . inspect ( root_dir_path ) : [EOL] _LOGGER . debug ( [string] , str ( manifest ) ) [EOL] assert isinstance ( manifest , my_manifests . FileManifest ) [EOL] counter += [number] [EOL] [EOL] assert counter == len ( file_names ) [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import json [EOL] import logging [EOL] import os [EOL] [EOL] [comment] [EOL] import jsonschema [EOL] import pytest [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ pytest . fixture ( [string] ) def cli_json_schema ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] data_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] schema_path = os . path . join ( data_path , [string] ) [EOL] _LOGGER . debug ( [string] , schema_path ) [EOL] with open ( schema_path , [string] ) as schema_file : [EOL] json_data = json . load ( schema_file ) [EOL] [EOL] [comment] [EOL] _ = jsonschema . Draft4Validator ( schema = json_data ) [EOL] return json_data [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import io [EOL] import logging [EOL] import builtins [EOL] import rudi_dire_insp [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import codecs [EOL] import io [EOL] import json [EOL] import logging [EOL] import typing [EOL] [EOL] [comment] [EOL] import jsonschema [EOL] import pytest [EOL] import testfixtures [EOL] [EOL] [comment] [EOL] import rudi_dire_insp . _cli as my_cli [EOL] import rudi_dire_insp . core as my_core [EOL] import rudi_dire_insp . hashing as my_hashing [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] pytestmark = pytest . mark . integration [EOL] [EOL] [EOL] def build_test_directory ( tmp_directory_posix_path , num_manifests ) : [EOL] [docstring] [EOL] [EOL] root_directory_posix_path = tmp_directory_posix_path / [string] [EOL] root_directory_posix_path . mkdir ( ) [EOL] root_directory_path = str ( root_directory_posix_path ) [EOL] [EOL] [comment] [EOL] manifests = [ ] [EOL] inspector = my_core . _FileInspector ( root_dir_path = root_directory_path ) [EOL] [EOL] [comment] [EOL] for index in range ( [number] , num_manifests + [number] ) : [EOL] [comment] [EOL] file_posix_path = root_directory_posix_path / [string] . format ( index ) [EOL] file_posix_path . write_text ( [string] . format ( index ) ) [EOL] [EOL] [comment] [EOL] manifest = inspector . inspect ( str ( file_posix_path ) ) [EOL] manifests . append ( manifest ) [EOL] [EOL] return root_directory_path , manifests [EOL] [EOL] [EOL] def test_convert_to_json ( tmp_path , cli_json_schema ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] _ , expected_manifests = build_test_directory ( tmp_path , num_manifests = [number] ) [EOL] expected_manifest = expected_manifests [ [number] ] [EOL] [EOL] json_text = my_cli . _convert_to_json_text ( expected_manifest ) [EOL] json_data = json . loads ( json_text ) [EOL] jsonschema . validate ( json_data , cli_json_schema ) [EOL] assert expected_manifest . relative_path == tuple ( json_data [ [string] ] ) [EOL] assert expected_manifest . raw_manifest . size == json_data [ [string] ] [EOL] assert expected_manifest . raw_manifest . hashes == my_hashing . Hashes ( ** json_data [ [string] ] ) [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] def _translate_to_sorted_json_objects ( lines , json_schema ) : [EOL] [docstring] [EOL] json_objects = [ ] [EOL] for line in lines : [EOL] json_object = json . loads ( line ) [EOL] jsonschema . validate ( json_object , json_schema ) [EOL] json_objects . append ( json_object ) [EOL] sorted_json_objects = sorted ( json_objects , key = lambda item : [string] . join ( item [ [string] ] ) ) [EOL] return sorted_json_objects [EOL] [EOL] [EOL] def test_run_inspection ( tmp_path , cli_json_schema ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [comment] [EOL] root_directory_path , expected_manifests = build_test_directory ( tmp_path , num_manifests = [number] ) [EOL] [EOL] [comment] [EOL] expected_text_lines = [ ] [EOL] for expected_manifest in expected_manifests : [EOL] expected_text_lines . append ( my_cli . _convert_to_json_text ( expected_manifest ) ) [EOL] expected_json_objects = _translate_to_sorted_json_objects ( expected_text_lines , cli_json_schema ) [EOL] _LOGGER . debug ( [string] , str ( expected_json_objects ) ) [EOL] [EOL] [comment] [EOL] found_bytes_buffer = io . BytesIO ( ) [EOL] my_cli . _run_inspection ( root_directory_path , found_bytes_buffer ) [EOL] found_bytes = found_bytes_buffer . getvalue ( ) [EOL] found_text = codecs . decode ( found_bytes , encoding = [string] ) [EOL] found_text_lines = io . StringIO ( found_text ) . readlines ( ) [EOL] found_json_objects = _translate_to_sorted_json_objects ( found_text_lines , cli_json_schema ) [EOL] _LOGGER . debug ( [string] , str ( expected_json_objects ) ) [EOL] [EOL] [comment] [EOL] testfixtures . compare ( expected_json_objects , found_json_objects ) [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [comment] [EOL] from tests . integration . fixtures import cli_json_schema [EOL] [EOL] [comment] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0
	0