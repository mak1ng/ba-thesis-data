from typing import Dict [EOL] import typing [EOL] import sheepdoge [EOL] import unittest [EOL] [EOL] from six import iteritems [EOL] [EOL] from sheepdoge . config import Config , DEFAULTS [EOL] from sheepdoge . exception import ( SheepdogeConfigurationAlreadyInitializedException , SheepdogeConfigurationNotInitializedException , ) [EOL] [EOL] [EOL] class ConfigTestCase ( unittest . TestCase ) : [EOL] def setUp ( self , * args , ** kwargs ) : [EOL] super ( ConfigTestCase , self ) . setUp ( * args , ** kwargs ) [EOL] [EOL] Config . clear_config_singleton ( ) [EOL] [EOL] def test_must_initialize_config_before_using ( self ) : [EOL] with self . assertRaises ( SheepdogeConfigurationNotInitializedException ) : [EOL] Config . get_config_singleton ( ) [EOL] [EOL] def test_can_only_initialize_config_once ( self ) : [EOL] Config . initialize_config_singleton ( ) [EOL] [EOL] with self . assertRaises ( SheepdogeConfigurationAlreadyInitializedException ) : [EOL] Config . initialize_config_singleton ( ) [EOL] [EOL] def test_initialize_config_with_defaults ( self ) : [EOL] Config . initialize_config_singleton ( ) [EOL] config = Config . get_config_singleton ( ) [EOL] [EOL] for default_key , default_value in iteritems ( DEFAULTS ) : [EOL] self . assertEqual ( config . get ( default_key ) , default_value ) [EOL] [EOL] def test_initialize_config_with_config_file_values ( self ) : [EOL] config_file_pupfile_path = [string] [EOL] config_file_contents = [string] . format ( config_file_pupfile_path ) [EOL] [EOL] Config . initialize_config_singleton ( config_file_contents = config_file_contents ) [EOL] config = Config . get_config_singleton ( ) [EOL] [EOL] self . assertEqual ( config . get ( [string] ) , config_file_pupfile_path ) [EOL] [EOL] def test_initialize_config_with_config_file_and_non_default_options ( self ) : [EOL] config_file_vault_password_file = [string] [EOL] [EOL] config_file_contents = [string] . format ( config_file_vault_password_file ) [EOL] [EOL] Config . initialize_config_singleton ( config_file_contents = config_file_contents ) [EOL] config = Config . get_config_singleton ( ) [EOL] [EOL] self . assertEqual ( config . get ( [string] ) , config_file_vault_password_file ) [EOL] [EOL] def test_initialize_config_with_config_option_values ( self ) : [EOL] config_options_pupfile_path = [string] [EOL] [EOL] config_options = { [string] : config_options_pupfile_path } [EOL] [EOL] Config . initialize_config_singleton ( config_options = config_options ) [EOL] config = Config . get_config_singleton ( ) [EOL] [EOL] self . assertEqual ( config . get ( [string] ) , config_options_pupfile_path ) [EOL] [EOL] def test_initialize_config_with_calculated_config ( self ) : [EOL] Config . initialize_config_singleton ( ) [EOL] config = Config . get_config_singleton ( ) [EOL] [EOL] for key in { [string] , [string] } : [EOL] self . assertIn ( [string] , config . get ( key ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Union , Any , Set , Dict , List [EOL] import typing [EOL] import sheepdoge [EOL] import mock [EOL] import os [EOL] import shutil [EOL] import tempfile [EOL] import unittest [EOL] [EOL] from six import iteritems [EOL] [EOL] from sheepdoge . config import Config [EOL] from sheepdoge . pup import ( AnsibleDependencies , FsPup , GalaxyPup , GitPup , Pup , PupDependencies , PupfileEntry , PythonDependencies , ) [EOL] [EOL] [EOL] class PupTestCase ( unittest . TestCase ) : [EOL] def setUp ( self , * args , ** kwargs ) : [EOL] super ( PupTestCase , self ) . setUp ( * args , ** kwargs ) [EOL] [EOL] Config . clear_config_singleton ( ) [EOL] Config . initialize_config_singleton ( ) [EOL] [EOL] def test_parse_text_into_entries ( self ) : [EOL] [docstring] [EOL] pupfile_contents = [string] [EOL] [EOL] expected_entries = [ PupfileEntry ( name = [string] , path = [string] , pup_type = [string] ) , PupfileEntry ( name = [string] , path = [string] , pup_type = [string] , ) , PupfileEntry ( name = [string] , path = [string] , pup_type = [string] ) , ] [EOL] [EOL] self . assertEqual ( Pup . parse_text_into_entries ( pupfile_contents ) , expected_entries ) [EOL] [EOL] def test_create_from_entries ( self ) : [EOL] [docstring] [EOL] pupfile_entries = [ PupfileEntry ( name = [string] , path = [string] , pup_type = [string] ) , PupfileEntry ( name = [string] , path = [string] , pup_type = [string] , ) , PupfileEntry ( name = [string] , path = [string] , pup_type = [string] ) , ] [EOL] [EOL] expected_pups = [ FsPup ( [string] , [string] ) , GitPup ( [string] , [string] ) , GalaxyPup ( [string] , [string] ) , ] [EOL] [EOL] actual_pup_dicts = [ pup . to_dict ( ) for pup in Pup . create_from_entries ( pupfile_entries ) ] [EOL] expected_pup_dicts = [ pup . to_dict ( ) for pup in expected_pups ] [EOL] [EOL] self . assertEqual ( actual_pup_dicts , expected_pup_dicts ) [EOL] [EOL] [EOL] class BasePupTestCase ( unittest . TestCase ) : [EOL] def setUp ( self , * args , ** kwargs ) : [EOL] super ( BasePupTestCase , self ) . setUp ( * args , ** kwargs ) [EOL] [EOL] dir_root , kennel_roles_dir , pupfile_dir = self . _create_test_fs ( ) [EOL] [EOL] self . _dir_root = dir_root [EOL] self . _kennel_roles_dir = kennel_roles_dir [EOL] self . _pupfile_dir = pupfile_dir [EOL] [EOL] mock_config_options = { [string] : self . _kennel_roles_dir , [string] : os . path . join ( self . _pupfile_dir , [string] ) , } [EOL] [EOL] Config . clear_config_singleton ( ) [EOL] Config . initialize_config_singleton ( config_options = mock_config_options ) [EOL] [EOL] @ staticmethod def _create_test_fs ( ) : [EOL] dir_root = tempfile . mkdtemp ( ) [EOL] pupfile_dir = dir_root [EOL] [EOL] kennel_roles_dir = os . path . join ( dir_root , [string] ) [EOL] os . mkdir ( kennel_roles_dir ) [EOL] [EOL] return dir_root , kennel_roles_dir , pupfile_dir [EOL] [EOL] def tearDown ( self , * args , ** kwargs ) : [EOL] super ( BasePupTestCase , self ) . tearDown ( * args , ** kwargs ) [EOL] [EOL] if os . path . isdir ( self . _dir_root ) : [EOL] shutil . rmtree ( self . _dir_root ) [EOL] [EOL] def _assert_pup_installed ( self , pup ) : [EOL] expected_pup_location = os . path . join ( self . _kennel_roles_dir , pup . _name ) [EOL] pup_copy_exists_in_kennel = os . path . isdir ( expected_pup_location ) [EOL] [EOL] self . assertTrue ( pup_copy_exists_in_kennel ) [EOL] [EOL] [EOL] class FsPupTestCase ( BasePupTestCase ) : [EOL] def test_install_pup_no_dependencies ( self ) : [EOL] no_dep_pup = self . _create_fs_pup ( [string] ) [EOL] no_dep_pup . install ( ) [EOL] [EOL] self . _assert_pup_installed ( no_dep_pup ) [EOL] [EOL] def _create_fs_pup ( self , name ) : [EOL] pups_dir = os . path . join ( self . _dir_root , [string] ) [EOL] os . mkdir ( pups_dir ) [EOL] [EOL] name_suffix = name . split ( [string] ) [ [number] ] [EOL] pup_dir = os . path . join ( pups_dir , name_suffix ) [EOL] os . mkdir ( pup_dir ) [EOL] [EOL] scratch_file_in_pup_dir = os . path . join ( pup_dir , [string] ) [EOL] with open ( scratch_file_in_pup_dir , [string] ) as scratch_file : [EOL] scratch_file . write ( [string] ) [EOL] [EOL] relative_pup_path = os . path . join ( [string] , [string] , name_suffix ) [EOL] return FsPup ( name , relative_pup_path ) [EOL] [EOL] [EOL] class GitPupTestCase ( BasePupTestCase ) : [EOL] @ unittest . skip ( [string] ) def test_install_git_pup ( self ) : [EOL] pass [EOL] [EOL] [EOL] class GalaxyPupTestCase ( BasePupTestCase ) : [EOL] @ unittest . skip ( [string] ) def test_install_galaxy_pup ( self ) : [EOL] pass [EOL] [EOL] [EOL] class PupDependenciesTestCase ( unittest . TestCase ) : [EOL] def setUp ( self , * args , ** kwargs ) : [EOL] super ( PupDependenciesTestCase , self ) . setUp ( * args , ** kwargs ) [EOL] [EOL] Config . clear_config_singleton ( ) [EOL] Config . initialize_config_singleton ( ) [EOL] [EOL] def test_create_from_dep_file_path ( self ) : [EOL] filename_to_expected_type = { [string] : PythonDependencies , [string] : AnsibleDependencies , } [EOL] [EOL] for filename , expected_type in iteritems ( filename_to_expected_type ) : [EOL] self . assertIsInstance ( PupDependencies . create_from_dep_file_path ( filename ) , expected_type ) [EOL] [EOL] [EOL] class PythonDependenciesTestCase ( unittest . TestCase ) : [EOL] def setUp ( self , * args , ** kwargs ) : [EOL] super ( PythonDependenciesTestCase , self ) . setUp ( * args , ** kwargs ) [EOL] [EOL] Config . clear_config_singleton ( ) [EOL] Config . initialize_config_singleton ( ) [EOL] [EOL] @ mock . patch ( [string] ) def test_install ( self , mock_check_call ) : [EOL] python_dep_file_path = [string] [EOL] [EOL] deps = PupDependencies . create_from_dep_file_path ( python_dep_file_path ) [EOL] deps . install ( ) [EOL] [EOL] self . assertEqual ( mock_check_call . call_count , [number] ) [EOL] [EOL] check_call_args , check_call_kwargs = mock_check_call . call_args [EOL] pip_cmd = check_call_args [ [number] ] [EOL] [EOL] for cmd_line in { [string] , [string] . format ( python_dep_file_path ) } : [EOL] self . assertIn ( cmd_line , pip_cmd ) [EOL] [EOL] [EOL] class AnsibleDependenciesTestCase ( unittest . TestCase ) : [EOL] def setUp ( self , * args , ** kwargs ) : [EOL] super ( AnsibleDependenciesTestCase , self ) . setUp ( * args , ** kwargs ) [EOL] [EOL] Config . clear_config_singleton ( ) [EOL] Config . initialize_config_singleton ( ) [EOL] [EOL] @ mock . patch ( [string] ) def test_install ( self , mock_check_call ) : [EOL] ansible_dep_file_path = [string] [EOL] [EOL] deps = PupDependencies . create_from_dep_file_path ( ansible_dep_file_path ) [EOL] deps . install ( ) [EOL] [EOL] self . assertEqual ( mock_check_call . call_count , [number] ) [EOL] [EOL] check_call_args , check_call_kwargs = mock_check_call . call_args [EOL] ansible_galaxy_cmd = check_call_args [ [number] ] [EOL] [EOL] config = Config . get_config_singleton ( ) [EOL] [EOL] expected_cmds = { [string] , [string] , [string] . format ( ansible_dep_file_path ) , [string] . format ( config . get ( [string] ) ) , } [EOL] [EOL] for cmd_line in expected_cmds : [EOL] self . assertIn ( cmd_line , ansible_galaxy_cmd ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[sheepdoge.pup.PupfileEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[sheepdoge.pup.PupfileEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sheepdoge.pup.PupfileEntry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[sheepdoge.pup.FsPup,sheepdoge.pup.GalaxyPup,sheepdoge.pup.GitPup]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sheepdoge.pup.PupfileEntry]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[sheepdoge.pup.FsPup,sheepdoge.pup.GalaxyPup,sheepdoge.pup.GitPup]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[typing.Union[sheepdoge.pup.AnsibleDependencies,sheepdoge.pup.PythonDependencies]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[typing.Union[sheepdoge.pup.AnsibleDependencies,sheepdoge.pup.PythonDependencies]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $sheepdoge.pup.PupDependencies$ 0 0 0 0 0 $builtins.str$ 0 0 $sheepdoge.pup.PupDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $sheepdoge.pup.PupDependencies$ 0 0 0 0 0 $builtins.str$ 0 0 $sheepdoge.pup.PupDependencies$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $sheepdoge.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sheepdoge [EOL] import mock [EOL] import os [EOL] import tempfile [EOL] import unittest [EOL] [EOL] from sheepdoge . config import Config [EOL] from sheepdoge . kennel import Kennel [EOL] [EOL] [EOL] class KennelTestCase ( unittest . TestCase ) : [EOL] def setUp ( self , * args , ** kwargs ) : [EOL] super ( KennelTestCase , self ) . setUp ( * args , ** kwargs ) [EOL] [EOL] Config . clear_config_singleton ( ) [EOL] Config . initialize_config_singleton ( ) [EOL] [EOL] def test_refresh_roles_dir_exists ( self ) : [EOL] [docstring] [EOL] mock_kennel_path = tempfile . mkdtemp ( ) [EOL] os . mkdir ( os . path . join ( mock_kennel_path , [string] ) ) [EOL] [EOL] Kennel . refresh_roles ( mock_kennel_path ) [EOL] [EOL] self . assertEqual ( os . listdir ( mock_kennel_path ) , [ ] ) [EOL] self . assertTrue ( os . path . isdir ( mock_kennel_path ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ mock . patch ( [string] ) def test_kennel_run ( self , mock_check_call ) : [EOL] [docstring] [EOL] kennel = Kennel ( ) [EOL] kennel . run ( ) [EOL] [EOL] self . assertEqual ( mock_check_call . call_count , [number] ) [EOL] [EOL] check_call_args , check_call_kwargs = mock_check_call . call_args [EOL] ansible_playbook_cmd = check_call_args [ [number] ] [EOL] [EOL] for expected_arg in { [string] , [string] } : [EOL] self . assertIn ( expected_arg , ansible_playbook_cmd ) [EOL] [EOL] self . assertTrue ( check_call_kwargs [ [string] ] ) [EOL] self . assertIn ( [string] , check_call_kwargs [ [string] ] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_kennel_run_include_vault_password_file ( self , mock_check_call ) : [EOL] [docstring] [EOL] Config . clear_config_singleton ( ) [EOL] Config . initialize_config_singleton ( config_options = { [string] : [string] } ) [EOL] [EOL] kennel = Kennel ( ) [EOL] kennel . run ( ) [EOL] [EOL] self . assertEqual ( mock_check_call . call_count , [number] ) [EOL] [EOL] check_call_args , check_call_kwargs = mock_check_call . call_args [EOL] ansible_playbook_cmd = check_call_args [ [number] ] [EOL] [EOL] self . assertTrue ( [string] in ansible_playbook_cmd ) [EOL] [EOL] @ mock . patch ( [string] ) def test_kennel_run_not_include_vault_password_file ( self , mock_check_call ) : [EOL] [docstring] [EOL] kennel = Kennel ( ) [EOL] kennel . run ( ) [EOL] [EOL] self . assertEqual ( mock_check_call . call_count , [number] ) [EOL] [EOL] check_call_args , check_call_kwargs = mock_check_call . call_args [EOL] ansible_playbook_cmd = check_call_args [ [number] ] [EOL] [EOL] self . assertFalse ( [string] in ansible_playbook_cmd ) [EOL] [EOL] @ mock . patch ( [string] ) def test_kennel_run_include_additional_ansible_arguments ( self , mock_check_call ) : [EOL] [docstring] [EOL] additional_ansible_args = [string] [EOL] kennel = Kennel ( additional_ansible_args = additional_ansible_args ) [EOL] kennel . run ( ) [EOL] [EOL] self . assertEqual ( mock_check_call . call_count , [number] ) [EOL] [EOL] check_call_args , check_call_kwargs = mock_check_call . call_args [EOL] ansible_playbook_cmd = check_call_args [ [number] ] [EOL] [EOL] self . assertFalse ( [string] in ansible_playbook_cmd ) [EOL] self . assertEqual ( [string] , ansible_playbook_cmd [ - [number] : ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.kennel.Kennel$ 0 0 0 0 0 $sheepdoge.kennel.Kennel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.kennel.Kennel$ 0 0 0 0 0 $sheepdoge.kennel.Kennel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sheepdoge.kennel.Kennel$ 0 0 0 0 0 $sheepdoge.kennel.Kennel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $sheepdoge.kennel.Kennel$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $sheepdoge.kennel.Kennel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List , Any [EOL] import typing [EOL] import mock [EOL] import unittest [EOL] from mock import MagicMock [EOL] [EOL] from sheepdoge . config import Config [EOL] from sheepdoge . action . install import InstallAction , ParallelInstallAction [EOL] [EOL] [EOL] class InstallActionTestCase ( unittest . TestCase ) : [EOL] def setUp ( self , * args , ** kwargs ) : [EOL] super ( InstallActionTestCase , self ) . setUp ( * args , ** kwargs ) [EOL] [EOL] Config . clear_config_singleton ( ) [EOL] Config . initialize_config_singleton ( ) [EOL] [EOL] def test_install_action_installs_pups ( self ) : [EOL] self . _test_install_action_installs_pups ( InstallAction ) [EOL] [EOL] def test_parallel_install_action_installs_pups ( self ) : [EOL] self . _test_install_action_installs_pups ( ParallelInstallAction ) [EOL] [EOL] def _test_install_action_installs_pups ( self , install_action_cls ) : [EOL] mock_kennel_cls = MagicMock ( ) [EOL] [EOL] individual_pup_mocks = [ MagicMock ( ) for _ in range ( [number] ) ] [EOL] [EOL] mock_pup_cls = MagicMock ( ) [EOL] mock_pup_cls . parse_pupfile_into_pups . return_value = individual_pup_mocks [EOL] [EOL] install_action = install_action_cls ( kennel_cls = mock_kennel_cls , pup_cls = mock_pup_cls ) [EOL] [EOL] install_action . run ( ) [EOL] [EOL] mock_kennel_cls . refresh_roles . assert_called_once ( ) [EOL] for mock_pup in individual_pup_mocks : [EOL] mock_pup . install . assert_called_once ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mock.MagicMock$ 0 0 0 0 0 0 $typing.List[mock.MagicMock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mock.MagicMock$ 0 0 0 0 0 $mock.MagicMock$ 0 0 0 0 0 $typing.List[mock.MagicMock]$ 0 0 $typing.Any$ 0 0 0 0 0 $mock.MagicMock$ 0 0 0 $mock.MagicMock$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $typing.List[mock.MagicMock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0