	0
from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] import requests [EOL] import json [EOL] from typing import Dict , Any [EOL] [EOL] BOOK = [string] [EOL] API = [string] [EOL] SERVICES = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] def get_btc_data ( service , params = None ) : [EOL] if not params : [EOL] params = { [string] : BOOK , [string] : [number] } [EOL] URL = API + SERVICES [ service ] [EOL] res = requests . get ( URL , params ) . text [EOL] return json . loads ( res ) [ [string] ] [EOL] [EOL] def get_ticker ( ) : [EOL] return get_btc_data ( [string] ) [EOL] [EOL] [EOL] def get_order_book ( ) : [EOL] return get_btc_data ( [string] ) [EOL] [EOL] [EOL] def get_trades ( ) : [EOL] return get_btc_data ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Tuple , Any , Dict [EOL] import typing [EOL] import models [EOL] import builtins [EOL] import platform [EOL] import time [EOL] from datetime import datetime , timedelta [EOL] from typing import Any , Dict , Tuple [EOL] [EOL] from utils . request import Request [EOL] [EOL] from . models . credentials import Credentials [EOL] [EOL] [EOL] class Reddit ( object ) : [EOL] [EOL] def __init__ ( self , credentials ) : [EOL] self . _token = None [EOL] self . _token_url = [string] [EOL] self . _credentials = credentials [EOL] [EOL] def _user_agent ( self ) : [EOL] return [string] . format ( platform . system ( ) , self . _credentials . app_id , self . _credentials . version , self . _credentials . username ) [EOL] [EOL] def _header ( self , include_token = True ) : [EOL] headers = { [string] : self . _user_agent ( ) } [EOL] if include_token : [EOL] headers [ [string] ] = [string] . format ( self . _token [ [string] ] , self . _token [ [string] ] ) [EOL] return headers [EOL] [EOL] def _auth ( self ) : [EOL] return ( self . _credentials . client_id , self . _credentials . client_secret ) [EOL] [EOL] def _request ( self , url , data = None , method = [string] ) : [EOL] return Request . run ( url , method , data , self . _header ( ) , self . _auth ( ) ) [EOL] [EOL] def _is_logged ( self ) : [EOL] if self . _token is not None and self . _token [ [string] ] < datetime . now ( ) : [EOL] return True [EOL] return False [EOL] [EOL] def login ( self ) : [EOL] if self . _is_logged ( ) : [EOL] return True [EOL] [EOL] data = { [string] : [string] , [string] : self . _credentials . username , [string] : self . _credentials . password } [EOL] response = Request . run ( self . _token_url , [string] , data , self . _header ( False ) , self . _auth ( ) ) [EOL] if response [ [string] ] == [number] : [EOL] self . _token = response [ [string] ] [EOL] self . _token [ [string] ] = datetime . fromtimestamp ( time . mktime ( datetime . now ( ) . timetuple ( ) ) ) + timedelta ( seconds = int ( self . _token [ [string] ] ) ) [EOL] return True [EOL] return False [EOL] [EOL] def headlines ( self , subreddit , limit , sort = [string] ) : [EOL] url = [string] . format ( subreddit , sort , limit ) [EOL] return self . _request ( url ) [EOL] [EOL] def comments ( self , subreddit , comment_id , limit ) : [EOL] url = [string] . format ( subreddit , comment_id , limit ) [EOL] return self . _request ( url ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] class Credentials ( object ) : [EOL] def __init__ ( self , username , password , client_id , client_secret , app_id , version ) : [EOL] self . app_id = app_id [EOL] self . version = version [EOL] self . username = username [EOL] self . password = password [EOL] self . client_id = client_id [EOL] self . client_secret = client_secret [EOL] [EOL] def __repr__ ( self ) : [EOL] attributes = [ x for x in self . __dict__ . keys ( ) if x [ : [number] ] != [string] ] [EOL] values = [ getattr ( self , x ) for x in attributes ] [EOL] return [string] . format ( [string] . join ( map ( lambda p : p , values ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
	0
from typing import List , Tuple , Any , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Any , Dict , List , Tuple [EOL] [EOL] HEADLINES_KEYS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] COMMENTS_KEYS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] class ThingAMaJig ( object ) : [EOL] def __init__ ( self , keys ) : [EOL] self . _wanted_keys = keys [EOL] [EOL] def _append_items_from_list ( self , items , obj ) : [EOL] for item in items : [EOL] if isinstance ( item , list ) : [EOL] self . _append_items_from_list ( item , obj ) [EOL] else : [EOL] obj . append ( item ) [EOL] [EOL] def _keep_keys ( self , item ) : [EOL] _data = [ ] [EOL] if item [ [string] ] == [string] and [string] in item [ [string] ] : [EOL] if item [ [string] ] [ [string] ] != [string] : [EOL] _data . append ( self . _dict_to_object ( item [ [string] ] [ [string] ] ) ) [EOL] [EOL] _data . append ( { k : item [ [string] ] [ k ] if k in item [ [string] ] else None for k in self . _wanted_keys } ) [EOL] return _data [EOL] [EOL] def _dict_to_object ( self , data ) : [EOL] _data = [ ] [EOL] if [string] in data : [EOL] start = [number] [EOL] if data [ [string] ] [ [string] ] [ [number] ] [ [string] ] == [string] : [EOL] start = [number] [EOL] for x in data [ [string] ] [ [string] ] [ start : ] : [EOL] item = self . _keep_keys ( x ) [EOL] if isinstance ( item , list ) : [EOL] self . _append_items_from_list ( item , _data ) [EOL] else : [EOL] _data . append ( item ) [EOL] return _data [EOL] [EOL] def embody ( self , data ) : [EOL] _data = [ ] [EOL] if isinstance ( data , list ) : [EOL] _data = [ self . embody ( item ) for item in data ] [EOL] elif isinstance ( data , dict ) : [EOL] _data = self . _dict_to_object ( data ) [EOL] if len ( _data ) > [number] and isinstance ( _data [ [number] ] , list ) : [EOL] return [ y for x in _data for y in x if len ( x ) > [number] ] [EOL] return _data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0
	0
from typing import Tuple [EOL] import typing [EOL] class State ( object ) : [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , c , h ) : [EOL] self . c = c [EOL] self . h = h [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . __class__ . __name__ , self . c , self . h ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] import numpy as np [EOL] [EOL] [EOL] class Embedding ( object ) : [EOL] [EOL] def __init__ ( self , partition_strategy = [string] ) : [EOL] self . _partition_strategy = partition_strategy [EOL] [EOL] def _ps_mod ( self , ids , num_partitions ) : [EOL] return ids % num_partitions , ids // num_partitions [EOL] [EOL] @ staticmethod def scalar_partition ( ) : [EOL] [comment] [EOL] pass [EOL] [EOL] @ staticmethod def vector_partition ( data , partition , ids_shape ) : [EOL] shape = ( partition . shape [ [number] ] , data . shape [ [number] ] ) [EOL] output = np . empty ( shape , dtype = data . dtype ) [EOL] el = [number] [EOL] for index in partition : [EOL] output [ el ] = data [ index ] [EOL] el += [number] [EOL] return output . reshape ( ids_shape ) [EOL] [EOL] def look_up ( self , lookup_table , ids ) : [EOL] num_partitions = lookup_table . size [EOL] _ids = ids . flatten ( ) [EOL] partitions , new_ids = None , None [EOL] if self . _partition_strategy == [string] : [EOL] partitions , new_ids = self . _ps_mod ( _ids , num_partitions ) [EOL] else : [EOL] [comment] [EOL] raise NotImplementedError ( [string] . format ( self . __class__ . __name__ , self . _partition_strategy ) ) [EOL] partitions = partitions . astype ( np . int32 ) [EOL] _shape = ids . shape + lookup_table . shape [ [number] : ] [EOL] partitions = self . vector_partition ( lookup_table , partitions , _shape ) [EOL] return partitions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0
	0
from typing import List , Tuple , Any [EOL] import typing [EOL] import ml [EOL] import decimal [EOL] [EOL] import numpy as np [EOL] [EOL] [EOL] class InitFn ( object ) : [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , init_fn , ** kwargs ) : [EOL] self . _kwargs = kwargs [EOL] self . _init_fn = init_fn [EOL] [EOL] def __call__ ( self , shape , dtype = np . int32 ) : [EOL] if [string] in self . _kwargs : [EOL] if self . _kwargs [ [string] ] is None : [EOL] self . _kwargs [ [string] ] = shape [EOL] return self . _init_fn ( ** self . _kwargs ) . astype ( dtype ) [EOL] return self . _init_fn ( shape = shape , dtype = dtype , ** self . _kwargs ) [EOL] [EOL] [EOL] class Matrix ( object ) : [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , dtype , shape , name , init_fn = None ) : [EOL] self . _name = name [EOL] self . _dtype = dtype [EOL] self . _shape = self . _get_shape ( shape ) [EOL] self . _value = None [EOL] if init_fn is not None : [EOL] self . _value = init_fn ( self . _shape , dtype = self . _dtype ) [EOL] self . _index = [number] [EOL] [EOL] def __add__ ( self , other ) : [EOL] if isinstance ( other , Matrix ) : [EOL] return self . _value + other . value [EOL] return self . _value + other [EOL] [EOL] def __mul__ ( self , other ) : [EOL] if isinstance ( other , Matrix ) : [EOL] return np . dot ( self . _value , other . value ) [EOL] b = self . _value . flatten ( ) [EOL] if ( self . _index >= len ( b ) ) : [EOL] self . _index = [number] [EOL] a = b [ self . _index ] * other [EOL] self . _index += [number] [EOL] return a [EOL] [EOL] def __rmul__ ( self , other ) : [EOL] if isinstance ( other , Matrix ) : [EOL] return self . _value * other . value [EOL] return self . __mul__ ( other ) [EOL] [EOL] def __array_ufunc__ ( self , ufunc , method , * inputs , ** other ) : [EOL] _inputs = [ ] [EOL] for x in inputs : [EOL] if isinstance ( x , Matrix ) : [EOL] _inputs . append ( x . value ) [EOL] else : [EOL] _inputs . append ( x ) [EOL] return ufunc ( * _inputs , ** other ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . __class__ . __name__ , np . dtype ( self . _dtype ) . name , str ( self . _shape ) , self . _name , self . _value ) [EOL] [EOL] def __getitem__ ( self , index ) : [EOL] return self . _value [ index ] [EOL] [EOL] def _get_shape ( self , shape ) : [EOL] if not isinstance ( shape , ( tuple , list , ) ) : [EOL] raise TypeError ( [string] ) [EOL] if not all ( isinstance ( x , ( int , np . number , type ( None ) , ) ) for x in shape ) : [EOL] raise TypeError ( [string] ) [EOL] return tuple ( [ x if x is not None else [number] for x in shape ] ) [EOL] [EOL] def __call__ ( self , value ) : [EOL] if isinstance ( value , ( np . ndarray , Matrix , ) ) : [EOL] dims = len ( self . _shape ) - len ( value . shape ) [EOL] self . _value = value [EOL] if self . _dtype != value . dtype : [EOL] self . _value = value . astype ( self . _dtype ) [EOL] if dims > [number] : [EOL] for _ in range ( dims ) : [EOL] _axis = len ( self . _value . shape ) - [number] [EOL] self . _value = np . expand_dims ( self . _value , axis = _axis ) [EOL] elif dims < [number] : [EOL] raise ValueError ( [string] . format ( value . ndim , len ( self . _shape ) ) ) [EOL] elif isinstance ( value , ( int , float , decimal . Decimal , np . number , ) ) : [EOL] self . _value = np . full ( self . _shape , value , self . _dtype ) [EOL] self . _shape = self . _value . shape [EOL] [EOL] @ property def shape ( self ) : [EOL] return self . _shape [EOL] [EOL] @ property def dtype ( self ) : [EOL] return self . _dtype [EOL] [EOL] @ property def ndim ( self ) : [EOL] return len ( self . _value . shape ) [EOL] [EOL] @ property def size ( self ) : [EOL] if self . _value is None : [EOL] return [number] [EOL] return self . _value . size [EOL] [EOL] @ property def value ( self ) : [EOL] return self . _value [EOL] [EOL] @ property def T ( self ) : [EOL] _value = self . _value . T [EOL] _m = Matrix ( self . _dtype , _value . shape , self . _name ) [EOL] _m ( _value ) [EOL] return _m [EOL] [EOL] def flatten ( self , order = [string] ) : [EOL] return self . _value . flatten ( order ) [EOL] [EOL] def argmax ( self , ** other ) : [EOL] return np . argmax ( self . _value , ** other ) [EOL] [EOL] def reverse ( self ) : [EOL] if self . _value . ndim == [number] : [EOL] self . _value = np . flipud ( self . _value ) [EOL] else : [EOL] self . _value = np . ascontiguousarray ( self . _value [ : : - [number] ] ) [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ml.network.matrix.Matrix$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ml.network.matrix.Matrix$ 0 0 0 0 0 $ml.network.matrix.Matrix$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Counter [EOL] import typing [EOL] import collections [EOL] import collections [EOL] import multiprocessing [EOL] from collections import Counter , deque [EOL] from string import punctuation [EOL] [EOL] import numpy as np [EOL] [EOL] from utils . logger import getLogger [EOL] [EOL] logger = getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_batches ( x , y , batch_size = [number] ) : [EOL] n_batches = len ( x ) // batch_size [EOL] x , y = x [ : n_batches * batch_size ] , y [ : n_batches * batch_size ] [EOL] for i in range ( [number] , len ( x ) , batch_size ) : [EOL] yield x [ i : i + batch_size ] , y [ i : i + batch_size ] [EOL] [EOL] [EOL] class Data ( object ) : [EOL] def __init__ ( self ) : [EOL] self . _labels = None [EOL] self . train_data_x = None [EOL] self . train_data_y = None [EOL] self . val_x = None [EOL] self . val_y = None [EOL] self . test_x = None [EOL] self . test_y = None [EOL] self . _int_map = deque ( ) [EOL] [EOL] def label_encoding ( self , labels , steps = [number] ) : [EOL] self . _labels = np . array ( [ [number] if l == [string] else [number] for l in labels . split ( ) ] ) [EOL] [EOL] self . _int_map = [ r [ [number] : steps ] for r in self . _int_map if len ( r ) > [number] ] [EOL] [comment] [EOL] [comment] [EOL] return Counter ( [ len ( x ) for x in self . _int_map ] ) [EOL] [EOL] def separate_data ( self , seq_len = [number] , split_frac_training = [number] , split_frac_test_val = [number] ) : [EOL] [EOL] features = np . zeros ( ( len ( self . _int_map ) , seq_len ) , dtype = np . int ) [EOL] for i , row in enumerate ( self . _int_map ) : [EOL] features [ i , - len ( row ) : ] = np . array ( row ) [ : seq_len ] [EOL] [EOL] split_index = int ( split_frac_training * len ( features ) ) [EOL] [EOL] self . _train_x , self . _val_x = features [ : split_index ] , features [ split_index : ] [EOL] self . _train_y , self . _val_y = self . _labels [ : split_index ] , self . _labels [ split_index : ] [EOL] [EOL] split_index = int ( split_frac_test_val * len ( self . _val_x ) ) [EOL] [EOL] self . _val_x , self . _test_x = self . _val_x [ : split_index ] , self . _val_x [ split_index : ] [EOL] self . _val_y , self . _test_y = self . _val_y [ : split_index ] , self . _val_y [ split_index : ] [EOL] [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] . format ( self . _train_x . shape ) ) [EOL] logger . info ( [string] . format ( self . _val_x . shape ) ) [EOL] logger . info ( [string] . format ( self . _test_x . shape ) ) [EOL] logger . info ( [string] . format ( self . _train_y . shape ) ) [EOL] logger . info ( [string] . format ( self . _val_y . shape ) ) [EOL] logger . info ( [string] . format ( self . _test_y . shape ) ) [EOL] [EOL] @ property def training_data ( self ) : [EOL] return self . _train_x , self . _train_y [EOL] [EOL] @ property def test_data ( self ) : [EOL] return self . _test_x , self . _test_y [EOL] [EOL] @ property def validation_data ( self ) : [EOL] return self . _val_x , self . _val_y [EOL] [EOL] [EOL] class Data2 ( Data ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . n_words = [number] [EOL] self . words_to_int = { } [EOL] [EOL] def no_punctuation ( self , text ) : [EOL] [comment] [EOL] return [string] . join ( [ c for c in text if c not in punctuation ] ) [EOL] [EOL] def _map_to_integers ( self , sentences , words ) : [EOL] counts = Counter ( words ) [EOL] vocab = sorted ( counts , key = counts . get , reverse = True ) [EOL] self . words_to_int = { word : i for i , word in enumerate ( vocab , [number] ) } [EOL] [EOL] for each in sentences : [EOL] self . _int_map . append ( [ self . words_to_int [ word ] for word in each . split ( ) ] ) [EOL] [EOL] self . n_words = len ( self . words_to_int ) + [number] [comment] [EOL] [EOL] def preprocessing ( self , data ) : [EOL] all_text = [string] . join ( list ( map ( self . no_punctuation , data ) ) ) [EOL] data = all_text . split ( [string] ) [EOL] [EOL] all_text = [string] . join ( data ) [EOL] words = all_text . split ( ) [EOL] self . _map_to_integers ( data , words ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.Counter[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $collections.Counter[typing.Any]$ 0 0 0 $collections.Counter[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0
	0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] from ml . ops import array [EOL] from ml . ops . activation import Activation [EOL] [EOL] [EOL] class Adam ( object ) : [EOL] [comment] [EOL] def __init__ ( self , alpha = [number] , beta1 = [number] , beta2 = [number] , epsilon = np . spacing ( [number] ) ) : [EOL] self . _alpha = alpha [EOL] self . _beta1 = beta1 [EOL] self . _beta2 = beta2 [EOL] self . _epsilon = epsilon [EOL] [EOL] def _update_moment ( self , decay_rate , moment , gradient ) : [EOL] w = decay_rate * moment + ( [number] - decay_rate ) [EOL] if gradient . ndim == [number] : [EOL] return np . array ( [ w * g for g in gradient ] ) [EOL] return w * gradient [EOL] [EOL] def _correct_moment ( self , decay_rate , moment ) : [EOL] return moment / ( [number] - decay_rate ) [EOL] [EOL] def _update_parameter ( self , cell , unit_m_w , unit_v_w , unit_m_b , unit_v_b ) : [EOL] l_w = self . _alpha * unit_m_w / ( np . sqrt ( unit_v_w . astype ( np . float64 ) ) + self . _epsilon ) [EOL] l_b = self . _alpha * unit_m_b / ( np . sqrt ( unit_v_b . astype ( np . float64 ) ) + self . _epsilon ) [EOL] cell . update_layer ( l_w , l_b ) [EOL] [EOL] def minimize ( self , error , output , output_1 , cell , state = None , m = [number] , v = [number] ) : [EOL] _shape = output . shape [EOL] if state is not None : [EOL] _shape = state . h . shape [EOL] [EOL] d_w_prev = np . zeros ( _shape , dtype = output . dtype ) [EOL] d_w = np . full ( _shape , [number] , dtype = output . dtype ) [EOL] [EOL] o , s , g = None , None , None [EOL] index = [number] [EOL] while not np . allclose ( d_w , d_w_prev , equal_nan = True ) : [EOL] d_w_prev = d_w [EOL] if state is None : [EOL] g = cell . back ( error , output , output_1 ) [EOL] else : [EOL] g = cell . back ( error , output , output_1 , state ) [EOL] if len ( g ) == [number] : [EOL] o , s , d_w , d_b = g [EOL] else : [EOL] o , d_w , d_b = g [EOL] [EOL] if d_w_prev . ndim != d_w . ndim : [EOL] d_w_prev = np . zeros ( d_w . shape , dtype = d_w . dtype ) [EOL] else : [EOL] d_w_prev = d_w [EOL] m_w = self . _update_moment ( self . _beta1 , m , d_w ) [EOL] m_b = self . _update_moment ( self . _beta1 , m , d_b ) [EOL] [EOL] v_w = self . _update_moment ( self . _beta2 , v , np . power ( d_w , [number] ) ) [EOL] v_b = self . _update_moment ( self . _beta2 , v , np . power ( d_b , [number] ) ) [EOL] [EOL] unit_m_w = self . _correct_moment ( self . _beta1 , m_w ) [EOL] unit_m_b = self . _correct_moment ( self . _beta1 , m_b ) [EOL] [EOL] unit_v_w = self . _correct_moment ( self . _beta1 , v_w ) [EOL] unit_v_b = self . _correct_moment ( self . _beta1 , v_b ) [EOL] [EOL] self . _update_parameter ( cell , unit_m_w , unit_v_w , unit_m_b , unit_v_b ) [EOL] if index > [number] : [comment] [EOL] break [EOL] index = index + [number] [EOL] return m , v , o , s [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] [EOL] [EOL] def change_mayor ( a ) : [EOL] axis1 = [number] [EOL] axis2 = [number] [EOL] return np . swapaxes ( a , axis1 , axis2 ) [EOL] [EOL] [EOL] def _broadcast_attempt ( a , b ) : [EOL] try : [EOL] np . broadcast ( a , b ) [EOL] return True [EOL] except ValueError : [EOL] return False [EOL] [EOL] [EOL] def broadcast_attempt ( a , b , axis = - [number] ) : [EOL] if a . ndim != b . ndim : [EOL] raise ValueError ( [string] [string] ) [EOL] if _broadcast_attempt ( a , b ) : [EOL] return b [EOL] elif _broadcast_attempt ( a , b . T ) : [EOL] return b . T [EOL] elif axis > - [number] : [EOL] if a . shape [ axis ] == b . shape [ axis ] : [EOL] return b [EOL] index = b . shape . index ( a . shape [ axis ] ) [EOL] b = np . swapaxes ( b , ( ( index + [number] ) % b . ndim ) , index ) [EOL] return b [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] [EOL] from ml . ops . activation import Softmax [EOL] [EOL] [EOL] def cross_entropy ( p , q , estimate = False ) : [EOL] [comment] [EOL] event_prob = np . log ( q ) [EOL] p_log_q = np . sum ( ( p * event_prob ) , [number] ) [EOL] if estimate : [EOL] p_log_q = p_log_q / p . size [EOL] return - [number] * p_log_q [EOL] [EOL] [EOL] def softmax_cross_entropy ( labels , logits ) : [EOL] return cross_entropy ( labels , Softmax . probability ( logits ) , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] [EOL] [EOL] class Activation ( object ) : [EOL] __slots__ = ( ) [EOL] [EOL] @ staticmethod def get_derivative ( fn ) : [EOL] dfn = getattr ( fn . __self__ , [string] . format ( fn . __name__ ) , None ) [EOL] if dfn is None : [EOL] dfn = getattr ( fn . __self__ , [string] , None ) [EOL] return dfn [EOL] [EOL] [EOL] class Sigmoid ( object ) : [EOL] [comment] [EOL] __slots__ = ( ) [EOL] [EOL] @ classmethod def logistic ( cls , z ) : [EOL] return [number] / ( [number] + ( np . exp ( - z , dtype = np . dtype ( [string] ) ) . astype ( z . dtype ) ) ) [EOL] [EOL] @ classmethod def logistic_derivative ( cls , z ) : [EOL] _sigmoid = cls . logistic ( z ) [EOL] return _sigmoid * ( [number] - _sigmoid ) [EOL] [EOL] [EOL] class Hyperbolic ( object ) : [EOL] [comment] [EOL] __slots__ = ( ) [EOL] [EOL] @ classmethod def tanh ( cls , z ) : [EOL] return np . tanh ( z . astype ( np . float64 ) ) [EOL] [EOL] @ classmethod def tanh_derivative ( cls , z ) : [EOL] return [number] - np . square ( cls . tanh ( z ) ) [EOL] [EOL] [EOL] class ReLU ( object ) : [EOL] [comment] [EOL] __slots__ = ( ) [EOL] [EOL] @ classmethod def noisy ( cls , z ) : [EOL] return np . maximum ( z , [number] ) [EOL] [EOL] @ classmethod def noisy_derivative ( cls , z ) : [EOL] return np . where ( z > [number] , [number] , [number] ) [EOL] [EOL] [EOL] class Softmax ( object ) : [EOL] [comment] [EOL] __slots__ = ( ) [EOL] [EOL] @ classmethod def probability ( cls , z ) : [EOL] z = z . astype ( np . dtype ( [string] ) ) [EOL] logits_exp = np . exp ( z - np . max ( z , axis = [number] , keepdims = True ) ) [EOL] return logits_exp / np . sum ( logits_exp , axis = [number] , keepdims = True ) [EOL] [EOL] @ classmethod def derivative ( cls , z ) : [EOL] z = z . astype ( np . dtype ( [string] ) ) [EOL] logits_exp = np . exp ( z - np . max ( z , axis = [number] , keepdims = True ) ) [EOL] div = np . sum ( logits_exp , axis = [number] , keepdims = True ) [EOL] logits_exp_1 = logits_exp [ : , [number] ] [EOL] logits_exp_2 = logits_exp [ : , [number] : ] [EOL] logits_exp_2 = np . sum ( logits_exp_2 , axis = [number] , keepdims = True ) [EOL] return ( logits_exp_1 * logits_exp_2 ) / np . square ( div ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0
	0
from typing import Union , Literal [EOL] import typing [EOL] import typing_extensions [EOL] import os [EOL] [EOL] from pymongo import MongoClient [EOL] [EOL] [EOL] def delete_item_s_in_collection ( collection , items = None ) : [EOL] if items is None : [EOL] collection . delete_many ( { } ) [EOL] elif isinstance ( items , [ ] ) : [EOL] collection . delete_many ( items ) [EOL] else : [EOL] collection . delete_one ( items ) [EOL] [EOL] [EOL] def get_collection ( db , name ) : [EOL] return db [ name ] [EOL] [EOL] [EOL] def get_connection ( ) : [EOL] MONGO_USER = os . environ . get ( [string] , [string] ) [EOL] MONGO_PWD = os . environ . get ( [string] , [string] ) [EOL] MONGO_DOM = os . environ . get ( [string] , [string] ) [EOL] MONGO_PORT = os . environ . get ( [string] , [number] ) [EOL] MONGO_DB = os . environ . get ( [string] , [string] ) [EOL] [EOL] conn_user_pass = [string] [EOL] if MONGO_USER != [string] : [EOL] conn_user_pass = [string] . format ( MONGO_USER , MONGO_PWD ) [EOL] connection_url = [string] . format ( conn_user_pass , MONGO_DOM , MONGO_PORT , MONGO_DB ) [EOL] if MONGO_DB == [string] : [EOL] return MongoClient ( connection_url ) [EOL] return MongoClient ( connection_url ) [ MONGO_DB ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from functools import wraps [EOL] [EOL] [EOL] def add_class_method ( cls ) : [EOL] def decorator ( func ) : [EOL] @ wraps ( func ) def wrapper ( self , * args , ** kwargs ) : [EOL] return func ( self , * args , ** kwargs ) [EOL] setattr ( cls , func . __name__ , wrapper ) [EOL] return func [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Type , Any , Dict [EOL] import typing [EOL] import utils [EOL] import builtins [EOL] import json [EOL] from typing import Any , Callable , Dict , Tuple [EOL] [EOL] import requests [EOL] [EOL] [EOL] class Method ( object ) : [EOL] GET = requests . get [EOL] POST = requests . post [EOL] [EOL] @ staticmethod def validate ( item ) : [EOL] if item == Method . GET or item == Method . POST : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] class Request ( object ) : [EOL] [EOL] @ staticmethod def method ( method ) : [EOL] if isinstance ( method , str ) : [EOL] return getattr ( Method , method ) [EOL] elif Method . validate ( method ) : [EOL] return method [EOL] raise ValueError ( [string] ) [EOL] [EOL] @ classmethod def run ( cls , url , method , data = None , headers = None , auth = None , time_out = None ) : [EOL] request = cls . method ( method ) [EOL] try : [EOL] req = request ( url , data = data , auth = auth , headers = headers , timeout = time_out ) [EOL] response = [string] [EOL] try : [EOL] response = req . json ( ) [EOL] except : [EOL] response = req . text [EOL] return { [string] : req . status_code , [string] : response } [EOL] except requests . exceptions . Timeout : [EOL] raise Exception ( [string] ) [EOL] except requests . exceptions . HTTPError as error : [EOL] return { [string] : req . status_code , [string] : error . response } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import builtins [EOL] import logging [EOL] [EOL] console = logging . StreamHandler ( ) [EOL] console . setLevel ( logging . DEBUG ) [EOL] formatter = logging . Formatter ( [string] ) [EOL] console . setFormatter ( formatter ) [EOL] [EOL] def getLogger ( name ) : [EOL] logger = logging . getLogger ( name ) [EOL] [comment] [EOL] logger . setLevel ( logging . DEBUG ) [EOL] logger . addHandler ( console ) [EOL] return logger [EOL]	0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] import plotly [EOL] from plotly . graph_objs import Layout , Box [EOL] [EOL] [comment] [EOL] y0 = np . random . randn ( [number] ) - [number] [EOL] y1 = np . random . randn ( [number] ) + [number] [EOL] [EOL] [comment] [EOL] trace1 = Box ( y = y0 , showlegend = True , name = [string] ) [EOL] trace2 = Box ( y = y1 , showlegend = True , name = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] plotly . offline . plot ( { [string] : [ trace1 , trace2 ] , [string] : Layout ( title = [string] , font = dict ( family = [string] , size = [number] , color = [string] ) ) } )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import typing [EOL] import sys [EOL] import time [EOL] [EOL] import airflow [EOL] from airflow . models import DAG [EOL] from airflow . operators . python_operator import PythonOperator [EOL] [EOL] try : [EOL] from DataGetters . reddit_task import main [EOL] except ImportError : [EOL] import os [EOL] sys . path . append ( os . getcwd ( ) ) [EOL] from DataGetters . reddit_task import main [EOL] [EOL] args = { [string] : [string] , [string] : airflow . utils . dates . days_ago ( [number] ) } [EOL] [EOL] dag = DAG ( dag_id = [string] , default_args = args , schedule_interval = [string] ) [EOL] [EOL] run_this = PythonOperator ( task_id = [string] , provide_context = True , python_callable = main , dag = dag ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
	0