from typing import Literal , Union [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] [EOL] from invoke import task [EOL] [EOL] @ task def install ( ctx , develop = True , pty = True ) : [EOL] ctx . run ( [string] ) [EOL] ctx . run ( [string] ) [EOL] req_file = [string] if develop else [string] [EOL] cmd = [string] . format ( req_file ) [EOL] ctx . run ( cmd , pty = pty ) [EOL] cmd = [string] . format ( [string] ) [EOL] ctx . run ( cmd , pty = pty ) [EOL] [EOL] [EOL] @ task def flake ( ctx ) : [EOL] [docstring] [EOL] ctx . run ( [string] , pty = True ) [EOL] [EOL] [EOL] @ task def mypy ( ctx ) : [EOL] [docstring] [EOL] ctx . run ( [string] , pty = True ) [EOL] [EOL] [EOL] @ task def test ( ctx ) : [EOL] cmd = [string] [EOL] ctx . run ( cmd , pty = True ) [EOL] [EOL] @ task def rabbitmq ( ctx ) : [EOL] ctx . run ( [string] , pty = True ) [EOL] [EOL] [EOL] @ task def server ( ctx ) : [EOL] ctx . run ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import json [EOL] import aiohttp [EOL] from aiohttp . web import Response [EOL] [EOL] def json_resp ( json_data , status = [number] ) : [EOL] return Response ( body = json . dumps ( json_data . copy ( ) ) , headers = { [string] : [string] } , status = status ) [EOL] [EOL] def data_resp ( raw_data , status = [number] ) : [EOL] return Response ( body = raw_data , status = status ) [EOL] [EOL] def empty_resp ( status = [number] ) : [EOL] return Response ( body = aiohttp . streams . EmptyStreamReader ( ) , status = status ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Any , Iterator [EOL] import typing [EOL] import pytest [EOL] import hashlib [EOL] [EOL] class FileMetadataTests : [EOL] [EOL] def test_file ( self , provider , file ) : [EOL] [EOL] assert file . provider == provider . name [EOL] assert isinstance ( file , provider . Item ) [EOL] [EOL] assert file . is_file is True [EOL] assert file . is_folder is False [EOL] assert file . is_root is False [EOL] assert file . kind == [string] [EOL] assert file . name == [string] [EOL] assert file . mimetype == [string] [EOL] assert file . unix_path == [string] [EOL] [EOL] def test_folder ( self , provider , folder ) : [EOL] [EOL] assert folder . provider == provider . name [EOL] assert isinstance ( folder , provider . Item ) [EOL] [EOL] assert folder . is_file is False [EOL] assert folder . is_folder is True [EOL] assert folder . is_root is False [EOL] assert folder . kind == [string] [EOL] assert folder . name == [string] [EOL] assert folder . mimetype is None [EOL] assert folder . unix_path == [string] [EOL] [EOL] def test_root ( self , provider , root ) : [EOL] [EOL] assert root . is_file is False [EOL] assert root . is_folder is True [EOL] assert root . is_root is True [EOL] assert root . kind == [string] [EOL] assert root . name == [string] [EOL] assert root . mimetype is None [EOL] assert root . unix_path == [string] [EOL] [EOL] def test_version ( self , provider , versions ) : [EOL] versions = reversed ( versions ) [comment] [EOL] for ind , file in enumerate ( versions , start = [number] ) : [EOL] assert file . provider == provider . name [EOL] assert isinstance ( file , provider . Item ) [EOL] [EOL] assert file . is_file is True [EOL] assert file . is_folder is False [EOL] assert file . is_root is False [EOL] assert file . kind == [string] [EOL] assert file . name == [string] [EOL] assert file . mimetype == [string] [EOL] assert file . unix_path == [string] [EOL] assert file . version_id == str ( ind ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from http import HTTPStatus [EOL] from aiohttp . web import HTTPException [EOL] [EOL] DEFAULT_ERROR_MSG = [string] [EOL] [EOL] [EOL] class WaterButlerError ( HTTPException ) : [EOL] [EOL] def __init__ ( self , message ) : [EOL] self . message = message [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . __class__ . __name__ , self . code , self . message ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . code , self . message ) [EOL] [EOL] [EOL] class InvalidParameters ( WaterButlerError ) : [EOL] [docstring] [EOL] code = [number] [EOL] [EOL] class UnsupportedHTTPMethodError ( WaterButlerError ) : [EOL] [docstring] [EOL] def __init__ ( self , method , supported = None ) : [EOL] [EOL] if supported is None : [EOL] supported_methods = [string] [EOL] else : [EOL] supported_methods = [string] . join ( list ( supported ) ) . upper ( ) [EOL] [EOL] super ( ) . __init__ ( [string] [string] . format ( method , supported_methods ) , code = HTTPStatus . METHOD_NOT_ALLOWED , is_user_error = True ) [EOL] [EOL] [EOL] class PluginError ( WaterButlerError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] class InvalidPathError ( PluginError ) : [EOL] status = [number] [EOL] [EOL] class AuthError ( PluginError ) : [EOL] status = [number] [EOL] [EOL] class Forbidden ( PluginError ) : [EOL] status = [number] [EOL] [EOL] class NotFoundError ( PluginError ) : [EOL] [EOL] def __init__ ( self , filename ) : [EOL] self . message = f' [string] { filename } [string] ' [EOL] status = [number] [EOL] [EOL] class Conflict ( PluginError ) : [EOL] status = [number] [EOL] [EOL] [EOL] class Gone ( PluginError ) : [EOL] status = [number] [EOL] [EOL] class ProviderError ( PluginError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class UnhandledProviderError ( ProviderError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class CopyError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL] [EOL] class CreateFolderError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL] [EOL] class DeleteError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL] [EOL] class DownloadError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL] [EOL] class IntraCopyError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL] [EOL] class IntraMoveError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL] [EOL] class MoveError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL] [EOL] class MetadataError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL] [EOL] class RevisionsError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL] [EOL] class UploadError ( UnhandledProviderError ) : [EOL] pass [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import abc [EOL] from enum import Enum [EOL] [EOL] [EOL] class AuthType ( Enum ) : [EOL] SOURCE = [number] [EOL] DESTINATION = [number] [EOL] [EOL] [EOL] class BaseAuthHandler ( metaclass = abc . ABCMeta ) : [EOL] [EOL] @ abc . abstractmethod async def fetch ( self , request , bundle ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod async def get ( self , resource , provider , request , action = None , auth_type = AuthType . SOURCE ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Any , Literal , Dict [EOL] import typing_extensions [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import abc [EOL] import hashlib [EOL] import mimetypes [EOL] from urllib . parse import urlparse , quote [EOL] [EOL] from aquavalet import settings [EOL] [EOL] [EOL] class BaseMetadata ( metaclass = abc . ABCMeta ) : [EOL] def __init__ ( self , attributes ) : [EOL] self . attributes = attributes . copy ( ) [EOL] self . default_segments = [ self . provider ] [EOL] [EOL] def serialized ( self ) : [EOL] [EOL] _ , ext = os . path . splitext ( self . name ) [EOL] return { [string] : self . kind , [string] : self . name , [string] : self . id , [string] : self . size , [string] : self . modified , [string] : mimetypes . types_map . get ( ext ) , [string] : self . provider , [string] : hashlib . sha256 ( [string] . format ( self . provider , self . etag ) . encode ( [string] ) ) . hexdigest ( ) , } [EOL] [EOL] def json_api_serialized ( self ) : [EOL] json_api = { [string] : self . id , [string] : [string] , [string] : self . serialized ( ) , [string] : self . _json_api_links ( ) , } [EOL] return json_api [EOL] [EOL] def _json_api_links ( self ) : [EOL] actions = { } [EOL] path_segments = [ quote ( seg ) for seg in self . attributes [ [string] ] . split ( [string] ) if seg ] [EOL] [EOL] actions [ [string] ] = self . construct_path ( path_segments , [string] ) [EOL] actions [ [string] ] = self . construct_path ( path_segments , [string] ) [EOL] [EOL] if self . kind == [string] : [EOL] actions [ [string] ] = self . construct_path ( path_segments , [string] ) [EOL] actions [ [string] ] = self . construct_path ( path_segments , [string] ) [EOL] actions [ [string] ] = self . construct_path ( path_segments , [string] ) [EOL] else : [EOL] actions [ [string] ] = self . construct_path ( path_segments , [string] ) [EOL] [EOL] return actions [EOL] [EOL] def construct_path ( self , path , action ) : [EOL] segments = self . default_segments + path [EOL] trailing_slash = [string] if self . kind == [string] or not path else [string] [EOL] return urlparse ( settings . DOMAIN + [string] + [string] . join ( segments ) + trailing_slash + [string] + action ) . geturl ( ) [EOL] [EOL] @ property @ abc . abstractmethod def provider ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] @ property @ abc . abstractmethod def kind ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] @ property @ abc . abstractmethod def name ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] @ property def etag ( self ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
	0
import builtins [EOL] from typing import Any , Type [EOL] import aquavalet [EOL] import typing [EOL] import abc [EOL] import asyncio [EOL] [EOL] [EOL] class BaseStream ( asyncio . StreamReader , metaclass = abc . ABCMeta ) : [EOL] [EOL] CHUNK_SIZE = [number] * [number] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . readers = { } [EOL] self . writers = { } [EOL] [EOL] @ abc . abstractmethod def size ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def add_reader ( self , name , reader ) : [EOL] self . readers [ name ] = reader [EOL] [EOL] def remove_reader ( self , name ) : [EOL] del self . readers [ name ] [EOL] [EOL] def add_writer ( self , name , writer ) : [EOL] self . writers [ name ] = writer [EOL] [EOL] def remove_writer ( self , name ) : [EOL] del self . writers [ name ] [EOL] [EOL] def feed_eof ( self ) : [EOL] super ( ) . feed_eof ( ) [EOL] for reader in self . readers . values ( ) : [EOL] reader . feed_eof ( ) [EOL] for writer in self . writers . values ( ) : [EOL] if hasattr ( writer , [string] ) and writer . can_write_eof ( ) : [EOL] writer . write_eof ( ) [EOL] [EOL] async def read ( self , size = - [number] ) : [EOL] eof = self . at_eof ( ) [EOL] data = await self . _read ( size ) [EOL] if not eof : [EOL] for reader in self . readers . values ( ) : [EOL] reader . feed_data ( data ) [EOL] for writer in self . writers . values ( ) : [EOL] writer . write ( data ) [EOL] return data [EOL] [EOL] @ abc . abstractmethod async def _read ( self , size ) : [EOL] pass [EOL] [EOL] def __aiter__ ( self ) : [EOL] return self [EOL] [EOL] async def __anext__ ( self ) : [EOL] chunk = await self . read ( self . CHUNK_SIZE ) [EOL] if not chunk : [EOL] raise StopAsyncIteration ( ) [EOL] return chunk [EOL] [EOL] [EOL] class MultiStream ( asyncio . StreamReader ) : [EOL] [docstring] [EOL] def __init__ ( self , * streams ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _size = [number] [EOL] self . stream = [ ] [EOL] self . _streams = [ ] [EOL] [EOL] self . add_streams ( * streams ) [EOL] [EOL] @ property def size ( self ) : [EOL] return self . _size [EOL] [EOL] @ property def streams ( self ) : [EOL] return self . _streams [EOL] [EOL] def add_streams ( self , * streams ) : [EOL] self . _size += sum ( x . size for x in streams ) [EOL] self . _streams . extend ( streams ) [EOL] [EOL] if not self . stream : [EOL] self . _cycle ( ) [EOL] [EOL] async def read ( self , n = - [number] ) : [EOL] if n < [number] : [EOL] return ( await super ( ) . read ( n ) ) [EOL] [EOL] chunk = [string] [EOL] [EOL] while self . stream and ( len ( chunk ) < n or n == - [number] ) : [EOL] if n == - [number] : [EOL] chunk += await self . stream . read ( - [number] ) [EOL] else : [EOL] chunk += await self . stream . read ( n - len ( chunk ) ) [EOL] [EOL] if self . stream . at_eof ( ) : [EOL] self . _cycle ( ) [EOL] [EOL] return chunk [EOL] [EOL] def _cycle ( self ) : [EOL] try : [EOL] self . stream = self . streams . pop ( [number] ) [EOL] except IndexError : [EOL] self . stream = None [EOL] self . feed_eof ( ) [EOL] [EOL] [EOL] class StringStream ( BaseStream ) : [EOL] def __init__ ( self , data ) : [EOL] super ( ) . __init__ ( ) [EOL] if isinstance ( data , str ) : [EOL] data = data . encode ( [string] ) [EOL] elif not isinstance ( data , bytes ) : [EOL] raise TypeError ( [string] . format ( type ( data ) ) ) [EOL] [EOL] self . _size = len ( data ) [EOL] self . feed_data ( data ) [EOL] self . feed_eof ( ) [EOL] [EOL] @ property def size ( self ) : [EOL] return self . _size [EOL] [EOL] async def _read ( self , n = - [number] ) : [EOL] return ( await asyncio . StreamReader . read ( self , n ) ) [EOL] [EOL] [EOL] class EmptyStream ( BaseStream ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _eof = False [EOL] [EOL] def size ( self ) : [EOL] return [number] [EOL] [EOL] def at_eof ( self ) : [EOL] return self . _eof [EOL] [EOL] async def _read ( self , n ) : [EOL] self . _eof = True [EOL] return bytearray ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import uuid [EOL] import asyncio [EOL] [EOL] from aquavalet . streams . base import BaseStream , MultiStream , StringStream [EOL] [EOL] [EOL] class ResponseStreamReader ( BaseStream ) : [EOL] [EOL] def __init__ ( self , response , size = None , name = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _name = name [EOL] self . response = response [EOL] [EOL] @ property def partial ( self ) : [EOL] return self . response . status == [number] [EOL] [EOL] @ property def content_type ( self ) : [EOL] return self . response . headers . get ( [string] , [string] ) [EOL] [EOL] @ property def content_range ( self ) : [EOL] return self . size [EOL] [EOL] @ property def name ( self ) : [EOL] return self . _name [EOL] [EOL] @ property def size ( self ) : [EOL] return self . response . content . _size [EOL] [EOL] async def _read ( self , size ) : [EOL] chunk = await self . response . content . read ( size ) [EOL] if not chunk : [EOL] self . feed_eof ( ) [EOL] await self . response . release ( ) [EOL] [EOL] return chunk [EOL] [EOL] [EOL] class RequestStreamReader ( BaseStream ) : [EOL] [EOL] def __init__ ( self , request , reader ) : [EOL] super ( ) . __init__ ( ) [EOL] self . reader = reader [EOL] self . request = request [EOL] [EOL] @ property def size ( self ) : [EOL] return int ( self . request . headers . get ( [string] ) ) [EOL] [EOL] def at_eof ( self ) : [EOL] return self . reader . at_eof ( ) [EOL] [EOL] async def _read ( self , size ) : [EOL] if self . reader . at_eof ( ) : [EOL] return [string] [EOL] if size < [number] : [EOL] return await self . reader . read ( size ) [EOL] try : [EOL] return await self . reader . readexactly ( size ) [EOL] except asyncio . IncompleteReadError as e : [EOL] return e . partial [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Optional , Any , Match [EOL] import typing [EOL] import re [EOL] from aquavalet import exceptions [EOL] [EOL] [EOL] def require_group ( match , group_name , message = [string] ) : [EOL] groupdict = match . groupdict ( ) [EOL] group = groupdict . get ( group_name ) [EOL] if group : [EOL] return group [EOL] else : [EOL] raise exceptions . InvalidPathError ( message = message ) [EOL] [EOL] [EOL] def require_match ( pattern , string , message = [string] ) : [EOL] match = re . match ( pattern , string ) [EOL] if match : [EOL] return match [EOL] else : [EOL] raise exceptions . InvalidPathError ( message = message ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[EOL] from typing import Any , List , Dict [EOL] import typing [EOL] from aquavalet import settings , exceptions [EOL] [EOL] CORS_ACCEPT_HEADERS = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] CORS_EXPOSE_HEADERS = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] class BaseHandler ( object ) : [EOL] [EOL] @ classmethod def as_entry ( cls ) : [EOL] return ( cls . PATTERN , cls ) [EOL] [EOL] def write_error ( self , status_code , exc_info ) : [EOL] etype , exc , _ = exc_info [EOL] self . set_status ( int ( exc . code ) ) [EOL] finish_args = [ { [string] : exc . code , [string] : exc . message } ] [EOL] self . finish ( * finish_args ) [EOL] [EOL] def set_status ( self , code , reason = None ) : [EOL] return super ( ) . set_status ( code , reason ) [EOL] [EOL] def _cross_origin_is_allowed ( self ) : [EOL] if self . request . method == [string] : [EOL] return True [EOL] elif not self . request . cookies and self . request . headers . get ( [string] ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def _int_or_none ( val ) : [EOL] val = val . strip ( ) [EOL] if val == [string] : [EOL] return None [EOL] return int ( val ) [EOL] [EOL] def _parse_request_range ( range_header ) : [EOL] unit , _ , value = range_header . partition ( [string] ) [EOL] unit , value = unit . strip ( ) , value . strip ( ) [EOL] if unit != [string] : [EOL] return None [EOL] start_b , _ , end_b = value . partition ( [string] ) [EOL] try : [EOL] start = _int_or_none ( start_b ) [EOL] end = _int_or_none ( end_b ) [EOL] except ValueError : [EOL] return None [EOL] if end is not None : [EOL] if start is None : [EOL] if end != [number] : [EOL] start = - end [EOL] end = None [EOL] else : [EOL] end += [number] [EOL] return ( start , end ) [EOL] [EOL] def parse_request_range ( range_header ) : [EOL] request_range = _parse_request_range ( range_header ) [EOL] [EOL] if request_range is None : [EOL] return request_range [EOL] [EOL] start , end = request_range [EOL] if start is None or start < [number] : [EOL] return None [EOL] [EOL] if end is not None : [EOL] end -= [number] [EOL] if end < start : [EOL] return None [EOL] [EOL] return start , end [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Union [EOL] import typing [EOL] import logging . config [EOL] [EOL] ADDRESS = [string] [EOL] PORT = [number] [EOL] DOMAIN = [string] . format ( PORT ) [EOL] [EOL] DEBUG = True [EOL] [EOL] CHUNK_SIZE = [number] [comment] [EOL] DEFAULT_CONFLICT = [string] [EOL] CONCURRENT_OPS = [number] [EOL] [EOL] ROOT_PATTERN = [string] [EOL] [EOL] DEFAULT_FORMATTER = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] DEFAULT_LOGGING_CONFIG = { [string] : [number] , [string] : False , [string] : { [string] : DEFAULT_FORMATTER , } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } } , [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , [string] : False } } , [string] : { [string] : [string] , [string] : [ [string] ] } } [EOL] [EOL] logging . config . dictConfig ( DEFAULT_LOGGING_CONFIG ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] from . defaults import * [comment] [EOL] [EOL] try : [EOL] from . local import * [comment] [EOL] except ImportError as error : [EOL] raise ImportError ( [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . import defaults [EOL] [EOL] OSF_TOKEN = [string] [EOL] ARTIFACTS_TOKEN = [string] [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0