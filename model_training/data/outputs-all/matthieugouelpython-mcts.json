from typing import Any [EOL] import tictactoe [EOL] import typing [EOL] [docstring] [EOL] [EOL] import random [EOL] [EOL] from players import MCTS , Random [EOL] from tictactoe import TicTacToe [EOL] [EOL] [EOL] EPISODES = [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] game = TicTacToe ( ) [EOL] players = [ MCTS ( game , [string] ) , Random ( game , [string] ) ] [EOL] [EOL] for _ in range ( EPISODES ) : [EOL] [EOL] observation = game . reset ( ) [EOL] random . shuffle ( players ) [EOL] [EOL] while True : [EOL] for current_player in players : [EOL] action = current_player . act ( observation ) [EOL] observation , _ , done , player = game . step ( current_player . token , action ) [EOL] [EOL] if done : [EOL] for p in players : [EOL] if player == p . token : [EOL] p . score [ [string] ] += [number] [EOL] elif player is None : [EOL] p . score [ [string] ] += [number] [EOL] else : [EOL] p . score [ [string] ] += [number] [EOL] break [EOL] else : [EOL] continue [EOL] break [EOL] [EOL] [comment] [EOL] print ( players ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $tictactoe.TicTacToe$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $tictactoe.TicTacToe$ 0 0 0 0 0 0 $tictactoe.TicTacToe$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $tictactoe.TicTacToe$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tictactoe.TicTacToe$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , List [EOL] import mcts [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [EOL] import datetime [EOL] import numpy as np [EOL] import pickle [EOL] import random [EOL] [EOL] [EOL] class State ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , game , observation , reward , done , player ) : [EOL] [docstring] [EOL] self . identifier = game . state ( observation , player ) [EOL] self . observation = observation [EOL] self . reward = reward [EOL] self . done = done [EOL] self . player = player [EOL] self . next_nodes = [ Node ( action ) for action in game . actions ( observation ) ] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . identifier == other . identifier [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . id [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . player } [string] { self . next_nodes } [string] " [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] [EOL] class Node ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , action , state = None , parent = None ) : [EOL] [docstring] [EOL] self . action = action [EOL] self . state = state [EOL] self . parent = parent [EOL] [EOL] self . visit_count = [number] [EOL] self . accumulated_reward = [number] [EOL] [EOL] @ property def is_evaluated ( self ) : [EOL] [docstring] [EOL] return bool ( self . state ) [EOL] [EOL] @ property def is_expanded ( self ) : [EOL] [docstring] [EOL] return all ( [ action . is_evaluated for action in self . state . next_nodes ] ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . state == other . state [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . visit_count } [string] { self . accumulated_reward } [string] { self . state } [string] " [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] [EOL] class MCTS ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , game , player , budget = [number] ) : [EOL] [docstring] [EOL] self . game = game . clone ( ) [EOL] self . player = player [EOL] self . budget = datetime . timedelta ( seconds = budget ) [EOL] self . tree = { } [EOL] [EOL] def register ( self , node ) : [EOL] [docstring] [EOL] self . tree [ self . game . state ( node . state . observation , node . state . player ) ] = node [EOL] [EOL] def randomax ( self , elements , key = None ) : [EOL] [docstring] [EOL] if key is None : [EOL] return max ( elements ) [EOL] [EOL] candidates = [ ] [EOL] best_value = None [EOL] for element in elements : [EOL] value = key ( element ) [EOL] if best_value is None : [EOL] best_value = value [EOL] if value > best_value : [EOL] best_value = value [EOL] candidates = [ element ] [EOL] if value == best_value : [EOL] candidates . append ( element ) [EOL] return random . choice ( candidates ) [EOL] [EOL] def act ( self , observation ) : [EOL] [docstring] [EOL] root_state = State ( self . game , observation , [number] , False , self . player ) [EOL] root_node = self . tree . get ( self . game . state ( root_state . observation , root_state . player ) ) [EOL] if not root_node : [EOL] root_node = Node ( None , state = root_state , parent = None ) [EOL] self . register ( root_node ) [EOL] [EOL] begin = datetime . datetime . now ( ) [EOL] while datetime . datetime . now ( ) - begin < self . budget : [EOL] self . run ( root_node , observation ) [EOL] return self . play ( root_node ) [EOL] [EOL] def run ( self , root_node , observation ) : [EOL] [docstring] [EOL] [comment] [EOL] parent_node , selected_node = self . selection ( root_node ) [EOL] [EOL] [comment] [EOL] self . expansion ( parent_node , selected_node ) [EOL] [EOL] [comment] [EOL] winner , reward = self . simulation ( selected_node ) [EOL] [EOL] [comment] [EOL] self . backpropagation ( selected_node , root_node , winner , reward ) [EOL] [EOL] def UCB1 ( self , node , c = [number] ) : [EOL] [docstring] [EOL] return ( node . accumulated_reward / node . visit_count ) + c * np . sqrt ( np . log ( node . parent . visit_count ) / node . visit_count ) [EOL] [EOL] def selection ( self , node ) : [EOL] [docstring] [EOL] while not node . state . done and node . is_expanded : [EOL] node = self . randomax ( node . state . next_nodes , key = lambda x : self . UCB1 ( x ) ) [EOL] [EOL] if node . state . done : [EOL] return node . parent , node [EOL] [EOL] return ( node , random . choice ( [ node for node in node . state . next_nodes if not node . is_evaluated ] ) , ) [EOL] [EOL] def expansion ( self , node , next_node ) : [EOL] [docstring] [EOL] if next_node . state is not None : [EOL] return next_node [EOL] [EOL] self . game . reset ( node . state . player , node . state . observation ) [EOL] observation , reward , done , player = self . game . step ( node . state . player , next_node . action ) [EOL] next_node . state = State ( self . game , observation , reward , done , player ) [EOL] next_node . parent = node [EOL] [EOL] self . register ( next_node ) [EOL] return next_node [EOL] [EOL] def simulation ( self , node ) : [EOL] [docstring] [EOL] observation = node . state . observation [EOL] reward = node . state . reward [EOL] done = node . state . done [EOL] player = node . state . player [EOL] [EOL] while not done : [EOL] [EOL] observation , reward , done , player = self . game . step ( player , random . choice ( self . game . actions ( observation ) ) ) [EOL] [EOL] return player , reward [EOL] [EOL] def backpropagation ( self , node , root_node , winner , reward ) : [EOL] [docstring] [EOL] if winner is None : [EOL] winner = random . choice ( self . game . players ) [EOL] [EOL] while node != root_node : [EOL] node . visit_count += [number] [EOL] if node . parent . state . player == winner : [EOL] node . accumulated_reward += reward [EOL] else : [EOL] node . accumulated_reward -= reward [EOL] [EOL] node = node . parent [EOL] [EOL] def play ( self , root_node ) : [EOL] [docstring] [EOL] next_node = self . randomax ( root_node . state . next_nodes , key = lambda x : x . visit_count ) [EOL] return next_node . action [EOL] [EOL] def dumps ( self , filename = [string] ) : [EOL] [docstring] [EOL] pickle . dump ( self . tree , open ( filename , [string] ) ) [EOL] [EOL] def loads ( self , filename = [string] ) : [EOL] [docstring] [EOL] self . tree = pickle . load ( open ( filename , [string] ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . tree ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mcts.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mcts.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $mcts.State$ 0 0 0 $mcts.State$ 0 0 0 0 0 0 0 $mcts.Node$ 0 0 $mcts.Node$ 0 0 0 0 0 0 0 $mcts.State$ 0 0 0 0 0 0 0 0 0 0 $mcts.Node$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $mcts.Node$ 0 0 0 0 0 0 0 0 0 $mcts.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , List [EOL] import builtins [EOL] import typing [EOL] import xxhash [EOL] [docstring] [EOL] [EOL] import copy [EOL] import numpy as np [EOL] import random [EOL] import xxhash [EOL] [EOL] from typing import Optional [EOL] [EOL] [EOL] class GameError ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class FixedTupleSpace ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , size , depth ) : [EOL] [docstring] [EOL] self . space = ( [ i for i in range ( depth ) ] , ) * size [EOL] [EOL] def sample ( self ) : [EOL] [docstring] [EOL] return tuple ( random . choice ( d ) for d in self . space ) [EOL] [EOL] [EOL] class TicTacToe ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , size = [number] ) : [EOL] [docstring] [EOL] self . size = size [EOL] self . reset ( ) [EOL] self . players = [ [string] , [string] ] [EOL] self . current_player = None [EOL] [EOL] def reset ( self , custom_current_player = None , custom_start = None ) : [EOL] [docstring] [EOL] self . current_player = custom_current_player [EOL] self . observation_space = ( np . copy ( custom_start ) [EOL] if custom_start is not None [EOL] else np . full ( ( self . size , ) * [number] , None ) ) [EOL] self . action_space = FixedTupleSpace ( [number] , self . size ) [EOL] return self . observation_space [EOL] [EOL] def clone ( self ) : [EOL] [docstring] [EOL] return copy . deepcopy ( self ) [EOL] [EOL] def step ( self , player , move ) : [EOL] [docstring] [EOL] if player not in self . players : [EOL] raise GameError ( [string] ) [EOL] [EOL] if self . current_player is not None and player != self . current_player : [EOL] raise GameError ( f" [string] { player } [string] " ) [EOL] [EOL] if move is None or len ( move ) != [number] : [EOL] raise GameError ( f"{ player } [string] " ) [EOL] [EOL] try : [EOL] if self . observation_space [ move [ [number] ] ] [ move [ [number] ] ] : [EOL] raise GameError ( [string] ) [EOL] except IndexError : [EOL] raise GameError ( [string] ) [EOL] [EOL] self . observation_space [ move [ [number] ] ] [ move [ [number] ] ] = player [EOL] [EOL] if self . is_winner ( player ) : [EOL] done = True [EOL] reward = [number] [EOL] info = player [EOL] elif self . is_finished : [EOL] done = True [EOL] reward = [number] [EOL] info = None [comment] [EOL] else : [EOL] done = False [EOL] reward = [number] [EOL] info = self . _switch_player ( player ) [EOL] [EOL] self . current_player = info [EOL] return np . copy ( self . observation_space ) , reward , done , info [EOL] [EOL] def state ( self , observation , player ) : [EOL] [docstring] [EOL] h = xxhash . xxh64 ( ) [EOL] state = np . copy ( observation ) [EOL] state [ state == player ] = [number] [EOL] state [ state == self . _switch_player ( player ) ] = - [number] [EOL] state [ state == None ] = [number] [comment] [EOL] h . update ( state ) [EOL] return h . intdigest ( ) [EOL] [EOL] def actions ( self , observation ) : [EOL] [docstring] [EOL] return [ ( i , j ) for i , j in zip ( * np . where ( observation == None ) ) ] [comment] [EOL] [EOL] @ property def is_finished ( self ) : [EOL] [docstring] [EOL] return None not in self . observation_space [EOL] [EOL] def is_winner ( self , token ) : [EOL] [docstring] [EOL] [EOL] def check ( array , token ) : [EOL] [docstring] [EOL] return np . count_nonzero ( array == token ) == self . size [EOL] [EOL] for i in range ( self . size ) : [EOL] if check ( self . observation_space [ i , : ] , token ) : [EOL] return True [EOL] if check ( self . observation_space [ : , i ] , token ) : [EOL] return True [EOL] if check ( self . observation_space . diagonal ( ) , token ) : [EOL] return True [EOL] if check ( self . observation_space [ : , : : - [number] ] . diagonal ( ) , token ) : [EOL] return True [EOL] return False [EOL] [EOL] def _switch_player ( self , player ) : [EOL] [docstring] [EOL] return [ p for p in self . players if p != player ] [ [number] ] [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return str ( self . observation_space ) [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return self . __str__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.tuple$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $xxhash.xxh64$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $xxhash.xxh64$ 0 0 0 $typing.Any$ 0 0 0 $xxhash.xxh64$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple , Dict [EOL] import builtins [EOL] import typing [EOL] import mcts [EOL] [docstring] [EOL] [EOL] import mcts [EOL] import numpy as np [EOL] import random [EOL] [EOL] from abc import ABC , abstractmethod [EOL] [EOL] [EOL] class BasePlayer ( ABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , game , token ) : [EOL] [docstring] [EOL] self . game = game [EOL] self . token = token [EOL] self . score = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] @ abstractmethod def act ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return str ( { self . token : self . score } ) [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return self . __str__ ( ) [EOL] [EOL] [EOL] class Iterate ( BasePlayer ) : [EOL] [docstring] [EOL] [EOL] def act ( self , observation ) : [EOL] [docstring] [EOL] for i in range ( observation . shape [ [number] ] ) : [EOL] for j in range ( observation . shape [ [number] ] ) : [EOL] if observation [ i ] [ j ] is None : [EOL] return ( i , j ) [EOL] [EOL] [EOL] class Random ( BasePlayer ) : [EOL] [docstring] [EOL] [EOL] def act ( self , observation ) : [EOL] [docstring] [EOL] candidates = [ ( i , j ) for i , j in zip ( * np . where ( observation == None ) ) ] [comment] [EOL] return random . choice ( candidates ) [EOL] [EOL] [EOL] class MCTS ( BasePlayer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . mcts = mcts . MCTS ( self . game , self . token , budget = [number] ) [EOL] [EOL] def act ( self , observation ) : [EOL] [docstring] [EOL] return self . mcts . act ( observation ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mcts.MCTS$ 0 $mcts.MCTS$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0