	0
from typing import Any [EOL] import typing [EOL] import trakt [EOL] import json [EOL] [EOL] import pytest [EOL] from tests . test_data . oauth import OAUTH_GET_TOKEN , OAUTH_VERIFICATION_CODE [EOL] from tests . utils import MockResponse , get_last_req , mk_mock_client [EOL] from trakt import Trakt , TraktCredentials [EOL] from trakt . core . components . oauth import CodeResponse [EOL] from trakt . core . exceptions import NotAuthenticated , TraktTimeoutError [EOL] [EOL] [EOL] def test_redirect_url ( ) : [EOL] client = Trakt ( [string] , [string] ) [EOL] [EOL] url = client . oauth . get_redirect_url ( ) [EOL] [EOL] exp_base = [string] [EOL] exp_args = [string] [EOL] assert url == exp_base + exp_args [EOL] [EOL] [EOL] def test_get_token ( ) : [EOL] client = mk_mock_client ( { [string] : [ OAUTH_GET_TOKEN , [number] ] } ) [EOL] trakt_credentials = client . oauth . get_token ( code = [string] , redirect_uri = [string] ) [EOL] [EOL] assert trakt_credentials . access_token == OAUTH_GET_TOKEN [ [string] ] [EOL] assert client . user [EOL] assert client . user . access_token == OAUTH_GET_TOKEN [ [string] ] [EOL] [EOL] [EOL] def test_revoke_token ( ) : [EOL] client = mk_mock_client ( { [string] : [ { } , [number] ] } , user = None ) [EOL] user = TraktCredentials ( [string] , [string] , [string] , [number] ) [EOL] [EOL] assert client . user is None [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . oauth . revoke_token ( ) [EOL] [EOL] client . set_user ( user ) [EOL] assert client . user [EOL] [EOL] client . oauth . revoke_token ( ) [EOL] assert client . user is None [EOL] [EOL] [EOL] def test_get_verification_code ( ) : [EOL] client = mk_mock_client ( { [string] : [ OAUTH_VERIFICATION_CODE , [number] ] } , client_id = [string] ) [EOL] [EOL] code = client . oauth . get_verification_code ( ) [EOL] assert code . device_code == OAUTH_VERIFICATION_CODE [ [string] ] [EOL] assert json . loads ( get_last_req ( client . http ) [ [string] ] ) [ [string] ] == [string] [EOL] [EOL] [EOL] def test_wait_for_response_success ( ) : [EOL] def pool_endpoint_responses ( ) : [EOL] yield MockResponse ( { } , [number] ) [EOL] yield MockResponse ( [ ] , [number] ) [EOL] yield MockResponse ( OAUTH_GET_TOKEN , [number] ) [EOL] [EOL] client = mk_mock_client ( { [string] : [ OAUTH_VERIFICATION_CODE , [number] ] , [string] : pool_endpoint_responses ( ) , } , user = None , ) [EOL] client . oauth . sleep = lambda t : None [EOL] [EOL] assert client . user is None [EOL] [EOL] code = client . oauth . get_verification_code ( ) [EOL] client . oauth . wait_for_verification ( code = code ) [EOL] [EOL] assert client . user [EOL] assert client . user . access_token == OAUTH_GET_TOKEN [ [string] ] [EOL] [EOL] requests_log = client . http . _requests . req_map [ [string] ] [EOL] assert len ( requests_log ) == [number] [EOL] [EOL] [EOL] def test_wait_for_response_timeout ( ) : [EOL] client = mk_mock_client ( { [string] : [ { } , [number] ] } ) [EOL] client . oauth . sleep = lambda t : None [EOL] [EOL] code = CodeResponse ( ** OAUTH_VERIFICATION_CODE ) [EOL] [EOL] with pytest . raises ( TraktTimeoutError ) : [EOL] client . oauth . wait_for_verification ( code = code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Union , Any [EOL] import typing [EOL] import trakt [EOL] import pytest [EOL] from tests . utils import MockRequests , mk_mock_client [EOL] from trakt import Trakt [EOL] from trakt . core . components import DefaultHttpComponent [EOL] from trakt . core . exceptions import BadRequest , RequestRelatedError [EOL] from trakt . core . executors import Executor [EOL] from trakt . core . paths . path import Path [EOL] [EOL] [EOL] def test_get_url ( ) : [EOL] client = Trakt ( [string] , [string] ) [EOL] [EOL] url = client . http . get_url ( [string] , { [string] : [string] } ) [EOL] [EOL] assert url == [string] [EOL] [EOL] [EOL] def test_bad_request_exception ( ) : [EOL] client = Trakt ( [string] , [string] ) [EOL] [EOL] http = DefaultHttpComponent ( client , requests_dependency = MockRequests ( { [string] : [ { } , [number] ] } ) ) [EOL] [EOL] with pytest . raises ( BadRequest ) : [EOL] http . request ( [string] ) [EOL] [EOL] [EOL] def test_extra_info_return ( ) : [EOL] client = Trakt ( [string] , [string] ) [EOL] [EOL] resp_headers = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] http = DefaultHttpComponent ( client , requests_dependency = MockRequests ( { [string] : [ { [string] : [string] } , [number] , resp_headers ] } ) , ) [EOL] [EOL] res = http . request ( [string] ) [EOL] [EOL] assert res . json == { [string] : [string] } [EOL] assert res . original . status_code == [number] [EOL] assert res . pagination [ [string] ] == [number] [EOL] assert res . pagination [ [string] ] == [number] [EOL] [EOL] [EOL] def test_add_quargs ( ) : [EOL] client = mk_mock_client ( { [string] : [ [ ] , [number] ] } ) [EOL] path = Path ( [string] , [ None ] , qargs = [ [string] ] ) [EOL] [EOL] executor = Executor ( client ) [EOL] [EOL] _ = executor . run ( path = path , arg = [string] ) [EOL] [EOL] req = client . http . _requests . req_map [ [string] ] [ [number] ] [EOL] [EOL] assert req [ [string] ] . endswith ( [string] ) [EOL] [EOL] [EOL] def test_unexpected_code ( ) : [EOL] client = mk_mock_client ( { [string] : [ [ ] , [number] ] } ) [EOL] [EOL] with pytest . raises ( RequestRelatedError ) : [EOL] client . networks . get_networks ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Set , List , Union [EOL] import tests [EOL] import typing [EOL] import trakt [EOL] import pytest [EOL] from trakt . core . exceptions import ArgumentError , NotAuthenticated [EOL] from trakt . core . paths import Path [EOL] from trakt . core . paths . validators import ( AuthRequiredValidator , ExtendedValidator , FiltersValidator , OptionalArgsValidator , PerArgValidator , RequiredArgsValidator , is_date , ) [EOL] [EOL] [EOL] class A : [EOL] pass [EOL] [EOL] [EOL] def test_auth_validator ( ) : [EOL] client = A ( ) [EOL] client . user = [string] [EOL] [EOL] assert AuthRequiredValidator ( ) . validate ( client = client ) is None [EOL] [EOL] client . user = None [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] AuthRequiredValidator ( ) . validate ( client = client ) [EOL] [EOL] [EOL] def test_required_args_validator ( ) : [EOL] p = Path ( [string] , { } ) [EOL] [EOL] assert RequiredArgsValidator ( ) . validate ( path = p , b = [string] , c = [string] ) is None [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] RequiredArgsValidator ( ) . validate ( path = p , c = [string] ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] RequiredArgsValidator ( ) . validate ( path = p , b = [string] ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] RequiredArgsValidator ( ) . validate ( path = p , d = [string] ) [EOL] [EOL] [EOL] def test_optional_args_validator ( ) : [EOL] p = Path ( [string] , { } ) [EOL] [EOL] assert OptionalArgsValidator ( ) . validate ( path = p ) is None [EOL] assert OptionalArgsValidator ( ) . validate ( path = p , b = [string] , c = [string] ) is None [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] OptionalArgsValidator ( ) . validate ( path = p , c = [string] ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] OptionalArgsValidator ( ) . validate ( path = p , b = [string] , d = [string] ) [EOL] [EOL] [EOL] def test_per_arg_validator ( ) : [EOL] b_validator = PerArgValidator ( [string] , lambda b : b in [ [string] , [string] ] ) [EOL] c_validator = PerArgValidator ( [string] , lambda c : [string] in c ) [EOL] p = Path ( [string] , { } , validators = [ b_validator , c_validator ] ) [EOL] [EOL] assert b_validator . validate ( path = p , b = [string] ) is None [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] b_validator . validate ( path = p , b = [string] ) [EOL] [EOL] assert c_validator . validate ( path = p , b = [string] ) is None [EOL] assert c_validator . validate ( path = p , b = [string] ) is None [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] c_validator . validate ( path = p , b = [string] , c = [string] ) [EOL] [EOL] [EOL] def test_extended_validator ( ) : [EOL] p = Path ( [string] , { } , extended = [ [string] , [string] ] ) [EOL] [EOL] assert ExtendedValidator ( ) . validate ( path = p , extended = [string] ) is None [EOL] assert ExtendedValidator ( ) . validate ( path = p , extended = [string] ) is None [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] ExtendedValidator ( ) . validate ( path = p , extended = [string] ) [EOL] [EOL] p = Path ( [string] , { } ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] ExtendedValidator ( ) . validate ( path = p , extended = [string] ) [EOL] [EOL] [EOL] def test_filters_validator ( ) : [EOL] p = Path ( [string] , { } , filters = { [string] , [string] , [string] , [string] } ) [EOL] [EOL] assert FiltersValidator ( ) . validate ( path = p ) is None [EOL] assert FiltersValidator ( ) . validate ( path = p , query = [string] ) is None [EOL] assert FiltersValidator ( ) . validate ( path = p , genres = [string] ) is None [EOL] assert FiltersValidator ( ) . validate ( path = p , genres = [ [string] , [string] ] ) is None [EOL] assert FiltersValidator ( ) . validate ( path = p , years = [number] ) is None [EOL] assert FiltersValidator ( ) . validate ( path = p , years = [string] ) is None [EOL] assert FiltersValidator ( ) . validate ( path = p , years = [string] ) is None [EOL] assert FiltersValidator ( ) . validate ( path = p , ratings = [string] ) is None [EOL] [EOL] should_raise = { [string] : [ [string] ] , [string] : [ [ [string] , [string] ] ] , [string] : [ [string] , [string] , [string] , [string] , [number] ] , [string] : [ { [string] } , [ [string] , [number] ] ] , [string] : [ [string] ] , } [EOL] [EOL] for k , v_list in should_raise . items ( ) : [EOL] for v in v_list : [EOL] with pytest . raises ( ArgumentError ) : [EOL] FiltersValidator ( ) . validate ( path = p , ** { k : v } ) [EOL] [EOL] [EOL] def test_is_date ( ) : [EOL] assert is_date ( [string] ) [EOL] assert not is_date ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict [EOL] import typing [EOL] import trakt [EOL] import pytest [EOL] from trakt import Trakt [EOL] from trakt . core . exceptions import ArgumentError [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . validators import PerArgValidator [EOL] [EOL] [EOL] def test_aliases ( ) : [EOL] p = Path ( [string] , { } , aliases = [ [string] , [string] ] ) [EOL] [EOL] assert p . does_match ( [string] ) [EOL] assert p . does_match ( [string] ) [EOL] assert not p . does_match ( [string] ) [EOL] [EOL] [EOL] def test_optional_args ( ) : [EOL] client = Trakt ( [string] , [string] ) [EOL] [EOL] p = Path ( [string] , [ { [string] : str } ] ) [EOL] [EOL] assert p . methods == [ [string] ] [EOL] assert p . args == [ [string] , [string] ] [EOL] [EOL] default_alias = [string] [EOL] [EOL] assert p . aliases == [ default_alias ] [EOL] assert p . does_match ( default_alias ) [EOL] assert not p . does_match ( default_alias [ [number] : ] ) [EOL] [EOL] assert p . is_valid ( client ) [EOL] assert p . get_path_and_qargs ( ) == ( [string] , { } ) [EOL] [EOL] assert p . is_valid ( client , start_date = [string] ) [EOL] assert p . get_path_and_qargs ( ) == ( [string] , { } ) [EOL] [EOL] [EOL] def test_required_args ( ) : [EOL] client = Trakt ( [string] , [string] ) [EOL] [EOL] p = Path ( [string] , [ { [string] : str } ] ) [EOL] [EOL] assert p . methods == [ [string] ] [EOL] assert p . args == [ [string] , [string] ] [EOL] [EOL] default_alias = [string] [EOL] [EOL] assert p . aliases == [ default_alias ] [EOL] assert p . does_match ( default_alias ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] p . is_valid ( client ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [comment] [EOL] p . is_valid ( client ) [EOL] [EOL] assert p . is_valid ( client , b = [number] ) [EOL] assert p . get_path_and_qargs ( ) == ( [string] , { } ) [EOL] [EOL] [EOL] def test_extended ( ) : [EOL] client = Trakt ( [string] , [string] ) [EOL] [EOL] p = Path ( [string] , { } , extended = [ [string] ] ) [EOL] [EOL] assert p . is_valid ( client ) [EOL] assert p . is_valid ( client , extended = [string] ) [EOL] assert p . is_valid ( client , extended = True ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] p . is_valid ( client , extended = [string] ) [EOL] [EOL] p . is_valid ( client , extended = True ) [EOL] _ , quargs = p . get_path_and_qargs ( ) [EOL] assert [string] in quargs and quargs [ [string] ] == [string] [EOL] [EOL] p = Path ( [string] , { } ) [EOL] p . is_valid ( client ) [EOL] _ , quargs = p . get_path_and_qargs ( ) [EOL] assert [string] not in quargs [EOL] [EOL] [EOL] def test_filters ( ) : [EOL] client = Trakt ( [string] , [string] ) [EOL] p = Path ( [string] , { } ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] p . is_valid ( client , genres = [string] ) [EOL] [EOL] p = Path ( [string] , { } , filters = { [string] , [string] } ) [EOL] [EOL] assert p . is_valid ( client , query = [string] ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] p . is_valid ( client , query = [ [string] , [string] ] ) [EOL] [EOL] assert p . is_valid ( client , genres = [string] ) [EOL] assert p . is_valid ( client , genres = [ [string] , [string] ] ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] p . is_valid ( client , query = [ [number] , [string] ] ) [EOL] [EOL] [EOL] def test_get_quargs ( ) : [EOL] client = Trakt ( [string] , [string] ) [EOL] p = Path ( [string] , { } , filters = { [string] , [string] } , extended = [ [string] ] ) [EOL] [EOL] assert p . is_valid ( client , extended = True , query = [string] , genres = [ [string] , [string] ] ) [EOL] [EOL] _ , quargs = p . get_path_and_qargs ( ) [EOL] [EOL] expected = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] assert quargs == expected [EOL] [EOL] [EOL] def test_multiple_validators_for_field ( ) : [EOL] p = Path ( [string] , { } , validators = [ PerArgValidator ( [string] , lambda x : x > [number] ) , PerArgValidator ( [string] , lambda x : x % [number] == [number] ) , ] , ) [EOL] [EOL] assert p . is_valid ( None , a = [number] ) [EOL] [EOL] for val in [ [number] , [number] ] : [EOL] with pytest . raises ( ArgumentError ) : [EOL] p . is_valid ( None , a = val ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List , Type , Any [EOL] import typing [EOL] import tests [EOL] from dataclasses import dataclass [EOL] from datetime import datetime [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] from tests . test_data . episodes import EPISODE , EXTENDED_EPISODE [EOL] from tests . test_data . lists import LIST , TRENDING_LISTS , USER [EOL] from tests . test_data . shows import EXTENDED_SHOW , SHOW [EOL] from trakt . core import json_parser [EOL] from trakt . core . exceptions import TraktResponseError [EOL] from trakt . core . models import Episode , Show , TraktList , User [EOL] from trakt . core . paths . response_structs import ListResponse [EOL] [EOL] [EOL] @ dataclass class MockClassName : [EOL] name = ... [EOL] [EOL] [EOL] @ dataclass class MockClassDateData : [EOL] date = ... [EOL] data = ... [EOL] [EOL] [EOL] def test_basic_list_dict ( ) : [EOL] data = [ [string] , [string] ] [EOL] tree_struct = [ str ] [EOL] [EOL] parsed = json_parser . parse_tree ( data , tree_struct ) [EOL] [EOL] assert parsed == [ [string] , [string] ] [EOL] [EOL] data = { [string] : [string] , [string] : [string] } [EOL] tree_struct = { [string] : str , [string] : str } [EOL] [EOL] parsed = json_parser . parse_tree ( data , tree_struct ) [EOL] [EOL] assert parsed == data [EOL] [EOL] [EOL] def test_dataclass ( ) : [EOL] data = { [string] : [string] } [EOL] tree_struct = MockClassName [EOL] [EOL] parsed = json_parser . parse_tree ( data , tree_struct ) [EOL] [EOL] assert parsed . __class__ == MockClassName [EOL] assert parsed . name == [string] [EOL] [EOL] data = [ { [string] : [string] } , { [string] : [string] } ] [EOL] tree_struct = [ MockClassName ] [EOL] [EOL] parsed = json_parser . parse_tree ( data , tree_struct ) [EOL] [EOL] assert parsed . __class__ == list [EOL] assert parsed [ [number] ] . __class__ == MockClassName [EOL] assert parsed [ [number] ] . name == [string] [EOL] [EOL] [EOL] def test_mixed_structure ( ) : [EOL] data = { [string] : [number] , [string] : [ { [string] : [string] , [string] : { [string] : [number] , [string] : { [string] : [string] } } } , { [string] : [string] , [string] : { [string] : [number] , [string] : { [string] : [string] } } } , ] , } [EOL] tree_struct = { [string] : int , [string] : [ { [string] : str , [string] : MockClassDateData } ] } [EOL] [EOL] parsed = json_parser . parse_tree ( data , tree_struct ) [EOL] [EOL] assert parsed . __class__ == dict [EOL] assert [string] in parsed and parsed [ [string] ] . __class__ == int [EOL] assert [string] in parsed and parsed [ [string] ] [ [number] ] . __class__ == dict [EOL] [EOL] item = parsed [ [string] ] [ [number] ] [EOL] [EOL] assert [string] in item and item [ [string] ] == [string] [EOL] assert [string] in item and item [ [string] ] . __class__ == MockClassDateData [EOL] assert item [ [string] ] . data . __class__ == MockClassName [EOL] [EOL] [EOL] def test_defaults ( ) : [EOL] data = { [string] : [string] } [EOL] tree_struct = { [string] : [string] , [string] : [string] } [EOL] [EOL] parsed = json_parser . parse_tree ( data , tree_struct ) [EOL] [EOL] assert parsed [ [string] ] == [string] [EOL] assert parsed [ [string] ] == [string] [EOL] assert json_parser . parse_tree ( data , { } ) == { } [EOL] [EOL] [EOL] def test_wildcards ( ) : [EOL] data = { [string] : [number] , [string] : [string] , [string] : [string] , True : [string] , [number] : [string] , [number] : [number] } [EOL] tree_struct = { [string] : int , str : str , float : Any } [EOL] [EOL] parsed = json_parser . parse_tree ( data , tree_struct ) [EOL] [EOL] assert parsed [ [string] ] == [number] [EOL] assert parsed [ [string] ] == [string] [EOL] assert parsed [ [string] ] == [string] [EOL] assert True not in parsed [EOL] assert parsed [ [number] ] == [string] [EOL] assert parsed [ [number] ] == [number] [EOL] [EOL] [EOL] def test_parser_nofail ( ) : [EOL] ep = json_parser . parse_tree ( EPISODE , Episode ) [EOL] epex = json_parser . parse_tree ( EXTENDED_EPISODE , Episode ) [EOL] [EOL] sh = json_parser . parse_tree ( SHOW , Show ) [EOL] shex = json_parser . parse_tree ( EXTENDED_SHOW , Show ) [EOL] [EOL] l = json_parser . parse_tree ( LIST , TraktList ) [EOL] tl = json_parser . parse_tree ( TRENDING_LISTS , [ ListResponse ] ) [EOL] [EOL] u = json_parser . parse_tree ( USER , User ) [EOL] [EOL] [EOL] def test_parser_datetime ( ) : [EOL] show = json_parser . parse_tree ( EXTENDED_SHOW , Show ) [EOL] [EOL] assert isinstance ( show . first_aired , datetime ) [EOL] assert show . first_aired == datetime . strptime ( EXTENDED_SHOW [ [string] ] [ : - [number] ] + [string] , [string] ) [EOL] [EOL] [EOL] def test_parser_default_none ( ) : [EOL] show = json_parser . parse_tree ( EXTENDED_SHOW , Show ) [EOL] [EOL] assert show . country == [string] [EOL] assert show . trailer is None [EOL] [EOL] [EOL] def test_parser_invalid_structure ( ) : [EOL] with pytest . raises ( TraktResponseError ) : [EOL] json_parser . parse_tree ( [ { [string] : [string] } ] , Show ) [EOL] [EOL] [EOL] def test_empty_resp ( ) : [EOL] data_list = json_parser . parse_tree ( [ ] , [ ] ) [EOL] data_dict = json_parser . parse_tree ( { } , { } ) [EOL] [EOL] assert data_dict == { } [EOL] assert data_list == [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $MockClassName$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pytest [EOL] from tests . test_data . certifications import CERTIFICATIONS [EOL] from tests . test_data . countries import COUNTRIES [EOL] from tests . test_data . genres import GENRES [EOL] from tests . test_data . languages import LANGUAGES [EOL] from tests . test_data . lists import TRENDING_LISTS [EOL] from tests . test_data . networks import NETWORKS [EOL] from tests . utils import mk_mock_client [EOL] from trakt . core . exceptions import ArgumentError [EOL] [EOL] [EOL] def test_countries ( ) : [EOL] client = mk_mock_client ( { [string] : [ COUNTRIES , [number] ] } ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . countries . get_countries ( type = [string] ) [EOL] [EOL] countries = client . countries . get_countries ( type = [string] ) [EOL] [EOL] assert countries [ [number] ] . code == COUNTRIES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_certifications ( ) : [EOL] client = mk_mock_client ( { [string] : [ CERTIFICATIONS , [number] ] } ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . certifications . get_certifications ( type = [string] ) [EOL] [EOL] certifications = client . certifications . get_certifications ( type = [string] ) [EOL] [EOL] assert certifications [ [number] ] . slug == CERTIFICATIONS [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_genres ( ) : [EOL] client = mk_mock_client ( { [string] : [ GENRES , [number] ] } ) [EOL] genres = client . genres . get_genres ( type = [string] ) [EOL] assert genres [ [number] ] . name == GENRES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_languages ( ) : [EOL] client = mk_mock_client ( { [string] : [ LANGUAGES , [number] ] } ) [EOL] languages = client . languages . get_languages ( type = [string] ) [EOL] assert languages [ [number] ] . name == LANGUAGES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_lists ( ) : [EOL] resp = [ TRENDING_LISTS , [number] , { [string] : [number] } ] [EOL] client = mk_mock_client ( { [string] : resp } ) [EOL] [EOL] tre = list ( client . lists . get_trending ( ) ) [EOL] pop = list ( client . lists . get_popular ( ) ) [EOL] assert tre [ [number] ] . like_count == pop [ [number] ] . like_count == TRENDING_LISTS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_networks ( ) : [EOL] client = mk_mock_client ( { [string] : [ NETWORKS , [number] ] } ) [EOL] networks = client . networks . get_networks ( ) [EOL] assert networks [ [number] ] . name == NETWORKS [ [number] ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pytest [EOL] from tests . test_data . lists import LIST [EOL] from tests . test_data . people import MOVIE_CREDITS , PERSON , SHOW_CREDITS [EOL] from tests . utils import mk_mock_client [EOL] from trakt . core . exceptions import ArgumentError [EOL] from trakt . core . json_parser import parse_tree [EOL] from trakt . core . models import Person [EOL] [EOL] [EOL] def test_get_person ( ) : [EOL] client = mk_mock_client ( { [string] : [ PERSON , [number] ] } ) [EOL] person = parse_tree ( PERSON , Person ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . people . get_person ( person = [number] ) [EOL] [EOL] assert client . people . get_person ( person = person . ids . trakt ) . name == PERSON [ [string] ] [EOL] assert client . people . get_person ( person = person ) . name == PERSON [ [string] ] [EOL] [EOL] [EOL] def test_get_movie_credits ( ) : [EOL] client = mk_mock_client ( { [string] : [ MOVIE_CREDITS , [number] ] } ) [EOL] [EOL] credits = client . people . get_movie_credits ( person = [number] ) [EOL] assert credits . cast [ [number] ] . character == MOVIE_CREDITS [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_get_show_credits ( ) : [EOL] client = mk_mock_client ( { [string] : [ SHOW_CREDITS , [number] ] } ) [EOL] [EOL] credits = client . people . get_show_credits ( person = [number] ) [EOL] expected = SHOW_CREDITS [ [string] ] [ [string] ] [ [number] ] [ [string] ] [EOL] assert credits . crew . production [ [number] ] . job == expected [EOL] [EOL] [EOL] def test_get_lists ( ) : [EOL] client = mk_mock_client ( { [string] : [ [ LIST ] , [number] ] } ) [EOL] [EOL] lists = list ( client . people . get_lists ( person = [number] ) ) [EOL] [EOL] assert len ( lists ) == [number] [EOL] assert lists [ [number] ] . name == LIST [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import trakt [EOL] import pytest [EOL] from tests . test_data . comments import ( ATTACHED_SHOW , COMMENT , LIKED_USER , TRENDING_COMMENTS , ) [EOL] from tests . test_data . movies import MOVIE1 [EOL] from tests . test_data . shows import SHOW [EOL] from tests . utils import get_last_req , mk_mock_client [EOL] from trakt . core . exceptions import ArgumentError [EOL] from trakt . core . json_parser import parse_tree [EOL] from trakt . core . paths . response_structs import Comment , Sharing [EOL] [EOL] PAG_H = { [string] : [number] } [EOL] [EOL] [EOL] @ pytest . fixture def comments_client ( ) : [EOL] return mk_mock_client ( { [string] : [ ATTACHED_SHOW , [number] ] , [string] : [ [ LIKED_USER ] , [number] , PAG_H ] , [string] : [ TRENDING_COMMENTS , [number] , PAG_H ] , [string] : [ TRENDING_COMMENTS , [number] , PAG_H ] , [string] : [ TRENDING_COMMENTS , [number] , PAG_H ] , } ) [EOL] [EOL] [EOL] def test_post_comment ( ) : [EOL] client = mk_mock_client ( { [string] : [ COMMENT , [number] ] } ) [EOL] text = [string] [comment] [EOL] sharing = Sharing ( twitter = True ) [EOL] comment = client . comments . post_comment ( item = [number] , comment = text , spoiler = True , sharing = sharing ) [EOL] [EOL] assert comment . id == COMMENT [ [string] ] [EOL] [EOL] [EOL] def test_get_comment ( ) : [EOL] client = mk_mock_client ( { [string] : [ COMMENT , [number] ] } ) [EOL] comment = parse_tree ( COMMENT , Comment ) [EOL] comment = client . comments . get_comment ( id = comment ) [EOL] [EOL] assert comment . user . name == COMMENT [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_update_comment ( ) : [EOL] client = mk_mock_client ( { [string] : [ COMMENT , [number] ] } ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . comments . update_comment ( id = [number] , comment = [string] ) [EOL] [EOL] comment = client . comments . update_comment ( id = [number] , comment = [string] ) [EOL] [EOL] assert comment . replies == COMMENT [ [string] ] [EOL] [EOL] [EOL] def test_delete_comment ( ) : [EOL] client = mk_mock_client ( { [string] : [ { } , [number] ] } ) [EOL] client . comments . delete_comment ( id = [number] ) [EOL] [EOL] assert get_last_req ( client . http ) [ [string] ] == [string] [EOL] [EOL] [EOL] def test_get_replies ( ) : [EOL] client = mk_mock_client ( { [string] : [ [ COMMENT ] , [number] , PAG_H ] } ) [EOL] comments = list ( client . comments . get_replies ( id = [number] ) ) [EOL] assert comments [ [number] ] . id == COMMENT [ [string] ] [EOL] [EOL] [EOL] def test_post_reply ( ) : [EOL] client = mk_mock_client ( { [string] : [ COMMENT , [number] ] } ) [EOL] reply = client . comments . post_reply ( id = [number] , comment = [string] ) [EOL] assert reply . id == COMMENT [ [string] ] [EOL] [EOL] [EOL] def test_get_item ( comments_client ) : [EOL] item = comments_client . comments . get_item ( id = [number] ) [EOL] [EOL] assert item . type == [string] [EOL] assert item . show . ids . trakt == SHOW [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_get_users ( comments_client ) : [EOL] likes = list ( comments_client . comments . get_likes ( id = [number] ) ) [EOL] assert likes [ [number] ] . user . username == LIKED_USER [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_like_comment ( ) : [EOL] client = mk_mock_client ( { [string] : [ { } , [number] ] } ) [EOL] client . comments . like_comment ( id = [number] ) [EOL] [EOL] assert get_last_req ( client . http ) [ [string] ] == [string] [EOL] [EOL] [EOL] def test_remove_like ( ) : [EOL] client = mk_mock_client ( { [string] : [ { } , [number] ] } ) [EOL] client . comments . remove_like ( id = [number] ) [EOL] [EOL] assert get_last_req ( client . http ) [ [string] ] == [string] [EOL] [EOL] [EOL] def test_trending ( comments_client ) : [EOL] comments = list ( comments_client . comments . get_trending ( include_replies = True ) ) [EOL] assert comments [ [number] ] . type == [string] [EOL] [EOL] [EOL] def test_recently_created ( comments_client ) : [EOL] comments = list ( comments_client . comments . get_recently_created ( sort = [string] ) ) [EOL] assert comments [ [number] ] . movie . title == MOVIE1 [ [string] ] [EOL] [EOL] [EOL] def test_recently_updated ( comments_client ) : [EOL] comments = list ( comments_client . comments . get_recently_updated ( type = [string] ) ) [EOL] assert comments [ [number] ] . comment . id == TRENDING_COMMENTS [ [number] ] [ [string] ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from datetime import date [EOL] [EOL] import pytest [EOL] from tests . test_data . calendars import MOVIE_PREMIERES , SEASON_PREMIERES , SHOWS [EOL] from tests . utils import USER , mk_mock_client [EOL] from trakt . core . exceptions import NotAuthenticated [EOL] [EOL] [EOL] def test_shows ( ) : [EOL] client = mk_mock_client ( { [string] : [ SHOWS , [number] ] } , user = None ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . calendars . get_my_shows ( ) [EOL] [EOL] shows = client . calendars . get_shows ( ) [EOL] client . set_user ( USER ) [EOL] my_shows = client . calendars . get_my_shows ( start_date = [string] , days = [number] ) [EOL] [EOL] assert my_shows == shows [EOL] [EOL] [EOL] def test_new_shows ( ) : [EOL] client = mk_mock_client ( { [string] : [ SHOWS , [number] ] } , user = None ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . calendars . get_my_new_shows ( ) [EOL] [EOL] shows = client . calendars . get_new_shows ( extended = True ) [EOL] client . set_user ( USER ) [EOL] my_shows = client . calendars . get_my_new_shows ( start_date = [string] , days = [number] ) [EOL] [EOL] assert my_shows == shows [EOL] [EOL] [EOL] def test_season_premieres ( ) : [EOL] client = mk_mock_client ( { [string] : [ SEASON_PREMIERES , [number] ] } ) [EOL] [EOL] premieres = client . calendars . get_season_premieres ( ) [EOL] my_premieres = client . calendars . get_my_season_premieres ( ) [EOL] [EOL] assert premieres == my_premieres [EOL] [EOL] assert len ( premieres ) == [number] [EOL] [EOL] premiere = premieres [ [number] ] [EOL] [EOL] assert premiere . first_aired [EOL] assert premiere . episode . title == [string] [EOL] assert premiere . show . title == [string] [EOL] [EOL] [EOL] def test_movies ( ) : [EOL] client = mk_mock_client ( { [string] : [ MOVIE_PREMIERES , [number] ] } ) [EOL] [EOL] movies = client . calendars . get_movies ( ) [EOL] my_movies = client . calendars . get_my_movies ( ) [EOL] [EOL] assert movies == my_movies [EOL] assert len ( movies ) == [number] [EOL] assert movies [ [number] ] . released == date ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_dvd ( ) : [EOL] client = mk_mock_client ( { [string] : [ MOVIE_PREMIERES , [number] ] } ) [EOL] [EOL] dvd = client . calendars . get_dvd_releases ( ) [EOL] my_dvd = client . calendars . get_my_dvd_releases ( ) [EOL] [EOL] assert dvd == my_dvd [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import pytest [EOL] from tests . test_data . comments import COMMENTS [EOL] from tests . test_data . episodes import EXTENDED_EPISODE [EOL] from tests . test_data . lists import LIST [EOL] from tests . test_data . movies import RATINGS [EOL] from tests . test_data . seasons import SEASON [EOL] from tests . test_data . shows import SHOW_STATS [EOL] from tests . test_data . user import USER [EOL] from tests . utils import mk_mock_client [EOL] [EOL] [EOL] @ pytest . fixture def seasons_client ( ) : [EOL] PAG_H = { [string] : [number] } [EOL] return mk_mock_client ( { [string] : [ COMMENTS , [number] , PAG_H ] , [string] : [ [ LIST ] , [number] , PAG_H ] , [string] : [ RATINGS , [number] ] , [string] : [ SHOW_STATS , [number] ] , [string] : [ [ USER ] , [number] ] , } ) [EOL] [EOL] [EOL] def test_summary ( ) : [EOL] client = mk_mock_client ( { [string] : [ [ SEASON ] , [number] ] } ) [EOL] seasons = list ( client . seasons . get_all_seasons ( show = [number] , season = [number] ) ) [EOL] [EOL] assert seasons [ [number] ] . number == SEASON [ [string] ] [EOL] [EOL] [EOL] def test_detail ( ) : [EOL] client = mk_mock_client ( { [string] : [ [ EXTENDED_EPISODE ] , [number] ] } ) [EOL] episodes = client . seasons . get_season ( show = [number] , season = [number] , extended = [string] ) [EOL] [EOL] assert episodes [ [number] ] . title == EXTENDED_EPISODE [ [string] ] [EOL] [EOL] [EOL] def test_comments ( seasons_client ) : [EOL] comments = list ( seasons_client . seasons . get_comments ( show = [number] , season = [number] ) ) [EOL] assert comments [ [number] ] . comment == COMMENTS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_lists ( seasons_client ) : [EOL] lists = list ( seasons_client . seasons . get_lists ( show = [number] , season = [number] ) ) [EOL] assert lists [ [number] ] . comment_count == LIST [ [string] ] [EOL] [EOL] [EOL] def test_ratings ( seasons_client ) : [EOL] ratings = seasons_client . seasons . get_ratings ( show = [number] , season = [number] ) [EOL] assert ratings . rating == RATINGS [ [string] ] [EOL] [EOL] [EOL] def test_stats ( seasons_client ) : [EOL] stats = seasons_client . seasons . get_stats ( show = [number] , season = [number] ) [EOL] assert stats . watchers == SHOW_STATS [ [string] ] [EOL] [EOL] [EOL] def test_watching ( seasons_client ) : [EOL] watching = list ( seasons_client . seasons . get_users_watching ( show = [number] , season = [number] ) ) [EOL] assert watching [ [number] ] . name == USER [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from tests . test_data . checkin import CHECKIN_EPISODE , CHECKIN_MOVIE [EOL] from tests . test_data . episodes import EPISODE [EOL] from tests . test_data . movies import MOVIE1 [EOL] from tests . test_data . shows import SHOW [EOL] from tests . utils import USER , get_last_req , mk_mock_client [EOL] from trakt . core . exceptions import ArgumentError , NotAuthenticated [EOL] from trakt . core . json_parser import parse_tree [EOL] from trakt . core . models import Episode , Movie , Show [EOL] from trakt . core . paths . response_structs import Sharing [EOL] [EOL] [EOL] def test_movie_arg_validation ( ) : [EOL] client = mk_mock_client ( { [string] : [ CHECKIN_MOVIE , [number] ] } , user = None ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . checkin . check_into ( ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . checkin . check_into_movie ( movie = [string] ) [EOL] [EOL] client . set_user ( USER ) [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] client . checkin . check_into_movie ( ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . checkin . check_into_movie ( movie = [string] , sharing = True ) [EOL] [EOL] client . checkin . check_into_movie ( movie = [string] , sharing = { [string] : True } ) [EOL] client . checkin . check_into_movie ( movie = [string] , sharing = Sharing ( medium = True , twitter = False ) ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . checkin . check_into_movie ( movie = [string] , message = [number] ) [EOL] [EOL] movie = parse_tree ( MOVIE1 , Movie ) [EOL] client . checkin . check_into_movie ( movie = movie ) [EOL] [EOL] [EOL] def test_episode_arg_validation ( ) : [EOL] client = mk_mock_client ( { [string] : [ CHECKIN_EPISODE , [number] ] } , user = None ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . checkin . check_into ( ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . checkin . check_into_episode ( episode = [string] ) [EOL] [EOL] client . set_user ( USER ) [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] client . checkin . check_into_episode ( ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . checkin . check_into_episode ( episode = [string] , sharing = True ) [EOL] [EOL] client . checkin . check_into_episode ( episode = [string] , sharing = { [string] : True } ) [EOL] client . checkin . check_into_episode ( episode = [string] , sharing = Sharing ( medium = True , twitter = False ) ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . checkin . check_into_episode ( episode = [string] , show = True ) [EOL] [EOL] client . checkin . check_into_episode ( episode = [string] , show = { [string] : { [string] : [string] } } ) [EOL] [EOL] episode , show = parse_tree ( EPISODE , Episode ) , parse_tree ( SHOW , Show ) [EOL] client . checkin . check_into_episode ( episode = episode , show = show ) [EOL] [EOL] [EOL] def test_dispatch ( ) : [EOL] client = mk_mock_client ( { [string] : [ CHECKIN_EPISODE , [number] ] } ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . checkin . check_into ( ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . checkin . check_into ( episode = [string] , movie = [string] ) [EOL] [EOL] client . checkin . check_into ( episode = [string] ) [EOL] [EOL] client = mk_mock_client ( { [string] : [ CHECKIN_MOVIE , [number] ] } ) [EOL] client . checkin . check_into ( movie = [string] ) [EOL] [EOL] [EOL] def test_delete_checkins ( ) : [EOL] client = mk_mock_client ( { [string] : [ { } , [number] ] } , user = None ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . checkin . delete_active_checkins ( ) [EOL] [EOL] client . set_user ( USER ) [EOL] [EOL] client . checkin . delete_active_checkins ( ) [EOL] assert get_last_req ( client . http ) [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from tests . test_data . movies import MOVIE1 , MOVIES [EOL] from tests . test_data . shows import SHOW [EOL] from tests . utils import USER , get_last_req , mk_mock_client [EOL] from trakt . core . exceptions import ArgumentError , NotAuthenticated [EOL] from trakt . core . json_parser import parse_tree [EOL] from trakt . core . models import Movie , Show [EOL] [EOL] [EOL] def test_recommendations_movies ( ) : [EOL] client = mk_mock_client ( { [string] : [ MOVIES , [number] ] } , user = None ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . recommendations . get_movie_recommendations ( ) [EOL] [EOL] client . set_user ( USER ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . recommendations . get_movie_recommendations ( ignore_collected = [number] ) [EOL] [EOL] movies = client . recommendations . get_movie_recommendations ( ignore_collected = True ) [EOL] [EOL] assert len ( movies ) == [number] [EOL] [EOL] [EOL] def test_hide_movie ( ) : [EOL] m_id = MOVIE1 [ [string] ] [ [string] ] [EOL] client = mk_mock_client ( { rf" [string] { m_id }" : [ { } , [number] ] } , user = None ) [EOL] [EOL] movie = parse_tree ( MOVIE1 , tree_structure = Movie ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . recommendations . hide_movie ( movie = movie ) [EOL] [EOL] client . set_user ( USER ) [EOL] [EOL] client . recommendations . hide_movie ( movie = movie ) [EOL] client . recommendations . hide_movie ( movie = movie . ids . trakt ) [EOL] [EOL] assert get_last_req ( client . http ) [ [string] ] == [string] [EOL] [EOL] [EOL] def test_recommendations_shows ( ) : [EOL] client = mk_mock_client ( { [string] : [ [ SHOW ] , [number] ] } , user = None ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . recommendations . get_show_recommendations ( ) [EOL] [EOL] client . set_user ( USER ) [EOL] shows = client . recommendations . get_show_recommendations ( ignore_collected = True ) [EOL] [EOL] assert len ( shows ) == [number] [EOL] [EOL] [EOL] def test_hide_show ( ) : [EOL] m_id = SHOW [ [string] ] [ [string] ] [EOL] client = mk_mock_client ( { rf" [string] { m_id }" : [ { } , [number] ] } , user = None ) [EOL] [EOL] show = parse_tree ( SHOW , tree_structure = Show ) [EOL] [EOL] with pytest . raises ( NotAuthenticated ) : [EOL] client . recommendations . hide_show ( show = show ) [EOL] [EOL] client . set_user ( USER ) [EOL] [EOL] client . recommendations . hide_show ( show = show ) [EOL] [EOL] assert get_last_req ( client . http ) [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import pytest [EOL] from tests . test_data . comments import COMMENTS [EOL] from tests . test_data . episodes import EXTENDED_EPISODE [EOL] from tests . test_data . lists import LIST [EOL] from tests . test_data . movies import ALIASES , RATINGS [EOL] from tests . test_data . people import MOVIE_ALL_PEOPLE [EOL] from tests . test_data . shows import ( ANTICIPATED_SHOWS , COLLECTION_PROGRESS , EXTENDED_SHOW , PLAYED_SHOWS , RELATED_SHOWS , SHOW , SHOW_STATS , TRANSLATIONS , TRENDING_SHOWS , UPDATED_SHOWS , WATCHED_PROGRESS , ) [EOL] from tests . test_data . user import USER [EOL] from tests . utils import MockResponse , mk_mock_client [EOL] from trakt . core . exceptions import ArgumentError [EOL] [EOL] [EOL] @ pytest . fixture def shows_client ( ) : [EOL] PAG_H = { [string] : [number] } [EOL] return mk_mock_client ( { [string] : [ TRENDING_SHOWS , [number] , PAG_H ] , [string] : [ [ SHOW ] , [number] , PAG_H ] , [string] : [ PLAYED_SHOWS , [number] , PAG_H ] , [string] : [ PLAYED_SHOWS , [number] , PAG_H ] , [string] : [ PLAYED_SHOWS , [number] , PAG_H ] , [string] : [ ANTICIPATED_SHOWS , [number] , PAG_H ] , [string] : [ UPDATED_SHOWS , [number] , PAG_H ] , [string] : [ ALIASES , [number] ] , [string] : [ TRANSLATIONS , [number] ] , [string] : [ COMMENTS , [number] , PAG_H ] , [string] : [ [ LIST ] , [number] , PAG_H ] , [string] : [ COLLECTION_PROGRESS , [number] ] , [string] : [ WATCHED_PROGRESS , [number] ] , [string] : [ MOVIE_ALL_PEOPLE , [number] , PAG_H ] , [string] : [ RATINGS , [number] ] , [string] : [ RELATED_SHOWS , [number] , PAG_H ] , [string] : [ SHOW_STATS , [number] ] , [string] : [ [ USER ] , [number] ] , } ) [EOL] [EOL] [EOL] def test_trending ( shows_client ) : [EOL] shows = list ( shows_client . shows . get_trending ( ) ) [EOL] [EOL] assert len ( shows ) == [number] [EOL] assert shows [ [number] ] . watchers == TRENDING_SHOWS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_popular ( shows_client ) : [EOL] shows = list ( shows_client . shows . get_popular ( ) ) [EOL] assert shows [ [number] ] . ids . trakt == SHOW [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_played ( shows_client ) : [EOL] shows = list ( shows_client . shows . get_most_played ( ) ) [EOL] assert shows [ [number] ] . show . title == PLAYED_SHOWS [ [number] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_watched ( shows_client ) : [EOL] shows = list ( shows_client . shows . get_most_watched ( ) ) [EOL] assert shows [ [number] ] . show . year == PLAYED_SHOWS [ [number] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_collected ( shows_client ) : [EOL] shows = list ( shows_client . shows . get_most_collected ( ) ) [EOL] assert shows [ [number] ] . show . ids . slug == PLAYED_SHOWS [ [number] ] [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_anticipated ( shows_client ) : [EOL] shows = list ( shows_client . shows . get_most_anticipated ( ) ) [EOL] assert shows [ [number] ] . list_count == ANTICIPATED_SHOWS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_updated ( shows_client ) : [EOL] shows = list ( shows_client . shows . get_recently_updated ( start_date = [string] ) ) [EOL] assert shows [ [number] ] . show . title == UPDATED_SHOWS [ [number] ] [ [string] ] [ [string] ] [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] shows_client . shows . get_recently_updated ( start_date = [string] ) [EOL] [EOL] [EOL] def test_summary ( ) : [EOL] client = mk_mock_client ( { [string] : [ EXTENDED_SHOW , [number] ] } ) [EOL] show = client . shows . get_summary ( show = [number] , extended = True ) [EOL] [EOL] assert show . network == EXTENDED_SHOW [ [string] ] [EOL] [EOL] [EOL] def test_aliases ( shows_client ) : [EOL] aliases = shows_client . shows . get_aliases ( show = [number] ) [EOL] assert aliases [ [number] ] . title == ALIASES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_translations ( shows_client ) : [EOL] translations = shows_client . shows . get_translations ( show = [number] , language = [string] ) [EOL] assert translations [ [number] ] . title == TRANSLATIONS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_comments ( shows_client ) : [EOL] with pytest . raises ( ArgumentError ) : [EOL] shows_client . shows . get_comments ( show = [number] , sort = [string] ) [EOL] [EOL] comments = list ( shows_client . shows . get_comments ( show = [number] ) ) [EOL] assert comments [ [number] ] . comment == COMMENTS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_lists ( shows_client ) : [EOL] lists = list ( shows_client . shows . get_lists ( show = [number] ) ) [EOL] assert lists [ [number] ] . comment_count == LIST [ [string] ] [EOL] [EOL] [EOL] def test_progress_collection ( shows_client ) : [EOL] progress = shows_client . shows . get_collection_progress ( show = [number] ) [EOL] assert progress . aired == COLLECTION_PROGRESS [ [string] ] [EOL] [EOL] [EOL] def test_progress_watched ( shows_client ) : [EOL] progress = shows_client . shows . get_watched_progress ( show = [number] ) [EOL] assert progress . completed == WATCHED_PROGRESS [ [string] ] [EOL] [EOL] [EOL] def test_get_people ( shows_client ) : [EOL] people = shows_client . shows . get_people ( show = [number] ) [EOL] assert people . cast [ [number] ] . character == MOVIE_ALL_PEOPLE [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_ratings ( shows_client ) : [EOL] ratings = shows_client . shows . get_ratings ( show = [number] ) [EOL] assert ratings . rating == RATINGS [ [string] ] [EOL] [EOL] [EOL] def test_related ( shows_client ) : [EOL] related = list ( shows_client . shows . get_related ( show = [number] ) ) [EOL] assert related [ [number] ] . title == RELATED_SHOWS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_stats ( shows_client ) : [EOL] stats = shows_client . shows . get_stats ( show = [number] ) [EOL] assert stats . watchers == SHOW_STATS [ [string] ] [EOL] [EOL] [EOL] def test_watching ( shows_client ) : [EOL] watching = list ( shows_client . shows . get_users_watching ( show = [number] ) ) [EOL] assert watching [ [number] ] . name == USER [ [string] ] [EOL] [EOL] [EOL] def next_last_ep_responses ( ) : [EOL] yield MockResponse ( { } , [number] ) [EOL] yield MockResponse ( EXTENDED_EPISODE , [number] ) [EOL] [EOL] [EOL] def test_next_episode ( ) : [EOL] client = mk_mock_client ( { [string] : next_last_ep_responses ( ) } ) [EOL] [EOL] no_ep = client . shows . get_next_episode ( show = [number] , extended = True ) [EOL] ep = client . shows . get_next_episode ( show = [number] , extended = True ) [EOL] [EOL] assert no_ep is None [EOL] assert ep . runtime == EXTENDED_EPISODE [ [string] ] [EOL] [EOL] [EOL] def test_last_episode ( ) : [EOL] client = mk_mock_client ( { [string] : next_last_ep_responses ( ) } ) [EOL] [EOL] no_ep = client . shows . get_last_episode ( show = [number] , extended = True ) [EOL] ep = client . shows . get_last_episode ( show = [number] , extended = True ) [EOL] [EOL] assert no_ep is None [EOL] assert ep . overview == EXTENDED_EPISODE [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from tests . test_data . scrobble import EPISODE , MOVIE1 , RESP_EPISODE , RESP_MOVIE , SHOW [EOL] from tests . utils import mk_mock_client [EOL] from trakt . core . exceptions import ArgumentError [EOL] from trakt . core . json_parser import parse_tree [EOL] from trakt . core . models import Episode , Movie , Show [EOL] [EOL] [EOL] def test_start_scrobble_movie ( ) : [EOL] client = mk_mock_client ( { [string] : [ RESP_MOVIE , [number] ] } ) [EOL] [EOL] movie = parse_tree ( MOVIE1 , Movie ) [EOL] episode = parse_tree ( EPISODE , Episode ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . scrobble . start_scrobble ( progress = [number] ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . scrobble . start_scrobble ( progress = [number] , episode = episode , movie = movie ) [EOL] [EOL] resp = client . scrobble . start_scrobble ( movie = movie , progress = [number] ) [EOL] [EOL] assert resp . movie . title == MOVIE1 [ [string] ] [EOL] [EOL] [EOL] def test_start_scrobble_episode ( ) : [EOL] client = mk_mock_client ( { [string] : [ RESP_EPISODE , [number] ] } ) [EOL] [EOL] episode = parse_tree ( EPISODE , Episode ) [EOL] show = parse_tree ( SHOW , Show ) [EOL] resp = client . scrobble . start_scrobble ( episode = episode , show = show , progress = [number] ) [EOL] [EOL] assert resp . show . title == SHOW [ [string] ] [EOL] [EOL] [EOL] def test_pause_scrobble_movie ( ) : [EOL] client = mk_mock_client ( { [string] : [ RESP_MOVIE , [number] ] } ) [EOL] [EOL] movie = parse_tree ( MOVIE1 , Movie ) [EOL] episode = parse_tree ( EPISODE , Episode ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . scrobble . pause_scrobble ( progress = [number] ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . scrobble . pause_scrobble ( progress = [number] , episode = episode , movie = movie ) [EOL] [EOL] resp = client . scrobble . pause_scrobble ( movie = movie , progress = [number] ) [EOL] [EOL] assert resp . movie . title == MOVIE1 [ [string] ] [EOL] [EOL] [EOL] def test_pause_scrobble_episode ( ) : [EOL] client = mk_mock_client ( { [string] : [ RESP_EPISODE , [number] ] } ) [EOL] resp = client . scrobble . pause_scrobble ( episode = [number] , show = [number] , progress = [number] ) [EOL] assert resp . show . title == SHOW [ [string] ] [EOL] [EOL] [EOL] def test_stop_scrobble_movie ( ) : [EOL] client = mk_mock_client ( { [string] : [ RESP_MOVIE , [number] ] } ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . scrobble . stop_scrobble ( progress = [number] ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] client . scrobble . stop_scrobble ( progress = [number] , episode = [number] , movie = [number] ) [EOL] [EOL] resp = client . scrobble . stop_scrobble ( movie = [number] , progress = [number] ) [EOL] assert resp . movie . title == MOVIE1 [ [string] ] [EOL] [EOL] [EOL] def test_stop_scrobble_episode ( ) : [EOL] client = mk_mock_client ( { [string] : [ RESP_EPISODE , [number] ] } ) [EOL] resp = client . scrobble . stop_scrobble ( episode = [number] , show = [number] , progress = [number] ) [EOL] assert resp . show . title == SHOW [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import pytest [EOL] from tests . test_data . comments import COMMENTS [EOL] from tests . test_data . lists import LIST [EOL] from tests . test_data . movies import ( ALIASES , ANTICIPATED_MOVIES , BOX_OFFICE , EXTENDED_MOVIE , MOVIE_STATS , MOVIES , PLAYED_MOVIES , RATINGS , RELATED_MOVIES , RELEASES , TRANSLATIONS , TRENDING_MOVIES , UPDATED_MOVIES , ) [EOL] from tests . test_data . people import MOVIE_ALL_PEOPLE [EOL] from tests . test_data . user import USER [EOL] from tests . utils import mk_mock_client [EOL] from trakt . core . exceptions import ArgumentError [EOL] [EOL] [EOL] @ pytest . fixture def movies_client ( ) : [EOL] PAG_H = { [string] : [number] } [EOL] return mk_mock_client ( { [string] : [ TRENDING_MOVIES , [number] , PAG_H ] , [string] : [ MOVIES , [number] , PAG_H ] , [string] : [ PLAYED_MOVIES , [number] , PAG_H ] , [string] : [ PLAYED_MOVIES , [number] , PAG_H ] , [string] : [ PLAYED_MOVIES , [number] , PAG_H ] , [string] : [ ANTICIPATED_MOVIES , [number] , PAG_H ] , [string] : [ BOX_OFFICE , [number] ] , [string] : [ UPDATED_MOVIES , [number] , PAG_H ] , [string] : [ ALIASES , [number] ] , [string] : [ RELEASES , [number] ] , [string] : [ TRANSLATIONS , [number] ] , [string] : [ COMMENTS , [number] , PAG_H ] , [string] : [ [ LIST ] , [number] , PAG_H ] , [string] : [ MOVIE_ALL_PEOPLE , [number] , PAG_H ] , [string] : [ RATINGS , [number] ] , [string] : [ RELATED_MOVIES , [number] , PAG_H ] , [string] : [ MOVIE_STATS , [number] ] , [string] : [ [ USER ] , [number] ] , } ) [EOL] [EOL] [EOL] def test_trending ( movies_client ) : [EOL] movies = list ( movies_client . movies . get_trending ( ) ) [EOL] [EOL] assert len ( movies ) == [number] [EOL] assert movies [ [number] ] . watchers == TRENDING_MOVIES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_popular ( movies_client ) : [EOL] movies = list ( movies_client . movies . get_popular ( ) ) [EOL] [EOL] assert len ( movies ) == [number] [EOL] assert movies [ [number] ] . title == MOVIES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_played ( movies_client ) : [EOL] movies = list ( movies_client . movies . get_most_played ( countries = [string] , period = [string] ) ) [EOL] [EOL] assert len ( movies ) == [number] [EOL] assert movies [ [number] ] . watcher_count == PLAYED_MOVIES [ [number] ] [ [string] ] [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] movies_client . movies . get_most_played ( countries = [string] ) [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] movies_client . movies . get_most_played ( period = [string] ) [EOL] [EOL] [EOL] def test_watched ( movies_client ) : [EOL] movies = list ( movies_client . movies . get_most_watched ( genres = [string] ) ) [EOL] assert movies [ [number] ] . play_count == PLAYED_MOVIES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_collected ( movies_client ) : [EOL] movies = list ( movies_client . movies . get_most_collected ( period = [string] ) ) [EOL] assert movies [ [number] ] . movie . title == PLAYED_MOVIES [ [number] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def test_anticipated ( movies_client ) : [EOL] movies = list ( movies_client . movies . get_most_anticipated ( ) ) [EOL] assert movies [ [number] ] . list_count == ANTICIPATED_MOVIES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_box_office ( movies_client ) : [EOL] movies = list ( movies_client . movies . get_box_office ( ) ) [EOL] assert movies [ [number] ] . revenue == BOX_OFFICE [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_updated ( movies_client ) : [EOL] movies = list ( movies_client . movies . get_recently_updated ( start_date = [string] ) ) [EOL] assert movies [ [number] ] . movie . title == UPDATED_MOVIES [ [number] ] [ [string] ] [ [string] ] [EOL] [EOL] with pytest . raises ( ArgumentError ) : [EOL] movies_client . movies . get_recently_updated ( start_date = [string] ) [EOL] [EOL] [EOL] def test_summary ( ) : [EOL] client = mk_mock_client ( { [string] : [ EXTENDED_MOVIE , [number] ] } ) [EOL] [EOL] movie = client . movies . get_summary ( movie = [number] , extended = True ) [EOL] [EOL] assert movie . homepage == EXTENDED_MOVIE [ [string] ] [EOL] [EOL] [EOL] def test_aliases ( movies_client ) : [EOL] aliases = movies_client . movies . get_aliases ( movie = [number] ) [EOL] assert aliases [ [number] ] . title == ALIASES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_releases ( movies_client ) : [EOL] releases = movies_client . movies . get_releases ( movie = [number] , country = [string] ) [EOL] assert releases [ [number] ] . release_type == RELEASES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_translations ( movies_client ) : [EOL] translations = movies_client . movies . get_translations ( movie = [number] , language = [string] ) [EOL] assert translations [ [number] ] . title == TRANSLATIONS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_comments ( movies_client ) : [EOL] with pytest . raises ( ArgumentError ) : [EOL] movies_client . movies . get_comments ( movie = [number] , sort = [string] ) [EOL] [EOL] comments = list ( movies_client . movies . get_comments ( movie = [number] ) ) [EOL] assert comments [ [number] ] . comment == COMMENTS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_lists ( movies_client ) : [EOL] lists = list ( movies_client . movies . get_lists ( movie = [number] ) ) [EOL] assert lists [ [number] ] . comment_count == LIST [ [string] ] [EOL] [EOL] [EOL] def test_get_people ( movies_client ) : [EOL] people = movies_client . movies . get_people ( movie = [number] ) [EOL] assert people . cast [ [number] ] . character == MOVIE_ALL_PEOPLE [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_ratings ( movies_client ) : [EOL] ratings = movies_client . movies . get_ratings ( movie = [number] ) [EOL] assert ratings . rating == RATINGS [ [string] ] [EOL] [EOL] [EOL] def test_related ( movies_client ) : [EOL] related = list ( movies_client . movies . get_related ( movie = [number] ) ) [EOL] assert related [ [number] ] . title == RELATED_MOVIES [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_stats ( movies_client ) : [EOL] stats = movies_client . movies . get_stats ( movie = [number] ) [EOL] assert stats . watchers == MOVIE_STATS [ [string] ] [EOL] [EOL] [EOL] def test_watching ( movies_client ) : [EOL] watching = list ( movies_client . movies . get_users_watching ( movie = [number] ) ) [EOL] assert watching [ [number] ] . name == USER [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] from tests . test_data . search import ID_RESULTS , TEXT_RESULTS [EOL] from tests . utils import mk_mock_client [EOL] [EOL] PAG_H = { [string] : [number] } [EOL] [EOL] [EOL] def test_text_query ( ) : [EOL] client = mk_mock_client ( { [string] : [ TEXT_RESULTS , [number] , PAG_H ] } ) [EOL] results = list ( client . search . text_query ( query = [string] , type = [ [string] , [string] ] , fields = [ [string] , [string] ] ) ) [EOL] [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] . type == TEXT_RESULTS [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def test_id_lookup ( ) : [EOL] client = mk_mock_client ( { [string] : [ ID_RESULTS , [number] , PAG_H ] } ) [EOL] results = list ( client . search . id_lookup ( id_type = [string] , id = [string] , type = [string] ) ) [EOL] [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] . type == ID_RESULTS [ [number] ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union [EOL] import typing [EOL] OAUTH_GET_TOKEN = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] [EOL] OAUTH_VERIFICATION_CODE = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , } [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List , Optional , Any [EOL] import typing [EOL] TRENDING_SHOWS = [ { [string] : [number] , [string] : { [string] : [string] , [string] : [number] , [string] : { [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [number] , } , } , } , { [string] : [number] , [string] : { [string] : [string] , [string] : [number] , [string] : { [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [number] , } , } , } , ] [EOL] [EOL] SHOW = { [string] : [string] , [string] : [number] , [string] : { [string] : [number] , [string] : [string] , [string] : [number] , [string] : { } , [string] : { } , [string] : { } , } , } [EOL] [EOL] EXTENDED_SHOW = { [string] : [string] , [string] : [number] , [string] : { [string] : [number] , [string] : [string] , [string] : [number] , [string] : { } , [string] : { } , [string] : { } , } , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : { } , [string] : [string] } , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { } , [string] : { } , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : { } , [string] : [ ] , [string] : [ [string] , [string] ] , [string] : [number] , } [EOL] [EOL] PLAYED_SHOWS = [ { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : SHOW , } ] [EOL] [EOL] ANTICIPATED_SHOWS = [ { [string] : [number] , [string] : SHOW } ] [EOL] [EOL] UPDATED_SHOWS = [ { [string] : [string] , [string] : SHOW } ] [EOL] [EOL] TRANSLATIONS = [ { [string] : [string] , [string] : [string] , [string] : [string] } ] [EOL] [EOL] SHOW_STATS = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] RELATED_SHOWS = [ SHOW ] [EOL] [EOL] COLLECTION_PROGRESS = { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [ { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ { [string] : [number] , [string] : True , [string] : [string] , } ] , } ] , [string] : [ { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] } } ] , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : None , [string] : None } , } , } [EOL] [EOL] WATCHED_PROGRESS = { [string] : [number] , [string] : [number] , [string] : [string] , [string] : None , [string] : [ { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ { [string] : [number] , [string] : True , [string] : [string] , } , { [string] : [number] , [string] : False , [string] : None } , ] , } ] , [string] : [ { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] } } ] , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : None , [string] : None } , } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] CERTIFICATIONS = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] } [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List [EOL] import typing [EOL] from tests . test_data . user import USER [EOL] [EOL] LIST = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : { [string] : [number] , [string] : [string] } , [string] : USER , } [EOL] [EOL] TRENDING_LISTS = [ { [string] : [number] , [string] : [number] , [string] : LIST , [string] : USER } ] [EOL] TRENDING_LISTS_MISSING_DATA = [ { [string] : [number] , [string] : LIST , [string] : USER } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , List [EOL] import typing [EOL] from tests . test_data . episodes import EPISODE , EXTENDED_EPISODE [EOL] from tests . test_data . movies import MOVIE_PREMIERES [EOL] from tests . test_data . shows import EXTENDED_SHOW , SHOW [EOL] [EOL] SEASON_PREMIERES = [ { [string] : [string] , [string] : EPISODE , [string] : SHOW } ] [EOL] [EOL] SEASON_PREMIERES_EXTENDED = [ { [string] : [string] , [string] : EXTENDED_EPISODE , [string] : EXTENDED_SHOW , } ] [EOL] [EOL] SHOWS = [ { [string] : [string] , [string] : EPISODE , [string] : SHOW } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] from tests . test_data . movies import MOVIE1 [EOL] from tests . test_data . shows import SHOW [EOL] [EOL] ID_RESULTS = [ { [string] : [string] , [string] : None , [string] : MOVIE1 } ] [EOL] [EOL] TEXT_RESULTS = [ { [string] : [string] , [string] : [number] , [string] : MOVIE1 } , { [string] : [string] , [string] : [number] , [string] : SHOW } , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] from tests . test_data . movies import MOVIE1 [EOL] from tests . test_data . shows import SHOW [EOL] from tests . test_data . user import USER [EOL] [EOL] COMMENT = { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , [string] : False , [string] : [number] , [string] : [number] , [string] : [number] , [string] : { [string] : [string] , [string] : False , [string] : [string] , [string] : True , [string] : False , [string] : { [string] : [string] } , } , } [EOL] [EOL] COMMENTS = [ COMMENT ] [EOL] [EOL] ATTACHED_SHOW = { [string] : [string] , [string] : SHOW } [EOL] [EOL] LIKED_USER = { [string] : [string] , [string] : USER } [EOL] [EOL] TRENDING_COMMENTS = [ { [string] : [string] , [string] : MOVIE1 , [string] : COMMENT } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union [EOL] import typing [EOL] SEASON = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] } } [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union [EOL] import typing [EOL] CHECKIN_MOVIE = { [string] : [number] , [string] : [string] , [string] : { [string] : True , [string] : False } , [string] : { [string] : [string] , [string] : [number] , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [number] , } , } , } [EOL] [EOL] CHECKIN_EPISODE = { [string] : [number] , [string] : [string] , [string] : { [string] : True , [string] : False } , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] } , } , [string] : { [string] : [string] , [string] : [number] , [string] : { [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , } , } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] COUNTRIES = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Any [EOL] import typing [EOL] from tests . test_data . episodes import EPISODE [EOL] from tests . test_data . movies import MOVIE1 [EOL] from tests . test_data . shows import SHOW [EOL] [EOL] RESP_MOVIE = { [string] : [number] , [string] : [string] , [string] : [number] , [string] : { [string] : True , [string] : False } , [string] : MOVIE1 , } [EOL] [EOL] RESP_EPISODE = { [string] : [number] , [string] : [string] , [string] : [number] , [string] : { [string] : True , [string] : False } , [string] : EPISODE , [string] : SHOW , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] NETWORKS = [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] EPISODE = { [string] : [number] , [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : { } , [string] : { } , [string] : { } } , } [EOL] [EOL] EXTENDED_EPISODE = { [string] : [number] , [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : { } , [string] : { } , [string] : { } } , [string] : { } , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.int]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.int]],typing.List[typing.Any],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] from tests . test_data . movies import MOVIE1 [EOL] from tests . test_data . shows import SHOW [EOL] [EOL] PERSON = { [string] : [string] , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [number] } , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , } [EOL] [EOL] MINI_PERSON = { [string] : [string] , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [number] } , } [EOL] [EOL] MOVIE_CREDITS = { [string] : [ { [string] : [string] , [string] : MOVIE1 } ] , [string] : { [string] : [ { [string] : [string] , [string] : MOVIE1 } ] , [string] : [ { [string] : [string] , [string] : MOVIE1 } ] , [string] : [ ] , } , } [EOL] [EOL] SHOW_CREDITS = { [string] : [ { [string] : [string] , [string] : SHOW } ] , [string] : { [string] : [ { [string] : [string] , [string] : SHOW } ] } , } [EOL] [EOL] MOVIE_ALL_PEOPLE = { [string] : [ { [string] : [string] , [string] : MINI_PERSON } , { [string] : [string] , [string] : MINI_PERSON } , ] , [string] : { [string] : [ { [string] : [string] , [string] : MINI_PERSON } ] , [string] : [ { [string] : [string] , [string] : MINI_PERSON } ] , [string] : [ { [string] : [string] , [string] : MINI_PERSON } ] , [string] : [ { [string] : [string] , [string] : MINI_PERSON } ] , [string] : [ { [string] : [string] , [string] : MINI_PERSON } ] , } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] LANGUAGES = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union [EOL] import typing [EOL] USER = { [string] : [string] , [string] : False , [string] : [string] , [string] : True , [string] : False , [string] : { [string] : [string] } , } [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , List [EOL] import typing [EOL] GENRES = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Type [EOL] import typing [EOL] import trakt [EOL] import logging [EOL] from logging import NullHandler [EOL] [EOL] from trakt . api import TraktApi , TraktCredentials [EOL] from trakt . version import __version__ [comment] [EOL] [EOL] Trakt = TraktApi [EOL] [EOL] __all__ = ( [string] , [string] ) [EOL] [EOL] [EOL] logging . getLogger ( __name__ ) . addHandler ( NullHandler ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[trakt.api.TraktApi]$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] import os [EOL] from typing import Any [EOL] [EOL] [EOL] def write_version ( command ) : [comment] [EOL] version = command . egg_version [EOL] [EOL] version_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] with open ( version_path , [string] ) as fp : [EOL] lines = fp . read ( ) . split ( [string] ) [EOL] [EOL] for i , line in enumerate ( lines ) : [EOL] if line . startswith ( [string] ) : [EOL] lines [ i ] = [string] % ( version , ) [EOL] [EOL] with open ( version_path , [string] ) as fp : [EOL] fp . write ( [string] . join ( lines ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Type , Optional [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] from typing import Any , List , Optional [EOL] [EOL] [EOL] class TraktError ( Exception ) : [EOL] message = [string] [EOL] [EOL] def __init__ ( self , message = None , errors = None ) : [EOL] if not message : [EOL] message = self . message [EOL] [EOL] super ( ) . __init__ ( message ) [EOL] if not errors : [EOL] errors = [ ] [EOL] self . errors = errors [EOL] [EOL] [EOL] ClientError = TraktError [EOL] [EOL] [EOL] class NotAuthenticated ( ClientError ) : [EOL] message = [string] [EOL] [EOL] [EOL] class ArgumentError ( ClientError ) : [EOL] message = [string] [EOL] [EOL] [EOL] class RequestRelatedError ( ClientError ) : [EOL] status_code = ... [EOL] response = ... [EOL] [EOL] def __init__ ( self , code = None , response = None , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] self . status_code = code [EOL] self . response = response [EOL] [EOL] [EOL] class BadRequest ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class Unauthorized ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class Forbidden ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class NotFound ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class MethodNotFound ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class Conflict ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class PreconditionFailed ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class UnprocessableEntity ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class RateLimitExceeded ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class ServerError ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class ServiceUnavailable ( RequestRelatedError ) : [EOL] status_code = [number] [EOL] [EOL] [EOL] class TraktResponseError ( ClientError ) : [EOL] message = [string] [EOL] [EOL] [EOL] class TraktTimeoutError ( RequestRelatedError ) : [EOL] message = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.List[builtins.Exception]]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[typing.List[builtins.Exception]]$ 0 0 $typing.Optional[typing.List[builtins.Exception]]$ 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.Exception]]$ 0 $typing.Optional[typing.List[builtins.Exception]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Callable , Any [EOL] import typing [EOL] from typing import Any , Callable [EOL] [EOL] from trakt . core . exceptions import NotAuthenticated [EOL] [EOL] [EOL] def auth_required ( f ) : [EOL] def wrapper ( self , * args , ** kwargs ) : [EOL] if not self . client . user : [EOL] raise NotAuthenticated [EOL] [EOL] return f ( self , * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Type , Tuple , Any [EOL] import builtins [EOL] import typing [EOL] from copy import deepcopy [EOL] from dataclasses import dataclass [EOL] from typing import Any , Dict , Union [EOL] [EOL] __all__ = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] ConfigEntryType = Union [ int , str , Dict [ str , Union [ str , int ] ] ] [EOL] InternalConfigType = Dict [ str , ConfigEntryType ] [EOL] [EOL] [EOL] def _update_dict_recursive ( org , new ) : [EOL] for k , v in new . items ( ) : [EOL] if k not in org : [EOL] org [ k ] = v [EOL] else : [EOL] if isinstance ( org [ k ] , dict ) : [EOL] _update_dict_recursive ( org [ k ] , v ) [EOL] else : [EOL] org [ k ] = v [EOL] [EOL] [EOL] class Config : [EOL] _config = ... [EOL] [EOL] def __init__ ( self , config ) : [EOL] self . _config = config [EOL] [EOL] def __getitem__ ( self , name ) : [EOL] return self . _config . get ( name ) [EOL] [EOL] def __setitem__ ( self , name , value ) : [EOL] self . _config [ name ] = value [EOL] [EOL] [EOL] DEFAULT_CONFIG = { [string] : { [string] : [string] , [string] : [number] } , [string] : { [string] : [string] , [string] : [number] * [number] * [number] * [number] , } , [string] : { [string] : [string] , [string] : [number] * [number] } , } [EOL] [EOL] [EOL] class DefaultConfig ( Config ) : [EOL] def __init__ ( self , ** custom_config ) : [EOL] config = deepcopy ( DEFAULT_CONFIG ) [EOL] [EOL] if custom_config : [EOL] _update_dict_recursive ( config , custom_config ) [EOL] [EOL] super ( ) . __init__ ( config ) [EOL] [EOL] [EOL] @ dataclass class TraktCredentials : [EOL] access_token = ... [EOL] refresh_token = ... [EOL] scope = ... [EOL] expires_at = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $InternalConfigType$ 0 0 0 0 0 $None$ 0 0 0 $InternalConfigType$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 $InternalConfigType$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $InternalConfigType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $ConfigEntryType$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 $InternalConfigType$ 0 0 0 0 $ConfigEntryType$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 $ConfigEntryType$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0
from typing import Set , Dict , Union , List , Type , Any [EOL] import builtins [EOL] import typing [EOL] from typing import Any , Dict , List [EOL] [EOL] import jsons [comment] [EOL] from trakt . core . exceptions import TraktResponseError [EOL] [EOL] TYPE_TYPE = int . __class__ [EOL] ITERABLES = { list , dict } [EOL] [EOL] GLOBAL_NAME_MAPPING = { [string] : [string] } [EOL] [EOL] [EOL] def parse_tree ( data , tree_structure ) : [EOL] try : [EOL] data = _apply_name_mapping ( data ) [EOL] data = _substitute_none_val ( data ) [EOL] return _parse_tree ( data , tree_structure ) [EOL] except Exception as e : [EOL] raise TraktResponseError ( errors = [ e ] ) [EOL] [EOL] [EOL] def _apply_name_mapping ( data ) : [EOL] if isinstance ( data , list ) : [EOL] data = [ _apply_name_mapping ( v ) for v in data ] [EOL] if isinstance ( data , dict ) : [EOL] data = { GLOBAL_NAME_MAPPING . get ( k , k ) : _apply_name_mapping ( v ) for k , v in data . items ( ) } [EOL] [EOL] return data [EOL] [EOL] [EOL] def _substitute_none_val ( data ) : [EOL] [docstring] [EOL] if data == { } : [EOL] return None [EOL] [EOL] if isinstance ( data , list ) : [EOL] data = [ _substitute_none_val ( v ) for v in data ] [EOL] if isinstance ( data , dict ) : [EOL] data = { k : _substitute_none_val ( v ) for k , v in data . items ( ) } [EOL] [EOL] return data [EOL] [EOL] [EOL] def _parse_tree ( data , tree_structure ) : [EOL] level_type = tree_structure . __class__ [EOL] [EOL] if level_type not in ITERABLES : [EOL] return jsons . load ( data , tree_structure ) [EOL] [EOL] if level_type == list : [EOL] return _parse_list ( data , tree_structure ) [EOL] [EOL] if level_type == dict : [EOL] return _parse_dict ( data , tree_structure ) [EOL] [EOL] [EOL] def _is_arbitrary_value ( x ) : [EOL] return x . __class__ not in ( ITERABLES | { type } ) [EOL] [EOL] [EOL] def _parse_list ( data , tree_structure ) : [EOL] if not tree_structure : [EOL] return tree_structure [EOL] [EOL] single_item_type = tree_structure [ [number] ] [EOL] if single_item_type is Any : [EOL] return data [EOL] if data is None or not data : [EOL] return [ ] [EOL] [EOL] return [ _parse_tree ( e , single_item_type ) for e in data ] [EOL] [EOL] [EOL] def _parse_dict ( data , tree_structure ) : [EOL] if not tree_structure : [EOL] return tree_structure [EOL] [EOL] wildcards = { k : v for k , v in tree_structure . items ( ) if isinstance ( k , type ) } [EOL] [EOL] defaults = { k : v for k , v in tree_structure . items ( ) if ( k not in wildcards ) and _is_arbitrary_value ( v ) } [EOL] [EOL] result = __parse_dict_items ( data , tree_structure , wildcards ) [EOL] [EOL] [comment] [EOL] for k , v in defaults . items ( ) : [EOL] if k not in result : [EOL] result [ k ] = v [EOL] [EOL] return result [EOL] [EOL] [EOL] def __parse_dict_items ( data , tree_structure , wildcards ) : [EOL] result = { } [EOL] for k , v in data . items ( ) : [EOL] if k in tree_structure : [EOL] [comment] [EOL] subtree = tree_structure [ k ] [EOL] subtree = subtree . __class__ if _is_arbitrary_value ( subtree ) else subtree [EOL] [EOL] result [ k ] = _parse_tree ( v , subtree ) [EOL] elif k . __class__ in wildcards : [EOL] wildcard = wildcards [ k . __class__ ] [EOL] result [ k ] = v if wildcard is Any else _parse_tree ( v , wildcard ) [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Type[typing.Union[builtins.dict,builtins.list]]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Type[typing.Union[builtins.dict,builtins.list]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Type[typing.Union[builtins.dict,builtins.list]]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from trakt . core . components . cache import CacheManager , FrozenRequest [EOL] from trakt . core . components . http_component import DefaultHttpComponent [EOL] from trakt . core . components . oauth import DefaultOauthComponent [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List , Type , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] import json [EOL] import urllib . parse [EOL] from dataclasses import dataclass , field [EOL] from typing import TYPE_CHECKING , Any , Dict , Optional [EOL] [EOL] import requests [EOL] from trakt . core . components . cache import FrozenRequest [EOL] from trakt . core . exceptions import ( BadRequest , Conflict , Forbidden , MethodNotFound , NotFound , PreconditionFailed , RateLimitExceeded , RequestRelatedError , ServerError , ServiceUnavailable , Unauthorized , UnprocessableEntity , ) [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . api import TraktApi [EOL] [EOL] STATUS_CODE_MAPPING = { [number] : BadRequest , [number] : Unauthorized , [number] : Forbidden , [number] : NotFound , [number] : MethodNotFound , [number] : Conflict , [number] : PreconditionFailed , [number] : UnprocessableEntity , [number] : RateLimitExceeded , [number] : ServerError , [number] : ServiceUnavailable , [number] : ServiceUnavailable , [number] : ServiceUnavailable , [number] : ServiceUnavailable , [number] : ServiceUnavailable , } [EOL] [EOL] [EOL] class DefaultHttpComponent : [EOL] name = [string] [EOL] client = ... [EOL] _requests = requests [EOL] _last_response = ... [EOL] [EOL] def __init__ ( self , client , requests_dependency = None ) : [EOL] self . client = client [EOL] self . _requests = requests_dependency if requests_dependency else requests [EOL] self . _last_response = None [EOL] [EOL] def request ( self , path , * , method = [string] , query_args = None , data = None , headers = None , no_raise = False , use_cache = False , ** kwargs , ) : [EOL] [EOL] url = urllib . parse . urljoin ( self . client . config [ [string] ] [ [string] ] , path ) [EOL] [EOL] query_args = query_args or { } [EOL] data = json . dumps ( data or { } ) [EOL] [EOL] headers = { [string] : [string] , ** ( headers if headers is not None else self . _get_headers ( ) ) , } [comment] [EOL] [EOL] response = self . _get_raw_response ( url , path , query_args , headers , method , data , use_cache ) [EOL] [EOL] if not no_raise : [EOL] self . _handle_code ( response ) [EOL] [EOL] json_response = self . _get_json ( response , no_raise = no_raise ) [EOL] [EOL] self . _last_response = FrozenRequest ( path , query_args , headers , response ) [EOL] [EOL] return ApiResponse ( json_response , response , self . _get_pagination_headers ( response ) ) [EOL] [EOL] def _get_raw_response ( self , url , path , query_args , headers , method , data , use_cache , ) : [EOL] if use_cache : [EOL] poss_cached_req = FrozenRequest ( path , query_args , headers , response = None ) [EOL] if self . client . cache . has ( poss_cached_req ) : [EOL] return self . client . cache . get ( poss_cached_req ) . response [EOL] [EOL] return self . _requests . request ( method , url , params = query_args , data = data , headers = headers ) [EOL] [EOL] @ staticmethod def _get_json ( response , no_raise ) : [EOL] try : [EOL] return response . json ( ) [EOL] except BaseException : [comment] [EOL] if no_raise : [EOL] return { } [EOL] else : [EOL] raise [EOL] [EOL] def _get_headers ( self ) : [EOL] headers = { [string] : [string] , [string] : self . client . client_id , [string] : [number] , } [EOL] [EOL] if self . client . user : [EOL] headers [ [string] ] = self . client . user . access_token [EOL] [EOL] str_headers = { k : str ( v ) for k , v in headers . items ( ) } [EOL] [EOL] return str_headers [EOL] [EOL] @ staticmethod def _handle_code ( response ) : [EOL] code = response . status_code [EOL] [EOL] if code in STATUS_CODE_MAPPING : [EOL] raise STATUS_CODE_MAPPING [ code ] ( code , response = response ) [EOL] [EOL] if code // [number] in { [number] , [number] } : [EOL] raise RequestRelatedError ( code = code , response = response ) [EOL] [EOL] def get_url ( self , path , query_args = None ) : [EOL] query_args = query_args or { } [EOL] [EOL] url_parts = list ( urllib . parse . urlparse ( self . client . config [ [string] ] [ [string] ] ) ) [EOL] url_parts [ [number] ] = path [EOL] url_parts [ [number] ] = urllib . parse . urlencode ( query_args or { } ) [EOL] [EOL] return urllib . parse . urlunparse ( url_parts ) [EOL] [EOL] @ staticmethod def _get_pagination_headers ( response ) : [EOL] headers = response . headers [EOL] [EOL] return { [string] : headers . get ( [string] ) , [string] : headers . get ( [string] ) , [string] : headers . get ( [string] ) , [string] : headers . get ( [string] ) , } [EOL] [EOL] @ property def last_request ( self ) : [EOL] return self . _last_response [EOL] [EOL] [EOL] @ dataclass class ApiResponse : [EOL] json = ... [EOL] original = ... [EOL] pagination = ... [EOL] code = field ( init = False ) [EOL] parsed = field ( init = False , default = None ) [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . code = self . original . status_code [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.api.TraktApi$ 0 0 0 0 0 0 0 $typing.Optional[trakt.core.components.cache.FrozenRequest]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ApiResponse$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Optional[trakt.core.components.cache.FrozenRequest]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 $trakt.core.components.cache.FrozenRequest$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.components.cache.FrozenRequest$ 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.components.cache.FrozenRequest$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[trakt.core.components.cache.FrozenRequest]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] import time [EOL] from typing import TYPE_CHECKING , NamedTuple , cast [EOL] [EOL] from trakt . core . config import TraktCredentials [EOL] from trakt . core . decorators import auth_required [EOL] from trakt . core . exceptions import TraktTimeoutError [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . api import TraktApi [EOL] [EOL] [EOL] class CodeResponse ( NamedTuple ) : [EOL] device_code = ... [EOL] user_code = ... [EOL] verification_url = ... [EOL] expires_in = ... [EOL] interval = ... [EOL] [EOL] [EOL] class DefaultOauthComponent : [EOL] name = [string] [EOL] client = ... [EOL] [EOL] def __init__ ( self , client ) : [EOL] self . client = client [EOL] [EOL] def get_redirect_url ( self , * , redirect_uri = [string] , state = [string] ) : [EOL] if not redirect_uri : [EOL] redirect_uri = self . client . config [ [string] ] [ [string] ] [EOL] [EOL] quargs = { [string] : [string] , [string] : self . client . client_id , [string] : redirect_uri , } [EOL] [EOL] if state : [EOL] quargs [ [string] ] = state [EOL] [EOL] return self . client . http . get_url ( [string] , query_args = quargs ) [EOL] [EOL] def get_token ( self , * , code , redirect_uri = [string] ) : [EOL] if not redirect_uri : [EOL] redirect_uri = self . client . config [ [string] ] [ [string] ] [EOL] [EOL] data = { [string] : code , [string] : self . client . client_id , [string] : self . client . client_secret , [string] : redirect_uri , [string] : [string] , } [EOL] [EOL] ret = self . client . http . request ( [string] , method = [string] , data = data ) . json [EOL] [EOL] self . client . user = TraktCredentials ( access_token = ret [ [string] ] , refresh_token = ret [ [string] ] , scope = ret [ [string] ] , expires_at = ( int ( ret [ [string] ] ) + int ( ret [ [string] ] ) ) , ) [EOL] [EOL] return self . client . user [EOL] [EOL] @ auth_required def refresh_token ( self , * , redirect_uri = [string] ) : [EOL] if not redirect_uri : [EOL] redirect_uri = self . client . config [ [string] ] [ [string] ] [EOL] [EOL] data = { [string] : cast ( TraktCredentials , self . client . user ) . access_token , [string] : self . client . client_id , [string] : self . client . client_secret , [string] : redirect_uri , [string] : [string] , } [EOL] [EOL] ret = self . client . http . request ( [string] , method = [string] , data = data ) . json [EOL] [EOL] self . client . user = TraktCredentials ( access_token = ret [ [string] ] , refresh_token = ret [ [string] ] , scope = ret [ [string] ] , expires_at = ( int ( ret [ [string] ] ) + int ( ret [ [string] ] ) ) , ) [EOL] [EOL] return self . client . user [EOL] [EOL] @ auth_required def revoke_token ( self ) : [EOL] data = { [string] : cast ( TraktCredentials , self . client . user ) . access_token , [string] : self . client . client_id , [string] : self . client . client_secret , } [EOL] [EOL] self . client . http . request ( [string] , method = [string] , data = data , headers = { } ) [EOL] self . client . user = None [EOL] [EOL] def get_verification_code ( self ) : [EOL] data = { [string] : self . client . client_id } [EOL] [EOL] ret = self . client . http . request ( [string] , method = [string] , data = data , headers = { } ) [EOL] [EOL] return CodeResponse ( ** ret . json ) [EOL] [EOL] def wait_for_verification ( self , * , code ) : [EOL] data = { [string] : code . device_code , [string] : self . client . client_id , [string] : self . client . client_secret , } [EOL] [EOL] elapsed_time = [number] [EOL] while True : [EOL] ret = self . client . http . request ( [string] , method = [string] , data = data , return_code = True , headers = { } , no_raise = True , ) [EOL] if ret . original . status_code == [number] : [EOL] break [EOL] [EOL] elapsed_time += code . interval + [number] [EOL] if elapsed_time > code . expires_in : [EOL] raise TraktTimeoutError ( message = [string] ) [EOL] [EOL] self . sleep ( code . interval + [number] ) [EOL] [EOL] self . client . user = TraktCredentials ( access_token = ret . json [ [string] ] , refresh_token = ret . json [ [string] ] , scope = ret . json [ [string] ] , expires_at = ( int ( ret . json [ [string] ] ) + int ( ret . json [ [string] ] ) ) , ) [EOL] [EOL] return self . client . user [EOL] [EOL] def sleep ( self , t ) : [comment] [EOL] return time . sleep ( t ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $trakt.api.TraktApi$ 0 0 0 0 0 $None$ 0 0 0 $trakt.api.TraktApi$ 0 0 0 0 0 $trakt.api.TraktApi$ 0 $trakt.api.TraktApi$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $trakt.core.config.TraktCredentials$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.config.TraktCredentials$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $CodeResponse$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.components.http_component.ApiResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.components.http_component.ApiResponse$ 0 0 0 0 0 0 $trakt.core.config.TraktCredentials$ 0 0 0 0 0 $CodeResponse$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $CodeResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $trakt.core.components.http_component.ApiResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.components.http_component.ApiResponse$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $CodeResponse$ 0 0 0 0 0 0 $builtins.float$ 0 $CodeResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $CodeResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.components.http_component.ApiResponse$ 0 0 0 0 0 0 0 0 $trakt.core.components.http_component.ApiResponse$ 0 0 0 0 0 0 0 0 $trakt.core.components.http_component.ApiResponse$ 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.components.http_component.ApiResponse$ 0 0 0 0 0 0 0 0 0 $trakt.core.components.http_component.ApiResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0
from typing import Callable , Dict , Union , List , Type , Tuple , ItemsView , Any [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] from typing import TYPE_CHECKING , Any , Callable , Dict , List , Tuple , Type , Union [EOL] [EOL] from trakt . core . components . http_component import ApiResponse [EOL] from trakt . core . exceptions import ArgumentError [EOL] from trakt . core . models import Episode , Movie , Person , Season , Show , TraktList [EOL] from trakt . core . paths . response_structs import Comment [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . api import TraktApi [EOL] from trakt . core . executors import Executor [EOL] from trakt . core . paths . path import Path [EOL] [EOL] [EOL] class SuiteInterface : [EOL] paths = { } [EOL] client = ... [EOL] executor_class = ... [EOL] name = ... [EOL] [EOL] def __init__ ( self , client , executor ) : [EOL] self . client = client [EOL] self . executor_class = executor [EOL] [EOL] def find_matching ( self , name ) : [EOL] poss_paths = self . paths . items ( ) [EOL] [EOL] params = name . split ( [string] ) if isinstance ( name , str ) else name [EOL] if params [ [number] ] == self . name : [EOL] params = params [ [number] : ] [EOL] [EOL] alias = [string] . join ( params ) [EOL] return [ ( p , getattr ( self , k ) ) for k , p in poss_paths if p . does_match ( alias ) ] [EOL] [EOL] def run ( self , command , ** kwargs ) : [EOL] return self . run_path ( path = self . _get_path ( command ) , ** kwargs ) [EOL] [EOL] def run_path ( self , path , return_extras = False , ** kwargs ) : [EOL] r = self . executor_class ( self . client ) . run ( path = path , ** kwargs ) [EOL] [EOL] if isinstance ( r , ApiResponse ) : [EOL] if return_extras : [EOL] return r [EOL] return r . parsed [EOL] [EOL] return r [EOL] [EOL] def _get_path ( self , command ) : [EOL] return self . paths [ command ] [EOL] [EOL] @ staticmethod def _generic_get_id ( item ) : [EOL] if isinstance ( item , ( int , str ) ) : [EOL] return item [EOL] if isinstance ( item , Comment ) : [EOL] return item . id [EOL] elif isinstance ( item , ( Movie , Episode , Show , Season , TraktList , Person ) ) : [EOL] return item . ids . trakt [EOL] else : [EOL] raise ArgumentError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 $trakt.api.TraktApi$ 0 0 0 $typing.Type[trakt.core.executors.Executor]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $trakt.api.TraktApi$ 0 $typing.Type[trakt.core.executors.Executor]$ 0 0 0 0 0 $trakt.api.TraktApi$ 0 $trakt.api.TraktApi$ 0 0 0 $typing.Type[trakt.core.executors.Executor]$ 0 $typing.Type[trakt.core.executors.Executor]$ 0 0 0 $typing.List[typing.Tuple[trakt.core.paths.path.Path,typing.Callable]]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 $typing.ItemsView[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ItemsView[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $trakt.core.paths.path.Path$ 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Union[trakt.core.executors.PaginationIterator[typing.Any],trakt.core.components.http_component.ApiResponse]$ 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.path.Path$ 0 $trakt.core.paths.path.Path$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Union[trakt.core.executors.PaginationIterator[typing.Any],trakt.core.components.http_component.ApiResponse]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Union[trakt.core.executors.PaginationIterator[typing.Any],trakt.core.components.http_component.ApiResponse]$ 0 0 $typing.Union[trakt.core.executors.PaginationIterator[typing.Any],trakt.core.components.http_component.ApiResponse]$ 0 0 0 0 0 $typing.Union[trakt.core.executors.PaginationIterator[typing.Any],trakt.core.components.http_component.ApiResponse]$ 0 0 0 $trakt.core.paths.path.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[trakt.core.models.Movie,trakt.core.models.Episode,trakt.core.models.Show,trakt.core.models.Season,trakt.core.paths.response_structs.Comment,trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,trakt.core.models.Episode,trakt.core.models.Show,trakt.core.models.Season,trakt.core.paths.response_structs.Comment,trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,trakt.core.models.Episode,trakt.core.models.Show,trakt.core.models.Season,trakt.core.paths.response_structs.Comment,trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 $typing.Union[trakt.core.models.Movie,trakt.core.models.Episode,trakt.core.models.Show,trakt.core.models.Season,trakt.core.paths.response_structs.Comment,trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,trakt.core.models.Episode,trakt.core.models.Show,trakt.core.models.Season,trakt.core.paths.response_structs.Comment,trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,trakt.core.models.Episode,trakt.core.models.Show,trakt.core.models.Season,trakt.core.paths.response_structs.Comment,trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,trakt.core.models.Episode,trakt.core.models.Show,trakt.core.models.Season,trakt.core.paths.response_structs.Comment,trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict [EOL] import typing [EOL] from trakt . core . paths . endpoint_mappings . calendars import CalendarsI [EOL] from trakt . core . paths . endpoint_mappings . checkin import CheckinI [EOL] from trakt . core . paths . endpoint_mappings . comments import CommentsI [EOL] from trakt . core . paths . endpoint_mappings . episodes import EpisodesI [EOL] from trakt . core . paths . endpoint_mappings . misc_mappings import ( CertificationsI , CountriesI , GenresI , LanguagesI , ListsI , NetworksI , Path , ) [EOL] from trakt . core . paths . endpoint_mappings . movies import MoviesI [EOL] from trakt . core . paths . endpoint_mappings . people import PeopleI [EOL] from trakt . core . paths . endpoint_mappings . recommendations import RecommendationsI [EOL] from trakt . core . paths . endpoint_mappings . scrobble import ScrobbleI [EOL] from trakt . core . paths . endpoint_mappings . search import SearchI [EOL] from trakt . core . paths . endpoint_mappings . seasons import SeasonsI [EOL] from trakt . core . paths . endpoint_mappings . shows import ShowsI [EOL] [EOL] DEFAULT_INTERFACES = { [string] : CountriesI , [string] : CalendarsI , [string] : ShowsI , [string] : GenresI , [string] : CertificationsI , [string] : LanguagesI , [string] : ListsI , [string] : MoviesI , [string] : CheckinI , [string] : PeopleI , [string] : NetworksI , [string] : CommentsI , [string] : SearchI , [string] : RecommendationsI , [string] : ScrobbleI , [string] : SeasonsI , [string] : EpisodesI , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict , Union , List , Optional , Tuple , Any [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] from typing import TYPE_CHECKING , Any , Dict , List , Optional , Set , Tuple , Union [EOL] [EOL] from trakt . core . components . cache import CacheLevel [EOL] from trakt . core . exceptions import ClientError [EOL] from trakt . core . paths . validators import ( MULTI_FILTERS , ExtendedValidator , FiltersValidator , OptionalArgsValidator , RequiredArgsValidator , Validator , ) [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . api import TraktApi [EOL] [EOL] DEFAULT_VALIDATORS = [ RequiredArgsValidator ( ) , OptionalArgsValidator ( ) , ExtendedValidator ( ) , FiltersValidator ( ) , ] [EOL] [EOL] [EOL] class Path : [EOL] path = ... [EOL] args = ... [EOL] req_args = ... [EOL] opt_args = ... [EOL] methods = ... [EOL] validators = ... [EOL] aliases = ... [EOL] extended = ... [EOL] filters = ... [EOL] pagination = ... [EOL] cache_level = ... [EOL] [EOL] _output_structure = ... [EOL] [EOL] __bound_client = ... [EOL] __bound_kwargs = ... [EOL] [EOL] def __init__ ( self , path , output_structure , * , methods = [string] , validators = None , qargs = None , aliases = None , extended = None , filters = None , pagination = False , cache_level = None ) : [EOL] self . path = path [EOL] self . _output_structure = output_structure [EOL] [EOL] if isinstance ( methods , str ) : [EOL] methods = [ methods ] [EOL] [EOL] self . methods = [ m . upper ( ) for m in methods ] [EOL] self . validators = DEFAULT_VALIDATORS + ( validators or [ ] ) [EOL] [EOL] self . params = path . split ( [string] ) [EOL] self . args = [ p for p in self . params if p [ [number] ] in [string] ] [EOL] self . req_args = [ p for p in self . args if p [ [number] ] == [string] ] [EOL] self . opt_args = [ p for p in self . args if p [ [number] ] == [string] ] [EOL] [EOL] default_alias = [string] . join ( [ p for p in self . params if p [ [number] ] not in [string] ] ) [EOL] self . aliases = [ default_alias ] + ( aliases or [ ] ) [EOL] [EOL] self . qargs = qargs or [ ] [EOL] [EOL] self . extended = extended or [ ] [EOL] self . filters = filters or set ( ) [EOL] [EOL] self . pagination = pagination [EOL] [EOL] self . __bound_client = None [EOL] [EOL] self . cache_level = self . _determine_cache_level ( cache_level ) [EOL] [EOL] def does_match ( self , name ) : [EOL] return name in self . aliases [EOL] [EOL] def is_valid ( self , client , ** kwargs ) : [EOL] for v in self . validators : [EOL] v . validate ( self , client = client , path = self , ** kwargs ) [comment] [EOL] [EOL] self . __bound_client = client [EOL] self . __bound_kwargs = kwargs [EOL] [EOL] return True [EOL] [EOL] def _get_param_value ( self , param ) : [EOL] if param not in self . args : [EOL] return param [EOL] [EOL] arg_name = param [ [number] : ] [EOL] [EOL] if param in self . req_args : [EOL] return self . __bound_kwargs [ arg_name ] [EOL] [EOL] if param in self . opt_args : [EOL] return self . __bound_kwargs . get ( arg_name ) [EOL] [EOL] def get_path_and_qargs ( self ) : [EOL] if not self . is_bound ( ) : [comment] [EOL] raise ClientError ( [string] ) [EOL] [EOL] parts = [ self . _get_param_value ( p ) for p in self . params ] [EOL] parts = [ str ( p ) for p in parts if p ] [comment] [EOL] [EOL] qargs = { q : self . __bound_kwargs [ q ] for q in self . qargs if q in self . __bound_kwargs } [EOL] [EOL] qargs . update ( self . _get_parsed_filters ( ) ) [EOL] [EOL] if [string] in self . __bound_kwargs and self . __bound_kwargs [ [string] ] : [EOL] if self . __bound_kwargs [ [string] ] is True : [EOL] [comment] [EOL] [comment] [EOL] self . __bound_kwargs [ [string] ] = self . extended [ [number] ] [EOL] [EOL] qargs [ [string] ] = self . __bound_kwargs [ [string] ] [EOL] [EOL] qargs = { k : self . _stringify_param ( v ) for k , v in qargs . items ( ) } [EOL] [EOL] return [string] . join ( parts ) , qargs [EOL] [EOL] @ staticmethod def _stringify_param ( v ) : [EOL] if isinstance ( v , bool ) : [EOL] return [string] if v else [string] [EOL] return str ( v ) [EOL] [EOL] def _get_parsed_filters ( self ) : [EOL] m = { } [EOL] [EOL] for f in self . filters : [EOL] if f in self . __bound_kwargs : [EOL] val = self . __bound_kwargs [ f ] [EOL] [EOL] if f in MULTI_FILTERS and isinstance ( val , ( tuple , list ) ) : [EOL] val = [string] . join ( val ) [EOL] [EOL] m [ f ] = str ( val ) [EOL] [EOL] return m [EOL] [EOL] def is_bound ( self ) : [EOL] return self . __bound_client is not None [EOL] [EOL] @ property def response_structure ( self ) : [EOL] return self . _output_structure [EOL] [EOL] @ property def method ( self ) : [EOL] return self . methods [ [number] ] [EOL] [EOL] def _determine_cache_level ( self , cache_level ) : [EOL] if set ( self . methods ) & { [string] , [string] , [string] } : [EOL] return CacheLevel . NO [EOL] [EOL] if cache_level : [comment] [EOL] if isinstance ( cache_level , str ) : [EOL] cache_level = CacheLevel ( cache_level . lower ( ) ) [EOL] [EOL] return cache_level [EOL] [EOL] return CacheLevel . FULL [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[trakt.core.paths.validators.Validator]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $trakt.core.components.cache.CacheLevel$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[trakt.api.TraktApi]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.components.cache.CacheLevel$ 0 0 0 $trakt.core.components.cache.CacheLevel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.components.cache.CacheLevel$ 0 0 0 0 0 0 $trakt.core.components.cache.CacheLevel$ 0 0 0 0 0 $trakt.core.components.cache.CacheLevel$ 0 0 0 $trakt.core.components.cache.CacheLevel$ 0 0 0 0 0 0 0 0 $trakt.core.components.cache.CacheLevel$ 0 0 0 0 0 0 0 0
from typing import Set , Callable , Dict , List , Any [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] import datetime [EOL] import re [EOL] from typing import TYPE_CHECKING , Any , Callable , Dict , List [EOL] [EOL] from trakt . core . exceptions import ArgumentError , NotAuthenticated [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . api import TraktApi [EOL] [EOL] SINGLE_FILTERS = { [string] , [string] , [string] , [string] } [EOL] MULTI_FILTERS = { [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] MOVIE_FILTERS = { [string] } [EOL] SHOWS_FILTERS = { [string] , [string] , [string] } [EOL] [EOL] [EOL] COMMON_FILTERS = SINGLE_FILTERS | { [string] , [string] , [string] } [EOL] [EOL] ALL_FILTERS = SINGLE_FILTERS | MULTI_FILTERS [EOL] [EOL] STATUS_FILTER_VALUES = { [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] [EOL] class Validator : [EOL] def validate ( self , * args , client , path , ** kwargs ) : [comment] [EOL] return None [EOL] [EOL] [EOL] class AuthRequiredValidator ( Validator ) : [EOL] def validate ( self , * args , client , ** kwargs ) : [EOL] if not client . user : [EOL] raise NotAuthenticated [EOL] [EOL] [EOL] class RequiredArgsValidator ( Validator ) : [EOL] def validate ( self , * args , path , ** kwargs ) : [EOL] for p in path . req_args : [EOL] arg_name = p [ [number] : ] [EOL] if arg_name not in kwargs or kwargs [ arg_name ] in ( None , [ ] , { } ) : [EOL] raise ArgumentError ( f" [string] { arg_name } [string] " ) [EOL] [EOL] [EOL] class OptionalArgsValidator ( Validator ) : [EOL] [docstring] [EOL] [EOL] def validate ( self , * args , path , ** kwargs ) : [EOL] require_previous = False [EOL] [EOL] for p in path . opt_args [ : : - [number] ] : [EOL] arg_name = p [ [number] : ] [EOL] if require_previous : [EOL] if arg_name not in kwargs or kwargs [ arg_name ] in ( None , [ ] , { } ) : [EOL] raise ArgumentError ( f" [string] { arg_name } [string] " ) [EOL] elif arg_name in kwargs : [EOL] require_previous = True [EOL] [EOL] [EOL] class PerArgValidator ( Validator ) : [EOL] def __init__ ( self , arg_name , f ) : [EOL] self . arg_name = arg_name [EOL] self . boolean_check = f [EOL] [EOL] def validate ( self , * args , ** kwargs ) : [EOL] if self . arg_name in kwargs : [EOL] if not bool ( self . boolean_check ( kwargs [ self . arg_name ] ) ) : [EOL] raise ArgumentError ( f" [string] { self . arg_name } [string] { kwargs [ self . arg_name ] } [string] " ) [EOL] [EOL] [EOL] class ExtendedValidator ( Validator ) : [EOL] def validate ( self , * args , path , ** kwargs ) : [EOL] if [string] in kwargs : [EOL] if len ( path . extended ) == [number] and kwargs [ [string] ] is True : [EOL] return [comment] [EOL] [EOL] if kwargs [ [string] ] and kwargs [ [string] ] not in path . extended : [EOL] message = f" [string] { kwargs [ [string] ] } [string] " [EOL] [EOL] if path . extended : [EOL] message += f" [string] { path . extended }" [EOL] else : [EOL] message += [string] [EOL] [EOL] raise ArgumentError ( message ) [EOL] [EOL] [EOL] class FiltersValidator ( Validator ) : [EOL] filter_value_validators = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . filter_value_validators = { [string] : lambda s : isinstance ( s , str ) and s , [string] : self . years_filter_validator , [string] : lambda g : isinstance ( g , str ) and g , [string] : lambda l : isinstance ( l , str ) and len ( l ) == [number] , [string] : lambda c : isinstance ( c , str ) and len ( c ) == [number] , [string] : lambda r : isinstance ( r , ( int , str ) ) and int ( r ) in range ( [number] ) , [string] : self . ratings_filter_validator , [string] : lambda c : isinstance ( c , str ) and c , [string] : lambda n : isinstance ( n , str ) and n , [string] : lambda s : s in STATUS_FILTER_VALUES , } [EOL] [EOL] def validate ( self , * args , path , ** kwargs ) : [EOL] for k in kwargs : [EOL] if k in ALL_FILTERS : [EOL] self . _validate_filter_arg ( path . filters , k , kwargs [ k ] ) [EOL] [EOL] def _validate_filter_arg ( self , allowed_filters , filter , value ) : [EOL] if filter not in allowed_filters : [EOL] raise ArgumentError ( f" [string] { filter } [string] " ) [EOL] [EOL] if filter in SINGLE_FILTERS and not isinstance ( value , ( int , str ) ) : [EOL] raise ArgumentError ( f"{ filter } [string] " ) [EOL] [EOL] if filter in MULTI_FILTERS : [EOL] self . _validate_multi_filter ( filter , value ) [EOL] [EOL] self . _validate_filter_value ( filter , value ) [EOL] [EOL] def _validate_multi_filter ( self , filter , value ) : [EOL] if not isinstance ( value , ( tuple , list , str ) ) : [EOL] raise ArgumentError ( f"{ filter } [string] " ) [EOL] if isinstance ( value , ( list , tuple ) ) : [EOL] for v in value : [EOL] if not isinstance ( v , str ) : [EOL] raise ArgumentError ( f"{ filter } [string] " ) [EOL] [EOL] def _validate_filter_value ( self , filter , value ) : [EOL] if not isinstance ( value , ( list , tuple ) ) : [EOL] value = [ value ] [EOL] for v in value : [EOL] if not self . filter_value_validators [ filter ] ( v ) : [EOL] raise ArgumentError ( f"{ filter } [string] { v } [string] " ) [EOL] [EOL] @ staticmethod def years_filter_validator ( years ) : [EOL] years = [ years ] if isinstance ( years , int ) else years . split ( [string] ) [EOL] [EOL] if len ( years ) not in { [number] , [number] } : [EOL] return False [EOL] [EOL] for y in years : [EOL] try : [EOL] if int ( y ) not in range ( [number] , [number] ) : [EOL] return False [EOL] except ValueError : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] @ staticmethod def ratings_filter_validator ( ratings ) : [EOL] return isinstance ( ratings , str ) and re . match ( [string] , ratings ) [EOL] [EOL] [EOL] def is_date ( d , format = [string] ) : [EOL] try : [EOL] datetime . datetime . strptime ( d , format ) [EOL] return True [EOL] except ValueError : [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $trakt.api.TraktApi$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $trakt.api.TraktApi$ 0 0 $typing.Any$ 0 0 0 0 0 $trakt.api.TraktApi$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Callable[[typing.Any],typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Callable[[typing.Any],typing.Any]$ 0 $typing.Callable[[typing.Any],typing.Any]$ 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Callable[[typing.Any],builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Callable[[typing.Any],builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] from typing import TYPE_CHECKING , List , Union [EOL] [EOL] from trakt . core . models import Comment , Episode , Season [EOL] from trakt . core . paths . endpoint_mappings . movies import ( COMMENT_SORT_VALUES , LIST_SORT_VALUES , LIST_TYPE_VALUES , ) [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . response_structs import ( EpisodeTranslation , RatingsSummary , SeasonEpisodeStats , Show , TraktList , User , ) [EOL] from trakt . core . paths . suite_interface import SuiteInterface [EOL] from trakt . core . paths . validators import PerArgValidator [EOL] [EOL] ID_VALIDATOR = PerArgValidator ( [string] , lambda i : isinstance ( i , ( int , str ) ) ) [EOL] SEASON_ID_VALIDATOR = PerArgValidator ( [string] , lambda i : isinstance ( i , int ) ) [EOL] EPISODE_ID_VALIDATOR = PerArgValidator ( [string] , lambda i : isinstance ( i , int ) ) [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . core . executors import PaginationIterator [EOL] [EOL] [EOL] class EpisodesI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , Episode , extended = [ [string] ] , validators = [ ID_VALIDATOR , SEASON_ID_VALIDATOR , EPISODE_ID_VALIDATOR ] , ) , [string] : Path ( [string] , [ EpisodeTranslation ] , validators = [ ID_VALIDATOR , SEASON_ID_VALIDATOR , EPISODE_ID_VALIDATOR , PerArgValidator ( [string] , lambda s : isinstance ( s , str ) ) , ] , ) , [string] : Path ( [string] , [ Comment ] , validators = [ ID_VALIDATOR , SEASON_ID_VALIDATOR , EPISODE_ID_VALIDATOR , PerArgValidator ( [string] , lambda s : s in COMMENT_SORT_VALUES ) , ] , pagination = True , ) , [string] : Path ( [string] , [ TraktList ] , validators = [ ID_VALIDATOR , SEASON_ID_VALIDATOR , EPISODE_ID_VALIDATOR , PerArgValidator ( [string] , lambda t : t in LIST_TYPE_VALUES ) , PerArgValidator ( [string] , lambda s : s in LIST_SORT_VALUES ) , ] , pagination = True , ) , [string] : Path ( [string] , RatingsSummary , validators = [ ID_VALIDATOR , SEASON_ID_VALIDATOR , EPISODE_ID_VALIDATOR ] , ) , [string] : Path ( [string] , SeasonEpisodeStats , validators = [ ID_VALIDATOR , SEASON_ID_VALIDATOR , EPISODE_ID_VALIDATOR ] , ) , [string] : Path ( [string] , [ User ] , extended = [ [string] ] , validators = [ ID_VALIDATOR , SEASON_ID_VALIDATOR , EPISODE_ID_VALIDATOR ] , ) , } [EOL] [EOL] def get_episode ( self , * , show , season , episode , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] season = self . _generic_get_id ( season ) [EOL] episode = self . _generic_get_id ( episode ) [EOL] return self . run ( [string] , ** kwargs , id = id , season = season , episode = episode ) [EOL] [EOL] def get_comments ( self , * , show , season , episode , sort = [string] , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] season = self . _generic_get_id ( season ) [EOL] episode = self . _generic_get_id ( episode ) [EOL] return self . run ( [string] , ** kwargs , sort = sort , id = id , season = season , episode = episode ) [EOL] [EOL] def get_translations ( self , * , show , season , episode , sort = [string] , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] season = self . _generic_get_id ( season ) [EOL] episode = self . _generic_get_id ( episode ) [EOL] return self . run ( [string] , ** kwargs , sort = sort , id = id , season = season , episode = episode ) [EOL] [EOL] def get_lists ( self , * , show , season , episode , type = [string] , sort = [string] , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] season = self . _generic_get_id ( season ) [EOL] episode = self . _generic_get_id ( episode ) [EOL] return self . run ( [string] , ** kwargs , type = type , sort = sort , id = id , season = season , episode = episode ) [EOL] [EOL] def get_ratings ( self , * , show , season , episode , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] season = self . _generic_get_id ( season ) [EOL] episode = self . _generic_get_id ( episode ) [EOL] return self . run ( [string] , ** kwargs , id = id , season = season , episode = episode ) [EOL] [EOL] def get_stats ( self , * , show , season , episode , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] season = self . _generic_get_id ( season ) [EOL] episode = self . _generic_get_id ( episode ) [EOL] return self . run ( [string] , ** kwargs , id = id , season = season , episode = episode ) [EOL] [EOL] def get_users_watching ( self , * , show , season , episode , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] season = self . _generic_get_id ( season ) [EOL] episode = self . _generic_get_id ( episode ) [EOL] return self . run ( [string] , ** kwargs , id = id , season = season , episode = episode ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 $trakt.core.models.Season$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 $trakt.core.executors.PaginationIterator[trakt.core.models.Comment]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 $typing.List[trakt.core.models.Comment]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 $trakt.core.executors.PaginationIterator[trakt.core.paths.response_structs.TraktList]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 $trakt.core.paths.response_structs.RatingsSummary$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 $trakt.core.paths.response_structs.SeasonEpisodeStats$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.User]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Season]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 $typing.Union[builtins.int,builtins.str,trakt.core.models.Episode]$ 0 0
from typing import Dict , Union , List [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from typing import List , Union [EOL] [EOL] from trakt . core . models import Person , TraktList [EOL] from trakt . core . paths . endpoint_mappings . movies import LIST_SORT_VALUES , LIST_TYPE_VALUES [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . response_structs import MovieCredits , ShowCredits [EOL] from trakt . core . paths . suite_interface import SuiteInterface [EOL] from trakt . core . paths . validators import PerArgValidator [EOL] [EOL] PERSON_ID_VALIDATOR = PerArgValidator ( [string] , lambda c : isinstance ( c , ( int , str ) ) ) [EOL] [EOL] [EOL] class PeopleI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , Person , validators = [ PERSON_ID_VALIDATOR ] , extended = [ [string] ] , cache_level = [string] , ) , [string] : Path ( [string] , MovieCredits , validators = [ PERSON_ID_VALIDATOR ] , extended = [ [string] ] , cache_level = [string] , ) , [string] : Path ( [string] , ShowCredits , validators = [ PERSON_ID_VALIDATOR ] , extended = [ [string] ] , cache_level = [string] , ) , [string] : Path ( [string] , [ TraktList ] , validators = [ PERSON_ID_VALIDATOR , PerArgValidator ( [string] , lambda t : t in LIST_TYPE_VALUES ) , PerArgValidator ( [string] , lambda s : s in LIST_SORT_VALUES ) , ] , extended = [ [string] ] , cache_level = [string] , ) , } [EOL] [EOL] def get_person ( self , person , ** kwargs ) : [EOL] id = self . _get_person_id ( person ) [EOL] return self . run ( [string] , ** kwargs , id = id ) [EOL] [EOL] def get_movie_credits ( self , person , ** kwargs ) : [EOL] id = self . _get_person_id ( person ) [EOL] return self . run ( [string] , ** kwargs , id = id ) [EOL] [EOL] def get_show_credits ( self , person , ** kwargs ) : [EOL] id = self . _get_person_id ( person ) [EOL] return self . run ( [string] , ** kwargs , id = id ) [EOL] [EOL] def get_lists ( self , person , ** kwargs ) : [EOL] id = self . _get_person_id ( person ) [EOL] return self . run ( [string] , ** kwargs , id = id ) [EOL] [EOL] def _get_person_id ( self , p ) : [EOL] return str ( self . _generic_get_id ( item = p ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.models.Person$ 0 0 0 $typing.Union[trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $trakt.core.paths.response_structs.MovieCredits$ 0 0 0 $typing.Union[trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $trakt.core.paths.response_structs.ShowCredits$ 0 0 0 $typing.Union[trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.List[trakt.core.models.TraktList]$ 0 0 0 $typing.Union[trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[trakt.core.models.Person,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[trakt.core.models.Person,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.models.Person,builtins.int,builtins.str]$ 0 0 0
from typing import Dict , Union , List , Type , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from typing import Any , Dict , Optional , Union [EOL] [EOL] from trakt . core . exceptions import ArgumentError [EOL] from trakt . core . models import Episode , Movie [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . response_structs import EpisodeScrobble , MovieScrobble , Show [EOL] from trakt . core . paths . suite_interface import SuiteInterface [EOL] from trakt . core . paths . validators import AuthRequiredValidator , PerArgValidator [EOL] [EOL] PROGRESS_VALIDATOR = PerArgValidator ( [string] , lambda p : isinstance ( p , ( int , float ) ) and [number] >= p >= [number] ) [EOL] [EOL] [EOL] class ScrobbleI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] base_paths = { [string] : [ [string] , MovieScrobble ] , [string] : [ [string] , EpisodeScrobble ] , [string] : [ [string] , MovieScrobble ] , [string] : [ [string] , EpisodeScrobble ] , [string] : [ [string] , MovieScrobble ] , [string] : [ [string] , EpisodeScrobble ] , } [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] for k , r in self . base_paths . items ( ) : [EOL] self . paths [ k ] = self . _make_path ( * r ) [EOL] [EOL] def _make_path ( self , resource_path , return_type ) : [EOL] return Path ( self . name + [string] + resource_path , return_type , validators = [ AuthRequiredValidator ( ) , PROGRESS_VALIDATOR ] , ) [EOL] [EOL] def start_scrobble ( self , * , movie = None , episode = None , show = None , progress , ** kwargs , ) : [EOL] if movie and episode : [EOL] raise ArgumentError ( [string] ) [EOL] [EOL] if movie : [EOL] return self . start_scrobble_movie ( movie = movie , progress = progress , ** kwargs ) [EOL] elif episode : [EOL] return self . start_scrobble_episode ( episode = episode , show = show , progress = progress , ** kwargs ) [EOL] else : [EOL] raise ArgumentError ( [string] ) [EOL] [EOL] def start_scrobble_movie ( self , * , movie , progress , ** kwargs ) : [EOL] data = self . _prepare_movie_data ( movie = movie , progress = progress ) [EOL] return self . run ( [string] , ** kwargs , body = data , progress = progress ) [EOL] [EOL] def start_scrobble_episode ( self , * , episode , progress , ** kwargs ) : [EOL] data = self . _prepare_episode_data ( episode , progress , show = kwargs . get ( [string] ) ) [EOL] return self . run ( [string] , ** kwargs , body = data , progress = progress ) [EOL] [EOL] def pause_scrobble ( self , * , movie = None , episode = None , show = None , ** kwargs , ) : [EOL] if movie and episode : [EOL] raise ArgumentError ( [string] ) [EOL] [EOL] if movie : [EOL] return self . pause_scrobble_movie ( movie = movie , ** kwargs ) [EOL] elif episode : [EOL] return self . pause_scrobble_episode ( episode = episode , show = show , ** kwargs ) [EOL] else : [EOL] raise ArgumentError ( [string] ) [EOL] [EOL] def pause_scrobble_movie ( self , * , movie , progress , ** kwargs ) : [EOL] data = self . _prepare_movie_data ( movie = movie , progress = progress ) [EOL] return self . run ( [string] , ** kwargs , body = data , progress = progress ) [EOL] [EOL] def pause_scrobble_episode ( self , * , episode , progress , ** kwargs ) : [EOL] data = self . _prepare_episode_data ( episode , progress , show = kwargs . get ( [string] ) ) [EOL] return self . run ( [string] , ** kwargs , body = data , progress = progress ) [EOL] [EOL] def stop_scrobble ( self , * , movie = None , episode = None , show = None , ** kwargs , ) : [EOL] if movie and episode : [EOL] raise ArgumentError ( [string] ) [EOL] [EOL] if movie : [EOL] return self . stop_scrobble_movie ( movie = movie , ** kwargs ) [EOL] elif episode : [EOL] return self . stop_scrobble_episode ( episode = episode , show = show , ** kwargs ) [EOL] else : [EOL] raise ArgumentError ( [string] ) [EOL] [EOL] def stop_scrobble_movie ( self , * , movie , progress , ** kwargs ) : [EOL] data = self . _prepare_movie_data ( movie = movie , progress = progress ) [EOL] return self . run ( [string] , ** kwargs , body = data , progress = progress ) [EOL] [EOL] def stop_scrobble_episode ( self , * , episode , progress , ** kwargs ) : [EOL] data = self . _prepare_episode_data ( episode , progress , show = kwargs . get ( [string] ) ) [EOL] return self . run ( [string] , ** kwargs , body = data , progress = progress ) [EOL] [EOL] def _prepare_episode_data ( self , episode , progress , show = None , ) : [EOL] data = { [string] : progress } [EOL] [EOL] if isinstance ( episode , Episode ) : [EOL] episode = { [string] : { [string] : self . _generic_get_id ( episode ) } } [EOL] data [ [string] ] = episode [EOL] [EOL] if show : [EOL] if isinstance ( show , Show ) : [EOL] data [ [string] ] = { [string] : { [string] : self . _generic_get_id ( show ) } } [EOL] else : [EOL] data [ [string] ] = show [EOL] [EOL] return data [EOL] [EOL] def _prepare_movie_data ( self , progress , movie ) : [EOL] data = { [string] : progress } [EOL] [EOL] if isinstance ( movie , Movie ) : [EOL] data [ [string] ] = { [string] : { [string] : self . _generic_get_id ( movie ) } } [EOL] else : [EOL] data [ [string] ] = movie [EOL] [EOL] return data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.path.Path$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.MovieScrobble,trakt.core.paths.response_structs.EpisodeScrobble]$ 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,typing.Dict[builtins.str,typing.Any]]]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.response_structs.MovieScrobble$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $trakt.core.paths.response_structs.EpisodeScrobble$ 0 0 0 0 0 $typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.MovieScrobble,trakt.core.paths.response_structs.EpisodeScrobble]$ 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,typing.Dict[builtins.str,typing.Any]]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.response_structs.MovieScrobble$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $trakt.core.paths.response_structs.EpisodeScrobble$ 0 0 0 0 0 $typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.MovieScrobble,trakt.core.paths.response_structs.EpisodeScrobble]$ 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]]$ 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,typing.Dict[builtins.str,typing.Any]]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.response_structs.MovieScrobble$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $trakt.core.paths.response_structs.EpisodeScrobble$ 0 0 0 0 0 $typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Union[trakt.core.models.Episode,typing.Dict[builtins.str,typing.Any]]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 $builtins.float$ 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,builtins.int,builtins.str]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,builtins.int,builtins.str]]$ 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,builtins.int,builtins.str]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Optional[typing.Union[trakt.core.paths.response_structs.Show,builtins.int,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.float$ 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Union[trakt.core.models.Movie,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] from typing import TYPE_CHECKING , Any , List [EOL] [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . response_structs import ( Certification , Country , Genre , Language , ListResponse , Network , ) [EOL] from trakt . core . paths . suite_interface import SuiteInterface [EOL] from trakt . core . paths . validators import PerArgValidator [EOL] [EOL] TYPE_MOVIES_SHOWS = PerArgValidator ( [string] , lambda t : t in { [string] , [string] } ) [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . core . executors import PaginationIterator [EOL] [EOL] [EOL] class CountriesI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , [ Country ] , aliases = [ [string] , [string] ] , validators = [ TYPE_MOVIES_SHOWS ] , cache_level = [string] , ) } [EOL] [EOL] def get_countries ( self , * , type , ** kwargs ) : [EOL] return self . run ( [string] , type = type , ** kwargs ) [EOL] [EOL] [EOL] class CertificationsI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , { [string] : [ Certification ] } , validators = [ TYPE_MOVIES_SHOWS ] , cache_level = [string] , ) } [EOL] [EOL] def get_certifications ( self , * , type , ** kwargs ) : [EOL] ret = self . run ( [string] , type = type , ** kwargs ) [EOL] return ret [ [string] ] [EOL] [EOL] [EOL] class GenresI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , [ Genre ] , validators = [ TYPE_MOVIES_SHOWS ] , cache_level = [string] ) } [EOL] [EOL] def get_genres ( self , * , type , ** kwargs ) : [EOL] return self . run ( [string] , type = type , ** kwargs ) [EOL] [EOL] [EOL] class LanguagesI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , [ Language ] , validators = [ TYPE_MOVIES_SHOWS ] , cache_level = [string] , ) } [EOL] [EOL] def get_languages ( self , * , type , ** kwargs ) : [EOL] return self . run ( [string] , type = type , ** kwargs ) [EOL] [EOL] [EOL] class ListsI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , [ ListResponse ] , extended = [ [string] ] , pagination = True ) , [string] : Path ( [string] , [ ListResponse ] , extended = [ [string] ] , pagination = True ) , } [EOL] [EOL] def get_trending ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_popular ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] [EOL] class NetworksI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , [ Network ] , cache_level = [string] ) } [EOL] [EOL] def get_networks ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[trakt.core.paths.response_structs.Country]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[trakt.core.paths.response_structs.Certification]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 $typing.List[trakt.core.paths.response_structs.Genre]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[trakt.core.paths.response_structs.Language]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.executors.PaginationIterator[trakt.core.paths.response_structs.ListResponse]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $trakt.core.executors.PaginationIterator[trakt.core.paths.response_structs.ListResponse]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[trakt.core.paths.response_structs.Network]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
	0
from typing import Dict , Union , List , Type , Any [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] import re [EOL] from typing import Any , List [EOL] [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . response_structs import EpisodePremiere , MoviePremiere [EOL] from trakt . core . paths . suite_interface import SuiteInterface [EOL] from trakt . core . paths . validators import ( COMMON_FILTERS , SHOWS_FILTERS , AuthRequiredValidator , PerArgValidator , Validator , ) [EOL] [EOL] [EOL] class CalendarsI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] base_paths = { [string] : [ [string] , [ EpisodePremiere ] ] , [string] : [ [string] , [ EpisodePremiere ] ] , [string] : [ [string] , [ EpisodePremiere ] ] , [string] : [ [string] , [ EpisodePremiere ] ] , [string] : [ [string] , [ EpisodePremiere ] , ] , [string] : [ [string] , [ EpisodePremiere ] , ] , [string] : [ [string] , [ MoviePremiere ] ] , [string] : [ [string] , [ MoviePremiere ] ] , [string] : [ [string] , [ MoviePremiere ] ] , [string] : [ [string] , [ MoviePremiere ] ] , } [EOL] [EOL] COMMON_VALIDATORS = [ PerArgValidator ( [string] , lambda t : isinstance ( t , int ) ) , PerArgValidator ( [string] , lambda t : re . match ( [string] , t ) ) , ] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . paths = { k : self . _make_path ( * r ) for k , r in self . base_paths . items ( ) } [EOL] [EOL] def _make_path ( self , resource_path , return_type ) : [EOL] extra_validators = [ AuthRequiredValidator ( ) ] if [string] in resource_path else [ ] [EOL] [EOL] return Path ( [string] + resource_path , return_type , extended = [ [string] ] , filters = COMMON_FILTERS | SHOWS_FILTERS , validators = self . COMMON_VALIDATORS + extra_validators , ) [EOL] [EOL] def get_shows ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_my_shows ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_new_shows ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_my_new_shows ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_season_premieres ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_my_season_premieres ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_movies ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_my_movies ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_dvd_releases ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_my_dvd_releases ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[trakt.core.paths.validators.Validator]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.path.Path$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[trakt.core.paths.validators.AuthRequiredValidator]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[trakt.core.paths.validators.AuthRequiredValidator]]$ 0 0 0 0 0 $typing.List[trakt.core.paths.response_structs.EpisodePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.EpisodePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.EpisodePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.EpisodePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.EpisodePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.EpisodePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.MoviePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.MoviePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.MoviePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.MoviePremiere]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Dict , Union , List , Type , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] from typing import TYPE_CHECKING , Any , Dict , List , Optional , Union [EOL] [EOL] from trakt . core . models import Comment [EOL] from trakt . core . paths . endpoint_mappings . movies import ( COMMENT_SORT_VALUES , LIST_SORT_VALUES , LIST_TYPE_VALUES , PERIOD_VALUES , ) [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . response_structs import ( Alias , AnticipatedShow , CastCrewList , Episode , RatingsSummary , Show , ShowCollectionProgress , ShowStats , ShowTranslation , ShowWatchedProgress , ShowWithStats , TraktList , TrendingShow , UpdatedShow , User , ) [EOL] from trakt . core . paths . suite_interface import SuiteInterface [EOL] from trakt . core . paths . validators import ( COMMON_FILTERS , SHOWS_FILTERS , AuthRequiredValidator , PerArgValidator , Validator , is_date , ) [EOL] [EOL] ID_VALIDATOR = PerArgValidator ( [string] , lambda i : isinstance ( i , ( int , str ) ) ) [EOL] [EOL] PROGRESS_VALIDATORS = [ AuthRequiredValidator ( ) , ID_VALIDATOR , PerArgValidator ( [string] , lambda t : isinstance ( t , bool ) ) , PerArgValidator ( [string] , lambda t : isinstance ( t , bool ) ) , PerArgValidator ( [string] , lambda t : isinstance ( t , bool ) ) , PerArgValidator ( [string] , lambda t : t in { [string] , [string] } ) , ] [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . core . executors import PaginationIterator [EOL] [EOL] [EOL] class ShowsI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] base_paths = { [string] : [ [string] , [ TrendingShow ] ] , [string] : [ [string] , [ Show ] ] , [string] : [ [string] , [ ShowWithStats ] ] , [string] : [ [string] , [ ShowWithStats ] ] , [string] : [ [string] , [ ShowWithStats ] ] , [string] : [ [string] , [ AnticipatedShow ] ] , } [EOL] [EOL] paths = { [string] : Path ( [string] , [ UpdatedShow ] , extended = [ [string] ] , pagination = True , validators = [ PerArgValidator ( [string] , is_date ) ] , ) , [string] : Path ( [string] , Show , extended = [ [string] ] , validators = [ ID_VALIDATOR ] , cache_level = [string] , ) , [string] : Path ( [string] , [ Alias ] , validators = [ ID_VALIDATOR ] , cache_level = [string] ) , [string] : Path ( [string] , [ ShowTranslation ] , validators = [ ID_VALIDATOR , PerArgValidator ( [string] , lambda c : isinstance ( c , str ) and len ( c ) == [number] ) , ] , cache_level = [string] , ) , [string] : Path ( [string] , [ Comment ] , validators = [ ID_VALIDATOR , PerArgValidator ( [string] , lambda s : s in COMMENT_SORT_VALUES ) , ] , pagination = True , ) , [string] : Path ( [string] , [ TraktList ] , validators = [ ID_VALIDATOR , PerArgValidator ( [string] , lambda t : t in LIST_TYPE_VALUES ) , PerArgValidator ( [string] , lambda s : s in LIST_SORT_VALUES ) , ] , pagination = True , ) , [string] : Path ( [string] , ShowCollectionProgress , validators = PROGRESS_VALIDATORS , qargs = [ [string] , [string] , [string] , [string] ] , ) , [string] : Path ( [string] , ShowWatchedProgress , validators = PROGRESS_VALIDATORS , qargs = [ [string] , [string] , [string] , [string] ] , ) , [string] : Path ( [string] , CastCrewList , extended = [ [string] ] , validators = [ ID_VALIDATOR ] , cache_level = [string] , ) , [string] : Path ( [string] , RatingsSummary , validators = [ ID_VALIDATOR ] ) , [string] : Path ( [string] , [ Show ] , extended = [ [string] ] , pagination = True , validators = [ ID_VALIDATOR ] , cache_level = [string] , ) , [string] : Path ( [string] , ShowStats , validators = [ ID_VALIDATOR ] ) , [string] : Path ( [string] , [ User ] , extended = [ [string] ] , validators = [ ID_VALIDATOR ] ) , [string] : Path ( [string] , Union [ Episode , Dict [ str , Any ] ] , extended = [ [string] ] , validators = [ ID_VALIDATOR ] , ) , [string] : Path ( [string] , Union [ Episode , Dict [ str , Any ] ] , extended = [ [string] ] , validators = [ ID_VALIDATOR ] , ) , } [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] for k , r in self . base_paths . items ( ) : [EOL] self . paths [ k ] = self . _make_path ( * r ) [EOL] [EOL] def _make_path ( self , resource_path , return_type ) : [EOL] extra_validators = [ ] [EOL] if [string] in resource_path : [EOL] extra_validators . append ( PerArgValidator ( [string] , lambda p : p in PERIOD_VALUES ) ) [EOL] [EOL] return Path ( self . name + [string] + resource_path , return_type , extended = [ [string] ] , filters = COMMON_FILTERS | SHOWS_FILTERS , pagination = True , validators = extra_validators , ) [EOL] [EOL] def get_trending ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_popular ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_most_played ( self , * , period = [string] , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , period = period ) [EOL] [EOL] def get_most_watched ( self , * , period = [string] , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , period = period ) [EOL] [EOL] def get_most_collected ( self , * , period = [string] , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , period = period ) [EOL] [EOL] def get_most_anticipated ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_recently_updated ( self , * , start_date = None , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , start_date = start_date ) [EOL] [EOL] def get_summary ( self , * , show , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] return self . run ( [string] , ** kwargs , id = id ) [EOL] [EOL] def get_aliases ( self , * , show , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] return self . run ( [string] , ** kwargs , id = id ) [EOL] [EOL] def get_translations ( self , * , show , language = None , ** kwargs ) : [EOL] extra_kwargs = { [string] : self . _generic_get_id ( show ) } [EOL] if language : [EOL] extra_kwargs [ [string] ] = language [EOL] [EOL] return self . run ( [string] , ** kwargs , ** extra_kwargs ) [EOL] [EOL] def get_comments ( self , * , show , sort = [string] , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] return self . run ( [string] , ** kwargs , sort = sort , id = id ) [EOL] [EOL] def get_lists ( self , * , show , type = [string] , sort = [string] , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] return self . run ( [string] , ** kwargs , type = type , sort = sort , id = id ) [EOL] [EOL] def get_collection_progress ( self , * , show , hidden = False , specials = False , count_specials = True , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _generic_get_id ( show ) , hidden = hidden , specials = specials , count_specials = count_specials ) [EOL] [EOL] def get_watched_progress ( self , * , show , hidden = False , specials = False , count_specials = True , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _generic_get_id ( show ) , hidden = hidden , specials = specials , count_specials = count_specials ) [EOL] [EOL] def get_people ( self , * , show , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _generic_get_id ( show ) ) [EOL] [EOL] def get_ratings ( self , * , show , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _generic_get_id ( show ) ) [EOL] [EOL] def get_related ( self , * , show , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _generic_get_id ( show ) ) [EOL] [EOL] def get_stats ( self , * , show , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _generic_get_id ( show ) ) [EOL] [EOL] def get_users_watching ( self , * , show , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _generic_get_id ( show ) ) [EOL] [EOL] def get_next_episode ( self , * , show , ** kwargs ) : [EOL] resp = self . run ( [string] , ** kwargs , id = self . _generic_get_id ( show ) , return_extras = True ) [EOL] [EOL] return None if resp . code == [number] else resp . parsed [EOL] [EOL] def get_last_episode ( self , * , show , ** kwargs ) : [EOL] resp = self . run ( [string] , ** kwargs , id = self . _generic_get_id ( show ) , return_extras = True ) [EOL] [EOL] return None if resp . code == [number] else resp . parsed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[trakt.core.paths.response_structs.User]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 0 0 0 $typing.Optional[trakt.core.paths.response_structs.Episode]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[trakt.core.paths.response_structs.Episode]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Show,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Dict , Union , List [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from typing import List , Union [EOL] [EOL] from trakt . core . models import Movie [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . response_structs import Show [EOL] from trakt . core . paths . suite_interface import SuiteInterface [EOL] from trakt . core . paths . validators import AuthRequiredValidator , PerArgValidator [EOL] [EOL] IGNORE_COLLECTED_VALIDATOR = PerArgValidator ( [string] , lambda i : isinstance ( i , bool ) ) [EOL] ID_VALIDATOR = PerArgValidator ( [string] , lambda c : isinstance ( c , ( int , str ) ) ) [EOL] [EOL] [EOL] class RecommendationsI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , [ Movie ] , validators = [ AuthRequiredValidator ( ) , IGNORE_COLLECTED_VALIDATOR ] , extended = [ [string] ] , qargs = [ [string] ] , ) , [string] : Path ( [string] , { } , methods = [string] , validators = [ AuthRequiredValidator ( ) , ID_VALIDATOR ] , ) , [string] : Path ( [string] , [ Show ] , validators = [ AuthRequiredValidator ( ) , IGNORE_COLLECTED_VALIDATOR ] , extended = [ [string] ] , qargs = [ [string] ] , ) , [string] : Path ( [string] , { } , methods = [string] , validators = [ AuthRequiredValidator ( ) , ID_VALIDATOR ] , ) , } [EOL] [EOL] def get_movie_recommendations ( self , * , ignore_collected = False , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , ignore_collected = ignore_collected ) [EOL] [EOL] def hide_movie ( self , * , movie , ** kwargs ) : [EOL] id = self . _generic_get_id ( movie ) [EOL] self . run ( [string] , ** kwargs , id = id ) [EOL] [EOL] def get_show_recommendations ( self , * , ignore_collected = False , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , ignore_collected = ignore_collected ) [EOL] [EOL] def hide_show ( self , * , show , ** kwargs ) : [EOL] id = self . _generic_get_id ( show ) [EOL] self . run ( [string] , ** kwargs , id = id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,trakt.core.paths.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.paths.validators.PerArgValidator$ 0 0 0 0 0 0 0 0 $typing.List[trakt.core.models.Movie]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $None$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 $typing.List[trakt.core.paths.response_structs.Show]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $None$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 $typing.Union[trakt.core.models.Movie,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 $typing.Union[builtins.int,builtins.str]$ 0 0
from typing import Set , Dict , Union , List , Optional [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] from typing import TYPE_CHECKING , List , Optional , Union [EOL] [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . response_structs import SearchResult [EOL] from trakt . core . paths . suite_interface import SuiteInterface [EOL] from trakt . core . paths . validators import ALL_FILTERS , PerArgValidator [EOL] [EOL] MEDIA_TYPES = [ [string] , [string] , [string] , [string] , [string] ] [EOL] ID_TYPES = [ [string] , [string] , [string] , [string] ] [EOL] POSSIBLE_FIELDS = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . core . executors import PaginationIterator [EOL] [EOL] [EOL] class SearchI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] paths = { [string] : Path ( [string] , [ SearchResult ] , extended = [ [string] ] , filters = ALL_FILTERS , pagination = True , validators = [ PerArgValidator ( [string] , lambda t : all ( x in MEDIA_TYPES for x in t . split ( [string] ) ) ) , PerArgValidator ( [string] , lambda q : isinstance ( q , str ) and q ) , PerArgValidator ( [string] , lambda f : all ( x in POSSIBLE_FIELDS for x in f . split ( [string] ) ) ) , ] , qargs = [ [string] ] , cache_level = [string] , ) , [string] : Path ( [string] , [ SearchResult ] , extended = [ [string] ] , filters = ALL_FILTERS , pagination = True , validators = [ PerArgValidator ( [string] , lambda t : isinstance ( t , ( int , str ) ) ) , PerArgValidator ( [string] , lambda it : it in ID_TYPES ) , PerArgValidator ( [string] , lambda f : all ( x in MEDIA_TYPES for x in f . split ( [string] ) ) ) , ] , qargs = [ [string] ] , cache_level = [string] , ) , } [EOL] [EOL] def text_query ( self , type , query , fields = None , ** kwargs ) : [EOL] type = [ type ] if isinstance ( type , str ) else type [EOL] type = [string] . join ( type ) [EOL] req = { [string] : type , [string] : query } [EOL] [EOL] if fields : [EOL] fields = [ fields ] if isinstance ( fields , str ) else fields [EOL] req [ [string] ] = [string] . join ( fields ) [EOL] [EOL] return self . run ( [string] , ** kwargs , ** req ) [EOL] [EOL] def id_lookup ( self , id_type , id , type = None , ** kwargs ) : [EOL] req = { [string] : id_type , [string] : id } [EOL] [EOL] if type : [EOL] type = [ type ] if isinstance ( type , str ) else type [EOL] req [ [string] ] = [string] . join ( type ) [EOL] [EOL] return self . run ( [string] , ** kwargs , ** req ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $trakt.core.executors.PaginationIterator[trakt.core.paths.response_structs.SearchResult]$ 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 $builtins.str$ 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Union[typing.List[builtins.str],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $trakt.core.executors.PaginationIterator[trakt.core.paths.response_structs.SearchResult]$ 0 0 0 $builtins.str$ 0 $typing.Union[builtins.str,builtins.int]$ 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[builtins.str,builtins.int]$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0
from typing import Set , Dict , Union , List , Type , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import trakt [EOL] from __future__ import annotations [EOL] [EOL] from typing import TYPE_CHECKING , Any , List , Optional , Union [EOL] [EOL] from trakt . core . models import Comment [EOL] from trakt . core . paths . path import Path [EOL] from trakt . core . paths . response_structs import ( Alias , AnticipatedMovie , BoxOffice , CastCrewList , Movie , MovieRelease , MovieStats , MovieTranslation , MovieWithStats , RatingsSummary , TraktList , TrendingMovie , UpdatedMovie , User , ) [EOL] from trakt . core . paths . suite_interface import SuiteInterface [EOL] from trakt . core . paths . validators import ( COMMON_FILTERS , PerArgValidator , Validator , is_date , ) [EOL] [EOL] if TYPE_CHECKING : [comment] [EOL] from trakt . core . executors import PaginationIterator [EOL] [EOL] PERIOD_VALUES = { [string] , [string] , [string] , [string] } [EOL] COMMENT_SORT_VALUES = { [string] , [string] , [string] , [string] } [EOL] LIST_TYPE_VALUES = { [string] , [string] , [string] , [string] } [EOL] LIST_SORT_VALUES = { [string] , [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] [EOL] class MoviesI ( SuiteInterface ) : [EOL] name = [string] [EOL] [EOL] base_paths = { [string] : [ [string] , [ TrendingMovie ] ] , [string] : [ [string] , [ Movie ] ] , [string] : [ [string] , [ MovieWithStats ] ] , [string] : [ [string] , [ MovieWithStats ] ] , [string] : [ [string] , [ MovieWithStats ] ] , [string] : [ [string] , [ AnticipatedMovie ] ] , } [EOL] [EOL] paths = { [string] : Path ( [string] , [ BoxOffice ] , extended = [ [string] ] , cache_level = [string] ) , [string] : Path ( [string] , [ UpdatedMovie ] , extended = [ [string] ] , pagination = True , validators = [ PerArgValidator ( [string] , is_date ) ] , ) , [string] : Path ( [string] , Movie , extended = [ [string] ] , cache_level = [string] ) , [string] : Path ( [string] , [ Alias ] , cache_level = [string] ) , [string] : Path ( [string] , [ MovieRelease ] , validators = [ PerArgValidator ( [string] , lambda c : isinstance ( c , str ) and len ( c ) == [number] ) ] , cache_level = [string] , ) , [string] : Path ( [string] , [ MovieTranslation ] , validators = [ PerArgValidator ( [string] , lambda c : isinstance ( c , str ) and len ( c ) == [number] ) ] , cache_level = [string] , ) , [string] : Path ( [string] , [ Comment ] , validators = [ PerArgValidator ( [string] , lambda s : s in COMMENT_SORT_VALUES ) ] , pagination = True , ) , [string] : Path ( [string] , [ TraktList ] , validators = [ PerArgValidator ( [string] , lambda t : t in LIST_TYPE_VALUES ) , PerArgValidator ( [string] , lambda s : s in LIST_SORT_VALUES ) , ] , pagination = True , ) , [string] : Path ( [string] , CastCrewList , extended = [ [string] ] , cache_level = [string] ) , [string] : Path ( [string] , RatingsSummary ) , [string] : Path ( [string] , [ Movie ] , extended = [ [string] ] , pagination = True , cache_level = [string] , ) , [string] : Path ( [string] , MovieStats ) , [string] : Path ( [string] , [ User ] , extended = [ [string] ] ) , } [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] for k , r in self . base_paths . items ( ) : [EOL] self . paths [ k ] = self . _make_path ( * r ) [EOL] [EOL] def _make_path ( self , resource_path , return_type ) : [EOL] extra_validators = [ ] [EOL] if [string] in resource_path : [EOL] extra_validators . append ( PerArgValidator ( [string] , lambda p : p in PERIOD_VALUES ) ) [EOL] [EOL] return Path ( self . name + [string] + resource_path , return_type , extended = [ [string] ] , filters = COMMON_FILTERS , pagination = True , validators = extra_validators , ) [EOL] [EOL] def get_trending ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_popular ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_most_played ( self , * , period = [string] , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , period = period ) [EOL] [EOL] def get_most_watched ( self , * , period = [string] , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , period = period ) [EOL] [EOL] def get_most_collected ( self , * , period = [string] , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , period = period ) [EOL] [EOL] def get_most_anticipated ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_box_office ( self , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs ) [EOL] [EOL] def get_recently_updated ( self , * , start_date = None , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , start_date = start_date ) [EOL] [EOL] def get_summary ( self , * , movie , ** kwargs ) : [EOL] movie_id = self . _get_movie_id ( movie ) [EOL] return self . run ( [string] , ** kwargs , id = movie_id ) [EOL] [EOL] def get_aliases ( self , * , movie , ** kwargs ) : [EOL] movie_id = self . _get_movie_id ( movie ) [EOL] return self . run ( [string] , ** kwargs , id = movie_id ) [EOL] [EOL] def get_releases ( self , * , movie , country = None , ** kwargs ) : [EOL] extra_kwargs = { [string] : self . _get_movie_id ( movie ) } [EOL] if country : [EOL] extra_kwargs [ [string] ] = country [EOL] [EOL] return self . run ( [string] , ** kwargs , ** extra_kwargs ) [EOL] [EOL] def get_translations ( self , * , movie , language = None , ** kwargs ) : [EOL] extra_kwargs = { [string] : self . _get_movie_id ( movie ) } [EOL] if language : [EOL] extra_kwargs [ [string] ] = language [EOL] [EOL] return self . run ( [string] , ** kwargs , ** extra_kwargs ) [EOL] [EOL] def get_comments ( self , * , movie , sort = [string] , ** kwargs ) : [EOL] movie_id = self . _get_movie_id ( movie ) [EOL] return self . run ( [string] , ** kwargs , sort = sort , id = movie_id ) [EOL] [EOL] def get_lists ( self , * , movie , type = [string] , sort = [string] , ** kwargs ) : [EOL] movie_id = self . _get_movie_id ( movie ) [EOL] return self . run ( [string] , ** kwargs , type = type , sort = sort , id = movie_id ) [EOL] [EOL] def get_people ( self , * , movie , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _get_movie_id ( movie ) ) [EOL] [EOL] def get_ratings ( self , * , movie , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _get_movie_id ( movie ) ) [EOL] [EOL] def get_related ( self , * , movie , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _get_movie_id ( movie ) ) [EOL] [EOL] def get_stats ( self , * , movie , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _get_movie_id ( movie ) ) [EOL] [EOL] def get_users_watching ( self , * , movie , ** kwargs ) : [EOL] return self . run ( [string] , ** kwargs , id = self . _get_movie_id ( movie ) ) [EOL] [EOL] def _get_movie_id ( self , movie ) : [EOL] return str ( self . _generic_get_id ( movie ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[trakt.core.paths.response_structs.User]$ 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Movie,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Movie,builtins.str,builtins.int]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[trakt.core.paths.response_structs.Movie,builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[trakt.core.paths.response_structs.Movie,builtins.str,builtins.int]$ 0 0 0
import builtins [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass class Sharing : [EOL] twitter = False [EOL] tumblr = False [EOL] medium = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0
from typing import List , Optional [EOL] import builtins [EOL] import typing [EOL] from dataclasses import dataclass , field [EOL] from datetime import date , datetime [EOL] from typing import List , Optional [EOL] [EOL] from trakt . core . models import Movie [EOL] from trakt . core . paths . response_structs . common import Sharing [EOL] [EOL] [EOL] @ dataclass class TrendingMovie : [EOL] watchers = ... [EOL] movie = ... [EOL] [EOL] [EOL] @ dataclass class MoviePremiere : [EOL] released = ... [EOL] movie = ... [EOL] [EOL] [EOL] @ dataclass class MovieCheckin : [EOL] id = ... [EOL] watched_at = ... [EOL] sharing = ... [EOL] movie = ... [EOL] [EOL] [EOL] @ dataclass class MovieWithStats : [EOL] watcher_count = ... [EOL] play_count = ... [EOL] collected_count = ... [EOL] movie = ... [EOL] [EOL] [EOL] @ dataclass class MovieStats : [EOL] watchers = ... [EOL] plays = ... [EOL] collectors = ... [EOL] comments = ... [EOL] lists = ... [EOL] votes = ... [EOL] [EOL] [EOL] @ dataclass class AnticipatedMovie : [EOL] list_count = ... [EOL] movie = ... [EOL] [EOL] [EOL] @ dataclass class BoxOffice : [EOL] revenue = ... [EOL] movie = ... [EOL] [EOL] [EOL] @ dataclass class UpdatedMovie : [EOL] updated_at = ... [EOL] movie = ... [EOL] [EOL] [EOL] @ dataclass class MovieRelease : [EOL] country = ... [EOL] certification = ... [EOL] release_date = ... [EOL] release_type = ... [EOL] note = None [EOL] [EOL] [EOL] @ dataclass class MovieTranslation : [EOL] title = ... [EOL] overview = ... [EOL] tagline = ... [EOL] language = ... [EOL] [EOL] [EOL] @ dataclass class MovieCastCredit : [EOL] character = ... [EOL] movie = ... [EOL] [EOL] [EOL] @ dataclass class MovieCrewCredit : [EOL] job = ... [EOL] movie = ... [EOL] [EOL] [EOL] @ dataclass class MovieCrewCredits : [EOL] production = field ( default_factory = list ) [EOL] art = field ( default_factory = list ) [EOL] crew = field ( default_factory = list ) [EOL] costume_make_up = field ( default_factory = list ) [EOL] directing = field ( default_factory = list ) [EOL] writing = field ( default_factory = list ) [EOL] sound = field ( default_factory = list ) [EOL] camera = field ( default_factory = list ) [EOL] [EOL] [EOL] @ dataclass class MovieCredits : [EOL] cast = ... [EOL] crew = ... [EOL] [EOL] [EOL] @ dataclass class MovieScrobble : [EOL] id = ... [EOL] action = ... [EOL] progress = ... [EOL] sharing = ... [EOL] movie = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $trakt.core.models.Movie$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 $trakt.core.models.Movie$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $trakt.core.paths.response_structs.common.Sharing$ 0 0 0 $trakt.core.models.Movie$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $trakt.core.models.Movie$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $trakt.core.models.Movie$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $trakt.core.models.Movie$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.date.time$ 0 0 0 $trakt.core.models.Movie$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $datetime.date$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $trakt.core.models.Movie$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $trakt.core.models.Movie$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[MovieCrewCredit]$ 0 0 0 0 0 0 0 0 $typing.List[MovieCrewCredit]$ 0 0 0 0 0 0 0 0 $typing.List[MovieCrewCredit]$ 0 0 0 0 0 0 0 0 $typing.List[MovieCrewCredit]$ 0 0 0 0 0 0 0 0 $typing.List[MovieCrewCredit]$ 0 0 0 0 0 0 0 0 $typing.List[MovieCrewCredit]$ 0 0 0 0 0 0 0 0 $typing.List[MovieCrewCredit]$ 0 0 0 0 0 0 0 0 $typing.List[MovieCrewCredit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[MovieCastCredit]$ 0 0 0 $MovieCrewCredits$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $trakt.core.paths.response_structs.common.Sharing$ 0 0 0 $trakt.core.models.Movie$ 0 0 0