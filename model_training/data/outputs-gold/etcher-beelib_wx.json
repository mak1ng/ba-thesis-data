[comment] [EOL] [comment] [EOL] import sqlite3 [EOL] import builtins [EOL] import pathlib [EOL] import csv [EOL] [docstring] [EOL] [EOL] import csv [EOL] import sqlite3 [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] DB_FILE_PATH = Path ( [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [EOL] def _generate_db ( source_csv ) : [EOL] if not DB_FILE_PATH : [EOL] raise FileNotFoundError ( DB_FILE_PATH ) [EOL] db = sqlite3 . connect ( str ( DB_FILE_PATH ) ) [EOL] try : [EOL] db . execute ( [string] ) [EOL] db . commit ( ) [EOL] except sqlite3 . OperationalError as err : [EOL] if [string] in err . args [ [number] ] : [EOL] pass [EOL] else : [EOL] raise [EOL] db . execute ( [string] ) [EOL] db . commit ( ) [EOL] cursor = db . cursor ( ) [EOL] csv_file = Path ( source_csv ) . resolve ( ) . absolute ( ) [EOL] print ( [string] , csv_file ) [EOL] with csv_file . open ( encoding = [string] ) as stream : [EOL] reader = csv . DictReader ( stream ) [EOL] for airport in reader : [EOL] airport_icao = airport [ [string] ] [EOL] airport_name = airport [ [string] ] . replace ( [string] , [string] ) [EOL] query = f" [string] { airport_icao } [string] { airport_name } [string] " [EOL] cursor . execute ( query ) [EOL] print ( [string] ) [EOL] db . commit ( ) [EOL] db . close ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] _generate_db ( * sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from mockito import unstub , verifyStubbedInvocationsAreUsed [EOL] [EOL] from test . refresh_test_data import iterate_test_data [EOL] [EOL] HERE = Path ( [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [EOL] def pytest_configure ( config ) : [EOL] [docstring] [EOL] print ( [string] , config . option ) [EOL] setattr ( sys , [string] , True ) [EOL] [EOL] [EOL] [comment] [EOL] def pytest_unconfigure ( config ) : [EOL] [docstring] [EOL] assert config [EOL] delattr ( sys , [string] ) [EOL] [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] [docstring] [EOL] parser . addoption ( [string] , action = [string] , help = [string] ) [EOL] [EOL] [EOL] def pytest_runtest_setup ( item ) : [EOL] [docstring] [EOL] long_marker = item . get_marker ( [string] ) [EOL] if long_marker is not None and not item . config . getoption ( [string] ) : [EOL] pytest . skip ( f'{ item . location } [string] ' ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def _global_tear_down ( tmpdir , monkeypatch ) : [EOL] [docstring] [EOL] try : [EOL] monkeypatch . delenv ( [string] ) [EOL] except KeyError : [EOL] pass [EOL] current_dir = os . getcwd ( ) [EOL] folder = Path ( tmpdir ) . absolute ( ) [EOL] os . chdir ( folder ) [EOL] yield [EOL] verifyStubbedInvocationsAreUsed ( ) [EOL] unstub ( ) [EOL] os . chdir ( current_dir ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def _clean_os_env ( ) : [EOL] env = os . environ . copy ( ) [EOL] yield [EOL] for key , value in env . items ( ) : [EOL] os . environ [ key ] = value [EOL] for key in os . environ . keys ( ) : [EOL] if key not in env . keys ( ) : [EOL] del os . environ [ key ] [EOL] [EOL] [EOL] @ pytest . fixture ( params = list ( iterate_test_data ( ) ) , ) def metar_string ( request ) : [EOL] [docstring] [EOL] yield request . param [EOL] [EOL] [EOL] @ pytest . fixture ( ) def with_db ( ) : [EOL] setattr ( sys , [string] , True ) [EOL] yield [EOL] delattr ( sys , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def all_metar_strings ( ) : [EOL] [docstring] [EOL] yield list ( iterate_test_data ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def examples_data_file ( ) : [EOL] [docstring] [EOL] yield Path ( HERE , [string] ) . absolute ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def caucasus_test_file ( ) : [EOL] return Path ( HERE , [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def nevada_test_file ( ) : [EOL] return Path ( HERE , [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def persian_gulf_test_file ( ) : [EOL] return Path ( HERE , [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def wx_test_file_1 ( ) : [EOL] return Path ( HERE , [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def wx_test_file_heavy_dust ( ) : [EOL] return Path ( HERE , [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def wx_test_file_snow ( ) : [EOL] return Path ( HERE , [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def wx_test_file_snowstorm ( ) : [EOL] return Path ( HERE , [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def wx_test_file_thunderstorm ( ) : [EOL] return Path ( HERE , [string] ) . resolve ( ) . absolute ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List , Iterator [EOL] import logging [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] [docstring] [EOL] import base64 [EOL] import logging [EOL] import pprint [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] _PATH_TO_METAR_DIR = Path ( [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [comment] [EOL] TEST_DATA_FILE = Path ( [string] ) . resolve ( ) . absolute ( ) [EOL] [EOL] [comment] [EOL] SEPARATOR = separator = [string] . encode ( [string] ) [EOL] [EOL] [EOL] def iterate_metar_files ( ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] , _PATH_TO_METAR_DIR ) [EOL] for file in _PATH_TO_METAR_DIR . iterdir ( ) : [EOL] yield file [EOL] [EOL] [EOL] def iterate_test_data ( ) : [EOL] [docstring] [EOL] raw_data = TEST_DATA_FILE . read_bytes ( ) . split ( SEPARATOR ) [EOL] for encoded_metar in raw_data : [EOL] yield base64 . b64decode ( encoded_metar ) . decode ( [string] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] elib_wx_logger = logging . getLogger ( [string] ) [EOL] elib_wx_logger . propagate = True [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . INFO ) [EOL] logger . addHandler ( logging . StreamHandler ( ) ) [EOL] [EOL] test_data = [ ] [EOL] corrupt_files = [ ] [EOL] [EOL] for file in iterate_metar_files ( ) : [EOL] try : [EOL] metar_data = file . read_text ( encoding = [string] ) [EOL] except UnicodeDecodeError : [EOL] corrupt_files . append ( file . name ) [EOL] else : [EOL] metar_str = metar_data . split ( [string] ) [ [number] ] [EOL] encoded_metar_str = base64 . b64encode ( metar_str . encode ( [string] ) ) [EOL] test_data . append ( encoded_metar_str ) [EOL] [EOL] logger . warning ( [string] , pprint . pformat ( corrupt_files , indent = [number] ) ) [EOL] [EOL] logger . info ( [string] , TEST_DATA_FILE ) [EOL] TEST_DATA_FILE . write_bytes ( SEPARATOR . join ( test_data ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[pathlib.Path]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL]	0 0 0 0
[comment] [EOL] from typing import Any , Tuple , Optional [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import typing [EOL] [EOL] [EOL] class _TestValue : [EOL] [EOL] def __init__ ( self , * , attr_name , expected_result , get_value = False , units = None ) : [EOL] self . attr_name = attr_name [EOL] self . get_value = get_value [EOL] self . units = units [EOL] self . expected_result = expected_result [EOL] [EOL] def _get_value ( self , _obj ) : [EOL] if self . get_value : [EOL] return getattr ( _obj , self . attr_name ) . value ( self . units ) [EOL] [EOL] return getattr ( _obj , self . attr_name ) [EOL] [EOL] def verify ( self , _obj ) : [EOL] return self . expected_result , self . _get_value ( _obj ) [EOL] [EOL] [EOL] class _TestCall : [EOL] [EOL] def __init__ ( self , attr_name , expected , * args , ** kwargs ) : [EOL] self . attr_name = attr_name [EOL] self . args = args [EOL] self . kwargs = kwargs [EOL] self . expected_result = expected [EOL] [EOL] def _get_value ( self , _obj ) : [EOL] return getattr ( _obj , self . attr_name ) ( * self . args , ** self . kwargs ) [EOL] [EOL] def verify ( self , _obj ) : [EOL] return self . expected_result , self . _get_value ( _obj ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.bool]$ 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [EOL] import elib_wx [EOL] import pytest [EOL] from mockito import expect , when [EOL] [EOL] from elib_wx import avwx , exc , utils , weather [EOL] [EOL] [EOL] def test_from_metar_string ( ) : [EOL] test_string = [string] [EOL] test_icao = [string] [EOL] expect ( weather . Weather ) . _set_station_name ( ) [EOL] expect ( weather . Weather ) . fill_from_metar_data ( ) [EOL] when ( utils ) . extract_station_from_metar_str ( test_string ) . thenReturn ( test_icao ) [EOL] when ( avwx . metar ) . parse ( test_icao , test_string ) . thenReturn ( ( [string] , [string] ) ) [EOL] wx = weather . Weather ( test_string ) [EOL] assert wx . source == test_string [EOL] assert wx . station_icao == test_icao [EOL] assert wx . source_type == [string] [EOL] [EOL] [EOL] def test_from_icao ( ) : [EOL] test_icao = [string] [EOL] metar_string = [string] [EOL] expect ( weather . Weather ) . _set_station_name ( ) [EOL] expect ( weather . Weather ) . fill_from_metar_data ( ) [EOL] when ( avwx . metar ) . fetch ( test_icao ) . thenReturn ( metar_string ) [EOL] when ( avwx . metar ) . parse ( test_icao , metar_string ) . thenReturn ( ( [string] , [string] ) ) [EOL] wx = weather . Weather ( test_icao ) [EOL] assert wx . source == test_icao [EOL] assert wx . station_icao == test_icao [EOL] assert wx . source_type == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None , [number] , - [number] , [number] , False , True , None , [number] ] ) @ pytest . mark . weather def test_wrong_source ( source ) : [EOL] with pytest . raises ( exc . InvalidWeatherSourceError ) : [EOL] [comment] [EOL] weather . Weather ( source ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import elib_wx [EOL] import inflect [EOL] import pytest [EOL] [EOL] import elib_wx [EOL] [EOL] _CONVERT = inflect . engine ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_from_miz_caucasus ( caucasus_test_file ) : [EOL] wx = elib_wx . Weather ( str ( caucasus_test_file ) ) [EOL] assert str ( caucasus_test_file ) == wx . source [EOL] assert [string] == wx . source_type [EOL] assert [number] == wx . visibility . value ( ) [EOL] assert [number] == wx . temperature . value ( ) [EOL] assert wx . dew_point . value ( ) < wx . temperature . value ( ) [EOL] assert [string] == wx . remarks [EOL] assert [string] == wx . station_icao [EOL] assert [string] == wx . station_name [EOL] assert [ ] == wx . cloud_layers [EOL] assert [string] == wx . date_time . repr [EOL] assert [number] == wx . wind_direction . value ( ) [EOL] assert [number] == wx . wind_speed . value ( ) [EOL] assert [number] == wx . wind_gust . value ( ) [EOL] assert [ ] == wx . wind_direction_range [EOL] assert wx . wind_direction_is_variable is False [EOL] assert [ ] == wx . other [EOL] assert f' [string] { wx . dew_point . value ( ) : [string] } [string] ' == wx . raw_metar_str [EOL] assert [string] f' [string] { wx . dew_point . value ( ) : [string] } [string] { wx . dew_point . value ( unit = [string] ) : [string] } [string] ' f' [string] ' [string] == wx . as_str ( ) [EOL] dew_point_c = _CONVERT . number_to_words ( wx . dew_point . value ( ) , group = [number] ) . replace ( [string] , [string] ) [EOL] dew_point_f = _CONVERT . number_to_words ( wx . dew_point . value ( unit = [string] ) , group = [number] ) . replace ( [string] , [string] ) [EOL] assert [string] [string] f' [string] { dew_point_c } [string] { dew_point_f } [string] ' [string] [string] [string] [string] == wx . as_speech ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_from_miz_persian_gulf ( persian_gulf_test_file ) : [EOL] wx = elib_wx . Weather ( str ( persian_gulf_test_file ) ) [EOL] assert wx . source == str ( persian_gulf_test_file ) [EOL] assert [string] == wx . source_type [EOL] assert [string] == wx . date_time . repr [EOL] assert f' [string] { wx . dew_point . value ( ) : [string] } [string] ' == wx . raw_metar_str [EOL] assert [string] f' [string] { wx . dew_point . value ( ) : [string] } [string] { wx . dew_point . value ( unit = [string] ) : [string] } [string] ' f' [string] ' [string] == wx . as_str ( ) [EOL] dew_point_c = _CONVERT . number_to_words ( wx . dew_point . value ( ) , group = [number] ) . replace ( [string] , [string] ) [EOL] dew_point_f = _CONVERT . number_to_words ( wx . dew_point . value ( unit = [string] ) , group = [number] ) . replace ( [string] , [string] ) [EOL] assert [string] [string] f' [string] { dew_point_c } [string] { dew_point_f } [string] ' [string] [string] [string] [string] == wx . as_speech ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_from_miz_nevada ( nevada_test_file ) : [EOL] wx = elib_wx . Weather ( str ( nevada_test_file ) ) [EOL] assert wx . source == str ( nevada_test_file ) [EOL] assert [string] == wx . source_type [EOL] assert [string] == wx . date_time . repr [EOL] assert [string] f' [string] { wx . dew_point . value ( ) : [string] } [string] { wx . dew_point . value ( unit = [string] ) : [string] } [string] ' f' [string] ' [string] == wx . as_str ( ) [EOL] dew_point_c = _CONVERT . number_to_words ( wx . dew_point . value ( ) , group = [number] ) . replace ( [string] , [string] ) [EOL] dew_point_f = _CONVERT . number_to_words ( wx . dew_point . value ( unit = [string] ) , group = [number] ) . replace ( [string] , [string] ) [EOL] assert [string] [string] f' [string] { dew_point_c } [string] { dew_point_f } [string] ' [string] [string] [string] [string] == wx . as_speech ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_from_miz_wx1 ( wx_test_file_1 ) : [EOL] wx = elib_wx . Weather ( str ( wx_test_file_1 ) ) [EOL] assert wx . source == str ( wx_test_file_1 ) [EOL] assert wx . source_type == [string] [EOL] assert [number] == wx . visibility . value ( ) [EOL] assert [number] == wx . temperature . value ( ) [EOL] assert wx . dew_point . value ( ) < wx . temperature . value ( ) [EOL] assert [string] == wx . remarks [EOL] assert [string] == wx . station_icao [EOL] assert [string] == wx . station_name [EOL] assert [ elib_wx . avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) ] == wx . cloud_layers [EOL] assert [string] == wx . date_time . repr [EOL] assert [number] == wx . wind_direction . value ( ) [EOL] assert [number] == wx . wind_speed . value ( ) [EOL] assert [number] == wx . wind_gust . value ( ) [EOL] assert [ ] == wx . wind_direction_range [EOL] assert wx . wind_direction_is_variable is False [EOL] assert [ [string] , [string] ] == wx . other [EOL] assert f' [string] { wx . dew_point . value ( ) : [string] } [string] ' == wx . raw_metar_str [EOL] assert [string] [string] [string] [string] f' [string] { wx . dew_point . value ( ) } [string] { wx . dew_point . value ( unit = [string] ) } [string] ' [string] [string] [string] == wx . as_str ( ) [EOL] dew_point_c = _CONVERT . number_to_words ( wx . dew_point . value ( ) , group = [number] ) . replace ( [string] , [string] ) [EOL] dew_point_f = _CONVERT . number_to_words ( wx . dew_point . value ( unit = [string] ) , group = [number] ) . replace ( [string] , [string] ) [EOL] assert [string] [string] [string] [string] f' [string] { dew_point_c } [string] { dew_point_f } [string] ' [string] [string] [string] [string] [string] == wx . as_speech ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_from_miz_thunderstorm ( wx_test_file_thunderstorm ) : [EOL] wx = elib_wx . Weather ( str ( wx_test_file_thunderstorm ) ) [EOL] assert str ( wx_test_file_thunderstorm ) == wx . source [EOL] assert [string] == wx . source_type [EOL] assert [number] == wx . visibility . value ( ) [EOL] assert [number] == wx . temperature . value ( ) [EOL] assert wx . dew_point . value ( ) < wx . temperature . value ( ) [EOL] assert [string] == wx . remarks [EOL] assert [string] == wx . station_icao [EOL] assert [string] == wx . station_name [EOL] assert [ elib_wx . avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) ] == wx . cloud_layers [EOL] assert [string] == wx . date_time . repr [EOL] assert [number] == wx . wind_direction . value ( ) [EOL] assert [number] == wx . wind_speed . value ( ) [EOL] assert [number] == wx . wind_gust . value ( ) [EOL] assert [ ] == wx . wind_direction_range [EOL] assert wx . wind_direction_is_variable is False [EOL] assert [ [string] , [string] ] == wx . other [EOL] assert f' [string] { wx . dew_point . value ( ) : [string] } [string] ' == wx . raw_metar_str [EOL] assert [string] [string] [string] [string] f' [string] { wx . dew_point . value ( ) } [string] { wx . dew_point . value ( unit = [string] ) } [string] ' [string] [string] [string] == wx . as_str ( ) [EOL] dew_point_c = _CONVERT . number_to_words ( wx . dew_point . value ( ) , group = [number] ) . replace ( [string] , [string] ) [EOL] dew_point_f = _CONVERT . number_to_words ( wx . dew_point . value ( unit = [string] ) , group = [number] ) . replace ( [string] , [string] ) [EOL] assert [string] [string] [string] [string] f' [string] { dew_point_c } [string] { dew_point_f } [string] ' [string] [string] [string] [string] [string] == wx . as_speech ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_from_miz_snow ( wx_test_file_snow ) : [EOL] wx = elib_wx . Weather ( str ( wx_test_file_snow ) ) [EOL] assert str ( wx_test_file_snow ) == wx . source [EOL] assert [string] == wx . source_type [EOL] assert [number] == wx . visibility . value ( ) [EOL] assert - [number] == wx . temperature . value ( ) [EOL] assert wx . dew_point . value ( ) < wx . temperature . value ( ) [EOL] assert [string] == wx . remarks [EOL] assert [string] == wx . station_icao [EOL] assert [string] == wx . station_name [EOL] assert [ elib_wx . avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) ] == wx . cloud_layers [EOL] assert [string] == wx . date_time . repr [EOL] assert [number] == wx . wind_direction . value ( ) [EOL] assert [number] == wx . wind_speed . value ( ) [EOL] assert [number] == wx . wind_gust . value ( ) [EOL] assert [ ] == wx . wind_direction_range [EOL] assert wx . wind_direction_is_variable is False [EOL] assert [ [string] , [string] , [string] ] == wx . other [EOL] assert f' [string] ' f' [string] { wx . dew_point . value ( ) : [string] } [string] ' == wx . raw_metar_str [EOL] assert [string] [string] [string] [string] f' [string] { wx . dew_point . value ( ) } [string] { wx . dew_point . value ( unit = [string] ) } [string] ' [string] [string] [string] == wx . as_str ( ) [EOL] dew_point_c = _CONVERT . number_to_words ( wx . dew_point . value ( ) , group = [number] ) . replace ( [string] , [string] ) [EOL] dew_point_f = _CONVERT . number_to_words ( wx . dew_point . value ( unit = [string] ) , group = [number] ) . replace ( [string] , [string] ) [EOL] assert [string] [string] [string] [string] f' [string] { dew_point_c } [string] { dew_point_f } [string] ' [string] [string] [string] [string] == wx . as_speech ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_from_miz_snowstorm ( wx_test_file_snowstorm ) : [EOL] wx = elib_wx . Weather ( str ( wx_test_file_snowstorm ) ) [EOL] assert str ( wx_test_file_snowstorm ) == wx . source [EOL] assert [string] == wx . source_type [EOL] assert [number] == wx . visibility . value ( ) [EOL] assert - [number] == wx . temperature . value ( ) [EOL] assert wx . dew_point . value ( ) < wx . temperature . value ( ) [EOL] assert [string] == wx . remarks [EOL] assert [string] == wx . station_icao [EOL] assert [string] == wx . station_name [EOL] assert [ elib_wx . avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) ] == wx . cloud_layers [EOL] assert [string] == wx . date_time . repr [EOL] assert [number] == wx . wind_direction . value ( ) [EOL] assert [number] == wx . wind_speed . value ( ) [EOL] assert [number] == wx . wind_gust . value ( ) [EOL] assert [ ] == wx . wind_direction_range [EOL] assert wx . wind_direction_is_variable is False [EOL] assert [ [string] , [string] , [string] ] == wx . other [EOL] assert f' [string] ' f' [string] { wx . dew_point . value ( ) : [string] } [string] ' == wx . raw_metar_str [EOL] assert [string] [string] [string] [string] f' [string] { wx . dew_point . value ( ) } [string] { wx . dew_point . value ( unit = [string] ) } [string] ' [string] [string] [string] == wx . as_str ( ) [EOL] dew_point_c = _CONVERT . number_to_words ( wx . dew_point . value ( ) , group = [number] ) . replace ( [string] , [string] ) [EOL] dew_point_f = _CONVERT . number_to_words ( wx . dew_point . value ( unit = [string] ) , group = [number] ) . replace ( [string] , [string] ) [EOL] assert [string] [string] [string] [string] f' [string] { dew_point_c } [string] { dew_point_f } [string] ' [string] [string] [string] [string] == wx . as_speech ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_from_miz_heavy_dust ( wx_test_file_heavy_dust ) : [EOL] wx = elib_wx . Weather ( str ( wx_test_file_heavy_dust ) ) [EOL] assert str ( wx_test_file_heavy_dust ) == wx . source [EOL] assert [string] == wx . source_type [EOL] assert [number] == wx . visibility . value ( ) [EOL] assert [number] == wx . temperature . value ( ) [EOL] assert wx . dew_point . value ( ) < wx . temperature . value ( ) [EOL] assert [string] == wx . remarks [EOL] assert [string] == wx . station_icao [EOL] assert [string] == wx . station_name [EOL] assert [ elib_wx . avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) ] == wx . cloud_layers [EOL] assert [string] == wx . date_time . repr [EOL] assert [number] == wx . wind_direction . value ( ) [EOL] assert [number] == wx . wind_speed . value ( ) [EOL] assert [number] == wx . wind_gust . value ( ) [EOL] assert [ ] == wx . wind_direction_range [EOL] assert wx . wind_direction_is_variable is False [EOL] assert [ [string] , [string] ] == wx . other [EOL] assert f' [string] ' f' [string] { wx . dew_point . value ( ) : [string] } [string] ' == wx . raw_metar_str [EOL] assert [string] [string] [string] [string] f' [string] { wx . dew_point . value ( ) } [string] { wx . dew_point . value ( unit = [string] ) } [string] ' [string] [string] [string] [string] [string] == wx . as_str ( ) [EOL] dew_point_c = _CONVERT . number_to_words ( wx . dew_point . value ( ) , group = [number] ) . replace ( [string] , [string] ) [EOL] dew_point_f = _CONVERT . number_to_words ( wx . dew_point . value ( unit = [string] ) , group = [number] ) . replace ( [string] , [string] ) [EOL] assert [string] [string] [string] [string] f' [string] { dew_point_c } [string] { dew_point_f } [string] ' [string] [string] [string] [string] [string] [string] == wx . as_speech ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_wx [EOL] import pytest [EOL] from mockito import expect [EOL] [EOL] import elib_wx [EOL] [EOL] [EOL] @ pytest . mark . weather def test_weather_from_icao ( with_db ) : [EOL] icao = [string] [EOL] expect ( elib_wx . avwx . metar ) . fetch ( icao ) . thenReturn ( [string] ) [EOL] expect ( elib_wx . avwx . metar ) . parse ( icao , [string] ) . thenReturn ( ( [string] , [string] ) ) [EOL] expect ( elib_wx . Weather ) . fill_from_metar_data ( ) [EOL] wx = elib_wx . Weather ( icao ) [EOL] assert wx . source_type == [string] [EOL] assert wx . metar_data == [string] [EOL] assert wx . metar_units == [string] [EOL] assert wx . station_name == [string] [EOL] [EOL] [EOL] @ pytest . mark . weather def test_weather_from_icao_unknown_icao ( ) : [EOL] icao = [string] [EOL] expect ( elib_wx . avwx . metar ) . fetch ( icao ) . thenReturn ( [string] ) [EOL] expect ( elib_wx . avwx . metar ) . parse ( icao , [string] ) . thenReturn ( ( [string] , [string] ) ) [EOL] expect ( elib_wx . Weather ) . fill_from_metar_data ( ) [EOL] wx = elib_wx . Weather ( icao ) [EOL] assert [string] == wx . station_name [EOL] [EOL] [EOL] @ pytest . mark . weather def test_weather_from_icao_wrong_icao ( ) : [EOL] icao = [string] [EOL] with pytest . raises ( elib_wx . BadStationError ) : [EOL] elib_wx . Weather ( icao ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Tuple , List [EOL] import typing [EOL] import elib_wx [EOL] import pytest [EOL] [EOL] import elib_wx [EOL] [EOL] _TEST_DATA = [ ( [string] , [string] [string] ) , ( [string] , [string] [string] [string] ) , ( [string] , [string] [string] ) , ( [string] , [string] ) , ( [string] , [string] [string] [string] ) , ( [string] , [string] ) , ( [string] , [string] [string] [string] ) , ( [string] , [string] ) , ( [string] , [string] [string] [string] ) , ( [string] , [string] [string] [string] ) , ( [string] , [string] [string] [string] ) , ( [string] , [string] [string] [string] ) , ( [string] , [string] [string] ) , ( [string] , [string] [string] ) , ] [EOL] [EOL] [EOL] @ pytest . mark . weather @ pytest . mark . parametrize ( [string] , _TEST_DATA ) def test_remarks ( metar_str , expected_remarks_speech ) : [EOL] wx = elib_wx . Weather ( metar_str ) [EOL] assert expected_remarks_speech == wx . _remarks_as_str ( spoken = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_wx [EOL] import pytest [EOL] [EOL] import elib_wx [EOL] [EOL] [EOL] @ pytest . mark . long def test_all_metars ( metar_string ) : [EOL] if metar_string [ [number] ] not in ( [string] , [string] , [string] ) : [EOL] return [EOL] assert isinstance ( metar_string , str ) [EOL] try : [EOL] wx = elib_wx . Weather ( metar_string ) [EOL] assert isinstance ( wx , elib_wx . Weather ) [EOL] wx . as_speech ( ) [EOL] except elib_wx . BadStationError : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_wx [EOL] import pytest [EOL] [EOL] import elib_wx [EOL] [EOL] [EOL] @ pytest . mark . weather def test_unknown_icao ( ) : [EOL] metar_str = [string] [EOL] wx = elib_wx . Weather ( metar_str ) [EOL] assert [string] == wx . station_name [EOL] [EOL] [EOL] @ pytest . mark . weather def test_wrong_icao ( ) : [EOL] metar_str = [string] [EOL] with pytest . raises ( elib_wx . BadStationError ) : [EOL] elib_wx . Weather ( metar_str ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_known_icao ( with_db ) : [EOL] metar_str = [string] [EOL] wx = elib_wx . Weather ( metar_str ) [EOL] assert wx . station_name == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] from hypothesis import given , strategies as st [EOL] [EOL] import elib_wx [EOL] [EOL] [EOL] @ pytest . mark . weather @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] , [number] ) , ( [string] , - [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ] ) @ given ( value = st . floats ( allow_nan = False , allow_infinity = False ) ) def test_normalize ( attr , min_ , max_ , value ) : [EOL] func = getattr ( elib_wx . weather . DCSWeather , f' [string] { attr }' ) [EOL] assert min_ <= func ( value ) <= max_ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Tuple , Set [EOL] import builtins [EOL] import typing [EOL] import test [EOL] import typing [EOL] [EOL] import pytest [EOL] [EOL] from test . utils import _TestValue [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = False ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = False ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , ) ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = True ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = True ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] ) , _TestValue ( attr_name = [string] , expected_result = [number] ) , ) , ) , ] , ids = [ [string] , [string] , [string] , [string] ] ) def test_data ( request ) : [EOL] yield request . param [ [number] ] , request . param [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Tuple , Literal , List [EOL] import typing_extensions [EOL] import typing [EOL] import elib_wx [EOL] import pytest [EOL] from hypothesis import given , settings , strategies as st [EOL] [EOL] import elib_wx [EOL] import elib_wx . static [EOL] from elib_wx . values . value import Temperature [EOL] [EOL] [EOL] @ pytest . mark . weather def test_generate_dcs_weather ( test_data ) : [EOL] metar , expected = test_data [EOL] wx = elib_wx . Weather ( metar ) [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] for test_value in expected : [EOL] expected , actual = test_value . verify ( dcs_wx ) [EOL] assert expected == actual [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] * [number] , [number] ) , ( [number] * [number] , [number] ) , ] ) @ pytest . mark . weather def test_dcs_wind_direction ( wind_dir , expected ) : [EOL] wx = elib_wx . Weather ( f' [string] ' ) [EOL] wx . wind_direction . set_value ( wind_dir ) [EOL] assert expected == wx . generate_dcs_weather ( ) . wind_ground_dir [EOL] [EOL] [EOL] [comment] [EOL] _CLOUDS_TEST_DATA = [ ( k , v ) for k , v in elib_wx . static . CLOUD_METAR_TO_DCS . items ( ) ] [EOL] [comment] [EOL] _CLOUDS_TEST_IDS = [ repr ( k ) + [string] + repr ( v ) for k , v in elib_wx . static . CLOUD_METAR_TO_DCS . items ( ) ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _CLOUDS_TEST_DATA , ids = _CLOUDS_TEST_IDS ) @ pytest . mark . weather def test_generate_dcs_weather_cloud_layers ( coverage , range_ ) : [EOL] _min_coverage = [number] [EOL] metar = f' [string] { coverage } [string] ' [EOL] wx = elib_wx . Weather ( metar ) [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] assert max ( _min_coverage , range_ [ [number] ] ) <= dcs_wx . cloud_density <= max ( _min_coverage , range_ [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _CLOUDS_TEST_DATA , ids = _CLOUDS_TEST_IDS ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] ) ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) @ given ( temperature = st . floats ( allow_infinity = False , allow_nan = False ) ) @ settings ( max_examples = [number] ) @ pytest . mark . weather def test_generate_dcs_weather_rain ( coverage , range_ , rain_marker , modifier , temperature ) : [EOL] _min_coverage = [number] [EOL] metar = f' [string] { modifier }{ rain_marker } [string] { coverage } [string] ' [EOL] wx = elib_wx . Weather ( metar ) [EOL] wx . temperature = Temperature ( temperature ) [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] assert max ( _min_coverage , range_ [ [number] ] ) <= dcs_wx . cloud_density <= max ( _min_coverage , range_ [ [number] ] ) [EOL] assert [number] == dcs_wx . precipitation_code [EOL] assert [number] <= dcs_wx . temperature [EOL] [EOL] [EOL] def test_generate_dcs_weather_rain_debug ( ) : [EOL] _min_coverage = [number] [EOL] metar = f' [string] ' [EOL] wx = elib_wx . Weather ( metar ) [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] assert [number] == dcs_wx . precipitation_code [EOL] assert [number] <= dcs_wx . temperature [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _CLOUDS_TEST_DATA , ids = _CLOUDS_TEST_IDS ) @ pytest . mark . parametrize ( [string] , ( [string] , ) ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) @ given ( temperature = st . floats ( allow_infinity = False , allow_nan = False ) ) @ settings ( max_examples = [number] ) @ pytest . mark . weather def test_generate_dcs_weather_snow ( coverage , range_ , snow_marker , modifier , temperature ) : [EOL] _min_coverage = [number] [EOL] metar = f' [string] { modifier }{ snow_marker } [string] { coverage } [string] { temperature } [string] ' [EOL] wx = elib_wx . Weather ( metar ) [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] assert max ( _min_coverage , range_ [ [number] ] ) <= dcs_wx . cloud_density <= max ( _min_coverage , range_ [ [number] ] ) [EOL] assert dcs_wx . temperature < [number] [EOL] assert [number] == dcs_wx . precipitation_code [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _CLOUDS_TEST_DATA , ids = _CLOUDS_TEST_IDS ) @ pytest . mark . parametrize ( [string] , ( [string] , ) ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) @ given ( temperature = st . floats ( allow_infinity = False , allow_nan = False ) ) @ settings ( max_examples = [number] ) @ pytest . mark . weather def test_generate_dcs_weather_thunderstorm ( coverage , range_ , snow_marker , modifier , temperature ) : [EOL] _min_coverage = [number] [EOL] metar = f' [string] { modifier }{ snow_marker } [string] { coverage } [string] { temperature } [string] ' [EOL] wx = elib_wx . Weather ( metar ) [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] assert max ( _min_coverage , range_ [ [number] ] ) <= dcs_wx . cloud_density <= max ( _min_coverage , range_ [ [number] ] ) [EOL] assert [number] == dcs_wx . precipitation_code [EOL] assert [number] <= dcs_wx . temperature [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _CLOUDS_TEST_DATA , ids = _CLOUDS_TEST_IDS ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] ) ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) @ given ( temperature = st . floats ( allow_infinity = False , allow_nan = False ) ) @ settings ( max_examples = [number] ) @ pytest . mark . weather def test_generate_dcs_weather_snow_storm ( coverage , range_ , snow_marker , modifier , temperature ) : [EOL] _min_coverage = [number] [EOL] metar = f' [string] { modifier }{ snow_marker } [string] { coverage } [string] { temperature } [string] ' [EOL] wx = elib_wx . Weather ( metar ) [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] assert max ( _min_coverage , range_ [ [number] ] ) <= dcs_wx . cloud_density <= max ( _min_coverage , range_ [ [number] ] ) [EOL] assert dcs_wx . temperature < [number] [EOL] assert [number] == dcs_wx . precipitation_code [EOL] assert dcs_wx . temperature < [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] ) ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) @ pytest . mark . weather def test_generate_dcs_weather_dust ( dust_marker , modifier , visibility ) : [EOL] metar = f' [string] { visibility : [string] } [string] { modifier }{ dust_marker } [string] ' [EOL] wx = elib_wx . Weather ( metar ) [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] dust_visibility = ( min ( [number] , visibility ) , max ( [number] , visibility ) ) [EOL] if visibility <= [number] : [EOL] assert dcs_wx . dust_enabled is True [EOL] assert max ( [number] , dust_visibility [ [number] ] ) <= dcs_wx . dust_density <= min ( [number] , dust_visibility [ [number] ] ) [EOL] else : [EOL] assert dcs_wx . dust_enabled is False [EOL] assert [number] == dcs_wx . dust_density [EOL] [EOL] [EOL] @ pytest . mark . weather def test_missing_cloud_layer_altitude ( ) : [EOL] wx = elib_wx . Weather ( [string] ) [EOL] wx . cloud_layers [ [number] ] . altitude = None [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] assert [number] <= dcs_wx . cloud_base <= [number] [EOL] assert [number] == dcs_wx . cloud_base % [number] [EOL] [EOL] [EOL] @ pytest . mark . weather def test_wrong_cloud_layer_altitude ( ) : [EOL] wx = elib_wx . Weather ( [string] ) [EOL] wx . metar_units . altitude = [string] [EOL] with pytest . raises ( ValueError ) : [EOL] wx . generate_dcs_weather ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_turbulence_but_wind_speed_zero ( ) : [EOL] wx = elib_wx . Weather ( [string] ) [EOL] wx . wind_speed . _raw_value = [number] [EOL] assert wx . wind_gust . value ( ) > [number] [EOL] dcs_wx = wx . generate_dcs_weather ( ) [EOL] assert dcs_wx . turbulence > [number] [EOL] assert [number] == dcs_wx . wind_ground_speed [EOL] assert [number] == wx . wind_speed . value ( ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_from_miz ( caucasus_test_file ) : [EOL] wx = elib_wx . Weather ( str ( caucasus_test_file ) ) [EOL] wx . generate_dcs_weather ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] import pathlib [EOL] import elib_wx [EOL] from pathlib import Path [EOL] [EOL] import elib_miz [EOL] import pytest [EOL] [EOL] import elib_wx [EOL] [EOL] [EOL] @ pytest . mark . weather def test_apply_to_miz ( test_data , wx_test_file_1 ) : [EOL] test_miz_file = [string] [EOL] metar , expected = test_data [EOL] wx = elib_wx . Weather ( metar ) [EOL] wx . apply_to_miz ( str ( wx_test_file_1 ) , test_miz_file ) [EOL] with elib_miz . Miz ( test_miz_file ) as miz : [EOL] for test_value in expected : [EOL] expected , actual = test_value . verify ( miz . mission . weather ) [EOL] assert expected == actual [EOL] [EOL] [EOL] @ pytest . mark . weather def test_apply_to_miz_file_exists ( test_data , wx_test_file_1 ) : [EOL] metar , _ = test_data [EOL] wx = elib_wx . Weather ( metar ) [EOL] test_miz_file = Path ( [string] ) . absolute ( ) [EOL] test_miz_file . touch ( ) [EOL] with pytest . raises ( elib_wx . FileAlreadyExistsError ) : [EOL] wx . apply_to_miz ( str ( wx_test_file_1 ) , str ( test_miz_file ) ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_apply_to_miz_file_exists_overwrite ( wx_test_file_1 ) : [EOL] wx = elib_wx . Weather ( [string] ) [EOL] test_miz_file = Path ( [string] ) . absolute ( ) [EOL] test_miz_file . touch ( ) [EOL] wx . apply_to_miz ( str ( wx_test_file_1 ) , str ( test_miz_file ) , overwrite = True ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_apply_to_miz_no_source_file ( ) : [EOL] wx = elib_wx . Weather ( [string] ) [EOL] test_miz_file = Path ( [string] ) . absolute ( ) [EOL] with pytest . raises ( elib_wx . SourceMizFileNotFoundError ) : [EOL] wx . apply_to_miz ( test_miz_file , str ( test_miz_file ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Union , Tuple , List [EOL] import elib_wx [EOL] import typing [EOL] import test [EOL] import pytest [EOL] from hypothesis import given , strategies as st [EOL] [EOL] import elib_wx [EOL] import elib_wx . static [EOL] from elib_wx import avwx [EOL] from test . utils import _TestCall , _TestValue [EOL] [EOL] _TEST_DATA = [ ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [ ] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [ avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) ] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [ avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) ] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [ avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) , avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = [string] ) , ] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] [string] , spoken = True ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [ ] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [ avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) ] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [ avwx . structs . Cloud ( repr = [string] , type = [string] , altitude = [number] , modifier = None ) ] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _TEST_DATA ) @ pytest . mark . weather def test_clouds_in_weather_from_metar_str ( metar_str , expected ) : [EOL] wx = elib_wx . Weather ( metar_str ) [EOL] assert isinstance ( wx , elib_wx . Weather ) [EOL] for test_value in expected : [EOL] expected , actual = test_value . verify ( wx ) [EOL] assert expected == actual [EOL] [EOL] [EOL] @ given ( density = st . sampled_from ( [ [string] , [string] , [string] , [string] ] ) , modifier = st . sampled_from ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , altitude = st . integers ( min_value = [number] , max_value = [number] ) , ) @ pytest . mark . weather def test ( density , modifier , altitude ) : [EOL] metar_str = f' [string] { density }{ altitude : [string] }{ modifier } [string] ' [EOL] wx = elib_wx . Weather ( metar_str ) [EOL] cloud_layer = wx . cloud_layers [ [number] ] [EOL] assert cloud_layer . altitude == altitude [EOL] if modifier == [string] : [EOL] assert cloud_layer . modifier is None [EOL] else : [EOL] assert cloud_layer . modifier == modifier [EOL] assert cloud_layer . repr == f'{ density }{ altitude : [string] }{ modifier }' [EOL] cloud_str = wx . _clouds_as_str ( spoken = False ) [EOL] if modifier != [string] : [EOL] assert elib_wx . static . CLOUD_TRANSLATIONS [ modifier ] in cloud_str [EOL] [EOL] [EOL] @ pytest . mark . weather def test_no_altitude ( ) : [EOL] metar_str = [string] [EOL] wx = elib_wx . Weather ( metar_str ) [EOL] wx . cloud_layers [ [number] ] . altitude = None [EOL] assert [string] == wx . _clouds_as_str ( spoken = False ) [EOL] [EOL] [EOL] @ pytest . mark . weather def test_unknown_modifier ( ) : [EOL] metar_str = [string] [EOL] wx = elib_wx . Weather ( metar_str ) [EOL] assert [string] == wx . _clouds_as_str ( spoken = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[typing.Tuple[test.utils._TestValue,test.utils._TestCall,test.utils._TestCall],typing.Tuple[test.utils._TestValue,test.utils._TestCall,test.utils._TestCall,test.utils._TestCall]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[typing.Tuple[test.utils._TestValue,test.utils._TestCall,test.utils._TestCall],typing.Tuple[test.utils._TestValue,test.utils._TestCall,test.utils._TestCall,test.utils._TestCall]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_wx [EOL] import pytest [EOL] [EOL] import elib_wx [EOL] from test . utils import _TestCall , _TestValue [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , ) , ) , ( [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ] ) @ pytest . mark . weather def test_wind_in_weather_from_metar_str ( metar_str , expected ) : [EOL] wx = elib_wx . Weather ( metar_str ) [EOL] assert isinstance ( wx , elib_wx . Weather ) [EOL] for test_value in expected : [EOL] expected , actual = test_value . verify ( wx ) [EOL] assert expected == actual [EOL] [EOL] [EOL] @ pytest . mark . weather def test_wind_in_weather_from_metar_str_no_wind_given ( ) : [EOL] wx = elib_wx . Weather ( [string] ) [EOL] assert isinstance ( wx , elib_wx . Weather ) [EOL] assert wx . wind_direction . value ( ) [EOL] assert [number] <= wx . wind_direction . value ( ) <= [number] [EOL] assert wx . wind_speed . value ( ) [EOL] assert [number] <= wx . wind_speed . value ( ) <= [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_wx [EOL] import pytest [EOL] [EOL] import elib_wx [EOL] from test . utils import _TestCall , _TestValue [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] [string] , ( _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True ) , _TestValue ( attr_name = [string] , expected_result = [number] , get_value = True , units = [string] ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] , ( _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] , ( _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] [string] , ( _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] [string] , ( _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ( [string] [string] , ( _TestCall ( attr_name = [string] , expected = [string] , spoken = False ) , _TestCall ( attr_name = [string] , expected = [string] , spoken = True ) , ) , ) , ] ) @ pytest . mark . weather def test_visibility_in_weather_from_metar_str ( metar_str , expected ) : [EOL] wx = elib_wx . Weather ( metar_str ) [EOL] assert isinstance ( wx , elib_wx . Weather ) [EOL] for test_value in expected : [EOL] expected , actual = test_value . verify ( wx ) [EOL] assert expected == actual [EOL] [EOL] [EOL] @ pytest . mark . weather def test_visibility_in_weather_from_metar_str_no_visibility_given ( ) : [EOL] wx = elib_wx . Weather ( [string] ) [EOL] assert isinstance ( wx , elib_wx . Weather ) [EOL] assert wx . visibility . value ( ) [EOL] assert [number] <= wx . visibility . value ( ) <= [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) , ( [string] , [number] ) , ] ) @ pytest . mark . weather def test_visibility_in_weather_from_metar_str_special_cases ( visibility , expected ) : [EOL] wx = elib_wx . Weather ( f' [string] { visibility } [string] ' ) [EOL] assert isinstance ( wx , elib_wx . Weather ) [EOL] assert expected == wx . visibility . value ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import elib_wx [EOL] [docstring] [EOL] [EOL] import json [EOL] import os [EOL] from copy import deepcopy [EOL] from datetime import datetime [EOL] from glob import glob [EOL] [EOL] [comment] [EOL] import pytest [EOL] from dataclasses import asdict [EOL] [EOL] [comment] [EOL] from elib_wx . avwx import Taf , core , structs , taf [EOL] [EOL] [EOL] @ pytest . mark . long def test_fetch ( ) : [EOL] [docstring] [EOL] for station in ( [string] , [string] , [string] , [string] ) : [EOL] report = taf . fetch ( station ) [EOL] assert isinstance ( report , str ) [EOL] assert report . startswith ( station ) or report . startswith ( [string] + station ) [EOL] [EOL] [EOL] def test_parse ( ) : [EOL] [docstring] [EOL] report = ( [string] [string] ) [EOL] data , units = taf . parse ( report [ : [number] ] , report ) [EOL] assert isinstance ( data , structs . TafData ) [EOL] assert isinstance ( units , structs . Units ) [EOL] assert data . raw == report [EOL] [EOL] [EOL] def test_prob_line ( ) : [EOL] [docstring] [EOL] report = ( [string] [string] [string] [string] [string] [string] ) [EOL] _taf = Taf ( [string] ) [EOL] _taf . update ( report ) [EOL] lines = _taf . taf_data . forecast [EOL] assert len ( lines ) == [number] [EOL] assert lines [ [number] ] . probability is None [EOL] assert lines [ [number] ] . probability == core . make_number ( [string] ) [EOL] assert lines [ [number] ] . raw . startswith ( [string] ) [EOL] [EOL] [EOL] def test_wind_shear ( ) : [EOL] [docstring] [EOL] report = ( [string] [string] [string] [string] [string] [string] [string] ) [EOL] _taf = Taf ( [string] ) [EOL] _taf . update ( report ) [EOL] lines = _taf . taf_data . forecast [EOL] assert len ( lines ) == [number] [EOL] assert lines [ [number] ] . wind_shear == [string] [EOL] assert _taf . taf_translations . forecast [ [number] ] . clouds is None [EOL] [EOL] [EOL] def test_prob_tempo ( ) : [EOL] [docstring] [EOL] report = ( [string] [string] [string] ) [EOL] _taf = Taf ( [string] ) [EOL] _taf . update ( report ) [EOL] lines = _taf . taf_data . forecast [EOL] for line in lines : [EOL] assert isinstance ( line . start_time , structs . Timestamp ) [EOL] assert isinstance ( line . end_time , structs . Timestamp ) [EOL] for i in range ( [number] , [number] ) : [EOL] assert lines [ i ] . type == [string] [EOL] assert lines [ i ] . probability . value == [number] [EOL] [EOL] [EOL] [comment] [EOL] def test_taf_ete ( ) : [EOL] [docstring] [EOL] [EOL] def _nodate ( s ) : [EOL] return s [ s . find ( [string] ) + [number] : ] [EOL] [EOL] for path in glob ( os . path . dirname ( os . path . realpath ( __file__ ) ) + [string] ) : [EOL] ref = json . load ( open ( path ) ) [EOL] station = Taf ( path . split ( [string] ) [ - [number] ] [ : [number] ] ) [EOL] assert station . last_updated is None [EOL] assert station . update ( ref [ [string] ] [ [string] ] ) is True [EOL] assert isinstance ( station . last_updated , datetime ) [EOL] [comment] [EOL] nodt = deepcopy ( station . taf_data ) [EOL] for key in ( [string] , [string] , [string] ) : [EOL] setattr ( nodt , key , None ) [EOL] for i in range ( len ( nodt . forecast ) ) : [EOL] for key in ( [string] , [string] ) : [EOL] setattr ( nodt . forecast [ i ] , key , None ) [EOL] assert asdict ( nodt ) == ref [ [string] ] [EOL] assert asdict ( station . taf_translations ) == ref [ [string] ] [EOL] assert station . summary == ref [ [string] ] [EOL] assert _nodate ( station . speech ) == _nodate ( ref [ [string] ] ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , Dict , List [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] import elib_wx [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] import unittest [EOL] [comment] [EOL] from copy import deepcopy [EOL] from datetime import datetime [EOL] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [comment] [EOL] from elib_wx . avwx import core , exceptions , static , structs [EOL] [EOL] [EOL] class BaseTest ( unittest . TestCase ) : [EOL] [EOL] def assert_number ( self , num , repr_ , value = None , spoken = None ) : [EOL] [docstring] [EOL] if not repr_ : [EOL] self . assertIsNone ( num ) [EOL] else : [EOL] self . assertIsInstance ( num , structs . Number ) [EOL] self . assertEqual ( num . repr , repr_ ) [EOL] self . assertEqual ( num . value , value ) [EOL] if spoken : [EOL] self . assertEqual ( num . spoken , spoken ) [EOL] [EOL] [EOL] class TestGlobal ( BaseTest ) : [EOL] [EOL] def test_valid_station ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] for station in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] core . valid_station ( station ) [EOL] [comment] [EOL] for station in ( [string] , [string] ) : [EOL] with self . assertRaises ( exceptions . BadStationError ) : [EOL] core . valid_station ( station ) [EOL] [EOL] def test_uses_na_format ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] for station in ( [string] , [string] , [string] , [string] ) : [EOL] self . assertTrue ( core . uses_na_format ( station ) ) [EOL] [comment] [EOL] for station in ( [string] , [string] , [string] ) : [EOL] self . assertFalse ( core . uses_na_format ( station ) ) [EOL] [comment] [EOL] for station in ( [string] , [string] ) : [EOL] with self . assertRaises ( exceptions . BadStationError ) : [EOL] core . uses_na_format ( station ) [EOL] [EOL] def test_is_unknown ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] self . assertTrue ( core . is_unknown ( [string] * i ) ) [EOL] [comment] [EOL] for value in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] self . assertFalse ( core . is_unknown ( value ) ) [EOL] [comment] [EOL] with self . assertRaises ( TypeError ) : [EOL] [comment] [EOL] core . is_unknown ( None ) [EOL] [EOL] def test_unpack_fraction ( self ) : [EOL] [docstring] [EOL] for fraction , unpacked in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] self . assertEqual ( core . unpack_fraction ( fraction ) , unpacked ) [EOL] [EOL] def test_remove_leading_zeros ( self ) : [EOL] [docstring] [EOL] for num , stripped in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] self . assertEqual ( core . remove_leading_zeros ( num ) , stripped ) [EOL] [EOL] def test_spoken_number ( self ) : [EOL] [docstring] [EOL] for num , spoken in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] self . assertEqual ( core . spoken_number ( num ) , spoken ) [EOL] [EOL] def test_make_number ( self ) : [EOL] [docstring] [EOL] self . assertIsNone ( core . make_number ( [string] ) ) [EOL] for num , value , spoken in ( ( [string] , [number] , [string] ) , ( [string] , [number] , [string] ) , ( [string] , [number] , [string] ) , ( [string] , - [number] , [string] ) , ( [string] , None , [string] ) , ( [string] , None , [string] ) , ) : [EOL] number = core . make_number ( num ) [EOL] self . assertEqual ( number . repr , num ) [EOL] self . assertEqual ( number . value , value ) [EOL] self . assertEqual ( number . spoken , spoken ) [EOL] for num , value , spoken , nmr , dnm , norm in ( ( [string] , [number] , [string] , [number] , [number] , [string] ) , ( [string] , [number] , [string] , [number] , [number] , [string] ) , ( [string] , [number] , [string] , [number] , [number] , [string] ) , ) : [EOL] number = core . make_number ( num ) [EOL] self . assertEqual ( number . value , value ) [EOL] self . assertEqual ( number . spoken , spoken ) [EOL] self . assertEqual ( number . numerator , nmr ) [EOL] self . assertEqual ( number . denominator , dnm ) [EOL] self . assertEqual ( number . normalized , norm ) [EOL] self . assertEqual ( core . make_number ( [string] , [string] ) . repr , [string] ) [EOL] number = core . make_number ( [string] , speak = [string] ) [EOL] self . assertEqual ( number . value , [number] ) [EOL] self . assertEqual ( number . spoken , [string] ) [EOL] [EOL] def test_find_first_in_list ( self ) : [EOL] [docstring] [EOL] for string , targets , index in ( ( [string] , ( [string] , [string] , [string] ) , [number] ) , ( [string] , ( [string] , [string] , [string] ) , [number] ) , ( [string] , static . METAR_RMK , [number] ) ) : [EOL] self . assertEqual ( core . find_first_in_list ( string , targets ) , index ) [EOL] [EOL] def test_extra_space_exists ( self ) : [EOL] [docstring] [EOL] for strings in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ) : [EOL] self . assertTrue ( core . extra_space_exists ( * strings ) ) [EOL] for strings in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] self . assertFalse ( core . extra_space_exists ( * strings ) ) [EOL] [EOL] def test_sanitize_report_list ( self ) : [EOL] [docstring] [EOL] for line , fixed in ( ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] line , fixed = line . split ( ) , fixed . split ( ) [EOL] self . assertEqual ( core . sanitize_report_list ( line ) , ( fixed , [ ] , [string] ) ) [EOL] [comment] [EOL] line = [string] . split ( ) [EOL] fixed = [string] . split ( ) [EOL] self . assertEqual ( core . sanitize_report_list ( line ) , ( fixed , [ [string] ] , [string] ) ) [EOL] [EOL] def test_is_possible_temp ( self ) : [EOL] [docstring] [EOL] for is_temp in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] self . assertTrue ( core . is_possible_temp ( is_temp ) ) [EOL] for not_temp in ( [string] , [string] , [string] , [string] ) : [EOL] self . assertFalse ( core . is_possible_temp ( not_temp ) ) [EOL] [EOL] def test_get_temp_and_dew ( self ) : [EOL] [docstring] [EOL] for wx , temp , dew in ( ( [ [string] , [string] ] , ( None , ) , ( None , ) ) , ( [ [string] , [string] , [string] ] , ( [string] , [number] ) , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] ] , ( [string] , [number] ) , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] ] , ( [string] , - [number] ) , ( [string] , - [number] ) ) , ( [ [string] , [string] , [string] ] , ( None , ) , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] ] , ( [string] , [number] ) , ( None , ) ) , ( [ [string] , [string] , [string] ] , ( None , ) , ( None , ) ) , ( [ [string] , [string] , [string] ] , ( None , ) , ( [string] , [number] ) ) , ) : [EOL] retwx , ret_temp , ret_dew = core . get_temp_and_dew ( wx ) [EOL] self . assertEqual ( retwx , [ [string] , [string] ] ) [EOL] self . assert_number ( ret_temp , * temp ) [EOL] self . assert_number ( ret_dew , * dew ) [EOL] self . assertEqual ( core . get_temp_and_dew ( [ [string] ] ) , ( [ [string] ] , None , None ) ) [EOL] [EOL] def test_get_station_and_time ( self ) : [EOL] [docstring] [EOL] for wx , ret , station , time , in ( ( [ [string] , [string] , [string] ] , [ [string] ] , [string] , [string] ) , ( [ [string] , [string] , [string] ] , [ [string] ] , [string] , [string] ) , ( [ [string] , [string] , [string] ] , [ [string] ] , [string] , [string] ) , ( [ [string] , [string] , [string] ] , [ [string] , [string] ] , [string] , [string] ) , ( [ [string] , [string] ] , [ [string] ] , [string] , [string] ) ) : [EOL] self . assertEqual ( core . get_station_and_time ( wx ) , ( ret , station , time ) ) [EOL] [EOL] def test_get_wind ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] for wx , unit , * wind , varv in ( ( [ [string] ] , [string] , ( None , ) , ( None , ) , ( None , ) , [ ] ) , ( [ [string] , [string] , [string] ] , [string] , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , [ ] ) , ( [ [string] , [string] ] , [string] , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , [ ] ) , ( [ [string] , [string] , [string] , [string] ] , [string] , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , [ ( [string] , [number] ) , ( [string] , [number] ) ] ) , ( [ [string] , [string] ] , [string] , ( [string] , ) , ( [string] , [number] ) , ( None , ) , [ ] ) , ( [ [string] , [string] ] , [string] , ( [string] , ) , ( [string] , [number] ) , ( [string] , [number] ) , [ ] ) ) : [EOL] units = structs . Units ( ** static . NA_UNITS ) [EOL] wx , * winds , var = core . get_wind ( wx , units ) [EOL] self . assertEqual ( wx , [ [string] ] ) [EOL] for i in range ( len ( wind ) ) : [EOL] self . assert_number ( winds [ i ] , * wind [ i ] ) [EOL] if varv : [EOL] self . assertIsInstance ( varv , list ) [EOL] for i in range ( [number] ) : [EOL] self . assert_number ( var [ i ] , * varv [ i ] ) [EOL] self . assertEqual ( units . wind_speed , unit ) [EOL] [EOL] def test_get_visibility ( self ) : [EOL] [docstring] [EOL] for wx , unit , visibility in ( ( [ [string] ] , [string] , ( None , ) ) , ( [ [string] , [string] ] , [string] , ( [string] , [number] ) ) , ( [ [string] , [string] ] , [string] , ( [string] , [number] ) ) , ( [ [string] , [string] ] , [string] , ( [string] , ) ) , ( [ [string] , [string] ] , [string] , ( [string] , ) ) , ( [ [string] , [string] ] , [string] , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] ] , [string] , ( [string] , [number] ) ) , ( [ [string] , [string] ] , [string] , ( [string] , [number] ) ) , ( [ [string] , [string] ] , [string] , ( [string] , [number] ) ) , ( [ [string] , [string] ] , [string] , ( [string] , [number] ) ) , ( [ [string] , [string] ] , [string] , ( [string] , [number] ) ) , ( [ [string] , [string] ] , [string] , ( [string] , [number] ) ) , ) : [EOL] units = structs . Units ( ** static . NA_UNITS ) [EOL] wx , vis = core . get_visibility ( wx , units ) [EOL] self . assertEqual ( wx , [ [string] ] ) [EOL] self . assert_number ( vis , * visibility ) [EOL] self . assertEqual ( units . visibility , unit ) [EOL] [EOL] def test_get_digit_list ( self ) : [EOL] [docstring] [EOL] items = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] items , ret = core . _get_digit_list ( items , [number] ) [EOL] self . assertEqual ( items , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( ret , [ [string] , [string] ] ) [EOL] items , ret = core . _get_digit_list ( items , [number] ) [EOL] self . assertEqual ( items , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( ret , [ [string] ] ) [EOL] [EOL] def test_sanitize_cloud ( self ) : [EOL] [docstring] [EOL] for bad , good in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] self . assertEqual ( core . sanitize_cloud ( bad ) , good ) [EOL] [EOL] def test_make_cloud ( self ) : [EOL] [docstring] [EOL] for cloud , out in ( ( [string] , [ [string] , [number] , None ] ) , ( [string] , [ [string] , [number] , None ] ) , ( [string] , [ [string] , [number] , [string] ] ) , ( [string] , [ [string] , [number] , [string] ] ) , ( [string] , [ [string] , [number] , None ] ) , ( [string] , [ [string] , None , None ] ) , ( [string] , [ [string] , [number] , None ] ) , ( [string] , [ [string] , None , None ] ) , ( [string] , [ [string] , None , [string] ] ) , ) : [EOL] ret_cloud = core . make_cloud ( cloud ) [EOL] self . assertIsInstance ( ret_cloud , structs . Cloud ) [EOL] self . assertEqual ( ret_cloud . repr , cloud ) [EOL] for i , key in enumerate ( ( [string] , [string] , [string] ) ) : [EOL] self . assertEqual ( getattr ( ret_cloud , key ) , out [ i ] ) [EOL] [EOL] def test_get_flight_rules ( self ) : [EOL] [docstring] [EOL] for vis , ceiling , rule in ( ( None , None , [string] ) , ( [string] , None , [string] ) , ( [string] , [ [string] , [number] ] , [string] ) , ( [string] , [ [string] , [number] ] , [string] ) , ( [string] , [ [string] , [number] ] , [string] ) , ( [string] , [ [string] , [number] ] , [string] ) , ( [string] , [ [string] , [number] ] , [string] ) , ( [string] , [ [string] , [number] ] , [string] ) , ( [string] , [ [string] , [number] ] , [string] ) , ) : [EOL] vis = core . make_number ( vis ) [EOL] if ceiling : [EOL] ceiling = structs . Cloud ( None , * ceiling ) [EOL] assert rule == static . FLIGHT_RULES [ core . get_flight_rules ( vis , ceiling ) ] [EOL] [EOL] def test_get_ceiling ( self ) : [EOL] [docstring] [EOL] for clouds , ceiling in ( ( [ ] , None ) , ( [ [ [string] , [number] ] , [ [string] , [number] ] ] , None ) , ( [ [ [string] , None ] ] , None ) , ( [ [ [string] , [number] ] ] , [ [string] , [number] ] ) , ( [ [ [string] , [number] ] , [ [string] , [number] ] ] , [ [string] , [number] ] ) , ( [ [ [string] , None ] , [ [string] , [number] ] ] , [ [string] , [number] ] ) , ( [ [ [string] , [number] ] , [ [string] , [number] ] ] , [ [string] , [number] ] ) , ) : [EOL] clouds = [ structs . Cloud ( None , * cloud ) for cloud in clouds ] [EOL] if ceiling : [EOL] ceiling = structs . Cloud ( None , * ceiling ) [EOL] self . assertEqual ( core . get_ceiling ( clouds ) , ceiling ) [EOL] [EOL] def test_parse_date ( self ) : [EOL] [docstring] [EOL] today = datetime . utcnow ( ) [EOL] rts = today . strftime ( [string] ) [EOL] parsed = core . parse_date ( rts ) [EOL] self . assertIsInstance ( parsed , datetime ) [EOL] self . assertEqual ( parsed . day , today . day ) [EOL] self . assertEqual ( parsed . hour , today . hour ) [EOL] self . assertEqual ( parsed . minute , today . minute ) [EOL] [EOL] def test_make_timestamp ( self ) : [EOL] [docstring] [EOL] today = datetime . utcnow ( ) [EOL] rts = today . strftime ( [string] ) [EOL] date = core . make_timestamp ( rts ) [EOL] self . assertIsInstance ( date , structs . Timestamp ) [EOL] self . assertEqual ( date . repr , rts ) [EOL] self . assertEqual ( date . dt . day , today . day ) [EOL] self . assertEqual ( date . dt . hour , today . hour ) [EOL] [EOL] [EOL] class TestMetar ( BaseTest ) : [EOL] [EOL] def test_get_remarks ( self ) : [EOL] [docstring] [EOL] for raw , wx , rmk in ( ( [string] , [ [string] , [string] , [string] , [string] ] , [string] ) , ( [string] , [ [string] , [string] , [string] , [string] ] , [string] ) , ( [string] , [ [string] , [string] , [string] ] , [string] ) , ( [string] , [ [string] , [string] , [string] ] , [string] ) ) : [EOL] testwx , testrmk = core . get_remarks ( raw ) [EOL] self . assertEqual ( wx , testwx ) [EOL] self . assertEqual ( rmk , testrmk ) [EOL] [EOL] def test_sanitize_report_string ( self ) : [EOL] [docstring] [EOL] line = [string] [EOL] fixed = [string] [EOL] self . assertEqual ( core . sanitize_report_string ( line ) , fixed ) [EOL] [EOL] def test_get_altimeter ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] units = structs . Units ( ** static . NA_UNITS ) [EOL] for wx , alt in ( ( [ [string] , [string] ] , ( None , ) ) , ( [ [string] , [string] , [string] ] , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] ] , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] , [string] ] , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] , [string] ] , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] ] , ( [string] , [number] ) ) , ) : [EOL] self . assertEqual ( units . altimeter , [string] ) [EOL] retwx , ret_alt = core . get_altimeter ( wx , units ) [EOL] self . assertEqual ( retwx , [ [string] , [string] ] ) [EOL] self . assert_number ( ret_alt , * alt ) [EOL] [comment] [EOL] self . assertEqual ( units . altimeter , [string] ) [EOL] [comment] [EOL] units = structs . Units ( ** static . IN_UNITS ) [EOL] for wx , alt in ( ( [ [string] , [string] ] , ( None , ) ) , ( [ [string] , [string] , [string] ] , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] ] , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] , [string] ] , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] , [string] ] , ( [string] , [number] ) ) , ( [ [string] , [string] , [string] ] , ( [string] , [number] ) ) , ) : [EOL] self . assertEqual ( units . altimeter , [string] ) [EOL] retwx , ret_alt = core . get_altimeter ( wx , units , [string] ) [EOL] self . assertEqual ( retwx , [ [string] , [string] ] ) [EOL] self . assert_number ( ret_alt , * alt ) [EOL] [comment] [EOL] self . assertEqual ( units . altimeter , [string] ) [EOL] [EOL] [EOL] class TestTaf ( unittest . TestCase ) : [EOL] [EOL] def test_get_taf_remarks ( self ) : [EOL] [docstring] [EOL] for txt , rmk in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] report , remarks = core . get_taf_remarks ( txt ) [EOL] self . assertEqual ( report , [string] ) [EOL] self . assertEqual ( remarks , rmk ) [EOL] [EOL] def test_sanitize_line ( self ) : [EOL] [docstring] [EOL] for line in ( [string] , [string] , [string] ) : [EOL] self . assertEqual ( core . sanitize_line ( line ) , [string] ) [EOL] for line in ( [string] , [string] , [string] , [string] ) : [EOL] self . assertEqual ( core . sanitize_line ( line ) , [string] ) [EOL] self . assertEqual ( core . sanitize_line ( [string] ) , [string] ) [EOL] [EOL] def test_is_tempo_or_prob ( self ) : [EOL] [docstring] [EOL] for rtype in ( [string] , [string] , [string] ) : [EOL] self . assertTrue ( core . _is_tempo_or_prob ( rtype ) ) [EOL] for rtype in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] self . assertFalse ( core . _is_tempo_or_prob ( rtype ) ) [EOL] [EOL] def test_get_taf_alt_ice_turb ( self ) : [EOL] [docstring] [EOL] for wx , * data in ( ( [ [string] ] , [string] , [ ] , [ ] ) , ( [ [string] , [string] , [string] ] , [string] , [ [string] ] , [ [string] ] ) , ( [ [string] , [string] , [string] ] , [string] , [ [string] ] , [ ] ) ) : [EOL] self . assertEqual ( core . get_taf_alt_ice_turb ( wx ) , ( [ [string] ] , * data ) ) [EOL] [EOL] def test_starts_new_line ( self ) : [EOL] [docstring] [EOL] for item in [ * static . TAF_NEWLINE , [string] , [string] , [string] , [string] ] : [EOL] self . assertTrue ( core . starts_new_line ( item ) ) [EOL] for item in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] self . assertFalse ( core . starts_new_line ( item ) ) [EOL] [EOL] def test_split_taf ( self ) : [EOL] [docstring] [EOL] for report , num in ( ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ) : [EOL] split = core . split_taf ( report ) [EOL] self . assertEqual ( len ( split ) , num ) [EOL] self . assertEqual ( split [ [number] ] , [string] ) [EOL] [EOL] def test_get_type_and_times ( self ) : [EOL] [docstring] [EOL] for wx , * data in ( ( [ [string] ] , [string] , [string] , [string] ) , ( [ [string] , [string] ] , [string] , [string] , [string] ) , ( [ [string] , [string] , [string] ] , [string] , [string] , [string] ) , ( [ [string] , [string] , [string] ] , [string] , [string] , [string] ) , ( [ [string] , [string] ] , [string] , [string] , [string] ) , ( [ [string] , [string] ] , [string] , [string] , [string] ) , ( [ [string] , [string] , [string] ] , [string] , [string] , [string] ) ) : [EOL] self . assertEqual ( core . get_type_and_times ( wx ) , ( [ [string] ] , * data ) ) [EOL] [EOL] [comment] [EOL] def test_find_missing_taf_times ( self ) : [EOL] [docstring] [EOL] good_lines = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } ] [EOL] for line in good_lines : [EOL] for key in ( [string] , [string] ) : [EOL] line [ key ] = core . make_timestamp ( line [ key ] ) [EOL] bad_lines = deepcopy ( good_lines ) [EOL] bad_lines [ [number] ] [ [string] ] = None [EOL] bad_lines [ [number] ] [ [string] ] = None [EOL] bad_lines [ [number] ] [ [string] ] = None [EOL] bad_lines [ [number] ] [ [string] ] = None [EOL] start , end = good_lines [ [number] ] [ [string] ] , good_lines [ - [number] ] [ [string] ] [EOL] self . assertEqual ( core . find_missing_taf_times ( bad_lines , start , end ) , good_lines ) [EOL] [EOL] def test_get_temp_min_and_max ( self ) : [EOL] [docstring] [EOL] for wx , * temps in ( ( [ [string] ] , [string] , [string] ) , ( [ [string] , [string] , [string] ] , [string] , [string] ) , ( [ [string] , [string] , [string] ] , [string] , [string] ) , ) : [EOL] self . assertEqual ( core . get_temp_min_and_max ( wx ) , ( [ [string] ] , * temps ) ) [EOL] [EOL] def test_get_oceania_temp_and_alt ( self ) : [EOL] [docstring] [EOL] items = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] items , tlist , qlist = core . get_oceania_temp_and_alt ( items ) [EOL] self . assertEqual ( items , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( tlist , [ [string] , [string] ] ) [EOL] self . assertEqual ( qlist , [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , ( [string] , [number] , None ) ) , ( [string] , ( [string] , [number] , None ) ) , ( [string] , ( [string] , [number] , [string] ) ) , ( [string] , ( [string] , [number] , [string] ) ) , ( [string] , ( [string] , [number] , None ) ) , ( [string] , ( [string] , None , None ) ) , ( [string] , ( [string] , [number] , None ) ) , ] ) def test_split_cloud ( cloud , out ) : [EOL] [docstring] [EOL] assert out == core . split_cloud ( cloud ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ [string] ] , [ ] ) , ( [ [string] , [string] ] , [ [ [string] , [number] , None ] ] ) , ( [ [string] , [string] , [string] , [string] ] , [ [ [string] , [number] , None ] , [ [string] , [number] , [string] ] , [ [string] , [number] , None ] ] ) , ( [ [string] , [string] , [string] ] , [ [ [string] , [number] , None ] , [ [string] , [number] , None ] ] ) , ] ) def test_get_clouds ( wx , clouds ) : [EOL] [docstring] [EOL] wx , ret_clouds = core . get_clouds ( wx ) [EOL] assert [ [string] ] == wx [EOL] for i , cloud in enumerate ( ret_clouds ) : [EOL] assert isinstance ( cloud , structs . Cloud ) [EOL] for j , key in enumerate ( ( [string] , [string] , [string] ) ) : [EOL] assert clouds [ i ] [ j ] == getattr ( cloud , key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Number$ 0 $builtins.str$ 0 $builtins.object$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $elib_wx.avwx.structs.Number$ 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Number$ 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Number$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $elib_wx.avwx.structs.Number$ 0 $builtins.object$ 0 $builtins.object$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $elib_wx.avwx.structs.Number$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[elib_wx.avwx.structs.Number]$ 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elib_wx.avwx.structs.Cloud]$ 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elib_wx.avwx.structs.Cloud]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elib_wx.avwx.structs.Cloud]$ 0 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 $typing.List[elib_wx.avwx.structs.Cloud]$ 0 0 $elib_wx.avwx.structs.Cloud$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 0 0 0 0 0 $elib_wx.avwx.structs.Timestamp$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $elib_wx.avwx.structs.Timestamp$ 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Timestamp$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $elib_wx.avwx.structs.Timestamp$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Timestamp$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , Dict , Literal , Any , List , Union , Tuple [EOL] import typing_extensions [EOL] import typing [EOL] import elib_wx [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import unittest [EOL] [EOL] import pytest [EOL] [EOL] [comment] [EOL] from elib_wx . avwx import core , static , structs , translate [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ] ) def test_visibility ( vis , unit , translation ) : [EOL] [docstring] [EOL] assert translation == translate . visibility ( core . make_number ( vis ) , unit ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ] ) def test_altimeter ( alt , unit , translation ) : [EOL] [docstring] [EOL] assert translate . altimeter ( core . make_number ( alt ) , unit ) == translation [EOL] [EOL] [EOL] def test_clouds_special ( ) : [EOL] [comment] [EOL] assert translate . clouds ( None ) == [string] [EOL] assert translate . clouds ( [ ] ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ [string] , [string] ] , [string] ) , ( [ [string] , [string] ] , [string] ) , ( [ [string] ] , [string] ) , ] ) def test_clouds ( clouds , translation ) : [EOL] clouds = [ core . make_cloud ( cloud ) for cloud in clouds ] [EOL] assert translate . clouds ( clouds ) == translation + [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) def test_wxcode ( code , translation ) : [EOL] assert translate . wxcode ( code ) == translation [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ ] , [string] ) , ( [ [string] , [string] ] , [string] ) , ( [ [string] ] , [string] ) , ] ) def test_other_list ( codes , translation ) : [EOL] for codes , translation in ( ) : [EOL] assert translate . other_list ( codes ) == translation [EOL] [EOL] [EOL] def test_shared ( ) : [EOL] units = structs . Units ( ** static . NA_UNITS ) [EOL] data = structs . SharedData ( altimeter = core . make_number ( [string] ) , clouds = [ core . make_cloud ( [string] ) ] , flight_rules = [string] , other = [ [string] ] , sanitized = [string] , visibility = core . make_number ( [string] ) , wind_direction = core . make_number ( [string] ) , wind_gust = core . make_number ( [string] ) , wind_speed = core . make_number ( [string] ) ) [EOL] [comment] [EOL] trans = translate . shared ( data , units ) [EOL] assert isinstance ( trans , dict ) [EOL] for key in ( [string] , [string] , [string] , [string] ) : [EOL] assert key in trans [EOL] assert trans [ key ] [EOL] [EOL] [EOL] class TestMetar ( unittest . TestCase ) : [EOL] [EOL] def test_cardinal_direction ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] keys = ( [number] , [number] , [number] , [number] ) [EOL] for i , cardinal in enumerate ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) : [EOL] lower = keys [ i % [number] ] + [number] * ( i // [number] ) [EOL] upper = keys [ [number] ] + [number] * ( ( i // [number] ) + [number] ) - [number] if i % [number] == [number] else keys [ ( i % [number] ) + [number] ] + [number] * ( i // [number] ) - [number] [EOL] for direction in range ( lower , upper + [number] ) : [EOL] self . assertEqual ( translate . get_cardinal_direction ( direction ) , cardinal ) [EOL] [comment] [EOL] for direction in range ( - [number] , [number] ) : [EOL] self . assertEqual ( translate . get_cardinal_direction ( direction ) , [string] ) [EOL] [EOL] def test_wind ( self ) : [EOL] [docstring] [EOL] for * wind , vardir , translation in ( ( [string] , [string] , [string] , None , [string] ) , ( [string] , [string] , [string] , [ [string] , [string] ] , [string] ) , ( [string] , [string] , [string] , None , [string] ) , ( [string] , [string] , [string] , None , [string] ) , ( [string] , [string] , [string] , [ [string] , [string] ] , [string] ) , ) : [EOL] wind = [ core . make_number ( i ) for i in wind ] [EOL] if vardir : [EOL] vardir = [ core . make_number ( i ) for i in vardir ] [EOL] self . assertEqual ( translate . wind ( * wind , vardir ) , translation ) [EOL] [EOL] def test_temperature ( self ) : [EOL] [docstring] [EOL] for temp , unit , translation in ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) : [EOL] self . assertEqual ( translate . temperature ( core . make_number ( temp ) , unit ) , translation ) [EOL] [EOL] def test_metar ( self ) : [EOL] [docstring] [EOL] units = structs . Units ( ** static . NA_UNITS ) [EOL] data = { [string] : core . make_number ( [string] ) , [string] : [ core . make_cloud ( [string] ) ] , [string] : core . make_number ( [string] ) , [string] : [ [string] ] , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : [ core . make_number ( [string] ) , core . make_number ( [string] ) ] } [EOL] data . update ( { k : [string] for k in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) } ) [EOL] data = structs . MetarData ( ** data ) [EOL] [comment] [EOL] trans = structs . MetarTrans ( altimeter = [string] , clouds = [string] , dewpoint = [string] , other = [string] , remarks = { } , temperature = [string] , visibility = [string] , wind = [string] ) [EOL] translated = translate . metar ( data , units ) [EOL] self . assertIsInstance ( translated , structs . MetarTrans ) [EOL] self . assertEqual ( translated , trans ) [EOL] [EOL] [EOL] class TestTaf ( unittest . TestCase ) : [EOL] [EOL] def test_wind_shear ( self ) : [EOL] [docstring] [EOL] for shear , translation in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ) : [EOL] self . assertEqual ( translate . wind_shear ( shear ) , translation ) [EOL] [EOL] def test_turb_ice ( self ) : [EOL] [docstring] [EOL] for turbice , translation in ( ( [ ] , [string] ) , ( [ [string] ] , [string] ) , ( [ [string] ] , [string] ) , ( [ [string] , [string] ] , [string] ) , ) : [EOL] self . assertEqual ( translate . turb_ice ( turbice ) , translation ) [EOL] [EOL] def test_min_max_temp ( self ) : [EOL] [docstring] [EOL] for temp , translation in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] self . assertEqual ( translate . min_max_temp ( temp ) , translation ) [EOL] [EOL] def test_taf ( self ) : [EOL] [docstring] [EOL] units = structs . Units ( ** static . NA_UNITS ) [EOL] line_data = { [string] : core . make_number ( [string] ) , [string] : [ core . make_cloud ( [string] ) ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : [string] , [string] : core . make_number ( [string] ) } [EOL] line_data . update ( { k : [string] for k in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) } ) [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] data . update ( { k : [string] for k in ( [string] , [string] , [string] , [string] , [string] ) } ) [EOL] data = structs . TafData ( forecast = [ structs . TafLineData ( ** line_data ) ] , ** data ) [EOL] [comment] [EOL] line_trans = structs . TafLineTrans ( altimeter = [string] , clouds = [string] , icing = [string] , other = [string] , turbulance = [string] , visibility = [string] , wind_shear = [string] , wind = [string] ) [EOL] trans = structs . TafTrans ( forecast = [ line_trans ] , max_temp = [string] , min_temp = [string] , remarks = { } ) [EOL] translated = translate . taf ( data , units ) [EOL] self . assertIsInstance ( translated , structs . TafTrans ) [EOL] for line in translated . forecast : [EOL] self . assertIsInstance ( line , structs . TafLineTrans ) [EOL] self . assertEqual ( translated , trans ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 0 0 0 $elib_wx.avwx.structs.MetarTrans$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarTrans$ 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarTrans$ 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarTrans$ 0 $elib_wx.avwx.structs.MetarTrans$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,typing.List[elib_wx.avwx.structs.Cloud],typing.List[builtins.str],elib_wx.avwx.structs.Number,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,typing.List[elib_wx.avwx.structs.Cloud],typing.List[builtins.str],elib_wx.avwx.structs.Number,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,typing.List[elib_wx.avwx.structs.Cloud],typing.List[builtins.str],elib_wx.avwx.structs.Number,builtins.str]]$ 0 0 0 0 $elib_wx.avwx.structs.TafData$ 0 0 0 0 $elib_wx.avwx.structs.TafLineTrans$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafTrans$ 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafLineTrans$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafTrans$ 0 0 0 0 0 $elib_wx.avwx.structs.TafData$ 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 $elib_wx.avwx.structs.TafTrans$ 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafTrans$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafTrans$ 0 $elib_wx.avwx.structs.TafTrans$ 0 0
[comment] [EOL] from typing import Dict , Any , List , Optional , Tuple [EOL] import typing [EOL] import elib_wx [EOL] [docstring] [EOL] import re [EOL] import unittest [EOL] [EOL] import pytest [EOL] [EOL] from elib_wx . avwx import core , speech , static , structs [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , None , None , None , [string] ) , ( [string] , [string] , [string] , None , [string] ) , ( [string] , [string] , [string] , None , [string] ) , ( [string] , [string] , None , None , [string] ) , ( [string] , [string] , [string] , [string] , [string] ) , ( [string] , [string] , [string] , [string] , [string] ) , ( [string] , [string] , [string] , None , [string] ) , ( [string] , [string] , [string] , None , [string] ) , ] ) def test_type_and_times ( type_ , start_time , end_time , prob , spoken ) : [EOL] times = core . make_timestamp ( start_time ) , core . make_timestamp ( end_time ) [EOL] if prob is not None : [EOL] prob = core . make_number ( prob ) [EOL] [comment] [EOL] ret = speech . type_and_times ( type_ , * times , prob ) [EOL] assert isinstance ( ret , str ) [EOL] assert ret == spoken [EOL] [EOL] [EOL] class TestSpeech ( unittest . TestCase ) : [EOL] [EOL] def test_wind ( self ) : [EOL] [docstring] [EOL] for * wind , vardir , spoken in ( ( [string] , [string] , [string] , None , [string] ) , ( [string] , [string] , [string] , [ [string] , [string] ] , [string] ) , ( [string] , [string] , [string] , None , [string] ) , ( [string] , [string] , [string] , None , [string] ) , ( [string] , [string] , [string] , [ [string] , [string] ] , [string] ) , ) : [EOL] wind = [ core . make_number ( i ) for i in wind ] [EOL] if vardir : [EOL] vardir = [ core . make_number ( i , speak = i ) for i in vardir ] [EOL] self . assertEqual ( speech . wind ( * wind , vardir ) , [string] + spoken ) [EOL] [EOL] def test_temperature ( self ) : [EOL] [docstring] [EOL] for temp , unit , spoken in ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) : [EOL] self . assertEqual ( speech . temperature ( [string] , core . make_number ( temp ) , unit ) , [string] + spoken ) [EOL] [EOL] def test_visibility ( self ) : [EOL] [docstring] [EOL] for vis , unit , spoken in ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) : [EOL] self . assertEqual ( speech . visibility ( core . make_number ( vis ) , unit ) , [string] + spoken ) [EOL] [EOL] def test_altimeter ( self ) : [EOL] [docstring] [EOL] for alt , unit , spoken in ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) : [EOL] self . assertEqual ( speech . altimeter ( core . make_number ( alt ) , unit ) , [string] + spoken ) [EOL] [EOL] def test_other ( self ) : [EOL] [docstring] [EOL] for code , spoken in ( ( [ ] , [string] ) , ( [ [string] ] , [string] ) , ( [ [string] , [string] ] , [string] ) , ( [ [string] , [string] , [string] ] , [string] ) , ) : [EOL] self . assertEqual ( speech . other ( code ) , spoken ) [EOL] [EOL] def test_metar ( self ) : [EOL] [docstring] [EOL] units = structs . Units ( ** static . NA_UNITS ) [EOL] data = { [string] : core . make_number ( [string] ) , [string] : [ core . make_cloud ( [string] ) ] , [string] : core . make_number ( [string] ) , [string] : [ [string] ] , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : [ core . make_number ( [string] ) , core . make_number ( [string] , speak = [string] ) ] } [EOL] data . update ( { k : None for k in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) } ) [EOL] data = structs . MetarData ( ** data ) [EOL] spoken = ( [string] [string] [string] [string] [string] ) [EOL] ret = speech . metar ( data , units ) [EOL] self . assertIsInstance ( ret , str ) [EOL] self . assertEqual ( ret , spoken ) [EOL] [EOL] def test_wind_shear ( self ) : [EOL] [docstring] [EOL] for shear , spoken in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ) : [EOL] self . assertEqual ( speech . wind_shear ( shear ) , spoken ) [EOL] [EOL] def test_taf_line ( self ) : [EOL] [docstring] [EOL] units = structs . Units ( ** static . NA_UNITS ) [EOL] line = { [string] : core . make_number ( [string] ) , [string] : [ core . make_cloud ( [string] ) ] , [string] : core . make_timestamp ( [string] ) , [string] : [ [string] ] , [string] : [ [string] ] , [string] : core . make_timestamp ( [string] ) , [string] : [ [string] ] , [string] : [string] , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : [string] , [string] : core . make_number ( [string] ) , } [EOL] line . update ( { k : None for k in ( [string] , [string] , [string] , [string] ) } ) [EOL] line = structs . TafLineData ( ** line ) [EOL] spoken = ( [string] [string] [string] [string] [string] [string] ) [EOL] ret = speech . taf_line ( line , units ) [EOL] self . assertIsInstance ( ret , str ) [EOL] self . assertEqual ( ret , spoken ) [EOL] [EOL] def test_taf ( self ) : [EOL] [docstring] [EOL] units = structs . Units ( ** static . NA_UNITS ) [EOL] [comment] [EOL] empty_line = { k : None for k in structs . TafLineData . __dataclass_fields__ . keys ( ) } [EOL] forecast = [ structs . TafLineData ( ** { ** empty_line , ** line } ) for line in ( { [string] : [string] , [string] : core . make_timestamp ( [string] ) , [string] : core . make_timestamp ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , [string] : core . make_number ( [string] ) , } , { [string] : [string] , [string] : core . make_number ( [string] ) , [string] : core . make_timestamp ( [string] ) , [string] : core . make_timestamp ( [string] ) , [string] : core . make_number ( [string] ) , } , ) ] [EOL] [comment] [EOL] taf = structs . TafData ( raw = None , remarks = None , station = None , time = None , forecast = forecast , start_time = core . make_timestamp ( [string] ) , end_time = core . make_timestamp ( [string] ) ) [EOL] ret = speech . taf ( taf , units ) [EOL] spoken = ( [string] [string] [string] [string] ) [EOL] self . assertIsInstance ( ret , str ) [EOL] assert re . match ( spoken , ret ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $elib_wx.avwx.structs.MetarData$ 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafLineData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafLineData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafLineData$ 0 0 0 0 0 0 $elib_wx.avwx.structs.TafLineData$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $elib_wx.avwx.structs.TafLineData$ 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.Units$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elib_wx.avwx.structs.TafLineData]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.structs.TafData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elib_wx.avwx.structs.TafLineData]$ 0 $typing.List[elib_wx.avwx.structs.TafLineData]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $elib_wx.avwx.structs.TafData$ 0 $elib_wx.avwx.structs.TafData$ 0 $elib_wx.avwx.structs.Units$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0
[comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import unittest [EOL] [EOL] [comment] [EOL] from elib_wx . avwx import structs , summary [EOL] [EOL] [EOL] class TestSummary ( unittest . TestCase ) : [EOL] [EOL] def test_metar ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertEqual ( summary . metar ( structs . MetarTrans ( altimeter = [string] , clouds = [string] , dewpoint = [string] , other = [string] , remarks = { } , temperature = [string] , visibility = [string] , wind = [string] ) ) , ( [string] [string] [string] ) ) [EOL] [EOL] def test_taf ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertEqual ( summary . taf ( structs . TafLineTrans ( altimeter = [string] , clouds = [string] , icing = [string] , other = [string] , turbulance = [string] , visibility = [string] , wind_shear = [string] , wind = [string] ) ) , ( [string] [string] [string] [string] [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import elib_wx [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import unittest [EOL] [EOL] import pytest [EOL] from requests import ConnectionError [EOL] [EOL] [comment] [EOL] from elib_wx . avwx import exceptions , service [EOL] [EOL] [EOL] @ pytest . mark . long class TestService ( unittest . TestCase ) : [EOL] serv = ... [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . serv = service . Service ( [string] ) [EOL] [EOL] def test_init ( self ) : [EOL] [docstring] [EOL] for attr in ( [string] , [string] , [string] , [string] ) : [EOL] self . assertTrue ( hasattr ( self . serv , attr ) ) [EOL] self . assertEqual ( self . serv . rtype , [string] ) [EOL] [EOL] def test_service ( self ) : [EOL] [docstring] [EOL] if type ( self . serv ) == service . Service : [EOL] with self . assertRaises ( NotImplementedError ) : [EOL] [comment] [EOL] self . serv . _extract ( None ) [EOL] else : [EOL] self . assertIsInstance ( self . serv . url , str ) [EOL] self . assertIsInstance ( self . serv . method , str ) [EOL] self . assertIn ( self . serv . method , ( [string] , [string] ) ) [EOL] [EOL] def test_make_err ( self ) : [EOL] [docstring] [EOL] key , msg = [string] , [string] [EOL] err = self . serv . make_err ( msg , key ) [EOL] err_str = f' [string] { key } [string] { self . serv . __class__ . __name__ } [string] { msg }' [EOL] self . assertIsInstance ( err , exceptions . InvalidRequestError ) [EOL] self . assertEqual ( err . args , ( err_str , ) ) [EOL] self . assertEqual ( str ( err ) , err_str ) [EOL] [EOL] def test_fetch ( self ) : [EOL] [docstring] [EOL] for station in ( [string] , [string] ) : [EOL] with self . assertRaises ( exceptions . BadStationError ) : [EOL] self . serv . fetch ( station ) [EOL] [comment] [EOL] with self . assertRaises ( AttributeError ) : [EOL] self . serv . fetch ( [string] ) [EOL] [EOL] [EOL] class TestNOAA ( TestService ) : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . serv = service . NOAA ( [string] ) [EOL] [EOL] def test_fetch ( self ) : [EOL] [docstring] [EOL] for station in ( [string] , [string] ) : [EOL] with self . assertRaises ( exceptions . BadStationError ) : [EOL] self . serv . fetch ( station ) [EOL] for station in ( [string] , [string] , [string] ) : [EOL] report = self . serv . fetch ( station ) [EOL] self . assertIsInstance ( report , str ) [EOL] self . assertTrue ( report . startswith ( station ) ) [EOL] [EOL] [EOL] @ pytest . mark . xfail ( raises = ConnectionError ) def test_fetch_amo ( ) : [EOL] [docstring] [EOL] serv = service . AMO ( [string] ) [EOL] for station in ( [string] , [string] ) : [EOL] with pytest . raises ( exceptions . BadStationError ) : [EOL] serv . fetch ( station ) [EOL] for station in ( [string] , [string] , [string] ) : [EOL] report = serv . fetch ( station ) [EOL] assert isinstance ( report , str ) [EOL] assert report . startswith ( station ) [EOL] [EOL] [EOL] class TestMAC ( TestService ) : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . serv = service . MAC ( [string] ) [EOL] [EOL] def test_fetch ( self ) : [EOL] [docstring] [EOL] for station in ( [string] , [string] ) : [EOL] with self . assertRaises ( exceptions . BadStationError ) : [EOL] self . serv . fetch ( station ) [EOL] for station in ( [string] , ) : [EOL] report = self . serv . fetch ( station ) [EOL] self . assertIsInstance ( report , str ) [EOL] self . assertTrue ( report . startswith ( station ) ) [EOL] [EOL] [EOL] class TestModule ( unittest . TestCase ) : [EOL] [EOL] def test_get_service ( self ) : [EOL] [docstring] [EOL] for stations , serv in ( ( ( [string] , [string] , [string] ) , service . NOAA ) , ( ( [string] , ) , service . AMO ) , ( ( [string] , [string] ) , service . MAC ) , ) : [EOL] for station in stations : [EOL] self . assertIsInstance ( service . get_service ( station ) ( station ) , serv ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.service.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.service.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.exceptions.InvalidRequestError$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.exceptions.InvalidRequestError$ 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.exceptions.InvalidRequestError$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.exceptions.InvalidRequestError$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.service.NOAA$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.service.MAC$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import elib_wx [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import json [EOL] import os [EOL] import unittest [EOL] from datetime import datetime [EOL] from glob import glob [EOL] [EOL] from dataclasses import asdict [EOL] [EOL] [comment] [EOL] from elib_wx . avwx import Metar , metar , structs [EOL] [EOL] [EOL] class TestMetar ( unittest . TestCase ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def test_parse ( self ) : [EOL] [docstring] [EOL] report = [string] [EOL] data , units = metar . parse ( report [ : [number] ] , report ) [EOL] self . assertIsInstance ( data , structs . MetarData ) [EOL] self . assertIsInstance ( units , structs . Units ) [EOL] self . assertEqual ( data . raw , report ) [EOL] [EOL] def test_metar_ete ( self ) : [EOL] [docstring] [EOL] for path in glob ( os . path . dirname ( os . path . realpath ( __file__ ) ) + [string] ) : [EOL] ref = json . load ( open ( path ) ) [EOL] station = Metar ( path . split ( [string] ) [ - [number] ] [ : [number] ] ) [EOL] self . assertIsNone ( station . last_updated ) [EOL] self . assertTrue ( station . update ( ref [ [string] ] [ [string] ] ) ) [EOL] self . assertIsInstance ( station . last_updated , datetime ) [EOL] [comment] [EOL] station . metar_data . time = None [EOL] self . assertEqual ( asdict ( station . metar_data ) , ref [ [string] ] ) [EOL] self . assertEqual ( asdict ( station . metar_translations ) , ref [ [string] ] ) [EOL] self . assertEqual ( station . summary , ref [ [string] ] ) [EOL] self . assertEqual ( station . speech , ref [ [string] ] ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.Metar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.Metar$ 0 0 0 0 0 0 0 0 $elib_wx.avwx.Metar$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.Metar$ 0 0 0 0 0 0 0 0 $elib_wx.avwx.Metar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.Metar$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.Metar$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.Metar$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $elib_wx.avwx.Metar$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , List [EOL] import typing [EOL] import elib_wx [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import unittest [EOL] [EOL] [comment] [EOL] from elib_wx . avwx import core , remarks , static , structs [EOL] [EOL] [EOL] class TestRemarks ( unittest . TestCase ) : [EOL] [EOL] def test_tdec ( self ) : [EOL] [docstring] [EOL] for code , temp in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] self . assertEqual ( remarks . _tdec ( code ) , temp ) [EOL] [EOL] def test_temp_minmax ( self ) : [EOL] [docstring] [EOL] for code , ttype , temp in ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) : [EOL] equals = f' [string] { ttype } [string] { temp }' [EOL] self . assertEqual ( remarks . temp_minmax ( code ) , equals ) [EOL] [EOL] def test_pressure_tendency ( self ) : [EOL] [docstring] [EOL] for code , pressure in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] equals = ( [string] f'{ pressure } [string] { static . PRESSURE_TENDENCIES [ code [ [number] ] ] }' ) [EOL] self . assertEqual ( remarks . pressure_tendency ( code ) , equals ) [EOL] [EOL] def test_precip_36 ( self ) : [EOL] [docstring] [EOL] for code , three , six in ( ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ) : [EOL] equals = f' [string] { three } [string] { six } [string] ' [EOL] self . assertEqual ( remarks . precip_36 ( code ) , equals ) [EOL] [EOL] def test_precip_24 ( self ) : [EOL] [docstring] [EOL] for code , precip in ( ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ) : [EOL] equals = f' [string] { precip } [string] ' [EOL] self . assertEqual ( remarks . precip_24 ( code ) , equals ) [EOL] [EOL] def test_sunshine_duration ( self ) : [EOL] [docstring] [EOL] for code , minutes in ( ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ) : [EOL] equals = f' [string] { minutes } [string] ' [EOL] self . assertEqual ( remarks . sunshine_duration ( code ) , equals ) [EOL] [EOL] def test_parse ( self ) : [EOL] [docstring] [EOL] for rmk , data in ( ( [string] , ( None , None ) ) , ( [string] , ( [string] , [string] ) ) , ( [string] , ( [string] , [string] ) ) , ) : [EOL] data = [ core . make_number ( d ) for d in data ] [EOL] self . assertEqual ( remarks . parse ( rmk ) , structs . RemarksData ( * data ) ) [EOL] [EOL] def test_translate ( self ) : [EOL] [docstring] [EOL] for rmk , out in ( ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) , ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) , ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) , ) : [EOL] self . assertEqual ( remarks . translate ( rmk ) , out ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[elib_wx.avwx.structs.Number]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0