from typing import Dict , List , Any [EOL] import requests [EOL] import typing [EOL] from datetime import datetime [EOL] from secrets import token_hex [EOL] [EOL] import requests [EOL] [EOL] [EOL] def get_random ( id ) : [EOL] random = token_hex ( [number] ) [EOL] current_time = datetime . now ( ) . isoformat ( ) [EOL] return f'{ id } [string] { random } [string] { current_time }' [EOL] [EOL] [EOL] def get_person ( ) : [EOL] url = [string] [EOL] response = requests . get ( url ) [EOL] [EOL] [comment] [EOL] if response . status_code == [number] : [EOL] return response . json ( ) [EOL] else : [EOL] return { } [EOL] [EOL] [EOL] def get_starship ( ) : [EOL] url1 = [string] [EOL] url2 = [string] [EOL] [EOL] st_1 = requests . get ( url1 ) [EOL] st_2 = requests . get ( url2 ) [EOL] [EOL] return st_1 , st_2 [EOL] [EOL] [EOL] def create_planet ( ) : [EOL] url = [string] [EOL] planets = [ { [string] : [string] } , { [string] : [string] } ] [EOL] [EOL] created = [ ] [EOL] for planet in planets : [EOL] response = requests . post ( url , json = planet ) [EOL] created . append ( response ) [EOL] [EOL] return created [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] [EOL] def fizzbuzz ( number ) : [EOL] if type ( number ) != int : [EOL] return [string] [EOL] if number % [number] == [number] : [EOL] return [string] [EOL] if number % [number] == [number] : [EOL] return [string] [EOL] if number % [number] == [number] : [EOL] return [string] [EOL] return number [EOL] [EOL] [EOL] class TestFizzbuzz ( TestCase ) : [EOL] def test_one_should_return_one ( self ) : [EOL] number = [number] [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , number ) [EOL] [EOL] def test_two_should_return_two ( self ) : [EOL] number = [number] [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , number ) [EOL] [EOL] def test_three_should_return_fizz ( self ) : [EOL] number = [number] [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_six_should_return_fizz ( self ) : [EOL] number = [number] [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_five_should_return_buzz ( self ) : [EOL] number = [number] [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_ten_should_return_ten ( self ) : [EOL] number = [number] [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_fifteen_should_return_fizzbuzz ( self ) : [EOL] number = [number] [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_thirty_should_return_fizzbuzz ( self ) : [EOL] number = [number] [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_enter_string_should_return_error_message ( self ) : [EOL] number = [string] [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_enter_bool_should_return_error_message ( self ) : [EOL] number = True [EOL] actual = fizzbuzz ( number ) [EOL] self . assertEqual ( actual , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import flask [EOL] import typing [EOL] from datetime import datetime [EOL] [EOL] from flask import jsonify , Flask , request [EOL] [EOL] [EOL] app = Flask ( __name__ ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def hello ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ app . route ( [string] ) def create_budget ( ) : [EOL] data = request . get_json ( ) [EOL] amount = data [ [string] ] [EOL] date = data . get ( [string] , datetime . now ( ) ) [EOL] [EOL] return jsonify ( dict ( amount = amount , date = date ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import find_packages , setup [EOL] [EOL] setup ( name = [string] , version = [string] , packages = find_packages ( ) , include_package_data = True , zip_safe = False , install_requires = [ [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Union [EOL] import freezegun [EOL] import typing [EOL] import unittest [EOL] from contextlib import ExitStack [EOL] from unittest import TestCase [EOL] from unittest . mock import patch , Mock , call [EOL] [EOL] from freezegun import freeze_time [EOL] [EOL] from get_random import get_person , get_random , get_starship , create_planet [EOL] [EOL] [EOL] class TestGetRandom ( TestCase ) : [EOL] [EOL] @ freeze_time ( [string] ) @ patch ( [string] , return_value = [string] ) def test_get_random_should_return_id_and_random_and_current_time ( self , mock_random ) : [EOL] id = [number] [EOL] actual = get_random ( id ) [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_get_random_with_context ( self ) : [EOL] id = [number] [EOL] [EOL] with patch ( [string] , return_value = [string] ) : [EOL] with freeze_time ( [string] ) : [EOL] actual = get_random ( id ) [EOL] [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_get_random_with_exit_stack ( self ) : [EOL] id = [number] [EOL] [EOL] with ExitStack ( ) as stack : [EOL] stack . enter_context ( patch ( [string] , return_value = [string] ) ) [EOL] stack . enter_context ( freeze_time ( [string] ) ) [EOL] [EOL] actual = get_random ( id ) [EOL] [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_get_random_with_exit_stack_complex ( self ) : [EOL] id = [number] [EOL] mock_list = [ patch ( [string] , return_value = [string] ) , freeze_time ( [string] ) ] [EOL] [EOL] with ExitStack ( ) as stack : [EOL] [ stack . enter_context ( mock ) for mock in mock_list ] [EOL] [EOL] actual = get_random ( id ) [EOL] [EOL] self . assertEqual ( actual , [string] ) [EOL] [EOL] def test_get_random_should_call_token_hex_with_16 ( self ) : [EOL] id = [number] [EOL] [EOL] with ExitStack ( ) as stack : [EOL] mock_token_hex = stack . enter_context ( patch ( [string] , return_value = [string] ) ) [EOL] stack . enter_context ( freeze_time ( [string] ) ) [EOL] [EOL] get_random ( id ) [EOL] [EOL] mock_token_hex . assert_called_once_with ( [number] ) [EOL] [EOL] [EOL] class TestGetPerson ( TestCase ) : [EOL] def mock_response ( self , status_code = [number] , json = { } ) : [EOL] return Mock ( status_code = status_code , json = Mock ( return_value = json ) ) [EOL] [EOL] def test_get_person_should_return_person ( self ) : [EOL] expected = { [string] : [string] } [EOL] [EOL] with patch ( [string] ) as mock_request : [EOL] mock_request . return_value = self . mock_response ( json = expected ) [EOL] actual = get_person ( ) [EOL] [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] def test_get_person_shoud_return_empty_dict_when_status_code_is_not_ok ( self ) : [EOL] expected = { } [EOL] [EOL] with patch ( [string] ) as mock_request : [EOL] mock_request . return_value = self . mock_response ( status_code = [number] ) [EOL] actual = get_person ( ) [EOL] [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] def test_get_person_should_make_request_with_url ( self ) : [EOL] url = [string] [EOL] [EOL] with patch ( [string] ) as mock_request : [EOL] mock_request . return_value = self . mock_response ( status_code = [number] ) [EOL] get_person ( ) [EOL] [EOL] mock_request . assert_called_once_with ( url ) [EOL] [EOL] [EOL] class TestGetStarship ( TestCase ) : [EOL] def mock_response ( self , status_code = [number] , json = { } ) : [EOL] return Mock ( status_code = status_code , json = Mock ( return_value = json ) ) [EOL] [EOL] def test_get_starship_should_make_2_request ( self ) : [EOL] url1 = [string] [EOL] url2 = [string] [EOL] [EOL] with patch ( [string] ) as mock_request : [EOL] mock_request . return_value = self . mock_response ( ) [EOL] get_starship ( ) [EOL] [EOL] mock_request . assert_has_calls ( [ call ( url1 ) , call ( url2 ) , ] , any_order = False ) [EOL] [EOL] [EOL] class TestCreatePlanet ( TestCase ) : [EOL] def test_create_planet_should_create_two_planet ( self ) : [EOL] url = [string] [EOL] planets = [ { [string] : [string] } , { [string] : [string] } ] [EOL] expected = [ { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } ] [EOL] [EOL] with patch ( [string] ) as mock_request : [EOL] mock_request . side_effect = expected [EOL] actual = create_planet ( ) [EOL] [EOL] self . assertEqual ( actual , expected ) [EOL] mock_request . assert_has_calls ( [ call ( url , json = planets [ [number] ] ) , call ( url , json = planets [ [number] ] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Union[unittest.mock._patch[typing.Union[unittest.mock.AsyncMock,unittest.mock.MagicMock]],freezegun.api._freeze_time]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[unittest.mock._patch[typing.Union[unittest.mock.AsyncMock,unittest.mock.MagicMock]],freezegun.api._freeze_time]]$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[unittest.mock.AsyncMock,unittest.mock.MagicMock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Union[unittest.mock.AsyncMock,unittest.mock.MagicMock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sqlite3 [EOL] [EOL] import click [EOL] from flask import current_app , g [EOL] from flask . cli import with_appcontext [EOL] [EOL] [EOL] def get_db ( ) : [EOL] if [string] not in g : [EOL] g . db = sqlite3 . connect ( current_app . config [ [string] ] , detect_types = sqlite3 . PARSE_DECLTYPES ) [EOL] g . db . row_factory = sqlite3 . Row [EOL] [EOL] return g . db [EOL] [EOL] [EOL] def close_db ( e = None ) : [EOL] db = g . pop ( [string] , None ) [EOL] [EOL] if db is not None : [EOL] db . close ( ) [EOL] [EOL] [EOL] def init_db ( ) : [EOL] db = get_db ( ) [EOL] [EOL] with current_app . open_resource ( [string] ) as f : [EOL] db . executescript ( f . read ( ) . decode ( [string] ) ) [EOL] [EOL] [EOL] @ click . command ( [string] ) @ with_appcontext def init_db_command ( ) : [EOL] init_db ( ) [EOL] click . echo ( [string] ) [EOL] [EOL] [EOL] def init_app ( app ) : [EOL] app . teardown_appcontext ( close_db ) [EOL] app . cli . add_command ( init_db_command ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import tempfile [EOL] [EOL] import pytest [EOL] from flaskr import create_app [EOL] from flaskr . db import get_db , init_db [EOL] [EOL] with open ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) , [string] ) as f : [EOL] _data_sql = f . read ( ) . decode ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def app ( ) : [EOL] db_fd , db_path = tempfile . mkstemp ( ) [EOL] [EOL] app = create_app ( { [string] : True , [string] : db_path , } ) [EOL] [EOL] with app . app_context ( ) : [EOL] init_db ( ) [EOL] get_db ( ) . executescript ( _data_sql ) [EOL] [EOL] yield app [EOL] [EOL] os . close ( db_fd ) [EOL] os . unlink ( db_path ) [EOL] [EOL] [EOL] @ pytest . fixture def client ( app ) : [EOL] return app . test_client ( ) [EOL] [EOL] [EOL] @ pytest . fixture def runner ( app ) : [EOL] return app . test_cli_runner ( ) [EOL] [EOL] [EOL] class AuthActions ( object ) : [EOL] def __init__ ( self , client ) : [EOL] self . _client = client [EOL] [EOL] def login ( self , username = [string] , password = [string] ) : [EOL] return self . _client . post ( [string] , data = { [string] : username , [string] : password } ) [EOL] [EOL] def logout ( self ) : [EOL] return self . _client . get ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def auth ( client ) : [EOL] return AuthActions ( client ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from flaskr import create_app [EOL] [EOL] [EOL] def test_config ( ) : [EOL] assert not create_app ( ) . testing [EOL] assert create_app ( { [string] : True } ) . testing [EOL] [EOL] [EOL] def test_hello ( client ) : [EOL] response = client . get ( [string] ) [EOL] assert response . data == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0