	0
from typing import Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] sys . path . append ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] from lib . translator . translater import Translator [EOL] [EOL] val = Translator ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
	0
from . entity import Entity , create_one , create_many , return_one , return_many [EOL] from . errors import ForeignKeyViolationError , NoDataFoundError , RestrictViolationError , SqlError , UniqueViolationError [EOL] from . data_contexts import DataContextFactory , EnvDataContextFactory [EOL] from . data_contexts import DataContext , PostgresDataContext [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . data_context import DataContext [EOL] from . data_context_factory import DataContextFactory [EOL] from . env_data_context_factory import EnvDataContextFactory [EOL] from . postgres_data_context import PostgresDataContext [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class NoDataFoundError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class ForeignKeyViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class SqlError ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class RestrictViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . foreign_key_violation_error import ForeignKeyViolationError [EOL] from . no_data_found_error import NoDataFoundError [EOL] from . restrict_violation_error import RestrictViolationError [EOL] from . sql_error import SqlError [EOL] from . unique_violation_error import UniqueViolationError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class NotNUllViolation ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class UniqueViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from manager import manager [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] manager . manage ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [EOL] from manager . commands import setup_reflections , setup_categories , setup_training [EOL] from manager . conf . env_congigure_facotry import EnvConfigureFactory [EOL] from manager . services . language_service import LanguageService [EOL] [EOL] [EOL] def manage ( ) : [EOL] conf = EnvConfigureFactory . create ( ) [EOL] [EOL] logging . info ( f' [string] ' ) [EOL] languages = LanguageService . get_supported_languages ( conf . dict_path + [string] ) [EOL] for lang in languages : [EOL] logging . info ( f' [string] { lang . title }' ) [EOL] [EOL] reflections = setup_reflections . setup ( conf = conf , languages = languages ) [EOL] [EOL] categories = setup_categories . setup ( conf = conf , languages = languages , reflections = reflections ) [EOL] [EOL] setup_training . setup ( conf = conf , categories = categories ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] manage ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Optional , Dict , Any [EOL] import manager [EOL] import requests [EOL] import builtins [EOL] import typing [EOL] import json [EOL] from functools import lru_cache [EOL] from typing import Optional [EOL] [EOL] import requests [EOL] [EOL] [EOL] from manager . conf . yandex_translator_conf import YandexTranslatorConf [EOL] [EOL] [EOL] class Translator ( object ) : [EOL] [EOL] def __init__ ( self , conf ) : [EOL] self . _conf = conf [EOL] [EOL] @ lru_cache ( maxsize = None ) def translate_word ( self , text , native_lang_code , foreign_lang_code ) : [EOL] [EOL] params = { [string] : self . _conf . key , [string] : self . _build_lang ( native_lang_code , foreign_lang_code ) , [string] : text } [EOL] [EOL] response = requests . get ( self . _conf . url , params = params ) [EOL] data = json . loads ( response . text ) [EOL] return None if len ( data ) == [number] else data . get ( [string] ) [ [number] ] [EOL] [EOL] def translate_text ( self , text , native_lang_code , foreign_lang_code ) : [EOL] params = { [string] : self . _conf . key , [string] : self . _build_lang ( native_lang_code , foreign_lang_code ) , [string] : text } [EOL] data = { [string] : text } [EOL] [EOL] response = requests . post ( self . _conf . url , params = params , data = data ) [EOL] data = json . loads ( response . text ) [EOL] return None if len ( data ) == [number] else data . get ( [string] ) [ [number] ] [EOL] [EOL] @ classmethod def _build_lang ( cls , native_lang_code , foreign_lang_code ) : [EOL] return f"{ native_lang_code } [string] { foreign_lang_code }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
import builtins [EOL] import uuid [EOL] from uuid import UUID [EOL] [EOL] [EOL] class Language ( object ) : [EOL] [EOL] def __init__ ( self , uid , title , code ) : [EOL] self . _uid = uid [EOL] self . _title = title [EOL] self . _code = code [EOL] [EOL] @ property def uid ( self ) : [EOL] return self . _uid [EOL] [EOL] @ property def title ( self ) : [EOL] return self . _title [EOL] [EOL] @ property def code ( self ) : [EOL] return self . _code [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $uuid.UUID$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $uuid.UUID$ 0 $uuid.UUID$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import manager [EOL] import uuid [EOL] import builtins [EOL] import typing [EOL] from typing import Set [EOL] from uuid import UUID [EOL] [EOL] from manager . models . reflection import Reflection [EOL] [EOL] [EOL] class Category ( object ) : [EOL] [EOL] def __init__ ( self , uid , title , reflection , items ) : [EOL] self . _uid = uid [EOL] self . _title = title [EOL] self . _reflection = reflection [EOL] self . _items = items [EOL] [EOL] @ property def uid ( self ) : [EOL] return self . _uid [EOL] [EOL] @ property def title ( self ) : [EOL] return self . _title [EOL] [EOL] @ property def reflection ( self ) : [EOL] return self . _reflection [EOL] [EOL] @ property def items ( self ) : [EOL] return self . _items [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $uuid.UUID$ 0 $builtins.str$ 0 $manager.models.reflection.Reflection$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $uuid.UUID$ 0 $uuid.UUID$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $manager.models.reflection.Reflection$ 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $manager.models.reflection.Reflection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0
import manager [EOL] import builtins [EOL] import uuid [EOL] from uuid import UUID [EOL] [EOL] from manager . models . category import Category [EOL] [EOL] [EOL] class Training ( object ) : [EOL] [EOL] def __init__ ( self , uid , category , native_item , foreign_item ) : [EOL] self . _uid = uid [EOL] self . _category = category [EOL] self . _native_item = native_item [EOL] self . _foreign_item = foreign_item [EOL] [EOL] @ property def uid ( self ) : [EOL] return self . _uid [EOL] [EOL] @ property def category ( self ) : [EOL] return self . _category [EOL] [EOL] @ property def native_item ( self ) : [EOL] return self . _native_item [EOL] [EOL] @ property def foreign_item ( self ) : [EOL] return self . _foreign_item [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $uuid.UUID$ 0 $manager.models.category.Category$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $uuid.UUID$ 0 $uuid.UUID$ 0 0 0 0 0 $manager.models.category.Category$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $manager.models.category.Category$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
	0
	0
import builtins [EOL] class YandexTranslatorConf ( object ) : [EOL] [EOL] def __init__ ( self , url , key ) : [EOL] self . _url = url [EOL] self . _key = key [EOL] [EOL] @ property def url ( self ) : [EOL] return self . _url [EOL] [EOL] @ property def key ( self ) : [EOL] return self . _key [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Tuple , Set , List [EOL] import builtins [EOL] import typing [EOL] import io [EOL] import _csv [EOL] import manager [EOL] import csv [EOL] import logging [EOL] from typing import Set , List , Tuple [EOL] from uuid import uuid4 [EOL] [EOL] from manager . conf . configure import Configure [EOL] from manager . conf . env_yandex_translator_cong_factory import EnvYandexTranslatorConfFactory [EOL] from manager . models . category import Category [EOL] from manager . models . training import Training [EOL] from manager . services . traslator import Translator [EOL] [EOL] logging . getLogger ( ) . setLevel ( logging . INFO ) [EOL] yandex_translator_conf = EnvYandexTranslatorConfFactory . create ( ) [EOL] translator = Translator ( yandex_translator_conf ) [EOL] [EOL] [EOL] def setup ( conf , categories ) : [EOL] trainings = create_trainings ( categories ) [EOL] save ( conf = conf , trainings = trainings ) [EOL] [EOL] [EOL] def save ( conf , trainings ) : [EOL] filename = f'{ conf . output_training_path } [string] ' [EOL] file = open ( filename , [string] ) [EOL] writer = csv . writer ( file , delimiter = [string] ) [EOL] writer . writerow ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] for t in trainings : [EOL] writer . writerow ( [ t . uid . hex , t . category . uid . hex , t . native_item , t . foreign_item ] ) [EOL] [EOL] file . close ( ) [EOL] [EOL] [EOL] def create_trainings ( categories ) : [EOL] training_list = [ ] [EOL] for category in categories : [EOL] items = category . items [EOL] logging . info ( f" [string] { category . title } [string] { category . reflection . title }" ) [EOL] for item in items : [EOL] native_item , foreign_item = translate_item ( item = item , native_lang_code = category . reflection . native_lang . code , foreign_lang_code = category . reflection . foreign_lang . code ) [EOL] [EOL] training = Training ( uid = uuid4 ( ) , category = category , native_item = native_item , foreign_item = foreign_item ) [EOL] training_list . append ( training ) [EOL] [EOL] return training_list [EOL] [EOL] [EOL] def translate_item ( item , native_lang_code , foreign_lang_code ) : [EOL] if native_lang_code == [string] : [EOL] native_item = item [EOL] else : [EOL] native_item = translator . translate_word ( item , [string] , native_lang_code ) [EOL] [EOL] foreign_item = translator . translate_word ( item , [string] , foreign_lang_code ) [EOL] return native_item , foreign_item [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[manager.models.training.Training]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Any , Dict [EOL] import src [EOL] import builtins [EOL] import typing [EOL] import unittest [EOL] [EOL] from typing import Dict , Any [EOL] [EOL] from src . tests . lingany_api_tests . language . language_stub import LanguageStub [EOL] [EOL] [EOL] class LanguageTestCase ( unittest . TestCase ) : [EOL] [EOL] _stub = None [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . _stub = LanguageStub ( ) [EOL] [EOL] def test_fail_create ( self ) : [EOL] response , sut = self . _stub . create ( ) [EOL] self . assertIn ( response . status_code , [ [number] , [number] ] ) [EOL] [EOL] def test_fail_delete ( self ) : [EOL] sut = self . _stub . get_instance ( ) [EOL] response = self . _stub . delete ( instance_id = sut [ [string] ] ) [EOL] self . assertIn ( response . status_code , [ [number] , [number] ] ) [EOL] [EOL] def test_get_by_id ( self ) : [EOL] sut = self . _stub . get_instance ( ) [EOL] response , obj = self . _stub . get_by_id ( sut [ [string] ] ) [EOL] self . assertEqual ( [number] , response . status_code ) [EOL] self . _check ( obj , sut ) [EOL] [EOL] def test_get_all ( self ) : [EOL] response , list_obj = self . _stub . get_all ( ) [EOL] self . assertEqual ( [number] , response . status_code ) [EOL] self . assertGreater ( len ( list_obj ) , [number] ) [EOL] [EOL] def _check ( self , obj , sut ) : [EOL] self . assertEqual ( obj [ [string] ] , sut [ [string] ] ) [EOL] self . assertEqual ( obj [ [string] ] , sut [ [string] ] ) [EOL] self . assertEqual ( obj [ [string] ] , sut [ [string] ] ) [EOL] self . assertEqual ( obj [ [string] ] , sut [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.tests.lingany_api_tests.language.language_stub.LanguageStub$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0
	0
	0
from typing import Any , Tuple , Dict , Optional [EOL] import flask [EOL] import uuid [EOL] import builtins [EOL] import typing [EOL] import os [EOL] [EOL] from typing import Any , Dict , Tuple , List , Optional [EOL] from uuid import uuid4 , UUID [EOL] [EOL] from flask import Response [EOL] [EOL] from apiutils import Request [EOL] from src . tests . lingany_api_tests . language . language_stub import LanguageStub [EOL] from testutils . stubs . api_stub import ApiStub [EOL] [EOL] [EOL] class ReflectionStub ( ApiStub ) : [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _language_stub = LanguageStub ( ) [EOL] [EOL] @ property def root ( self ) : [EOL] return f" [string] { os . environ [ [string] ] } [string] " [EOL] [EOL] def _generate ( self , ** kwargs ) : [EOL] data = { [string] : None , [string] : uuid4 ( ) . hex if kwargs . get ( [string] ) is None else kwargs . get ( [string] ) , [string] : kwargs . get ( [string] ) , [string] : kwargs . get ( [string] ) } [EOL] [EOL] if data . get ( [string] ) is None : [EOL] languge_stub = self . _language_stub . get_instance ( ) [EOL] data [ [string] ] = languge_stub [ [string] ] [EOL] [EOL] if data . get ( [string] ) is None : [EOL] languge_stub = self . _language_stub . get_instance ( ) [EOL] data [ [string] ] = languge_stub [ [string] ] [EOL] [EOL] return data [EOL] [EOL] def get_instance ( self ) : [EOL] _ , list_obj = self . get_all ( ) [EOL] return None if len ( list_obj ) == [number] else list_obj [ [number] ] [EOL] [EOL] def get_reflection_by_languages ( self , native_lang_id , foreign_lang_id ) : [EOL] response = Request . get ( f'{ self . root } [string] { native_lang_id } [string] { foreign_lang_id }' ) [EOL] result = None [EOL] if response . status_code == [number] : [EOL] result = response . json ( ) [EOL] return response , result [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Tuple , Dict [EOL] import builtins [EOL] import flask [EOL] import typing [EOL] import os [EOL] [EOL] from typing import Any , Dict , Tuple , List [EOL] [EOL] from flask import Response [EOL] [EOL] from apiutils import Request [EOL] from testutils . stubs . api_stub import ApiStub [EOL] [EOL] [EOL] class WordStub ( ApiStub ) : [EOL] [EOL] @ property def root ( self ) : [EOL] return f" [string] { os . environ [ [string] ] } [string] " [EOL] [EOL] def get_translation_by_text ( self , text , ref_id ) : [EOL] response = Request . get ( f'{ self . root } [string] { text } [string] { ref_id }' ) [EOL] result = None [EOL] if response . status_code == [number] : [EOL] result = response . json ( ) [EOL] return response , result [EOL] [EOL] def get_text_by_translation ( self , translation , ref_id ) : [EOL] response = Request . get ( f'{ self . root } [string] { translation } [string] { ref_id }' ) [EOL] result = None [EOL] if response . status_code == [number] : [EOL] result = response . json ( ) [EOL] return response , result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import src [EOL] import unittest [EOL] [EOL] from src . tests . lingany_api_tests . word . word_stub import WordStub [EOL] [EOL] [EOL] class WordTestCase ( unittest . TestCase ) : [EOL] [EOL] _stub = None [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . _stub = WordStub ( ) [EOL] [EOL] [comment] [EOL] def test_get_translation_by_text_from_db ( self ) : [EOL] ref_id = [string] [comment] [EOL] text = [string] [EOL] response , obj = self . _stub . get_translation_by_text ( text , ref_id ) [EOL] self . assertEqual ( [number] , response . status_code ) [EOL] translation = [string] [EOL] self . assertEqual ( translation , obj . get ( [string] ) ) [EOL] [EOL] def test_get_text_by_translation_from_db ( self ) : [EOL] ref_id = [string] [comment] [EOL] translation = [string] [EOL] response , obj = self . _stub . get_text_by_translation ( translation , ref_id ) [EOL] self . assertEqual ( [number] , response . status_code ) [EOL] text = [string] [EOL] self . assertEqual ( text , obj . get ( [string] ) ) [EOL] [EOL] def test_get_translation_by_text_from_web ( self ) : [EOL] ref_id = [string] [comment] [EOL] text = [string] [EOL] response , obj = self . _stub . get_translation_by_text ( text , ref_id ) [EOL] self . assertEqual ( [number] , response . status_code ) [EOL] translation = [string] [EOL] self . assertEqual ( translation , obj . get ( [string] ) ) [EOL] [EOL] def test_get_text_by_translation_from_web ( self ) : [EOL] ref_id = [string] [comment] [EOL] translation = [string] [EOL] response , obj = self . _stub . get_text_by_translation ( translation , ref_id ) [EOL] self . assertEqual ( [number] , response . status_code ) [EOL] text = [string] [EOL] self . assertEqual ( text , obj . get ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.tests.lingany_api_tests.word.word_stub.WordStub$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
	0
	0
	0
import builtins [EOL] from uuid import uuid4 [EOL] [EOL] [EOL] def make_str ( ) : [EOL] return uuid4 ( ) . hex [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from . abstract_expand_set import AbstractExpandSet [EOL] from . converter import Converter [EOL] from . entity import Entity , create_one , create_many [EOL] from . empty_expand_set import EmptyExpandSet [EOL] from . expand_item import ExpandItem [EOL] from . expand_set import ExpandSet [EOL] from . model import Model [EOL] from . repository import Repository [EOL] from . service import Service [EOL] [EOL] from . errors import ForeignKeyViolationError , NoDataFoundError , RestrictViolationError , SqlError , UniqueViolationError [EOL] from . data_contexts import ConfigDataContextFactory , DataContextFactory , EnvDataContextFactory [EOL] from . data_contexts import DataContext , MongoDataContext , PostgresDataContext [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . data_contexts . data_context_factory import DataContextFactory [EOL] [EOL] [EOL] class ConfigDataContextFactory ( DataContextFactory ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config_file ) : [EOL] [docstring] [EOL] self . _config_file = config_file [EOL] [EOL] def create_data_context ( self ) : [EOL] [comment] [EOL] return NotImplementedError [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . config_data_context_factory import ConfigDataContextFactory [EOL] from . data_context import DataContext [EOL] from . data_context_factory import DataContextFactory [EOL] from . env_data_context_factory import EnvDataContextFactory [EOL] from . mongo_data_context import MongoDataContext [EOL] from . postgres_data_context import PostgresDataContext [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class UniqueViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class NoDataFoundError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class RestrictViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class SqlError ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
from . foreign_key_violation_error import ForeignKeyViolationError [EOL] from . no_data_found_error import NoDataFoundError [EOL] from . restrict_violation_error import RestrictViolationError [EOL] from . sql_error import SqlError [EOL] from . unique_violation_error import UniqueViolationError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class ForeignKeyViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . base_blueprint import BaseBlueprint , return_one , return_many [EOL] from . request import Request [EOL] from . serializer import Serializer [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from lingany_api . app import app [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( host = [string] , port = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import expand_item [EOL] import builtins [EOL] from abc import ABCMeta , abstractmethod [EOL] [EOL] from . expand_item import ExpandItem [EOL] [EOL] [EOL] class AbstractExpandSet ( metaclass = ABCMeta ) : [EOL] [EOL] @ abstractmethod def append ( self , item ) : [EOL] pass [EOL] [EOL] @ abstractmethod def contains ( self , item ) : [EOL] pass [EOL] [EOL] @ abstractmethod def extract ( self , parent ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $expand_item.ExpandItem$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $expand_item.ExpandItem$ 0 0 0 0 0 0 0 0 0 $"AbstractExpandSet"$ 0 0 0 $expand_item.ExpandItem$ 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class NoDataFoundError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class SqlError ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
from . foreign_key_violation_error import ForeignKeyViolationError [EOL] from . no_data_found_error import NoDataFoundError [EOL] from . restrict_violation_error import RestrictViolationError [EOL] from . sql_error import SqlError [EOL] from . unique_violation_error import UniqueViolationError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class RestrictViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class ForeignKeyViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class UniqueViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] from sqlutils . data_contexts . data_context_factory import DataContextFactory [EOL] from sqlutils . data_contexts . postgres_data_context import PostgresDataContext [EOL] [EOL] [EOL] class EnvDataContextFactory ( DataContextFactory ) : [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def create_data_context ( self ) : [EOL] [comment] [EOL] host = os . environ [ [string] ] [EOL] port = os . environ [ [string] ] [EOL] database = os . environ [ [string] ] [EOL] user = os . environ [ [string] ] [EOL] password = os . environ [ [string] ] [EOL] [EOL] return PostgresDataContext ( host , port , database , user , password ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0
from sqlutils . data_contexts . data_context_factory import DataContextFactory [EOL] [EOL] [EOL] class ConfigDataContextFactory ( DataContextFactory ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config_file ) : [EOL] [docstring] [EOL] self . _config_file = config_file [EOL] [EOL] def create_data_context ( self ) : [EOL] [comment] [EOL] return NotImplementedError [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . config_data_context_factory import ConfigDataContextFactory [EOL] from . data_context import DataContext [EOL] from . data_context_factory import DataContextFactory [EOL] from . env_data_context_factory import EnvDataContextFactory [EOL] from . mongo_data_context import MongoDataContext [EOL] from . postgres_data_context import PostgresDataContext [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] import uuid [EOL] from uuid import UUID [EOL] [EOL] [EOL] class Attribute ( object ) : [EOL] [EOL] def __init__ ( self , attribute_type_id , attribute_value ) : [EOL] self . _attribute_type_id = attribute_type_id [EOL] self . _attribute_value = attribute_value [EOL] [EOL] @ property def attribute_type_id ( self ) : [EOL] return self . _attribute_type_id [EOL] [EOL] @ property def attribute_value ( self ) : [EOL] return self . _attribute_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $uuid.UUID$ 0 $builtins.str$ 0 0 0 0 0 $uuid.UUID$ 0 $uuid.UUID$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from enum import Enum [EOL] [EOL] [EOL] class MessageCategory ( Enum ) : [EOL] [EOL] EVENT = [number] [EOL] COMMAND = [number] [EOL] INFO = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import netutils [EOL] import uuid [EOL] import builtins [EOL] import typing [EOL] import dateutil . parser [EOL] [EOL] from typing import Dict , Any [EOL] from uuid import UUID [EOL] [EOL] from netutils . converters . attribute_converter import AttributeConverter [EOL] from netutils . messages . message import Message [EOL] from netutils . messages . message_category import MessageCategory [EOL] [EOL] [EOL] class MessageConverter ( object ) : [EOL] [EOL] @ staticmethod def dump ( message ) : [EOL] data = { [string] : message . uid . hex , [string] : message . actor_id . hex , [string] : message . actor_type_id . hex , [string] : message . occurred . astimezone ( ) . isoformat ( ) , [string] : message . category . value , [string] : message . message_type_id . hex , [string] : [ AttributeConverter . dump ( attribute ) for attribute in message . attributes ] } [EOL] return data [EOL] [EOL] @ staticmethod def load ( data ) : [EOL] if data [ [string] ] is None : [EOL] source_message_id = None [EOL] else : [EOL] source_message_id = UUID ( data [ [string] ] ) [EOL] [EOL] msg = Message ( uid = UUID ( data [ [string] ] ) , actor_id = UUID ( data [ [string] ] ) , actor_type_id = UUID ( data [ [string] ] ) , occurred = dateutil . parser . parse ( data [ [string] ] ) , category = MessageCategory ( data [ [string] ] ) , message_type_id = UUID ( data [ [string] ] ) , source_message_id = source_message_id , attributes = [ AttributeConverter . load ( attribute ) for attribute in data [ [string] ] ] ) [EOL] return msg [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Message"$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $uuid.UUID$ 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any , Dict [EOL] import netutils [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , Any [EOL] from uuid import UUID [EOL] [EOL] from netutils . messages . attribute import Attribute [EOL] [EOL] [EOL] class AttributeConverter ( object ) : [EOL] [EOL] @ staticmethod def dump ( attribute ) : [EOL] data = { [string] : attribute . attribute_type_id . hex , [string] : attribute . attribute_value } [EOL] return data [EOL] [EOL] @ staticmethod def load ( data ) : [EOL] attribute = Attribute ( attribute_type_id = UUID ( data [ [string] ] ) , attribute_value = data [ [string] ] ) [EOL] return attribute [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Attribute"$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0
	0
from typing import Callable , Dict [EOL] import builtins [EOL] import typing [EOL] from typing import Callable , Dict , Any [EOL] [EOL] from nameko . rpc import rpc [EOL] from nameko . standalone . events import event_dispatcher [EOL] [EOL] [EOL] class Dispatcher ( object ) : [EOL] [EOL] def __init__ ( self , amqp_uri ) : [EOL] config = { [string] : amqp_uri } [EOL] self . _amqp_uri = amqp_uri [EOL] self . _dispatch = event_dispatcher ( config ) [EOL] [EOL] @ property def amqp_uri ( self ) : [EOL] return self . _amqp_uri [EOL] [EOL] @ rpc def publish ( self , name , event_type , payload ) : [EOL] self . _dispatch ( name , event_type , payload ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Callable[[builtins.str,builtins.str,typing.Dict],None]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.object]$ 0 0
	0
from typing import Any , Dict [EOL] import netutils [EOL] import builtins [EOL] import typing [EOL] from typing import Dict [EOL] [EOL] from nameko . amqp import get_connection [EOL] from nameko . standalone . events import get_event_exchange [EOL] [EOL] from netutils . publisher . dispatcher import Dispatcher [EOL] [EOL] [EOL] class ChangePublisher ( object ) : [EOL] [EOL] def __init__ ( self , name , dispatcher ) : [EOL] self . _name = name [EOL] self . _dispatcher = dispatcher [EOL] self . _create_exchange ( ) [EOL] [EOL] def _create_exchange ( self ) : [EOL] with get_connection ( self . _dispatcher . amqp_uri ) as connection : [EOL] exchange = get_event_exchange ( self . _name ) [EOL] exchange . maybe_bind ( connection ) [EOL] exchange . declare ( ) [EOL] [EOL] def on_create ( self , payload ) : [EOL] self . _dispatcher . publish ( self . _name , [string] , payload ) [EOL] [EOL] def on_update ( self , payload ) : [EOL] self . _dispatcher . publish ( self . _name , [string] , payload ) [EOL] [EOL] def on_delete ( self , payload ) : [EOL] self . _dispatcher . publish ( self . _name , [string] , payload ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $netutils.publisher.dispatcher.Dispatcher$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $netutils.publisher.dispatcher.Dispatcher$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0
	0
from enum import Enum [EOL] [EOL] [EOL] class StopBits ( Enum ) : [EOL] [EOL] ONE = [number] [EOL] ONE_POINT_FIVE = [number] [EOL] TWO = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from enum import Enum [EOL] [EOL] [EOL] class Parity ( Enum ) : [EOL] [EOL] NONE = [string] [EOL] EVENT = [string] [EOL] ODD = [string] [EOL] MARK = [string] [EOL] SPACE = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from enum import Enum [EOL] [EOL] [EOL] class ByteSize ( Enum ) : [EOL] [EOL] FIVE = [number] [EOL] SIX = [number] [EOL] SEVEN = [number] [EOL] EIGHT = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Tuple , List [EOL] import asyncio [EOL] import netutils [EOL] import builtins [EOL] import typing [EOL] from abc import ABCMeta [EOL] from asyncio import AbstractEventLoop [EOL] from typing import Any , Tuple , List [EOL] [EOL] from netutils . clients . base_client import BaseClient [EOL] from netutils . controllers . controller import Controller [EOL] [EOL] [EOL] class SimpleController ( Controller , metaclass = ABCMeta ) : [EOL] [EOL] def __init__ ( self , client , loop ) : [EOL] super ( ) . __init__ ( client , loop ) [EOL] self . _msg_counter = [number] [EOL] [EOL] def _get_message_id_for ( self , data ) : [EOL] return sorted ( self . _wait_message_id_set ) . pop ( ) [EOL] [EOL] def _get_request_id_for ( self , data ) : [EOL] self . _msg_counter += [number] [EOL] return self . _msg_counter [EOL] [EOL] def _on_event_received ( self , data ) : [EOL] pass [EOL] [EOL] def _split_messages ( self , data ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $netutils.clients.base_client.BaseClient$ 0 $asyncio.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 $netutils.clients.base_client.BaseClient$ 0 $asyncio.AbstractEventLoop$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.bytes],builtins.bytes]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0
	0
from . config_data_context_factory import ConfigDataContextFactory [EOL] from . data_context import DataContext [EOL] from . data_context_factory import DataContextFactory [EOL] from . env_data_context_factory import EnvDataContextFactory [EOL] from . mongo_data_context import MongoDataContext [EOL] from . postgres_data_context import PostgresDataContext [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . data_contexts . data_context_factory import DataContextFactory [EOL] [EOL] [EOL] class ConfigDataContextFactory ( DataContextFactory ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config_file ) : [EOL] [docstring] [EOL] self . _config_file = config_file [EOL] [EOL] def create_data_context ( self ) : [EOL] [comment] [EOL] return NotImplementedError [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class ForeignKeyViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class SqlError ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
from . foreign_key_violation_error import ForeignKeyViolationError [EOL] from . no_data_found_error import NoDataFoundError [EOL] from . restrict_violation_error import RestrictViolationError [EOL] from . sql_error import SqlError [EOL] from . unique_violation_error import UniqueViolationError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class NoDataFoundError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class UniqueViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sqlutils . errors . sql_error import SqlError [EOL] [EOL] [EOL] class RestrictViolationError ( SqlError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from . base_blueprint import BaseBlueprint , return_one , return_many [EOL] from . request import Request [EOL] from . serializer import Serializer [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Tuple , Dict [EOL] import builtins [EOL] import src [EOL] import requests [EOL] import typing [EOL] import os [EOL] [EOL] import requests [EOL] from flask import json [EOL] from requests import Response [EOL] from typing import Dict , Any , Tuple [EOL] [EOL] [EOL] class Request ( object ) : [EOL] [EOL] proxies = { [string] : [string] } [EOL] headers = { } [EOL] [EOL] proxy = os . environ . get ( [string] ) [EOL] if proxy is not None : [EOL] proxies [ [string] ] = proxy [EOL] [EOL] authorization = os . environ . get ( [string] ) [EOL] if authorization is not None : [EOL] headers [ [string] ] = authorization [EOL] [EOL] @ staticmethod def get ( url ) : [EOL] return requests . get ( url , proxies = Request . proxies , headers = Request . headers ) [EOL] [EOL] @ staticmethod def post ( url , data = None , is_json = True , files = None ) : [EOL] headers , data = Request . _prepare_data ( data , is_json ) [EOL] return requests . post ( url , data = data , proxies = Request . proxies , headers = headers , files = files ) [EOL] [EOL] @ staticmethod def delete ( url ) : [EOL] return requests . delete ( url , proxies = Request . proxies , headers = Request . headers ) [EOL] [EOL] @ staticmethod def put ( url , data = None , is_json = True , files = None ) : [EOL] headers , data = Request . _prepare_data ( data , is_json ) [EOL] return requests . put ( url , data = data , proxies = Request . proxies , headers = headers , files = files ) [EOL] [EOL] @ staticmethod def patch ( url , data = None , is_json = True , files = None ) : [EOL] headers , data = Request . _prepare_data ( data , is_json ) [EOL] return requests . patch ( url , data = data , proxies = Request . proxies , headers = headers , files = files ) [EOL] [EOL] @ staticmethod def _prepare_data ( data , is_json ) : [EOL] headers = Request . headers . copy ( ) [EOL] if is_json : [EOL] headers [ [string] ] = [string] [EOL] data = json . dumps ( data ) [EOL] return headers , data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0
	0
import flask [EOL] from flask import Flask [EOL] from injector import inject , singleton [EOL] [EOL] from lingany_api . blueprints . category_blueprint import CategoryBlueprint [EOL] from lingany_api . blueprints . language_blueprint import LanguageBlueprint [EOL] from lingany_api . blueprints . reflection_blueprint import ReflectionBlueprint [EOL] from lingany_api . blueprints . training_blueprint import TrainingBlueprint [EOL] from lingany_api . blueprints . word_blueprint import WordBlueprint [EOL] from lingany_api . ioc import ioc [EOL] [EOL] [EOL] class Application ( object ) : [EOL] [EOL] @ inject def __init__ ( self ) : [EOL] self . _languages = ioc . get ( LanguageBlueprint , scope = singleton ) . blueprint [EOL] self . _reflection = ioc . get ( ReflectionBlueprint , scope = singleton ) . blueprint [EOL] self . _categories = ioc . get ( CategoryBlueprint , scope = singleton ) . blueprint [EOL] self . _training = ioc . get ( TrainingBlueprint , scope = singleton ) . blueprint [EOL] self . _word = ioc . get ( WordBlueprint , scope = singleton ) . blueprint [EOL] [EOL] def register ( self , app ) : [EOL] app . register_blueprint ( self . _languages , url_prefix = [string] ) [EOL] app . register_blueprint ( self . _reflection , url_prefix = [string] ) [EOL] app . register_blueprint ( self . _categories , url_prefix = [string] ) [EOL] app . register_blueprint ( self . _training , url_prefix = [string] ) [EOL] app . register_blueprint ( self . _word , url_prefix = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $flask.Flask$ 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from flask_caching import Cache [EOL] [EOL] cache = Cache ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from injector import Injector [EOL] [EOL] from lingany_api . configuration import Configuration [EOL] [EOL] ioc = Injector ( [ Configuration ( ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
import sqlutils [EOL] from injector import Module , singleton , provider [EOL] [EOL] from sqlutils import DataContext , EnvDataContextFactory [EOL] [EOL] [EOL] class Configuration ( Module ) : [EOL] @ singleton @ provider def provide_context ( self ) : [EOL] return EnvDataContextFactory ( ) . create_data_context ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlutils.DataContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import sqlutils [EOL] import lingany_api [EOL] import builtins [EOL] import typing [EOL] from injector import singleton , inject [EOL] from typing import Optional , List [EOL] from uuid import UUID [EOL] [EOL] from lingany_api . converters . reflection_converter import ReflectionConverter [EOL] from lingany_api . models . reflection import Reflection [EOL] from lingany_api . persistance . dto . reflection_dto import ReflectionDTO [EOL] from lingany_api . persistance . repositories . reflection_repository import ReflectionRepository [EOL] from sqlutils import AbstractExpandSet , Service [EOL] [EOL] [EOL] @ singleton class ReflectionService ( Service [ Reflection , ReflectionDTO , ReflectionRepository ] ) : [EOL] [EOL] @ inject def __init__ ( self , repo ) : [EOL] super ( ) . __init__ ( repo ) [EOL] self . _converter = ReflectionConverter ( ) [EOL] [EOL] def get_reflection_by_languages ( self , native_language_id , foreign_language_id , expand ) : [EOL] reflection_dto = self . _repo . get_reflection_by_languages ( native_language_id , foreign_language_id ) [EOL] return self . _convert ( reflection_dto , expand ) [EOL] [EOL] def _convert ( self , entity , expand ) : [EOL] if not entity : [EOL] return None [EOL] [EOL] reflection = self . _converter . convert ( entity ) [EOL] return reflection [EOL] [EOL] @ staticmethod def _clear_cache ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[lingany_api.models.reflection.Reflection]$ 0 0 0 $lingany_api.persistance.dto.reflection_dto.ReflectionDTO$ 0 $sqlutils.AbstractExpandSet$ 0 0 0 0 0 $lingany_api.persistance.dto.reflection_dto.ReflectionDTO$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $lingany_api.persistance.dto.reflection_dto.ReflectionDTO$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List , Optional [EOL] import sqlutils [EOL] import builtins [EOL] import lingany_api [EOL] import typing [EOL] from injector import singleton , inject [EOL] from typing import Optional , List [EOL] from uuid import UUID [EOL] [EOL] from lingany_api . converters . category_converter import CategoryConverter [EOL] from lingany_api . models . category import Category [EOL] from lingany_api . persistance . dto . category_dto import CategoryDTO [EOL] from lingany_api . persistance . repositories . category_repository import CategoryRepository [EOL] from sqlutils import AbstractExpandSet , Service [EOL] [EOL] [EOL] @ singleton class CategoryService ( Service [ Category , CategoryDTO , CategoryRepository ] ) : [EOL] [EOL] @ inject def __init__ ( self , repo ) : [EOL] super ( ) . __init__ ( repo ) [EOL] self . _converter = CategoryConverter ( ) [EOL] [EOL] def get_categories_for_reflection ( self , reflection_id , expand ) : [EOL] category_dto_list = self . _repo . get_categories_for_reflection ( reflection_id ) [EOL] return self . _convert_many ( category_dto_list , expand ) [EOL] [EOL] def _convert ( self , entity , expand ) : [EOL] if not entity : [EOL] return None [EOL] [EOL] category = self . _converter . convert ( entity ) [EOL] return category [EOL] [EOL] @ staticmethod def _clear_cache ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[lingany_api.models.category.Category]$ 0 0 0 0 0 $sqlutils.AbstractExpandSet$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Any , Dict , Optional [EOL] import builtins [EOL] import typing [EOL] import uuid [EOL] import sqlutils [EOL] import lingany_api [EOL] from typing import Optional , Dict , Any [EOL] from uuid import UUID [EOL] [EOL] from flask import url_for [EOL] [EOL] from apiutils import Serializer [EOL] from lingany_api . models . training import Training [EOL] from lingany_api . persistance . dto . training_dto import TrainingDTO [EOL] from lingany_api . serializers . category_serializer import CategorySerializer [EOL] from sqlutils import AbstractExpandSet [EOL] [EOL] [EOL] class TrainingSerializer ( Serializer ) : [EOL] [EOL] @ staticmethod def dump ( model , expand = None ) : [EOL] if not model : [EOL] return None [EOL] [EOL] data = { [string] : url_for ( [string] , uid = model . uid ) , [string] : model . uid , } [EOL] [EOL] if model . is_loaded : [EOL] data . update ( { [string] : CategorySerializer . dump ( model . category ) , [string] : None if model . native_word is None else model . native_word , [string] : None if model . foreign_word is None else model . foreign_word } ) [EOL] [EOL] return data [EOL] [EOL] @ staticmethod def load ( data ) : [EOL] training_id = None if data [ [string] ] is None or data [ [string] ] == [string] else UUID ( data [ [string] ] ) [EOL] category_id = data [ [string] ] [EOL] native_word = data [ [string] ] [EOL] foreign_word = data [ [string] ] [EOL] return TrainingDTO ( training_id , category_id , native_word , foreign_word ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lingany_api.persistance.dto.training_dto.TrainingDTO$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Optional[uuid.UUID]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Optional[uuid.UUID]$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0
	0
import builtins [EOL] import uuid [EOL] from uuid import UUID [EOL] [EOL] from sqlutils import Entity [EOL] [EOL] [EOL] class ReflectionDTO ( Entity ) : [EOL] [EOL] @ property def _key_field ( self ) : [EOL] return [string] [EOL] [EOL] def __init__ ( self , uid = None , title = None , native_language_id = None , foreign_language_id = None ) : [EOL] [EOL] super ( ) . __init__ ( uid ) [EOL] self . _title = title [EOL] self . _native_language_id = native_language_id [EOL] self . _foreign_language_id = foreign_language_id [EOL] [EOL] @ property def title ( self ) : [EOL] return self . _title [EOL] [EOL] @ property def native_language_id ( self ) : [EOL] return self . _native_language_id [EOL] [EOL] @ property def foreign_language_id ( self ) : [EOL] return self . _foreign_language_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] import uuid [EOL] from uuid import UUID [EOL] [EOL] from sqlutils import Entity [EOL] [EOL] [EOL] class TrainingDTO ( Entity ) : [EOL] [EOL] @ property def _key_field ( self ) : [EOL] return [string] [EOL] [EOL] def __init__ ( self , uid = None , category_id = None , native_word = None , foreign_word = None ) : [EOL] [EOL] super ( ) . __init__ ( uid ) [EOL] self . _category_id = category_id [EOL] self . _native_word = native_word [EOL] self . _foreign_word = foreign_word [EOL] [EOL] @ property def category_id ( self ) : [EOL] return self . _category_id [EOL] [EOL] @ property def native_word ( self ) : [EOL] return self . _native_word [EOL] [EOL] @ property def foreign_word ( self ) : [EOL] return self . _foreign_word [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import sqlutils [EOL] import builtins [EOL] import lingany_api [EOL] import typing [EOL] from uuid import UUID [EOL] [EOL] from injector import inject [EOL] from typing import Any , List [EOL] [EOL] from lingany_api . persistance . dto . training_dto import TrainingDTO [EOL] from sqlutils import Repository , DataContext , create_one , create_many [EOL] [EOL] [EOL] class TrainingRepository ( Repository [ TrainingDTO ] ) : [EOL] [EOL] @ inject def __init__ ( self , context ) : [EOL] self . _context = context [EOL] [EOL] def get_by_id ( self , uid ) : [EOL] data = self . _context . callproc ( [string] , [ uid ] ) [EOL] return create_one ( TrainingDTO , data ) [EOL] [EOL] def get_all_for_reflection ( self , reflection_id ) : [EOL] data = self . _context . callproc ( [string] , [ reflection_id ] ) [EOL] return create_many ( TrainingDTO , data ) [EOL] [EOL] def get_all ( self ) : [EOL] data = self . _context . callproc ( [string] , [ ] ) [EOL] return create_many ( TrainingDTO , data ) [EOL] [EOL] def get_trainings_for_category ( self , category_id ) : [EOL] data = self . _context . callproc ( [string] , [ category_id ] ) [EOL] return create_many ( TrainingDTO , data ) [EOL] [EOL] def add ( self , entity ) : [EOL] raise NotImplementedError [EOL] [EOL] def update ( self , entity ) : [EOL] raise NotImplementedError [EOL] [EOL] def delete ( self , uid ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $sqlutils.DataContext$ 0 0 0 0 0 0 0 $sqlutils.DataContext$ 0 0 0 $lingany_api.persistance.dto.training_dto.TrainingDTO$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[lingany_api.persistance.dto.training_dto.TrainingDTO]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[lingany_api.persistance.dto.training_dto.TrainingDTO]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[lingany_api.persistance.dto.training_dto.TrainingDTO]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $lingany_api.persistance.dto.training_dto.TrainingDTO$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import sqlutils [EOL] import builtins [EOL] import lingany_api [EOL] import typing [EOL] from injector import inject [EOL] from typing import Any , List [EOL] [EOL] from lingany_api . persistance . dto . reflection_dto import ReflectionDTO [EOL] from sqlutils import Repository , DataContext , create_one , create_many [EOL] [EOL] [EOL] class ReflectionRepository ( Repository [ ReflectionDTO ] ) : [EOL] [EOL] @ inject def __init__ ( self , context ) : [EOL] self . _context = context [EOL] [EOL] def get_by_id ( self , uid ) : [EOL] data = self . _context . callproc ( [string] , [ uid ] ) [EOL] return create_one ( ReflectionDTO , data ) [EOL] [EOL] def get_all ( self ) : [EOL] data = self . _context . callproc ( [string] , [ ] ) [EOL] return create_many ( ReflectionDTO , data ) [EOL] [EOL] def get_reflection_by_languages ( self , native_language_id , foreign_language_id ) : [EOL] data = self . _context . callproc ( [string] , [ native_language_id , foreign_language_id ] ) [EOL] return create_one ( ReflectionDTO , data ) [EOL] [EOL] def add ( self , entity ) : [EOL] raise NotImplementedError [EOL] [EOL] def update ( self , entity ) : [EOL] raise NotImplementedError [EOL] [EOL] def delete ( self , uid ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $sqlutils.DataContext$ 0 0 0 0 0 0 0 $sqlutils.DataContext$ 0 0 0 $lingany_api.persistance.dto.reflection_dto.ReflectionDTO$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[lingany_api.persistance.dto.reflection_dto.ReflectionDTO]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $lingany_api.persistance.dto.reflection_dto.ReflectionDTO$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $lingany_api.persistance.dto.reflection_dto.ReflectionDTO$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0
	0
import uuid [EOL] import lingany_api [EOL] import builtins [EOL] from uuid import UUID [EOL] [EOL] from lingany_api . models . reflection import Reflection [EOL] from sqlutils import Model [EOL] [EOL] [EOL] class Category ( Model ) : [EOL] [EOL] def __init__ ( self , uid ) : [EOL] super ( ) . __init__ ( uid ) [EOL] self . _reflection = None [EOL] self . _title = None [EOL] [EOL] @ property def title ( self ) : [EOL] return self . _title [EOL] [EOL] @ property def reflection ( self ) : [EOL] return self . _reflection [EOL] [EOL] def fill ( self , title , reflection ) : [EOL] self . _title = title [EOL] self . _reflection = reflection [EOL] self . _filled ( ) [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lingany_api.models.reflection.Reflection$ 0 0 0 0 0 0 0 0 0 0 0 0 $"Category"$ 0 0 0 $builtins.str$ 0 $lingany_api.models.reflection.Reflection$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $lingany_api.models.reflection.Reflection$ 0 0 0 0 0 0 0 0 0 0
import uuid [EOL] import lingany_api [EOL] import builtins [EOL] from uuid import UUID [EOL] [EOL] from lingany_api . models . category import Category [EOL] from sqlutils import Model [EOL] [EOL] [EOL] class Training ( Model ) : [EOL] [EOL] def __init__ ( self , uid ) : [EOL] super ( ) . __init__ ( uid ) [EOL] self . _category = None [EOL] self . _native_word = None [EOL] self . _foreign_word = None [EOL] [EOL] @ property def category ( self ) : [EOL] return self . _category [EOL] [EOL] @ property def native_word ( self ) : [EOL] return self . _native_word [EOL] [EOL] @ property def foreign_word ( self ) : [EOL] return self . _foreign_word [EOL] [EOL] def fill ( self , category , native_word , foreign_word ) : [EOL] self . _category = category [EOL] self . _native_word = native_word [EOL] self . _foreign_word = foreign_word [EOL] self . _filled ( ) [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lingany_api.models.category.Category$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $"Training"$ 0 0 0 $lingany_api.models.category.Category$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $lingany_api.models.category.Category$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
import uuid [EOL] import lingany_api [EOL] import builtins [EOL] from uuid import UUID [EOL] [EOL] from lingany_api . models . language import Language [EOL] from sqlutils import Model [EOL] [EOL] [EOL] class Reflection ( Model ) : [EOL] [EOL] def __init__ ( self , uid ) : [EOL] super ( ) . __init__ ( uid ) [EOL] self . _title = None [EOL] self . _native_language = None [EOL] self . _foreign_language = None [EOL] [EOL] @ property def title ( self ) : [EOL] return self . _title [EOL] [EOL] @ property def native_language ( self ) : [EOL] return self . _native_language [EOL] [EOL] @ property def foreign_language ( self ) : [EOL] return self . _foreign_language [EOL] [EOL] def fill ( self , title , native_language , foreign_language ) : [EOL] self . _title = title [EOL] self . _native_language = native_language [EOL] self . _foreign_language = foreign_language [EOL] self . _filled ( ) [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lingany_api.models.language.Language$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lingany_api.models.language.Language$ 0 0 0 0 0 0 0 0 0 0 0 0 $"Reflection"$ 0 0 0 $builtins.str$ 0 $lingany_api.models.language.Language$ 0 $lingany_api.models.language.Language$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $lingany_api.models.language.Language$ 0 0 0 0 0 $lingany_api.models.language.Language$ 0 0 0 0 0 0 0 0 0 0
import lingany_api [EOL] from lingany_api . models . word import Word [EOL] from lingany_api . persistance . dto . word_dto import WordDTO [EOL] from sqlutils import Converter [EOL] [EOL] [EOL] class WordConverter ( Converter [ Word , WordDTO ] ) : [EOL] [EOL] def convert ( self , entity ) : [EOL] return Word ( uid = entity . uid ) . fill ( text = entity . text , translation = entity . translation ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import lingany_api [EOL] from lingany_api . models . category import Category [EOL] from lingany_api . models . training import Training [EOL] from lingany_api . persistance . dto . training_dto import TrainingDTO [EOL] from sqlutils import Converter [EOL] [EOL] [EOL] class TrainingConverter ( Converter [ Training , TrainingDTO ] ) : [EOL] [EOL] def convert ( self , entity ) : [EOL] return Training ( uid = entity . uid ) . fill ( category = Category ( entity . category_id ) , native_word = entity . native_word , foreign_word = entity . foreign_word ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lingany_api.models.training.Training$ 0 0 0 $lingany_api.persistance.dto.training_dto.TrainingDTO$ 0 0 0 0 0 0 0 0 $lingany_api.persistance.dto.training_dto.TrainingDTO$ 0 0 0 0 0 0 0 0 0 0 $lingany_api.persistance.dto.training_dto.TrainingDTO$ 0 0 0 0 0 0 $lingany_api.persistance.dto.training_dto.TrainingDTO$ 0 0 0 0 0 $lingany_api.persistance.dto.training_dto.TrainingDTO$ 0 0 0 0
	0
import lingany_api [EOL] from lingany_api . models . category import Category [EOL] from lingany_api . models . reflection import Reflection [EOL] from lingany_api . persistance . dto . category_dto import CategoryDTO [EOL] from sqlutils import Converter [EOL] [EOL] [EOL] class CategoryConverter ( Converter [ Category , CategoryDTO ] ) : [EOL] [EOL] def convert ( self , entity ) : [EOL] return Category ( uid = entity . uid ) . fill ( title = entity . title , reflection = Reflection ( entity . reflection_id ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lingany_api.models.category.Category$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import builtins [EOL] import flask [EOL] import typing [EOL] import lingany_api [EOL] from uuid import UUID [EOL] [EOL] from flask import Blueprint , request [EOL] from injector import singleton , inject [EOL] [EOL] from apiutils import BaseBlueprint [EOL] from lingany_api . serializers . category_serializer import CategorySerializer [EOL] from lingany_api . services . category_service import CategoryService [EOL] from sqlutils import ExpandSet [EOL] [EOL] [EOL] @ singleton class CategoryBlueprint ( BaseBlueprint [ CategoryService ] ) : [EOL] [EOL] @ inject def __init__ ( self , service ) : [EOL] super ( ) . __init__ ( service ) [EOL] [EOL] @ property def _name ( self ) : [EOL] return [string] [EOL] [EOL] @ property def _serializer ( self ) : [EOL] return CategorySerializer ( ) [EOL] [EOL] def _create_blueprint ( self ) : [EOL] blueprint = Blueprint ( self . _name , __name__ ) [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def _get_by_id ( uid ) : [EOL] expand = ExpandSet . load ( request . args . get ( [string] ) ) [EOL] return self . _get_by_id ( UUID ( uid ) , expand ) [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def _get_all ( ) : [EOL] expand = ExpandSet . load ( request . args . get ( [string] ) ) [EOL] return self . _get_all ( expand ) [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def _get_categories_for_reflection ( uid ) : [EOL] expand = ExpandSet . load ( request . args . get ( [string] ) ) [EOL] models = self . _service . get_categories_for_reflection ( uid , expand = expand ) [EOL] return self . _return_many ( models ) [EOL] [EOL] return blueprint [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Blueprint$ 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $flask.blueprints.Blueprint$ 0
from typing import Any [EOL] import flask [EOL] import builtins [EOL] import lingany_api [EOL] import typing [EOL] from uuid import UUID [EOL] [EOL] from flask import Blueprint , request [EOL] from injector import singleton , inject [EOL] [EOL] from apiutils import BaseBlueprint [EOL] from lingany_api . serializers . training_serializer import TrainingSerializer [EOL] from lingany_api . services . training_service import TrainingService [EOL] from sqlutils import ExpandSet [EOL] [EOL] [EOL] @ singleton class TrainingBlueprint ( BaseBlueprint [ TrainingService ] ) : [EOL] [EOL] @ inject def __init__ ( self , service ) : [EOL] super ( ) . __init__ ( service ) [EOL] [EOL] @ property def _name ( self ) : [EOL] return [string] [EOL] [EOL] @ property def _serializer ( self ) : [EOL] return TrainingSerializer ( ) [EOL] [EOL] def _create_blueprint ( self ) : [EOL] blueprint = Blueprint ( self . _name , __name__ ) [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def _get_by_id ( uid ) : [EOL] expand = ExpandSet . load ( request . args . get ( [string] ) ) [EOL] return self . _get_by_id ( UUID ( uid ) , expand ) [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def _get_all ( ) : [EOL] expand = ExpandSet . load ( request . args . get ( [string] ) ) [EOL] return self . _get_all ( expand ) [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def _get_trainings_for_category ( uid ) : [EOL] expand = ExpandSet . load ( request . args . get ( [string] ) ) [EOL] models = self . _service . get_trainings_for_category ( uid , expand = expand ) [EOL] return self . _return_many ( models ) [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def _get_shape_for_reflection ( uid ) : [EOL] models = self . _service . get_shape_for_reflection ( uid ) [EOL] return self . _return_many ( models ) [EOL] [EOL] return blueprint [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $lingany_api.serializers.training_serializer.TrainingSerializer$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Blueprint$ 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $flask.blueprints.Blueprint$ 0
from typing import Any [EOL] import flask [EOL] import lingany_api [EOL] import builtins [EOL] import typing [EOL] from uuid import UUID [EOL] [EOL] from flask import Blueprint , request [EOL] from injector import singleton , inject [EOL] [EOL] from apiutils import BaseBlueprint [EOL] from lingany_api . serializers . language_serializer import LanguageSerializer [EOL] from lingany_api . services . language_service import LanguageService [EOL] from sqlutils import ExpandSet [EOL] [EOL] [EOL] @ singleton class LanguageBlueprint ( BaseBlueprint [ LanguageService ] ) : [EOL] [EOL] @ inject def __init__ ( self , service ) : [EOL] super ( ) . __init__ ( service ) [EOL] [EOL] @ property def _name ( self ) : [EOL] return [string] [EOL] [EOL] @ property def _serializer ( self ) : [EOL] return LanguageSerializer ( ) [EOL] [EOL] def _create_blueprint ( self ) : [EOL] blueprint = Blueprint ( self . _name , __name__ ) [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def _get_by_id ( uid ) : [EOL] expand = ExpandSet . load ( request . args . get ( [string] ) ) [EOL] return self . _get_by_id ( UUID ( uid ) , expand ) [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) def _get_all ( ) : [EOL] expand = ExpandSet . load ( request . args . get ( [string] ) ) [EOL] return self . _get_all ( expand ) [EOL] [EOL] return blueprint [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Blueprint$ 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $flask.blueprints.Blueprint$ 0