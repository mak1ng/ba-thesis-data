from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = open ( [string] ) . read ( ) , author = [string] , author_email = [string] , url = [string] , packages = [ [string] , [string] , [string] ] , entry_points = { [string] : [ [string] ] } , install_requires = [ [string] , [string] , [string] , [string] , [string] ] , license = [string] , keywords = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] import logging [EOL] import sys [EOL] from os . path import isfile [EOL] import logging [EOL] import asyncio [EOL] from asyncio . subprocess import create_subprocess_exec [EOL] [EOL] [EOL] def run ( task , debug = False ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] result = loop . run_until_complete ( task ) [EOL] return result [EOL] [EOL] [EOL] async def get_local_file_hash ( file_path ) : [EOL] [docstring] [EOL] if not isfile ( file_path ) : [EOL] raise FileNotFoundError ( [string] . format ( file_path ) ) [EOL] [EOL] subprocess = await create_subprocess_exec ( [string] , file_path , stdout = asyncio . subprocess . PIPE ) [EOL] [EOL] local_hash = await subprocess . stdout . read ( ) [EOL] return local_hash . split ( [string] , [number] ) [ [number] ] [EOL] [EOL] [EOL] def setup_logger ( level = None ) : [EOL] root_logger = logging . getLogger ( [string] ) [EOL] [EOL] if level : [EOL] root_logger . setLevel ( level ) [EOL] elif [string] in sys . argv : [EOL] root_logger . setLevel ( logging . DEBUG ) [EOL] elif [string] in sys . argv : [EOL] root_logger . setLevel ( logging . INFO ) [EOL] else : [EOL] root_logger . setLevel ( logging . WARNING ) [EOL] [EOL] [EOL] def format_collection_result ( result , level = [number] ) : [EOL] [docstring] [EOL] output = [string] . format ( [string] * level , result ) [EOL] try : [EOL] for r in result . result : [EOL] output += format_collection_result ( r , level = level + [number] ) [EOL] except TypeError : [EOL] pass [EOL] return output [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict , Tuple [EOL] import typing [EOL] import builtins [EOL] import okonf [EOL] import asyncio [EOL] from typing import Tuple [EOL] [EOL] from apistar import Command [EOL] from apistar . frameworks . asyncio import ASyncIOApp as App [EOL] [EOL] from okonf . facts . abstract import Fact [EOL] from okonf . utils import run , format_collection_result , setup_logger [EOL] [EOL] [EOL] def load_config ( file_path ) : [EOL] locals = { } [EOL] exec ( open ( file_path ) . read ( ) , locals ) [EOL] file_hosts = locals [ [string] ] [EOL] file_configs = locals [ [string] ] [EOL] return file_configs , file_hosts [EOL] [EOL] [EOL] def check ( file_path , host , debug = False , info = False ) : [EOL] setup_logger ( ) [EOL] [EOL] file_configs , file_hosts = load_config ( file_path ) [EOL] target_host = file_hosts [ host ] [EOL] target_config = file_configs [ host ] [EOL] [EOL] result = run ( target_config . check ( target_host ) ) [EOL] print ( format_collection_result ( result ) ) [EOL] [EOL] asyncio . get_event_loop ( ) . close ( ) [EOL] return { [string] : result } [EOL] [EOL] [EOL] def apply ( file_path , host , debug = False , info = False ) : [EOL] setup_logger ( ) [EOL] [EOL] file_configs , file_hosts = load_config ( file_path ) [EOL] target_host = file_hosts [ host ] [EOL] target_config = file_configs [ host ] [EOL] [EOL] result = run ( target_config . apply ( target_host ) ) [EOL] print ( format_collection_result ( result ) ) [EOL] [EOL] asyncio . get_event_loop ( ) . close ( ) [EOL] return { [string] : result } [EOL] [EOL] [EOL] commands = [ Command ( [string] , check ) , Command ( [string] , apply ) ] [EOL] [EOL] app = App ( commands = commands ) [EOL] [EOL] if __name__ == [string] : [EOL] app . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import okonf . connectors [EOL] import okonf . facts [EOL] import okonf . utils [EOL] from okonf . facts . multiple import Sequence , Collection [EOL] [EOL] assert Sequence [EOL] assert Collection [EOL] assert okonf . utils [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , Generator [EOL] import typing [EOL] import builtins [EOL] from typing import Iterable [EOL] [EOL] from okonf . facts . abstract import Fact [EOL] from okonf . facts . files import FilePresent [EOL] [EOL] [EOL] class Virtualenv ( Fact ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , python = [string] , site_packages = False , always_copy = False ) : [EOL] self . path = path [EOL] self . python = python [EOL] self . site_packages = site_packages [EOL] self . always_copy = always_copy [EOL] [EOL] async def check ( self , host ) : [EOL] path = [string] . format ( self . path ) [EOL] return await FilePresent ( path ) . check ( host ) [EOL] [EOL] async def enforce ( self , host ) : [EOL] command = [ [string] ] [EOL] [EOL] if self . python : [EOL] command . append ( [string] . format ( self . python ) ) [EOL] [EOL] if self . site_packages : [EOL] command . append ( [string] ) [EOL] [EOL] if self . always_copy : [EOL] command . append ( [string] ) [EOL] [EOL] command . append ( self . path ) [EOL] command = [string] . join ( command ) [EOL] [EOL] await host . run ( command ) [EOL] return True [EOL] [EOL] @ property def description ( self ) : [EOL] return self . path [EOL] [EOL] [EOL] class PipInstalled ( Fact ) : [EOL] [EOL] def __init__ ( self , packages , virtualenv = None , latest = False ) : [EOL] self . packages = packages [EOL] self . virtualenv = virtualenv [EOL] self . latest = latest [EOL] [EOL] async def info ( self , host ) : [EOL] if self . virtualenv : [EOL] if not await Virtualenv ( self . virtualenv ) . check ( host ) : [EOL] return { } [EOL] command = [string] . format ( self . virtualenv ) [EOL] else : [EOL] command = [string] [EOL] output = await host . run ( command ) [EOL] lines = ( line . split ( [string] , [number] ) for line in output . strip ( ) . split ( [string] ) ) [EOL] return { key . lower ( ) : value for key , value in lines } [EOL] [EOL] async def enquire ( self , host ) : [EOL] installed = await self . info ( host ) [EOL] for pkg in self . packages : [EOL] if [string] in pkg : [EOL] [comment] [EOL] pkg , version = pkg . split ( [string] ) [EOL] if version != installed . get ( pkg . lower ( ) , False ) : [EOL] return False [EOL] else : [EOL] [comment] [EOL] if pkg . lower ( ) not in installed : [EOL] return False [EOL] return True [EOL] [EOL] async def enforce ( self , host ) : [EOL] if self . virtualenv : [EOL] pip = [string] . format ( self . virtualenv ) [EOL] else : [EOL] pip = [string] [EOL] [EOL] command = [string] . format ( pip , [string] . join ( self . packages ) ) [EOL] await host . run ( command ) [EOL] return True [EOL] [EOL] @ property def description ( self ) : [EOL] return str ( [string] . format ( [string] . join ( self . packages ) , self . virtualenv ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[builtins.str]$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 $typing.Iterable[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from os . path import join [EOL] from hashlib import sha256 [EOL] from tempfile import NamedTemporaryFile [EOL] [EOL] from okonf import Collection , Sequence [EOL] from okonf . connectors . exceptions import NoSuchFileError [EOL] from okonf . facts . abstract import Fact [EOL] from okonf . utils import get_local_file_hash [EOL] [EOL] [EOL] class FilePresent ( Fact ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , remote_path ) : [EOL] self . remote_path = remote_path [EOL] [EOL] async def enquire ( self , host ) : [EOL] command = [string] . format ( self . remote_path ) [EOL] return await host . run ( command , check = False ) != [string] [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . run ( [string] . format ( self . remote_path ) ) [EOL] return True [EOL] [EOL] [EOL] class FileAbsent ( FilePresent ) : [EOL] [docstring] [EOL] [EOL] async def enquire ( self , host ) : [EOL] return not await FilePresent . enquire ( self , host ) [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . run ( [string] . format ( self . remote_path ) ) [EOL] return True [EOL] [EOL] [EOL] class FileHash ( Fact ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , remote_path , hash ) : [EOL] self . remote_path = remote_path [EOL] self . hash = hash [EOL] [EOL] async def get_hash ( self , host ) : [EOL] try : [EOL] output = await host . run ( [string] . format ( self . remote_path ) , no_such_file = True ) [EOL] except (NoSuchFileError) : [EOL] return False [EOL] return output . split ( [string] , [number] ) [ [number] ] . encode ( ) [EOL] [EOL] async def enquire ( self , host ) : [EOL] remote_hash = await self . get_hash ( host ) [EOL] return remote_hash == self . hash [EOL] [EOL] async def enforce ( self , host ) : [EOL] raise NotImplemented [EOL] [EOL] [EOL] class FileCopy ( Fact ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , remote_path , local_path , remote_hash = None ) : [EOL] [docstring] [EOL] self . remote_path = remote_path [EOL] self . local_path = local_path [EOL] self . remote_hash = remote_hash [EOL] [EOL] async def enquire ( self , host ) : [EOL] local_hash = await get_local_file_hash ( self . local_path ) [EOL] if self . remote_hash : [EOL] return local_hash == self . remote_hash [EOL] else : [EOL] return await FileHash ( self . remote_path , local_hash ) . enquire ( host ) [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . put ( self . remote_path , self . local_path ) [EOL] return True [EOL] [EOL] @ property def description ( self ) : [EOL] return str ( self . remote_path ) [EOL] [EOL] [EOL] class FileContent ( Fact ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , remote_path , content ) : [EOL] self . remote_path = remote_path [EOL] self . content = content [EOL] [EOL] async def check ( self , host ) : [EOL] content_hash = sha256 ( self . content ) . hexdigest ( ) . encode ( ) [EOL] return await FileHash ( self . remote_path , content_hash ) . check ( host ) [EOL] [EOL] async def enforce ( self , host ) : [EOL] with NamedTemporaryFile ( ) as tmpfile : [EOL] tmpfile . write ( self . content ) [EOL] tmpfile . seek ( [number] ) [EOL] await host . put ( self . remote_path , tmpfile . name ) [EOL] return True [EOL] [EOL] [EOL] class DirectoryPresent ( Fact ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , remote_path ) : [EOL] self . remote_path = remote_path [EOL] [EOL] async def enquire ( self , host ) : [EOL] command = [string] . format ( self . remote_path ) [EOL] return await host . run ( command , check = False ) != [string] [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . run ( [string] . format ( self . remote_path ) ) [EOL] return True [EOL] [EOL] @ property def description ( self ) : [EOL] return str ( self . remote_path ) [EOL] [EOL] [EOL] class DirectoryAbsent ( DirectoryPresent ) : [EOL] [docstring] [EOL] [EOL] async def enquire ( self , host ) : [EOL] return not await DirectoryPresent . enquire ( self , host ) [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . run ( [string] . format ( self . remote_path ) ) [EOL] return True [EOL] [EOL] [EOL] class DirectoryCopy ( Fact ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , remote_path , local_path , delete = False ) : [EOL] self . remote_path = remote_path [EOL] self . local_path = local_path [EOL] self . delete = delete [EOL] [EOL] async def info_files_hash ( self , host ) : [EOL] try : [EOL] command = [string] % self . remote_path [EOL] output = await host . run ( command , no_such_file = True ) [EOL] result = { } [EOL] for line in output . strip ( ) . split ( [string] ) : [EOL] if not line : [EOL] continue [EOL] hash , path = line . split ( ) [EOL] result [ path ] = hash [EOL] return result [EOL] except NoSuchFileError as error : [EOL] return { } [EOL] [EOL] async def info_dirs_present ( self , host ) : [EOL] try : [EOL] command = [string] . format ( self . remote_path ) [EOL] output = await host . run ( command , no_such_file = True ) [EOL] result = output . strip ( ) . split ( [string] ) [EOL] return result if result != [ [string] ] else [ ] [EOL] except NoSuchFileError as error : [EOL] return [ ] [EOL] [EOL] def _get_remote_path ( self , local_path ) : [EOL] assert local_path . startswith ( self . local_path ) [EOL] rel_path = local_path [ len ( self . local_path ) : ] . strip ( [string] ) [EOL] return join ( self . remote_path , rel_path ) [EOL] [EOL] def _get_local_path ( self , remote_path ) : [EOL] assert remote_path . startswith ( self . remote_path ) [EOL] rel_path = remote_path [ len ( self . remote_path ) : ] . strip ( [string] ) [EOL] return join ( self . local_path , rel_path ) [EOL] [EOL] async def subfacts ( self , host ) : [EOL] [docstring] [EOL] [EOL] dirs_to_create = [ ] [EOL] files_to_copy = [ ] [EOL] dirs_to_remove = [ ] [EOL] files_to_remove = [ ] [EOL] [EOL] existing_files = await self . info_files_hash ( host ) [EOL] [EOL] for root , dirs , files in os . walk ( self . local_path ) : [EOL] remote_root = self . _get_remote_path ( root ) [EOL] [EOL] for dirname in dirs : [EOL] dirs_to_create . append ( DirectoryPresent ( join ( remote_root , dirname ) ) ) [EOL] [EOL] for filename in files : [EOL] remote_path = join ( remote_root , filename ) [EOL] files_to_copy . append ( FileCopy ( remote_path , join ( root , filename ) , remote_hash = existing_files . get ( remote_path ) ) ) [EOL] [EOL] if self . delete : [EOL] for filepath in existing_files : [EOL] local_path = self . _get_local_path ( filepath ) [EOL] if not os . path . isfile ( local_path ) : [EOL] files_to_remove . append ( FileAbsent ( filepath ) ) [EOL] [EOL] existing_dirs = await self . info_dirs_present ( host ) [EOL] for dirname in existing_dirs : [EOL] local_path = self . _get_local_path ( dirname ) [EOL] if not os . path . isdir ( local_path ) : [EOL] dirs_to_remove . append ( DirectoryAbsent ( dirname ) ) [EOL] else : [EOL] files_to_remove = [ ] [EOL] dirs_to_remove = [ ] [EOL] [EOL] return Collection ( ( Sequence ( ( Collection ( dirs_to_create ) , Collection ( files_to_copy ) , ) ) , Sequence ( ( Collection ( files_to_remove ) , Collection ( dirs_to_remove ) , ) ) , ) ) [EOL] [EOL] async def check ( self , host ) : [EOL] facts = await self . subfacts ( host ) [EOL] return await facts . check ( host ) [EOL] [EOL] async def apply ( self , host ) : [EOL] facts = await self . subfacts ( host ) [EOL] return await facts . apply ( host ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import List , Any , Tuple [EOL] import typing [EOL] import asyncio [EOL] [EOL] from okonf . facts . abstract import Fact , FactCheck , FactResult [EOL] [EOL] [EOL] class Collection ( Fact ) : [EOL] [docstring] [EOL] def __init__ ( self , facts ) : [EOL] self . facts = list ( facts ) [EOL] [EOL] async def check ( self , host ) : [EOL] [docstring] [EOL] result = await asyncio . gather ( * ( step . check ( host ) for step in self . facts ) ) [EOL] return FactCheck ( self , result ) [EOL] [EOL] async def apply ( self , host ) : [EOL] result = await asyncio . gather ( * ( step . apply ( host ) for step in self . facts ) ) [EOL] return FactResult ( self , result ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] if isinstance ( other , Sequence ) : [EOL] return Sequence ( [ self , other ] ) [EOL] elif isinstance ( other , Collection ) : [EOL] return Collection ( self . facts + other . facts ) [EOL] else : [EOL] raise TypeError ( [string] , type ( other ) ) [EOL] [EOL] @ property def description ( self ) : [EOL] return [string] . format ( str ( len ( self . facts ) ) ) [EOL] [EOL] [EOL] class Sequence ( Collection ) : [EOL] [docstring] [EOL] async def apply ( self , host ) : [EOL] result = [ ] [EOL] for step in self . facts : [EOL] result . append ( await step . apply ( host ) ) [EOL] return FactResult ( self , result ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] if isinstance ( other , Sequence ) : [EOL] return Sequence ( self . facts + other . facts ) [EOL] elif isinstance ( other , Collection ) : [EOL] return Sequence ( [ self , other ] ) [EOL] else : [EOL] raise TypeError ( [string] , type ( other ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Any [EOL] import typing [EOL] import builtins [EOL] import okonf [EOL] import logging [EOL] [EOL] from collections import Iterable [EOL] from typing import List , Union [EOL] [EOL] import colorama [EOL] from abc import abstractmethod [EOL] from colorama import Fore [EOL] [EOL] [EOL] def all_true ( iterable ) : [EOL] [docstring] [EOL] for element in iterable : [EOL] if isinstance ( element , Iterable ) : [EOL] if not all_true ( element ) : [EOL] return False [EOL] elif not element : [EOL] return False [EOL] else : [EOL] pass [EOL] return True [EOL] [EOL] [EOL] def any_true ( iterable ) : [EOL] [docstring] [EOL] for element in iterable : [EOL] if isinstance ( element , Iterable ) : [EOL] if not any_true ( element ) : [EOL] return True [EOL] elif element : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] class FactCheck : [EOL] [EOL] def __init__ ( self , fact , result ) : [EOL] assert isinstance ( result , bool ) or isinstance ( result , list ) [EOL] self . fact = fact [EOL] self . result = result [EOL] [EOL] def __bool__ ( self ) : [EOL] if isinstance ( self . result , bool ) : [EOL] return self . result [EOL] else : [EOL] return all_true ( self . result ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . result == other [EOL] [EOL] def __repr__ ( self ) : [EOL] if bool ( self ) : [EOL] return [string] . format ( Fore . GREEN , [string] , Fore . WHITE , self . fact ) [EOL] else : [EOL] return [string] . format ( Fore . RED , [string] , Fore . WHITE , self . fact ) [EOL] [EOL] [EOL] class FactResult : [EOL] [EOL] def __init__ ( self , fact , result ) : [EOL] assert isinstance ( result , bool ) or isinstance ( result , list ) [EOL] self . fact = fact [EOL] self . result = result [EOL] [EOL] def __bool__ ( self ) : [EOL] if isinstance ( self . result , bool ) : [EOL] return self . result [EOL] else : [EOL] return any_true ( self . result ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . result == other [EOL] [EOL] def __repr__ ( self ) : [EOL] if bool ( self ) : [EOL] return [string] . format ( Fore . GREEN , [string] , Fore . WHITE , self . fact ) [EOL] else : [EOL] return [string] . format ( Fore . MAGENTA , [string] , Fore . WHITE , self . fact ) [EOL] [EOL] [EOL] class Fact : [EOL] @ abstractmethod async def enquire ( self , host ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ abstractmethod async def enforce ( self , host ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] async def check ( self , host ) : [EOL] result = FactCheck ( self , await self . enquire ( host ) ) [EOL] logging . info ( str ( result ) ) [EOL] return result [EOL] [EOL] async def apply ( self , host ) : [EOL] [docstring] [EOL] if not await self . check ( host ) : [EOL] result = FactResult ( self , await self . enforce ( host ) ) [EOL] else : [EOL] result = FactResult ( self , False ) [EOL] logging . info ( str ( result ) ) [EOL] return result [EOL] [EOL] @ property def description ( self ) : [EOL] return str ( self . __dict__ ) [EOL] [EOL] def __str__ ( self ) : [EOL] arguments = ( colorama . Fore . CYAN + str ( self . description ) + colorama . Style . RESET_ALL ) [EOL] return [string] . join ( ( self . __class__ . __name__ , arguments ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . __class__ . __name__ , self . description ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $okonf.facts.abstract.Fact$ 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 0 0 0 0 0 $okonf.facts.abstract.Fact$ 0 $okonf.facts.abstract.Fact$ 0 0 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $okonf.facts.abstract.Fact$ 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 0 0 0 0 0 $okonf.facts.abstract.Fact$ 0 $okonf.facts.abstract.Fact$ 0 0 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 $typing.Union[typing.List[typing.Any],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FactCheck$ 0 0 0 0 0 0 0 $okonf.facts.abstract.FactCheck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $okonf.facts.abstract.FactCheck$ 0 0 0 0 $okonf.facts.abstract.FactCheck$ 0 0 0 0 $FactResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $okonf.facts.abstract.FactResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $okonf.facts.abstract.FactResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $okonf.facts.abstract.FactResult$ 0 0 0 0 $okonf.facts.abstract.FactResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Match , Any [EOL] import typing [EOL] import re [EOL] from okonf . facts . abstract import Fact [EOL] [EOL] RE_UPGRADEABLE = [string] [string] [EOL] [EOL] [EOL] def parse_upgradeable ( lines ) : [EOL] for line in lines : [EOL] match = re . match ( RE_UPGRADEABLE , line ) [EOL] if match : [EOL] name , source , next_version , arch , version = match . groups ( ) [EOL] yield name , { [string] : source , [string] : next_version , [string] : arch , [string] : version , } [EOL] [EOL] [EOL] class AptPresent ( Fact ) : [EOL] [EOL] def __init__ ( self , name , sudo = True ) : [EOL] self . name = name [EOL] self . sudo = sudo [EOL] [EOL] async def enquire ( self , host ) : [EOL] status = await host . run ( [string] . format ( self . name ) , check = False ) [EOL] for line in status . split ( [string] ) : [EOL] if re . match ( [string] . format ( self . name ) , line ) : [EOL] return True [EOL] return False [EOL] [EOL] async def enforce ( self , host ) : [EOL] if self . sudo : [EOL] await host . run ( [string] . format ( self . name ) ) [EOL] else : [EOL] await host . run ( [string] . format ( self . name ) ) [EOL] return True [EOL] [EOL] @ property def description ( self ) : [EOL] return str ( self . name ) [EOL] [EOL] [EOL] class AptUpdated ( Fact ) : [EOL] [EOL] def __init__ ( self , names = tuple ( ) ) : [EOL] self . names = names [EOL] [EOL] async def enquire ( self , host ) : [EOL] return False [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . run ( [string] ) [EOL] return True [EOL] [EOL] [EOL] class AptUpgraded ( Fact ) : [EOL] [EOL] def __init__ ( self , names = tuple ( ) ) : [EOL] self . names = names [EOL] [EOL] async def info ( self , host ) : [EOL] names_str = [string] . join ( self . names ) [EOL] status = await host . run ( [string] . format ( names_str ) ) [EOL] [EOL] if status . startswith ( [string] ) : [EOL] status = status [ len ( [string] ) : ] [EOL] [EOL] return { name : values for name , values in parse_upgradeable ( status . split ( [string] ) ) } [EOL] [EOL] async def enquire ( self , host ) : [EOL] upgradeable = await self . info ( host ) [EOL] return len ( upgradeable ) == [number] [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . run ( [string] ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] from okonf . facts . abstract import Fact [EOL] [EOL] [EOL] class GroupMember ( Fact ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , username , group ) : [EOL] self . username = username [EOL] self . group = group [EOL] [EOL] async def info ( self , host ) : [EOL] command = [string] . format ( self . username ) [EOL] result = await host . run ( command , check = False ) [EOL] [EOL] prefix = [string] . format ( self . username ) [EOL] assert result . startswith ( prefix ) [EOL] return result [ len ( prefix ) : ] . split ( ) [EOL] [EOL] async def enquire ( self , host ) : [EOL] info = await self . info ( host ) [EOL] return self . group in info [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . run ( [string] . format ( self . username , self . group ) ) [EOL] return True [EOL] [EOL] @ property def description ( self ) : [EOL] return str ( [string] . format ( self . username , self . group ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] [EOL] from okonf . facts . abstract import Fact [EOL] from okonf . facts . files import DirectoryPresent [EOL] [EOL] [EOL] class GitClone ( Fact ) : [EOL] [EOL] def __init__ ( self , repository , directory , branch = None ) : [EOL] self . repository = repository [EOL] self . directory = directory [EOL] self . branch = branch [EOL] [EOL] async def get_branch ( self , host ) : [EOL] if not await DirectoryPresent ( self . directory ) . check ( host ) : [EOL] logging . debug ( [string] . format ( self . directory ) ) [EOL] return False [EOL] command = [string] . format ( self . directory ) [EOL] branch_name = await host . run ( command ) [EOL] return branch_name . strip ( ) [EOL] [EOL] async def enquire ( self , host ) : [EOL] branch = await self . get_branch ( host ) [EOL] if branch and not self . branch : [EOL] return True [EOL] else : [EOL] return branch == self . branch [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . run ( [string] . format ( self . repository , self . directory ) ) [EOL] return True [EOL] [EOL] @ property def description ( self ) : [EOL] return str ( self . directory ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] import json [EOL] [EOL] from okonf . facts . abstract import Fact [EOL] [EOL] [EOL] class Container ( Fact ) : [EOL] [EOL] def __init__ ( self , name , image = [string] ) : [EOL] self . name = name [EOL] self . image = image [EOL] [EOL] async def info ( self , host ) : [EOL] command = [string] [EOL] result = json . loads ( await host . run ( command ) ) [EOL] existing = [ container for container in result if container [ [string] ] == self . name ] [EOL] return existing [ [number] ] if existing else None [EOL] [EOL] async def enquire ( self , host ) : [EOL] existing = await self . info ( host ) [EOL] return existing is not None [EOL] [EOL] async def enforce ( self , host ) : [EOL] await host . run ( [string] . format ( self . image , self . name ) ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] class ShellError ( Exception ) : [EOL] [EOL] def __init__ ( self , exit_code , stdout = None , stderr = None ) : [EOL] self . exit_code = exit_code [EOL] self . stdout = stdout [EOL] self . stderr = stderr [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . exit_code , self . stderr , self . stdout ) [EOL] [EOL] [EOL] class NoSuchFileError ( ShellError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import io [EOL] import logging [EOL] import asyncio [EOL] [EOL] from pylxd import Client [EOL] [EOL] from okonf . connectors . exceptions import NoSuchFileError , ShellError [EOL] [EOL] [EOL] class LXDHost : [EOL] def __init__ ( self , name ) : [EOL] self . _client = Client ( ) [EOL] self . _container = self . _client . containers . get ( name ) [EOL] [EOL] async def run ( self , command , check = True , no_such_file = False ) : [EOL] logging . info ( [string] , self . _container . name , command ) [EOL] [EOL] command = command . split ( [string] ) [EOL] [EOL] result = await asyncio . get_event_loop ( ) . run_in_executor ( None , self . _container . execute , command ) [EOL] [EOL] if check and result . exit_code != [number] : [EOL] if no_such_file and result . stderr . endswith ( [string] ) : [EOL] raise NoSuchFileError ( result . exit_code , stdout = result . stdout , stderr = result . stderr ) [EOL] else : [EOL] raise ShellError ( result . exit_code , stdout = result . stdout , stderr = result . stderr ) [EOL] return result . stdout [EOL] [EOL] async def put ( self , path , local_path ) : [EOL] if path . startswith ( [string] ) : [EOL] path = [string] + path [ [number] : ] [EOL] content = open ( local_path , [string] ) [EOL] result = self . _container . files . put ( path , content ) [EOL] print ( [string] , result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $io.BufferedReader$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $io.BufferedReader$ 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import asyncssh [EOL] [EOL] from okonf . connectors . exceptions import NoSuchFileError , ShellError [EOL] [EOL] [EOL] class SSHHost : [EOL] [EOL] def __init__ ( self , ** kwargs ) : [EOL] self . ssh_settings = kwargs [EOL] [EOL] async def run ( self , command , check = True , no_such_file = False ) : [EOL] host , username = self . ssh_settings [ [string] ] , self . ssh_settings [ [string] ] [EOL] logging . info ( [string] , username , host , command ) [EOL] [EOL] async with asyncssh . connect ( ** self . ssh_settings ) as ssh : [EOL] result = await ssh . run ( command , check = False ) [EOL] [EOL] if no_such_file and result . exit_status != [number] : [EOL] if result . stderr . endswith ( [string] ) : [EOL] raise NoSuchFileError ( result . exit_status , stdout = result . stdout , stderr = result . stderr ) [EOL] [EOL] if check and result . exit_status != [number] : [EOL] raise ShellError ( result . exit_status , stdout = result . stdout , stderr = result . stderr ) [EOL] [EOL] logging . debug ( [string] , result . stdout ) [EOL] return result . stdout [EOL] [EOL] async def put ( self , path , local_path ) : [EOL] host = self . ssh_settings [ [string] ] [EOL] if path . startswith ( [string] ) : [EOL] username = self . ssh_settings [ [string] ] [EOL] if username == [string] : [EOL] path = [string] . format ( path [ [number] : ] ) [EOL] else : [EOL] path = [string] . format ( username , path [ [number] : ] ) [EOL] [EOL] logging . info ( [string] , local_path , host , path ) [EOL] async with asyncssh . connect ( ** self . ssh_settings ) as ssh : [EOL] async with ssh . start_sftp_client ( ) as sftp : [EOL] await sftp . put ( local_path , path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from . local import LocalHost [EOL] from . ssh import SSHHost [EOL] from . lxd import LXDHost [EOL] [EOL] assert SSHHost [EOL] assert LXDHost [EOL] assert LocalHost [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] import asyncio [EOL] [EOL] import colorama [EOL] from os . path import expanduser [EOL] from shutil import copyfile [EOL] [EOL] from okonf . connectors . exceptions import NoSuchFileError , ShellError [EOL] [EOL] [EOL] class LocalHost : [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] async def run ( self , command , check = True , no_such_file = False ) : [EOL] logging . debug ( [string] + colorama . Fore . YELLOW + [string] , command ) [EOL] colorama . reinit ( ) [EOL] [EOL] process = await asyncio . create_subprocess_shell ( cmd = command , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE ) [EOL] [EOL] logging . debug ( [string] , [ process . returncode ] ) [EOL] [EOL] if no_such_file and process . returncode not in ( None , [number] , [string] ) : [EOL] stderr = await process . stderr . read ( ) [EOL] if stderr . endswith ( [string] ) : [EOL] raise NoSuchFileError ( process . returncode , stdout = await process . stdout . read ( ) , stderr = stderr ) [EOL] [EOL] if check and process . returncode not in ( None , [number] , [string] ) : [EOL] raise ShellError ( process . returncode , stdout = await process . stdout . read ( ) , stderr = await process . stderr . read ( ) ) [EOL] [EOL] result = await process . stdout . read ( ) [EOL] logging . debug ( [string] , result ) [EOL] logging . debug ( [string] , await process . stderr . read ( ) ) [EOL] return result . decode ( ) [EOL] [EOL] async def put ( self , path , local_path ) : [EOL] path = expanduser ( path ) [EOL] copyfile ( local_path , path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 0 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $asyncio.subprocess.Process$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $asyncio.subprocess.Process$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $asyncio.subprocess.Process$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0
	0
import os [EOL] import pytest [EOL] from hashlib import sha256 [EOL] [EOL] from okonf . utils import get_local_file_hash [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_local_file_hash ( ) : [EOL] filepath = [string] [EOL] content = [string] [EOL] content_hash = sha256 ( content ) . hexdigest ( ) . encode ( ) [EOL] [EOL] try : [EOL] with open ( filepath , [string] ) as f : [EOL] f . write ( content ) [EOL] file_hash = await get_local_file_hash ( filepath ) [EOL] assert file_hash == content_hash [EOL] finally : [EOL] os . remove ( filepath ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import okonf [EOL] import os [EOL] import pytest [EOL] from shutil import copyfile [EOL] [EOL] from okonf . connectors import SSHHost [EOL] from okonf . facts . files import FilePresent , FileContent [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_FilePresent ( ) : [EOL] host = SSHHost ( host = [string] , username = [string] ) [EOL] [EOL] os . system ( [string] ) [EOL] os . mkdir ( [string] ) [EOL] os . system ( [string] ) [EOL] os . system ( [string] ) [EOL] copyfile ( [string] , [string] ) [EOL] [EOL] assert await FilePresent ( [string] ) . check ( host ) [EOL] [EOL] filename = [string] [EOL] assert not os . path . isfile ( filename ) [EOL] assert not await FilePresent ( filename ) . check ( host ) [EOL] [EOL] try : [EOL] assert await FilePresent ( filename ) . apply ( host ) [EOL] assert os . path . isfile ( filename ) [EOL] assert await FilePresent ( filename ) . check ( host ) [EOL] finally : [EOL] os . remove ( filename ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_SSHHost_put ( ) : [EOL] host = SSHHost ( host = [string] , username = [string] ) [EOL] [EOL] os . system ( [string] ) [EOL] os . makedirs ( [string] , exist_ok = True ) [EOL] if not await FilePresent ( [string] ) . check ( host ) : [EOL] os . system ( [string] ) [EOL] os . system ( [string] ) [EOL] copyfile ( [string] , [string] ) [EOL] [EOL] assert await FilePresent ( [string] ) . check ( host ) [EOL] [EOL] filename1 = [string] [EOL] filename2 = [string] [EOL] filepath2 = [string] [EOL] [EOL] assert filepath2 == [string] + filename2 [ [number] : ] [EOL] [EOL] fact1 = FileContent ( filename1 , [string] ) [EOL] fact2 = FileContent ( filename2 , [string] ) [EOL] [EOL] assert not os . path . isfile ( filename1 ) [EOL] assert not os . path . isfile ( filename2 ) [EOL] assert not await fact1 . check ( host ) [EOL] assert not await fact2 . check ( host ) [EOL] [EOL] try : [EOL] assert await fact1 . apply ( host ) [EOL] assert await fact2 . apply ( host ) [EOL] assert os . path . isfile ( filename1 ) [EOL] assert os . path . isfile ( filepath2 ) [EOL] assert await fact1 . check ( host ) [EOL] assert await fact2 . check ( host ) [EOL] finally : [EOL] os . remove ( filename1 ) [EOL] os . remove ( filepath2 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import okonf [EOL] import pytest [EOL] [EOL] from okonf . connectors import LocalHost [EOL] from okonf . facts . apt import AptPresent [EOL] from okonf . facts . git import GitClone [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_GitClone ( ) : [EOL] host = LocalHost ( ) [EOL] repository = [string] [EOL] directory = [string] [EOL] [EOL] await AptPresent ( [string] ) . apply ( host ) [EOL] [EOL] assert not await GitClone ( repository , directory ) . check ( host ) [EOL] assert await GitClone ( repository , directory ) . apply ( host ) [EOL] assert await GitClone ( repository , directory ) . check ( host ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import okonf [EOL] import os . path [EOL] import pytest [EOL] [EOL] from okonf . connectors import LocalHost [EOL] from okonf . facts . apt import AptPresent [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_AptPresent ( ) : [EOL] host = LocalHost ( ) [EOL] assert await AptPresent ( [string] ) . check ( host ) [EOL] assert not await AptPresent ( [string] ) . check ( host ) [EOL] assert not os . path . isfile ( [string] ) [EOL] assert await AptPresent ( [string] ) . apply ( host ) [EOL] assert os . path . isfile ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import okonf [EOL] import os [EOL] import pytest [EOL] from shutil import rmtree [EOL] [EOL] from okonf . connectors import LocalHost [EOL] from okonf . facts . files import FilePresent , FileAbsent , FileHash , FileCopy , FileContent , DirectoryPresent , DirectoryAbsent , DirectoryCopy [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_FilePresent ( ) : [EOL] host = LocalHost ( ) [EOL] assert await FilePresent ( [string] ) . check ( host ) [EOL] [EOL] filename = [string] [EOL] assert not os . path . isfile ( filename ) [EOL] assert not await FilePresent ( filename ) . check ( host ) [EOL] [EOL] try : [EOL] assert await FilePresent ( filename ) . apply ( host ) [EOL] assert os . path . isfile ( filename ) [EOL] assert await FilePresent ( filename ) . check ( host ) [EOL] finally : [EOL] os . remove ( filename ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_FileAbsent ( ) : [EOL] host = LocalHost ( ) [EOL] filename = [string] [EOL] assert await FileAbsent ( filename ) . check ( host ) [EOL] open ( filename , [string] ) . write ( [string] ) [EOL] assert not await FileAbsent ( filename ) . check ( host ) [EOL] assert await FileAbsent ( filename ) . apply ( host ) [EOL] assert not os . path . isfile ( filename ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_FileHash ( ) : [EOL] host = LocalHost ( ) [EOL] filename = [string] [EOL] expected_hash = [string] [string] [EOL] [EOL] assert not os . path . isfile ( filename ) [EOL] assert not await FileHash ( filename , [string] ) . check ( host ) [EOL] try : [EOL] open ( filename , [string] ) . write ( [string] ) [EOL] assert await FileHash ( filename , [string] ) . get_hash ( host ) == expected_hash [EOL] assert await FileHash ( filename , expected_hash ) . check ( host ) [EOL] finally : [EOL] os . remove ( filename ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_FileCopy ( ) : [EOL] host = LocalHost ( ) [EOL] remote_path = [string] [EOL] local_path = [string] [EOL] [EOL] assert not os . path . isfile ( remote_path ) [EOL] assert not await FileCopy ( remote_path , local_path ) . check ( host ) [EOL] try : [EOL] assert await FileCopy ( remote_path , local_path ) . apply ( host ) [EOL] assert open ( local_path , [string] ) . read ( ) == open ( remote_path , [string] ) . read ( ) [EOL] finally : [EOL] os . remove ( remote_path ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_FileContent ( ) : [EOL] host = LocalHost ( ) [EOL] remote_path = [string] [EOL] content = [string] [EOL] [EOL] assert not os . path . isfile ( remote_path ) [EOL] assert not await FileContent ( remote_path , content ) . check ( host ) [EOL] try : [EOL] assert await FileContent ( remote_path , content ) . apply ( host ) [EOL] assert open ( remote_path , [string] ) . read ( ) == content [EOL] finally : [EOL] os . remove ( remote_path ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_DirectoryPresent ( ) : [EOL] host = LocalHost ( ) [EOL] assert await DirectoryPresent ( [string] ) . check ( host ) [EOL] [EOL] remote_path = [string] [EOL] assert not os . path . isdir ( remote_path ) [EOL] assert not await DirectoryPresent ( remote_path ) . check ( host ) [EOL] [EOL] try : [EOL] assert await DirectoryPresent ( remote_path ) . apply ( host ) [EOL] assert os . path . isdir ( remote_path ) [EOL] assert await DirectoryPresent ( remote_path ) . check ( host ) [EOL] finally : [EOL] os . rmdir ( remote_path ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_DirectoryAbsent ( ) : [EOL] host = LocalHost ( ) [EOL] remote_path = [string] [EOL] assert await DirectoryAbsent ( remote_path ) . check ( host ) [EOL] try : [EOL] os . makedirs ( remote_path ) [EOL] assert not await DirectoryAbsent ( remote_path ) . check ( host ) [EOL] assert await DirectoryAbsent ( remote_path ) . apply ( host ) [EOL] finally : [EOL] assert not os . path . isdir ( remote_path ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_DirectoryCopy ( ) : [EOL] host = LocalHost ( ) [EOL] local_path = [string] [EOL] remote_path = [string] [EOL] [EOL] [comment] [EOL] assert not await DirectoryCopy ( remote_path , local_path ) . check ( host ) [EOL] try : [EOL] result = await DirectoryCopy ( remote_path , local_path ) . apply ( host ) [EOL] assert len ( result . result ) == [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert not await DirectoryCopy ( remote_path , local_path ) . check ( host ) [EOL] finally : [EOL] rmtree ( remote_path ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_DirectoryCopyDelete ( ) : [EOL] host = LocalHost ( ) [EOL] local_path = [string] [EOL] remote_path = [string] [EOL] [EOL] [comment] [EOL] assert not await DirectoryCopy ( remote_path , local_path , delete = True ) . check ( host ) [EOL] try : [EOL] result = await DirectoryCopy ( remote_path , local_path , delete = True ) . apply ( host ) [EOL] assert len ( result . result ) == [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert not await DirectoryCopy ( remote_path , local_path , delete = True ) . check ( host ) [EOL] finally : [EOL] rmtree ( remote_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import okonf [EOL] import os . path [EOL] import pytest [EOL] [EOL] from okonf . connectors import LocalHost [EOL] from okonf . facts . python import Virtualenv , PipInstalled [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_Virtualenv ( ) : [EOL] host = LocalHost ( ) [EOL] path = [string] [EOL] [EOL] assert not os . path . exists ( path ) [EOL] assert not await Virtualenv ( path ) . check ( host ) [EOL] [EOL] assert await Virtualenv ( path ) . apply ( host ) [EOL] assert os . path . isdir ( path ) [EOL] assert await Virtualenv ( path ) . check ( host ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_PipInstalled ( ) : [EOL] host = LocalHost ( ) [EOL] packages = [ [string] ] [EOL] virtualenv = [string] [EOL] [EOL] await Virtualenv ( virtualenv ) . apply ( host ) [EOL] [EOL] assert not await PipInstalled ( packages , virtualenv ) . check ( host ) [EOL] [EOL] assert await PipInstalled ( packages , virtualenv ) . apply ( host ) [EOL] assert await PipInstalled ( packages , virtualenv ) . check ( host ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import okonf [EOL] import pytest [EOL] [EOL] from okonf . connectors import LocalHost [EOL] from okonf . facts . users import GroupMember [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_Virtualenv ( ) : [EOL] host = LocalHost ( ) [EOL] await host . run ( [string] ) [EOL] await host . run ( [string] ) [EOL] [EOL] assert not await GroupMember ( [string] , [string] ) . check ( host ) [EOL] assert await GroupMember ( [string] , [string] ) . apply ( host ) [EOL] assert await GroupMember ( [string] , [string] ) . check ( host ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0