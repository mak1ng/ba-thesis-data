[docstring] [EOL]	0 0
from typing import Type , List , Pattern , Dict , Any [EOL] import tests [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import asyncio [EOL] from contextlib import contextmanager [EOL] import json as _json [EOL] import re [EOL] from unittest import mock [EOL] from urllib . parse import parse_qs [EOL] [EOL] from aiohttp import ClientSession [EOL] from yarl import URL [EOL] [EOL] from aiohttp . client_exceptions import ClientResponseError [EOL] [EOL] retype = type ( re . compile ( [string] ) ) [EOL] [EOL] [EOL] class AiohttpClientMocker : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _mocks = [ ] [EOL] self . _cookies = { } [EOL] self . mock_calls = [ ] [EOL] [EOL] def request ( self , method , url , * , auth = None , status = [number] , text = None , data = None , content = None , json = None , params = None , headers = { } , exc = None , cookies = None ) : [EOL] [docstring] [EOL] if json is not None : [EOL] text = _json . dumps ( json ) [EOL] if text is not None : [EOL] content = text . encode ( [string] ) [EOL] if content is None : [EOL] content = [string] [EOL] [EOL] if not isinstance ( url , retype ) : [EOL] url = URL ( url ) [EOL] if params : [EOL] url = url . with_query ( params ) [EOL] [EOL] self . _mocks . append ( AiohttpClientMockResponse ( method , url , status , content , cookies , exc , headers ) ) [EOL] [EOL] def get ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . request ( [string] , * args , ** kwargs ) [EOL] [EOL] def put ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . request ( [string] , * args , ** kwargs ) [EOL] [EOL] def post ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . request ( [string] , * args , ** kwargs ) [EOL] [EOL] def delete ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . request ( [string] , * args , ** kwargs ) [EOL] [EOL] def options ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . request ( [string] , * args , ** kwargs ) [EOL] [EOL] @ property def call_count ( self ) : [EOL] [docstring] [EOL] return len ( self . mock_calls ) [EOL] [EOL] def clear_requests ( self ) : [EOL] [docstring] [EOL] self . _mocks . clear ( ) [EOL] self . _cookies . clear ( ) [EOL] self . mock_calls . clear ( ) [EOL] [EOL] def create_session ( self , loop ) : [EOL] [docstring] [EOL] session = ClientSession ( loop = loop ) [EOL] [comment] [EOL] object . __setattr__ ( session , [string] , self . match_request ) [EOL] return session [EOL] [EOL] async def match_request ( self , method , url , * , data = None , auth = None , params = None , headers = None , allow_redirects = None , timeout = None , json = None ) : [EOL] [docstring] [EOL] data = data or json [EOL] url = URL ( url ) [EOL] if params : [EOL] url = url . with_query ( params ) [EOL] [EOL] for response in self . _mocks : [EOL] if response . match_request ( method , url , params ) : [EOL] self . mock_calls . append ( ( method , url , data , headers ) ) [EOL] [EOL] if response . exc : [EOL] raise response . exc [EOL] return response [EOL] [EOL] assert False , [string] . format ( method . upper ( ) , url , params ) [EOL] [EOL] [EOL] class AiohttpClientMockResponse : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , method , url , status , response , cookies = None , exc = None , headers = None ) : [EOL] [docstring] [EOL] self . method = method [EOL] self . _url = url [EOL] self . status = status [EOL] self . response = response [EOL] self . exc = exc [EOL] [EOL] self . _headers = headers or { } [EOL] self . _cookies = { } [EOL] [EOL] if cookies : [EOL] for name , data in cookies . items ( ) : [EOL] cookie = mock . MagicMock ( ) [EOL] cookie . value = data [EOL] self . _cookies [ name ] = cookie [EOL] [EOL] if isinstance ( response , list ) : [EOL] self . content = mock . MagicMock ( ) [EOL] [EOL] @ asyncio . coroutine def read ( * argc , ** kwargs ) : [EOL] [docstring] [EOL] if self . response : [EOL] return self . response . pop ( ) [EOL] return None [EOL] [EOL] self . content . read = read [EOL] [EOL] def match_request ( self , method , url , params = None ) : [EOL] [docstring] [EOL] if method . lower ( ) != self . method . lower ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if isinstance ( self . _url , retype ) : [EOL] return self . _url . search ( str ( url ) ) is not None [EOL] [EOL] if ( self . _url . scheme != url . scheme or self . _url . host != url . host or self . _url . path != url . path ) : [EOL] return False [EOL] [EOL] [comment] [EOL] request_qs = parse_qs ( url . query_string ) [EOL] matcher_qs = parse_qs ( self . _url . query_string ) [EOL] for key , vals in matcher_qs . items ( ) : [EOL] for val in vals : [EOL] try : [EOL] request_qs . get ( key , [ ] ) . remove ( val ) [EOL] except ValueError : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] @ property def headers ( self ) : [EOL] [docstring] [EOL] return self . _headers [EOL] [EOL] @ property def cookies ( self ) : [EOL] [docstring] [EOL] return self . _cookies [EOL] [EOL] @ asyncio . coroutine def read ( self ) : [EOL] [docstring] [EOL] return self . response [EOL] [EOL] @ asyncio . coroutine def text ( self , encoding = [string] ) : [EOL] [docstring] [EOL] return self . response . decode ( encoding ) [EOL] [EOL] @ asyncio . coroutine def json ( self , encoding = [string] ) : [EOL] [docstring] [EOL] return _json . loads ( self . response . decode ( encoding ) ) [EOL] [EOL] @ asyncio . coroutine def release ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def raise_for_status ( self ) : [EOL] [docstring] [EOL] if self . status >= [number] : [EOL] raise ClientResponseError ( None , None , code = self . status , headers = self . headers ) [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] @ contextmanager def mock_aiohttp_client ( ) : [EOL] [docstring] [EOL] mocker = AiohttpClientMocker ( ) [EOL] [EOL] with mock . patch ( [string] , side_effect = lambda hass , * args : mocker . create_session ( hass . loop ) ) : [EOL] yield mocker [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[typing.Pattern[builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . setup import setup_component [EOL] import homeassistant . core as ha [EOL] import homeassistant . components . statsd as statsd [EOL] from homeassistant . const import ( STATE_ON , STATE_OFF , EVENT_STATE_CHANGED ) [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class TestStatsd ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_invalid_config ( self ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } } [EOL] [EOL] with self . assertRaises ( vol . Invalid ) : [EOL] statsd . CONFIG_SCHEMA ( None ) [EOL] with self . assertRaises ( vol . Invalid ) : [EOL] statsd . CONFIG_SCHEMA ( config ) [EOL] [EOL] @ mock . patch ( [string] ) def test_statsd_setup_full ( self , mock_connection ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , } } [EOL] self . hass . bus . listen = mock . MagicMock ( ) [EOL] self . assertTrue ( setup_component ( self . hass , statsd . DOMAIN , config ) ) [EOL] self . assertEqual ( mock_connection . call_count , [number] ) [EOL] self . assertEqual ( mock_connection . call_args , mock . call ( host = [string] , port = [number] , prefix = [string] ) ) [EOL] [EOL] self . assertTrue ( self . hass . bus . listen . called ) [EOL] self . assertEqual ( EVENT_STATE_CHANGED , self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_statsd_setup_defaults ( self , mock_connection ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } } [EOL] [EOL] config [ [string] ] [ statsd . CONF_PORT ] = statsd . DEFAULT_PORT [EOL] config [ [string] ] [ statsd . CONF_PREFIX ] = statsd . DEFAULT_PREFIX [EOL] [EOL] self . hass . bus . listen = mock . MagicMock ( ) [EOL] self . assertTrue ( setup_component ( self . hass , statsd . DOMAIN , config ) ) [EOL] self . assertEqual ( mock_connection . call_count , [number] ) [EOL] self . assertEqual ( mock_connection . call_args , mock . call ( host = [string] , port = [number] , prefix = [string] ) ) [EOL] self . assertTrue ( self . hass . bus . listen . called ) [EOL] [EOL] @ mock . patch ( [string] ) def test_event_listener_defaults ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : { [string] : [number] } } } [EOL] [EOL] config [ [string] ] [ statsd . CONF_RATE ] = statsd . DEFAULT_RATE [EOL] [EOL] self . hass . bus . listen = mock . MagicMock ( ) [EOL] setup_component ( self . hass , statsd . DOMAIN , config ) [EOL] self . assertTrue ( self . hass . bus . listen . called ) [EOL] handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] valid = { [string] : [number] , [string] : [number] , [string] : [number] , STATE_ON : [number] , STATE_OFF : [number] } [EOL] for in_ , out in valid . items ( ) : [EOL] state = mock . MagicMock ( state = in_ , attributes = { [string] : [number] } ) [EOL] handler_method ( mock . MagicMock ( data = { [string] : state } ) ) [EOL] mock_client . return_value . gauge . assert_has_calls ( [ mock . call ( state . entity_id , out , statsd . DEFAULT_RATE ) , ] ) [EOL] [EOL] mock_client . return_value . gauge . reset_mock ( ) [EOL] [EOL] self . assertEqual ( mock_client . return_value . incr . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . incr . call_args , mock . call ( state . entity_id , rate = statsd . DEFAULT_RATE ) ) [EOL] mock_client . return_value . incr . reset_mock ( ) [EOL] [EOL] for invalid in ( [string] , [string] , object ) : [EOL] handler_method ( mock . MagicMock ( data = { [string] : ha . State ( [string] , invalid , { } ) } ) ) [EOL] self . assertFalse ( mock_client . return_value . gauge . called ) [EOL] self . assertTrue ( mock_client . return_value . incr . called ) [EOL] [EOL] @ mock . patch ( [string] ) def test_event_listener_attr_details ( self , mock_client ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , [string] : True } } [EOL] [EOL] config [ [string] ] [ statsd . CONF_RATE ] = statsd . DEFAULT_RATE [EOL] [EOL] self . hass . bus . listen = mock . MagicMock ( ) [EOL] setup_component ( self . hass , statsd . DOMAIN , config ) [EOL] self . assertTrue ( self . hass . bus . listen . called ) [EOL] handler_method = self . hass . bus . listen . call_args_list [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] valid = { [string] : [number] , [string] : [number] , STATE_ON : [number] , STATE_OFF : [number] } [EOL] for in_ , out in valid . items ( ) : [EOL] state = mock . MagicMock ( state = in_ , attributes = { [string] : [number] } ) [EOL] handler_method ( mock . MagicMock ( data = { [string] : state } ) ) [EOL] mock_client . return_value . gauge . assert_has_calls ( [ mock . call ( [string] % state . entity_id , out , statsd . DEFAULT_RATE ) , mock . call ( [string] % state . entity_id , [number] , statsd . DEFAULT_RATE ) , ] ) [EOL] [EOL] mock_client . return_value . gauge . reset_mock ( ) [EOL] [EOL] self . assertEqual ( mock_client . return_value . incr . call_count , [number] ) [EOL] self . assertEqual ( mock_client . return_value . incr . call_args , mock . call ( state . entity_id , rate = statsd . DEFAULT_RATE ) ) [EOL] mock_client . return_value . incr . reset_mock ( ) [EOL] [EOL] for invalid in ( [string] , [string] , object ) : [EOL] handler_method ( mock . MagicMock ( data = { [string] : ha . State ( [string] , invalid , { } ) } ) ) [EOL] self . assertFalse ( mock_client . return_value . gauge . called ) [EOL] self . assertTrue ( mock_client . return_value . incr . called ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.float]$ 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.float]$ 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Generator , Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import pytest [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] import homeassistant . components . prometheus as prometheus [EOL] [EOL] [EOL] @ pytest . fixture def prometheus_client ( loop , hass , aiohttp_client ) : [EOL] [docstring] [EOL] assert loop . run_until_complete ( async_setup_component ( hass , prometheus . DOMAIN , { prometheus . DOMAIN : { } } , ) ) [EOL] return loop . run_until_complete ( aiohttp_client ( hass . http . app ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_view ( prometheus_client ) : [comment] [EOL] [docstring] [EOL] resp = yield from prometheus_client . get ( prometheus . API_ENDPOINT ) [EOL] [EOL] assert resp . status == [number] [EOL] assert resp . headers [ [string] ] == [string] [EOL] body = yield from resp . text ( ) [EOL] body = body . split ( [string] ) [EOL] [EOL] assert len ( body ) > [number] [comment] [EOL] for line in body : [EOL] if line : [EOL] assert line . startswith ( [string] ) or line . startswith ( [string] ) or line . startswith ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] import asyncio [EOL] import builtins [EOL] import unittest [EOL] [docstring] [EOL] import asyncio [EOL] import os [EOL] import tempfile [EOL] import unittest [EOL] from typing import Tuple [EOL] from unittest . mock import Mock , patch [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components import shell_command [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] @ asyncio . coroutine def mock_process_creator ( error = False ) : [EOL] [docstring] [EOL] @ asyncio . coroutine def communicate ( ) : [EOL] [docstring] [EOL] return [string] , [string] [EOL] [EOL] mock_process = Mock ( ) [EOL] mock_process . communicate = communicate [EOL] mock_process . returncode = int ( error ) [EOL] return mock_process [EOL] [EOL] [EOL] class TestShellCommand ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] asyncio . get_child_watcher ( ) . attach_loop ( self . hass . loop ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_executing_service ( self ) : [EOL] [docstring] [EOL] with tempfile . TemporaryDirectory ( ) as tempdirname : [EOL] path = os . path . join ( tempdirname , [string] ) [EOL] assert setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] . format ( path ) } } ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( os . path . isfile ( path ) ) [EOL] [EOL] def test_config_not_dict ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : [ [string] , [string] , [string] ] } ) ) [EOL] [EOL] def test_config_not_valid_service_names ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] } } ) ) [EOL] [EOL] @ patch ( [string] [string] ) def test_template_render_no_template ( self , mock_call ) : [EOL] [docstring] [EOL] mock_call . return_value = mock_process_creator ( error = False ) [EOL] [EOL] self . assertTrue ( setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] } } ) ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] cmd = mock_call . mock_calls [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] self . assertEqual ( [number] , mock_call . call_count ) [EOL] self . assertEqual ( [string] , cmd ) [EOL] [EOL] @ patch ( [string] [string] ) def test_template_render ( self , mock_call ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [string] ) [EOL] mock_call . return_value = mock_process_creator ( error = False ) [EOL] self . assertTrue ( setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : ( [string] [string] ) } } ) ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] cmd = mock_call . mock_calls [ [number] ] [ [number] ] [EOL] [EOL] self . assertEqual ( [number] , mock_call . call_count ) [EOL] self . assertEqual ( ( [string] , [string] , [string] ) , cmd ) [EOL] [EOL] @ patch ( [string] [string] ) @ patch ( [string] ) def test_subprocess_error ( self , mock_error , mock_call ) : [EOL] [docstring] [EOL] mock_call . return_value = mock_process_creator ( error = True ) [EOL] with tempfile . TemporaryDirectory ( ) as tempdirname : [EOL] path = os . path . join ( tempdirname , [string] ) [EOL] self . assertTrue ( setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] . format ( path ) } } ) ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , mock_call . call_count ) [EOL] self . assertEqual ( [number] , mock_error . call_count ) [EOL] self . assertFalse ( os . path . isfile ( path ) ) [EOL] [EOL] @ patch ( [string] ) def test_stdout_captured ( self , mock_output ) : [EOL] [docstring] [EOL] test_phrase = [string] [EOL] self . assertTrue ( setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] . format ( test_phrase ) } } ) ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , mock_output . call_count ) [EOL] self . assertEqual ( test_phrase . encode ( ) + [string] , mock_output . call_args_list [ [number] ] [ [number] ] [ - [number] ] ) [EOL] [EOL] @ patch ( [string] ) def test_stderr_captured ( self , mock_output ) : [EOL] [docstring] [EOL] test_phrase = [string] [EOL] self . assertTrue ( setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] . format ( test_phrase ) } } ) ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , mock_output . call_count ) [EOL] self . assertEqual ( test_phrase . encode ( ) + [string] , mock_output . call_args_list [ [number] ] [ [number] ] [ - [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Generator , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] from collections import OrderedDict [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import config_entries as core_ce [EOL] from homeassistant . config_entries import HANDLERS [EOL] from homeassistant . data_entry_flow import FlowHandler [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components . config import config_entries [EOL] from homeassistant . loader import set_component [EOL] [EOL] from tests . common import MockConfigEntry , MockModule , mock_coro_func [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def mock_test_component ( hass ) : [EOL] [docstring] [EOL] set_component ( hass , [string] , MockModule ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . fixture def client ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] hass . loop . run_until_complete ( async_setup_component ( hass , [string] , { } ) ) [EOL] hass . loop . run_until_complete ( config_entries . async_setup ( hass ) ) [EOL] yield hass . loop . run_until_complete ( aiohttp_client ( hass . http . app ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_entries ( hass , client ) : [EOL] [docstring] [EOL] MockConfigEntry ( domain = [string] , title = [string] , source = [string] ) . add_to_hass ( hass ) [EOL] MockConfigEntry ( domain = [string] , title = [string] , source = [string] , state = core_ce . ENTRY_STATE_LOADED , ) . add_to_hass ( hass ) [EOL] resp = yield from client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] for entry in data : [EOL] entry . pop ( [string] ) [EOL] assert data == [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_remove_entry ( hass , client ) : [EOL] [docstring] [EOL] entry = MockConfigEntry ( domain = [string] ) [EOL] entry . add_to_hass ( hass ) [EOL] resp = yield from client . delete ( [string] . format ( entry . entry_id ) ) [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] assert data == { [string] : True } [EOL] assert len ( hass . config_entries . async_entries ( ) ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_available_flows ( hass , client ) : [EOL] [docstring] [EOL] with patch . object ( core_ce , [string] , [ [string] , [string] ] ) : [EOL] resp = yield from client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] assert data == [ [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_initialize_flow ( hass , client ) : [EOL] [docstring] [EOL] class TestFlow ( FlowHandler ) : [EOL] @ asyncio . coroutine def async_step_init ( self , user_input = None ) : [EOL] schema = OrderedDict ( ) [EOL] schema [ vol . Required ( [string] ) ] = str [EOL] schema [ vol . Required ( [string] ) ] = str [EOL] [EOL] return self . async_show_form ( step_id = [string] , data_schema = schema , description_placeholders = { [string] : [string] , } , errors = { [string] : [string] } ) [EOL] [EOL] with patch . dict ( HANDLERS , { [string] : TestFlow } ) : [EOL] resp = yield from client . post ( [string] , json = { [string] : [string] } ) [EOL] [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] [EOL] data . pop ( [string] ) [EOL] [EOL] assert data == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : True , [string] : [string] } , { [string] : [string] , [string] : True , [string] : [string] } ] , [string] : { [string] : [string] , } , [string] : { [string] : [string] } } [EOL] [EOL] [EOL] @ asyncio . coroutine def test_abort ( hass , client ) : [EOL] [docstring] [EOL] class TestFlow ( FlowHandler ) : [EOL] @ asyncio . coroutine def async_step_init ( self , user_input = None ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] with patch . dict ( HANDLERS , { [string] : TestFlow } ) : [EOL] resp = yield from client . post ( [string] , json = { [string] : [string] } ) [EOL] [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] data . pop ( [string] ) [EOL] assert data == { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] @ asyncio . coroutine def test_create_account ( hass , client ) : [EOL] [docstring] [EOL] set_component ( hass , [string] , MockModule ( [string] , async_setup_entry = mock_coro_func ( True ) ) ) [EOL] [EOL] class TestFlow ( FlowHandler ) : [EOL] VERSION = [number] [EOL] [EOL] @ asyncio . coroutine def async_step_init ( self , user_input = None ) : [EOL] return self . async_create_entry ( title = [string] , data = { [string] : [string] } ) [EOL] [EOL] with patch . dict ( HANDLERS , { [string] : TestFlow } ) : [EOL] resp = yield from client . post ( [string] , json = { [string] : [string] } ) [EOL] [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] data . pop ( [string] ) [EOL] assert data == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] [EOL] [EOL] @ asyncio . coroutine def test_two_step_flow ( hass , client ) : [EOL] [docstring] [EOL] set_component ( hass , [string] , MockModule ( [string] , async_setup_entry = mock_coro_func ( True ) ) ) [EOL] [EOL] class TestFlow ( FlowHandler ) : [EOL] VERSION = [number] [EOL] [EOL] @ asyncio . coroutine def async_step_init ( self , user_input = None ) : [EOL] return self . async_show_form ( step_id = [string] , data_schema = vol . Schema ( { [string] : str } ) ) [EOL] [EOL] @ asyncio . coroutine def async_step_account ( self , user_input = None ) : [EOL] return self . async_create_entry ( title = user_input [ [string] ] , data = { [string] : [string] } ) [EOL] [EOL] with patch . dict ( HANDLERS , { [string] : TestFlow } ) : [EOL] resp = yield from client . post ( [string] , json = { [string] : [string] } ) [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] flow_id = data . pop ( [string] ) [EOL] assert data == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } ] , [string] : None , [string] : None } [EOL] [EOL] with patch . dict ( HANDLERS , { [string] : TestFlow } ) : [EOL] resp = yield from client . post ( [string] . format ( flow_id ) , json = { [string] : [string] } ) [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] data . pop ( [string] ) [EOL] assert data == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_progress_index ( hass , client ) : [EOL] [docstring] [EOL] class TestFlow ( FlowHandler ) : [EOL] VERSION = [number] [EOL] [EOL] @ asyncio . coroutine def async_step_hassio ( self , info ) : [EOL] return ( yield from self . async_step_account ( ) ) [EOL] [EOL] @ asyncio . coroutine def async_step_account ( self , user_input = None ) : [EOL] return self . async_show_form ( step_id = [string] , ) [EOL] [EOL] with patch . dict ( HANDLERS , { [string] : TestFlow } ) : [EOL] form = yield from hass . config_entries . flow . async_init ( [string] , source = [string] ) [EOL] [EOL] resp = yield from client . get ( [string] ) [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] assert data == [ { [string] : form [ [string] ] , [string] : [string] , [string] : [string] } ] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_progress_flow ( hass , client ) : [EOL] [docstring] [EOL] class TestFlow ( FlowHandler ) : [EOL] @ asyncio . coroutine def async_step_init ( self , user_input = None ) : [EOL] schema = OrderedDict ( ) [EOL] schema [ vol . Required ( [string] ) ] = str [EOL] schema [ vol . Required ( [string] ) ] = str [EOL] [EOL] return self . async_show_form ( step_id = [string] , data_schema = schema , errors = { [string] : [string] } ) [EOL] [EOL] with patch . dict ( HANDLERS , { [string] : TestFlow } ) : [EOL] resp = yield from client . post ( [string] , json = { [string] : [string] } ) [EOL] [EOL] assert resp . status == [number] [EOL] data = yield from resp . json ( ) [EOL] [EOL] resp2 = yield from client . get ( [string] . format ( data [ [string] ] ) ) [EOL] [EOL] assert resp2 . status == [number] [EOL] data2 = yield from resp2 . json ( ) [EOL] [EOL] assert data == data2 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] import unittest [EOL] from unittest . mock import MagicMock , patch [EOL] [EOL] from homeassistant . setup import setup_component [EOL] import homeassistant . components . notify as notify [EOL] from homeassistant . components . notify import group , demo [EOL] from homeassistant . util . async_ import run_coroutine_threadsafe [EOL] [EOL] from tests . common import assert_setup_component , get_test_home_assistant [EOL] [EOL] [EOL] class TestNotifyGroup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . events = [ ] [EOL] self . service1 = demo . DemoNotificationService ( self . hass ) [EOL] self . service2 = demo . DemoNotificationService ( self . hass ) [EOL] [EOL] self . service1 . send_message = MagicMock ( autospec = True ) [EOL] self . service2 . send_message = MagicMock ( autospec = True ) [EOL] [EOL] def mock_get_service ( hass , config , discovery_info = None ) : [EOL] if config [ [string] ] == [string] : [EOL] return self . service1 [EOL] return self . service2 [EOL] [EOL] with assert_setup_component ( [number] ) , patch . object ( demo , [string] , mock_get_service ) : [EOL] setup_component ( self . hass , notify . DOMAIN , { [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] } ) [EOL] [EOL] self . service = run_coroutine_threadsafe ( group . async_get_service ( self . hass , { [string] : [ { [string] : [string] } , { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] } } } ] } ) , self . hass . loop ) . result ( ) [EOL] [EOL] assert self . service is not None [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_send_message_with_data ( self ) : [EOL] [docstring] [EOL] run_coroutine_threadsafe ( self . service . async_send_message ( [string] , title = [string] , data = { [string] : [string] } ) , self . hass . loop ) . result ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . service1 . send_message . mock_calls [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert self . service1 . send_message . mock_calls [ [number] ] [ [number] ] == { [string] : [string] , [string] : { [string] : [string] } } [EOL] assert self . service2 . send_message . mock_calls [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert self . service2 . send_message . mock_calls [ [number] ] [ [number] ] == { [string] : [ [string] ] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , List , Union , Any [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] from copy import copy [EOL] import unittest [EOL] [EOL] from voluptuous . error import MultipleInvalid [EOL] [EOL] from homeassistant . const import ( STATE_OFF , STATE_ON , STATE_UNKNOWN , STATE_PLAYING , STATE_PAUSED ) [EOL] import homeassistant . components . switch as switch [EOL] import homeassistant . components . input_number as input_number [EOL] import homeassistant . components . input_select as input_select [EOL] import homeassistant . components . media_player as media_player [EOL] import homeassistant . components . media_player . universal as universal [EOL] from homeassistant . util . async_ import run_coroutine_threadsafe [EOL] [EOL] from tests . common import mock_service , get_test_home_assistant [EOL] [EOL] [EOL] def validate_config ( config ) : [EOL] [docstring] [EOL] validated_config = universal . PLATFORM_SCHEMA ( config ) [EOL] validated_config . pop ( [string] ) [EOL] return validated_config [EOL] [EOL] [EOL] class MockMediaPlayer ( media_player . MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _name = name [EOL] self . entity_id = media_player . ENTITY_ID_FORMAT . format ( name ) [EOL] self . _state = STATE_OFF [EOL] self . _volume_level = [number] [EOL] self . _is_volume_muted = False [EOL] self . _media_title = None [EOL] self . _supported_features = [number] [EOL] self . _source = None [EOL] self . _tracks = [number] [EOL] self . _media_image_url = None [EOL] self . _shuffle = False [EOL] [EOL] self . service_calls = { [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_TURN_ON ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_TURN_OFF ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_VOLUME_MUTE ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_VOLUME_SET ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_MEDIA_PLAY ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_MEDIA_PAUSE ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_MEDIA_PREVIOUS_TRACK ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_MEDIA_NEXT_TRACK ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_MEDIA_SEEK ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_PLAY_MEDIA ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_VOLUME_UP ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_VOLUME_DOWN ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_MEDIA_PLAY_PAUSE ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_SELECT_SOURCE ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_CLEAR_PLAYLIST ) , [string] : mock_service ( hass , media_player . DOMAIN , media_player . SERVICE_SHUFFLE_SET ) , } [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume_level [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _is_volume_muted [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported_features [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . _media_image_url [EOL] [EOL] @ property def shuffle ( self ) : [EOL] [docstring] [EOL] return self . _shuffle [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_UNKNOWN [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_OFF [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . _is_volume_muted = mute [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . _volume_level = volume [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_PAUSED [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] self . _source = source [EOL] [EOL] def clear_playlist ( self ) : [EOL] [docstring] [EOL] self . _tracks = [number] [EOL] [EOL] def set_shuffle ( self , shuffle ) : [EOL] [docstring] [EOL] self . _shuffle = shuffle [EOL] [EOL] [EOL] class TestMediaPlayer ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] self . mock_mp_1 = MockMediaPlayer ( self . hass , [string] ) [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] [EOL] self . mock_mp_2 = MockMediaPlayer ( self . hass , [string] ) [EOL] self . mock_mp_2 . schedule_update_ha_state ( ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_mute_switch_id = switch . ENTITY_ID_FORMAT . format ( [string] ) [EOL] self . hass . states . set ( self . mock_mute_switch_id , STATE_OFF ) [EOL] [EOL] self . mock_state_switch_id = switch . ENTITY_ID_FORMAT . format ( [string] ) [EOL] self . hass . states . set ( self . mock_state_switch_id , STATE_OFF ) [EOL] [EOL] self . mock_volume_id = input_number . ENTITY_ID_FORMAT . format ( [string] ) [EOL] self . hass . states . set ( self . mock_volume_id , [number] ) [EOL] [EOL] self . mock_source_list_id = input_select . ENTITY_ID_FORMAT . format ( [string] ) [EOL] self . hass . states . set ( self . mock_source_list_id , [ [string] , [string] ] ) [EOL] [EOL] self . mock_source_id = input_select . ENTITY_ID_FORMAT . format ( [string] ) [EOL] self . hass . states . set ( self . mock_source_id , [string] ) [EOL] [EOL] self . mock_shuffle_switch_id = switch . ENTITY_ID_FORMAT . format ( [string] ) [EOL] self . hass . states . set ( self . mock_shuffle_switch_id , STATE_OFF ) [EOL] [EOL] self . config_children_only = { [string] : [string] , [string] : [string] , [string] : [ media_player . ENTITY_ID_FORMAT . format ( [string] ) , media_player . ENTITY_ID_FORMAT . format ( [string] ) ] } [EOL] self . config_children_and_attr = { [string] : [string] , [string] : [string] , [string] : [ media_player . ENTITY_ID_FORMAT . format ( [string] ) , media_player . ENTITY_ID_FORMAT . format ( [string] ) ] , [string] : { [string] : self . mock_mute_switch_id , [string] : self . mock_volume_id , [string] : self . mock_source_id , [string] : self . mock_source_list_id , [string] : self . mock_state_switch_id , [string] : self . mock_shuffle_switch_id } } [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_config_children_only ( self ) : [EOL] [docstring] [EOL] config_start = copy ( self . config_children_only ) [EOL] del config_start [ [string] ] [EOL] config_start [ [string] ] = { } [EOL] config_start [ [string] ] = { } [EOL] [EOL] config = validate_config ( self . config_children_only ) [EOL] self . assertEqual ( config_start , config ) [EOL] [EOL] def test_config_children_and_attr ( self ) : [EOL] [docstring] [EOL] config_start = copy ( self . config_children_and_attr ) [EOL] del config_start [ [string] ] [EOL] config_start [ [string] ] = { } [EOL] [EOL] config = validate_config ( self . config_children_and_attr ) [EOL] self . assertEqual ( config_start , config ) [EOL] [EOL] def test_config_no_name ( self ) : [EOL] [docstring] [EOL] response = True [EOL] try : [EOL] validate_config ( { [string] : [string] } ) [EOL] except MultipleInvalid : [EOL] response = False [EOL] self . assertFalse ( response ) [EOL] [EOL] def test_config_bad_children ( self ) : [EOL] [docstring] [EOL] config_no_children = { [string] : [string] , [string] : [string] } [EOL] config_bad_children = { [string] : [string] , [string] : { } , [string] : [string] } [EOL] [EOL] config_no_children = validate_config ( config_no_children ) [EOL] self . assertEqual ( [ ] , config_no_children [ [string] ] ) [EOL] [EOL] config_bad_children = validate_config ( config_bad_children ) [EOL] self . assertEqual ( [ ] , config_bad_children [ [string] ] ) [EOL] [EOL] def test_config_bad_commands ( self ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] } [EOL] [EOL] config = validate_config ( config ) [EOL] self . assertEqual ( { } , config [ [string] ] ) [EOL] [EOL] def test_config_bad_attributes ( self ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] } [EOL] [EOL] config = validate_config ( config ) [EOL] self . assertEqual ( { } , config [ [string] ] ) [EOL] [EOL] def test_config_bad_key ( self ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [number] , [string] : [string] } [EOL] [EOL] config = validate_config ( config ) [EOL] self . assertFalse ( [string] in config ) [EOL] [EOL] def test_platform_setup ( self ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] } [EOL] bad_config = { [string] : [string] } [EOL] entities = [ ] [EOL] [EOL] def add_devices ( new_entities ) : [EOL] [docstring] [EOL] for dev in new_entities : [EOL] entities . append ( dev ) [EOL] [EOL] setup_ok = True [EOL] try : [EOL] run_coroutine_threadsafe ( universal . async_setup_platform ( self . hass , validate_config ( bad_config ) , add_devices ) , self . hass . loop ) . result ( ) [EOL] except MultipleInvalid : [EOL] setup_ok = False [EOL] self . assertFalse ( setup_ok ) [EOL] self . assertEqual ( [number] , len ( entities ) ) [EOL] [EOL] run_coroutine_threadsafe ( universal . async_setup_platform ( self . hass , validate_config ( config ) , add_devices ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( entities ) ) [EOL] self . assertEqual ( [string] , entities [ [number] ] . name ) [EOL] [EOL] def test_master_state ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertEqual ( None , ump . master_state ) [EOL] [EOL] def test_master_state_with_attrs ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_and_attr ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertEqual ( STATE_OFF , ump . master_state ) [EOL] self . hass . states . set ( self . mock_state_switch_id , STATE_ON ) [EOL] self . assertEqual ( STATE_ON , ump . master_state ) [EOL] [EOL] def test_master_state_with_template ( self ) : [EOL] [docstring] [EOL] config = copy ( self . config_children_and_attr ) [EOL] self . hass . states . set ( [string] , STATE_OFF ) [EOL] templ = [string] [string] [EOL] config [ [string] ] = templ [EOL] config = validate_config ( config ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertEqual ( STATE_ON , ump . master_state ) [EOL] self . hass . states . set ( [string] , STATE_ON ) [EOL] self . assertEqual ( STATE_OFF , ump . master_state ) [EOL] [EOL] def test_master_state_with_bad_attrs ( self ) : [EOL] [docstring] [EOL] config = copy ( self . config_children_and_attr ) [EOL] config [ [string] ] [ [string] ] = [string] [EOL] config = validate_config ( config ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertEqual ( STATE_OFF , ump . master_state ) [EOL] [EOL] def test_active_child_state ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . assertEqual ( None , ump . _child_state ) [EOL] [EOL] self . mock_mp_1 . _state = STATE_PLAYING [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( self . mock_mp_1 . entity_id , ump . _child_state . entity_id ) [EOL] [EOL] self . mock_mp_2 . _state = STATE_PLAYING [EOL] self . mock_mp_2 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( self . mock_mp_1 . entity_id , ump . _child_state . entity_id ) [EOL] [EOL] self . mock_mp_1 . _state = STATE_OFF [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( self . mock_mp_2 . entity_id , ump . _child_state . entity_id ) [EOL] [EOL] def test_name ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertEqual ( config [ [string] ] , ump . name ) [EOL] [EOL] def test_polling ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertEqual ( False , ump . should_poll ) [EOL] [EOL] def test_state_children_only ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . assertTrue ( ump . state , STATE_OFF ) [EOL] [EOL] self . mock_mp_1 . _state = STATE_PLAYING [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( STATE_PLAYING , ump . state ) [EOL] [EOL] def test_state_with_children_and_attrs ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_and_attr ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . assertEqual ( STATE_OFF , ump . state ) [EOL] [EOL] self . hass . states . set ( self . mock_state_switch_id , STATE_ON ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( STATE_ON , ump . state ) [EOL] [EOL] self . mock_mp_1 . _state = STATE_PLAYING [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( STATE_PLAYING , ump . state ) [EOL] [EOL] self . hass . states . set ( self . mock_state_switch_id , STATE_OFF ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( STATE_OFF , ump . state ) [EOL] [EOL] def test_volume_level ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . assertEqual ( None , ump . volume_level ) [EOL] [EOL] self . mock_mp_1 . _state = STATE_PLAYING [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , ump . volume_level ) [EOL] [EOL] self . mock_mp_1 . _volume_level = [number] [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , ump . volume_level ) [EOL] [EOL] def test_media_image_url ( self ) : [EOL] [docstring] [EOL] test_url = [string] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . assertEqual ( None , ump . media_image_url ) [EOL] [EOL] self . mock_mp_1 . _state = STATE_PLAYING [EOL] self . mock_mp_1 . _media_image_url = test_url [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( self . mock_mp_1 . entity_picture , ump . entity_picture ) [EOL] [EOL] def test_is_volume_muted_children_only ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . assertFalse ( ump . is_volume_muted ) [EOL] [EOL] self . mock_mp_1 . _state = STATE_PLAYING [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertFalse ( ump . is_volume_muted ) [EOL] [EOL] self . mock_mp_1 . _is_volume_muted = True [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertTrue ( ump . is_volume_muted ) [EOL] [EOL] def test_source_list_children_and_attr ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_and_attr ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertEqual ( [string] , ump . source_list ) [EOL] [EOL] self . hass . states . set ( self . mock_source_list_id , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( [string] , ump . source_list ) [EOL] [EOL] def test_source_children_and_attr ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_and_attr ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertEqual ( [string] , ump . source ) [EOL] [EOL] self . hass . states . set ( self . mock_source_id , [string] ) [EOL] self . assertEqual ( [string] , ump . source ) [EOL] [EOL] def test_volume_level_children_and_attr ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_and_attr ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertEqual ( [string] , ump . volume_level ) [EOL] [EOL] self . hass . states . set ( self . mock_volume_id , [number] ) [EOL] self . assertEqual ( [string] , ump . volume_level ) [EOL] [EOL] def test_is_volume_muted_children_and_attr ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_and_attr ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] [EOL] self . assertFalse ( ump . is_volume_muted ) [EOL] [EOL] self . hass . states . set ( self . mock_mute_switch_id , STATE_ON ) [EOL] self . assertTrue ( ump . is_volume_muted ) [EOL] [EOL] def test_supported_features_children_only ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . assertEqual ( [number] , ump . supported_features ) [EOL] [EOL] self . mock_mp_1 . _supported_features = [number] [EOL] self . mock_mp_1 . _state = STATE_PLAYING [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , ump . supported_features ) [EOL] [EOL] def test_supported_features_children_and_cmds ( self ) : [EOL] [docstring] [EOL] config = copy ( self . config_children_and_attr ) [EOL] excmd = { [string] : [string] , [string] : { [string] : [string] } } [EOL] config [ [string] ] = { [string] : excmd , [string] : excmd , [string] : excmd , [string] : excmd , [string] : excmd , [string] : excmd , [string] : excmd , [string] : excmd } [EOL] config = validate_config ( config ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . mock_mp_1 . _state = STATE_PLAYING [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] check_flags = universal . SUPPORT_TURN_ON | universal . SUPPORT_TURN_OFF | universal . SUPPORT_VOLUME_STEP | universal . SUPPORT_VOLUME_MUTE | universal . SUPPORT_SELECT_SOURCE | universal . SUPPORT_SHUFFLE_SET [EOL] [EOL] self . assertEqual ( check_flags , ump . supported_features ) [EOL] [EOL] def test_service_call_no_active_child ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_and_attr ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . mock_mp_1 . _state = STATE_OFF [EOL] self . mock_mp_1 . schedule_update_ha_state ( ) [EOL] self . mock_mp_2 . _state = STATE_OFF [EOL] self . mock_mp_2 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_turn_off ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_1 . service_calls [ [string] ] ) ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] def test_service_call_to_child ( self ) : [EOL] [docstring] [EOL] config = validate_config ( self . config_children_only ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . mock_mp_2 . _state = STATE_PLAYING [EOL] self . mock_mp_2 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_turn_off ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_turn_on ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_mute_volume ( True ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_set_volume_level ( [number] ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_media_play ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_media_pause ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_media_previous_track ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_media_next_track ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_media_seek ( [number] ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_play_media ( [string] , [string] ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_volume_up ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_volume_down ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_media_play_pause ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_select_source ( [string] ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_clear_playlist ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_set_shuffle ( True ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( self . mock_mp_2 . service_calls [ [string] ] ) ) [EOL] [EOL] def test_service_call_to_command ( self ) : [EOL] [docstring] [EOL] config = copy ( self . config_children_only ) [EOL] config [ [string] ] = { [string] : { [string] : [string] , [string] : { } } } [EOL] config = validate_config ( config ) [EOL] [EOL] service = mock_service ( self . hass , [string] , [string] ) [EOL] [EOL] ump = universal . UniversalMediaPlayer ( self . hass , ** config ) [EOL] ump . entity_id = media_player . ENTITY_ID_FORMAT . format ( config [ [string] ] ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] self . mock_mp_2 . _state = STATE_PLAYING [EOL] self . mock_mp_2 . schedule_update_ha_state ( ) [EOL] self . hass . block_till_done ( ) [EOL] run_coroutine_threadsafe ( ump . async_update ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] run_coroutine_threadsafe ( ump . async_turn_off ( ) , self . hass . loop ) . result ( ) [EOL] self . assertEqual ( [number] , len ( service ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.media_player.test_universal.MockMediaPlayer$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.media_player.test_universal.MockMediaPlayer$ 0 0 0 0 0 0 0 0 $tests.components.media_player.test_universal.MockMediaPlayer$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.media_player.test_universal.MockMediaPlayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , List , Union , Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import requests [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] from nx584 import client as nx584_client [EOL] [EOL] from homeassistant . components . binary_sensor import nx584 [EOL] from homeassistant . setup import setup_component [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class StopMe ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class TestNX584SensorSetup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . _mock_client = mock . patch . object ( nx584_client , [string] ) [EOL] self . _mock_client . start ( ) [EOL] [EOL] self . fake_zones = [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , ] [EOL] [EOL] client = nx584_client . Client . return_value [EOL] client . list_zones . return_value = self . fake_zones [EOL] client . get_version . return_value = [string] [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] self . _mock_client . stop ( ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_setup_defaults ( self , mock_nx , mock_watcher ) : [EOL] [docstring] [EOL] add_devices = mock . MagicMock ( ) [EOL] config = { [string] : nx584 . DEFAULT_HOST , [string] : nx584 . DEFAULT_PORT , [string] : [ ] , [string] : { } , } [EOL] self . assertTrue ( nx584 . setup_platform ( self . hass , config , add_devices ) ) [EOL] mock_nx . assert_has_calls ( [ mock . call ( zone , [string] ) for zone in self . fake_zones ] ) [EOL] self . assertTrue ( add_devices . called ) [EOL] self . assertEqual ( nx584_client . Client . call_count , [number] ) [EOL] self . assertEqual ( nx584_client . Client . call_args , mock . call ( [string] ) ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_setup_full_config ( self , mock_nx , mock_watcher ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [number] , [string] : [ [number] ] , [string] : { [number] : [string] } , } [EOL] add_devices = mock . MagicMock ( ) [EOL] self . assertTrue ( nx584 . setup_platform ( self . hass , config , add_devices ) ) [EOL] mock_nx . assert_has_calls ( [ mock . call ( self . fake_zones [ [number] ] , [string] ) , mock . call ( self . fake_zones [ [number] ] , [string] ) , ] ) [EOL] self . assertTrue ( add_devices . called ) [EOL] self . assertEqual ( nx584_client . Client . call_count , [number] ) [EOL] self . assertEqual ( nx584_client . Client . call_args , mock . call ( [string] ) ) [EOL] self . assertTrue ( mock_watcher . called ) [EOL] [EOL] def _test_assert_graceful_fail ( self , config ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , [string] , config ) ) [EOL] [EOL] def test_setup_bad_config ( self ) : [EOL] [docstring] [EOL] bad_configs = [ { [string] : [ [string] ] } , { [string] : { [string] : [string] } } , { [string] : { [number] : [string] } } , { [string] : { [string] : [string] } } , ] [EOL] for config in bad_configs : [EOL] self . _test_assert_graceful_fail ( config ) [EOL] [EOL] def test_setup_connect_failed ( self ) : [EOL] [docstring] [EOL] nx584_client . Client . return_value . list_zones . side_effect = requests . exceptions . ConnectionError [EOL] self . _test_assert_graceful_fail ( { } ) [EOL] [EOL] def test_setup_no_partitions ( self ) : [EOL] [docstring] [EOL] nx584_client . Client . return_value . list_zones . side_effect = IndexError [EOL] self . _test_assert_graceful_fail ( { } ) [EOL] [EOL] def test_setup_version_too_old ( self ) : [EOL] [docstring] [EOL] nx584_client . Client . return_value . get_version . return_value = [string] [EOL] self . _test_assert_graceful_fail ( { } ) [EOL] [EOL] def test_setup_no_zones ( self ) : [EOL] [docstring] [EOL] nx584_client . Client . return_value . list_zones . return_value = [ ] [EOL] add_devices = mock . MagicMock ( ) [EOL] self . assertTrue ( nx584 . setup_platform ( self . hass , { } , add_devices ) ) [EOL] self . assertFalse ( add_devices . called ) [EOL] [EOL] [EOL] class TestNX584ZoneSensor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_sensor_normal ( self ) : [EOL] [docstring] [EOL] zone = { [string] : [number] , [string] : [string] , [string] : True } [EOL] sensor = nx584 . NX584ZoneSensor ( zone , [string] ) [EOL] self . assertEqual ( [string] , sensor . name ) [EOL] self . assertFalse ( sensor . should_poll ) [EOL] self . assertTrue ( sensor . is_on ) [EOL] [EOL] zone [ [string] ] = False [EOL] self . assertFalse ( sensor . is_on ) [EOL] [EOL] [EOL] class TestNX584Watcher ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] @ mock . patch . object ( nx584 . NX584ZoneSensor , [string] ) def test_process_zone_event ( self , mock_update ) : [EOL] [docstring] [EOL] zone1 = { [string] : [number] , [string] : [string] , [string] : True } [EOL] zone2 = { [string] : [number] , [string] : [string] , [string] : True } [EOL] zones = { [number] : nx584 . NX584ZoneSensor ( zone1 , [string] ) , [number] : nx584 . NX584ZoneSensor ( zone2 , [string] ) , } [EOL] watcher = nx584 . NX584Watcher ( None , zones ) [EOL] watcher . _process_zone_event ( { [string] : [number] , [string] : False } ) [EOL] self . assertFalse ( zone1 [ [string] ] ) [EOL] self . assertEqual ( [number] , mock_update . call_count ) [EOL] [EOL] @ mock . patch . object ( nx584 . NX584ZoneSensor , [string] ) def test_process_zone_event_missing_zone ( self , mock_update ) : [EOL] [docstring] [EOL] watcher = nx584 . NX584Watcher ( None , { } ) [EOL] watcher . _process_zone_event ( { [string] : [number] , [string] : False } ) [EOL] self . assertFalse ( mock_update . called ) [EOL] [EOL] def test_run_with_zone_events ( self ) : [EOL] [docstring] [EOL] empty_me = [ [number] , [number] ] [EOL] [EOL] def fake_get_events ( ) : [EOL] [docstring] [EOL] if empty_me : [EOL] empty_me . pop ( ) [EOL] else : [EOL] return fake_events [EOL] [EOL] client = mock . MagicMock ( ) [EOL] fake_events = [ { [string] : [number] , [string] : True , [string] : [string] } , { [string] : [number] , [string] : False } , ] [EOL] client . get_events . side_effect = fake_get_events [EOL] watcher = nx584 . NX584Watcher ( client , { } ) [EOL] [EOL] @ mock . patch . object ( watcher , [string] ) def run ( fake_process ) : [EOL] [docstring] [EOL] fake_process . side_effect = StopMe [EOL] self . assertRaises ( StopMe , watcher . _run ) [EOL] self . assertEqual ( fake_process . call_count , [number] ) [EOL] self . assertEqual ( fake_process . call_args , mock . call ( fake_events [ [number] ] ) ) [EOL] [EOL] run ( ) [EOL] self . assertEqual ( [number] , client . get_events . call_count ) [EOL] [EOL] @ mock . patch ( [string] ) def test_run_retries_failures ( self , mock_sleep ) : [EOL] [docstring] [EOL] empty_me = [ [number] , [number] ] [EOL] [EOL] def fake_run ( ) : [EOL] [docstring] [EOL] if empty_me : [EOL] empty_me . pop ( ) [EOL] raise requests . exceptions . ConnectionError ( ) [EOL] else : [EOL] raise StopMe ( ) [EOL] [EOL] watcher = nx584 . NX584Watcher ( None , { } ) [EOL] with mock . patch . object ( watcher , [string] ) as mock_inner : [EOL] mock_inner . side_effect = fake_run [EOL] self . assertRaises ( StopMe , watcher . run ) [EOL] self . assertEqual ( [number] , mock_inner . call_count ) [EOL] mock_sleep . assert_has_calls ( [ mock . call ( [number] ) , mock . call ( [number] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,builtins.str],typing.List[builtins.int],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,builtins.str],typing.List[builtins.int],builtins.int,builtins.str]]$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.Dict[builtins.str,typing.List[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.Dict[builtins.str,typing.List[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Dict , Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import socket [EOL] import unittest [EOL] from copy import copy [EOL] from uuid import uuid4 [EOL] from unittest . mock import patch , Mock [EOL] [EOL] from tests . common import ( get_test_home_assistant , assert_setup_component ) [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components . sensor import tcp [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . template import Template [EOL] [EOL] TEST_CONFIG = { [string] : { [string] : [string] , tcp . CONF_NAME : [string] , tcp . CONF_HOST : [string] , tcp . CONF_PORT : [number] , tcp . CONF_TIMEOUT : tcp . DEFAULT_TIMEOUT + [number] , tcp . CONF_PAYLOAD : [string] , tcp . CONF_UNIT_OF_MEASUREMENT : [string] , tcp . CONF_VALUE_TEMPLATE : Template ( [string] ) , tcp . CONF_VALUE_ON : [string] , tcp . CONF_BUFFER_SIZE : tcp . DEFAULT_BUFFER_SIZE + [number] } , } [EOL] [EOL] KEYS_AND_DEFAULTS = { tcp . CONF_TIMEOUT : tcp . DEFAULT_TIMEOUT , tcp . CONF_UNIT_OF_MEASUREMENT : None , tcp . CONF_VALUE_TEMPLATE : None , tcp . CONF_VALUE_ON : None , tcp . CONF_BUFFER_SIZE : tcp . DEFAULT_BUFFER_SIZE } [EOL] [EOL] [EOL] class TestTCPSensor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def teardown_method ( self , method ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ patch ( [string] ) def test_setup_platform_valid_config ( self , mock_update ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup_component ( self . hass , [string] , TEST_CONFIG ) [EOL] [EOL] add_devices = Mock ( ) [EOL] tcp . setup_platform ( None , TEST_CONFIG [ [string] ] , add_devices ) [EOL] assert add_devices . called [EOL] assert isinstance ( add_devices . call_args [ [number] ] [ [number] ] [ [number] ] , tcp . TcpSensor ) [EOL] [EOL] def test_setup_platform_invalid_config ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [number] , } } ) [EOL] [EOL] @ patch ( [string] ) def test_name ( self , mock_update ) : [EOL] [docstring] [EOL] sensor = tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] assert sensor . name == TEST_CONFIG [ [string] ] [ tcp . CONF_NAME ] [EOL] [EOL] @ patch ( [string] ) def test_name_not_set ( self , mock_update ) : [EOL] [docstring] [EOL] config = copy ( TEST_CONFIG [ [string] ] ) [EOL] del config [ tcp . CONF_NAME ] [EOL] entity = Entity ( ) [EOL] sensor = tcp . TcpSensor ( self . hass , config ) [EOL] assert sensor . name == entity . name [EOL] [EOL] @ patch ( [string] ) def test_state ( self , mock_update ) : [EOL] [docstring] [EOL] sensor = tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] uuid = str ( uuid4 ( ) ) [EOL] sensor . _state = uuid [EOL] assert sensor . state == uuid [EOL] [EOL] @ patch ( [string] ) def test_unit_of_measurement ( self , mock_update ) : [EOL] [docstring] [EOL] sensor = tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] assert sensor . unit_of_measurement == TEST_CONFIG [ [string] ] [ tcp . CONF_UNIT_OF_MEASUREMENT ] [EOL] [EOL] @ patch ( [string] ) def test_config_valid_keys ( self , * args ) : [EOL] [docstring] [EOL] sensor = tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] del TEST_CONFIG [ [string] ] [ [string] ] [EOL] [EOL] for key in TEST_CONFIG [ [string] ] : [EOL] assert key in sensor . _config [EOL] [EOL] def test_validate_config_valid_keys ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup_component ( self . hass , [string] , TEST_CONFIG ) [EOL] [EOL] @ patch ( [string] ) def test_config_invalid_keys ( self , mock_update ) : [EOL] [docstring] [EOL] config = copy ( TEST_CONFIG [ [string] ] ) [EOL] config . update ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] sensor = tcp . TcpSensor ( self . hass , config ) [EOL] for invalid_key in [string] : [EOL] assert invalid_key not in sensor . _config [EOL] [EOL] def test_validate_config_invalid_keys ( self ) : [EOL] [docstring] [EOL] config = copy ( TEST_CONFIG [ [string] ] ) [EOL] config . update ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] [EOL] @ patch ( [string] ) def test_config_uses_defaults ( self , mock_update ) : [EOL] [docstring] [EOL] config = copy ( TEST_CONFIG [ [string] ] ) [EOL] [EOL] for key in KEYS_AND_DEFAULTS : [EOL] del config [ key ] [EOL] [EOL] with assert_setup_component ( [number] ) as result_config : [EOL] assert setup_component ( self . hass , [string] , { [string] : config , } ) [EOL] [EOL] sensor = tcp . TcpSensor ( self . hass , result_config [ [string] ] [ [number] ] ) [EOL] [EOL] for key , default in KEYS_AND_DEFAULTS . items ( ) : [EOL] assert sensor . _config [ key ] == default [EOL] [EOL] def test_validate_config_missing_defaults ( self ) : [EOL] [docstring] [EOL] config = copy ( TEST_CONFIG [ [string] ] ) [EOL] [EOL] for key in KEYS_AND_DEFAULTS : [EOL] del config [ key ] [EOL] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] [EOL] def test_validate_config_missing_required ( self ) : [EOL] [docstring] [EOL] for key in TEST_CONFIG [ [string] ] : [EOL] if key in KEYS_AND_DEFAULTS : [EOL] continue [EOL] config = copy ( TEST_CONFIG [ [string] ] ) [EOL] del config [ key ] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] [EOL] @ patch ( [string] ) def test_init_calls_update ( self , mock_update ) : [EOL] [docstring] [EOL] tcp . TcpSensor ( self . hass , TEST_CONFIG ) [EOL] assert mock_update . called [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] , return_value = ( True , False , False ) ) def test_update_connects_to_host_and_port ( self , mock_select , mock_socket ) : [EOL] [docstring] [EOL] tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] mock_socket = mock_socket ( ) . __enter__ ( ) [EOL] assert mock_socket . connect . mock_calls [ [number] ] [ [number] ] == ( ( TEST_CONFIG [ [string] ] [ tcp . CONF_HOST ] , TEST_CONFIG [ [string] ] [ tcp . CONF_PORT ] ) , ) [EOL] [EOL] @ patch ( [string] , side_effect = socket . error ( ) ) def test_update_returns_if_connecting_fails ( self , * args ) : [EOL] [docstring] [EOL] with patch ( [string] ) : [EOL] sensor = tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] assert sensor . update ( ) is None [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] , side_effect = socket . error ( ) ) def test_update_returns_if_sending_fails ( self , * args ) : [EOL] [docstring] [EOL] with patch ( [string] ) : [EOL] sensor = tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] assert sensor . update ( ) is None [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] , return_value = ( False , False , False ) ) def test_update_returns_if_select_fails ( self , * args ) : [EOL] [docstring] [EOL] with patch ( [string] ) : [EOL] sensor = tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] assert sensor . update ( ) is None [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] , return_value = ( True , False , False ) ) def test_update_sends_payload ( self , mock_select , mock_socket ) : [EOL] [docstring] [EOL] tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] mock_socket = mock_socket ( ) . __enter__ ( ) [EOL] mock_socket . send . assert_called_with ( TEST_CONFIG [ [string] ] [ tcp . CONF_PAYLOAD ] . encode ( ) ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] , return_value = ( True , False , False ) ) def test_update_calls_select_with_timeout ( self , mock_select , mock_socket ) : [EOL] [docstring] [EOL] tcp . TcpSensor ( self . hass , TEST_CONFIG [ [string] ] ) [EOL] mock_socket = mock_socket ( ) . __enter__ ( ) [EOL] mock_select . assert_called_with ( [ mock_socket ] , [ ] , [ ] , TEST_CONFIG [ [string] ] [ tcp . CONF_TIMEOUT ] ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] , return_value = ( True , False , False ) ) def test_update_receives_packet_and_sets_as_state ( self , mock_select , mock_socket ) : [EOL] [docstring] [EOL] test_value = [string] [EOL] mock_socket = mock_socket ( ) . __enter__ ( ) [EOL] mock_socket . recv . return_value = test_value . encode ( ) [EOL] config = copy ( TEST_CONFIG [ [string] ] ) [EOL] del config [ tcp . CONF_VALUE_TEMPLATE ] [EOL] sensor = tcp . TcpSensor ( self . hass , config ) [EOL] assert sensor . _state == test_value [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] , return_value = ( True , False , False ) ) def test_update_renders_value_in_template ( self , mock_select , mock_socket ) : [EOL] [docstring] [EOL] test_value = [string] [EOL] mock_socket = mock_socket ( ) . __enter__ ( ) [EOL] mock_socket . recv . return_value = test_value . encode ( ) [EOL] config = copy ( TEST_CONFIG [ [string] ] ) [EOL] config [ tcp . CONF_VALUE_TEMPLATE ] = Template ( [string] ) [EOL] sensor = tcp . TcpSensor ( self . hass , config ) [EOL] assert sensor . _state == [string] % test_value [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] , return_value = ( True , False , False ) ) def test_update_returns_if_template_render_fails ( self , mock_select , mock_socket ) : [EOL] [docstring] [EOL] test_value = [string] [EOL] mock_socket = mock_socket ( ) . __enter__ ( ) [EOL] mock_socket . recv . return_value = test_value . encode ( ) [EOL] config = copy ( TEST_CONFIG [ [string] ] ) [EOL] config [ tcp . CONF_VALUE_TEMPLATE ] = Template ( [string] ) [EOL] sensor = tcp . TcpSensor ( self . hass , config ) [EOL] assert sensor . update ( ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Dict , List , Union , Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . helpers . template import Template [EOL] from homeassistant . components . sensor import command_line [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class TestCommandSensorSensor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def update_side_effect ( self , data ) : [EOL] [docstring] [EOL] self . commandline . data = data [EOL] [EOL] def test_setup ( self ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } [EOL] devices = [ ] [EOL] [EOL] def add_dev_callback ( devs , update ) : [EOL] [docstring] [EOL] for dev in devs : [EOL] devices . append ( dev ) [EOL] [EOL] command_line . setup_platform ( self . hass , config , add_dev_callback ) [EOL] [EOL] self . assertEqual ( [number] , len ( devices ) ) [EOL] entity = devices [ [number] ] [EOL] entity . update ( ) [EOL] self . assertEqual ( [string] , entity . name ) [EOL] self . assertEqual ( [string] , entity . unit_of_measurement ) [EOL] self . assertEqual ( [string] , entity . state ) [EOL] [EOL] def test_template ( self ) : [EOL] [docstring] [EOL] data = command_line . CommandSensorData ( self . hass , [string] , [number] ) [EOL] [EOL] entity = command_line . CommandSensor ( self . hass , data , [string] , [string] , Template ( [string] , self . hass ) , [ ] ) [EOL] [EOL] entity . update ( ) [EOL] self . assertEqual ( [number] , float ( entity . state ) ) [EOL] [EOL] def test_template_render ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [string] ) [EOL] data = command_line . CommandSensorData ( self . hass , [string] , [number] ) [EOL] data . update ( ) [EOL] [EOL] self . assertEqual ( [string] , data . value ) [EOL] [EOL] def test_bad_command ( self ) : [EOL] [docstring] [EOL] data = command_line . CommandSensorData ( self . hass , [string] , [number] ) [EOL] data . update ( ) [EOL] [EOL] self . assertEqual ( None , data . value ) [EOL] [EOL] def test_update_with_json_attrs ( self ) : [EOL] [docstring] [EOL] data = command_line . CommandSensorData ( self . hass , ( [string] ) , [number] ) [EOL] [EOL] self . sensor = command_line . CommandSensor ( self . hass , data , [string] , None , None , [ [string] , [string] , [string] ] ) [EOL] self . sensor . update ( ) [EOL] self . assertEqual ( [string] , self . sensor . device_state_attributes [ [string] ] ) [EOL] self . assertEqual ( [string] , self . sensor . device_state_attributes [ [string] ] ) [EOL] self . assertEqual ( [string] , self . sensor . device_state_attributes [ [string] ] ) [EOL] [EOL] @ patch ( [string] ) def test_update_with_json_attrs_no_data ( self , mock_logger ) : [EOL] [docstring] [EOL] data = command_line . CommandSensorData ( self . hass , [string] , [number] ) [EOL] self . sensor = command_line . CommandSensor ( self . hass , data , [string] , None , None , [ [string] ] ) [EOL] self . sensor . update ( ) [EOL] self . assertEqual ( { } , self . sensor . device_state_attributes ) [EOL] self . assertTrue ( mock_logger . warning . called ) [EOL] [EOL] @ patch ( [string] ) def test_update_with_json_attrs_not_dict ( self , mock_logger ) : [EOL] [docstring] [EOL] data = command_line . CommandSensorData ( self . hass , [string] , [number] ) [EOL] self . sensor = command_line . CommandSensor ( self . hass , data , [string] , None , None , [ [string] ] ) [EOL] self . sensor . update ( ) [EOL] self . assertEqual ( { } , self . sensor . device_state_attributes ) [EOL] self . assertTrue ( mock_logger . warning . called ) [EOL] [EOL] @ patch ( [string] ) def test_update_with_json_attrs_bad_JSON ( self , mock_logger ) : [EOL] [docstring] [EOL] data = command_line . CommandSensorData ( self . hass , [string] , [number] ) [EOL] self . sensor = command_line . CommandSensor ( self . hass , data , [string] , None , None , [ [string] ] ) [EOL] self . sensor . update ( ) [EOL] self . assertEqual ( { } , self . sensor . device_state_attributes ) [EOL] self . assertTrue ( mock_logger . warning . called ) [EOL] [EOL] def test_update_with_missing_json_attrs ( self ) : [EOL] [docstring] [EOL] data = command_line . CommandSensorData ( self . hass , ( [string] ) , [number] ) [EOL] [EOL] self . sensor = command_line . CommandSensor ( self . hass , data , [string] , None , None , [ [string] , [string] , [string] , [string] ] ) [EOL] self . sensor . update ( ) [EOL] self . assertEqual ( [string] , self . sensor . device_state_attributes [ [string] ] ) [EOL] self . assertEqual ( [string] , self . sensor . device_state_attributes [ [string] ] ) [EOL] self . assertEqual ( [string] , self . sensor . device_state_attributes [ [string] ] ) [EOL] self . assertFalse ( [string] in self . sensor . device_state_attributes ) [EOL] [EOL] def test_update_with_unnecessary_json_attrs ( self ) : [EOL] [docstring] [EOL] data = command_line . CommandSensorData ( self . hass , ( [string] ) , [number] ) [EOL] [EOL] self . sensor = command_line . CommandSensor ( self . hass , data , [string] , None , None , [ [string] , [string] ] ) [EOL] self . sensor . update ( ) [EOL] self . assertEqual ( [string] , self . sensor . device_state_attributes [ [string] ] ) [EOL] self . assertEqual ( [string] , self . sensor . device_state_attributes [ [string] ] ) [EOL] self . assertFalse ( [string] in self . sensor . device_state_attributes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] from collections import namedtuple [EOL] from unittest . mock import patch , MagicMock [EOL] import pytest [EOL] from homeassistant . const import ( DEVICE_CLASS_TEMPERATURE , DEVICE_CLASS_HUMIDITY , ATTR_ATTRIBUTION ) [EOL] from homeassistant . components . sensor import arlo [EOL] from homeassistant . components . arlo import DATA_ARLO [EOL] [EOL] [EOL] def _get_named_tuple ( input_dict ) : [EOL] return namedtuple ( [string] , input_dict . keys ( ) ) ( * input_dict . values ( ) ) [EOL] [EOL] [EOL] def _get_sensor ( name = [string] , sensor_type = [string] , data = None ) : [EOL] if data is None : [EOL] data = { } [EOL] return arlo . ArloSensor ( name , data , sensor_type ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def default_sensor ( ) : [EOL] [docstring] [EOL] return _get_sensor ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def battery_sensor ( ) : [EOL] [docstring] [EOL] data = _get_named_tuple ( { [string] : [number] } ) [EOL] return _get_sensor ( [string] , [string] , data ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def temperature_sensor ( ) : [EOL] [docstring] [EOL] return _get_sensor ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def humidity_sensor ( ) : [EOL] [docstring] [EOL] return _get_sensor ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def cameras_sensor ( ) : [EOL] [docstring] [EOL] data = _get_named_tuple ( { [string] : [ [number] , [number] ] } ) [EOL] return _get_sensor ( [string] , [string] , data ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def captured_sensor ( ) : [EOL] [docstring] [EOL] data = _get_named_tuple ( { [string] : [ [number] , [number] , [number] , [number] , [number] ] } ) [EOL] return _get_sensor ( [string] , [string] , data ) [EOL] [EOL] [EOL] class PlatformSetupFixture ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . sensors = None [EOL] self . update = False [EOL] [EOL] def add_devices ( self , sensors , update ) : [EOL] [docstring] [EOL] self . sensors = sensors [EOL] self . update = update [EOL] [EOL] [EOL] @ pytest . fixture ( ) def platform_setup ( ) : [EOL] [docstring] [EOL] return PlatformSetupFixture ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def sensor_with_hass_data ( default_sensor , hass ) : [EOL] [docstring] [EOL] hass . data = { } [EOL] default_sensor . hass = hass [EOL] return default_sensor [EOL] [EOL] [EOL] @ pytest . fixture ( ) def mock_dispatch ( ) : [EOL] [docstring] [EOL] target = [string] [EOL] with patch ( target , MagicMock ( ) ) as _mock : [EOL] yield _mock [EOL] [EOL] [EOL] def test_setup_with_no_data ( platform_setup , hass ) : [EOL] [docstring] [EOL] arlo . setup_platform ( hass , None , platform_setup . add_devices ) [EOL] assert platform_setup . sensors is None [EOL] assert not platform_setup . update [EOL] [EOL] [EOL] def test_setup_with_valid_data ( platform_setup , hass ) : [EOL] [docstring] [EOL] config = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] } [EOL] [EOL] hass . data [ DATA_ARLO ] = _get_named_tuple ( { [string] : [ _get_named_tuple ( { [string] : [string] , [string] : [string] } ) ] , [string] : [ _get_named_tuple ( { [string] : [string] , [string] : [string] } ) ] } ) [EOL] [EOL] arlo . setup_platform ( hass , config , platform_setup . add_devices ) [EOL] assert len ( platform_setup . sensors ) == [number] [EOL] assert platform_setup . update [EOL] [EOL] [EOL] def test_sensor_name ( default_sensor ) : [EOL] [docstring] [EOL] assert default_sensor . name == [string] [EOL] [EOL] [EOL] async def test_async_added_to_hass ( sensor_with_hass_data , mock_dispatch ) : [EOL] [docstring] [EOL] await sensor_with_hass_data . async_added_to_hass ( ) [EOL] assert len ( mock_dispatch . mock_calls ) == [number] [EOL] kall = mock_dispatch . call_args [EOL] args , kwargs = kall [EOL] assert len ( args ) == [number] [EOL] assert args [ [number] ] == sensor_with_hass_data . hass [EOL] assert args [ [number] ] == [string] [EOL] assert not kwargs [EOL] [EOL] [EOL] def test_sensor_state_default ( default_sensor ) : [EOL] [docstring] [EOL] assert default_sensor . state is None [EOL] [EOL] [EOL] def test_sensor_icon_battery ( battery_sensor ) : [EOL] [docstring] [EOL] assert battery_sensor . icon == [string] [EOL] [EOL] [EOL] def test_sensor_icon ( temperature_sensor ) : [EOL] [docstring] [EOL] assert temperature_sensor . icon == [string] [EOL] [EOL] [EOL] def test_unit_of_measure ( default_sensor , battery_sensor ) : [EOL] [docstring] [EOL] assert default_sensor . unit_of_measurement is None [EOL] assert battery_sensor . unit_of_measurement == [string] [EOL] [EOL] [EOL] def test_device_class ( default_sensor , temperature_sensor , humidity_sensor ) : [EOL] [docstring] [EOL] assert default_sensor . device_class is None [EOL] assert temperature_sensor . device_class == DEVICE_CLASS_TEMPERATURE [EOL] assert humidity_sensor . device_class == DEVICE_CLASS_HUMIDITY [EOL] [EOL] [EOL] def test_update_total_cameras ( cameras_sensor ) : [EOL] [docstring] [EOL] cameras_sensor . update ( ) [EOL] assert cameras_sensor . state == [number] [EOL] [EOL] [EOL] def test_update_captured_today ( captured_sensor ) : [EOL] [docstring] [EOL] captured_sensor . update ( ) [EOL] assert captured_sensor . state == [number] [EOL] [EOL] [EOL] def _test_attributes ( sensor_type ) : [EOL] data = _get_named_tuple ( { [string] : [string] } ) [EOL] sensor = _get_sensor ( [string] , sensor_type , data ) [EOL] attrs = sensor . device_state_attributes [EOL] assert attrs . get ( ATTR_ATTRIBUTION ) == [string] [EOL] assert attrs . get ( [string] ) == [string] [EOL] assert attrs . get ( [string] ) == [string] [EOL] [EOL] [EOL] def test_state_attributes ( ) : [EOL] [docstring] [EOL] _test_attributes ( [string] ) [EOL] _test_attributes ( [string] ) [EOL] _test_attributes ( [string] ) [EOL] _test_attributes ( [string] ) [EOL] _test_attributes ( [string] ) [EOL] [EOL] [EOL] def test_attributes_total_cameras ( cameras_sensor ) : [EOL] [docstring] [EOL] attrs = cameras_sensor . device_state_attributes [EOL] assert attrs . get ( ATTR_ATTRIBUTION ) == [string] [EOL] assert attrs . get ( [string] ) == [string] [EOL] assert attrs . get ( [string] ) is None [EOL] [EOL] [EOL] def _test_update ( sensor_type , key , value ) : [EOL] data = _get_named_tuple ( { key : value } ) [EOL] sensor = _get_sensor ( [string] , sensor_type , data ) [EOL] sensor . update ( ) [EOL] assert sensor . state == value [EOL] [EOL] [EOL] def test_update ( ) : [EOL] [docstring] [EOL] _test_update ( [string] , [string] , [number] ) [EOL] _test_update ( [string] , [string] , [number] ) [EOL] _test_update ( [string] , [string] , [number] ) [EOL] _test_update ( [string] , [string] , [number] ) [EOL] _test_update ( [string] , [string] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Any [EOL] import tests [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import copy [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from homeassistant . components . canary import DATA_CANARY [EOL] from homeassistant . components . sensor import canary [EOL] from homeassistant . components . sensor . canary import CanarySensor , SENSOR_TYPES , ATTR_AIR_QUALITY , STATE_AIR_QUALITY_NORMAL , STATE_AIR_QUALITY_ABNORMAL , STATE_AIR_QUALITY_VERY_ABNORMAL [EOL] from tests . common import ( get_test_home_assistant ) [EOL] from tests . components . test_canary import mock_device , mock_location [EOL] [EOL] VALID_CONFIG = { [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] [EOL] class TestCanarySensorSetup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] DEVICES = [ ] [EOL] [EOL] def add_devices ( self , devices , action ) : [EOL] [docstring] [EOL] for device in devices : [EOL] self . DEVICES . append ( device ) [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . config = copy . deepcopy ( VALID_CONFIG ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_sensors ( self ) : [EOL] [docstring] [EOL] online_device_at_home = mock_device ( [number] , [string] , True , [string] ) [EOL] offline_device_at_home = mock_device ( [number] , [string] , False , [string] ) [EOL] online_device_at_work = mock_device ( [number] , [string] , True , [string] ) [EOL] [EOL] self . hass . data [ DATA_CANARY ] = Mock ( ) [EOL] self . hass . data [ DATA_CANARY ] . locations = [ mock_location ( [string] , True , devices = [ online_device_at_home , offline_device_at_home ] ) , mock_location ( [string] , True , devices = [ online_device_at_work ] ) , ] [EOL] [EOL] canary . setup_platform ( self . hass , self . config , self . add_devices , None ) [EOL] [EOL] self . assertEqual ( [number] , len ( self . DEVICES ) ) [EOL] [EOL] def test_temperature_sensor ( self ) : [EOL] [docstring] [EOL] device = mock_device ( [number] , [string] , [string] ) [EOL] location = mock_location ( [string] , False ) [EOL] [EOL] data = Mock ( ) [EOL] data . get_reading . return_value = [number] [EOL] [EOL] sensor = CanarySensor ( data , SENSOR_TYPES [ [number] ] , location , device ) [EOL] sensor . update ( ) [EOL] [EOL] self . assertEqual ( [string] , sensor . name ) [EOL] self . assertEqual ( [string] , sensor . unit_of_measurement ) [EOL] self . assertEqual ( [number] , sensor . state ) [EOL] self . assertEqual ( [string] , sensor . icon ) [EOL] [EOL] def test_temperature_sensor_with_none_sensor_value ( self ) : [EOL] [docstring] [EOL] device = mock_device ( [number] , [string] , [string] ) [EOL] location = mock_location ( [string] , False ) [EOL] [EOL] data = Mock ( ) [EOL] data . get_reading . return_value = None [EOL] [EOL] sensor = CanarySensor ( data , SENSOR_TYPES [ [number] ] , location , device ) [EOL] sensor . update ( ) [EOL] [EOL] self . assertEqual ( None , sensor . state ) [EOL] [EOL] def test_humidity_sensor ( self ) : [EOL] [docstring] [EOL] device = mock_device ( [number] , [string] , [string] ) [EOL] location = mock_location ( [string] ) [EOL] [EOL] data = Mock ( ) [EOL] data . get_reading . return_value = [number] [EOL] [EOL] sensor = CanarySensor ( data , SENSOR_TYPES [ [number] ] , location , device ) [EOL] sensor . update ( ) [EOL] [EOL] self . assertEqual ( [string] , sensor . name ) [EOL] self . assertEqual ( [string] , sensor . unit_of_measurement ) [EOL] self . assertEqual ( [number] , sensor . state ) [EOL] self . assertEqual ( [string] , sensor . icon ) [EOL] [EOL] def test_air_quality_sensor_with_very_abnormal_reading ( self ) : [EOL] [docstring] [EOL] device = mock_device ( [number] , [string] , [string] ) [EOL] location = mock_location ( [string] ) [EOL] [EOL] data = Mock ( ) [EOL] data . get_reading . return_value = [number] [EOL] [EOL] sensor = CanarySensor ( data , SENSOR_TYPES [ [number] ] , location , device ) [EOL] sensor . update ( ) [EOL] [EOL] self . assertEqual ( [string] , sensor . name ) [EOL] self . assertEqual ( None , sensor . unit_of_measurement ) [EOL] self . assertEqual ( [number] , sensor . state ) [EOL] self . assertEqual ( [string] , sensor . icon ) [EOL] [EOL] air_quality = sensor . device_state_attributes [ ATTR_AIR_QUALITY ] [EOL] self . assertEqual ( STATE_AIR_QUALITY_VERY_ABNORMAL , air_quality ) [EOL] [EOL] def test_air_quality_sensor_with_abnormal_reading ( self ) : [EOL] [docstring] [EOL] device = mock_device ( [number] , [string] , [string] ) [EOL] location = mock_location ( [string] ) [EOL] [EOL] data = Mock ( ) [EOL] data . get_reading . return_value = [number] [EOL] [EOL] sensor = CanarySensor ( data , SENSOR_TYPES [ [number] ] , location , device ) [EOL] sensor . update ( ) [EOL] [EOL] self . assertEqual ( [string] , sensor . name ) [EOL] self . assertEqual ( None , sensor . unit_of_measurement ) [EOL] self . assertEqual ( [number] , sensor . state ) [EOL] self . assertEqual ( [string] , sensor . icon ) [EOL] [EOL] air_quality = sensor . device_state_attributes [ ATTR_AIR_QUALITY ] [EOL] self . assertEqual ( STATE_AIR_QUALITY_ABNORMAL , air_quality ) [EOL] [EOL] def test_air_quality_sensor_with_normal_reading ( self ) : [EOL] [docstring] [EOL] device = mock_device ( [number] , [string] , [string] ) [EOL] location = mock_location ( [string] ) [EOL] [EOL] data = Mock ( ) [EOL] data . get_reading . return_value = [number] [EOL] [EOL] sensor = CanarySensor ( data , SENSOR_TYPES [ [number] ] , location , device ) [EOL] sensor . update ( ) [EOL] [EOL] self . assertEqual ( [string] , sensor . name ) [EOL] self . assertEqual ( None , sensor . unit_of_measurement ) [EOL] self . assertEqual ( [number] , sensor . state ) [EOL] self . assertEqual ( [string] , sensor . icon ) [EOL] [EOL] air_quality = sensor . device_state_attributes [ ATTR_AIR_QUALITY ] [EOL] self . assertEqual ( STATE_AIR_QUALITY_NORMAL , air_quality ) [EOL] [EOL] def test_air_quality_sensor_with_none_sensor_value ( self ) : [EOL] [docstring] [EOL] device = mock_device ( [number] , [string] , [string] ) [EOL] location = mock_location ( [string] ) [EOL] [EOL] data = Mock ( ) [EOL] data . get_reading . return_value = None [EOL] [EOL] sensor = CanarySensor ( data , SENSOR_TYPES [ [number] ] , location , device ) [EOL] sensor . update ( ) [EOL] [EOL] self . assertEqual ( None , sensor . state ) [EOL] self . assertEqual ( None , sensor . device_state_attributes ) [EOL] [EOL] def test_battery_sensor ( self ) : [EOL] [docstring] [EOL] device = mock_device ( [number] , [string] , [string] ) [EOL] location = mock_location ( [string] ) [EOL] [EOL] data = Mock ( ) [EOL] data . get_reading . return_value = [number] [EOL] [EOL] sensor = CanarySensor ( data , SENSOR_TYPES [ [number] ] , location , device ) [EOL] sensor . update ( ) [EOL] [EOL] self . assertEqual ( [string] , sensor . name ) [EOL] self . assertEqual ( [string] , sensor . unit_of_measurement ) [EOL] self . assertEqual ( [number] , sensor . state ) [EOL] self . assertEqual ( [string] , sensor . icon ) [EOL] [EOL] def test_wifi_sensor ( self ) : [EOL] [docstring] [EOL] device = mock_device ( [number] , [string] , [string] ) [EOL] location = mock_location ( [string] ) [EOL] [EOL] data = Mock ( ) [EOL] data . get_reading . return_value = - [number] [EOL] [EOL] sensor = CanarySensor ( data , SENSOR_TYPES [ [number] ] , location , device ) [EOL] sensor . update ( ) [EOL] [EOL] self . assertEqual ( [string] , sensor . name ) [EOL] self . assertEqual ( [string] , sensor . unit_of_measurement ) [EOL] self . assertEqual ( - [number] , sensor . state ) [EOL] self . assertEqual ( [string] , sensor . icon ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . const import ( STATE_ON , STATE_OFF , STATE_UNAVAILABLE , ATTR_ASSUMED_STATE ) [EOL] import homeassistant . components . light as light [EOL] import homeassistant . core as ha [EOL] from tests . common import ( get_test_home_assistant , mock_mqtt_component , fire_mqtt_message , assert_setup_component , mock_coro ) [EOL] [EOL] [EOL] class TestLightMQTTTemplate ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . mock_publish = mock_mqtt_component ( self . hass ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_fails ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , light . DOMAIN ) : [EOL] assert setup_component ( self . hass , light . DOMAIN , { light . DOMAIN : { [string] : [string] , [string] : [string] , } } ) [EOL] self . assertIsNone ( self . hass . states . get ( [string] ) ) [EOL] [EOL] def test_state_change_via_topic ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , light . DOMAIN ) : [EOL] assert setup_component ( self . hass , light . DOMAIN , { light . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] [string] [string] [string] [string] [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertFalse ( state . attributes . get ( ATTR_ASSUMED_STATE ) ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_ON , state . state ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] [EOL] def test_state_brightness_color_effect_temp_white_change_via_topic ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , light . DOMAIN ) : [EOL] assert setup_component ( self . hass , light . DOMAIN , { light . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [string] [string] [string] [string] [string] [string] [string] [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] , [string] : [string] [string] , [string] : [string] [string] , [string] : [string] } } ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertFalse ( state . attributes . get ( ATTR_ASSUMED_STATE ) ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_ON , state . state ) [EOL] self . assertEqual ( ( [number] , [number] , [number] ) , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] light_state = self . hass . states . get ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , light_state . attributes [ [string] ] ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] light_state = self . hass . states . get ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , light_state . attributes [ [string] ] ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] light_state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( ( [number] , [number] , [number] ) , light_state . attributes . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] light_state = self . hass . states . get ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , light_state . attributes [ [string] ] ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] light_state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [string] , light_state . attributes . get ( [string] ) ) [EOL] [EOL] def test_optimistic ( self ) : [EOL] [docstring] [EOL] fake_state = ha . State ( [string] , [string] , { [string] : [number] , [string] : [ [number] , [number] ] , [string] : [string] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] with patch ( [string] [string] , return_value = mock_coro ( fake_state ) ) : [EOL] with assert_setup_component ( [number] , light . DOMAIN ) : [EOL] assert setup_component ( self . hass , light . DOMAIN , { light . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] [string] [string] [string] [string] [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [number] } } ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_ON , state . state ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( ( [number] , [number] ) , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] self . assertTrue ( state . attributes . get ( ATTR_ASSUMED_STATE ) ) [EOL] [EOL] [comment] [EOL] light . turn_on ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] self . mock_publish . async_publish . reset_mock ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_ON , state . state ) [EOL] [EOL] [comment] [EOL] light . turn_off ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] self . mock_publish . async_publish . reset_mock ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] [comment] [EOL] light . turn_on ( self . hass , [string] , brightness = [number] , rgb_color = [ [number] , [number] , [number] ] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] self . mock_publish . async_publish . reset_mock ( ) [EOL] [EOL] [comment] [EOL] light . turn_on ( self . hass , [string] , color_temp = [number] , white_value = [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_ON , state . state ) [EOL] self . assertEqual ( ( [number] , [number] , [number] ) , state . attributes [ [string] ] ) [EOL] self . assertEqual ( [number] , state . attributes [ [string] ] ) [EOL] self . assertEqual ( [number] , state . attributes [ [string] ] ) [EOL] self . assertEqual ( [number] , state . attributes [ [string] ] ) [EOL] [EOL] def test_flash ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , light . DOMAIN ) : [EOL] assert setup_component ( self . hass , light . DOMAIN , { light . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } } ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] [comment] [EOL] light . turn_on ( self . hass , [string] , flash = [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] self . mock_publish . async_publish . reset_mock ( ) [EOL] [EOL] [comment] [EOL] light . turn_on ( self . hass , [string] , flash = [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] [EOL] def test_transition ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , light . DOMAIN ) : [EOL] assert setup_component ( self . hass , light . DOMAIN , { light . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] [comment] [EOL] light . turn_on ( self . hass , [string] , transition = [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] self . mock_publish . async_publish . reset_mock ( ) [EOL] [EOL] [comment] [EOL] light . turn_off ( self . hass , [string] , transition = [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . mock_publish . async_publish . assert_called_once_with ( [string] , [string] , [number] , False ) [EOL] [EOL] def test_invalid_values ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , light . DOMAIN ) : [EOL] assert setup_component ( self . hass , light . DOMAIN , { light . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [string] [string] [string] [string] [string] [string] [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] , [string] : [string] [string] , [string] : [string] [string] , [string] : [string] , } } ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertIsNone ( state . attributes . get ( [string] ) ) [EOL] self . assertFalse ( state . attributes . get ( ATTR_ASSUMED_STATE ) ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_ON , state . state ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( ( [number] , [number] , [number] ) , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_ON , state . state ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( ( [number] , [number] , [number] ) , state . attributes . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [number] , state . attributes . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [string] , state . attributes . get ( [string] ) ) [EOL] [EOL] def test_default_availability_payload ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , light . DOMAIN , { light . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] def test_custom_availability_payload ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , light . DOMAIN , { light . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] import homeassistant . components . automation as automation [EOL] from homeassistant . core import callback [EOL] from homeassistant . setup import setup_component [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] from tests . common import ( get_test_home_assistant , mock_component , fire_time_changed , assert_setup_component ) [EOL] [EOL] [EOL] [comment] [EOL] class TestAutomationNumericState ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] mock_component ( self . hass , [string] ) [EOL] self . calls = [ ] [EOL] [EOL] @ callback def record_call ( service ) : [EOL] [docstring] [EOL] self . calls . append ( service ) [EOL] [EOL] self . hass . services . register ( [string] , [string] , record_call ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_if_fires_on_entity_change_below ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] automation . turn_off ( self . hass ) [EOL] self . hass . block_till_done ( ) [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_over_to_below ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entities_change_over_to_below ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [ [string] , [string] , ] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_fires_on_entity_change_below_to_below ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_below_fires_on_entity_change_to_equal ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_initial_entity_below ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_initial_entity_above ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_above ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_below_to_above ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_fires_on_entity_change_above_to_above ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_above_fires_on_entity_change_to_equal ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_below_range ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_below_above_range ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_over_to_below_range ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_over_to_below_above_range ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_fires_if_entity_not_match ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_below_with_attribute ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] , { [string] : [number] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_fires_on_entity_change_not_below_with_attribute ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [number] , { [string] : [number] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_attribute_change_with_attribute_below ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [string] , { [string] : [number] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_fires_on_attribute_change_with_attribute_not_below ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [string] , { [string] : [number] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_fires_on_entity_change_with_attribute_below ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [string] , { [string] : [number] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_fires_on_entity_change_with_not_attribute_below ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_fires_on_attr_change_with_attribute_below_and_multiple_attr ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_template_list ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [string] , { [string] : [ [number] , [number] , [number] ] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_template_string ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] , [string] : { [string] : [string] % [string] . join ( ( [string] , [string] , [string] , [string] , [string] , [string] ) ) } , } } } ) [EOL] self . hass . states . set ( [string] , [string] , { [string] : [string] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . hass . states . set ( [string] , [string] , { [string] : [string] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] self . assertEqual ( [string] [string] , self . calls [ [number] ] . data [ [string] ] ) [EOL] [EOL] def test_not_fires_on_attr_change_with_attr_not_below_multiple_attr ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [comment] [EOL] self . hass . states . set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_action ( self ) : [EOL] [docstring] [EOL] entity_id = [string] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : entity_id , [string] : [number] , [string] : [number] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] self . hass . states . set ( entity_id , [number] ) [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] self . hass . states . set ( entity_id , [number] ) [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] self . hass . states . set ( entity_id , [number] ) [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fails_setup_bad_for ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : { [string] : [number] } , } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] def test_if_fails_setup_for_without_above_below ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [number] } , } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] def test_if_not_fires_on_entity_change_with_for ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : { [string] : [number] } , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] fire_time_changed ( self . hass , dt_util . utcnow ( ) + timedelta ( seconds = [number] ) ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_not_fires_on_entities_change_with_for_after_stop ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [ [string] , [string] , ] , [string] : [number] , [string] : [number] , [string] : { [string] : [number] } , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] fire_time_changed ( self . hass , dt_util . utcnow ( ) + timedelta ( seconds = [number] ) ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] automation . turn_off ( self . hass ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] fire_time_changed ( self . hass , dt_util . utcnow ( ) + timedelta ( seconds = [number] ) ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_with_for_attribute_change ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : { [string] : [number] } , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] utcnow = dt_util . utcnow ( ) [EOL] with patch ( [string] ) as mock_utcnow : [EOL] mock_utcnow . return_value = utcnow [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] mock_utcnow . return_value += timedelta ( seconds = [number] ) [EOL] fire_time_changed ( self . hass , mock_utcnow . return_value ) [EOL] self . hass . states . set ( [string] , [number] , attributes = { [string] : [string] } ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] mock_utcnow . return_value += timedelta ( seconds = [number] ) [EOL] fire_time_changed ( self . hass , mock_utcnow . return_value ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_fires_on_entity_change_with_for ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : { [string] : [number] } , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] fire_time_changed ( self . hass , dt_util . utcnow ( ) + timedelta ( seconds = [number] ) ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_wait_template_with_trigger ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : [ { [string] : [string] } , { [string] : [string] , [string] : { [string] : [string] % [string] . join ( ( [string] , [string] , [string] ) ) } } ] , } } ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] self . calls = [ ] [EOL] [EOL] self . hass . states . set ( [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . hass . states . set ( [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] self . assertEqual ( [string] , self . calls [ [number] ] . data [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from unittest . mock import patch , PropertyMock [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components import camera , image_processing as ip [EOL] from homeassistant . components . image_processing . openalpr_cloud import ( OPENALPR_API_URL ) [EOL] [EOL] from tests . common import ( get_test_home_assistant , assert_setup_component , load_fixture , mock_coro ) [EOL] [EOL] [EOL] class TestOpenAlprCloudSetup : [EOL] [docstring] [EOL] [EOL] def setup_method ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def teardown_method ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_platform ( self ) : [EOL] [docstring] [EOL] config = { ip . DOMAIN : { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] } , } [EOL] [EOL] with assert_setup_component ( [number] , ip . DOMAIN ) : [EOL] setup_component ( self . hass , ip . DOMAIN , config ) [EOL] [EOL] assert self . hass . states . get ( [string] ) [EOL] [EOL] def test_setup_platform_name ( self ) : [EOL] [docstring] [EOL] config = { ip . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] } , } [EOL] [EOL] with assert_setup_component ( [number] , ip . DOMAIN ) : [EOL] setup_component ( self . hass , ip . DOMAIN , config ) [EOL] [EOL] assert self . hass . states . get ( [string] ) [EOL] [EOL] def test_setup_platform_without_api_key ( self ) : [EOL] [docstring] [EOL] config = { ip . DOMAIN : { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , } , [string] : { [string] : [string] } , } [EOL] [EOL] with assert_setup_component ( [number] , ip . DOMAIN ) : [EOL] setup_component ( self . hass , ip . DOMAIN , config ) [EOL] [EOL] def test_setup_platform_without_region ( self ) : [EOL] [docstring] [EOL] config = { ip . DOMAIN : { [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , } , [string] : { [string] : [string] } , } [EOL] [EOL] with assert_setup_component ( [number] , ip . DOMAIN ) : [EOL] setup_component ( self . hass , ip . DOMAIN , config ) [EOL] [EOL] [EOL] class TestOpenAlprCloud : [EOL] [docstring] [EOL] [EOL] def setup_method ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] config = { ip . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] } , } [EOL] [EOL] with patch ( [string] [string] , new_callable = PropertyMock ( return_value = False ) ) : [EOL] setup_component ( self . hass , ip . DOMAIN , config ) [EOL] [EOL] self . alpr_events = [ ] [EOL] [EOL] @ callback def mock_alpr_event ( event ) : [EOL] [docstring] [EOL] self . alpr_events . append ( event ) [EOL] [EOL] self . hass . bus . listen ( [string] , mock_alpr_event ) [EOL] [EOL] self . params = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] } [EOL] [EOL] def teardown_method ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_openalpr_process_image ( self , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . post ( OPENALPR_API_URL , params = self . params , text = load_fixture ( [string] ) , status = [number] ) [EOL] [EOL] with patch ( [string] , return_value = mock_coro ( camera . Image ( [string] , [string] ) ) ) : [EOL] ip . scan ( self . hass , entity_id = [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] assert len ( self . alpr_events ) == [number] [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] assert state . state == [string] [EOL] [EOL] event_data = [ event . data for event in self . alpr_events if event . data . get ( [string] ) == [string] ] [EOL] assert len ( event_data ) == [number] [EOL] assert event_data [ [number] ] [ [string] ] == [string] [EOL] assert event_data [ [number] ] [ [string] ] == float ( [number] ) [EOL] assert event_data [ [number] ] [ [string] ] == [string] [EOL] [EOL] def test_openalpr_process_image_api_error ( self , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . post ( OPENALPR_API_URL , params = self . params , text = [string] , status = [number] ) [EOL] [EOL] with patch ( [string] , return_value = mock_coro ( camera . Image ( [string] , [string] ) ) ) : [EOL] ip . scan ( self . hass , entity_id = [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] assert len ( self . alpr_events ) == [number] [EOL] [EOL] def test_openalpr_process_image_api_timeout ( self , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . post ( OPENALPR_API_URL , params = self . params , exc = asyncio . TimeoutError ( ) ) [EOL] [EOL] with patch ( [string] , return_value = mock_coro ( camera . Image ( [string] , [string] ) ) ) : [EOL] ip . scan ( self . hass , entity_id = [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( aioclient_mock . mock_calls ) == [number] [EOL] assert len ( self . alpr_events ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . const import STATE_ON , STATE_OFF [EOL] from tests . common import MockToggleDevice [EOL] [EOL] [EOL] DEVICES = [ ] [EOL] [EOL] [EOL] def init ( empty = False ) : [EOL] [docstring] [EOL] global DEVICES [EOL] [EOL] DEVICES = [ ] if empty else [ MockToggleDevice ( [string] , STATE_ON ) , MockToggleDevice ( [string] , STATE_OFF ) , MockToggleDevice ( None , STATE_OFF ) ] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices_callback , discovery_info = None ) : [EOL] [docstring] [EOL] async_add_devices_callback ( DEVICES ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 0 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any [EOL] import logging [EOL] import typing [EOL] import asyncio [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import os [EOL] from typing import Dict , Optional [EOL] [EOL] from homeassistant . const import EVENT_HOMEASSISTANT_STOP [EOL] from homeassistant . core import callback [EOL] from homeassistant . loader import bind_hass [EOL] from homeassistant . util import json [EOL] from homeassistant . helpers . event import async_call_later [EOL] [EOL] STORAGE_DIR = [string] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ bind_hass async def async_migrator ( hass , old_path , store , * , old_conf_migrate_func = None ) : [EOL] [docstring] [EOL] def load_old_config ( ) : [EOL] [docstring] [EOL] if not os . path . isfile ( old_path ) : [EOL] return None [EOL] [EOL] return json . load_json ( old_path ) [EOL] [EOL] config = await hass . async_add_executor_job ( load_old_config ) [EOL] [EOL] if config is None : [EOL] return await store . async_load ( ) [EOL] [EOL] if old_conf_migrate_func is not None : [EOL] config = await old_conf_migrate_func ( config ) [EOL] [EOL] await store . async_save ( config ) [EOL] await hass . async_add_executor_job ( os . remove , old_path ) [EOL] return config [EOL] [EOL] [EOL] @ bind_hass class Store : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , version , key ) : [EOL] [docstring] [EOL] self . version = version [EOL] self . key = key [EOL] self . hass = hass [EOL] self . _data = None [EOL] self . _unsub_delay_listener = None [EOL] self . _unsub_stop_listener = None [EOL] self . _write_lock = asyncio . Lock ( ) [EOL] self . _load_task = None [EOL] [EOL] @ property def path ( self ) : [EOL] [docstring] [EOL] return self . hass . config . path ( STORAGE_DIR , self . key ) [EOL] [EOL] async def async_load ( self ) : [EOL] [docstring] [EOL] if self . _load_task is None : [EOL] self . _load_task = self . hass . async_add_job ( self . _async_load ( ) ) [EOL] [EOL] return await self . _load_task [EOL] [EOL] async def _async_load ( self ) : [EOL] [docstring] [EOL] if self . _data is not None : [EOL] data = self . _data [EOL] else : [EOL] data = await self . hass . async_add_executor_job ( json . load_json , self . path ) [EOL] [EOL] if data == { } : [EOL] return None [EOL] if data [ [string] ] == self . version : [EOL] stored = data [ [string] ] [EOL] else : [EOL] _LOGGER . info ( [string] , self . key , data [ [string] ] , self . version ) [EOL] stored = await self . _async_migrate_func ( data [ [string] ] , data [ [string] ] ) [EOL] [EOL] self . _load_task = None [EOL] return stored [EOL] [EOL] async def async_save ( self , data , * , delay = None ) : [EOL] [docstring] [EOL] self . _data = { [string] : self . version , [string] : self . key , [string] : data , } [EOL] [EOL] self . _async_cleanup_delay_listener ( ) [EOL] [EOL] if delay is None : [EOL] self . _async_cleanup_stop_listener ( ) [EOL] await self . _async_handle_write_data ( ) [EOL] return [EOL] [EOL] self . _unsub_delay_listener = async_call_later ( self . hass , delay , self . _async_callback_delayed_write ) [EOL] [EOL] self . _async_ensure_stop_listener ( ) [EOL] [EOL] @ callback def _async_ensure_stop_listener ( self ) : [EOL] [docstring] [EOL] if self . _unsub_stop_listener is None : [EOL] self . _unsub_stop_listener = self . hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , self . _async_callback_stop_write ) [EOL] [EOL] @ callback def _async_cleanup_stop_listener ( self ) : [EOL] [docstring] [EOL] if self . _unsub_stop_listener is not None : [EOL] self . _unsub_stop_listener ( ) [EOL] self . _unsub_stop_listener = None [EOL] [EOL] @ callback def _async_cleanup_delay_listener ( self ) : [EOL] [docstring] [EOL] if self . _unsub_delay_listener is not None : [EOL] self . _unsub_delay_listener ( ) [EOL] self . _unsub_delay_listener = None [EOL] [EOL] async def _async_callback_delayed_write ( self , _now ) : [EOL] [docstring] [EOL] self . _unsub_delay_listener = None [EOL] self . _async_cleanup_stop_listener ( ) [EOL] await self . _async_handle_write_data ( ) [EOL] [EOL] async def _async_callback_stop_write ( self , _event ) : [EOL] [docstring] [EOL] self . _unsub_stop_listener = None [EOL] self . _async_cleanup_delay_listener ( ) [EOL] await self . _async_handle_write_data ( ) [EOL] [EOL] async def _async_handle_write_data ( self , * _args ) : [EOL] [docstring] [EOL] data = self . _data [EOL] self . _data = None [EOL] [EOL] async with self . _write_lock : [EOL] try : [EOL] await self . hass . async_add_executor_job ( self . _write_data , self . path , data ) [EOL] except ( json . SerializationError , json . WriteError ) as err : [EOL] _LOGGER . error ( [string] , self . key , err ) [EOL] [EOL] def _write_data ( self , path , data ) : [EOL] [docstring] [EOL] if not os . path . isdir ( os . path . dirname ( path ) ) : [EOL] os . makedirs ( os . path . dirname ( path ) ) [EOL] [EOL] _LOGGER . debug ( [string] , self . key ) [EOL] json . save_json ( path , data ) [EOL] [EOL] async def _async_migrate_func ( self , old_version , old_data ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.locks.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Generator , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import aiohttp [EOL] from aiohttp import hdrs [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_TIMEOUT , CONF_USERNAME , CONF_PASSWORD , CONF_URL , CONF_PAYLOAD , CONF_METHOD , CONF_HEADERS ) [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_TIMEOUT = [number] [EOL] DEFAULT_METHOD = [string] [EOL] [EOL] SUPPORT_REST_METHODS = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] CONF_CONTENT_TYPE = [string] [EOL] [EOL] COMMAND_SCHEMA = vol . Schema ( { vol . Required ( CONF_URL ) : cv . template , vol . Optional ( CONF_METHOD , default = DEFAULT_METHOD ) : vol . All ( vol . Lower , vol . In ( SUPPORT_REST_METHODS ) ) , vol . Optional ( CONF_HEADERS ) : vol . Schema ( { cv . string : cv . string } ) , vol . Inclusive ( CONF_USERNAME , [string] ) : cv . string , vol . Inclusive ( CONF_PASSWORD , [string] ) : cv . string , vol . Optional ( CONF_PAYLOAD ) : cv . template , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : vol . Coerce ( int ) , vol . Optional ( CONF_CONTENT_TYPE ) : cv . string } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { cv . slug : COMMAND_SCHEMA , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] websession = async_get_clientsession ( hass ) [EOL] [EOL] def async_register_rest_command ( name , command_config ) : [EOL] [docstring] [EOL] timeout = command_config [ CONF_TIMEOUT ] [EOL] method = command_config [ CONF_METHOD ] [EOL] [EOL] template_url = command_config [ CONF_URL ] [EOL] template_url . hass = hass [EOL] [EOL] auth = None [EOL] if CONF_USERNAME in command_config : [EOL] username = command_config [ CONF_USERNAME ] [EOL] password = command_config . get ( CONF_PASSWORD , [string] ) [EOL] auth = aiohttp . BasicAuth ( username , password = password ) [EOL] [EOL] template_payload = None [EOL] if CONF_PAYLOAD in command_config : [EOL] template_payload = command_config [ CONF_PAYLOAD ] [EOL] template_payload . hass = hass [EOL] [EOL] headers = None [EOL] if CONF_HEADERS in command_config : [EOL] headers = command_config [ CONF_HEADERS ] [EOL] [EOL] if CONF_CONTENT_TYPE in command_config : [EOL] content_type = command_config [ CONF_CONTENT_TYPE ] [EOL] if headers is None : [EOL] headers = { } [EOL] headers [ hdrs . CONTENT_TYPE ] = content_type [EOL] [EOL] @ asyncio . coroutine def async_service_handler ( service ) : [EOL] [docstring] [EOL] payload = None [EOL] if template_payload : [EOL] payload = bytes ( template_payload . async_render ( variables = service . data ) , [string] ) [EOL] [EOL] try : [EOL] with async_timeout . timeout ( timeout , loop = hass . loop ) : [EOL] request = yield from getattr ( websession , method ) ( template_url . async_render ( variables = service . data ) , data = payload , auth = auth , headers = headers ) [EOL] [EOL] if request . status < [number] : [EOL] _LOGGER . info ( [string] , request . url ) [EOL] else : [EOL] _LOGGER . warning ( [string] , request . status , request . url ) [EOL] [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . warning ( [string] , request . url ) [EOL] [EOL] except aiohttp . ClientError : [EOL] _LOGGER . error ( [string] , request . url ) [EOL] [EOL] [comment] [EOL] hass . services . async_register ( DOMAIN , name , async_service_handler ) [EOL] [EOL] for command , command_config in config [ DOMAIN ] . items ( ) : [EOL] async_register_rest_command ( command , command_config ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Generator , Any [EOL] import logging [EOL] import typing [EOL] import xml [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import CONF_HOST , CONF_PASSWORD , CONF_DOMAIN [EOL] from homeassistant . helpers . event import async_track_time_interval [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] UPDATE_URL = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_DOMAIN ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_HOST , default = [string] ) : cv . string , } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] host = config [ DOMAIN ] [ CONF_HOST ] [EOL] domain = config [ DOMAIN ] [ CONF_DOMAIN ] [EOL] password = config [ DOMAIN ] [ CONF_PASSWORD ] [EOL] [EOL] session = async_get_clientsession ( hass ) [EOL] [EOL] result = yield from _update_namecheapdns ( session , host , domain , password ) [EOL] [EOL] if not result : [EOL] return False [EOL] [EOL] @ asyncio . coroutine def update_domain_interval ( now ) : [EOL] [docstring] [EOL] yield from _update_namecheapdns ( session , host , domain , password ) [EOL] [EOL] async_track_time_interval ( hass , update_domain_interval , INTERVAL ) [EOL] [EOL] return result [EOL] [EOL] [EOL] @ asyncio . coroutine def _update_namecheapdns ( session , host , domain , password ) : [EOL] [docstring] [EOL] import xml . etree . ElementTree as ET [EOL] [EOL] params = { [string] : host , [string] : domain , [string] : password , } [EOL] [EOL] resp = yield from session . get ( UPDATE_URL , params = params ) [EOL] xml_string = yield from resp . text ( ) [EOL] root = ET . fromstring ( xml_string ) [EOL] err_count = root . find ( [string] ) . text [EOL] [EOL] if int ( err_count ) != [number] : [EOL] _LOGGER . warning ( [string] , domain ) [EOL] return False [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Generator , Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( CONF_DOMAIN , CONF_PASSWORD , CONF_TIMEOUT , CONF_USERNAME ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] DEFAULT_TIMEOUT = [number] [EOL] [EOL] UPDATE_URL = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_DOMAIN ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int , } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup ( hass , config ) : [EOL] [docstring] [EOL] domain = config [ DOMAIN ] . get ( CONF_DOMAIN ) [EOL] user = config [ DOMAIN ] . get ( CONF_USERNAME ) [EOL] password = config [ DOMAIN ] . get ( CONF_PASSWORD ) [EOL] timeout = config [ DOMAIN ] . get ( CONF_TIMEOUT ) [EOL] [EOL] session = hass . helpers . aiohttp_client . async_get_clientsession ( ) [EOL] [EOL] result = yield from _update_google_domains ( hass , session , domain , user , password , timeout ) [EOL] [EOL] if not result : [EOL] return False [EOL] [EOL] @ asyncio . coroutine def update_domain_interval ( now ) : [EOL] [docstring] [EOL] yield from _update_google_domains ( hass , session , domain , user , password , timeout ) [EOL] [EOL] hass . helpers . event . async_track_time_interval ( update_domain_interval , INTERVAL ) [EOL] [EOL] return True [EOL] [EOL] [EOL] @ asyncio . coroutine def _update_google_domains ( hass , session , domain , user , password , timeout ) : [EOL] [docstring] [EOL] url = UPDATE_URL . format ( user , password ) [EOL] [EOL] params = { [string] : domain } [EOL] [EOL] try : [EOL] with async_timeout . timeout ( timeout , loop = hass . loop ) : [EOL] resp = yield from session . get ( url , params = params ) [EOL] body = yield from resp . text ( ) [EOL] [EOL] if body . startswith ( [string] ) or body . startswith ( [string] ) : [EOL] return True [EOL] [EOL] _LOGGER . warning ( [string] , domain , body ) [EOL] [EOL] except aiohttp . ClientError : [EOL] _LOGGER . warning ( [string] ) [EOL] [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . warning ( [string] , domain ) [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . alarm_control_panel import ( PLATFORM_SCHEMA , AlarmControlPanel ) [EOL] from homeassistant . const import ( CONF_CODE , CONF_NAME , CONF_PASSWORD , CONF_USERNAME , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_UNKNOWN ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] ATTR_ALARM_ACTIVE = [string] [EOL] ATTR_TEMPERATURE = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_CODE ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from simplipy . api import SimpliSafeApiInterface , SimpliSafeAPIException [EOL] name = config . get ( CONF_NAME ) [EOL] code = config . get ( CONF_CODE ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] try : [EOL] simplisafe = SimpliSafeApiInterface ( username , password ) [EOL] except SimpliSafeAPIException : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] systems = [ ] [EOL] [EOL] for system in simplisafe . get_systems ( ) : [EOL] systems . append ( SimpliSafeAlarm ( system , name , code ) ) [EOL] [EOL] add_devices ( systems ) [EOL] [EOL] [EOL] class SimpliSafeAlarm ( AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , simplisafe , name , code ) : [EOL] [docstring] [EOL] self . simplisafe = simplisafe [EOL] self . _name = name [EOL] self . _code = str ( code ) if code else None [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . simplisafe . location_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] if self . _name is not None : [EOL] return self . _name [EOL] return [string] . format ( self . simplisafe . location_id ) [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] if self . _code is None : [EOL] return None [EOL] if isinstance ( self . _code , str ) and re . search ( [string] , self . _code ) : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] status = self . simplisafe . state [EOL] if status . lower ( ) == [string] : [EOL] state = STATE_ALARM_DISARMED [EOL] elif status . lower ( ) == [string] or status . lower ( ) == [string] : [EOL] state = STATE_ALARM_ARMED_HOME [EOL] elif ( status . lower ( ) == [string] or status . lower ( ) == [string] or status . lower ( ) == [string] ) : [EOL] state = STATE_ALARM_ARMED_AWAY [EOL] else : [EOL] state = STATE_UNKNOWN [EOL] return state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = { } [EOL] [EOL] attributes [ ATTR_ALARM_ACTIVE ] = self . simplisafe . alarm_active [EOL] if self . simplisafe . temperature is not None : [EOL] attributes [ ATTR_TEMPERATURE ] = self . simplisafe . temperature [EOL] [EOL] return attributes [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . simplisafe . update ( ) [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , [string] ) : [EOL] return [EOL] self . simplisafe . set_state ( [string] ) [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , [string] ) : [EOL] return [EOL] self . simplisafe . set_state ( [string] ) [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , [string] ) : [EOL] return [EOL] self . simplisafe . set_state ( [string] ) [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] def _validate_code ( self , code , state ) : [EOL] [docstring] [EOL] check = self . _code is None or code == self . _code [EOL] if not check : [EOL] _LOGGER . warning ( [string] , state ) [EOL] return check [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] import homeassistant [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . dyson import DYSON_DEVICES [EOL] from homeassistant . components . vacuum import ( SUPPORT_BATTERY , SUPPORT_FAN_SPEED , SUPPORT_PAUSE , SUPPORT_RETURN_HOME , SUPPORT_STATUS , SUPPORT_STOP , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , VacuumDevice ) [EOL] from homeassistant . helpers . icon import icon_for_battery_level [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_CLEAN_ID = [string] [EOL] ATTR_FULL_CLEAN_TYPE = [string] [EOL] ATTR_POSITION = [string] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] DYSON_360_EYE_DEVICES = [string] [EOL] [EOL] SUPPORT_DYSON = SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_PAUSE | SUPPORT_RETURN_HOME | SUPPORT_FAN_SPEED | SUPPORT_STATUS | SUPPORT_BATTERY | SUPPORT_STOP [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from libpurecoollink . dyson_360_eye import Dyson360Eye [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] if DYSON_360_EYE_DEVICES not in hass . data : [EOL] hass . data [ DYSON_360_EYE_DEVICES ] = [ ] [EOL] [EOL] [comment] [EOL] for device in [ d for d in hass . data [ DYSON_DEVICES ] if isinstance ( d , Dyson360Eye ) ] : [EOL] dyson_entity = Dyson360EyeDevice ( device ) [EOL] hass . data [ DYSON_360_EYE_DEVICES ] . append ( dyson_entity ) [EOL] [EOL] add_devices ( hass . data [ DYSON_360_EYE_DEVICES ] ) [EOL] return True [EOL] [EOL] [EOL] class Dyson360EyeDevice ( VacuumDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , device . name ) [EOL] self . _device = device [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . async_add_job ( self . _device . add_message_listener , self . on_message ) [EOL] [EOL] def on_message ( self , message ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . name , message ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _device . name [EOL] [EOL] @ property def status ( self ) : [EOL] [docstring] [EOL] from libpurecoollink . const import Dyson360EyeMode [EOL] dyson_labels = { Dyson360EyeMode . INACTIVE_CHARGING : [string] , Dyson360EyeMode . INACTIVE_CHARGED : [string] , Dyson360EyeMode . FULL_CLEAN_PAUSED : [string] , Dyson360EyeMode . FULL_CLEAN_RUNNING : [string] , Dyson360EyeMode . FULL_CLEAN_ABORTED : [string] , Dyson360EyeMode . FULL_CLEAN_INITIATED : [string] , Dyson360EyeMode . FAULT_USER_RECOVERABLE : [string] , Dyson360EyeMode . FAULT_REPLACE_ON_DOCK : [string] , Dyson360EyeMode . FULL_CLEAN_FINISHED : [string] , Dyson360EyeMode . FULL_CLEAN_NEEDS_CHARGE : [string] } [EOL] return dyson_labels . get ( self . _device . state . state , self . _device . state . state ) [EOL] [EOL] @ property def battery_level ( self ) : [EOL] [docstring] [EOL] return self . _device . state . battery_level [EOL] [EOL] @ property def fan_speed ( self ) : [EOL] [docstring] [EOL] from libpurecoollink . const import PowerMode [EOL] speed_labels = { PowerMode . MAX : [string] , PowerMode . QUIET : [string] } [EOL] return speed_labels [ self . _device . state . power_mode ] [EOL] [EOL] @ property def fan_speed_list ( self ) : [EOL] [docstring] [EOL] return [ [string] , [string] ] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_POSITION : str ( self . _device . state . position ) } [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] from libpurecoollink . const import Dyson360EyeMode [EOL] [EOL] return self . _device . state . state in [ Dyson360EyeMode . FULL_CLEAN_INITIATED , Dyson360EyeMode . FULL_CLEAN_ABORTED , Dyson360EyeMode . FULL_CLEAN_RUNNING ] [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_DYSON [EOL] [EOL] @ property def battery_icon ( self ) : [EOL] [docstring] [EOL] from libpurecoollink . const import Dyson360EyeMode [EOL] [EOL] charging = self . _device . state . state in [ Dyson360EyeMode . INACTIVE_CHARGING ] [EOL] return icon_for_battery_level ( battery_level = self . battery_level , charging = charging ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] from libpurecoollink . const import Dyson360EyeMode [EOL] [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] if self . _device . state . state in [ Dyson360EyeMode . FULL_CLEAN_PAUSED ] : [EOL] self . _device . resume ( ) [EOL] else : [EOL] self . _device . start ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] self . _device . pause ( ) [EOL] [EOL] def stop ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] self . _device . pause ( ) [EOL] [EOL] def set_fan_speed ( self , fan_speed , ** kwargs ) : [EOL] [docstring] [EOL] from libpurecoollink . const import PowerMode [EOL] [EOL] _LOGGER . debug ( [string] , fan_speed , self . name ) [EOL] power_modes = { [string] : PowerMode . QUIET , [string] : PowerMode . MAX } [EOL] self . _device . set_power_mode ( power_modes [ fan_speed ] ) [EOL] [EOL] def start_pause ( self , ** kwargs ) : [EOL] [docstring] [EOL] from libpurecoollink . const import Dyson360EyeMode [EOL] [EOL] if self . _device . state . state in [ Dyson360EyeMode . FULL_CLEAN_PAUSED ] : [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] self . _device . resume ( ) [EOL] elif self . _device . state . state in [ Dyson360EyeMode . INACTIVE_CHARGED , Dyson360EyeMode . INACTIVE_CHARGING ] : [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] self . _device . start ( ) [EOL] else : [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] self . _device . pause ( ) [EOL] [EOL] def return_to_base ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] self . _device . abort ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] from itertools import filterfalse [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . lock import ( LockDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_PASSWORD , CONF_USERNAME ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_ADDRESS = [string] [EOL] ATTR_LOCATION_ID = [string] [EOL] EVENT_DOOR_BELL = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from pynello import Nello [EOL] nello = Nello ( config . get ( CONF_USERNAME ) , config . get ( CONF_PASSWORD ) ) [EOL] add_devices ( [ NelloLock ( lock ) for lock in nello . locations ] , True ) [EOL] [EOL] [EOL] class NelloLock ( LockDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , nello_lock ) : [EOL] [docstring] [EOL] self . _nello_lock = nello_lock [EOL] self . _device_attrs = None [EOL] self . _activity = None [EOL] self . _name = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_locked ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _device_attrs [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _nello_lock . update ( ) [EOL] [comment] [EOL] location_id = self . _nello_lock . location_id [EOL] short_id = self . _nello_lock . short_id [EOL] address = self . _nello_lock . address [EOL] self . _name = [string] . format ( short_id ) [EOL] self . _device_attrs = { ATTR_ADDRESS : address , ATTR_LOCATION_ID : location_id } [EOL] [comment] [EOL] activity = self . _nello_lock . activity [EOL] if self . _activity : [EOL] [comment] [EOL] new_activity = list ( filterfalse ( lambda x : x in self . _activity , activity ) ) [EOL] if new_activity : [EOL] for act in new_activity : [EOL] activity_type = act . get ( [string] ) [EOL] if activity_type == [string] : [EOL] event_data = { [string] : address , [string] : act . get ( [string] ) , [string] : act . get ( [string] ) , [string] : location_id , [string] : short_id } [EOL] self . hass . bus . fire ( EVENT_DOOR_BELL , event_data ) [EOL] [comment] [EOL] self . _activity = activity [EOL] [EOL] def unlock ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _nello_lock . open_door ( ) : [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
import builtins [EOL] from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . climate import ( ClimateDevice , DOMAIN , SUPPORT_HOLD_MODE , SUPPORT_OPERATION_MODE , SUPPORT_TARGET_TEMPERATURE , STATE_AUTO , STATE_HEAT , STATE_IDLE ) [EOL] from homeassistant . components . nuheat import DOMAIN as NUHEAT_DOMAIN [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_TEMPERATURE , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ICON = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] [comment] [EOL] MODE_AUTO = STATE_AUTO [comment] [EOL] MODE_HOLD_TEMPERATURE = [string] [EOL] MODE_TEMPORARY_HOLD = [string] [EOL] [EOL] OPERATION_LIST = [ STATE_HEAT , STATE_IDLE ] [EOL] [EOL] SCHEDULE_HOLD = [number] [EOL] SCHEDULE_RUN = [number] [EOL] SCHEDULE_TEMPORARY_HOLD = [number] [EOL] [EOL] SERVICE_RESUME_PROGRAM = [string] [EOL] [EOL] RESUME_PROGRAM_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids } ) [EOL] [EOL] SUPPORT_FLAGS = ( SUPPORT_TARGET_TEMPERATURE | SUPPORT_HOLD_MODE | SUPPORT_OPERATION_MODE ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] temperature_unit = hass . config . units . temperature_unit [EOL] api , serial_numbers = hass . data [ NUHEAT_DOMAIN ] [EOL] thermostats = [ NuHeatThermostat ( api , serial_number , temperature_unit ) for serial_number in serial_numbers ] [EOL] add_devices ( thermostats , True ) [EOL] [EOL] def resume_program_set_service ( service ) : [EOL] [docstring] [EOL] entity_id = service . data . get ( ATTR_ENTITY_ID ) [EOL] if entity_id : [EOL] target_thermostats = [ device for device in thermostats if device . entity_id in entity_id ] [EOL] else : [EOL] target_thermostats = thermostats [EOL] [EOL] for thermostat in target_thermostats : [EOL] thermostat . resume_program ( ) [EOL] [EOL] thermostat . schedule_update_ha_state ( True ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_RESUME_PROGRAM , resume_program_set_service , schema = RESUME_PROGRAM_SCHEMA ) [EOL] [EOL] [EOL] class NuHeatThermostat ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api , serial_number , temperature_unit ) : [EOL] [docstring] [EOL] self . _thermostat = api . get_thermostat ( serial_number ) [EOL] self . _temperature_unit = temperature_unit [EOL] self . _force_update = False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _thermostat . room [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FLAGS [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return TEMP_CELSIUS [EOL] [EOL] return TEMP_FAHRENHEIT [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return self . _thermostat . celsius [EOL] [EOL] return self . _thermostat . fahrenheit [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] if self . _thermostat . heating : [EOL] return STATE_HEAT [EOL] [EOL] return STATE_IDLE [EOL] [EOL] @ property def min_temp ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return self . _thermostat . min_celsius [EOL] [EOL] return self . _thermostat . min_fahrenheit [EOL] [EOL] @ property def max_temp ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return self . _thermostat . max_celsius [EOL] [EOL] return self . _thermostat . max_fahrenheit [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return self . _thermostat . target_celsius [EOL] [EOL] return self . _thermostat . target_fahrenheit [EOL] [EOL] @ property def current_hold_mode ( self ) : [EOL] [docstring] [EOL] schedule_mode = self . _thermostat . schedule_mode [EOL] if schedule_mode == SCHEDULE_RUN : [EOL] return MODE_AUTO [EOL] [EOL] if schedule_mode == SCHEDULE_HOLD : [EOL] return MODE_HOLD_TEMPERATURE [EOL] [EOL] if schedule_mode == SCHEDULE_TEMPORARY_HOLD : [EOL] return MODE_TEMPORARY_HOLD [EOL] [EOL] return MODE_AUTO [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return OPERATION_LIST [EOL] [EOL] def resume_program ( self ) : [EOL] [docstring] [EOL] self . _thermostat . resume_schedule ( ) [EOL] self . _force_update = True [EOL] [EOL] def set_hold_mode ( self , hold_mode ) : [EOL] [docstring] [EOL] if hold_mode == MODE_AUTO : [EOL] schedule_mode = SCHEDULE_RUN [EOL] [EOL] if hold_mode == MODE_HOLD_TEMPERATURE : [EOL] schedule_mode = SCHEDULE_HOLD [EOL] [EOL] if hold_mode == MODE_TEMPORARY_HOLD : [EOL] schedule_mode = SCHEDULE_TEMPORARY_HOLD [EOL] [EOL] self . _thermostat . schedule_mode = schedule_mode [EOL] self . _force_update = True [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if self . _temperature_unit == [string] : [EOL] self . _thermostat . target_celsius = temperature [EOL] else : [EOL] self . _thermostat . target_fahrenheit = temperature [EOL] [EOL] _LOGGER . debug ( [string] , temperature , self . temperature_unit ) [EOL] [EOL] self . _force_update = True [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . _force_update : [EOL] self . _throttled_update ( no_throttle = True ) [EOL] self . _force_update = False [EOL] else : [EOL] self . _throttled_update ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def _throttled_update ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _thermostat . get_data ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from homeassistant . components . climate import ( ATTR_TEMPERATURE , ENTITY_ID_FORMAT , STATE_AUTO , STATE_COOL , STATE_ECO , STATE_ELECTRIC , STATE_FAN_ONLY , STATE_GAS , STATE_HEAT , STATE_HEAT_PUMP , STATE_HIGH_DEMAND , STATE_PERFORMANCE , SUPPORT_FAN_MODE , SUPPORT_ON_OFF , SUPPORT_OPERATION_MODE , SUPPORT_TARGET_TEMPERATURE , ClimateDevice ) [EOL] from homeassistant . components . fan import SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH [EOL] from homeassistant . components . tuya import DATA_TUYA , TuyaDevice [EOL] [EOL] from homeassistant . const import ( PRECISION_WHOLE , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] DEVICE_TYPE = [string] [EOL] [EOL] HA_STATE_TO_TUYA = { STATE_AUTO : [string] , STATE_COOL : [string] , STATE_ECO : [string] , STATE_ELECTRIC : [string] , STATE_FAN_ONLY : [string] , STATE_GAS : [string] , STATE_HEAT : [string] , STATE_HEAT_PUMP : [string] , STATE_HIGH_DEMAND : [string] , STATE_PERFORMANCE : [string] , } [EOL] [EOL] TUYA_STATE_TO_HA = { value : key for key , value in HA_STATE_TO_TUYA . items ( ) } [EOL] [EOL] FAN_MODES = { SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] tuya = hass . data [ DATA_TUYA ] [EOL] dev_ids = discovery_info . get ( [string] ) [EOL] devices = [ ] [EOL] for dev_id in dev_ids : [EOL] device = tuya . get_device_by_id ( dev_id ) [EOL] if device is None : [EOL] continue [EOL] devices . append ( TuyaClimateDevice ( device ) ) [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class TuyaClimateDevice ( TuyaDevice , ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tuya ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( tuya ) [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( tuya . object_id ( ) ) [EOL] self . operations = [ ] [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] await super ( ) . async_added_to_hass ( ) [EOL] modes = self . tuya . operation_list ( ) [EOL] if modes is None : [EOL] return [EOL] for mode in modes : [EOL] if mode in TUYA_STATE_TO_HA : [EOL] self . operations . append ( TUYA_STATE_TO_HA [ mode ] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . tuya . state ( ) [EOL] [EOL] @ property def precision ( self ) : [EOL] [docstring] [EOL] return PRECISION_WHOLE [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] unit = self . tuya . temperature_unit ( ) [EOL] if unit == [string] : [EOL] return TEMP_CELSIUS [EOL] if unit == [string] : [EOL] return TEMP_FAHRENHEIT [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] mode = self . tuya . current_operation ( ) [EOL] if mode is None : [EOL] return None [EOL] return TUYA_STATE_TO_HA . get ( mode ) [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return self . operations [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . tuya . current_temperature ( ) [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . tuya . target_temperature ( ) [EOL] [EOL] @ property def target_temperature_step ( self ) : [EOL] [docstring] [EOL] return self . tuya . target_temperature_step ( ) [EOL] [EOL] @ property def current_fan_mode ( self ) : [EOL] [docstring] [EOL] return self . tuya . current_fan_mode ( ) [EOL] [EOL] @ property def fan_list ( self ) : [EOL] [docstring] [EOL] return self . tuya . fan_list ( ) [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_TEMPERATURE in kwargs : [EOL] self . tuya . set_temperature ( kwargs [ ATTR_TEMPERATURE ] ) [EOL] [EOL] def set_fan_mode ( self , fan_mode ) : [EOL] [docstring] [EOL] self . tuya . set_fan_mode ( fan_mode ) [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] self . tuya . set_operation_mode ( HA_STATE_TO_TUYA . get ( operation_mode ) ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . tuya . turn_on ( ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . tuya . turn_off ( ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] supports = SUPPORT_ON_OFF [EOL] if self . tuya . support_target_temperature ( ) : [EOL] supports = supports | SUPPORT_TARGET_TEMPERATURE [EOL] if self . tuya . support_mode ( ) : [EOL] supports = supports | SUPPORT_OPERATION_MODE [EOL] if self . tuya . support_wind_speed ( ) : [EOL] supports = supports | SUPPORT_FAN_MODE [EOL] return supports [EOL] [EOL] @ property def min_temp ( self ) : [EOL] [docstring] [EOL] return self . tuya . min_temp ( ) [EOL] [EOL] @ property def max_temp ( self ) : [EOL] [docstring] [EOL] return self . tuya . max_temp ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Dict , Any , Generator [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from homeassistant . components import zha [EOL] from homeassistant . components . fan import ( DOMAIN , FanEntity , SPEED_OFF , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH , SUPPORT_SET_SPEED ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] SPEED_ON = [string] [EOL] [comment] [EOL] SPEED_AUTO = [string] [EOL] [comment] [EOL] SPEED_SMART = [string] [EOL] [EOL] SPEED_LIST = [ SPEED_OFF , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH , SPEED_ON , SPEED_AUTO , SPEED_SMART ] [EOL] [EOL] VALUE_TO_SPEED = { i : speed for i , speed in enumerate ( SPEED_LIST ) } [EOL] SPEED_TO_VALUE = { speed : i for i , speed in enumerate ( SPEED_LIST ) } [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] discovery_info = zha . get_discovery_info ( hass , discovery_info ) [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] async_add_devices ( [ ZhaFan ( ** discovery_info ) ] , update_before_add = True ) [EOL] [EOL] [EOL] class ZhaFan ( zha . Entity , FanEntity ) : [EOL] [docstring] [EOL] [EOL] _domain = DOMAIN [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_SET_SPEED [EOL] [EOL] @ property def speed_list ( self ) : [EOL] [docstring] [EOL] return SPEED_LIST [EOL] [EOL] @ property def speed ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] if self . _state is None : [EOL] return False [EOL] return self . _state != SPEED_OFF [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , speed = None , ** kwargs ) : [EOL] [docstring] [EOL] if speed is None : [EOL] speed = SPEED_MEDIUM [EOL] [EOL] yield from self . async_set_speed ( speed ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] yield from self . async_set_speed ( SPEED_OFF ) [EOL] [EOL] @ asyncio . coroutine def async_set_speed ( self , speed ) : [EOL] [docstring] [EOL] yield from self . _endpoint . fan . write_attributes ( { [string] : SPEED_TO_VALUE [ speed ] } ) [EOL] [EOL] self . _state = speed [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] result = yield from zha . safe_read ( self . _endpoint . fan , [ [string] ] ) [EOL] new_value = result . get ( [string] , None ) [EOL] self . _state = VALUE_TO_SPEED . get ( new_value , None ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , List , Generator , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import re [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_HOST , CONF_PORT [EOL] from homeassistant . components . tts import Provider , PLATFORM_SCHEMA , CONF_LANG [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_LANGUAGES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] SUPPORT_CODEC = [ [string] , [string] , [string] ] [EOL] [EOL] CONF_VOICE = [string] [EOL] CONF_CODEC = [string] [EOL] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_LANG = [string] [EOL] DEFAULT_VOICE = [string] [EOL] DEFAULT_CODEC = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_LANG , default = DEFAULT_LANG ) : vol . In ( SUPPORT_LANGUAGES ) , vol . Optional ( CONF_VOICE , default = DEFAULT_VOICE ) : cv . string , vol . Optional ( CONF_CODEC , default = DEFAULT_CODEC ) : vol . In ( SUPPORT_CODEC ) } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_get_engine ( hass , config ) : [EOL] [docstring] [EOL] return MaryTTSProvider ( hass , config ) [EOL] [EOL] [EOL] class MaryTTSProvider ( Provider ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , conf ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _host = conf . get ( CONF_HOST ) [EOL] self . _port = conf . get ( CONF_PORT ) [EOL] self . _codec = conf . get ( CONF_CODEC ) [EOL] self . _voice = conf . get ( CONF_VOICE ) [EOL] self . _language = conf . get ( CONF_LANG ) [EOL] self . name = [string] [EOL] [EOL] @ property def default_language ( self ) : [EOL] [docstring] [EOL] return self . _language [EOL] [EOL] @ property def supported_languages ( self ) : [EOL] [docstring] [EOL] return SUPPORT_LANGUAGES [EOL] [EOL] @ asyncio . coroutine def async_get_tts_audio ( self , message , language , options = None ) : [EOL] [docstring] [EOL] websession = async_get_clientsession ( self . hass ) [EOL] [EOL] actual_language = re . sub ( [string] , [string] , language ) [EOL] [EOL] try : [EOL] with async_timeout . timeout ( [number] , loop = self . hass . loop ) : [EOL] url = [string] . format ( self . _host , self . _port ) [EOL] [EOL] audio = self . _codec . upper ( ) [EOL] if audio == [string] : [EOL] audio = [string] [EOL] [EOL] url_param = { [string] : message , [string] : [string] , [string] : audio , [string] : self . _voice , [string] : [string] , [string] : actual_language } [EOL] [EOL] request = yield from websession . get ( url , params = url_param ) [EOL] [EOL] if request . status != [number] : [EOL] _LOGGER . error ( [string] , request . status , request . url ) [EOL] return ( None , None ) [EOL] data = yield from request . read ( ) [EOL] [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . error ( [string] ) [EOL] return ( None , None ) [EOL] [EOL] return ( self . _codec , data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import socket [EOL] import homeassistant [EOL] [docstring] [EOL] import json [EOL] import logging [EOL] import socket [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_HS_COLOR , ATTR_EFFECT , SUPPORT_BRIGHTNESS , SUPPORT_COLOR , SUPPORT_EFFECT , Light , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT , CONF_NAME ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . color as color_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DEFAULT_COLOR = [string] [EOL] CONF_PRIORITY = [string] [EOL] CONF_HDMI_PRIORITY = [string] [EOL] CONF_EFFECT_LIST = [string] [EOL] [EOL] DEFAULT_COLOR = [ [number] , [number] , [number] ] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_PRIORITY = [number] [EOL] DEFAULT_HDMI_PRIORITY = [number] [EOL] DEFAULT_EFFECT_LIST = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] SUPPORT_HYPERION = ( SUPPORT_COLOR | SUPPORT_BRIGHTNESS | SUPPORT_EFFECT ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_DEFAULT_COLOR , default = DEFAULT_COLOR ) : vol . All ( list , vol . Length ( min = [number] , max = [number] ) , [ vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PRIORITY , default = DEFAULT_PRIORITY ) : cv . positive_int , vol . Optional ( CONF_HDMI_PRIORITY , default = DEFAULT_HDMI_PRIORITY ) : cv . positive_int , vol . Optional ( CONF_EFFECT_LIST , default = DEFAULT_EFFECT_LIST ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] priority = config . get ( CONF_PRIORITY ) [EOL] hdmi_priority = config . get ( CONF_HDMI_PRIORITY ) [EOL] default_color = config . get ( CONF_DEFAULT_COLOR ) [EOL] effect_list = config . get ( CONF_EFFECT_LIST ) [EOL] [EOL] device = Hyperion ( config . get ( CONF_NAME ) , host , port , priority , default_color , hdmi_priority , effect_list ) [EOL] [EOL] if device . setup ( ) : [EOL] add_devices ( [ device ] ) [EOL] return True [EOL] return False [EOL] [EOL] [EOL] class Hyperion ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , host , port , priority , default_color , hdmi_priority , effect_list ) : [EOL] [docstring] [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _name = name [EOL] self . _priority = priority [EOL] self . _hdmi_priority = hdmi_priority [EOL] self . _default_color = default_color [EOL] self . _rgb_color = [ [number] , [number] , [number] ] [EOL] self . _rgb_mem = [ [number] , [number] , [number] ] [EOL] self . _brightness = [number] [EOL] self . _icon = [string] [EOL] self . _effect_list = effect_list [EOL] self . _effect = None [EOL] self . _skip_update = False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return color_util . color_RGB_to_hs ( * self . _rgb_color ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _rgb_color != [ [number] , [number] , [number] ] [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def effect ( self ) : [EOL] [docstring] [EOL] return self . _effect [EOL] [EOL] @ property def effect_list ( self ) : [EOL] [docstring] [EOL] return self . _effect_list [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_HYPERION [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_HS_COLOR in kwargs : [EOL] rgb_color = color_util . color_hs_to_RGB ( * kwargs [ ATTR_HS_COLOR ] ) [EOL] elif self . _rgb_mem == [ [number] , [number] , [number] ] : [EOL] rgb_color = self . _default_color [EOL] else : [EOL] rgb_color = self . _rgb_mem [EOL] [EOL] brightness = kwargs . get ( ATTR_BRIGHTNESS , self . _brightness ) [EOL] [EOL] if ATTR_EFFECT in kwargs : [EOL] self . _skip_update = True [EOL] self . _effect = kwargs [ ATTR_EFFECT ] [EOL] if self . _effect == [string] : [EOL] self . json_request ( { [string] : [string] } ) [EOL] self . _icon = [string] [EOL] self . _brightness = [number] [EOL] self . _rgb_color = [ [number] , [number] , [number] ] [EOL] else : [EOL] self . json_request ( { [string] : [string] , [string] : self . _priority , [string] : { [string] : self . _effect } } ) [EOL] self . _icon = [string] [EOL] self . _rgb_color = [ [number] , [number] , [number] ] [EOL] return [EOL] [EOL] cal_color = [ int ( round ( x * float ( brightness ) / [number] ) ) for x in rgb_color ] [EOL] self . json_request ( { [string] : [string] , [string] : self . _priority , [string] : cal_color } ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . json_request ( { [string] : [string] } ) [EOL] self . json_request ( { [string] : [string] , [string] : self . _priority , [string] : [ [number] , [number] , [number] ] } ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _skip_update : [EOL] self . _skip_update = False [EOL] return [EOL] response = self . json_request ( { [string] : [string] } ) [EOL] if response : [EOL] [comment] [EOL] if [string] not in response [ [string] ] : [EOL] self . _rgb_color = self . _default_color [EOL] self . _rgb_mem = self . _default_color [EOL] self . _brightness = [number] [EOL] self . _icon = [string] [EOL] self . _effect = None [EOL] return [EOL] [comment] [EOL] try : [EOL] active_priority = response [ [string] ] [ [string] ] [ [number] ] [ [string] ] [EOL] if active_priority == self . _hdmi_priority : [EOL] self . _brightness = [number] [EOL] self . _rgb_color = [ [number] , [number] , [number] ] [EOL] self . _icon = [string] [EOL] self . _effect = [string] [EOL] return [EOL] except ( KeyError , IndexError ) : [EOL] pass [EOL] [EOL] led_color = response [ [string] ] [ [string] ] [EOL] if not led_color or led_color [ [number] ] [ [string] ] == [ [number] , [number] , [number] ] : [EOL] [comment] [EOL] if response [ [string] ] . get ( [string] ) : [EOL] self . _rgb_color = [ [number] , [number] , [number] ] [EOL] self . _icon = [string] [EOL] try : [EOL] s_name = response [ [string] ] [ [string] ] [ [number] ] [ [string] ] [EOL] s_name = s_name . split ( [string] ) [ - [number] ] [ : - [number] ] . split ( [string] ) [ [number] ] [EOL] self . _effect = [ x for x in self . _effect_list if s_name . lower ( ) in x . lower ( ) ] [ [number] ] [EOL] except ( KeyError , IndexError ) : [EOL] self . _effect = None [EOL] [comment] [EOL] else : [EOL] self . _rgb_color = [ [number] , [number] , [number] ] [EOL] self . _icon = [string] [EOL] self . _effect = None [EOL] else : [EOL] [comment] [EOL] self . _rgb_color = led_color [ [number] ] [ [string] ] [EOL] self . _brightness = max ( self . _rgb_color ) [EOL] self . _rgb_mem = [ int ( round ( float ( x ) * [number] / self . _brightness ) ) for x in self . _rgb_color ] [EOL] self . _icon = [string] [EOL] self . _effect = None [EOL] [EOL] def setup ( self ) : [EOL] [docstring] [EOL] response = self . json_request ( { [string] : [string] } ) [EOL] if response : [EOL] if self . _name == self . _host : [EOL] self . _name = response [ [string] ] [ [string] ] [EOL] return True [EOL] return False [EOL] [EOL] def json_request ( self , request , wait_for_response = False ) : [EOL] [docstring] [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] sock . settimeout ( [number] ) [EOL] [EOL] try : [EOL] sock . connect ( ( self . _host , self . _port ) ) [EOL] except OSError : [EOL] sock . close ( ) [EOL] return False [EOL] [EOL] sock . send ( bytearray ( json . dumps ( request ) + [string] , [string] ) ) [EOL] try : [EOL] buf = sock . recv ( [number] ) [EOL] except socket . timeout : [EOL] [comment] [EOL] sock . close ( ) [EOL] return False [EOL] [EOL] [comment] [EOL] buffering = True [EOL] while buffering : [EOL] if [string] in str ( buf , [string] ) : [EOL] response = str ( buf , [string] ) . split ( [string] ) [ [number] ] [EOL] buffering = False [EOL] else : [EOL] try : [EOL] more = sock . recv ( [number] ) [EOL] except socket . timeout : [EOL] more = None [EOL] if not more : [EOL] buffering = False [EOL] response = str ( buf , [string] ) [EOL] else : [EOL] buf += more [EOL] [EOL] sock . close ( ) [EOL] return json . loads ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $None$ 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_TRANSITION , Light , PLATFORM_SCHEMA , SUPPORT_BRIGHTNESS , SUPPORT_TRANSITION ) [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD , EVENT_HOMEASSISTANT_STOP ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , } ) [EOL] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] [comment] [EOL] from decora_wifi import DecoraWiFiSession [EOL] from decora_wifi . models . person import Person [EOL] from decora_wifi . models . residential_account import ResidentialAccount [EOL] [EOL] email = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] session = DecoraWiFiSession ( ) [EOL] [EOL] try : [EOL] success = session . login ( email , password ) [EOL] [EOL] [comment] [EOL] if success is None : [EOL] msg = [string] [EOL] _LOGGER . error ( msg ) [EOL] hass . components . persistent_notification . create ( msg , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] return False [EOL] [EOL] [comment] [EOL] perms = session . user . get_residential_permissions ( ) [EOL] all_switches = [ ] [EOL] for permission in perms : [EOL] acct = ResidentialAccount ( session , permission . residentialAccountId ) [EOL] for residence in acct . get_residences ( ) : [EOL] for switch in residence . get_iot_switches ( ) : [EOL] all_switches . append ( switch ) [EOL] [EOL] add_devices ( DecoraWifiLight ( sw ) for sw in all_switches ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] [comment] [EOL] def logout ( event ) : [EOL] [docstring] [EOL] try : [EOL] if session is not None : [EOL] Person . logout ( session ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] hass . bus . listen ( EVENT_HOMEASSISTANT_STOP , logout ) [EOL] [EOL] [EOL] class DecoraWifiLight ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , switch ) : [EOL] [docstring] [EOL] self . _switch = switch [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . _switch . canSetLevel : [EOL] return SUPPORT_BRIGHTNESS | SUPPORT_TRANSITION [EOL] return [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _switch . name [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return int ( self . _switch . brightness * [number] / [number] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _switch . power == [string] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] attribs = { [string] : [string] } [EOL] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] min_level = self . _switch . data . get ( [string] , [number] ) [EOL] max_level = self . _switch . data . get ( [string] , [number] ) [EOL] brightness = int ( kwargs [ ATTR_BRIGHTNESS ] * max_level / [number] ) [EOL] brightness = max ( brightness , min_level ) [EOL] attribs [ [string] ] = brightness [EOL] [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition = int ( kwargs [ ATTR_TRANSITION ] ) [EOL] attribs [ [string] ] = attribs [ [string] ] = transition [EOL] [EOL] try : [EOL] self . _switch . update_attributes ( attribs ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] attribs = { [string] : [string] } [EOL] try : [EOL] self . _switch . update_attributes ( attribs ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _switch . refresh ( ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components import mysensors [EOL] from homeassistant . components . cover import ATTR_POSITION , DOMAIN , CoverDevice [EOL] from homeassistant . const import STATE_OFF , STATE_ON [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] mysensors . setup_mysensors_platform ( hass , DOMAIN , discovery_info , MySensorsCover , async_add_devices = async_add_devices ) [EOL] [EOL] [EOL] class MySensorsCover ( mysensors . device . MySensorsEntity , CoverDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return self . gateway . optimistic [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] set_req = self . gateway . const . SetReq [EOL] if set_req . V_DIMMER in self . _values : [EOL] return self . _values . get ( set_req . V_DIMMER ) == [number] [EOL] return self . _values . get ( set_req . V_LIGHT ) == STATE_OFF [EOL] [EOL] @ property def current_cover_position ( self ) : [EOL] [docstring] [EOL] set_req = self . gateway . const . SetReq [EOL] return self . _values . get ( set_req . V_DIMMER ) [EOL] [EOL] async def async_open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] set_req = self . gateway . const . SetReq [EOL] self . gateway . set_child_value ( self . node_id , self . child_id , set_req . V_UP , [number] ) [EOL] if self . gateway . optimistic : [EOL] [comment] [EOL] if set_req . V_DIMMER in self . _values : [EOL] self . _values [ set_req . V_DIMMER ] = [number] [EOL] else : [EOL] self . _values [ set_req . V_LIGHT ] = STATE_ON [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] async def async_close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] set_req = self . gateway . const . SetReq [EOL] self . gateway . set_child_value ( self . node_id , self . child_id , set_req . V_DOWN , [number] ) [EOL] if self . gateway . optimistic : [EOL] [comment] [EOL] if set_req . V_DIMMER in self . _values : [EOL] self . _values [ set_req . V_DIMMER ] = [number] [EOL] else : [EOL] self . _values [ set_req . V_LIGHT ] = STATE_OFF [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] async def async_set_cover_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] position = kwargs . get ( ATTR_POSITION ) [EOL] set_req = self . gateway . const . SetReq [EOL] self . gateway . set_child_value ( self . node_id , self . child_id , set_req . V_DIMMER , position ) [EOL] if self . gateway . optimistic : [EOL] [comment] [EOL] self . _values [ set_req . V_DIMMER ] = position [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] async def async_stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] set_req = self . gateway . const . SetReq [EOL] self . gateway . set_child_value ( self . node_id , self . child_id , set_req . V_STOP , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import DefaultDict , List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] from collections import defaultdict [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_USERNAME , CONF_PASSWORD , ATTR_ATTRIBUTION ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import slugify [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . util . dt import now , parse_date [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_UPDATE_INTERVAL = [string] [EOL] COOKIE = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] STATUS_DELIVERED = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_UPDATE_INTERVAL , default = timedelta ( seconds = [number] ) ) : vol . All ( cv . time_period , cv . positive_timedelta ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import fedexdeliverymanager [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] update_interval = config . get ( CONF_UPDATE_INTERVAL ) [EOL] [EOL] try : [EOL] cookie = hass . config . path ( COOKIE ) [EOL] session = fedexdeliverymanager . get_session ( config . get ( CONF_USERNAME ) , config . get ( CONF_PASSWORD ) , cookie_path = cookie ) [EOL] except fedexdeliverymanager . FedexError : [EOL] _LOGGER . exception ( [string] ) [EOL] return False [EOL] [EOL] add_devices ( [ FedexSensor ( session , name , update_interval ) ] , True ) [EOL] [EOL] [EOL] class FedexSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session , name , interval ) : [EOL] [docstring] [EOL] self . _session = session [EOL] self . _name = name [EOL] self . _attributes = None [EOL] self . _state = None [EOL] self . update = Throttle ( interval ) ( self . _update ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name or DOMAIN [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def _update ( self ) : [EOL] [docstring] [EOL] import fedexdeliverymanager [EOL] status_counts = defaultdict ( int ) [EOL] for package in fedexdeliverymanager . get_packages ( self . _session ) : [EOL] status = slugify ( package [ [string] ] ) [EOL] skip = status == STATUS_DELIVERED and parse_date ( package [ [string] ] ) < now ( ) . date ( ) [EOL] if skip : [EOL] continue [EOL] status_counts [ status ] += [number] [EOL] self . _attributes = { ATTR_ATTRIBUTION : fedexdeliverymanager . ATTRIBUTION } [EOL] self . _attributes . update ( status_counts ) [EOL] self . _state = sum ( status_counts . values ( ) ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
import builtins [EOL] from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] from datetime import timedelta [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( LENGTH_KILOMETERS , CONF_MONITORED_CONDITIONS , CONF_NAME , ATTR_ATTRIBUTION ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] URL = [string] [EOL] [EOL] CONF_ATTRIBUTION = [string] [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] REGEX = [string] [EOL] [EOL] OPTION_TRAFFIC_JAM = [string] [EOL] OPTION_MEAN_VELOCITY = [string] [EOL] OPTION_CONGESTION = [string] [EOL] [EOL] SENSOR_TYPES = { OPTION_CONGESTION : [ [string] , [string] ] , OPTION_MEAN_VELOCITY : [ [string] , LENGTH_KILOMETERS + [string] ] , OPTION_TRAFFIC_JAM : [ [string] , LENGTH_KILOMETERS ] , } [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = [ OPTION_TRAFFIC_JAM ] ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] sytadin = SytadinData ( URL ) [EOL] [EOL] dev = [ ] [EOL] for option in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] _LOGGER . debug ( [string] , option ) [EOL] dev . append ( SytadinSensor ( sytadin , name , option , SENSOR_TYPES [ option ] [ [number] ] , SENSOR_TYPES [ option ] [ [number] ] ) ) [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class SytadinSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , name , sensor_type , option , unit ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _state = None [EOL] self . _name = name [EOL] self . _option = option [EOL] self . _type = sensor_type [EOL] self . _unit = unit [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name , self . _option ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] [EOL] if self . data is None : [EOL] return [EOL] [EOL] if self . _type == OPTION_TRAFFIC_JAM : [EOL] self . _state = self . data . traffic_jam [EOL] elif self . _type == OPTION_MEAN_VELOCITY : [EOL] self . _state = self . data . mean_velocity [EOL] elif self . _type == OPTION_CONGESTION : [EOL] self . _state = self . data . congestion [EOL] [EOL] [EOL] class SytadinData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource ) : [EOL] [docstring] [EOL] self . _resource = resource [EOL] self . data = None [EOL] self . traffic_jam = self . mean_velocity = self . congestion = None [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] from bs4 import BeautifulSoup [EOL] [EOL] try : [EOL] raw_html = requests . get ( self . _resource , timeout = [number] ) . text [EOL] data = BeautifulSoup ( raw_html , [string] ) [EOL] [EOL] values = data . select ( [string] ) [EOL] self . traffic_jam = re . search ( REGEX , values [ [number] ] . text ) . group ( ) [EOL] self . mean_velocity = re . search ( REGEX , values [ [number] ] . text ) . group ( ) [EOL] self . congestion = re . search ( REGEX , values [ [number] ] . text ) . group ( ) [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] ) [EOL] self . data = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import homeassistant [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DESTINATION = [string] [EOL] CONF_START = [string] [EOL] CONF_ONLY_DIRECT = [string] [EOL] DEFAULT_ONLY_DIRECT = False [EOL] [EOL] ICON = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DESTINATION ) : cv . string , vol . Required ( CONF_START ) : cv . string , vol . Optional ( CONF_ONLY_DIRECT , default = DEFAULT_ONLY_DIRECT ) : cv . boolean , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] start = config . get ( CONF_START ) [EOL] destination = config . get ( CONF_DESTINATION ) [EOL] only_direct = config . get ( CONF_ONLY_DIRECT ) [EOL] [EOL] add_devices ( [ DeutscheBahnSensor ( start , destination , only_direct ) ] , True ) [EOL] [EOL] [EOL] class DeutscheBahnSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , start , goal , only_direct ) : [EOL] [docstring] [EOL] self . _name = [string] . format ( start , goal ) [EOL] self . data = SchieneData ( start , goal , only_direct ) [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] connections = self . data . connections [ [number] ] [EOL] if len ( self . data . connections ) > [number] : [EOL] connections [ [string] ] = self . data . connections [ [number] ] [ [string] ] [EOL] if len ( self . data . connections ) > [number] : [EOL] connections [ [string] ] = self . data . connections [ [number] ] [ [string] ] [EOL] return connections [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] self . _state = self . data . connections [ [number] ] . get ( [string] , [string] ) [EOL] if self . data . connections [ [number] ] . get ( [string] , [number] ) != [number] : [EOL] self . _state += [string] . format ( self . data . connections [ [number] ] [ [string] ] ) [EOL] [EOL] [EOL] class SchieneData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , start , goal , only_direct ) : [EOL] [docstring] [EOL] import schiene [EOL] [EOL] self . start = start [EOL] self . goal = goal [EOL] self . only_direct = only_direct [EOL] self . schiene = schiene . Schiene ( ) [EOL] self . connections = [ { } ] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . connections = self . schiene . connections ( self . start , self . goal , dt_util . as_local ( dt_util . utcnow ( ) ) , self . only_direct ) [EOL] [EOL] if not self . connections : [EOL] self . connections = [ { } ] [EOL] [EOL] for con in self . connections : [EOL] [comment] [EOL] [comment] [EOL] if [string] in con : [EOL] con . pop ( [string] ) [EOL] delay = con . get ( [string] , { [string] : [number] , [string] : [number] } ) [EOL] con [ [string] ] = delay [ [string] ] [EOL] con [ [string] ] = delay [ [string] ] [EOL] con [ [string] ] = con . get ( [string] , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.sensor.deutsche_bahn.SchieneData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import json [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_VALUE_TEMPLATE , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_SERIAL_PORT = [string] [EOL] CONF_BAUDRATE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_BAUDRATE = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SERIAL_PORT ) : cv . string , vol . Optional ( CONF_BAUDRATE , default = DEFAULT_BAUDRATE ) : cv . positive_int , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] port = config . get ( CONF_SERIAL_PORT ) [EOL] baudrate = config . get ( CONF_BAUDRATE ) [EOL] [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] sensor = SerialSensor ( name , port , baudrate , value_template ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , sensor . stop_serial_read ( ) ) [EOL] async_add_devices ( [ sensor ] , True ) [EOL] [EOL] [EOL] class SerialSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , port , baudrate , value_template ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _port = port [EOL] self . _baudrate = baudrate [EOL] self . _serial_loop_task = None [EOL] self . _template = value_template [EOL] self . _attributes = [ ] [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _serial_loop_task = self . hass . loop . create_task ( self . serial_read ( self . _port , self . _baudrate ) ) [EOL] [EOL] @ asyncio . coroutine def serial_read ( self , device , rate , ** kwargs ) : [EOL] [docstring] [EOL] import serial_asyncio [EOL] reader , _ = yield from serial_asyncio . open_serial_connection ( url = device , baudrate = rate , ** kwargs ) [EOL] while True : [EOL] line = yield from reader . readline ( ) [EOL] line = line . decode ( [string] ) . strip ( ) [EOL] [EOL] try : [EOL] data = json . loads ( line ) [EOL] if isinstance ( data , dict ) : [EOL] self . _attributes = data [EOL] except ValueError : [EOL] pass [EOL] [EOL] if self . _template is not None : [EOL] line = self . _template . async_render_with_possible_json_value ( line ) [EOL] [EOL] _LOGGER . debug ( [string] , line ) [EOL] self . _state = line [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def stop_serial_read ( self ) : [EOL] [docstring] [EOL] if self . _serial_loop_task : [EOL] self . _serial_loop_task . cancel ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Union , Dict , Any [EOL] import logging [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_API_KEY , CONF_MONITORED_CONDITIONS , CONF_NAME , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_FORECAST = [string] [EOL] CONF_LANGUAGE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_FORECAST , default = False ) : cv . boolean , vol . Optional ( CONF_LANGUAGE ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from pyowm import OWM [EOL] [EOL] if None in ( hass . config . latitude , hass . config . longitude ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] SENSOR_TYPES [ [string] ] [ [number] ] = hass . config . units . temperature_unit [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] forecast = config . get ( CONF_FORECAST ) [EOL] language = config . get ( CONF_LANGUAGE ) [EOL] if isinstance ( language , str ) : [EOL] language = language . lower ( ) [ : [number] ] [EOL] [EOL] owm = OWM ( API_key = config . get ( CONF_API_KEY ) , language = language ) [EOL] [EOL] if not owm : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] data = WeatherData ( owm , forecast , hass . config . latitude , hass . config . longitude ) [EOL] dev = [ ] [EOL] for variable in config [ CONF_MONITORED_CONDITIONS ] : [EOL] dev . append ( OpenWeatherMapSensor ( name , data , variable , SENSOR_TYPES [ variable ] [ [number] ] ) ) [EOL] [EOL] if forecast : [EOL] SENSOR_TYPES [ [string] ] = [ [string] , None ] [EOL] dev . append ( OpenWeatherMapSensor ( name , data , [string] , SENSOR_TYPES [ [string] ] [ [number] ] ) ) [EOL] [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class OpenWeatherMapSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , weather_data , sensor_type , temp_unit ) : [EOL] [docstring] [EOL] self . client_name = name [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . owa_client = weather_data [EOL] self . temp_unit = temp_unit [EOL] self . type = sensor_type [EOL] self . _state = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from pyowm . exceptions . api_call_error import APICallError [EOL] [EOL] try : [EOL] self . owa_client . update ( ) [EOL] except APICallError : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] data = self . owa_client . data [EOL] fc_data = self . owa_client . fc_data [EOL] [EOL] if data is None : [EOL] return [EOL] [EOL] if self . type == [string] : [EOL] self . _state = data . get_detailed_status ( ) [EOL] elif self . type == [string] : [EOL] if self . temp_unit == TEMP_CELSIUS : [EOL] self . _state = round ( data . get_temperature ( [string] ) [ [string] ] , [number] ) [EOL] elif self . temp_unit == TEMP_FAHRENHEIT : [EOL] self . _state = round ( data . get_temperature ( [string] ) [ [string] ] , [number] ) [EOL] else : [EOL] self . _state = round ( data . get_temperature ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_wind ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_wind ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_humidity ( ) , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_pressure ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = data . get_clouds ( ) [EOL] elif self . type == [string] : [EOL] if data . get_rain ( ) : [EOL] self . _state = round ( data . get_rain ( ) [ [string] ] , [number] ) [EOL] self . _unit_of_measurement = [string] [EOL] else : [EOL] self . _state = [string] [EOL] self . _unit_of_measurement = [string] [EOL] elif self . type == [string] : [EOL] if data . get_snow ( ) : [EOL] self . _state = round ( data . get_snow ( ) , [number] ) [EOL] self . _unit_of_measurement = [string] [EOL] else : [EOL] self . _state = [string] [EOL] self . _unit_of_measurement = [string] [EOL] elif self . type == [string] : [EOL] if fc_data is None : [EOL] return [EOL] self . _state = fc_data . get_weathers ( ) [ [number] ] . get_detailed_status ( ) [EOL] [EOL] [EOL] class WeatherData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , owm , forecast , latitude , longitude ) : [EOL] [docstring] [EOL] self . owm = owm [EOL] self . forecast = forecast [EOL] self . latitude = latitude [EOL] self . longitude = longitude [EOL] self . data = None [EOL] self . fc_data = None [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] from pyowm . exceptions . api_call_error import APICallError [EOL] [EOL] try : [EOL] obs = self . owm . weather_at_coords ( self . latitude , self . longitude ) [EOL] except ( APICallError , TypeError ) : [EOL] _LOGGER . error ( [string] [string] ) [EOL] obs = None [EOL] [EOL] if obs is None : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] [EOL] self . data = obs . get_weather ( ) [EOL] [EOL] if self . forecast == [number] : [EOL] try : [EOL] obs = self . owm . three_hours_forecast_at_coords ( self . latitude , self . longitude ) [EOL] self . fc_data = obs . get_forecast ( ) [EOL] except ( ConnectionResetError , TypeError ) : [EOL] _LOGGER . warning ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Dict , List , Union , Any [EOL] import logging [EOL] import typing [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import DOMAIN , PLATFORM_SCHEMA [EOL] from homeassistant . const import ATTR_ATTRIBUTION , CONF_MONITORED_CONDITIONS [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import track_time_change [EOL] from homeassistant . helpers . restore_state import async_get_last_state [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_BYTES_RECEIVED = [string] [EOL] ATTR_BYTES_SENT = [string] [EOL] ATTR_SERVER_COUNTRY = [string] [EOL] ATTR_SERVER_HOST = [string] [EOL] ATTR_SERVER_ID = [string] [EOL] ATTR_SERVER_LATENCY = [string] [EOL] ATTR_SERVER_NAME = [string] [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_SECOND = [string] [EOL] CONF_MINUTE = [string] [EOL] CONF_HOUR = [string] [EOL] CONF_DAY = [string] [EOL] CONF_SERVER_ID = [string] [EOL] CONF_MANUAL = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MONITORED_CONDITIONS ) : vol . All ( cv . ensure_list , [ vol . In ( list ( SENSOR_TYPES ) ) ] ) , vol . Optional ( CONF_DAY ) : vol . All ( cv . ensure_list , [ vol . All ( vol . Coerce ( int ) , vol . Range ( [number] , [number] ) ) ] ) , vol . Optional ( CONF_HOUR ) : vol . All ( cv . ensure_list , [ vol . All ( vol . Coerce ( int ) , vol . Range ( [number] , [number] ) ) ] ) , vol . Optional ( CONF_MANUAL , default = False ) : cv . boolean , vol . Optional ( CONF_MINUTE , default = [ [number] ] ) : vol . All ( cv . ensure_list , [ vol . All ( vol . Coerce ( int ) , vol . Range ( [number] , [number] ) ) ] ) , vol . Optional ( CONF_SECOND , default = [ [number] ] ) : vol . All ( cv . ensure_list , [ vol . All ( vol . Coerce ( int ) , vol . Range ( [number] , [number] ) ) ] ) , vol . Optional ( CONF_SERVER_ID ) : cv . positive_int , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] data = SpeedtestData ( hass , config ) [EOL] [EOL] dev = [ ] [EOL] for sensor in config [ CONF_MONITORED_CONDITIONS ] : [EOL] dev . append ( SpeedtestSensor ( data , sensor ) ) [EOL] [EOL] add_devices ( dev ) [EOL] [EOL] def update ( call = None ) : [EOL] [docstring] [EOL] data . update ( dt_util . now ( ) ) [EOL] for sensor in dev : [EOL] sensor . update ( ) [EOL] [EOL] hass . services . register ( DOMAIN , [string] , update ) [EOL] [EOL] [EOL] class SpeedtestSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , speedtest_data , sensor_type ) : [EOL] [docstring] [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . speedtest_client = speedtest_data [EOL] self . type = sensor_type [EOL] self . _state = None [EOL] self . _data = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ self . type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( [string] , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _data is not None : [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , ATTR_BYTES_RECEIVED : self . _data [ [string] ] , ATTR_BYTES_SENT : self . _data [ [string] ] , ATTR_SERVER_COUNTRY : self . _data [ [string] ] [ [string] ] , ATTR_SERVER_ID : self . _data [ [string] ] [ [string] ] , ATTR_SERVER_LATENCY : self . _data [ [string] ] [ [string] ] , ATTR_SERVER_NAME : self . _data [ [string] ] [ [string] ] , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _data = self . speedtest_client . data [EOL] if self . _data is None : [EOL] return [EOL] [EOL] if self . type == [string] : [EOL] self . _state = self . _data [ [string] ] [EOL] elif self . type == [string] : [EOL] self . _state = round ( self . _data [ [string] ] / [number] ** [number] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( self . _data [ [string] ] / [number] ** [number] , [number] ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] state = yield from async_get_last_state ( self . hass , self . entity_id ) [EOL] if not state : [EOL] return [EOL] self . _state = state . state [EOL] [EOL] [EOL] class SpeedtestData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] self . data = None [EOL] self . _server_id = config . get ( CONF_SERVER_ID ) [EOL] if not config . get ( CONF_MANUAL ) : [EOL] track_time_change ( hass , self . update , second = config . get ( CONF_SECOND ) , minute = config . get ( CONF_MINUTE ) , hour = config . get ( CONF_HOUR ) , day = config . get ( CONF_DAY ) ) [EOL] [EOL] def update ( self , now ) : [EOL] [docstring] [EOL] import speedtest [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] servers = [ ] if self . _server_id is None else [ self . _server_id ] [EOL] [EOL] speed = speedtest . Speedtest ( ) [EOL] speed . get_servers ( servers ) [EOL] speed . get_best_server ( ) [EOL] speed . download ( ) [EOL] speed . upload ( ) [EOL] [EOL] self . data = speed . results . dict ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],typing.list]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Union[typing.List[typing.Any],typing.list]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Dict , List , Union , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . upnp import DATA_UPNP , UNITS , CIC_SERVICE [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] BYTES_RECEIVED = [number] [EOL] BYTES_SENT = [number] [EOL] PACKETS_RECEIVED = [number] [EOL] PACKETS_SENT = [number] [EOL] [EOL] [comment] [EOL] SENSOR_TYPES = { BYTES_RECEIVED : [ [string] , True , [string] ] , BYTES_SENT : [ [string] , True , [string] ] , PACKETS_RECEIVED : [ [string] , False , [string] ] , PACKETS_SENT : [ [string] , False , [string] ] , } [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] device = hass . data [ DATA_UPNP ] [EOL] service = device . find_first_service ( CIC_SERVICE ) [EOL] unit = discovery_info [ [string] ] [EOL] async_add_devices ( [ IGDSensor ( service , t , unit if SENSOR_TYPES [ t ] [ [number] ] else [string] ) for t in SENSOR_TYPES ] , True ) [EOL] [EOL] [EOL] class IGDSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , service , sensor_type , unit = None ) : [EOL] [docstring] [EOL] self . _service = service [EOL] self . type = sensor_type [EOL] self . unit = unit [EOL] self . unit_factor = UNITS [ unit ] if unit in UNITS else [number] [EOL] self . _name = [string] . format ( SENSOR_TYPES [ sensor_type ] [ [number] ] ) [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _state : [EOL] return format ( float ( self . _state ) / self . unit_factor , [string] ) [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES [ self . type ] [ [number] ] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . unit [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] if self . type == BYTES_RECEIVED : [EOL] self . _state = await self . _service . get_total_bytes_received ( ) [EOL] elif self . type == BYTES_SENT : [EOL] self . _state = await self . _service . get_total_bytes_sent ( ) [EOL] elif self . type == PACKETS_RECEIVED : [EOL] self . _state = await self . _service . get_total_packets_received ( ) [EOL] elif self . type == PACKETS_SENT : [EOL] self . _state = await self . _service . get_total_packets_sent ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[typing.Union[builtins.bool,builtins.str]]]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] import homeassistant [EOL] import datetime [EOL] [docstring] [EOL] import os [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( TEMP_CELSIUS , CONF_DISPLAY_OPTIONS , CONF_NAME ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] CONF_IS_HAT_ATTACHED = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , TEMP_CELSIUS ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DISPLAY_OPTIONS , default = list ( SENSOR_TYPES ) ) : [ vol . In ( SENSOR_TYPES ) ] , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_IS_HAT_ATTACHED , default = True ) : cv . boolean } ) [EOL] [EOL] [EOL] def get_cpu_temp ( ) : [EOL] [docstring] [EOL] res = os . popen ( [string] ) . readline ( ) [EOL] t_cpu = float ( res . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] return t_cpu [EOL] [EOL] [EOL] def get_average ( temp_base ) : [EOL] [docstring] [EOL] if not hasattr ( get_average , [string] ) : [EOL] get_average . temp = [ temp_base , temp_base , temp_base ] [EOL] get_average . temp [ [number] ] = get_average . temp [ [number] ] [EOL] get_average . temp [ [number] ] = get_average . temp [ [number] ] [EOL] get_average . temp [ [number] ] = temp_base [EOL] temp_avg = ( get_average . temp [ [number] ] + get_average . temp [ [number] ] + get_average . temp [ [number] ] ) / [number] [EOL] return temp_avg [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] data = SenseHatData ( config . get ( CONF_IS_HAT_ATTACHED ) ) [EOL] dev = [ ] [EOL] for variable in config [ CONF_DISPLAY_OPTIONS ] : [EOL] dev . append ( SenseHatSensor ( data , variable ) ) [EOL] [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class SenseHatSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , sensor_types ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _name = SENSOR_TYPES [ sensor_types ] [ [number] ] [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_types ] [ [number] ] [EOL] self . type = sensor_types [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] if not self . data . humidity : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] if self . type == [string] : [EOL] self . _state = self . data . temperature [EOL] if self . type == [string] : [EOL] self . _state = self . data . humidity [EOL] if self . type == [string] : [EOL] self . _state = self . data . pressure [EOL] [EOL] [EOL] class SenseHatData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , is_hat_attached ) : [EOL] [docstring] [EOL] self . temperature = None [EOL] self . humidity = None [EOL] self . pressure = None [EOL] self . is_hat_attached = is_hat_attached [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] from sense_hat import SenseHat [EOL] sense = SenseHat ( ) [EOL] temp_from_h = sense . get_temperature_from_humidity ( ) [EOL] temp_from_p = sense . get_temperature_from_pressure ( ) [EOL] t_total = ( temp_from_h + temp_from_p ) / [number] [EOL] [EOL] if self . is_hat_attached : [EOL] t_cpu = get_cpu_temp ( ) [EOL] t_correct = t_total - ( ( t_cpu - t_total ) / [number] ) [EOL] t_correct = get_average ( t_correct ) [EOL] else : [EOL] t_correct = get_average ( t_total ) [EOL] [EOL] self . temperature = t_correct [EOL] self . humidity = sense . get_humidity ( ) [EOL] self . pressure = sense . get_pressure ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] import requests [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] import json [EOL] [EOL] import voluptuous as vol [EOL] import requests [EOL] from requests . auth import HTTPBasicAuth , HTTPDigestAuth [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_AUTHENTICATION , CONF_FORCE_UPDATE , CONF_HEADERS , CONF_NAME , CONF_METHOD , CONF_PASSWORD , CONF_PAYLOAD , CONF_RESOURCE , CONF_UNIT_OF_MEASUREMENT , CONF_USERNAME , CONF_VALUE_TEMPLATE , CONF_VERIFY_SSL , HTTP_BASIC_AUTHENTICATION , HTTP_DIGEST_AUTHENTICATION , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_METHOD = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_VERIFY_SSL = True [EOL] DEFAULT_FORCE_UPDATE = False [EOL] [EOL] CONF_JSON_ATTRS = [string] [EOL] METHODS = [ [string] , [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_RESOURCE ) : cv . url , vol . Optional ( CONF_AUTHENTICATION ) : vol . In ( [ HTTP_BASIC_AUTHENTICATION , HTTP_DIGEST_AUTHENTICATION ] ) , vol . Optional ( CONF_HEADERS ) : vol . Schema ( { cv . string : cv . string } ) , vol . Optional ( CONF_JSON_ATTRS , default = [ ] ) : cv . ensure_list_csv , vol . Optional ( CONF_METHOD , default = DEFAULT_METHOD ) : vol . In ( METHODS ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PAYLOAD ) : cv . string , vol . Optional ( CONF_UNIT_OF_MEASUREMENT ) : cv . string , vol . Optional ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_VERIFY_SSL , default = DEFAULT_VERIFY_SSL ) : cv . boolean , vol . Optional ( CONF_FORCE_UPDATE , default = DEFAULT_FORCE_UPDATE ) : cv . boolean , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] resource = config . get ( CONF_RESOURCE ) [EOL] method = config . get ( CONF_METHOD ) [EOL] payload = config . get ( CONF_PAYLOAD ) [EOL] verify_ssl = config . get ( CONF_VERIFY_SSL ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] headers = config . get ( CONF_HEADERS ) [EOL] unit = config . get ( CONF_UNIT_OF_MEASUREMENT ) [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] json_attrs = config . get ( CONF_JSON_ATTRS ) [EOL] force_update = config . get ( CONF_FORCE_UPDATE ) [EOL] [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] if username and password : [EOL] if config . get ( CONF_AUTHENTICATION ) == HTTP_DIGEST_AUTHENTICATION : [EOL] auth = HTTPDigestAuth ( username , password ) [EOL] else : [EOL] auth = HTTPBasicAuth ( username , password ) [EOL] else : [EOL] auth = None [EOL] rest = RestData ( method , resource , auth , headers , payload , verify_ssl ) [EOL] rest . update ( ) [EOL] [EOL] add_devices ( [ RestSensor ( hass , rest , name , unit , value_template , json_attrs , force_update ) ] , True ) [EOL] [EOL] [EOL] class RestSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , rest , name , unit_of_measurement , value_template , json_attrs , force_update ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . rest = rest [EOL] self . _name = name [EOL] self . _state = STATE_UNKNOWN [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _value_template = value_template [EOL] self . _json_attrs = json_attrs [EOL] self . _attributes = None [EOL] self . _force_update = force_update [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . rest . data is not None [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def force_update ( self ) : [EOL] [docstring] [EOL] return self . _force_update [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . rest . update ( ) [EOL] value = self . rest . data [EOL] [EOL] if self . _json_attrs : [EOL] self . _attributes = { } [EOL] if value : [EOL] try : [EOL] json_dict = json . loads ( value ) [EOL] if isinstance ( json_dict , dict ) : [EOL] attrs = { k : json_dict [ k ] for k in self . _json_attrs if k in json_dict } [EOL] self . _attributes = attrs [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] except ValueError : [EOL] _LOGGER . warning ( [string] ) [EOL] _LOGGER . debug ( [string] , value ) [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] if value is None : [EOL] value = STATE_UNKNOWN [EOL] elif self . _value_template is not None : [EOL] value = self . _value_template . render_with_possible_json_value ( value , STATE_UNKNOWN ) [EOL] [EOL] self . _state = value [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] [EOL] class RestData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , method , resource , auth , headers , data , verify_ssl ) : [EOL] [docstring] [EOL] self . _request = requests . Request ( method , resource , headers = headers , auth = auth , data = data ) . prepare ( ) [EOL] self . _verify_ssl = verify_ssl [EOL] self . data = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] with requests . Session ( ) as sess : [EOL] response = sess . send ( self . _request , timeout = [number] , verify = self . _verify_ssl ) [EOL] [EOL] self . data = response . text [EOL] except requests . exceptions . RequestException as ex : [EOL] _LOGGER . error ( [string] , self . _request , self . _request . url , ex ) [EOL] self . data = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Union , Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . ring import ( CONF_ATTRIBUTION , DEFAULT_ENTITY_NAMESPACE , DATA_RING ) [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_ENTITY_NAMESPACE , CONF_MONITORED_CONDITIONS , STATE_UNKNOWN , ATTR_ATTRIBUTION ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . icon import icon_for_battery_level [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [comment] [EOL] SENSOR_TYPES = { [string] : [ [string] , [ [string] , [string] ] , [string] , [string] , None ] , [string] : [ [string] , [ [string] , [string] ] , None , [string] , None ] , [string] : [ [string] , [ [string] ] , None , [string] , [string] ] , [string] : [ [string] , [ [string] , [string] ] , None , [string] , [string] ] , [string] : [ [string] , [ [string] , [string] , [string] ] , None , [string] , None ] , [string] : [ [string] , [ [string] , [string] , [string] ] , None , [string] , None ] , [string] : [ [string] , [ [string] , [string] , [string] ] , [string] , [string] , None ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_ENTITY_NAMESPACE , default = DEFAULT_ENTITY_NAMESPACE ) : cv . string , vol . Required ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] ring = hass . data [ DATA_RING ] [EOL] [EOL] sensors = [ ] [EOL] for sensor_type in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] for device in ring . chimes : [EOL] if [string] in SENSOR_TYPES [ sensor_type ] [ [number] ] : [EOL] sensors . append ( RingSensor ( hass , device , sensor_type ) ) [EOL] [EOL] for device in ring . doorbells : [EOL] if [string] in SENSOR_TYPES [ sensor_type ] [ [number] ] : [EOL] sensors . append ( RingSensor ( hass , device , sensor_type ) ) [EOL] [EOL] for device in ring . stickup_cams : [EOL] if [string] in SENSOR_TYPES [ sensor_type ] [ [number] ] : [EOL] sensors . append ( RingSensor ( hass , device , sensor_type ) ) [EOL] [EOL] add_devices ( sensors , True ) [EOL] return True [EOL] [EOL] [EOL] class RingSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , data , sensor_type ) : [EOL] [docstring] [EOL] super ( RingSensor , self ) . __init__ ( ) [EOL] self . _sensor_type = sensor_type [EOL] self . _data = data [EOL] self . _extra = None [EOL] self . _icon = [string] . format ( SENSOR_TYPES . get ( self . _sensor_type ) [ [number] ] ) [EOL] self . _kind = SENSOR_TYPES . get ( self . _sensor_type ) [ [number] ] [EOL] self . _name = [string] . format ( self . _data . name , SENSOR_TYPES . get ( self . _sensor_type ) [ [number] ] ) [EOL] self . _state = STATE_UNKNOWN [EOL] self . _tz = str ( hass . config . time_zone ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { } [EOL] [EOL] attrs [ ATTR_ATTRIBUTION ] = CONF_ATTRIBUTION [EOL] attrs [ [string] ] = self . _data . id [EOL] attrs [ [string] ] = self . _data . firmware [EOL] attrs [ [string] ] = self . _data . kind [EOL] attrs [ [string] ] = self . _data . timezone [EOL] attrs [ [string] ] = self . _data . family [EOL] attrs [ [string] ] = self . _data . wifi_name [EOL] [EOL] if self . _extra and self . _sensor_type . startswith ( [string] ) : [EOL] attrs [ [string] ] = self . _extra [ [string] ] [EOL] attrs [ [string] ] = self . _extra [ [string] ] [EOL] attrs [ [string] ] = self . _extra [ [string] ] [ [string] ] [EOL] attrs [ [string] ] = self . _extra [ [string] ] [EOL] [EOL] return attrs [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . _sensor_type == [string] and self . _state is not STATE_UNKNOWN : [EOL] return icon_for_battery_level ( battery_level = int ( self . _state ) , charging = False ) [EOL] return self . _icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES . get ( self . _sensor_type ) [ [number] ] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] [EOL] self . _data . update ( ) [EOL] [EOL] if self . _sensor_type == [string] : [EOL] self . _state = self . _data . volume [EOL] [EOL] if self . _sensor_type == [string] : [EOL] self . _state = self . _data . battery_life [EOL] [EOL] if self . _sensor_type . startswith ( [string] ) : [EOL] history = self . _data . history ( limit = [number] , timezone = self . _tz , kind = self . _kind , enforce_limit = True ) [EOL] if history : [EOL] self . _extra = history [ [number] ] [EOL] created_at = self . _extra [ [string] ] [EOL] self . _state = [string] . format ( created_at . hour , created_at . minute ) [EOL] [EOL] if self . _sensor_type == [string] : [EOL] self . _state = self . _data . wifi_signal_category [EOL] [EOL] if self . _sensor_type == [string] : [EOL] self . _state = self . _data . wifi_signal_strength [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[None,typing.List[builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] from copy import deepcopy [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , ATTR_ATTRIBUTION , STATE_UNKNOWN ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_NEXT_DEPARTURE = [string] [EOL] [EOL] CONF_STATION = [string] [EOL] CONF_DESTINATIONS = [string] [EOL] CONF_DIRECTIONS = [string] [EOL] CONF_LINES = [string] [EOL] CONF_PRODUCTS = [string] [EOL] CONF_TIMEOFFSET = [string] [EOL] CONF_NUMBER = [string] [EOL] [EOL] DEFAULT_PRODUCT = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] ICONS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] ATTRIBUTION = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NEXT_DEPARTURE ) : [ { vol . Required ( CONF_STATION ) : cv . string , vol . Optional ( CONF_DESTINATIONS , default = [ [string] ] ) : cv . ensure_list_csv , vol . Optional ( CONF_DIRECTIONS , default = [ [string] ] ) : cv . ensure_list_csv , vol . Optional ( CONF_LINES , default = [ [string] ] ) : cv . ensure_list_csv , vol . Optional ( CONF_PRODUCTS , default = DEFAULT_PRODUCT ) : cv . ensure_list_csv , vol . Optional ( CONF_TIMEOFFSET , default = [number] ) : cv . positive_int , vol . Optional ( CONF_NUMBER , default = [number] ) : cv . positive_int , vol . Optional ( CONF_NAME ) : cv . string } ] } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] sensors = [ ] [EOL] for nextdeparture in config . get ( CONF_NEXT_DEPARTURE ) : [EOL] sensors . append ( MVGLiveSensor ( nextdeparture . get ( CONF_STATION ) , nextdeparture . get ( CONF_DESTINATIONS ) , nextdeparture . get ( CONF_DIRECTIONS ) , nextdeparture . get ( CONF_LINES ) , nextdeparture . get ( CONF_PRODUCTS ) , nextdeparture . get ( CONF_TIMEOFFSET ) , nextdeparture . get ( CONF_NUMBER ) , nextdeparture . get ( CONF_NAME ) ) ) [EOL] add_devices ( sensors , True ) [EOL] [EOL] [EOL] class MVGLiveSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , station , destinations , directions , lines , products , timeoffset , number , name ) : [EOL] [docstring] [EOL] self . _station = station [EOL] self . _name = name [EOL] self . data = MVGLiveData ( station , destinations , directions , lines , products , timeoffset , number ) [EOL] self . _state = STATE_UNKNOWN [EOL] self . _icon = ICONS [ [string] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] if self . _name : [EOL] return self . _name [EOL] return self . _station [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] dep = self . data . departures [EOL] if not dep : [EOL] return None [EOL] attr = dep [ [number] ] [comment] [EOL] attr [ [string] ] = deepcopy ( dep ) [comment] [EOL] return attr [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] if not self . data . departures : [EOL] self . _state = [string] [EOL] self . _icon = ICONS [ [string] ] [EOL] else : [EOL] self . _state = self . data . departures [ [number] ] . get ( [string] , [string] ) [EOL] self . _icon = ICONS [ self . data . departures [ [number] ] . get ( [string] , [string] ) ] [EOL] [EOL] [EOL] class MVGLiveData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , station , destinations , directions , lines , products , timeoffset , number ) : [EOL] [docstring] [EOL] import MVGLive [EOL] self . _station = station [EOL] self . _destinations = destinations [EOL] self . _directions = directions [EOL] self . _lines = lines [EOL] self . _products = products [EOL] self . _timeoffset = timeoffset [EOL] self . _number = number [EOL] self . _include_ubahn = True if [string] in self . _products else False [EOL] self . _include_tram = True if [string] in self . _products else False [EOL] self . _include_bus = True if [string] in self . _products else False [EOL] self . _include_sbahn = True if [string] in self . _products else False [EOL] self . mvg = MVGLive . MVGLive ( ) [EOL] self . departures = [ ] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] _departures = self . mvg . getlivedata ( station = self . _station , timeoffset = self . _timeoffset , ubahn = self . _include_ubahn , tram = self . _include_tram , bus = self . _include_bus , sbahn = self . _include_sbahn ) [EOL] except ValueError : [EOL] self . departures = [ ] [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] self . departures = [ ] [EOL] for i , _departure in enumerate ( _departures ) : [EOL] [comment] [EOL] if ( [string] not in self . _destinations [ : [number] ] and _departure [ [string] ] not in self . _destinations ) : [EOL] continue [EOL] elif ( [string] not in self . _directions [ : [number] ] and _departure [ [string] ] not in self . _directions ) : [EOL] continue [EOL] elif ( [string] not in self . _lines [ : [number] ] and _departure [ [string] ] not in self . _lines ) : [EOL] continue [EOL] elif _departure [ [string] ] < self . _timeoffset : [EOL] continue [EOL] [comment] [EOL] _nextdep = { ATTR_ATTRIBUTION : ATTRIBUTION } [EOL] for k in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] _nextdep [ k ] = _departure . get ( k , [string] ) [EOL] _nextdep [ [string] ] = int ( _nextdep [ [string] ] ) [EOL] self . departures . append ( _nextdep ) [EOL] if i == self . _number - [number] : [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.sensor.mvglive.MVGLiveData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] import threading [EOL] [docstring] [EOL] import logging [EOL] import socket [EOL] import threading [EOL] import datetime [EOL] import time [EOL] import re [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT , CONF_NAME , CONF_PASSWORD , CONF_USERNAME , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_PHONEBOOK = [string] [EOL] CONF_PREFIXES = [string] [EOL] [EOL] DEFAULT_HOST = [string] [comment] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] INTERVAL_RECONNECT = [number] [EOL] [EOL] VALUE_CALL = [string] [EOL] VALUE_CONNECT = [string] [EOL] VALUE_DEFAULT = [string] [EOL] VALUE_DISCONNECT = [string] [EOL] VALUE_RING = [string] [EOL] [EOL] [comment] [EOL] MIN_TIME_PHONEBOOK_UPDATE = datetime . timedelta ( hours = [number] ) [EOL] SCAN_INTERVAL = datetime . timedelta ( hours = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_PASSWORD , default = [string] ) : cv . string , vol . Optional ( CONF_USERNAME , default = [string] ) : cv . string , vol . Optional ( CONF_PHONEBOOK , default = [number] ) : cv . positive_int , vol . Optional ( CONF_PREFIXES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] phonebook_id = config . get ( [string] ) [EOL] prefixes = config . get ( [string] ) [EOL] [EOL] try : [EOL] phonebook = FritzBoxPhonebook ( host = host , port = port , username = username , password = password , phonebook_id = phonebook_id , prefixes = prefixes ) [EOL] except : [comment] [EOL] phonebook = None [EOL] _LOGGER . warning ( [string] , phonebook_id ) [EOL] [EOL] sensor = FritzBoxCallSensor ( name = name , phonebook = phonebook ) [EOL] [EOL] add_devices ( [ sensor ] ) [EOL] [EOL] monitor = FritzBoxCallMonitor ( host = host , port = port , sensor = sensor ) [EOL] monitor . connect ( ) [EOL] [EOL] def _stop_listener ( _event ) : [EOL] monitor . stopped . set ( ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , _stop_listener ) [EOL] [EOL] return monitor . sock is not None [EOL] [EOL] [EOL] class FritzBoxCallSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , phonebook ) : [EOL] [docstring] [EOL] self . _state = VALUE_DEFAULT [EOL] self . _attributes = { } [EOL] self . _name = name [EOL] self . phonebook = phonebook [EOL] [EOL] def set_state ( self , state ) : [EOL] [docstring] [EOL] self . _state = state [EOL] [EOL] def set_attributes ( self , attributes ) : [EOL] [docstring] [EOL] self . _attributes = attributes [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return self . phonebook is not None [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] def number_to_name ( self , number ) : [EOL] [docstring] [EOL] if self . phonebook is None : [EOL] return [string] [EOL] return self . phonebook . get_name ( number ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . phonebook is not None : [EOL] self . phonebook . update_phonebook ( ) [EOL] [EOL] [EOL] class FritzBoxCallMonitor : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , sensor ) : [EOL] [docstring] [EOL] self . host = host [EOL] self . port = port [EOL] self . sock = None [EOL] self . _sensor = sensor [EOL] self . stopped = threading . Event ( ) [EOL] [EOL] def connect ( self ) : [EOL] [docstring] [EOL] self . sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] self . sock . settimeout ( [number] ) [EOL] try : [EOL] self . sock . connect ( ( self . host , self . port ) ) [EOL] threading . Thread ( target = self . _listen ) . start ( ) [EOL] except socket . error as err : [EOL] self . sock = None [EOL] _LOGGER . error ( [string] , self . host , self . port , err ) [EOL] [EOL] def _listen ( self ) : [EOL] [docstring] [EOL] while not self . stopped . isSet ( ) : [EOL] try : [EOL] response = self . sock . recv ( [number] ) [EOL] except socket . timeout : [EOL] [comment] [EOL] continue [EOL] response = str ( response , [string] ) [EOL] [EOL] if not response : [EOL] [comment] [EOL] [comment] [EOL] self . sock = None [EOL] while self . sock is None : [EOL] self . connect ( ) [EOL] time . sleep ( INTERVAL_RECONNECT ) [EOL] else : [EOL] line = response . split ( [string] , [number] ) [ [number] ] [EOL] self . _parse ( line ) [EOL] time . sleep ( [number] ) [EOL] [EOL] def _parse ( self , line ) : [EOL] [docstring] [EOL] line = line . split ( [string] ) [EOL] df_in = [string] [EOL] df_out = [string] [EOL] isotime = datetime . datetime . strptime ( line [ [number] ] , df_in ) . strftime ( df_out ) [EOL] if line [ [number] ] == [string] : [EOL] self . _sensor . set_state ( VALUE_RING ) [EOL] att = { [string] : [string] , [string] : line [ [number] ] , [string] : line [ [number] ] , [string] : line [ [number] ] , [string] : isotime } [EOL] att [ [string] ] = self . _sensor . number_to_name ( att [ [string] ] ) [EOL] self . _sensor . set_attributes ( att ) [EOL] elif line [ [number] ] == [string] : [EOL] self . _sensor . set_state ( VALUE_CALL ) [EOL] att = { [string] : [string] , [string] : line [ [number] ] , [string] : line [ [number] ] , [string] : line [ [number] ] , [string] : isotime } [EOL] att [ [string] ] = self . _sensor . number_to_name ( att [ [string] ] ) [EOL] self . _sensor . set_attributes ( att ) [EOL] elif line [ [number] ] == [string] : [EOL] self . _sensor . set_state ( VALUE_CONNECT ) [EOL] att = { [string] : line [ [number] ] , [string] : line [ [number] ] , [string] : isotime } [EOL] att [ [string] ] = self . _sensor . number_to_name ( att [ [string] ] ) [EOL] self . _sensor . set_attributes ( att ) [EOL] elif line [ [number] ] == [string] : [EOL] self . _sensor . set_state ( VALUE_DISCONNECT ) [EOL] att = { [string] : line [ [number] ] , [string] : isotime } [EOL] self . _sensor . set_attributes ( att ) [EOL] self . _sensor . schedule_update_ha_state ( ) [EOL] [EOL] [EOL] class FritzBoxPhonebook : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , username , password , phonebook_id = [number] , prefixes = None ) : [EOL] [docstring] [EOL] self . host = host [EOL] self . username = username [EOL] self . password = password [EOL] self . port = port [EOL] self . phonebook_id = phonebook_id [EOL] self . phonebook_dict = None [EOL] self . number_dict = None [EOL] self . prefixes = prefixes or [ ] [EOL] [EOL] [comment] [EOL] import fritzconnection as fc [EOL] [comment] [EOL] self . fph = fc . FritzPhonebook ( address = self . host , user = self . username , password = self . password ) [EOL] [EOL] if self . phonebook_id not in self . fph . list_phonebooks : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . update_phonebook ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_PHONEBOOK_UPDATE ) def update_phonebook ( self ) : [EOL] [docstring] [EOL] self . phonebook_dict = self . fph . get_all_names ( self . phonebook_id ) [EOL] self . number_dict = { re . sub ( [string] , [string] , nr ) : name for name , nrs in self . phonebook_dict . items ( ) for nr in nrs } [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] def get_name ( self , number ) : [EOL] [docstring] [EOL] number = re . sub ( [string] , [string] , str ( number ) ) [EOL] if self . number_dict is None : [EOL] return [string] [EOL] try : [EOL] return self . number_dict [ number ] [EOL] except KeyError : [EOL] pass [EOL] if self . prefixes : [EOL] for prefix in self . prefixes : [EOL] try : [EOL] return self . number_dict [ prefix + number ] [EOL] except KeyError : [EOL] pass [EOL] try : [EOL] return self . number_dict [ prefix + number . lstrip ( [string] ) ] [EOL] except KeyError : [EOL] pass [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Union , Dict , Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] import homeassistant [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_MONITORED_VARIABLES , CONF_NAME , CONF_PASSWORD , CONF_PORT , CONF_USERNAME , STATE_IDLE ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_MONITORED_VARIABLES , default = [ [string] ] ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_USERNAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import transmissionrpc [EOL] from transmissionrpc . error import TransmissionError [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] try : [EOL] transmission = transmissionrpc . Client ( host , port = port , user = username , password = password ) [EOL] transmission_api = TransmissionData ( transmission ) [EOL] except TransmissionError as error : [EOL] if str ( error ) . find ( [string] ) : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] _LOGGER . warning ( [string] , host , port ) [EOL] raise PlatformNotReady [EOL] [EOL] dev = [ ] [EOL] for variable in config [ CONF_MONITORED_VARIABLES ] : [EOL] dev . append ( TransmissionSensor ( variable , transmission_api , name ) ) [EOL] [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class TransmissionSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor_type , transmission_api , client_name ) : [EOL] [docstring] [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _state = None [EOL] self . _transmission_api = transmission_api [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _data = None [EOL] self . client_name = client_name [EOL] self . type = sensor_type [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _transmission_api . available [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _transmission_api . update ( ) [EOL] self . _data = self . _transmission_api . data [EOL] [EOL] if self . type == [string] : [EOL] if self . _data : [EOL] upload = self . _data . uploadSpeed [EOL] download = self . _data . downloadSpeed [EOL] if upload > [number] and download > [number] : [EOL] self . _state = [string] [EOL] elif upload > [number] and download == [number] : [EOL] self . _state = [string] [EOL] elif upload == [number] and download > [number] : [EOL] self . _state = [string] [EOL] else : [EOL] self . _state = STATE_IDLE [EOL] else : [EOL] self . _state = None [EOL] [EOL] if self . _data : [EOL] if self . type == [string] : [EOL] mb_spd = float ( self . _data . downloadSpeed ) [EOL] mb_spd = mb_spd / [number] / [number] [EOL] self . _state = round ( mb_spd , [number] if mb_spd < [number] else [number] ) [EOL] elif self . type == [string] : [EOL] mb_spd = float ( self . _data . uploadSpeed ) [EOL] mb_spd = mb_spd / [number] / [number] [EOL] self . _state = round ( mb_spd , [number] if mb_spd < [number] else [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = self . _data . activeTorrentCount [EOL] elif self . type == [string] : [EOL] self . _state = self . _data . pausedTorrentCount [EOL] elif self . type == [string] : [EOL] self . _state = self . _data . torrentCount [EOL] [EOL] [EOL] class TransmissionData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api ) : [EOL] [docstring] [EOL] self . data = None [EOL] self . available = True [EOL] self . _api = api [EOL] [EOL] @ Throttle ( SCAN_INTERVAL ) def update ( self ) : [EOL] [docstring] [EOL] from transmissionrpc . error import TransmissionError [EOL] [EOL] try : [EOL] self . data = self . _api . session_stats ( ) [EOL] self . available = True [EOL] except TransmissionError : [EOL] self . available = False [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import List , Union , Optional , Match , Dict , Any [EOL] import logging [EOL] import typing [EOL] import requests [EOL] import homeassistant [EOL] [docstring] [EOL] import base64 [EOL] from datetime import datetime [EOL] import hashlib [EOL] import logging [EOL] import re [EOL] [EOL] from aiohttp . hdrs import ( ACCEPT , COOKIE , PRAGMA , REFERER , CONNECTION , KEEP_ALIVE , USER_AGENT , CONTENT_TYPE , CACHE_CONTROL , ACCEPT_ENCODING , ACCEPT_LANGUAGE ) [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . device_tracker import ( DOMAIN , PLATFORM_SCHEMA , DeviceScanner ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_USERNAME , HTTP_HEADER_X_REQUESTED_WITH ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] HTTP_HEADER_NO_CACHE = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string } ) [EOL] [EOL] [EOL] def get_scanner ( hass , config ) : [EOL] [docstring] [EOL] for cls in [ TplinkDeviceScanner , Tplink5DeviceScanner , Tplink4DeviceScanner , Tplink3DeviceScanner , Tplink2DeviceScanner , Tplink1DeviceScanner ] : [EOL] scanner = cls ( config [ DOMAIN ] ) [EOL] if scanner . success_init : [EOL] return scanner [EOL] [EOL] return None [EOL] [EOL] [EOL] class TplinkDeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] from tplink . tplink import TpLinkClient [EOL] host = config [ CONF_HOST ] [EOL] password = config [ CONF_PASSWORD ] [EOL] username = config [ CONF_USERNAME ] [EOL] [EOL] self . tplink_client = TpLinkClient ( password , host = host , username = username ) [EOL] [EOL] self . last_results = { } [EOL] self . success_init = self . _update_info ( ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results . keys ( ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return self . last_results . get ( device ) [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] result = self . tplink_client . get_connected_devices ( ) [EOL] [EOL] if result : [EOL] self . last_results = result [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] class Tplink1DeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] host = config [ CONF_HOST ] [EOL] username , password = config [ CONF_USERNAME ] , config [ CONF_PASSWORD ] [EOL] [EOL] self . parse_macs = re . compile ( [string] + [string] ) [EOL] [EOL] self . host = host [EOL] self . username = username [EOL] self . password = password [EOL] [EOL] self . last_results = { } [EOL] self . success_init = self . _update_info ( ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = [string] . format ( self . host ) [EOL] referer = [string] . format ( self . host ) [EOL] page = requests . get ( url , auth = ( self . username , self . password ) , headers = { REFERER : referer } , timeout = [number] ) [EOL] [EOL] result = self . parse_macs . findall ( page . text ) [EOL] [EOL] if result : [EOL] self . last_results = [ mac . replace ( [string] , [string] ) for mac in result ] [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] class Tplink2DeviceScanner ( Tplink1DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results . keys ( ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return self . last_results . get ( device ) [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = [string] . format ( self . host ) [EOL] referer = [string] . format ( self . host ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] username_password = [string] . format ( self . username , self . password ) [EOL] b64_encoded_username_password = base64 . b64encode ( username_password . encode ( [string] ) ) . decode ( [string] ) [EOL] cookie = [string] . format ( b64_encoded_username_password ) [EOL] [EOL] response = requests . post ( url , headers = { REFERER : referer , COOKIE : cookie } , timeout = [number] ) [EOL] [EOL] try : [EOL] result = response . json ( ) . get ( [string] ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] [EOL] if result : [EOL] self . last_results = { device [ [string] ] . replace ( [string] , [string] ) : device [ [string] ] for device in result } [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] class Tplink3DeviceScanner ( Tplink1DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . stok = [string] [EOL] self . sysauth = [string] [EOL] super ( Tplink3DeviceScanner , self ) . __init__ ( config ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] self . _log_out ( ) [EOL] return self . last_results . keys ( ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return self . last_results . get ( device ) [EOL] [EOL] def _get_auth_tokens ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = [string] . format ( self . host ) [EOL] referer = [string] . format ( self . host ) [EOL] [EOL] [comment] [EOL] response = requests . post ( url , params = { [string] : [string] , [string] : self . username , [string] : self . password } , headers = { REFERER : referer } , timeout = [number] ) [EOL] [EOL] try : [EOL] self . stok = response . json ( ) . get ( [string] ) . get ( [string] ) [EOL] _LOGGER . info ( self . stok ) [EOL] regex_result = re . search ( [string] , response . headers [ [string] ] ) [EOL] self . sysauth = regex_result . group ( [number] ) [EOL] _LOGGER . info ( self . sysauth ) [EOL] return True [EOL] except ( ValueError , KeyError ) as _ : [EOL] _LOGGER . error ( [string] , response . text ) [EOL] return False [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] if ( self . stok == [string] ) or ( self . sysauth == [string] ) : [EOL] self . _get_auth_tokens ( ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = ( [string] [string] ) . format ( self . host , self . stok ) [EOL] referer = [string] . format ( self . host ) [EOL] [EOL] response = requests . post ( url , params = { [string] : [string] } , headers = { REFERER : referer } , cookies = { [string] : self . sysauth } , timeout = [number] ) [EOL] [EOL] try : [EOL] json_response = response . json ( ) [EOL] [EOL] if json_response . get ( [string] ) : [EOL] result = response . json ( ) . get ( [string] ) [EOL] else : [EOL] if json_response . get ( [string] ) == [string] : [EOL] _LOGGER . info ( [string] ) [EOL] self . stok = [string] [EOL] self . sysauth = [string] [EOL] return False [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] except ValueError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] [EOL] if result : [EOL] self . last_results = { device [ [string] ] . replace ( [string] , [string] ) : device [ [string] ] for device in result } [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def _log_out ( self ) : [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = ( [string] [string] ) . format ( self . host , self . stok ) [EOL] referer = [string] . format ( self . host ) [EOL] [EOL] requests . post ( url , params = { [string] : [string] } , headers = { REFERER : referer } , cookies = { [string] : self . sysauth } ) [EOL] self . stok = [string] [EOL] self . sysauth = [string] [EOL] [EOL] [EOL] class Tplink4DeviceScanner ( Tplink1DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . credentials = [string] [EOL] self . token = [string] [EOL] super ( Tplink4DeviceScanner , self ) . __init__ ( config ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def _get_auth_tokens ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] url = [string] . format ( self . host ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] password = hashlib . md5 ( self . password . encode ( [string] ) [ : [number] ] ) . hexdigest ( ) [EOL] credentials = [string] . format ( self . username , password ) . encode ( [string] ) [EOL] [EOL] [comment] [EOL] self . credentials = base64 . b64encode ( credentials ) . decode ( [string] ) [EOL] [EOL] [comment] [EOL] cookie = [string] . format ( self . credentials ) [EOL] [EOL] response = requests . get ( url , headers = { COOKIE : cookie } ) [EOL] [EOL] try : [EOL] result = re . search ( [string] [string] , response . text ) [EOL] if not result : [EOL] return False [EOL] self . token = result . group ( [number] ) [EOL] return True [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] if ( self . credentials == [string] ) or ( self . token == [string] ) : [EOL] self . _get_auth_tokens ( ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] mac_results = [ ] [EOL] [EOL] [comment] [EOL] for clients_url in ( [string] , [string] ) : [EOL] url = [string] . format ( self . host , self . token , clients_url ) [EOL] referer = [string] . format ( self . host ) [EOL] cookie = [string] . format ( self . credentials ) [EOL] [EOL] page = requests . get ( url , headers = { COOKIE : cookie , REFERER : referer , } ) [EOL] mac_results . extend ( self . parse_macs . findall ( page . text ) ) [EOL] [EOL] if not mac_results : [EOL] return False [EOL] [EOL] self . last_results = [ mac . replace ( [string] , [string] ) for mac in mac_results ] [EOL] return True [EOL] [EOL] [EOL] class Tplink5DeviceScanner ( Tplink1DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results . keys ( ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] base_url = [string] . format ( self . host ) [EOL] [EOL] header = { USER_AGENT : [string] [string] , ACCEPT : [string] , ACCEPT_LANGUAGE : [string] , ACCEPT_ENCODING : [string] , CONTENT_TYPE : [string] , HTTP_HEADER_X_REQUESTED_WITH : [string] , REFERER : [string] . format ( self . host ) , CONNECTION : KEEP_ALIVE , PRAGMA : HTTP_HEADER_NO_CACHE , CACHE_CONTROL : HTTP_HEADER_NO_CACHE , } [EOL] [EOL] password_md5 = hashlib . md5 ( self . password . encode ( [string] ) ) . hexdigest ( ) . upper ( ) [EOL] [EOL] [comment] [EOL] session = requests . session ( ) [EOL] session . get ( base_url , headers = header ) [EOL] [EOL] login_data = { [string] : self . username , [string] : password_md5 } [EOL] session . post ( base_url , login_data , headers = header ) [EOL] [EOL] [comment] [EOL] timestamp = int ( datetime . now ( ) . timestamp ( ) * [number] ) [EOL] [EOL] client_list_url = [string] . format ( base_url ) [EOL] [EOL] get_params = { [string] : [string] , [string] : timestamp , } [EOL] [EOL] response = session . get ( client_list_url , headers = header , params = get_params ) [EOL] session . close ( ) [EOL] try : [EOL] list_of_devices = response . json ( ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] [EOL] if list_of_devices : [EOL] self . last_results = { device [ [string] ] . replace ( [string] , [string] ) : device [ [string] ] for device in list_of_devices [ [string] ] } [EOL] return True [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.sessions.Session$ 0 0 0 $requests.sessions.Session$ 0 0 0 $requests.sessions.Session$ 0 0 0 $builtins.str$ 0 0 0 $typing.dict$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $requests.sessions.Session$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $requests.models.Response$ 0 $requests.sessions.Session$ 0 0 0 $builtins.str$ 0 0 0 $typing.dict$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 $requests.sessions.Session$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , List , Union , Any [EOL] import typing [EOL] import typing_extensions [EOL] import logging [EOL] import homeassistant [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( MEDIA_TYPE_MUSIC , MEDIA_TYPE_PLAYLIST , SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PLAY_MEDIA , SUPPORT_PREVIOUS_TRACK , SUPPORT_SEEK , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , PLATFORM_SCHEMA , SUPPORT_PLAY , MediaPlayerDevice ) [EOL] from homeassistant . const import ( STATE_IDLE , STATE_OFF , STATE_ON , STATE_PAUSED , STATE_PLAYING , CONF_NAME , CONF_HOST , CONF_PORT , CONF_SSL ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_TIMEOUT = [number] [EOL] DEFAULT_SSL = False [EOL] DOMAIN = [string] [EOL] [EOL] SUPPORT_ITUNES = SUPPORT_PAUSE | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_SEEK | SUPPORT_PLAY_MEDIA | SUPPORT_PLAY | SUPPORT_TURN_OFF [EOL] [EOL] SUPPORT_AIRPLAY = SUPPORT_VOLUME_SET | SUPPORT_TURN_ON | SUPPORT_TURN_OFF [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_SSL , default = DEFAULT_SSL ) : cv . boolean , } ) [EOL] [EOL] [EOL] class Itunes : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , use_ssl ) : [EOL] [docstring] [EOL] self . host = host [EOL] self . port = port [EOL] self . use_ssl = use_ssl [EOL] [EOL] @ property def _base_url ( self ) : [EOL] [docstring] [EOL] if self . use_ssl : [EOL] uri_scheme = [string] [EOL] else : [EOL] uri_scheme = [string] [EOL] [EOL] if self . port : [EOL] return [string] . format ( uri_scheme , self . host , self . port ) [EOL] [EOL] return [string] . format ( uri_scheme , self . host ) [EOL] [EOL] def _request ( self , method , path , params = None ) : [EOL] [docstring] [EOL] url = [string] . format ( self . _base_url , path ) [EOL] [EOL] try : [EOL] if method == [string] : [EOL] response = requests . get ( url , timeout = DEFAULT_TIMEOUT ) [EOL] elif method == [string] : [EOL] response = requests . put ( url , params , timeout = DEFAULT_TIMEOUT ) [EOL] elif method == [string] : [EOL] response = requests . put ( url , params , timeout = DEFAULT_TIMEOUT ) [EOL] elif method == [string] : [EOL] response = requests . delete ( url , timeout = DEFAULT_TIMEOUT ) [EOL] [EOL] return response . json ( ) [EOL] except requests . exceptions . HTTPError : [EOL] return { [string] : [string] } [EOL] except requests . exceptions . RequestException : [EOL] return { [string] : [string] } [EOL] [EOL] def _command ( self , named_command ) : [EOL] [docstring] [EOL] return self . _request ( [string] , [string] + named_command ) [EOL] [EOL] def now_playing ( self ) : [EOL] [docstring] [EOL] return self . _request ( [string] , [string] ) [EOL] [EOL] def set_volume ( self , level ) : [EOL] [docstring] [EOL] return self . _request ( [string] , [string] , { [string] : level } ) [EOL] [EOL] def set_muted ( self , muted ) : [EOL] [docstring] [EOL] return self . _request ( [string] , [string] , { [string] : muted } ) [EOL] [EOL] def play ( self ) : [EOL] [docstring] [EOL] return self . _command ( [string] ) [EOL] [EOL] def pause ( self ) : [EOL] [docstring] [EOL] return self . _command ( [string] ) [EOL] [EOL] def next ( self ) : [EOL] [docstring] [EOL] return self . _command ( [string] ) [EOL] [EOL] def previous ( self ) : [EOL] [docstring] [EOL] return self . _command ( [string] ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] return self . _command ( [string] ) [EOL] [EOL] def play_playlist ( self , playlist_id_or_name ) : [EOL] [docstring] [EOL] response = self . _request ( [string] , [string] ) [EOL] playlists = response . get ( [string] , [ ] ) [EOL] [EOL] found_playlists = [ playlist for playlist in playlists if ( playlist_id_or_name in [ playlist [ [string] ] , playlist [ [string] ] ] ) ] [EOL] [EOL] if found_playlists : [EOL] playlist = found_playlists [ [number] ] [EOL] path = [string] + playlist [ [string] ] + [string] [EOL] return self . _request ( [string] , path ) [EOL] [EOL] def artwork_url ( self ) : [EOL] [docstring] [EOL] return self . _base_url + [string] [EOL] [EOL] def airplay_devices ( self ) : [EOL] [docstring] [EOL] return self . _request ( [string] , [string] ) [EOL] [EOL] def airplay_device ( self , device_id ) : [EOL] [docstring] [EOL] return self . _request ( [string] , [string] + device_id ) [EOL] [EOL] def toggle_airplay_device ( self , device_id , toggle ) : [EOL] [docstring] [EOL] command = [string] if toggle else [string] [EOL] path = [string] + device_id + [string] + command [EOL] return self . _request ( [string] , path ) [EOL] [EOL] def set_volume_airplay_device ( self , device_id , level ) : [EOL] [docstring] [EOL] path = [string] + device_id + [string] [EOL] return self . _request ( [string] , path , { [string] : level } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] add_devices ( [ ItunesDevice ( config . get ( CONF_NAME ) , config . get ( CONF_HOST ) , config . get ( CONF_PORT ) , config . get ( CONF_SSL ) , add_devices ) ] ) [EOL] [EOL] [EOL] class ItunesDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , host , port , use_ssl , add_devices ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _use_ssl = use_ssl [EOL] self . _add_devices = add_devices [EOL] [EOL] self . client = Itunes ( self . _host , self . _port , self . _use_ssl ) [EOL] [EOL] self . current_volume = None [EOL] self . muted = None [EOL] self . current_title = None [EOL] self . current_album = None [EOL] self . current_artist = None [EOL] self . current_playlist = None [EOL] self . content_id = None [EOL] [EOL] self . player_state = None [EOL] [EOL] self . airplay_devices = { } [EOL] [EOL] self . update ( ) [EOL] [EOL] def update_state ( self , state_hash ) : [EOL] [docstring] [EOL] self . player_state = state_hash . get ( [string] , None ) [EOL] [EOL] self . current_volume = state_hash . get ( [string] , [number] ) [EOL] self . muted = state_hash . get ( [string] , None ) [EOL] self . current_title = state_hash . get ( [string] , None ) [EOL] self . current_album = state_hash . get ( [string] , None ) [EOL] self . current_artist = state_hash . get ( [string] , None ) [EOL] self . current_playlist = state_hash . get ( [string] , None ) [EOL] self . content_id = state_hash . get ( [string] , None ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . player_state == [string] or self . player_state is None : [EOL] return [string] [EOL] [EOL] if self . player_state == [string] : [EOL] return [string] [EOL] [EOL] if self . player_state == [string] : [EOL] return STATE_IDLE [EOL] [EOL] if self . player_state == [string] : [EOL] return STATE_PAUSED [EOL] [EOL] return STATE_PLAYING [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] now_playing = self . client . now_playing ( ) [EOL] self . update_state ( now_playing ) [EOL] [EOL] found_devices = self . client . airplay_devices ( ) [EOL] found_devices = found_devices . get ( [string] , [ ] ) [EOL] [EOL] new_devices = [ ] [EOL] [EOL] for device_data in found_devices : [EOL] device_id = device_data . get ( [string] ) [EOL] [EOL] if self . airplay_devices . get ( device_id ) : [EOL] [comment] [EOL] airplay_device = self . airplay_devices . get ( device_id ) [EOL] airplay_device . update_state ( device_data ) [EOL] else : [EOL] [comment] [EOL] airplay_device = AirPlayDevice ( device_id , self . client ) [EOL] airplay_device . update_state ( device_data ) [EOL] self . airplay_devices [ device_id ] = airplay_device [EOL] new_devices . append ( airplay_device ) [EOL] [EOL] if new_devices : [EOL] self . _add_devices ( new_devices ) [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . muted [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . current_volume / [number] [EOL] [EOL] @ property def media_content_id ( self ) : [EOL] [docstring] [EOL] return self . content_id [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] if self . player_state in ( STATE_PLAYING , STATE_IDLE , STATE_PAUSED ) and self . current_title is not None : [EOL] return self . client . artwork_url ( ) + [string] + self . content_id [EOL] [EOL] return [string] [string] [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . current_title [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . current_artist [EOL] [EOL] @ property def media_album_name ( self ) : [EOL] [docstring] [EOL] return self . current_album [EOL] [EOL] @ property def media_playlist ( self ) : [EOL] [docstring] [EOL] return self . current_playlist [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_ITUNES [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] response = self . client . set_volume ( int ( volume * [number] ) ) [EOL] self . update_state ( response ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] response = self . client . set_muted ( mute ) [EOL] self . update_state ( response ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] response = self . client . play ( ) [EOL] self . update_state ( response ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] response = self . client . pause ( ) [EOL] self . update_state ( response ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] response = self . client . next ( ) [EOL] self . update_state ( response ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] response = self . client . previous ( ) [EOL] self . update_state ( response ) [EOL] [EOL] def play_media ( self , media_type , media_id , ** kwargs ) : [EOL] [docstring] [EOL] if media_type == MEDIA_TYPE_PLAYLIST : [EOL] response = self . client . play_playlist ( media_id ) [EOL] self . update_state ( response ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] response = self . client . stop ( ) [EOL] self . update_state ( response ) [EOL] [EOL] [EOL] class AirPlayDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device_id , client ) : [EOL] [docstring] [EOL] self . _id = device_id [EOL] self . client = client [EOL] self . device_name = [string] [EOL] self . kind = None [EOL] self . active = False [EOL] self . selected = False [EOL] self . volume = [number] [EOL] self . supports_audio = False [EOL] self . supports_video = False [EOL] self . player_state = None [EOL] [EOL] def update_state ( self , state_hash ) : [EOL] [docstring] [EOL] if [string] in state_hash : [EOL] self . player_state = state_hash . get ( [string] , None ) [EOL] [EOL] if [string] in state_hash : [EOL] name = state_hash . get ( [string] , [string] ) [EOL] self . device_name = ( name + [string] ) . strip ( ) [EOL] [EOL] if [string] in state_hash : [EOL] self . kind = state_hash . get ( [string] , None ) [EOL] [EOL] if [string] in state_hash : [EOL] self . active = state_hash . get ( [string] , None ) [EOL] [EOL] if [string] in state_hash : [EOL] self . selected = state_hash . get ( [string] , None ) [EOL] [EOL] if [string] in state_hash : [EOL] self . volume = state_hash . get ( [string] , [number] ) [EOL] [EOL] if [string] in state_hash : [EOL] self . supports_audio = state_hash . get ( [string] , None ) [EOL] [EOL] if [string] in state_hash : [EOL] self . supports_video = state_hash . get ( [string] , None ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . device_name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . selected is True : [EOL] return [string] [EOL] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . selected is True : [EOL] return STATE_ON [EOL] [EOL] return STATE_OFF [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return float ( self . volume ) / [number] [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_AIRPLAY [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] volume = int ( volume * [number] ) [EOL] response = self . client . set_volume_airplay_device ( self . _id , volume ) [EOL] self . update_state ( response ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . update_state ( { [string] : True } ) [EOL] self . schedule_update_ha_state ( ) [EOL] response = self . client . toggle_airplay_device ( self . _id , True ) [EOL] self . update_state ( response ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . update_state ( { [string] : False } ) [EOL] self . schedule_update_ha_state ( ) [EOL] response = self . client . toggle_airplay_device ( self . _id , False ) [EOL] self . update_state ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.media_player.itunes.Itunes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $homeassistant.components.media_player.itunes.AirPlayDevice$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $homeassistant.components.media_player.itunes.AirPlayDevice$ 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.media_player.itunes.AirPlayDevice$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $homeassistant.components.media_player.itunes.AirPlayDevice$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $homeassistant.components.media_player.itunes.AirPlayDevice$ 0 $typing.List[typing.Any]$ 0 0 0 $homeassistant.components.media_player.itunes.AirPlayDevice$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_VOLUME_SET , SUPPORT_VOLUME_MUTE , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_VOLUME_STEP , SUPPORT_SELECT_SOURCE , MediaPlayerDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_NAME , STATE_OFF , STATE_ON ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_MIN_VOLUME = - [number] [EOL] DEFAULT_MAX_VOLUME = - [number] [EOL] [EOL] SUPPORT_NAD = SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_VOLUME_STEP | SUPPORT_SELECT_SOURCE [EOL] [EOL] CONF_SERIAL_PORT = [string] [EOL] CONF_MIN_VOLUME = [string] [EOL] CONF_MAX_VOLUME = [string] [EOL] CONF_SOURCE_DICT = [string] [EOL] [EOL] SOURCE_DICT_SCHEMA = vol . Schema ( { vol . Range ( min = [number] , max = [number] ) : cv . string } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SERIAL_PORT ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_MIN_VOLUME , default = DEFAULT_MIN_VOLUME ) : int , vol . Optional ( CONF_MAX_VOLUME , default = DEFAULT_MAX_VOLUME ) : int , vol . Optional ( CONF_SOURCE_DICT , default = { } ) : SOURCE_DICT_SCHEMA , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from nad_receiver import NADReceiver [EOL] add_devices ( [ NAD ( config . get ( CONF_NAME ) , NADReceiver ( config . get ( CONF_SERIAL_PORT ) ) , config . get ( CONF_MIN_VOLUME ) , config . get ( CONF_MAX_VOLUME ) , config . get ( CONF_SOURCE_DICT ) ) ] , True ) [EOL] [EOL] [EOL] class NAD ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , nad_receiver , min_volume , max_volume , source_dict ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _nad_receiver = nad_receiver [EOL] self . _min_volume = min_volume [EOL] self . _max_volume = max_volume [EOL] self . _source_dict = source_dict [EOL] self . _reverse_mapping = { value : key for key , value in self . _source_dict . items ( ) } [EOL] [EOL] self . _volume = self . _state = self . _mute = self . _source = None [EOL] [EOL] def calc_volume ( self , decibel ) : [EOL] [docstring] [EOL] return abs ( self . _min_volume - decibel ) / abs ( self . _min_volume - self . _max_volume ) [EOL] [EOL] def calc_db ( self , volume ) : [EOL] [docstring] [EOL] return self . _min_volume + round ( abs ( self . _min_volume - self . _max_volume ) * volume ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . _nad_receiver . main_power ( [string] ) == [string] : [EOL] self . _state = STATE_OFF [EOL] else : [EOL] self . _state = STATE_ON [EOL] [EOL] if self . _nad_receiver . main_mute ( [string] ) == [string] : [EOL] self . _mute = False [EOL] else : [EOL] self . _mute = True [EOL] [EOL] self . _volume = self . calc_volume ( self . _nad_receiver . main_volume ( [string] ) ) [EOL] self . _source = self . _source_dict . get ( self . _nad_receiver . main_source ( [string] ) ) [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _mute [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_NAD [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . _nad_receiver . main_power ( [string] , [string] ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . _nad_receiver . main_power ( [string] , [string] ) [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] self . _nad_receiver . main_volume ( [string] ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] self . _nad_receiver . main_volume ( [string] ) [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . _nad_receiver . main_volume ( [string] , self . calc_db ( volume ) ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] self . _nad_receiver . main_source ( [string] , self . _reverse_mapping . get ( source ) ) [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _source [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return sorted ( list ( self . _reverse_mapping . keys ( ) ) ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] if mute : [EOL] self . _nad_receiver . main_mute ( [string] , [string] ) [EOL] else : [EOL] self . _nad_receiver . main_mute ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Generator , Any [EOL] import logging [EOL] import typing [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] import asyncio [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( PLATFORM_SCHEMA , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_SELECT_SOURCE , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , MediaPlayerDevice ) [EOL] from homeassistant . const import ( CONF_NAME , CONF_HOST , CONF_PORT , STATE_OFF , STATE_ON , STATE_UNKNOWN , EVENT_HOMEASSISTANT_STOP ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] SUPPORT_ANTHEMAV = SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import anthemav [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] name = config . get ( CONF_NAME ) [EOL] device = None [EOL] [EOL] _LOGGER . info ( [string] , host , port ) [EOL] [EOL] def async_anthemav_update_callback ( message ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , message ) [EOL] hass . async_add_job ( device . async_update_ha_state ( ) ) [EOL] [EOL] avr = yield from anthemav . Connection . create ( host = host , port = port , loop = hass . loop , update_callback = async_anthemav_update_callback ) [EOL] [EOL] device = AnthemAVR ( avr , name ) [EOL] [EOL] _LOGGER . debug ( [string] , device . dump_avrdata ) [EOL] _LOGGER . debug ( [string] , avr . dump_conndata ) [EOL] _LOGGER . debug ( [string] , avr . protocol . dump_rawdata ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , device . avr . close ) [EOL] async_add_devices ( [ device ] ) [EOL] [EOL] [EOL] class AnthemAVR ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , avr , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . avr = avr [EOL] self . _name = name [EOL] [EOL] def _lookup ( self , propname , dval = None ) : [EOL] return getattr ( self . avr . protocol , propname , dval ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_ANTHEMAV [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name or self . _lookup ( [string] ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] pwrstate = self . _lookup ( [string] ) [EOL] [EOL] if pwrstate is True : [EOL] return STATE_ON [EOL] if pwrstate is False : [EOL] return STATE_OFF [EOL] return STATE_UNKNOWN [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , False ) [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [number] ) [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [string] ) [EOL] [EOL] @ property def app_name ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [string] ) + [string] + self . _lookup ( [string] , [string] ) [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [string] ) [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [ [string] ] ) [EOL] [EOL] @ asyncio . coroutine def async_select_source ( self , source ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , source ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , False ) [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , True ) [EOL] [EOL] @ asyncio . coroutine def async_set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , volume ) [EOL] [EOL] @ asyncio . coroutine def async_mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , mute ) [EOL] [EOL] def _update_avr ( self , propname , value ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , propname , str ( value ) ) [EOL] setattr ( self . avr . protocol , propname , value ) [EOL] [EOL] @ property def dump_avrdata ( self ) : [EOL] [docstring] [EOL] attrs = vars ( self ) [EOL] return ( [string] + [string] . join ( [string] % item for item in attrs . items ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] import homeassistant [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( PLATFORM_SCHEMA , SUPPORT_NEXT_TRACK , SUPPORT_PREVIOUS_TRACK , SUPPORT_SELECT_SOURCE , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_VOLUME_STEP , MediaPlayerDevice ) [EOL] from homeassistant . const import ( CONF_ACCESS_TOKEN , CONF_HOST , CONF_NAME , STATE_OFF , STATE_ON , STATE_UNKNOWN ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant import util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_SUPPRESS_WARNING = [string] [EOL] CONF_VOLUME_STEP = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_VOLUME_STEP = [number] [EOL] DEVICE_ID = [string] [EOL] DEVICE_NAME = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] SUPPORTED_COMMANDS = SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE | SUPPORT_NEXT_TRACK | SUPPORT_PREVIOUS_TRACK | SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_STEP | SUPPORT_VOLUME_SET [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_ACCESS_TOKEN ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_SUPPRESS_WARNING , default = False ) : cv . boolean , vol . Optional ( CONF_VOLUME_STEP , default = DEFAULT_VOLUME_STEP ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST ) [EOL] token = config . get ( CONF_ACCESS_TOKEN ) [EOL] name = config . get ( CONF_NAME ) [EOL] volume_step = config . get ( CONF_VOLUME_STEP ) [EOL] [EOL] device = VizioDevice ( host , token , name , volume_step ) [EOL] if device . validate_setup ( ) is False : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return [EOL] [EOL] if config . get ( CONF_SUPPRESS_WARNING ) : [EOL] from requests . packages import urllib3 [EOL] _LOGGER . warning ( [string] [string] ) [EOL] urllib3 . disable_warnings ( urllib3 . exceptions . InsecureRequestWarning ) [EOL] add_devices ( [ device ] , True ) [EOL] [EOL] [EOL] class VizioDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , token , name , volume_step ) : [EOL] [docstring] [EOL] import pyvizio [EOL] self . _device = pyvizio . Vizio ( DEVICE_ID , host , DEFAULT_NAME , token ) [EOL] self . _name = name [EOL] self . _state = STATE_UNKNOWN [EOL] self . _volume_level = None [EOL] self . _volume_step = volume_step [EOL] self . _current_input = None [EOL] self . _available_inputs = None [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update ( self ) : [EOL] [docstring] [EOL] is_on = self . _device . get_power_state ( ) [EOL] if is_on is None : [EOL] self . _state = STATE_UNKNOWN [EOL] return [EOL] if is_on is False : [EOL] self . _state = STATE_OFF [EOL] else : [EOL] self . _state = STATE_ON [EOL] [EOL] volume = self . _device . get_current_volume ( ) [EOL] if volume is not None : [EOL] self . _volume_level = float ( volume ) / [number] [EOL] input_ = self . _device . get_current_input ( ) [EOL] if input_ is not None : [EOL] self . _current_input = input_ . meta_name [EOL] inputs = self . _device . get_inputs ( ) [EOL] if inputs is not None : [EOL] self . _available_inputs = [ ] [EOL] for input_ in inputs : [EOL] self . _available_inputs . append ( input_ . name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume_level [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _current_input [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _available_inputs [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORTED_COMMANDS [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . _device . pow_on ( ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . _device . pow_off ( ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] if mute : [EOL] self . _device . mute_on ( ) [EOL] else : [EOL] self . _device . mute_off ( ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _device . ch_down ( ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _device . ch_up ( ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] self . _device . input_switch ( source ) [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] self . _volume_level += self . _volume_step / [number] [EOL] self . _device . vol_up ( num = self . _volume_step ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] self . _volume_level -= self . _volume_step / [number] [EOL] self . _device . vol_down ( num = self . _volume_step ) [EOL] [EOL] def validate_setup ( self ) : [EOL] [docstring] [EOL] return self . _device . get_current_volume ( ) is not None [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] if self . _volume_level is not None : [EOL] if volume > self . _volume_level : [EOL] num = int ( [number] * ( volume - self . _volume_level ) ) [EOL] self . _volume_level = volume [EOL] self . _device . vol_up ( num = num ) [EOL] elif volume < self . _volume_level : [EOL] num = int ( [number] * ( self . _volume_level - volume ) ) [EOL] self . _volume_level = volume [EOL] self . _device . vol_down ( num = num ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0
from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_VOLUME_MUTE , SUPPORT_PAUSE , SUPPORT_STOP , SUPPORT_NEXT_TRACK , SUPPORT_PREVIOUS_TRACK , SUPPORT_VOLUME_STEP , SUPPORT_PLAY , MediaPlayerDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( STATE_OFF , STATE_IDLE , STATE_PAUSED , STATE_PLAYING , CONF_NAME , CONF_HOST , CONF_PORT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] SUPPORT_MPCHC = SUPPORT_VOLUME_MUTE | SUPPORT_PAUSE | SUPPORT_STOP | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_VOLUME_STEP | SUPPORT_PLAY [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] url = [string] . format ( host , port ) [EOL] [EOL] add_devices ( [ MpcHcDevice ( name , url ) ] , True ) [EOL] [EOL] [EOL] class MpcHcDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , url ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _url = url [EOL] self . _player_variables = dict ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] response = requests . get ( [string] . format ( self . _url ) , data = None , timeout = [number] ) [EOL] [EOL] mpchc_variables = re . findall ( [string] , response . text ) [EOL] [EOL] for var in mpchc_variables : [EOL] self . _player_variables [ var [ [number] ] ] = var [ [number] ] . lower ( ) [EOL] except requests . exceptions . RequestException : [EOL] _LOGGER . error ( [string] , self . _url ) [EOL] [EOL] def _send_command ( self , command_id ) : [EOL] [docstring] [EOL] try : [EOL] params = { [string] : command_id } [EOL] requests . get ( [string] . format ( self . _url ) , params = params , timeout = [number] ) [EOL] except requests . exceptions . RequestException : [EOL] _LOGGER . error ( [string] , command_id , self . _url ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] state = self . _player_variables . get ( [string] , None ) [EOL] [EOL] if state is None : [EOL] return STATE_OFF [EOL] if state == [string] : [EOL] return STATE_PLAYING [EOL] if state == [string] : [EOL] return STATE_PAUSED [EOL] [EOL] return STATE_IDLE [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _player_variables . get ( [string] , None ) [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return int ( self . _player_variables . get ( [string] , [number] ) ) / [number] [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _player_variables . get ( [string] , [string] ) == [string] [EOL] [EOL] @ property def media_duration ( self ) : [EOL] [docstring] [EOL] duration = self . _player_variables . get ( [string] , [string] ) . split ( [string] ) [EOL] return int ( duration [ [number] ] ) * [number] + int ( duration [ [number] ] ) * [number] + int ( duration [ [number] ] ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_MPCHC [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] self . _send_command ( [number] ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] self . _send_command ( [number] ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . _send_command ( [number] ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _send_command ( [number] ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _send_command ( [number] ) [EOL] [EOL] def media_stop ( self ) : [EOL] [docstring] [EOL] self . _send_command ( [number] ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _send_command ( [number] ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _send_command ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import logging [EOL] import typing [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , ENTITY_ID_FORMAT ) [EOL] from homeassistant . components . tesla import DOMAIN as TESLA_DOMAIN , TeslaDevice [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] devices = [ TeslaBinarySensor ( device , hass . data [ TESLA_DOMAIN ] [ [string] ] , [string] ) for device in hass . data [ TESLA_DOMAIN ] [ [string] ] [ [string] ] ] [EOL] add_devices ( devices , True ) [EOL] [EOL] [EOL] class TeslaBinarySensor ( TeslaDevice , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tesla_device , controller , sensor_type ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( tesla_device , controller ) [EOL] self . _state = False [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( self . tesla_id ) [EOL] self . _sensor_type = sensor_type [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _sensor_type [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] self . tesla_device . update ( ) [EOL] self . _state = self . tesla_device . get_value ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA , DEVICE_CLASSES_SCHEMA ) [EOL] from homeassistant . const import ( CONF_RESOURCE , CONF_PIN , CONF_NAME , CONF_DEVICE_CLASS ) [EOL] from homeassistant . util import Throttle [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_RESOURCE ) : cv . url , vol . Optional ( CONF_NAME ) : cv . string , vol . Required ( CONF_PIN ) : cv . string , vol . Optional ( CONF_DEVICE_CLASS ) : DEVICE_CLASSES_SCHEMA , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] resource = config . get ( CONF_RESOURCE ) [EOL] pin = config . get ( CONF_PIN ) [EOL] device_class = config . get ( CONF_DEVICE_CLASS ) [EOL] [EOL] try : [EOL] response = requests . get ( resource , timeout = [number] ) . json ( ) [EOL] except requests . exceptions . MissingSchema : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] , resource ) [EOL] return False [EOL] [EOL] arest = ArestData ( resource , pin ) [EOL] [EOL] add_devices ( [ ArestBinarySensor ( arest , resource , config . get ( CONF_NAME , response [ CONF_NAME ] ) , device_class , pin ) ] , True ) [EOL] [EOL] [EOL] class ArestBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , arest , resource , name , device_class , pin ) : [EOL] [docstring] [EOL] self . arest = arest [EOL] self . _resource = resource [EOL] self . _name = name [EOL] self . _device_class = device_class [EOL] self . _pin = pin [EOL] [EOL] if self . _pin is not None : [EOL] request = requests . get ( [string] . format ( self . _resource , self . _pin ) , timeout = [number] ) [EOL] if request . status_code != [number] : [EOL] _LOGGER . error ( [string] , self . _resource ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . arest . data . get ( [string] ) ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . arest . update ( ) [EOL] [EOL] [EOL] class ArestData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource , pin ) : [EOL] [docstring] [EOL] self . _resource = resource [EOL] self . _pin = pin [EOL] self . data = { } [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] response = requests . get ( [string] . format ( self . _resource , self . _pin ) , timeout = [number] ) [EOL] self . data = { [string] : response . json ( ) [ [string] ] } [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] , self . _resource ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . components . hive import DATA_HIVE [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] DEVICETYPE_DEVICE_CLASS = { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] session = hass . data . get ( DATA_HIVE ) [EOL] [EOL] add_devices ( [ HiveBinarySensorEntity ( session , discovery_info ) ] ) [EOL] [EOL] [EOL] class HiveBinarySensorEntity ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hivesession , hivedevice ) : [EOL] [docstring] [EOL] self . node_id = hivedevice [ [string] ] [EOL] self . node_name = hivedevice [ [string] ] [EOL] self . device_type = hivedevice [ [string] ] [EOL] self . node_device_type = hivedevice [ [string] ] [EOL] self . session = hivesession [EOL] self . attributes = { } [EOL] self . data_updatesource = [string] . format ( self . device_type , self . node_id ) [EOL] [EOL] self . session . entities . append ( self ) [EOL] [EOL] def handle_update ( self , updatesource ) : [EOL] [docstring] [EOL] if [string] . format ( self . device_type , self . node_id ) not in updatesource : [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICETYPE_DEVICE_CLASS . get ( self . node_device_type ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . node_name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . attributes [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . session . sensor . get_state ( self . node_id , self . node_device_type ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . session . core . update_data ( self . node_id ) [EOL] self . attributes = self . session . attributes . state_attributes ( self . node_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] import homeassistant [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import ( PLATFORM_SCHEMA , BinarySensorDevice ) [EOL] from homeassistant . const import CONF_NAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_LOCATION = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_LOCATION ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] location = config . get ( CONF_LOCATION ) [EOL] [EOL] taps_aff_data = TapsAffData ( location ) [EOL] [EOL] add_devices ( [ TapsAffSensor ( taps_aff_data , name ) ] , True ) [EOL] [EOL] [EOL] class TapsAffSensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , taps_aff_data , name ) : [EOL] [docstring] [EOL] self . data = taps_aff_data [EOL] self . _name = name [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . data . is_taps_aff [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] [EOL] [EOL] class TapsAffData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , location ) : [EOL] [docstring] [EOL] from tapsaff import TapsAff [EOL] [EOL] self . _is_taps_aff = None [EOL] self . taps_aff = TapsAff ( location ) [EOL] [EOL] @ property def is_taps_aff ( self ) : [EOL] [docstring] [EOL] return self . _is_taps_aff [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _is_taps_aff = self . taps_aff . is_taps_aff [EOL] except RuntimeError : [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Tuple , Pattern , Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] import subprocess [EOL] [docstring] [EOL] import logging [EOL] import subprocess [EOL] import re [EOL] import sys [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import CONF_NAME , CONF_HOST [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_ROUND_TRIP_TIME_AVG = [string] [EOL] ATTR_ROUND_TRIP_TIME_MAX = [string] [EOL] ATTR_ROUND_TRIP_TIME_MDEV = [string] [EOL] ATTR_ROUND_TRIP_TIME_MIN = [string] [EOL] [EOL] CONF_PING_COUNT = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PING_COUNT = [number] [EOL] DEFAULT_DEVICE_CLASS = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PING_MATCHER = re . compile ( [string] ) [EOL] [EOL] PING_MATCHER_BUSYBOX = re . compile ( [string] ) [EOL] [EOL] WIN32_PING_MATCHER = re . compile ( [string] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PING_COUNT , default = DEFAULT_PING_COUNT ) : cv . positive_int , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] count = config . get ( CONF_PING_COUNT ) [EOL] [EOL] add_devices ( [ PingBinarySensor ( name , PingData ( host , count ) ) ] , True ) [EOL] [EOL] [EOL] class PingBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , ping ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . ping = ping [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEFAULT_DEVICE_CLASS [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . ping . available [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . ping . data is not False : [EOL] return { ATTR_ROUND_TRIP_TIME_AVG : self . ping . data [ [string] ] , ATTR_ROUND_TRIP_TIME_MAX : self . ping . data [ [string] ] , ATTR_ROUND_TRIP_TIME_MDEV : self . ping . data [ [string] ] , ATTR_ROUND_TRIP_TIME_MIN : self . ping . data [ [string] ] , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . ping . update ( ) [EOL] [EOL] [EOL] class PingData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , count ) : [EOL] [docstring] [EOL] self . _ip_address = host [EOL] self . _count = count [EOL] self . data = { } [EOL] self . available = False [EOL] [EOL] if sys . platform == [string] : [EOL] self . _ping_cmd = [ [string] , [string] , str ( self . _count ) , [string] , [string] , self . _ip_address ] [EOL] else : [EOL] self . _ping_cmd = [ [string] , [string] , [string] , [string] , str ( self . _count ) , [string] , self . _ip_address ] [EOL] [EOL] def ping ( self ) : [EOL] [docstring] [EOL] pinger = subprocess . Popen ( self . _ping_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] try : [EOL] out = pinger . communicate ( ) [EOL] _LOGGER . debug ( [string] , str ( out ) ) [EOL] if sys . platform == [string] : [EOL] match = WIN32_PING_MATCHER . search ( str ( out ) . split ( [string] ) [ - [number] ] ) [EOL] rtt_min , rtt_avg , rtt_max = match . groups ( ) [EOL] return { [string] : rtt_min , [string] : rtt_avg , [string] : rtt_max , [string] : [string] } [EOL] if [string] not in str ( out ) : [EOL] match = PING_MATCHER_BUSYBOX . search ( str ( out ) . split ( [string] ) [ - [number] ] ) [EOL] rtt_min , rtt_avg , rtt_max = match . groups ( ) [EOL] return { [string] : rtt_min , [string] : rtt_avg , [string] : rtt_max , [string] : [string] } [EOL] match = PING_MATCHER . search ( str ( out ) . split ( [string] ) [ - [number] ] ) [EOL] rtt_min , rtt_avg , rtt_max , rtt_mdev = match . groups ( ) [EOL] return { [string] : rtt_min , [string] : rtt_avg , [string] : rtt_max , [string] : rtt_mdev } [EOL] except ( subprocess . CalledProcessError , AttributeError ) : [EOL] return False [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data = self . ping ( ) [EOL] self . available = bool ( self . data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_NAME , CONF_RESOURCE ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_FUNCTIONS = [string] [EOL] CONF_PINS = [string] [EOL] CONF_INVERT = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PIN_FUNCTION_SCHEMA = vol . Schema ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_INVERT , default = False ) : cv . boolean , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_RESOURCE ) : cv . url , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PINS , default = { } ) : vol . Schema ( { cv . string : PIN_FUNCTION_SCHEMA } ) , vol . Optional ( CONF_FUNCTIONS , default = { } ) : vol . Schema ( { cv . string : PIN_FUNCTION_SCHEMA } ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] resource = config . get ( CONF_RESOURCE ) [EOL] [EOL] try : [EOL] response = requests . get ( resource , timeout = [number] ) [EOL] except requests . exceptions . MissingSchema : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] , resource ) [EOL] return False [EOL] [EOL] dev = [ ] [EOL] pins = config . get ( CONF_PINS ) [EOL] for pinnum , pin in pins . items ( ) : [EOL] dev . append ( ArestSwitchPin ( resource , config . get ( CONF_NAME , response . json ( ) [ CONF_NAME ] ) , pin . get ( CONF_NAME ) , pinnum , pin . get ( CONF_INVERT ) ) ) [EOL] [EOL] functions = config . get ( CONF_FUNCTIONS ) [EOL] for funcname , func in functions . items ( ) : [EOL] dev . append ( ArestSwitchFunction ( resource , config . get ( CONF_NAME , response . json ( ) [ CONF_NAME ] ) , func . get ( CONF_NAME ) , funcname ) ) [EOL] [EOL] add_devices ( dev ) [EOL] [EOL] [EOL] class ArestSwitchBase ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource , location , name ) : [EOL] [docstring] [EOL] self . _resource = resource [EOL] self . _name = [string] . format ( location . title ( ) , name . title ( ) ) [EOL] self . _state = None [EOL] self . _available = True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] [EOL] class ArestSwitchFunction ( ArestSwitchBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource , location , name , func ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( resource , location , name ) [EOL] self . _func = func [EOL] [EOL] request = requests . get ( [string] . format ( self . _resource , self . _func ) , timeout = [number] ) [EOL] [EOL] if request . status_code != [number] : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] try : [EOL] request . json ( ) [ [string] ] [EOL] except KeyError : [EOL] _LOGGER . error ( [string] ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] request = requests . get ( [string] . format ( self . _resource , self . _func ) , timeout = [number] , params = { [string] : [string] } ) [EOL] [EOL] if request . status_code == [number] : [EOL] self . _state = True [EOL] else : [EOL] _LOGGER . error ( [string] , self . _func , self . _resource ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] request = requests . get ( [string] . format ( self . _resource , self . _func ) , timeout = [number] , params = { [string] : [string] } ) [EOL] [EOL] if request . status_code == [number] : [EOL] self . _state = False [EOL] else : [EOL] _LOGGER . error ( [string] , self . _func , self . _resource ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] request = requests . get ( [string] . format ( self . _resource , self . _func ) , timeout = [number] ) [EOL] self . _state = request . json ( ) [ [string] ] != [number] [EOL] self . _available = True [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . warning ( [string] , self . _resource ) [EOL] self . _available = False [EOL] [EOL] [EOL] class ArestSwitchPin ( ArestSwitchBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource , location , name , pin , invert ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( resource , location , name ) [EOL] self . _pin = pin [EOL] self . invert = invert [EOL] [EOL] request = requests . get ( [string] . format ( self . _resource , self . _pin ) , timeout = [number] ) [EOL] if request . status_code != [number] : [EOL] _LOGGER . error ( [string] ) [EOL] self . _available = False [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] turn_on_payload = int ( not self . invert ) [EOL] request = requests . get ( [string] . format ( self . _resource , self . _pin , turn_on_payload ) , timeout = [number] ) [EOL] if request . status_code == [number] : [EOL] self . _state = True [EOL] else : [EOL] _LOGGER . error ( [string] , self . _pin , self . _resource ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] turn_off_payload = int ( self . invert ) [EOL] request = requests . get ( [string] . format ( self . _resource , self . _pin , turn_off_payload ) , timeout = [number] ) [EOL] if request . status_code == [number] : [EOL] self . _state = False [EOL] else : [EOL] _LOGGER . error ( [string] , self . _pin , self . _resource ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] request = requests . get ( [string] . format ( self . _resource , self . _pin ) , timeout = [number] ) [EOL] status_value = int ( self . invert ) [EOL] self . _state = request . json ( ) [ [string] ] != status_value [EOL] self . _available = True [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . warning ( [string] , self . _resource ) [EOL] self . _available = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from time import time [EOL] [EOL] from homeassistant . components . verisure import HUB as hub [EOL] from homeassistant . components . verisure import CONF_SMARTPLUGS [EOL] from homeassistant . components . switch import SwitchDevice [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if not int ( hub . config . get ( CONF_SMARTPLUGS , [number] ) ) : [EOL] return False [EOL] [EOL] hub . update_overview ( ) [EOL] switches = [ ] [EOL] switches . extend ( [ VerisureSmartplug ( device_label ) for device_label in hub . get ( [string] ) ] ) [EOL] add_devices ( switches ) [EOL] [EOL] [EOL] class VerisureSmartplug ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device_id ) : [EOL] [docstring] [EOL] self . _device_label = device_id [EOL] self . _change_timestamp = [number] [EOL] self . _state = False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] if time ( ) - self . _change_timestamp < [number] : [EOL] return self . _state [EOL] self . _state = hub . get_first ( [string] , self . _device_label ) == [string] [EOL] return self . _state [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) is not None [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] hub . session . set_smartplug_state ( self . _device_label , True ) [EOL] self . _state = True [EOL] self . _change_timestamp = time ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] hub . session . set_smartplug_state ( self . _device_label , False ) [EOL] self . _state = False [EOL] self . _change_timestamp = time ( ) [EOL] [EOL] [comment] [EOL] def update ( self ) : [EOL] [docstring] [EOL] hub . update_overview ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . components . homematic import HMDevice , ATTR_DISCOVER_DEVICES [EOL] from homeassistant . const import STATE_UNKNOWN [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] devices = [ ] [EOL] for conf in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] new_device = HMSwitch ( conf ) [EOL] devices . append ( new_device ) [EOL] [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class HMSwitch ( HMDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] try : [EOL] return self . _hm_get_state ( ) > [number] [EOL] except TypeError : [EOL] return False [EOL] [EOL] @ property def today_energy_kwh ( self ) : [EOL] [docstring] [EOL] if [string] in self . _data : [EOL] try : [EOL] return self . _data [ [string] ] / [number] [EOL] except ZeroDivisionError : [EOL] return [number] [EOL] [EOL] return None [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _hmdevice . on ( self . _channel ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _hmdevice . off ( self . _channel ) [EOL] [EOL] def _init_data_struct ( self ) : [EOL] [docstring] [EOL] self . _state = [string] [EOL] self . _data . update ( { self . _state : STATE_UNKNOWN } ) [EOL] [EOL] [comment] [EOL] for node in self . _hmdevice . SENSORNODE : [EOL] self . _data . update ( { node : STATE_UNKNOWN } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , CONF_PASSWORD , CONF_USERNAME , STATE_OFF , STATE_ON ) [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGING = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_USERNAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import transmissionrpc [EOL] from transmissionrpc . error import TransmissionError [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] try : [EOL] transmission_api = transmissionrpc . Client ( host , port = port , user = username , password = password ) [EOL] transmission_api . session_stats ( ) [EOL] except TransmissionError as error : [EOL] _LOGGING . error ( [string] , host , port , error . original ) [EOL] return False [EOL] [EOL] add_devices ( [ TransmissionSwitch ( transmission_api , name ) ] ) [EOL] [EOL] [EOL] class TransmissionSwitch ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , transmission_client , name ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . transmission_client = transmission_client [EOL] self . _state = STATE_OFF [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state == STATE_ON [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGING . debug ( [string] ) [EOL] self . transmission_client . set_session ( alt_speed_enabled = True ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGING . debug ( [string] ) [EOL] self . transmission_client . set_session ( alt_speed_enabled = False ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] active = self . transmission_client . get_session ( ) . alt_speed_enabled [EOL] self . _state = STATE_ON if active else STATE_OFF [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Match , Dict , Optional , Any [EOL] import datetime [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] import socket [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] import socket [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import util [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_NAME , CONF_HOST , CONF_PORT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] _PULSEAUDIO_SERVERS = { } [EOL] [EOL] CONF_BUFFER_SIZE = [string] [EOL] CONF_SINK_NAME = [string] [EOL] CONF_SOURCE_NAME = [string] [EOL] CONF_TCP_TIMEOUT = [string] [EOL] [EOL] DEFAULT_BUFFER_SIZE = [number] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_TCP_TIMEOUT = [number] [EOL] [EOL] IGNORED_SWITCH_WARN = [string] [EOL] [EOL] LOAD_CMD = [string] [EOL] [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( milliseconds = [number] ) [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] MOD_REGEX = [string] [string] [EOL] [EOL] UNLOAD_CMD = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SINK_NAME ) : cv . string , vol . Required ( CONF_SOURCE_NAME ) : cv . string , vol . Optional ( CONF_BUFFER_SIZE , default = DEFAULT_BUFFER_SIZE ) : cv . positive_int , vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_TCP_TIMEOUT , default = DEFAULT_TCP_TIMEOUT ) : cv . positive_int , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] sink_name = config . get ( CONF_SINK_NAME ) [EOL] source_name = config . get ( CONF_SOURCE_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] buffer_size = config . get ( CONF_BUFFER_SIZE ) [EOL] tcp_timeout = config . get ( CONF_TCP_TIMEOUT ) [EOL] [EOL] server_id = str . format ( [string] , host , port ) [EOL] [EOL] if server_id in _PULSEAUDIO_SERVERS : [EOL] server = _PULSEAUDIO_SERVERS [ server_id ] [EOL] else : [EOL] server = PAServer ( host , port , buffer_size , tcp_timeout ) [EOL] _PULSEAUDIO_SERVERS [ server_id ] = server [EOL] [EOL] add_devices ( [ PALoopbackSwitch ( hass , name , server , sink_name , source_name ) ] ) [EOL] [EOL] [EOL] class PAServer ( ) : [EOL] [docstring] [EOL] [EOL] _current_module_state = [string] [EOL] [EOL] def __init__ ( self , host , port , buff_sz , tcp_timeout ) : [EOL] [docstring] [EOL] self . _pa_host = host [EOL] self . _pa_port = int ( port ) [EOL] self . _buffer_size = int ( buff_sz ) [EOL] self . _tcp_timeout = int ( tcp_timeout ) [EOL] [EOL] def _send_command ( self , cmd , response_expected ) : [EOL] [docstring] [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] sock . settimeout ( self . _tcp_timeout ) [EOL] try : [EOL] sock . connect ( ( self . _pa_host , self . _pa_port ) ) [EOL] _LOGGER . info ( [string] , cmd ) [EOL] sock . send ( ( cmd + [string] ) . encode ( [string] ) ) [EOL] if response_expected : [EOL] return_data = self . _get_full_response ( sock ) [EOL] _LOGGER . debug ( [string] , return_data ) [EOL] else : [EOL] return_data = [string] [EOL] finally : [EOL] sock . close ( ) [EOL] return return_data [EOL] [EOL] def _get_full_response ( self , sock ) : [EOL] [docstring] [EOL] result = [string] [EOL] rcv_buffer = sock . recv ( self . _buffer_size ) [EOL] result += rcv_buffer . decode ( [string] ) [EOL] [EOL] while len ( rcv_buffer ) == self . _buffer_size : [EOL] rcv_buffer = sock . recv ( self . _buffer_size ) [EOL] result += rcv_buffer . decode ( [string] ) [EOL] [EOL] return result [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update_module_state ( self ) : [EOL] [docstring] [EOL] self . _current_module_state = self . _send_command ( [string] , True ) [EOL] [EOL] def turn_on ( self , sink_name , source_name ) : [EOL] [docstring] [EOL] self . _send_command ( str . format ( LOAD_CMD , sink_name , source_name ) , False ) [EOL] [EOL] def turn_off ( self , module_idx ) : [EOL] [docstring] [EOL] self . _send_command ( str . format ( UNLOAD_CMD , module_idx ) , False ) [EOL] [EOL] def get_module_idx ( self , sink_name , source_name ) : [EOL] [docstring] [EOL] result = re . search ( str . format ( MOD_REGEX , re . escape ( sink_name ) , re . escape ( source_name ) ) , self . _current_module_state ) [EOL] if result and result . group ( [number] ) . isdigit ( ) : [EOL] return int ( result . group ( [number] ) ) [EOL] return - [number] [EOL] [EOL] [EOL] class PALoopbackSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , pa_server , sink_name , source_name ) : [EOL] [docstring] [EOL] self . _module_idx = - [number] [EOL] self . _hass = hass [EOL] self . _name = name [EOL] self . _sink_name = sink_name [EOL] self . _source_name = source_name [EOL] self . _pa_svr = pa_server [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _module_idx > [number] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . is_on : [EOL] self . _pa_svr . turn_on ( self . _sink_name , self . _source_name ) [EOL] self . _pa_svr . update_module_state ( no_throttle = True ) [EOL] self . _module_idx = self . _pa_svr . get_module_idx ( self . _sink_name , self . _source_name ) [EOL] self . schedule_update_ha_state ( ) [EOL] else : [EOL] _LOGGER . warning ( IGNORED_SWITCH_WARN ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . is_on : [EOL] self . _pa_svr . turn_off ( self . _module_idx ) [EOL] self . _pa_svr . update_module_state ( no_throttle = True ) [EOL] self . _module_idx = self . _pa_svr . get_module_idx ( self . _sink_name , self . _source_name ) [EOL] self . schedule_update_ha_state ( ) [EOL] else : [EOL] _LOGGER . warning ( IGNORED_SWITCH_WARN ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _pa_svr . update_module_state ( ) [EOL] self . _module_idx = self . _pa_svr . get_module_idx ( self . _sink_name , self . _source_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $socket.socket$ 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Generator , Any [EOL] import logging [EOL] import typing [EOL] import asyncio [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . components . ring import ( DATA_RING , CONF_ATTRIBUTION , NOTIFICATION_ID ) [EOL] from homeassistant . components . camera import Camera , PLATFORM_SCHEMA [EOL] from homeassistant . components . ffmpeg import DATA_FFMPEG [EOL] from homeassistant . const import ATTR_ATTRIBUTION , CONF_SCAN_INTERVAL [EOL] from homeassistant . helpers . aiohttp_client import async_aiohttp_proxy_stream [EOL] from homeassistant . util import dt as dt_util [EOL] [EOL] CONF_FFMPEG_ARGUMENTS = [string] [EOL] [EOL] DEPENDENCIES = [ [string] , [string] ] [EOL] [EOL] FORCE_REFRESH_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_FFMPEG_ARGUMENTS ) : cv . string , vol . Optional ( CONF_SCAN_INTERVAL , default = SCAN_INTERVAL ) : cv . time_period , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] ring = hass . data [ DATA_RING ] [EOL] [EOL] cams = [ ] [EOL] cams_no_plan = [ ] [EOL] for camera in ring . doorbells : [EOL] if camera . has_subscription : [EOL] cams . append ( RingCam ( hass , camera , config ) ) [EOL] else : [EOL] cams_no_plan . append ( camera ) [EOL] [EOL] for camera in ring . stickup_cams : [EOL] if camera . has_subscription : [EOL] cams . append ( RingCam ( hass , camera , config ) ) [EOL] else : [EOL] cams_no_plan . append ( camera ) [EOL] [EOL] [comment] [EOL] if cams_no_plan : [EOL] cameras = str ( [string] . join ( [ camera . name for camera in cams_no_plan ] ) ) [EOL] [EOL] err_msg = [string] [string] . format ( cameras ) [EOL] [EOL] _LOGGER . error ( err_msg ) [EOL] hass . components . persistent_notification . async_create ( [string] [string] [string] . format ( err_msg ) , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] [EOL] async_add_devices ( cams , True ) [EOL] return True [EOL] [EOL] [EOL] class RingCam ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , camera , device_info ) : [EOL] [docstring] [EOL] super ( RingCam , self ) . __init__ ( ) [EOL] self . _camera = camera [EOL] self . _hass = hass [EOL] self . _name = self . _camera . name [EOL] self . _ffmpeg = hass . data [ DATA_FFMPEG ] [EOL] self . _ffmpeg_arguments = device_info . get ( CONF_FFMPEG_ARGUMENTS ) [EOL] self . _last_video_id = self . _camera . last_recording_id [EOL] self . _video_url = self . _camera . recording_url ( self . _last_video_id ) [EOL] self . _utcnow = dt_util . utcnow ( ) [EOL] self . _expires_at = FORCE_REFRESH_INTERVAL + self . _utcnow [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , [string] : self . _camera . id , [string] : self . _camera . firmware , [string] : self . _camera . kind , [string] : self . _camera . timezone , [string] : self . _camera . family , [string] : self . _video_url , } [EOL] [EOL] @ asyncio . coroutine def async_camera_image ( self ) : [EOL] [docstring] [EOL] from haffmpeg import ImageFrame , IMAGE_JPEG [EOL] ffmpeg = ImageFrame ( self . _ffmpeg . binary , loop = self . hass . loop ) [EOL] [EOL] if self . _video_url is None : [EOL] return [EOL] [EOL] image = yield from asyncio . shield ( ffmpeg . get_image ( self . _video_url , output_format = IMAGE_JPEG , extra_cmd = self . _ffmpeg_arguments ) , loop = self . hass . loop ) [EOL] return image [EOL] [EOL] @ asyncio . coroutine def handle_async_mjpeg_stream ( self , request ) : [EOL] [docstring] [EOL] from haffmpeg import CameraMjpeg [EOL] [EOL] if self . _video_url is None : [EOL] return [EOL] [EOL] stream = CameraMjpeg ( self . _ffmpeg . binary , loop = self . hass . loop ) [EOL] yield from stream . open_camera ( self . _video_url , extra_cmd = self . _ffmpeg_arguments ) [EOL] [EOL] yield from async_aiohttp_proxy_stream ( self . hass , request , stream , [string] ) [EOL] yield from stream . close ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] self . _camera . update ( ) [EOL] self . _utcnow = dt_util . utcnow ( ) [EOL] [EOL] last_recording_id = self . _camera . last_recording_id [EOL] [EOL] if self . _last_video_id != last_recording_id or self . _utcnow >= self . _expires_at : [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] [comment] [EOL] self . _last_video_id = self . _camera . last_recording_id [EOL] self . _video_url = self . _camera . recording_url ( self . _last_video_id ) [EOL] self . _expires_at = FORCE_REFRESH_INTERVAL + self . _utcnow [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[asyncio.futures.Future[typing.Any],None,None]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[asyncio.futures.Future[typing.Any],None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components import mqtt [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . components . camera import Camera , PLATFORM_SCHEMA [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_TOPIC = [string] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_TOPIC ) : mqtt . valid_subscribe_topic , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] config = PLATFORM_SCHEMA ( discovery_info ) [EOL] [EOL] async_add_devices ( [ MqttCamera ( config . get ( CONF_NAME ) , config . get ( CONF_TOPIC ) ) ] ) [EOL] [EOL] [EOL] class MqttCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , topic ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _name = name [EOL] self . _topic = topic [EOL] self . _qos = [number] [EOL] self . _last_image = None [EOL] [EOL] @ asyncio . coroutine def async_camera_image ( self ) : [EOL] [docstring] [EOL] return self . _last_image [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] @ callback def message_received ( topic , payload , qos ) : [EOL] [docstring] [EOL] self . _last_image = payload [EOL] [EOL] return mqtt . async_subscribe ( self . hass , self . _topic , message_received , self . _qos , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components import mysensors [EOL] from homeassistant . components . notify import ( ATTR_TARGET , DOMAIN , BaseNotificationService ) [EOL] [EOL] [EOL] async def async_get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] new_devices = mysensors . setup_mysensors_platform ( hass , DOMAIN , discovery_info , MySensorsNotificationDevice ) [EOL] if not new_devices : [EOL] return None [EOL] return MySensorsNotificationService ( hass ) [EOL] [EOL] [EOL] class MySensorsNotificationDevice ( mysensors . device . MySensorsDevice ) : [EOL] [docstring] [EOL] [EOL] def send_msg ( self , msg ) : [EOL] [docstring] [EOL] for sub_msg in [ msg [ i : i + [number] ] for i in range ( [number] , len ( msg ) , [number] ) ] : [EOL] [comment] [EOL] self . gateway . set_child_value ( self . node_id , self . child_id , self . value_type , sub_msg ) [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . name ) [EOL] [EOL] [EOL] class MySensorsNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass ) : [EOL] [docstring] [EOL] self . devices = mysensors . get_mysensors_devices ( hass , DOMAIN ) [EOL] [EOL] async def async_send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] target_devices = kwargs . get ( ATTR_TARGET ) [EOL] devices = [ device for device in self . devices . values ( ) if target_devices is None or device . name in target_devices ] [EOL] [EOL] for device in devices : [EOL] device . send_msg ( message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . components . notify import BaseNotificationService [EOL] [EOL] EVENT_NOTIFY = [string] [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] return DemoNotificationService ( hass ) [EOL] [EOL] [EOL] class DemoNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] [EOL] @ property def targets ( self ) : [EOL] [docstring] [EOL] return { [string] : [string] } [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] kwargs [ [string] ] = message [EOL] self . hass . bus . fire ( EVENT_NOTIFY , kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
import builtins [EOL] from typing import List , Dict , Any [EOL] import logging [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import json [EOL] import logging [EOL] [EOL] from aiohttp . hdrs import CONTENT_TYPE [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . notify import ( PLATFORM_SCHEMA , BaseNotificationService ) [EOL] from homeassistant . const import ( CONF_API_KEY , CONF_RECIPIENT , CONF_SENDER , CONF_USERNAME , CONTENT_TYPE_JSON ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] BASE_API_URL = [string] [EOL] [EOL] HEADERS = { CONTENT_TYPE : CONTENT_TYPE_JSON } [EOL] [EOL] [EOL] def validate_sender ( config ) : [EOL] [docstring] [EOL] if CONF_SENDER in config : [EOL] return config [EOL] config [ CONF_SENDER ] = config [ CONF_RECIPIENT ] [EOL] return config [EOL] [EOL] [EOL] PLATFORM_SCHEMA = vol . Schema ( vol . All ( PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_RECIPIENT , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_SENDER ) : cv . string , } ) , validate_sender ) ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] print ( [string] , config ) [EOL] if _authenticate ( config ) is False : [EOL] _LOGGER . exception ( [string] ) [EOL] return None [EOL] [EOL] return ClicksendNotificationService ( config ) [EOL] [EOL] [EOL] class ClicksendNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . username = config . get ( CONF_USERNAME ) [EOL] self . api_key = config . get ( CONF_API_KEY ) [EOL] self . recipients = config . get ( CONF_RECIPIENT ) [EOL] self . sender = config . get ( CONF_SENDER , CONF_RECIPIENT ) [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] data = { [string] : [ ] } [EOL] for recipient in self . recipients : [EOL] data [ [string] ] . append ( { [string] : [string] , [string] : self . sender , [string] : recipient , [string] : message , } ) [EOL] [EOL] api_url = [string] . format ( BASE_API_URL ) [EOL] [EOL] resp = requests . post ( api_url , data = json . dumps ( data ) , headers = HEADERS , auth = ( self . username , self . api_key ) , timeout = [number] ) [EOL] [EOL] obj = json . loads ( resp . text ) [EOL] response_msg = obj [ [string] ] [EOL] response_code = obj [ [string] ] [EOL] [EOL] if resp . status_code != [number] : [EOL] _LOGGER . error ( [string] , resp . status_code , response_msg , response_code ) [EOL] [EOL] [EOL] def _authenticate ( config ) : [EOL] [docstring] [EOL] api_url = [string] . format ( BASE_API_URL ) [EOL] resp = requests . get ( api_url , headers = HEADERS , auth = ( config . get ( CONF_USERNAME ) , config . get ( CONF_API_KEY ) ) , timeout = [number] ) [EOL] [EOL] if resp . status_code != [number] : [EOL] return False [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , Callable [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Callable , TypeVar [EOL] [EOL] CALLABLE_T = TypeVar ( [string] , bound = Callable ) [comment] [EOL] [EOL] [EOL] class Registry ( dict ) : [EOL] [docstring] [EOL] [EOL] def register ( self , name ) : [EOL] [docstring] [EOL] def decorator ( func ) : [EOL] [docstring] [EOL] self [ name ] = func [EOL] return func [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[CALLABLE_T],CALLABLE_T]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $CALLABLE_T$ 0 $CALLABLE_T$ 0 0 0 0 0 0 0 0 0 0 $CALLABLE_T$ 0 0 $CALLABLE_T$ 0 0 0 0 0