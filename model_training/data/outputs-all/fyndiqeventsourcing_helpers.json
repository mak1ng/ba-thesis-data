from typing import Callable , Any , List [EOL] import typing [EOL] import builtins [EOL] import _importlib_modulespec [EOL] from copy import deepcopy [EOL] from importlib import import_module [EOL] from typing import Any , Callable , List [EOL] [EOL] [EOL] def import_backend ( location ) : [EOL] [docstring] [EOL] module_name , class_name = location . rsplit ( [string] , [number] ) [EOL] module = import_module ( f'{ module_name }' ) [EOL] [EOL] backend_cls = getattr ( module , class_name ) [EOL] return backend_cls [EOL] [EOL] [EOL] def get_all_nested_keys ( data , current_keys ) : [EOL] [docstring] [EOL] all_keys = deepcopy ( current_keys ) [EOL] if isinstance ( data , dict ) : [EOL] all_keys . extend ( list ( data . keys ( ) ) ) [EOL] for key , value in data . items ( ) : [EOL] if key == [string] : [EOL] all_keys . append ( value ) [EOL] else : [EOL] all_keys = get_all_nested_keys ( value , all_keys ) [EOL] elif isinstance ( data , ( list , tuple ) ) : [EOL] for item in data : [EOL] all_keys = get_all_nested_keys ( item , all_keys ) [EOL] [EOL] return all_keys [EOL] [EOL] [EOL] def get_callable_representation ( target ) : [EOL] [docstring] [EOL] return getattr ( target , [string] , getattr ( target , [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] import eventsourcing_helpers [EOL] from functools import wraps [EOL] [EOL] base_metric = [string] [EOL] [EOL] [EOL] class StatsdNullClient : [EOL] [docstring] [EOL] __call__ = __getattr__ = lambda self , * _ , ** __ : self [EOL] [EOL] def timed ( self , * args , ** kwargs ) : [EOL] return TimedNullDecorator ( ) [EOL] [EOL] [EOL] class TimedNullDecorator : [EOL] __enter__ = __getattr__ = lambda self , * _ , ** __ : self [EOL] [EOL] def __call__ ( self , f ) : [EOL] def wrapped ( * args , ** kwargs ) : [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] return wrapped [EOL] [EOL] def __exit__ ( self , * args ) : [EOL] pass [EOL] [EOL] [EOL] try : [EOL] import datadog [EOL] statsd = datadog . statsd [EOL] except ModuleNotFoundError : [EOL] statsd = StatsdNullClient ( ) [comment] [EOL] [EOL] [EOL] def call_counter ( base_metric ) : [EOL] def wrapped ( f ) : [EOL] @ wraps ( f ) def decorator ( * args , ** kwargs ) : [EOL] statsd . increment ( f"{ base_metric } [string] " ) [EOL] try : [EOL] return f ( * args , ** kwargs ) [EOL] except Exception : [EOL] statsd . increment ( f"{ base_metric } [string] " ) [EOL] raise [EOL] return decorator [EOL] return wrapped [EOL] [EOL] [EOL] def timed ( base_metric , tags = None ) : [EOL] if tags is None : [EOL] tags = [ ] [EOL] [EOL] def wrapped ( f ) : [EOL] @ wraps ( f ) def decorator ( * args , ** kwargs ) : [EOL] with statsd . timed ( f"{ base_metric } [string] " , tags = tags ) : [EOL] return f ( * args , ** kwargs ) [EOL] return decorator [EOL] return wrapped [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $eventsourcing_helpers.metrics.StatsdNullClient$ 0 0 0 $eventsourcing_helpers.metrics.StatsdNullClient$ 0 0 0 0 0 $eventsourcing_helpers.metrics.StatsdNullClient$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $eventsourcing_helpers.metrics.StatsdNullClient$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $eventsourcing_helpers.metrics.StatsdNullClient$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $eventsourcing_helpers.metrics.StatsdNullClient$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Callable [EOL] import typing [EOL] import builtins [EOL] from typing import Callable [EOL] [EOL] import structlog [EOL] [EOL] from eventsourcing_helpers . utils import import_backend [EOL] [EOL] BACKENDS = { [string] : [string] , [string] : [string] } [EOL] [EOL] logger = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] class MessageBus : [EOL] [docstring] [EOL] DEFAULT_BACKEND = [string] [EOL] [EOL] def __init__ ( self , config , importer = import_backend , ** kwargs ) : [EOL] backend_path = config . get ( [string] , BACKENDS [ self . DEFAULT_BACKEND ] ) [EOL] assert [string] in config , [string] [EOL] backend_config = config . get ( [string] ) [EOL] [EOL] logger . debug ( [string] , backend = backend_path , config = backend_config ) [EOL] backend_class = importer ( backend_path ) [EOL] self . backend = backend_class ( config = backend_config , ** kwargs ) [EOL] [EOL] def produce ( self , value , key = None , ** kwargs ) : [EOL] [docstring] [EOL] self . backend . produce ( key = key , value = value , ** kwargs ) [EOL] [EOL] def get_consumer ( self ) : [EOL] [docstring] [EOL] return self . backend . get_consumer ( ) [EOL] [EOL] def consume ( self , handler ) : [EOL] [docstring] [EOL] self . backend . consume ( handler ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 $typing.Callable$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $typing.Any$ 0 $builtins.dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.dict$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Callable$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.dict$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0
import builtins [EOL] class MessageBusBackend : [EOL] [docstring] [EOL] [EOL] def produce ( self , value , key = None , ** kwargs ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def get_consumer ( self ) : [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Deque , Any , Callable [EOL] import builtins [EOL] import confluent_kafka_helpers [EOL] import typing [EOL] import eventsourcing_helpers [EOL] from collections import deque [EOL] from dataclasses import dataclass , field [EOL] from typing import Callable , Deque [EOL] [EOL] import structlog [EOL] [EOL] from confluent_kafka_helpers . message import Message [EOL] [EOL] from eventsourcing_helpers . messagebus . backends import MessageBusBackend [EOL] from eventsourcing_helpers . messagebus . backends . mock . utils import create_message [EOL] [EOL] logger = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] @ dataclass class Consumer : [EOL] messages = field ( default_factory = deque ) [EOL] [EOL] def add_message ( self , message_class , data , headers = None ) : [EOL] message = create_message ( message_class = message_class , data = data , headers = headers ) [EOL] self . messages . append ( message ) [EOL] [EOL] def get_messages ( self ) : [EOL] return self . messages [EOL] [EOL] def assert_one_message_added_with ( self , message_class , data , headers = None ) : [EOL] if headers is None : [EOL] headers = { } [EOL] assert len ( self . messages ) == [number] [EOL] assert { [string] : message_class , [string] : data } == self . messages [ [number] ] . value [EOL] assert headers == self . messages [ [number] ] . _meta . headers [EOL] [EOL] [EOL] @ dataclass class Producer : [EOL] messages = field ( default_factory = deque ) [EOL] [EOL] def add_message ( self , message ) : [EOL] self . messages . append ( message ) [EOL] [EOL] def clear_messages ( self ) : [EOL] self . messages . clear ( ) [EOL] [EOL] def assert_one_message_produced_with ( self , key , value , ** kwargs ) : [EOL] assert len ( self . messages ) == [number] [EOL] assert dict ( key = key , value = value , ** kwargs ) in self . messages [EOL] [EOL] def assert_no_messages_produced ( self ) : [EOL] assert len ( self . messages ) == [number] [EOL] [EOL] [EOL] class MockBackend ( MessageBusBackend ) : [EOL] def __init__ ( self , config ) : [EOL] self . consumer = Consumer ( ) [EOL] self . producer = Producer ( ) [EOL] [EOL] def produce ( self , value , key = None , ** kwargs ) : [EOL] self . producer . add_message ( dict ( value = value , key = key , ** kwargs ) ) [EOL] [EOL] def consume ( self , handler ) : [EOL] messages = self . consumer . get_messages ( ) [EOL] while messages : [EOL] handler ( messages . popleft ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Deque[confluent_kafka_helpers.message.Message]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.dict$ 0 $builtins.dict$ 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Deque[confluent_kafka_helpers.message.Message]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Deque[builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 0 0 0 0 $eventsourcing_helpers.messagebus.backends.mock.Consumer$ 0 0 0 0 0 0 0 $eventsourcing_helpers.messagebus.backends.mock.Producer$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0
from typing import Any , Union [EOL] import builtins [EOL] import confluent_kafka_helpers [EOL] import typing [EOL] import unittest [EOL] import copy [EOL] import time [EOL] from typing import Union [EOL] from unittest . mock import MagicMock [EOL] [EOL] from confluent_kafka_helpers . message import Message [EOL] [EOL] [EOL] def create_message ( message_class , data , headers ) : [EOL] kafka_message = MagicMock ( ) [EOL] kafka_message . configure_mock ( ** { [string] : { [string] : message_class , [string] : copy . deepcopy ( data ) } , [string] : ( [number] , time . time ( ) ) , [string] : headers } ) [EOL] message = Message ( kafka_message = kafka_message ) [EOL] return message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $confluent_kafka_helpers.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import tests [EOL] import typing [EOL] import unittest [EOL] import eventsourcing_helpers [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import pytest [EOL] [EOL] from eventsourcing_helpers . models import AggregateRoot , Entity , EntityDict [EOL] [EOL] [EOL] class Foo ( AggregateRoot ) : [EOL] pass [EOL] [EOL] [EOL] class Bar ( Entity ) : [EOL] pass [EOL] [EOL] [EOL] class LargerTestAggregate ( AggregateRoot ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . title = None [EOL] self . description = None [EOL] self . status = None [EOL] self . tags = None [EOL] self . properties = None [EOL] [EOL] [EOL] class NestedAggregate ( AggregateRoot ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . nested_entity = EntityDict ( ) [EOL] self . nested_entity . nested_entity_id = [string] [EOL] [EOL] [EOL] class DoubleNestedAggregate ( AggregateRoot ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . nested_entity = EntityDict ( ) [EOL] self . nested_entity . nested_entity_id = [string] [EOL] self . nested_entity . second_nested_entity = EntityDict ( ) [EOL] self . nested_entity . second_nested_entity . second_nested_entity_id = [string] [EOL] [EOL] [EOL] class AggregateRootTests : [EOL] [EOL] def test_subclass ( self ) : [EOL] [docstring] [EOL] aggregate_root = Foo ( ) [EOL] [EOL] assert isinstance ( aggregate_root , AggregateRoot ) [EOL] assert isinstance ( aggregate_root , Entity ) [EOL] [EOL] [EOL] class EntityTests : [EOL] [EOL] def setup_method ( self ) : [EOL] self . aggregate_root = Foo ( ) [EOL] self . entity = Bar ( ) [EOL] self . event = Mock ( ) [EOL] self . event . _class = [string] [EOL] self . event . id = [number] [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) @ patch ( [string] ) def test_apply_event ( self , mock_event , mock_entity , mock_apply ) : [EOL] [docstring] [EOL] mock_apply . return_value = [string] [EOL] is_new = False [EOL] [EOL] self . aggregate_root . apply_event ( self . event ) [EOL] [EOL] mock_apply . called_once_with ( self . event . __class__ . __name__ ) [EOL] mock_entity . called_once_with ( self . event . id ) [EOL] mock_event . called_once_with ( self . event , self . aggregate_root , [string] , is_new ) [EOL] [EOL] @ patch ( [string] ) def test_apply_events ( self , mock_apply ) : [EOL] [docstring] [EOL] num_events = [number] [EOL] events = [ None ] * num_events [EOL] [EOL] self . aggregate_root . _apply_events ( events ) [EOL] assert mock_apply . call_count == num_events [EOL] [EOL] def test_clear_events ( self ) : [EOL] [docstring] [EOL] self . aggregate_root . _events . append ( self . event ) [EOL] self . entity . _events . append ( self . event ) [EOL] [EOL] assert len ( self . aggregate_root . _events ) == [number] [EOL] self . aggregate_root . _clear_staged_events ( ) [EOL] [EOL] assert len ( self . aggregate_root . _events ) == [number] [EOL] assert len ( self . entity . _events ) == [number] [EOL] [EOL] def test_create_id ( self ) : [EOL] [docstring] [EOL] id = self . entity . create_id ( ) [EOL] [EOL] assert isinstance ( id , str ) [EOL] assert len ( id ) == [number] [EOL] [EOL] def test_get_apply_method_name ( self ) : [EOL] [docstring] [EOL] apply_method_name = self . entity . _get_apply_method_name ( self . event . _class ) [EOL] assert apply_method_name == [string] [EOL] [EOL] @ patch ( [string] ) def test_get_entity ( self , mock_entities ) : [EOL] [docstring] [EOL] self . aggregate_root . id = [number] [EOL] self . entity . id = [number] [EOL] [EOL] entities = [ self . aggregate_root , self . entity ] [EOL] mock_entities . return_value = entities [EOL] entity = self . aggregate_root . _get_entity ( self . entity . id ) [EOL] assert entity == self . entity [EOL] [EOL] entities . pop ( ) [EOL] mock_entities . return_value = entities [EOL] entity = self . aggregate_root . _get_entity ( self . entity . id ) [EOL] assert entity == self . aggregate_root [EOL] [EOL] @ patch ( [string] ) def test_get_all_entities ( self , mock_entities ) : [EOL] [docstring] [EOL] mock_entities . return_value = [ self . entity ] [EOL] entities = self . aggregate_root . _get_all_entities ( ) [EOL] [EOL] assert list ( entities ) == [ self . aggregate_root , self . entity ] [EOL] [EOL] @ patch ( [string] ) def test_get_child_entities ( self , mock_entities ) : [EOL] [docstring] [EOL] self . aggregate_root . __dict__ . update ( { [string] : self . entity } ) [EOL] mock_entities . return_value = [ self . entity ] [EOL] entities = self . aggregate_root . _get_child_entities ( ) [EOL] [EOL] assert list ( entities ) == [ self . entity ] [EOL] [EOL] def test_stage_event ( self ) : [EOL] [docstring] [EOL] self . entity . _stage_event ( self . event , is_new = False ) [EOL] assert len ( self . entity . _events ) == [number] [EOL] [EOL] self . entity . _stage_event ( self . event , is_new = True ) [EOL] assert len ( self . entity . _events ) == [number] [EOL] assert self . event in self . entity . _events [EOL] [EOL] def test_get_apply_method ( self ) : [EOL] [docstring] [EOL] mock_method = Mock ( ) [EOL] self . aggregate_root . apply_foo_event = mock_method [EOL] method = self . aggregate_root . _get_apply_method ( self . aggregate_root , [string] ) [EOL] assert method == mock_method [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_apply_event_aggregate_root ( self , mock_stage , mock_apply ) : [EOL] [docstring] [EOL] method_name , is_new = [string] , True [EOL] [EOL] self . aggregate_root . _apply_event ( self . event , self . aggregate_root , method_name , is_new ) [EOL] mock_apply . assert_called_once_with ( self . aggregate_root , method_name ) [EOL] mock_stage . assert_called_once_with ( self . event , is_new ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Foo ( ) , [ [string] , [string] , [string] ] ) , ( LargerTestAggregate ( ) , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , ] ) def test_get_representation_includes_name_and_fields ( self , entity , data ) : [EOL] representation = entity . get_representation ( ) [EOL] for field in data : [EOL] assert field in representation [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( NestedAggregate ( ) , [ [string] , [string] , [string] , [string] , [string] , [string] ] ) , ( DoubleNestedAggregate ( ) , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , ] ) def test_get_representation_handles_nested_entities ( self , entity , data ) : [EOL] representation = entity . get_representation ( ) [EOL] for field in data : [EOL] assert field in representation [EOL] [EOL] [EOL] class EntityDictTests : [EOL] [EOL] def setup_method ( self ) : [EOL] self . entity = Bar ( ) [EOL] self . entity_dict = EntityDict ( { [number] : self . entity } ) [EOL] [EOL] def test_values ( self ) : [EOL] [docstring] [EOL] with pytest . raises ( AssertionError ) : [EOL] self . entity_dict [ [number] ] = { [number] : [string] } [EOL] [EOL] self . entity_dict [ [number] ] = Foo ( ) [EOL] [EOL] @ patch ( [string] ) def test_get_all_entities ( self , mock_entities ) : [EOL] [docstring] [EOL] self . entity_dict . _get_all_entities ( ) [EOL] mock_entities . assert_called_once ( ) [EOL] [EOL] @ patch ( [string] ) def test_get_child_entities ( self , mock_entities ) : [EOL] [docstring] [EOL] mock_entities . return_value = [ self . entity ] [EOL] entities = self . entity_dict . _get_child_entities ( ) [EOL] [EOL] assert list ( entities ) == [ self . entity ] [EOL] mock_entities . assert_called_once ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $eventsourcing_helpers.models.EntityDict$ 0 0 0 0 0 0 0 $eventsourcing_helpers.models.EntityDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $eventsourcing_helpers.models.EntityDict$ 0 0 0 0 0 0 0 $eventsourcing_helpers.models.EntityDict$ 0 0 0 0 0 0 0 $eventsourcing_helpers.models.EntityDict$ 0 0 0 0 0 0 0 0 0 $eventsourcing_helpers.models.EntityDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_models.Foo$ 0 0 0 0 0 0 0 0 0 $tests.test_models.Foo$ 0 0 0 0 0 0 0 $tests.test_models.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[None]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[None]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import call , patch [EOL] [EOL] import pytest [EOL] [EOL] from eventsourcing_helpers . metrics import StatsdNullClient , call_counter [EOL] [EOL] [EOL] class StatsdNullClientTests : [EOL] def setup_method ( self ) : [EOL] self . client = StatsdNullClient ( ) [EOL] [EOL] def test_method_calls_should_not_fail ( self ) : [EOL] self . client . increment ( [string] , [number] ) [EOL] self . client . foo ( [string] , [number] ) [EOL] [EOL] def test_timed_decorator_should_execute_decorated_method ( self ) : [EOL] @ self . client . timed ( [string] , [number] ) def foo ( a ) : [EOL] return a [EOL] [EOL] value = foo ( [string] ) [EOL] assert value == [string] [EOL] [EOL] [EOL] class CallCounterTests : [EOL] @ patch ( [string] ) def test_increments_total_count ( self , mock_statsd ) : [EOL] @ call_counter ( [string] ) def foo ( a ) : [EOL] pass [EOL] [EOL] foo ( [string] ) [EOL] mock_statsd . increment . assert_called_once_with ( [string] ) [EOL] [EOL] @ patch ( [string] ) def test_increments_counts_and_reraises_exception ( self , mock_statsd ) : [EOL] @ call_counter ( [string] ) def foo ( a ) : [EOL] [number] / [number] [EOL] [EOL] with pytest . raises ( ZeroDivisionError ) : [EOL] foo ( [string] ) [EOL] expected_calls = [ call ( [string] ) , call ( [string] ) ] [EOL] mock_statsd . increment . assert_has_calls ( expected_calls ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0
	0
	0
from typing import Dict , Any , Union [EOL] import typing [EOL] from eventsourcing_helpers . repository . backends . kafka import config [EOL] [EOL] [EOL] class KafkaConfigTests : [EOL] [EOL] def setup_method ( self ) : [EOL] self . config = { [string] : [string] , [string] : [string] , [string] : { [string] : [number] } , [string] : { [string] : [number] , [string] : { [string] : [number] } } } [EOL] [EOL] def test_get_producer_config ( self ) : [EOL] [docstring] [EOL] producer_config = config . get_producer_config ( self . config ) [EOL] expected_config = { [string] : [string] , [string] : [string] , [string] : [number] } [EOL] assert producer_config == expected_config [EOL] [EOL] def test_get_loader_config ( self ) : [EOL] [docstring] [EOL] loader_config = config . get_loader_config ( self . config ) [EOL] expected_config = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : { [string] : [string] , [string] : [string] , [string] : [number] } } [EOL] assert loader_config == expected_config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]],builtins.int,builtins.str]]$ 0
from typing import Dict , Tuple , Any , List [EOL] import typing [EOL] import unittest [EOL] from functools import partial [EOL] from unittest . mock import MagicMock , Mock , patch [EOL] [EOL] from eventsourcing_helpers . repository . backends . kafka import KafkaAvroBackend [EOL] [EOL] events = [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] class KafkaBackendTests : [EOL] def setup_method ( self ) : [EOL] config = { [string] : events } [EOL] self . loader = MagicMock ( ) [EOL] self . loader . configure_mock ( ** config ) [EOL] self . producer = Mock ( ) [EOL] self . value_serializer = Mock ( ) [EOL] self . config = { [string] : { [string] : [string] } , [string] : { [string] : [string] } } [EOL] self . get_producer_config = Mock ( return_value = self . config [ [string] ] ) [EOL] self . get_loader_config = Mock ( return_value = self . config [ [string] ] ) [EOL] self . id , self . events = [number] , [ [number] , [number] , [number] ] [EOL] self . backend = partial ( KafkaAvroBackend , self . config , self . producer , self . loader , self . value_serializer , self . get_producer_config , self . get_loader_config ) [EOL] [EOL] def test_init ( self ) : [EOL] [docstring] [EOL] self . backend ( ) [EOL] [EOL] self . loader . assert_called_once_with ( self . config [ [string] ] ) [EOL] self . producer . assert_called_once_with ( { [string] : [string] } , value_serializer = self . value_serializer ) [EOL] [EOL] def test_commit ( self ) : [EOL] [docstring] [EOL] backend = self . backend ( ) [EOL] backend . commit ( self . id , self . events ) [EOL] [EOL] expected = [ ( { [string] : self . id , [string] : e } , ) for e in self . events ] [EOL] assert self . producer . return_value . produce . call_args_list == expected [EOL] assert self . producer . return_value . produce . call_count == len ( self . events ) [EOL] [EOL] def test_load ( self ) : [EOL] [docstring] [EOL] backend = self . backend ( ) [EOL] backend . load ( self . id ) [EOL] self . loader . return_value . load . assert_called_once_with ( self . id ) [EOL] [EOL] def test_get_events ( self ) : [EOL] backend = self . backend ( ) [EOL] config = { [string] : events } [EOL] load_mock = MagicMock ( ) [EOL] load_mock . configure_mock ( ** config ) [EOL] [EOL] with patch ( [string] , load_mock ) : [EOL] _events = backend . get_events ( id ) [EOL] assert events == list ( _events ) [EOL] load_mock . assert_called_once_with ( id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.Tuple[typing.Dict[builtins.str,unknown]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Dict[builtins.str,unknown]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.int]]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Any$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0
import builtins [EOL] from typing import Type , Any [EOL] import tests [EOL] import typing [EOL] from functools import partial [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] [EOL] from eventsourcing_helpers . repository . snapshot import Snapshot [EOL] [EOL] [EOL] class SnapshotTests : [EOL] config = { [string] : { } } [EOL] snapshot_data_mock = [string] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def setup_method ( self , aggregate_root_cls_mock , snapshot_backend_mock , importer_mock ) : [EOL] self . aggregate_root_cls = aggregate_root_cls_mock ( ) [EOL] self . backend = snapshot_backend_mock ( return_value = self . snapshot_data_mock ) [EOL] self . importer = importer_mock ( return_value = self . backend ) [EOL] self . deserializer = Mock ( ) [EOL] self . serializer = Mock ( ) [EOL] self . hash_function = Mock ( ) [EOL] [EOL] self . snapshot = partial ( Snapshot , config = self . config , importer = self . importer , serializer = self . serializer , deserializer = self . deserializer , hash_function = self . hash_function ) [EOL] [EOL] def test_save ( self ) : [EOL] snapshot = self . snapshot ( ) [EOL] aggregate_root = self . aggregate_root_cls ( ) [EOL] aggregate_root . id = [number] [EOL] snapshot . save ( aggregate_root ) [EOL] [EOL] self . serializer . call_count == [number] [EOL] self . hash_function . call_count == [number] [EOL] self . backend . save . call_count == [number] [EOL] [EOL] def test_load ( self ) : [EOL] snapshot = self . snapshot ( ) [EOL] aggregate_root = self . aggregate_root_cls ( ) [EOL] test_id = [number] [EOL] snapshot . load ( test_id , aggregate_root ) [EOL] test_hash = snapshot . hash_function ( aggregate_root . get_representation ( ) ) [EOL] [EOL] self . backend ( ) . load . assert_called_once_with ( test_id ) [EOL] self . deserializer . assert_called_once_with ( self . snapshot_data_mock , test_hash ) [EOL] [EOL] def test_delete ( self ) : [EOL] snapshot = self . snapshot ( ) [EOL] aggregate_root = self . aggregate_root_cls ( ) [EOL] aggregate_root . id = [number] [EOL] snapshot . delete ( aggregate_root ) [EOL] [EOL] self . backend ( ) . delete . assert_called_once_with ( aggregate_root . id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] from mongomock import MongoClient [EOL] [EOL] from eventsourcing_helpers . repository . snapshot . backends . mongo import MongoSnapshotBackend [EOL] [EOL] [EOL] class MongoSnapshotBackendTests ( ) : [EOL] config = { [string] : [string] } [EOL] [EOL] @ pytest . fixture ( autouse = True ) def setup_method ( self , aggregate_root_cls_mock , snapshot_backend_mock , importer_mock ) : [EOL] self . backend = MongoSnapshotBackend ( self . config , MongoClient ) [EOL] [EOL] def test_mongo_save_saves_data ( self ) : [EOL] id = [string] [EOL] data = { [string] : [number] } [EOL] [EOL] self . backend . save ( id = id , data = data ) [EOL] [EOL] stored_data = self . backend . client . snapshots . snapshots . find_one ( { [string] : id } ) [EOL] expected_data = { [string] : id } [EOL] expected_data . update ( data ) [EOL] assert stored_data == expected_data [EOL] [EOL] def test_mongo_load_loads_correct_data ( self ) : [EOL] id = [string] [EOL] query = { [string] : id } [EOL] data = { [string] : [number] } [EOL] [EOL] self . backend . client . snapshots . snapshots . find_one_and_replace ( query , data , upsert = True ) [EOL] stored_data = self . backend . load ( id ) [EOL] [EOL] expected_data = { [string] : id } [EOL] expected_data . update ( data ) [EOL] assert stored_data == expected_data [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( { [string] : [string] } , { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) , ( { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) ] ) def test_mongo_init_uses_default_config ( self , config , expected_call ) : [EOL] mongo_client_mock = Mock ( ) [EOL] self . backend = MongoSnapshotBackend ( config , mongo_client_mock ) [EOL] [EOL] mongo_client_mock . assert_called_once_with ( ** expected_call ) [EOL] [EOL] def test_mongo_delete_deletes_latest_snapshot ( self ) : [EOL] id = [string] [EOL] query = { [string] : id } [EOL] data = { [string] : [number] } [EOL] [EOL] db = self . backend . client . snapshots . snapshots [EOL] db . find_one_and_replace ( query , data , upsert = True ) [EOL] assert db . find ( ) . count ( ) == [number] [EOL] [EOL] self . backend . delete ( id ) [EOL] assert db . find ( ) . count ( ) == [number] [EOL] [EOL] def test_mongo_delete_can_delete_empty ( self ) : [EOL] id = [string] [EOL] [EOL] db = self . backend . client . snapshots . snapshots [EOL] assert db . find ( ) . count ( ) == [number] [EOL] self . backend . delete ( id ) [EOL] assert db . find ( ) . count ( ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] [EOL] from eventsourcing_helpers . messagebus . backends . mock import MockBackend [EOL] [EOL] [EOL] class MockBackendTests : [EOL] def setup_method ( self ) : [EOL] self . backend = MockBackend ( config = { } ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ ( [string] , [string] ) ] , { [string] : [string] } ) , ( None , { } ) , ] , ) def test_add_one_consumer_message_should_be_added_to_internal_queue ( self , headers , expected_headers ) : [EOL] self . backend . consumer . add_message ( message_class = [string] , data = { [string] : [string] } , headers = headers ) [EOL] expected_message = dict ( message_class = [string] , data = { [string] : [string] } , headers = expected_headers ) [EOL] self . backend . consumer . assert_one_message_added_with ( ** expected_message ) [EOL] [EOL] def test_consume_messages_should_call_handler ( self ) : [EOL] self . backend . consumer . add_message ( message_class = [string] , data = { [string] : [string] } ) [EOL] self . backend . consumer . add_message ( message_class = [string] , data = { [string] : [string] } ) [EOL] handler = Mock ( ) [EOL] self . backend . consume ( handler = handler ) [EOL] assert handler . call_count == [number] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ { [string] : [string] } , None ] ) def test_produced_message_should_be_added_to_internal_queue ( self , headers ) : [EOL] self . backend . produce ( value = [string] , key = [string] , headers = headers ) [EOL] self . backend . producer . assert_one_message_produced_with ( ** dict ( value = [string] , key = [string] , headers = headers ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0