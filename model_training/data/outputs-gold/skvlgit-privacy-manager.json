from typing import Any , Dict [EOL] import typing [EOL] import setuptools [EOL] [EOL] [EOL] about = { } [EOL] with open ( [string] ) as f : [EOL] exec ( f . read ( ) , about ) [EOL] [EOL] with open ( [string] , [string] ) as fh : [EOL] long_description = fh . read ( ) [EOL] [EOL] setuptools . setup ( name = about [ [string] ] , version = about [ [string] ] , author = about [ [string] ] , author_email = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , url = [string] , project_urls = { [string] : [string] , [string] : [string] } , packages = setuptools . find_packages ( ) , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , python_requires = [string] , install_requires = [ [string] , [string] ] , entry_points = { [string] : [ [string] ] , } , test_suite = [string] , command_options = { [string] : { [string] : ( [string] , [string] ) , [string] : ( [string] , [string] ) , } , } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] import os [EOL] import sys [EOL] from datetime import date [EOL] [EOL] file_loc = os . path . split ( __file__ ) [ [number] ] [EOL] sys . path . insert ( [number] , os . path . abspath ( os . path . join ( os . path . dirname ( file_loc ) , [string] ) ) ) [EOL] [EOL] [comment] [EOL] [EOL] gpm = dict ( ) [EOL] with open ( [string] , [string] ) as f : [EOL] for l in f . readlines ( ) : [EOL] v = l . split ( [string] ) [EOL] gpm [ v [ [number] ] ] = v [ [number] ] [EOL] [EOL] project = gpm [ [string] ] [EOL] author = gpm [ [string] ] [EOL] copyright = [string] . format ( date . today ( ) . year , author ) [EOL] [EOL] version = gpm [ [string] ] [EOL] [comment] [EOL] release = version [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] master_doc = [string] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] autodoc_mock_imports = [ [string] ] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] todo_include_todos = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
__project__ = [string] [EOL] __author__ = [string] [EOL] __version__ = [string] [comment] [EOL] __licence__ = [string]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0
import git_privacy_manager [EOL] import pathlib [EOL] import click [EOL] from getpass import getpass [EOL] from git_privacy_manager import GPM [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] [EOL] @ click . group ( ) @ click . pass_context @ click . option ( [string] , [string] , help = [string] , type = click . Path ( ) , default = os . getcwd ( ) ) @ click . option ( [string] , [string] , help = [string] , type = click . Path ( ) , default = None ) @ click . option ( [string] , [string] , help = [string] , type = str , default = None ) def main ( ctx , directory , output , passphrase ) : [EOL] [comment] [EOL] directory = Path ( directory ) [EOL] if output : [EOL] output = Path ( output ) [EOL] [EOL] gpm = GPM ( directory , passphrase , output ) [EOL] [EOL] ctx . obj = { [string] : gpm , [string] : passphrase , } [EOL] [EOL] [EOL] @ main . command ( ) @ click . pass_context def encrypt ( ctx ) : [EOL] [docstring] [EOL] if not ctx . obj [ [string] ] : [EOL] passphrase = getpass ( prompt = [string] ) [EOL] ctx . obj [ [string] ] . set_passphrase ( passphrase ) [EOL] [EOL] ctx . obj [ [string] ] . encrypt ( ) [EOL] [EOL] [EOL] @ main . command ( ) @ click . pass_context def decrypt ( ctx ) : [EOL] [docstring] [EOL] if not ctx . obj [ [string] ] : [EOL] passphrase = getpass ( prompt = [string] ) [EOL] ctx . obj [ [string] ] . set_passphrase ( passphrase ) [EOL] [EOL] ctx . obj [ [string] ] . decrypt ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Type , Any , Tuple , Dict [EOL] import builtins [EOL] import hashlib [EOL] import cryptography [EOL] import typing [EOL] import pathlib [EOL] import base64 [EOL] from cryptography . hazmat . backends import default_backend [EOL] from cryptography . hazmat . primitives import hashes [EOL] from cryptography . hazmat . primitives . kdf . pbkdf2 import PBKDF2HMAC [EOL] import hashlib [EOL] import json [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , Tuple [EOL] from uuid import uuid4 [EOL] [EOL] from . utils . crypto import Crypto [EOL] [EOL] [comment] [EOL] DataBase = Dict [ str , Dict [ str , Any ] ] [EOL] [EOL] [EOL] class GPM : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] def __init__ ( self , directory , key = None , output = None ) : [EOL] [docstring] [EOL] if key : [EOL] self . _crypto_key = self . _safe_key ( key ) [EOL] [EOL] self . _working_dir = directory . resolve ( ) [EOL] self . _metadata_dir = self . _working_dir / [string] [EOL] self . _metafile = self . _metadata_dir / [string] [EOL] if not output : [EOL] self . _output_dir = self . _metadata_dir / [string] [EOL] else : [EOL] self . _output_dir = output [EOL] self . _metafile_blob = self . _output_dir / [string] [EOL] [EOL] self . _metadata_dir . mkdir ( exist_ok = True , parents = True ) [EOL] self . _output_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] self . _all_files = [ ] [EOL] self . _metadata = { } [EOL] self . _metadata_dirty = False [EOL] [EOL] self . _read_metadata ( ) [EOL] [EOL] def __del__ ( self ) : [EOL] self . _write_metadata ( ) [EOL] [EOL] @ property def key ( self ) : [EOL] return self . _crypto_key [EOL] [EOL] @ key . setter def key ( self , key ) : [EOL] [comment] [EOL] self . _crypto_key = self . _safe_key ( key ) [EOL] [EOL] def decrypt ( self ) : [EOL] [docstring] [EOL] self . _read_metadata_blob ( ) [EOL] [EOL] files_to_decrypt = [ ] [EOL] for key in self . _metadata : [EOL] file = self . _working_dir / key [EOL] if not file . is_file ( ) or checksum ( file ) != self . _metadata [ key ] [ [string] ] : [EOL] blob = self . _blob ( key ) [EOL] passphrase = self . _metadata [ key ] [ [string] ] . encode ( ) [EOL] files_to_decrypt . append ( ( file , blob , passphrase ) ) [EOL] [EOL] for file , blob , passphrase in files_to_decrypt : [EOL] self . _decrypt_file ( blob , file , passphrase ) [EOL] [EOL] self . _remove_remains_in_working_dir ( ) [EOL] self . _remove_ramains_in_output_dir ( ) [EOL] [EOL] def encrypt ( self ) : [EOL] [docstring] [EOL] self . _remove_ramains_in_output_dir ( ) [EOL] [EOL] files_to_encrypt = [ ] [EOL] for file in self . _all_files : [EOL] key = self . _key ( file ) [EOL] file_checksum = checksum ( file ) [EOL] if not self . _contains ( file ) : [EOL] files_to_encrypt . append ( self . _add ( file , file_checksum ) ) [EOL] elif self . _differ ( file , file_checksum ) : [EOL] files_to_encrypt . append ( self . _update_checksum ( file , file_checksum ) ) [EOL] else : [EOL] logging . info ( f' [string] { key } [string] ' % self . _metadata [ key ] [ [string] ] ) [EOL] [EOL] for file , blob , passphrase in files_to_encrypt : [EOL] self . _encrypt_file ( file , blob , passphrase ) [EOL] [EOL] self . _write_metadata ( ) [EOL] self . _write_metadata_blob ( ) [EOL] [EOL] def _read_metadata ( self ) : [EOL] [comment] [EOL] if self . _metafile . is_file ( ) : [EOL] with open ( self . _metafile , [string] ) as f : [EOL] self . _metadata = json . load ( f ) [EOL] logging . debug ( f' [string] { self . _metafile } [string] { self . _metadata }' ) [EOL] [EOL] def _write_metadata ( self ) : [EOL] if self . _metadata_dirty : [EOL] with open ( self . _metafile , [string] ) as f : [EOL] json . dump ( self . _metadata , f ) [EOL] logging . debug ( f' [string] { self . _metafile } [string] { self . _metadata }' ) [EOL] self . _metadata_dirty = False [EOL] [EOL] def _read_metadata_blob ( self ) : [EOL] if not self . _metafile_blob . is_file ( ) : [EOL] raise RuntimeError ( [string] ) [EOL] self . _decrypt_file ( self . _metafile_blob , self . _metafile ) [EOL] with open ( self . _metafile , [string] ) as f : [EOL] self . _metadata = json . load ( f ) [EOL] [EOL] def _write_metadata_blob ( self ) : [EOL] self . _encrypt_file ( self . _metafile , self . _metafile_blob ) [EOL] [EOL] def _remove_ramains_in_output_dir ( self ) : [EOL] self . _all_files = get_all_files ( self . _working_dir , [ self . _metadata_dir ] ) [EOL] self . _read_metadata ( ) [EOL] [comment] [EOL] [comment] [EOL] deleted_files = [ ] [EOL] [EOL] for key in self . _metadata : [EOL] file = self . _working_dir / key [EOL] if file not in self . _all_files : [EOL] logging . debug ( f' [string] { key } [string] { self . _all_files } [string] { self . _metadata }' ) [EOL] deleted_files . append ( key ) [EOL] [EOL] for key in deleted_files : [EOL] logging . info ( f' [string] { key } [string] ' ) [EOL] blob = self . _blob ( key ) [EOL] if blob . is_file ( ) : [EOL] blob . unlink ( ) [EOL] del self . _metadata [ key ] [EOL] self . _metadata_dirty = True [EOL] [EOL] self . _write_metadata ( ) [EOL] [EOL] def _remove_remains_in_working_dir ( self ) : [EOL] [docstring] [EOL] self . _all_files = get_all_files ( self . _working_dir , [ self . _metadata_dir ] ) [EOL] [EOL] for file in self . _all_files : [EOL] key = self . _key ( file ) [EOL] if key not in self . _metadata : [EOL] file . unlink ( ) [EOL] [EOL] self . _all_files = get_all_files ( self . _working_dir , [ self . _metadata_dir ] ) [EOL] [EOL] def _decrypt_file ( self , src , dst , key = None ) : [EOL] if not key : [EOL] key = self . _crypto_key [EOL] dst . parent . mkdir ( exist_ok = True ) [EOL] Crypto ( key ) . decrypt_file ( src , dst ) [EOL] [EOL] def _encrypt_file ( self , src , dst , key = None ) : [EOL] if not key : [EOL] key = self . _crypto_key [EOL] Crypto ( key ) . encrypt_file ( src , dst ) [EOL] [EOL] def _add ( self , file , file_checksum ) : [EOL] [docstring] [EOL] key = self . _key ( file ) [EOL] file_uuid = self . _uuid ( ) [EOL] file_passphrase = Crypto . generate_key ( ) [EOL] self . _metadata [ key ] = { [string] : file_uuid , [string] : file_checksum , [string] : file_passphrase . decode ( ) } [EOL] self . _metadata_dirty = True [EOL] logging . info ( f' [string] { key } [string] { file_uuid } [string] ' ) [EOL] [EOL] return file , self . _blob ( key ) , file_passphrase [EOL] [EOL] def _contains ( self , file ) : [EOL] [docstring] [EOL] return self . _key ( file ) in self . _metadata [EOL] [EOL] def _differ ( self , file , file_checksum ) : [EOL] [docstring] [EOL] return self . _metadata [ self . _key ( file ) ] [ [string] ] != file_checksum [EOL] [EOL] def _key ( self , file ) : [EOL] [docstring] [EOL] if self . _working_dir not in file . parents : [EOL] raise RuntimeError ( f' [string] { file } [string] ' ) [EOL] return str ( file . relative_to ( self . _working_dir ) ) [EOL] [EOL] def _blob ( self , key ) : [EOL] file_uuid = self . _metadata [ key ] [ [string] ] [EOL] return ( self . _output_dir / file_uuid ) . with_suffix ( [string] ) [EOL] [EOL] def _update_checksum ( self , file , file_checksum ) : [EOL] [docstring] [EOL] key = self . _key ( file ) [EOL] file_uuid = self . _metadata [ key ] [ [string] ] [EOL] old_checksum = self . _metadata [ key ] [ [string] ] [EOL] file_passphrase = Crypto . generate_key ( ) [EOL] self . _metadata [ key ] [ [string] ] = file_checksum [EOL] self . _metadata [ key ] [ [string] ] = file_passphrase . decode ( ) [EOL] self . _metadata_dirty = True [EOL] logging . info ( f' [string] { key } [string] { file_uuid } [string] { old_checksum } [string] { file_checksum } [string] ' ) [EOL] return file , self . _blob ( key ) , file_passphrase [EOL] [EOL] def _uuid ( self ) : [EOL] [docstring] [EOL] for _ in range ( [number] ) : [EOL] file_uuid = str ( uuid4 ( ) ) [EOL] if not self . _metadata : [EOL] logging . debug ( f' [string] { file_uuid }' ) [EOL] return file_uuid [EOL] no_collisions = True [EOL] for file_name , file_info in self . _metadata . items ( ) : [EOL] if file_uuid != file_info [ [string] ] : [EOL] continue [EOL] else : [EOL] logging . debug ( f' [string] { file_uuid } [string] { file_name } [string] ' ) [EOL] no_collisions = False [EOL] break [EOL] if no_collisions : [EOL] logging . debug ( f' [string] { file_uuid }' ) [EOL] return file_uuid [EOL] logging . debug ( [string] ) [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] def _safe_key ( self , key ) : [EOL] kdf = PBKDF2HMAC ( algorithm = hashes . SHA256 ( ) , length = [number] , salt = key . encode ( ) , iterations = [number] , backend = default_backend ( ) ) [EOL] return base64 . urlsafe_b64encode ( kdf . derive ( key . encode ( ) ) ) [EOL] [EOL] [EOL] [comment] [EOL] def checksum ( file ) : [EOL] [docstring] [EOL] hash_md5 = hashlib . md5 ( ) [EOL] with open ( file , [string] ) as f : [EOL] for chunk in iter ( lambda : f . read ( [number] ) , [string] ) : [EOL] hash_md5 . update ( chunk ) [EOL] return hash_md5 . hexdigest ( ) [EOL] [EOL] [EOL] def get_all_files ( working_dir , exclude = [ ] ) : [EOL] [docstring] [EOL] def excluded ( entry ) : [EOL] for path in exclude : [EOL] return path == entry or path in entry . parents [EOL] [EOL] fs = [ ] [EOL] for entry in working_dir . rglob ( [string] ) : [EOL] if entry . is_file ( ) and not excluded ( entry ) : [EOL] fs . append ( entry ) [EOL] return fs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[pathlib.Path,pathlib.Path,builtins.bytes]$ 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bytes$ 0 0 0 $builtins.bool$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[pathlib.Path,pathlib.Path,builtins.bytes]$ 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 0 0 $cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . gpm import GPM [EOL] from . __about__ import __project__ , __author__ , __version__ , __licence__ [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Iterator [EOL] import builtins [EOL] import cryptography [EOL] import pathlib [EOL] import typing [EOL] import base64 [EOL] from cryptography . exceptions import InvalidSignature [EOL] from cryptography . hazmat . backends import default_backend [EOL] from cryptography . hazmat . primitives import hashes [EOL] from cryptography . hazmat . primitives . ciphers import Cipher , algorithms , modes [EOL] from cryptography . hazmat . primitives . hmac import HMAC [EOL] import os [EOL] from pathlib import Path [EOL] import struct [EOL] import time [EOL] from typing import Iterator [EOL] [EOL] [EOL] class InvalidToken ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] _MAX_CLOCK_SKEW = [number] [EOL] [EOL] [EOL] class Crypto ( object ) : [EOL] [docstring] [EOL] [EOL] magic = [string] [EOL] [EOL] def __init__ ( self , key ) : [EOL] backend = default_backend ( ) [EOL] [EOL] key = base64 . urlsafe_b64decode ( key ) [EOL] if len ( key ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . _signing_key = key [ : [number] ] [EOL] self . _encryption_key = key [ [number] : ] [EOL] self . _backend = backend [EOL] [EOL] @ classmethod def generate_key ( cls ) : [EOL] return base64 . urlsafe_b64encode ( os . urandom ( [number] ) ) [EOL] [EOL] def encrypt_file ( self , src , dst ) : [EOL] with open ( src , [string] ) as s , open ( dst , [string] ) as d : [EOL] ciphertext = self . encrypt_stream ( iter ( lambda : s . read ( [number] ) , [string] ) ) [EOL] for data in ciphertext : [EOL] if data : [EOL] d . write ( data ) [EOL] [EOL] def encrypt_stream ( self , src ) : [EOL] nonce = os . urandom ( [number] ) [EOL] encryptor = Cipher ( algorithms . AES ( self . _encryption_key ) , modes . CTR ( nonce ) , self . _backend ) . encryptor ( ) [EOL] hmac = HMAC ( self . _signing_key , hashes . SHA256 ( ) , backend = self . _backend ) [EOL] [comment] [EOL] current_time = int ( time . time ( ) ) [EOL] basic_parts = ( self . magic + struct . pack ( [string] , current_time ) + nonce ) [EOL] hmac . update ( basic_parts ) [comment] [EOL] yield basic_parts [EOL] [comment] [EOL] for data in src : [EOL] ciphertext = encryptor . update ( data ) [EOL] hmac . update ( ciphertext ) [EOL] yield ciphertext [EOL] [comment] [EOL] fin = encryptor . finalize ( ) [EOL] hmac . update ( fin ) [EOL] yield fin [EOL] [comment] [EOL] yield hmac . finalize ( ) [EOL] [EOL] def decrypt_file ( self , src , dst , ttl = None ) : [EOL] with open ( src , [string] ) as s , open ( dst , [string] ) as d : [EOL] plaintext = self . decrypt_stream ( iter ( lambda : s . read ( [number] ) , [string] ) , ttl ) [EOL] for data in plaintext : [EOL] if data : [EOL] d . write ( data ) [EOL] [EOL] def decrypt_stream ( self , src , ttl = None ) : [EOL] [comment] [EOL] [comment] [EOL] buffer = [string] [EOL] [comment] [EOL] for data in src : [EOL] buffer += data [EOL] if len ( buffer ) < [number] : [EOL] yield [string] [EOL] self . _check_header ( buffer , ttl ) [EOL] [comment] [EOL] hmac = HMAC ( self . _signing_key , hashes . SHA256 ( ) , backend = self . _backend ) [EOL] [comment] [EOL] decryptor = Cipher ( algorithms . AES ( self . _encryption_key ) , modes . CTR ( buffer [ [number] : [number] ] ) , self . _backend ) . decryptor ( ) [EOL] [comment] [EOL] hmac . update ( buffer [ [number] : [number] ] ) [comment] [EOL] buffer = buffer [ [number] : ] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for data in src : [EOL] if len ( data ) < [number] : [EOL] buffer += data [EOL] yield [string] [EOL] hmac . update ( buffer ) [EOL] yield decryptor . update ( buffer ) [EOL] buffer = data [EOL] [comment] [EOL] signature = buffer [ - [number] : ] [EOL] [comment] [EOL] buffer = buffer [ : - [number] ] [EOL] hmac . update ( buffer ) [EOL] try : [EOL] plaintext = decryptor . update ( buffer ) + decryptor . finalize ( ) [EOL] yield plaintext [EOL] except ValueError : [EOL] raise InvalidToken [EOL] [comment] [EOL] try : [EOL] hmac . verify ( signature ) [EOL] except InvalidSignature : [EOL] raise InvalidToken [EOL] [EOL] @ staticmethod def _get_timestamp ( data ) : [EOL] try : [EOL] timestamp , = struct . unpack ( [string] , data [ [number] : [number] ] ) [EOL] except struct . error : [EOL] raise InvalidToken [EOL] return timestamp [EOL] [EOL] @ classmethod def _check_header ( cls , buffer , ttl = None ) : [EOL] if len ( buffer ) < [number] : [EOL] raise InvalidToken [EOL] [comment] [EOL] if buffer [ [number] : [number] ] != cls . magic : [EOL] raise InvalidToken [EOL] [comment] [EOL] if ttl is not None : [EOL] timestamp = cls . _get_timestamp ( buffer [ [number] : [number] ] ) [EOL] current_time = int ( time . time ( ) ) [EOL] if timestamp + ttl < current_time : [EOL] raise InvalidToken [EOL] [EOL] if current_time + _MAX_CLOCK_SKEW < timestamp : [EOL] raise InvalidToken [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $cryptography.hazmat.primitives.ciphers.CipherContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $cryptography.hazmat.primitives.ciphers.CipherContext$ 0 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.bytes$ 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 $builtins.bytes$ 0 $cryptography.hazmat.primitives.ciphers.CipherContext$ 0 0 0 0 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $cryptography.hazmat.primitives.ciphers.CipherContext$ 0 0 0 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 0 $typing.Iterator[builtins.bytes]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.int$ 0 0 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cryptography.hazmat.primitives.ciphers.CipherContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $cryptography.hazmat.primitives.ciphers.CipherContext$ 0 0 0 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 $builtins.bytes$ 0 0 0 $cryptography.hazmat.primitives.ciphers.CipherContext$ 0 0 0 $builtins.bytes$ 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $cryptography.hazmat.primitives.ciphers.CipherContext$ 0 0 0 $builtins.bytes$ 0 0 $cryptography.hazmat.primitives.ciphers.CipherContext$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $cryptography.hazmat.primitives.hmac.HMAC$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0
	0
import git_privacy_manager [EOL] import pathlib [EOL] [docstring] [EOL] import git_privacy_manager as gpm [EOL] import os [EOL] from pathlib import Path [EOL] import tempfile [EOL] import unittest [EOL] from unittest . mock import patch [EOL] import uuid [comment] [EOL] from . utils import add_file , files_in_directory [EOL] [EOL] [EOL] class TestCustomOutputDir ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . working_directory = Path ( tempfile . mkdtemp ( ) ) [EOL] self . output_direcotry = Path ( tempfile . mkdtemp ( ) ) [EOL] self . pswd = [string] [EOL] self . gpm = gpm . GPM ( self . working_directory , self . pswd , self . output_direcotry ) [EOL] [EOL] def test_custom_output_dir ( self ) : [EOL] self . assertEqual ( [number] , files_in_directory ( self . output_direcotry ) ) [EOL] add_file ( self . working_directory ) [EOL] self . gpm . encrypt ( ) [EOL] [comment] [EOL] self . assertEqual ( [number] , files_in_directory ( self . output_direcotry ) ) [EOL] [EOL] [EOL] class TestSingleFileCRUD ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . working_directory = tempfile . mkdtemp ( ) [EOL] self . pswd = [string] [EOL] self . gpm = gpm . GPM ( Path ( self . working_directory ) , self . pswd ) [EOL] [EOL] self . file_path , self . file_data = add_file ( self . working_directory ) [EOL] self . gpm . encrypt ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] def test_add_single_file ( self ) : [EOL] os . remove ( self . file_path ) [EOL] self . gpm . decrypt ( ) [EOL] [EOL] self . assertTrue ( os . path . isfile ( self . file_path ) ) [EOL] with open ( self . file_path , [string] ) as f : [EOL] self . assertEqual ( self . file_data , f . read ( ) ) [EOL] [EOL] def test_update_single_file ( self ) : [EOL] file_data_updated = str ( uuid . uuid4 ( ) ) [EOL] with open ( self . file_path , [string] ) as f : [EOL] f . write ( file_data_updated ) [EOL] self . gpm . encrypt ( ) [EOL] os . remove ( self . file_path ) [EOL] self . gpm . decrypt ( ) [EOL] [EOL] self . assertTrue ( os . path . isfile ( self . file_path ) ) [EOL] with open ( self . file_path , [string] ) as f : [EOL] self . assertEqual ( file_data_updated , f . read ( ) ) [EOL] [EOL] def test_delete_single_file ( self ) : [EOL] os . remove ( self . file_path ) [EOL] self . gpm . encrypt ( ) [EOL] self . gpm . decrypt ( ) [EOL] [EOL] self . assertFalse ( os . path . exists ( self . file_path ) ) [EOL] [EOL] def test_decrypt_malformed ( self ) : [EOL] self . gpm . _metafile_blob . unlink ( ) [EOL] with self . assertRaises ( RuntimeError ) : [EOL] self . gpm . decrypt ( ) [EOL] [EOL] [EOL] class TestMultipleFilesCRUD ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . working_directory = tempfile . mkdtemp ( ) [EOL] self . pswd = [string] [EOL] self . gpm = gpm . GPM ( Path ( self . working_directory ) , self . pswd ) [EOL] [EOL] self . file_1_path , self . file_1_data = add_file ( self . working_directory ) [EOL] self . file_2_path , self . file_2_data = add_file ( self . working_directory ) [EOL] self . gpm . encrypt ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] def test_add_multiple_files ( self ) : [EOL] os . remove ( self . file_1_path ) [EOL] os . remove ( self . file_2_path ) [EOL] self . gpm . decrypt ( ) [EOL] [EOL] self . assertTrue ( os . path . isfile ( self . file_1_path ) ) [EOL] with open ( self . file_1_path , [string] ) as f : [EOL] self . assertEqual ( self . file_1_data , f . read ( ) ) [EOL] [EOL] self . assertTrue ( os . path . isfile ( self . file_2_path ) ) [EOL] with open ( self . file_2_path , [string] ) as f : [EOL] self . assertEqual ( self . file_2_data , f . read ( ) ) [EOL] [EOL] def test_update_one_of_many_files ( self ) : [EOL] file_data_updated = str ( uuid . uuid4 ( ) ) [EOL] with open ( self . file_1_path , [string] ) as f : [EOL] f . write ( file_data_updated ) [EOL] self . gpm . encrypt ( ) [EOL] os . remove ( self . file_1_path ) [EOL] os . remove ( self . file_2_path ) [EOL] self . gpm . decrypt ( ) [EOL] [EOL] self . assertTrue ( os . path . isfile ( self . file_1_path ) ) [EOL] with open ( self . file_1_path , [string] ) as f : [EOL] self . assertEqual ( file_data_updated , f . read ( ) . decode ( ) ) [EOL] [EOL] self . assertTrue ( os . path . isfile ( self . file_2_path ) ) [EOL] with open ( self . file_2_path , [string] ) as f : [EOL] self . assertEqual ( self . file_2_data , f . read ( ) ) [EOL] [EOL] def test_update_many_files ( self ) : [EOL] file_1_data_updated = str ( uuid . uuid4 ( ) ) [EOL] with open ( self . file_1_path , [string] ) as f : [EOL] f . write ( file_1_data_updated ) [EOL] file_2_data_updated = str ( uuid . uuid4 ( ) ) [EOL] with open ( self . file_2_path , [string] ) as f : [EOL] f . write ( file_2_data_updated ) [EOL] self . gpm . encrypt ( ) [EOL] os . remove ( self . file_1_path ) [EOL] os . remove ( self . file_2_path ) [EOL] self . gpm . decrypt ( ) [EOL] [EOL] self . assertTrue ( os . path . isfile ( self . file_1_path ) ) [EOL] with open ( self . file_1_path , [string] ) as f : [EOL] self . assertEqual ( file_1_data_updated , f . read ( ) ) [EOL] [EOL] self . assertTrue ( os . path . isfile ( self . file_2_path ) ) [EOL] with open ( self . file_2_path , [string] ) as f : [EOL] self . assertEqual ( file_2_data_updated , f . read ( ) ) [EOL] [EOL] def test_delete_one_of_many_files ( self ) : [EOL] os . remove ( self . file_1_path ) [EOL] self . gpm . encrypt ( ) [EOL] self . gpm . decrypt ( ) [EOL] [EOL] self . assertFalse ( os . path . exists ( self . file_1_path ) ) [EOL] [EOL] self . assertTrue ( os . path . isfile ( self . file_2_path ) ) [EOL] with open ( self . file_2_path , [string] ) as f : [EOL] self . assertEqual ( self . file_2_data , f . read ( ) ) [EOL] [EOL] @ patch ( [string] ) def test_uuid_collision_raises ( self , mock_uuid ) : [EOL] mock_uuid . return_value = [number] [EOL] add_file ( self . working_directory ) [EOL] add_file ( self . working_directory ) [EOL] with self . assertRaises ( RuntimeError ) : [EOL] self . gpm . encrypt ( ) [EOL] [EOL] @ patch ( [string] ) def test_uuid_collision_success ( self , mock_uuid ) : [EOL] mock_uuid . side_effect = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] add_file ( self . working_directory ) [EOL] add_file ( self . working_directory ) [EOL] self . gpm . encrypt ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $git_privacy_manager.gpm.GPM$ 0 $git_privacy_manager.gpm.GPM$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $git_privacy_manager.gpm.GPM$ 0 $git_privacy_manager.gpm.GPM$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $git_privacy_manager.gpm.GPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $git_privacy_manager.gpm.GPM$ 0 $git_privacy_manager.gpm.GPM$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $git_privacy_manager.gpm.GPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , List [EOL] import typing [EOL] import pathlib [EOL] from pathlib import Path [EOL] import shutil [EOL] import tempfile [EOL] from typing import List [EOL] [EOL] [EOL] def add_file ( working_directory ) : [EOL] file_data = [string] * [number] + [string] [EOL] file_handle , file_path = tempfile . mkstemp ( dir = working_directory , text = True ) [EOL] with open ( file_handle , [string] ) as f : [EOL] f . write ( file_data ) [EOL] [EOL] return Path ( file_path ) , file_data [EOL] [EOL] [EOL] def copy_files ( src_dir , dst_dir ) : [EOL] for f in get_all_files ( src_dir ) : [EOL] name = f . name [EOL] dst = dst_dir / name [EOL] shutil . copyfile ( f , dst ) [EOL] [EOL] [EOL] def files_in_directory ( path ) : [EOL] all_files = path . rglob ( [string] ) [EOL] return len ( [ f for f in all_files if f . is_file ( ) ] ) [EOL] [EOL] [EOL] def get_all_files ( path ) : [EOL] all_files = path . rglob ( [string] ) [EOL] return [ f for f in all_files if f . is_file ( ) and path == f . parent ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import git_privacy_manager [EOL] import pathlib [EOL] import typing [EOL] [docstring] [EOL] [EOL] import git_privacy_manager as gpm [EOL] import os [EOL] from pathlib import Path [EOL] import tempfile [EOL] import unittest [EOL] from . utils import add_file , copy_files , files_in_directory , get_all_files [EOL] [EOL] [EOL] class TestRepoSync ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . gpm1 = gpm . GPM ( Path ( tempfile . mkdtemp ( ) ) , [string] ) [EOL] self . gpm2 = gpm . GPM ( Path ( tempfile . mkdtemp ( ) ) , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] add_file ( self . gpm1 . _working_dir ) [EOL] self . gpm1 . encrypt ( ) [EOL] self . _sync_repo2 ( ) [EOL] [EOL] def test_repo_clone ( self ) : [EOL] self . _if_repos_equal ( ) [EOL] [EOL] def test_repo_sync_new_file ( self ) : [EOL] add_file ( self . gpm1 . _working_dir ) [EOL] self . gpm1 . encrypt ( ) [comment] [EOL] self . _sync_repo2 ( ) [EOL] self . _if_repos_equal ( ) [EOL] [EOL] def test_repo_sync_delete_file ( self ) : [EOL] f = get_all_files ( self . gpm1 . _working_dir ) [ [number] ] [EOL] f . unlink ( ) [EOL] self . gpm1 . encrypt ( ) [comment] [EOL] self . _sync_repo2 ( ) [EOL] self . _if_repos_equal ( ) [EOL] [EOL] def _sync_repo2 ( self ) : [EOL] [comment] [EOL] for f in get_all_files ( self . gpm2 . _output_dir ) : [EOL] f . unlink ( ) [EOL] [comment] [EOL] [comment] [EOL] copy_files ( self . gpm1 . _output_dir , self . gpm2 . _output_dir ) [EOL] [comment] [EOL] self . gpm2 . decrypt ( ) [EOL] [EOL] def _if_repos_equal ( self ) : [EOL] repo1_files = get_all_files ( self . gpm1 . _working_dir ) [EOL] repo2_files = get_all_files ( self . gpm2 . _working_dir ) [EOL] [EOL] self . assertEqual ( len ( repo1_files ) , len ( repo2_files ) ) [EOL] [EOL] for f in repo1_files : [EOL] f2 = self . gpm2 . _working_dir / f . name [EOL] [EOL] self . assertTrue ( f2 in repo2_files ) [EOL] [EOL] [comment] [EOL] f_data = [string] [EOL] with open ( f , [string] ) as fh : [EOL] f_data = fh . read ( ) [EOL] [EOL] f2_data = [string] [EOL] with open ( f2 , [string] ) as fh : [EOL] f2_data = fh . read ( ) [EOL] [EOL] self . assertEqual ( f_data , f2_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $git_privacy_manager.gpm.GPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $git_privacy_manager.gpm.GPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $git_privacy_manager.gpm.GPM$ 0 0 0 0 0 0 $git_privacy_manager.gpm.GPM$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
import subprocess [EOL] [docstring] [EOL] import unittest [EOL] import subprocess [EOL] [EOL] [EOL] class TestTyping ( unittest . TestCase ) : [EOL] [EOL] def test_typing ( self ) : [EOL] rc = subprocess . run ( [ [string] , [string] ] , capture_output = True , text = True ) [EOL] self . assertEqual ( rc . returncode , [number] , f' [string] { rc . stdout } [string] { rc . stderr } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.str]$ 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.str]$ 0 0 0 0 0 $subprocess.CompletedProcess[builtins.str]$ 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0