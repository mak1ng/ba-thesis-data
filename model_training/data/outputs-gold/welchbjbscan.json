[docstring] [EOL] [EOL] import sys [EOL] [EOL] from sublemon import crossplat_loop_run [EOL] [EOL] from bscan . cli import ( main as cli_main ) [EOL] from bscan . cli_wordlists import ( main as cli_wordlists_main ) [EOL] from bscan . cli_shells import ( main as cli_shells_main ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] sys . exit ( crossplat_loop_run ( cli_main ( ) ) ) [EOL] [EOL] [EOL] def wordlists_main ( ) : [EOL] [docstring] [EOL] sys . exit ( cli_wordlists_main ( ) ) [EOL] [EOL] [EOL] def shells_main ( ) : [EOL] [docstring] [EOL] sys . exit ( cli_shells_main ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Set , List [EOL] import typing [EOL] import builtins [EOL] import argparse [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import sys [EOL] [EOL] from argparse import ( ArgumentParser , Namespace , RawTextHelpFormatter ) [EOL] from colorama import ( init as init_colorama ) [EOL] from sublemon import ( Sublemon ) [EOL] from typing import ( List , Optional , Set ) [EOL] [EOL] from bscan . config import ( init_config , good_py_version , py_version_str ) [EOL] from bscan . dir_gen import ( create_dir_skeleton ) [EOL] from bscan . errors import ( BscanConfigError , BscanError , BscanForceSkipTarget , BscanForceSilentExit , BscanInternalError , BscanSubprocessError ) [EOL] from bscan . io_console import ( print_color_info , print_e_d1 , print_i_d1 , print_w_d1 ) [EOL] from bscan . networks import ( is_valid_hostname , is_valid_ip_host_addr , is_valid_ip_net_addr ) [EOL] from bscan . scans import ( scan_target ) [EOL] from bscan . runtime import ( get_db_value , status_update_poller , write_db_value ) [EOL] from bscan . version import ( __version__ ) [EOL] [EOL] [EOL] def get_parsed_args ( args = None ) : [EOL] [docstring] [EOL] parser = ArgumentParser ( prog = [string] , usage = [string] , description = ( [string] [string] [string] [string] [string] [string] ) , formatter_class = RawTextHelpFormatter ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] [string] [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , nargs = [string] , metavar = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , version = str ( __version__ ) , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , type = str , metavar = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] [EOL] if args is None : [EOL] args = sys . argv [ [number] : ] [EOL] [EOL] return parser . parse_args ( args ) [EOL] [EOL] [EOL] async def main ( args = None ) : [EOL] [docstring] [EOL] try : [EOL] init_colorama ( ) [EOL] [EOL] if not good_py_version ( ) : [EOL] print_w_d1 ( [string] , py_version_str ( ) , [string] ) [EOL] [EOL] opts = get_parsed_args ( args ) [EOL] print_i_d1 ( [string] ) [EOL] mc = opts . max_concurrency [EOL] try : [EOL] mc = ( [number] if mc is None else int ( mc ) ) [EOL] if mc < [number] : [EOL] raise ValueError [EOL] except ValueError : [EOL] raise BscanConfigError ( [string] [string] + str ( mc ) ) [EOL] [EOL] async with Sublemon ( max_concurrency = mc ) as subl : [EOL] await write_db_value ( [string] , subl ) [EOL] await init_config ( opts ) [EOL] [EOL] print_color_info ( ) [EOL] [EOL] if not opts . targets : [EOL] print_e_d1 ( [string] [string] ) [EOL] return [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] targets = [ ] [EOL] _target_set = set ( ) [EOL] for candidate in opts . targets : [EOL] if candidate in _target_set : [EOL] print_w_d1 ( [string] , candidate , [string] [string] ) [EOL] continue [EOL] elif is_valid_ip_host_addr ( candidate ) : [EOL] pass [EOL] elif is_valid_hostname ( candidate ) : [EOL] pass [EOL] elif is_valid_ip_net_addr ( candidate ) : [EOL] print_w_d1 ( [string] [string] , candidate ) [EOL] continue [EOL] else : [EOL] print_e_d1 ( [string] , candidate , [string] ) [EOL] continue [EOL] [EOL] try : [EOL] create_dir_skeleton ( candidate ) [EOL] except BscanForceSkipTarget as e : [EOL] print_e_d1 ( e . message ) [EOL] print_e_d1 ( candidate , [string] ) [EOL] continue [EOL] [EOL] targets . append ( candidate ) [EOL] _target_set . add ( candidate ) [EOL] [EOL] if not targets : [EOL] print_e_d1 ( [string] ) [EOL] return [number] [EOL] [EOL] print_i_d1 ( [string] , len ( targets ) , [string] ) [EOL] tasks = [ scan_target ( target ) for target in targets ] [EOL] if get_db_value ( [string] ) > [number] : [EOL] tasks . append ( status_update_poller ( ) ) [EOL] await asyncio . gather ( * tasks ) [EOL] [EOL] print_i_d1 ( [string] ) [EOL] return [number] [EOL] except BscanConfigError as e : [EOL] print_e_d1 ( [string] , e . message ) [EOL] return [number] [EOL] except BscanForceSilentExit as e : [EOL] return [number] [EOL] except BscanInternalError as e : [EOL] print_e_d1 ( [string] , e . message ) [EOL] return [number] [EOL] except BscanSubprocessError as e : [EOL] print_e_d1 ( [string] , e . message ) [EOL] return [number] [EOL] except BscanError as e : [EOL] print_e_d1 ( [string] ) [EOL] return [number] [EOL] except Exception as e : [EOL] print_e_d1 ( [string] , file = sys . stderr ) [EOL] raise e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] __version_info__ = ( [number] , [number] , [number] ) [EOL] __version__ = [string] . join ( str ( i ) for i in __version_info__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0
from typing import Dict , Any , Type , AsyncGenerator [EOL] import typing [EOL] import asyncio [EOL] import builtins [EOL] import bscan [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] [EOL] from asyncio import ( Lock ) [EOL] from collections import ( namedtuple ) [EOL] from typing import ( Any , AsyncGenerator , Dict ) [EOL] [EOL] from bscan . errors import ( BscanInternalError ) [EOL] from bscan . io_console import ( print_i_d2 , print_i_d3 , print_w_d3 , shortened_cmd ) [EOL] [EOL] db = dict ( ) [EOL] lock = Lock ( ) [EOL] [EOL] _STATUS_POLL_PERIOD = [number] [EOL] [EOL] RuntimeStats = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] [docstring] [EOL] [EOL] [EOL] async def write_db_value ( key , val ) : [EOL] [docstring] [EOL] async with lock : [EOL] db [ key ] = val [EOL] [EOL] [EOL] def get_db_value ( key ) : [EOL] [docstring] [EOL] try : [EOL] return db [ key ] [EOL] except KeyError : [EOL] raise BscanInternalError ( [string] ) [EOL] [EOL] [EOL] async def add_active_target ( target ) : [EOL] [docstring] [EOL] target_set = db [ [string] ] [EOL] if target in target_set : [EOL] raise BscanInternalError ( [string] + target + [string] [string] ) [EOL] [EOL] async with lock : [EOL] target_set . add ( target ) [EOL] [EOL] [EOL] async def remove_active_target ( target ) : [EOL] [docstring] [EOL] target_set = db [ [string] ] [EOL] if target not in target_set : [EOL] raise BscanInternalError ( [string] + target + [string] + [string] ) [EOL] [EOL] async with lock : [EOL] target_set . remove ( target ) [EOL] [EOL] [EOL] async def proc_spawn ( target , cmd ) : [EOL] [docstring] [EOL] cmd_len = get_db_value ( [string] ) [EOL] subl = get_db_value ( [string] ) [EOL] print_i_d3 ( target , [string] , shortened_cmd ( cmd , cmd_len ) ) [EOL] sp , = subl . spawn ( cmd ) [EOL] async for line in sp . stdout : [EOL] yield line . decode ( [string] ) . strip ( ) [EOL] [EOL] exit_code = await sp . wait_done ( ) [EOL] if exit_code != [number] : [EOL] print_w_d3 ( target , [string] , shortened_cmd ( cmd , cmd_len ) , [string] , exit_code ) [EOL] [EOL] [EOL] async def status_update_poller ( ) : [EOL] [docstring] [EOL] interval = get_db_value ( [string] ) [EOL] verbose = get_db_value ( [string] ) [EOL] cmd_len = get_db_value ( [string] ) [EOL] if interval <= [number] : [EOL] raise BscanInternalError ( [string] + str ( interval ) ) [EOL] [EOL] time_elapsed = float ( [number] ) [EOL] while True : [EOL] await asyncio . sleep ( _STATUS_POLL_PERIOD ) [EOL] [EOL] stats = get_runtime_stats ( ) [EOL] if stats . num_active_targets < [number] : [EOL] break [EOL] [EOL] time_elapsed += _STATUS_POLL_PERIOD [EOL] if time_elapsed >= interval : [EOL] time_elapsed = float ( [number] ) [EOL] msg = ( [string] + str ( stats . num_total_subprocs ) + [string] + str ( stats . num_active_targets ) + [string] ) [EOL] if verbose : [EOL] subl = db [ [string] ] [EOL] print_i_d2 ( msg , [string] ) [EOL] for sp in subl . running_subprocesses : [EOL] print_i_d3 ( shortened_cmd ( sp . cmd , cmd_len ) ) [EOL] else : [EOL] print_i_d2 ( msg ) [EOL] [EOL] [EOL] def get_runtime_stats ( ) : [EOL] [docstring] [EOL] return RuntimeStats ( len ( db [ [string] ] ) , len ( db [ [string] ] . running_subprocesses ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $asyncio.locks.Lock$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $typing.Type[bscan.runtime.RuntimeStats]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $asyncio.locks.Lock$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.locks.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.locks.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncGenerator[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RuntimeStats$ 0 0 0 0 0 0 0 $typing.Type[bscan.runtime.RuntimeStats]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0
import functools [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from colorama import ( Fore , Style ) [EOL] from functools import ( partial ) [EOL] [EOL] [EOL] def red ( s ) : [EOL] [docstring] [EOL] return Fore . RED + s + Style . RESET_ALL [EOL] [EOL] [EOL] def purple ( s ) : [EOL] [docstring] [EOL] return Fore . MAGENTA + s + Style . RESET_ALL [EOL] [EOL] [EOL] def blue ( s ) : [EOL] [docstring] [EOL] return Fore . CYAN + s + Style . RESET_ALL [EOL] [EOL] [EOL] def yellow ( s ) : [EOL] [docstring] [EOL] return Fore . YELLOW + s + Style . RESET_ALL [EOL] [EOL] [EOL] def shortened_cmd ( cmd , length ) : [EOL] [docstring] [EOL] if len ( cmd ) + [number] <= length : [EOL] return [string] + cmd + [string] [EOL] [EOL] return [string] + cmd [ : ( length - [number] ) ] + [string] [EOL] [EOL] [EOL] print_i_d1 = partial ( print , blue ( [string] ) , sep = [string] ) [EOL] print_w_d1 = partial ( print , yellow ( [string] ) , sep = [string] ) [EOL] print_e_d1 = partial ( print , red ( [string] ) , sep = [string] ) [EOL] print_i_d2 = partial ( print , blue ( [string] ) , sep = [string] ) [EOL] print_w_d2 = partial ( print , yellow ( [string] ) , sep = [string] ) [EOL] print_e_d2 = partial ( print , red ( [string] ) , sep = [string] ) [EOL] print_i_d3 = partial ( print , blue ( [string] ) , sep = [string] ) [EOL] print_w_d3 = partial ( print , yellow ( [string] ) , sep = [string] ) [EOL] print_e_d3 = partial ( print , red ( [string] ) , sep = [string] ) [EOL] [EOL] [EOL] def print_color_info ( ) : [EOL] print_i_d1 ( [string] , blue ( [string] ) , [string] , yellow ( [string] ) , [string] , red ( [string] ) , [string] , purple ( [string] ) , sep = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , List [EOL] import typing [EOL] import builtins [EOL] import bscan [EOL] [docstring] [EOL] [EOL] from collections import ( namedtuple ) [EOL] from typing import ( List ) [EOL] [EOL] from bscan . io_files import ( file_exists ) [EOL] from bscan . runtime import ( get_db_value ) [EOL] from bscan . dir_structure import ( get_scan_file ) [EOL] [EOL] ParsedService = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] [docstring] [EOL] [EOL] _DetectedService = namedtuple ( [string] , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class DetectedService ( _DetectedService ) : [EOL] [docstring] [EOL] [EOL] def build_scans ( self ) : [EOL] [docstring] [EOL] built_scans = [ ] [EOL] for scan , cmd in self . scans . items ( ) : [EOL] built_scans . extend ( self . _fill_template ( scan , cmd ) ) [EOL] return built_scans [EOL] [EOL] def build_recommendations ( self ) : [EOL] [docstring] [EOL] built_recs = [ ] [EOL] for i , cmd in enumerate ( self . recommendations ) : [EOL] built_recs . extend ( self . _fill_template ( [string] + str ( i ) , cmd ) ) [EOL] return built_recs [EOL] [EOL] def port_str ( self ) : [EOL] [docstring] [EOL] return [string] . join ( [ str ( p ) for p in self . ports ] ) [EOL] [EOL] def _fill_template ( self , scan_name , cmd ) : [EOL] [docstring] [EOL] cmd = ( cmd . replace ( [string] , self . target ) . replace ( [string] , get_db_value ( [string] ) ) . replace ( [string] , get_db_value ( [string] ) ) . replace ( [string] , get_db_value ( [string] ) ) ) [EOL] [EOL] if [string] in cmd : [EOL] fout = get_scan_file ( self . target , self . name + [string] + [string] . join ( [ str ( p ) for p in self . ports ] ) + [string] + scan_name ) [EOL] return [ cmd . replace ( [string] , self . port_str ( ) ) . replace ( [string] , fout ) ] [EOL] elif [string] in cmd : [EOL] cmds = [ ] [EOL] for port in self . ports : [EOL] fout = get_scan_file ( self . target , self . name + [string] + str ( port ) + [string] + scan_name ) [EOL] cmds . append ( cmd . replace ( [string] , str ( port ) ) . replace ( [string] , fout ) ) [EOL] return cmds [EOL] else : [EOL] fout = get_scan_file ( self . target , self . name + [string] + scan_name ) [EOL] [comment] [EOL] [comment] [EOL] i = [number] [EOL] while file_exists ( fout ) : [EOL] fout = get_scan_file ( self . target , self . name + [string] + str ( i ) + [string] + scan_name ) [EOL] i += [number] [EOL] cmd = cmd . replace ( [string] , fout ) [EOL] return [ cmd ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[bscan.models.ParsedService]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[bscan.models._DetectedService]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[bscan.models._DetectedService]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0
from typing import Pattern [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import ipaddress [EOL] import re [EOL] [EOL] [EOL] def is_valid_ip_net_addr ( ip ) : [EOL] [docstring] [EOL] try : [EOL] ipaddress . ip_network ( ip ) [EOL] except ValueError : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def is_valid_ip_host_addr ( ip ) : [EOL] [docstring] [EOL] try : [EOL] ipaddress . ip_address ( ip ) [EOL] except ValueError : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def is_valid_hostname ( ho ) : [EOL] [docstring] [EOL] if len ( ho ) > [number] : [EOL] return False [EOL] ho = ho . rstrip ( [string] ) [EOL] allowed = re . compile ( [string] , re . IGNORECASE ) [EOL] return all ( allowed . match ( x ) for x in ho . split ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0