from typing import List [EOL] import typing [EOL] from sys import version_info [EOL] from setuptools import setup [EOL] [EOL] if version_info . major == [number] and version_info . minor < [number] or version_info . major < [number] : [EOL] print ( [string] ) [EOL] exit ( [number] ) [EOL] [EOL] from freqtrade import __version__ [EOL] [EOL] [comment] [EOL] api = [ [string] ] [EOL] plot = [ [string] ] [EOL] [EOL] develop = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] jupyter = [ [string] , [string] , [string] , ] [EOL] [EOL] all_extra = api + plot + develop + jupyter [EOL] [EOL] setup ( name = [string] , version = __version__ , description = [string] , url = [string] , author = [string] , author_email = [string] , license = [string] , packages = [ [string] ] , setup_requires = [ [string] , [string] ] , tests_require = [ [string] , [string] , [string] ] , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , extras_require = { [string] : api , [string] : all_extra , [string] : plot , [string] : all_extra , [string] : jupyter , } , include_package_data = True , zip_safe = False , entry_points = { [string] : [ [string] , ] , } , classifiers = [ [string] , [string] , [string] , [string] , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import sys [EOL] [EOL] [EOL] print ( [string] [string] ) [EOL] print ( [string] [string] ) [EOL] [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import sys [EOL] [EOL] [EOL] print ( [string] [string] ) [EOL] print ( [string] [string] ) [EOL] [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , List [EOL] import pathlib [EOL] import argparse [EOL] import typing [EOL] import builtins [EOL] import scripts [EOL] import requests [EOL] import logging [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import json [EOL] import logging [EOL] import inspect [EOL] from urllib . parse import urlencode , urlparse , urlunparse [EOL] from pathlib import Path [EOL] [EOL] import requests [EOL] from requests . exceptions import ConnectionError [EOL] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] , ) [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class FtRestClient ( ) : [EOL] [EOL] def __init__ ( self , serverurl , username = None , password = None ) : [EOL] [EOL] self . _serverurl = serverurl [EOL] self . _session = requests . Session ( ) [EOL] self . _session . auth = ( username , password ) [EOL] [EOL] def _call ( self , method , apipath , params = None , data = None , files = None ) : [EOL] [EOL] if str ( method ) . upper ( ) not in ( [string] , [string] , [string] , [string] ) : [EOL] raise ValueError ( [string] . format ( method ) ) [EOL] basepath = f"{ self . _serverurl } [string] { apipath }" [EOL] [EOL] hd = { [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] schema , netloc , path , par , query , fragment = urlparse ( basepath ) [EOL] [comment] [EOL] query = urlencode ( params ) if params else [string] [EOL] [comment] [EOL] url = urlunparse ( ( schema , netloc , path , par , query , fragment ) ) [EOL] [EOL] try : [EOL] resp = self . _session . request ( method , url , headers = hd , data = json . dumps ( data ) ) [EOL] [comment] [EOL] return resp . json ( ) [EOL] except ConnectionError : [EOL] logger . warning ( [string] ) [EOL] [EOL] def _get ( self , apipath , params = None ) : [EOL] return self . _call ( [string] , apipath , params = params ) [EOL] [EOL] def _post ( self , apipath , params = None , data = None ) : [EOL] return self . _call ( [string] , apipath , params = params , data = data ) [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] return self . _post ( [string] ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] return self . _post ( [string] ) [EOL] [EOL] def stopbuy ( self ) : [EOL] [docstring] [EOL] return self . _post ( [string] ) [EOL] [EOL] def reload_conf ( self ) : [EOL] [docstring] [EOL] return self . _post ( [string] ) [EOL] [EOL] def balance ( self ) : [EOL] [docstring] [EOL] return self . _get ( [string] ) [EOL] [EOL] def count ( self ) : [EOL] [docstring] [EOL] return self . _get ( [string] ) [EOL] [EOL] def daily ( self , days = None ) : [EOL] [docstring] [EOL] return self . _get ( [string] , params = { [string] : days } if days else None ) [EOL] [EOL] def edge ( self ) : [EOL] [docstring] [EOL] return self . _get ( [string] ) [EOL] [EOL] def profit ( self ) : [EOL] [docstring] [EOL] return self . _get ( [string] ) [EOL] [EOL] def performance ( self ) : [EOL] [docstring] [EOL] return self . _get ( [string] ) [EOL] [EOL] def status ( self ) : [EOL] [docstring] [EOL] return self . _get ( [string] ) [EOL] [EOL] def version ( self ) : [EOL] [docstring] [EOL] return self . _get ( [string] ) [EOL] [EOL] def whitelist ( self ) : [EOL] [docstring] [EOL] return self . _get ( [string] ) [EOL] [EOL] def blacklist ( self , * args ) : [EOL] [docstring] [EOL] if not args : [EOL] return self . _get ( [string] ) [EOL] else : [EOL] return self . _post ( [string] , data = { [string] : args } ) [EOL] [EOL] def forcebuy ( self , pair , price = None ) : [EOL] [docstring] [EOL] data = { [string] : pair , [string] : price } [EOL] return self . _post ( [string] , data = data ) [EOL] [EOL] def forcesell ( self , tradeid ) : [EOL] [docstring] [EOL] [EOL] return self . _post ( [string] , data = { [string] : tradeid } ) [EOL] [EOL] [EOL] def add_arguments ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , dest = [string] , action = [string] , default = False ) [EOL] [EOL] parser . add_argument ( [string] , [string] , help = [string] , dest = [string] , type = str , metavar = [string] , default = [string] ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , nargs = [string] , default = [ ] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] return vars ( args ) [EOL] [EOL] [EOL] def load_config ( configfile ) : [EOL] file = Path ( configfile ) [EOL] if file . is_file ( ) : [EOL] with file . open ( [string] ) as f : [EOL] config = json . load ( f ) [EOL] return config [EOL] return { } [EOL] [EOL] [EOL] def print_commands ( ) : [EOL] [comment] [EOL] client = FtRestClient ( None ) [EOL] print ( [string] ) [EOL] for x , y in inspect . getmembers ( client ) : [EOL] if not x . startswith ( [string] ) : [EOL] print ( f"{ x } [string] { getattr ( client , x ) . __doc__ }" ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] [EOL] if args . get ( [string] ) : [EOL] print_commands ( ) [EOL] [EOL] config = load_config ( args [ [string] ] ) [EOL] url = config . get ( [string] , { } ) . get ( [string] , [string] ) [EOL] port = config . get ( [string] , { } ) . get ( [string] , [string] ) [EOL] username = config . get ( [string] , { } ) . get ( [string] ) [EOL] password = config . get ( [string] , { } ) . get ( [string] ) [EOL] [EOL] server_url = f" [string] { url } [string] { port }" [EOL] client = FtRestClient ( server_url , username , password ) [EOL] [EOL] m = [ x for x , y in inspect . getmembers ( client ) if not x . startswith ( [string] ) ] [EOL] command = args [ [string] ] [EOL] if command not in m : [EOL] logger . error ( f" [string] { command } [string] " ) [EOL] print_commands ( ) [EOL] return [EOL] [EOL] print ( getattr ( client , command ) ( * args [ [string] ] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] args = add_arguments ( ) [EOL] main ( args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.sessions.Session$ 0 0 0 0 0 0 0 0 0 $requests.sessions.Session$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 $builtins.dict$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [EOL] import sys [EOL] [EOL] [EOL] print ( [string] [string] ) [EOL] print ( [string] [string] ) [EOL] [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pandas [EOL] import datetime [EOL] import builtins [EOL] import typing [EOL] from math import exp [EOL] from datetime import datetime [EOL] [EOL] from pandas import DataFrame [EOL] [EOL] from freqtrade . optimize . hyperopt import IHyperOptLoss [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] TARGET_TRADES = [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] EXPECTED_MAX_PROFIT = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] MAX_ACCEPTED_TRADE_DURATION = [number] [EOL] [EOL] [EOL] class SampleHyperOptLoss ( IHyperOptLoss ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def hyperopt_loss_function ( results , trade_count , min_date , max_date , * args , ** kwargs ) : [EOL] [docstring] [EOL] total_profit = results . profit_percent . sum ( ) [EOL] trade_duration = results . trade_duration . mean ( ) [EOL] [EOL] trade_loss = [number] - [number] * exp ( - ( trade_count - TARGET_TRADES ) ** [number] / [number] ** [number] ) [EOL] profit_loss = max ( [number] , [number] - total_profit / EXPECTED_MAX_PROFIT ) [EOL] duration_loss = [number] * min ( trade_duration / MAX_ACCEPTED_TRADE_DURATION , [number] ) [EOL] result = trade_loss + profit_loss + duration_loss [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $pandas.DataFrame$ 0 $builtins.int$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.float$ 0
	0
	0
[docstring] [EOL] __version__ = [string] [EOL] [EOL] [EOL] class DependencyException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class OperationalException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InvalidOrderException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TemporaryError ( Exception ) : [EOL] [docstring] [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import pathlib [EOL] import argparse [EOL] import typing [EOL] import builtins [EOL] import freqtrade [EOL] import logging [EOL] import logging [EOL] import sys [EOL] from argparse import Namespace [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List [EOL] [EOL] import arrow [EOL] [EOL] from freqtrade . configuration import Configuration , TimeRange [EOL] from freqtrade . configuration . directory_operations import create_userdata_dir [EOL] from freqtrade . data . history import refresh_backtest_ohlcv_data [EOL] from freqtrade . exchange import available_exchanges [EOL] from freqtrade . resolvers import ExchangeResolver [EOL] from freqtrade . state import RunMode [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_utils_configuration ( args , method ) : [EOL] [docstring] [EOL] configuration = Configuration ( args , method ) [EOL] config = configuration . get_config ( ) [EOL] [EOL] config [ [string] ] [ [string] ] = True [EOL] [comment] [EOL] config [ [string] ] [ [string] ] = [string] [EOL] config [ [string] ] [ [string] ] = [string] [EOL] [EOL] return config [EOL] [EOL] [EOL] def start_list_exchanges ( args ) : [EOL] [docstring] [EOL] [EOL] if args . print_one_column : [EOL] print ( [string] . join ( available_exchanges ( ) ) ) [EOL] else : [EOL] print ( f" [string] " f"{ [string] . join ( available_exchanges ( ) ) }" ) [EOL] [EOL] [EOL] def start_create_userdir ( args ) : [EOL] [docstring] [EOL] if [string] in args and args . user_data_dir : [EOL] create_userdata_dir ( args . user_data_dir , create_dir = True ) [EOL] else : [EOL] logger . warning ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def start_download_data ( args ) : [EOL] [docstring] [EOL] config = setup_utils_configuration ( args , RunMode . OTHER ) [EOL] [EOL] timerange = TimeRange ( ) [EOL] if [string] in config : [EOL] time_since = arrow . utcnow ( ) . shift ( days = - config [ [string] ] ) . strftime ( [string] ) [EOL] timerange = TimeRange . parse_timerange ( f'{ time_since } [string] ' ) [EOL] [EOL] dl_path = Path ( config [ [string] ] ) [EOL] logger . info ( f' [string] { config [ [string] ] } [string] ' f' [string] { config [ [string] ] } [string] { dl_path }' ) [EOL] [EOL] pairs_not_available = [ ] [EOL] [EOL] try : [EOL] [comment] [EOL] exchange = ExchangeResolver ( config [ [string] ] [ [string] ] , config ) . exchange [EOL] [EOL] pairs_not_available = refresh_backtest_ohlcv_data ( exchange , pairs = config [ [string] ] , timeframes = config [ [string] ] , dl_path = Path ( config [ [string] ] ) , timerange = timerange , erase = config . get ( [string] ) ) [EOL] [EOL] except KeyboardInterrupt : [EOL] sys . exit ( [string] ) [EOL] [EOL] finally : [EOL] if pairs_not_available : [EOL] logger . info ( f" [string] { [string] . join ( pairs_not_available ) } [string] " f" [string] { config [ [string] ] [ [string] ] } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Dict , Any , List , Optional [EOL] import pathlib [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] from typing import Any , Dict , Optional [EOL] from pathlib import Path [EOL] [EOL] from freqtrade import OperationalException [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def create_datadir ( config , datadir = None ) : [EOL] [EOL] folder = Path ( datadir ) if datadir else Path ( f"{ config [ [string] ] } [string] " ) [EOL] if not datadir : [EOL] [comment] [EOL] exchange_name = config . get ( [string] , { } ) . get ( [string] ) . lower ( ) [EOL] folder = folder . joinpath ( exchange_name ) [EOL] [EOL] if not folder . is_dir ( ) : [EOL] folder . mkdir ( parents = True ) [EOL] logger . info ( f' [string] { datadir }' ) [EOL] return str ( folder ) [EOL] [EOL] [EOL] def create_userdata_dir ( directory , create_dir = False ) : [EOL] [docstring] [EOL] sub_dirs = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] folder = Path ( directory ) [EOL] if not folder . is_dir ( ) : [EOL] if create_dir : [EOL] folder . mkdir ( parents = True ) [EOL] logger . info ( f' [string] { folder }' ) [EOL] else : [EOL] raise OperationalException ( f" [string] { folder } [string] " [string] ) [EOL] [EOL] [comment] [EOL] for f in sub_dirs : [EOL] subfolder = folder / f [EOL] if not subfolder . is_dir ( ) : [EOL] subfolder . mkdir ( parents = False ) [EOL] return folder [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] from typing import Any , Dict [EOL] [EOL] from freqtrade import OperationalException [EOL] from freqtrade . exchange import ( available_exchanges , get_exchange_bad_reason , is_exchange_available , is_exchange_bad , is_exchange_officially_supported ) [EOL] from freqtrade . state import RunMode [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def check_exchange ( config , check_for_bad = True ) : [EOL] [docstring] [EOL] [EOL] if config [ [string] ] in [ RunMode . PLOT ] and not config . get ( [string] , { } ) . get ( [string] ) : [EOL] [comment] [EOL] return True [EOL] logger . info ( [string] ) [EOL] [EOL] exchange = config . get ( [string] , { } ) . get ( [string] ) . lower ( ) [EOL] if not is_exchange_available ( exchange ) : [EOL] raise OperationalException ( f' [string] { exchange } [string] ' f' [string] ' f' [string] ' f'{ [string] . join ( available_exchanges ( ) ) }' ) [EOL] [EOL] if check_for_bad and is_exchange_bad ( exchange ) : [EOL] raise OperationalException ( f' [string] { exchange } [string] ' f' [string] { get_exchange_bad_reason ( exchange ) }' ) [EOL] [EOL] if is_exchange_officially_supported ( exchange ) : [EOL] logger . info ( f' [string] { exchange } [string] ' f' [string] ' ) [EOL] else : [EOL] logger . warning ( f' [string] { exchange } [string] ' f' [string] ' f' [string] ' f' [string] ' f' [string] ' ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from freqtrade . configuration . arguments import Arguments [comment] [EOL] from freqtrade . configuration . timerange import TimeRange [comment] [EOL] from freqtrade . configuration . configuration import Configuration [comment] [EOL] from freqtrade . configuration . config_validation import validate_config_consistency [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import rapidjson [EOL] import logging [EOL] import sys [EOL] from typing import Any , Dict [EOL] [EOL] from freqtrade import OperationalException [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] CONFIG_PARSE_MODE = rapidjson . PM_COMMENTS | rapidjson . PM_TRAILING_COMMAS [EOL] [EOL] [EOL] def load_config_file ( path ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] with open ( path ) if path != [string] else sys . stdin as file : [EOL] config = rapidjson . load ( file , parse_mode = CONFIG_PARSE_MODE ) [EOL] except FileNotFoundError : [EOL] raise OperationalException ( f' [string] { path } [string] ' [string] ) [EOL] [EOL] return config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from freqtrade . pairlist . IPairList import IPairList [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class StaticPairList ( IPairList ) : [EOL] [EOL] def __init__ ( self , freqtrade , config ) : [EOL] super ( ) . __init__ ( freqtrade , config ) [EOL] [EOL] def short_desc ( self ) : [EOL] [docstring] [EOL] return f"{ self . name } [string] { self . whitelist }" [EOL] [EOL] def refresh_pairlist ( self ) : [EOL] [docstring] [EOL] self . _whitelist = self . _validate_whitelist ( self . _config [ [string] ] [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict , Set , List [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from abc import ABC , abstractmethod [EOL] from typing import List [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class IPairList ( ABC ) : [EOL] [EOL] def __init__ ( self , freqtrade , config ) : [EOL] self . _freqtrade = freqtrade [EOL] self . _config = config [EOL] self . _whitelist = self . _config [ [string] ] [ [string] ] [EOL] self . _blacklist = self . _config [ [string] ] . get ( [string] , [ ] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . __class__ . __name__ [EOL] [EOL] @ property def whitelist ( self ) : [EOL] [docstring] [EOL] return self . _whitelist [EOL] [EOL] @ property def blacklist ( self ) : [EOL] [docstring] [EOL] return self . _blacklist [EOL] [EOL] @ abstractmethod def short_desc ( self ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def refresh_pairlist ( self ) : [EOL] [docstring] [EOL] [EOL] def _validate_whitelist ( self , whitelist ) : [EOL] [docstring] [EOL] markets = self . _freqtrade . exchange . markets [EOL] [EOL] sanitized_whitelist = set ( ) [EOL] for pair in whitelist : [EOL] [comment] [EOL] if ( pair in self . blacklist or pair not in markets or not pair . endswith ( self . _config [ [string] ] ) ) : [EOL] logger . warning ( f" [string] { pair } [string] " f"{ self . _freqtrade . exchange . name } [string] " f" [string] " ) [EOL] continue [EOL] [comment] [EOL] market = markets [ pair ] [EOL] if not market [ [string] ] : [EOL] logger . info ( f" [string] { pair } [string] " ) [EOL] continue [EOL] sanitized_whitelist . add ( pair ) [EOL] [EOL] [comment] [EOL] return list ( sanitized_whitelist ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0
from . rpc import RPC , RPCMessageType , RPCException [comment] [EOL] from . rpc_manager import RPCManager [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import argparse [EOL] import typing [EOL] from argparse import Namespace [EOL] from freqtrade import OperationalException [EOL] from freqtrade . state import RunMode [EOL] from freqtrade . utils import setup_utils_configuration [EOL] [EOL] [EOL] def validate_plot_args ( args ) : [EOL] args_tmp = vars ( args ) [EOL] if not args_tmp . get ( [string] ) and not args_tmp . get ( [string] ) : [EOL] raise OperationalException ( [string] [string] ) [EOL] [EOL] [EOL] def start_plot_dataframe ( args ) : [EOL] [docstring] [EOL] [comment] [EOL] from freqtrade . plot . plotting import analyse_and_plot_pairs [EOL] validate_plot_args ( args ) [EOL] config = setup_utils_configuration ( args , RunMode . PLOT ) [EOL] [EOL] analyse_and_plot_pairs ( config ) [EOL] [EOL] [EOL] def start_plot_profit ( args ) : [EOL] [docstring] [EOL] [comment] [EOL] from freqtrade . plot . plotting import plot_profit [EOL] validate_plot_args ( args ) [EOL] config = setup_utils_configuration ( args , RunMode . PLOT ) [EOL] [EOL] plot_profit ( config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import plotly [EOL] import pathlib [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import pandas [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List [EOL] [EOL] import pandas as pd [EOL] [EOL] from freqtrade . configuration import TimeRange [EOL] from freqtrade . data import history [EOL] from freqtrade . data . btanalysis import ( combine_tickers_with_mean , create_cum_profit , extract_trades_of_period , load_trades ) [EOL] from freqtrade . resolvers import StrategyResolver [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] try : [EOL] from plotly . subplots import make_subplots [EOL] from plotly . offline import plot [EOL] import plotly . graph_objects as go [EOL] except ImportError : [EOL] logger . exception ( [string] ) [EOL] exit ( [number] ) [EOL] [EOL] [EOL] def init_plotscript ( config ) : [EOL] [docstring] [EOL] [EOL] if [string] in config : [EOL] pairs = config [ [string] ] [EOL] else : [EOL] pairs = config [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] timerange = TimeRange . parse_timerange ( config . get ( [string] ) ) [EOL] [EOL] tickers = history . load_data ( datadir = Path ( str ( config . get ( [string] ) ) ) , pairs = pairs , ticker_interval = config . get ( [string] , [string] ) , timerange = timerange , ) [EOL] [EOL] trades = load_trades ( config [ [string] ] , db_url = config . get ( [string] ) , exportfilename = config . get ( [string] ) , ) [EOL] [EOL] return { [string] : tickers , [string] : trades , [string] : pairs , } [EOL] [EOL] [EOL] def add_indicators ( fig , row , indicators , data ) : [EOL] [docstring] [EOL] for indicator in indicators : [EOL] if indicator in data : [EOL] [comment] [EOL] scattergl = go . Scatter ( x = data [ [string] ] , y = data [ indicator ] . values , mode = [string] , name = indicator ) [EOL] fig . add_trace ( scattergl , row , [number] ) [EOL] else : [EOL] logger . info ( [string] [string] , indicator ) [EOL] [EOL] return fig [EOL] [EOL] [EOL] def add_profit ( fig , row , data , column , name ) : [EOL] [docstring] [EOL] profit = go . Scattergl ( x = data . index , y = data [ column ] , name = name , ) [EOL] fig . add_trace ( profit , row , [number] ) [EOL] [EOL] return fig [EOL] [EOL] [EOL] def plot_trades ( fig , trades ) : [EOL] [docstring] [EOL] [comment] [EOL] if trades is not None and len ( trades ) > [number] : [EOL] trade_buys = go . Scatter ( x = trades [ [string] ] , y = trades [ [string] ] , mode = [string] , name = [string] , marker = dict ( symbol = [string] , size = [number] , line = dict ( width = [number] ) , color = [string] ) ) [EOL] [comment] [EOL] desc = trades . apply ( lambda row : f"{ round ( row [ [string] ] , [number] ) } [string] { row [ [string] ] } [string] " f"{ row [ [string] ] } [string] " , axis = [number] ) [EOL] trade_sells = go . Scatter ( x = trades [ [string] ] , y = trades [ [string] ] , text = desc , mode = [string] , name = [string] , marker = dict ( symbol = [string] , size = [number] , line = dict ( width = [number] ) , color = [string] ) ) [EOL] fig . add_trace ( trade_buys , [number] , [number] ) [EOL] fig . add_trace ( trade_sells , [number] , [number] ) [EOL] else : [EOL] logger . warning ( [string] ) [EOL] return fig [EOL] [EOL] [EOL] def generate_candlestick_graph ( pair , data , trades = None , indicators1 = [ ] , indicators2 = [ ] , ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] fig = make_subplots ( rows = [number] , cols = [number] , shared_xaxes = True , row_width = [ [number] , [number] , [number] ] , vertical_spacing = [number] , ) [EOL] fig [ [string] ] . update ( title = pair ) [EOL] fig [ [string] ] [ [string] ] . update ( title = [string] ) [EOL] fig [ [string] ] [ [string] ] . update ( title = [string] ) [EOL] fig [ [string] ] [ [string] ] . update ( title = [string] ) [EOL] fig [ [string] ] [ [string] ] [ [string] ] . update ( visible = False ) [EOL] [EOL] [comment] [EOL] candles = go . Candlestick ( x = data . date , open = data . open , high = data . high , low = data . low , close = data . close , name = [string] ) [EOL] fig . add_trace ( candles , [number] , [number] ) [EOL] [EOL] if [string] in data . columns : [EOL] df_buy = data [ data [ [string] ] == [number] ] [EOL] if len ( df_buy ) > [number] : [EOL] buys = go . Scatter ( x = df_buy . date , y = df_buy . close , mode = [string] , name = [string] , marker = dict ( symbol = [string] , size = [number] , line = dict ( width = [number] ) , color = [string] , ) ) [EOL] fig . add_trace ( buys , [number] , [number] ) [EOL] else : [EOL] logger . warning ( [string] ) [EOL] [EOL] if [string] in data . columns : [EOL] df_sell = data [ data [ [string] ] == [number] ] [EOL] if len ( df_sell ) > [number] : [EOL] sells = go . Scatter ( x = df_sell . date , y = df_sell . close , mode = [string] , name = [string] , marker = dict ( symbol = [string] , size = [number] , line = dict ( width = [number] ) , color = [string] , ) ) [EOL] fig . add_trace ( sells , [number] , [number] ) [EOL] else : [EOL] logger . warning ( [string] ) [EOL] [EOL] if [string] in data and [string] in data : [EOL] bb_lower = go . Scattergl ( x = data . date , y = data . bb_lowerband , name = [string] , line = { [string] : [string] } , ) [EOL] bb_upper = go . Scattergl ( x = data . date , y = data . bb_upperband , name = [string] , fill = [string] , fillcolor = [string] , line = { [string] : [string] } , ) [EOL] fig . add_trace ( bb_lower , [number] , [number] ) [EOL] fig . add_trace ( bb_upper , [number] , [number] ) [EOL] [EOL] [comment] [EOL] fig = add_indicators ( fig = fig , row = [number] , indicators = indicators1 , data = data ) [EOL] [EOL] fig = plot_trades ( fig , trades ) [EOL] [EOL] [comment] [EOL] volume = go . Bar ( x = data [ [string] ] , y = data [ [string] ] , name = [string] ) [EOL] fig . add_trace ( volume , [number] , [number] ) [EOL] [EOL] [comment] [EOL] fig = add_indicators ( fig = fig , row = [number] , indicators = indicators2 , data = data ) [EOL] [EOL] return fig [EOL] [EOL] [EOL] def generate_profit_graph ( pairs , tickers , trades ) : [EOL] [comment] [EOL] df_comb = combine_tickers_with_mean ( tickers , [string] ) [EOL] [EOL] [comment] [EOL] df_comb = create_cum_profit ( df_comb , trades , [string] ) [EOL] [EOL] [comment] [EOL] avgclose = go . Scattergl ( x = df_comb . index , y = df_comb [ [string] ] , name = [string] , ) [EOL] [EOL] fig = make_subplots ( rows = [number] , cols = [number] , shared_xaxes = True , row_width = [ [number] , [number] , [number] ] , vertical_spacing = [number] , subplot_titles = [ [string] , [string] , [string] ] ) [EOL] fig [ [string] ] . update ( title = [string] ) [EOL] fig [ [string] ] [ [string] ] . update ( title = [string] ) [EOL] fig [ [string] ] [ [string] ] . update ( title = [string] ) [EOL] fig [ [string] ] [ [string] ] . update ( title = [string] ) [EOL] fig [ [string] ] [ [string] ] [ [string] ] . update ( visible = False ) [EOL] [EOL] fig . add_trace ( avgclose , [number] , [number] ) [EOL] fig = add_profit ( fig , [number] , df_comb , [string] , [string] ) [EOL] [EOL] for pair in pairs : [EOL] profit_col = f' [string] { pair }' [EOL] df_comb = create_cum_profit ( df_comb , trades [ trades [ [string] ] == pair ] , profit_col ) [EOL] [EOL] fig = add_profit ( fig , [number] , df_comb , profit_col , f" [string] { pair }" ) [EOL] [EOL] return fig [EOL] [EOL] [EOL] def generate_plot_filename ( pair , ticker_interval ) : [EOL] [docstring] [EOL] pair_name = pair . replace ( [string] , [string] ) [EOL] file_name = [string] + pair_name + [string] + ticker_interval + [string] [EOL] [EOL] logger . info ( [string] , pair ) [EOL] [EOL] return file_name [EOL] [EOL] [EOL] def store_plot_file ( fig , filename , directory , auto_open = False ) : [EOL] [docstring] [EOL] directory . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] _filename = directory . joinpath ( filename ) [EOL] plot ( fig , filename = str ( _filename ) , auto_open = auto_open ) [EOL] logger . info ( f" [string] { _filename }" ) [EOL] [EOL] [EOL] def analyse_and_plot_pairs ( config ) : [EOL] [docstring] [EOL] strategy = StrategyResolver ( config ) . strategy [EOL] [EOL] plot_elements = init_plotscript ( config ) [EOL] trades = plot_elements [ [string] ] [EOL] [EOL] pair_counter = [number] [EOL] for pair , data in plot_elements [ [string] ] . items ( ) : [EOL] pair_counter += [number] [EOL] logger . info ( [string] , pair ) [EOL] tickers = { } [EOL] tickers [ pair ] = data [EOL] [EOL] dataframe = strategy . analyze_ticker ( tickers [ pair ] , { [string] : pair } ) [EOL] [EOL] trades_pair = trades . loc [ trades [ [string] ] == pair ] [EOL] trades_pair = extract_trades_of_period ( dataframe , trades_pair ) [EOL] [EOL] fig = generate_candlestick_graph ( pair = pair , data = dataframe , trades = trades_pair , indicators1 = config [ [string] ] , indicators2 = config [ [string] ] , ) [EOL] [EOL] store_plot_file ( fig , filename = generate_plot_filename ( pair , config [ [string] ] ) , directory = config [ [string] ] / [string] ) [EOL] [EOL] logger . info ( [string] , pair_counter ) [EOL] [EOL] [EOL] def plot_profit ( config ) : [EOL] [docstring] [EOL] plot_elements = init_plotscript ( config ) [EOL] trades = load_trades ( config [ [string] ] , db_url = str ( config . get ( [string] ) ) , exportfilename = str ( config . get ( [string] ) ) , ) [EOL] [comment] [EOL] trades = trades [ trades [ [string] ] . isin ( plot_elements [ [string] ] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] fig = generate_profit_graph ( plot_elements [ [string] ] , plot_elements [ [string] ] , trades ) [EOL] store_plot_file ( fig , filename = [string] , directory = config [ [string] ] / [string] , auto_open = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $plotly.subplots.make_subplots$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $plotly.subplots.make_subplots$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $plotly.subplots.make_subplots$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $plotly.graph_objects.Figure$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $plotly.graph_objects.Figure$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from freqtrade . resolvers . iresolver import IResolver [comment] [EOL] from freqtrade . resolvers . exchange_resolver import ExchangeResolver [comment] [EOL] [comment] [EOL] [comment] [EOL] from freqtrade . resolvers . pairlist_resolver import PairListResolver [comment] [EOL] from freqtrade . resolvers . strategy_resolver import StrategyResolver [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any , List , Optional [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import freqtrade [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Optional , Dict [EOL] [EOL] from freqtrade import OperationalException [EOL] from freqtrade . constants import DEFAULT_HYPEROPT , DEFAULT_HYPEROPT_LOSS [EOL] from freqtrade . optimize . hyperopt_interface import IHyperOpt [EOL] from freqtrade . optimize . hyperopt_loss_interface import IHyperOptLoss [EOL] from freqtrade . resolvers import IResolver [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class HyperOptResolver ( IResolver ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] hyperopt_name = config . get ( [string] ) or DEFAULT_HYPEROPT [EOL] self . hyperopt = self . _load_hyperopt ( hyperopt_name , config , extra_dir = config . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] IHyperOpt . ticker_interval = str ( config [ [string] ] ) [EOL] [EOL] if not hasattr ( self . hyperopt , [string] ) : [EOL] logger . warning ( [string] [string] ) [EOL] if not hasattr ( self . hyperopt , [string] ) : [EOL] logger . warning ( [string] [string] ) [EOL] [EOL] def _load_hyperopt ( self , hyperopt_name , config , extra_dir = None ) : [EOL] [docstring] [EOL] current_path = Path ( __file__ ) . parent . parent . joinpath ( [string] ) . resolve ( ) [EOL] [EOL] abs_paths = [ config [ [string] ] . joinpath ( [string] ) , current_path , ] [EOL] [EOL] if extra_dir : [EOL] [comment] [EOL] abs_paths . insert ( [number] , Path ( extra_dir ) . resolve ( ) ) [EOL] [EOL] hyperopt = self . _load_object ( paths = abs_paths , object_type = IHyperOpt , object_name = hyperopt_name ) [EOL] if hyperopt : [EOL] return hyperopt [EOL] raise OperationalException ( f" [string] { hyperopt_name } [string] " [string] ) [EOL] [EOL] [EOL] class HyperOptLossResolver ( IResolver ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , config = None ) : [EOL] [docstring] [EOL] config = config or { } [EOL] [EOL] [comment] [EOL] hyperopt_name = config . get ( [string] ) or DEFAULT_HYPEROPT_LOSS [EOL] self . hyperoptloss = self . _load_hyperoptloss ( hyperopt_name , config , extra_dir = config . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] self . hyperoptloss . __class__ . ticker_interval = str ( config [ [string] ] ) [EOL] [EOL] if not hasattr ( self . hyperoptloss , [string] ) : [EOL] raise OperationalException ( f" [string] { hyperopt_name } [string] " ) [EOL] [EOL] def _load_hyperoptloss ( self , hyper_loss_name , config , extra_dir = None ) : [EOL] [docstring] [EOL] current_path = Path ( __file__ ) . parent . parent . joinpath ( [string] ) . resolve ( ) [EOL] [EOL] abs_paths = [ config [ [string] ] . joinpath ( [string] ) , current_path , ] [EOL] [EOL] if extra_dir : [EOL] [comment] [EOL] abs_paths . insert ( [number] , Path ( extra_dir ) . resolve ( ) ) [EOL] [EOL] hyperoptloss = self . _load_object ( paths = abs_paths , object_type = IHyperOptLoss , object_name = hyper_loss_name ) [EOL] if hyperoptloss : [EOL] return hyperoptloss [EOL] [EOL] raise OperationalException ( f" [string] { hyper_loss_name } [string] " [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Generator , Optional , List , Union , Any , Tuple , Type [EOL] import pathlib [EOL] import typing [EOL] import _importlib_modulespec [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] import importlib . util [EOL] import inspect [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Any , List , Optional , Tuple , Type , Union [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class IResolver ( object ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def _get_valid_object ( object_type , module_path , object_name ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] spec = importlib . util . spec_from_file_location ( object_name , str ( module_path ) ) [EOL] module = importlib . util . module_from_spec ( spec ) [EOL] try : [EOL] spec . loader . exec_module ( module ) [comment] [EOL] except ( ModuleNotFoundError , SyntaxError ) as err : [EOL] [comment] [EOL] logger . warning ( f" [string] { module_path } [string] { err } [string] " ) [EOL] [EOL] valid_objects_gen = ( obj for name , obj in inspect . getmembers ( module , inspect . isclass ) if object_name == name and object_type in obj . __bases__ ) [EOL] return next ( valid_objects_gen , None ) [EOL] [EOL] @ staticmethod def _search_object ( directory , object_type , object_name , kwargs = { } ) : [EOL] [docstring] [EOL] logger . debug ( [string] , object_type . __name__ , object_name , directory ) [EOL] for entry in directory . iterdir ( ) : [EOL] [comment] [EOL] if not str ( entry ) . endswith ( [string] ) : [EOL] logger . debug ( [string] , entry ) [EOL] continue [EOL] module_path = entry . resolve ( ) [EOL] obj = IResolver . _get_valid_object ( object_type , module_path , object_name ) [EOL] if obj : [EOL] return ( obj ( ** kwargs ) , module_path ) [EOL] return ( None , None ) [EOL] [EOL] @ staticmethod def _load_object ( paths , object_type , object_name , kwargs = { } ) : [EOL] [docstring] [EOL] [EOL] for _path in paths : [EOL] try : [EOL] ( module , module_path ) = IResolver . _search_object ( directory = _path , object_type = object_type , object_name = object_name , kwargs = kwargs ) [EOL] if module : [EOL] logger . info ( f" [string] { object_type . __name__ . lower ( ) [ [number] : ] } [string] { object_name } [string] " f" [string] { module_path } [string] " ) [EOL] return module [EOL] except FileNotFoundError : [EOL] logger . warning ( [string] , _path . resolve ( ) ) [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Type[typing.Any]]$ 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleSpec$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleSpec$ 0 0 0 0 0 $_importlib_modulespec.ModuleSpec$ 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 $typing.Union[typing.Tuple[typing.Any,pathlib.Path],typing.Tuple[None,None]]$ 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Optional[typing.Type[typing.Any]]$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Type[typing.Any]]$ 0 0 0 0 $typing.Optional[typing.Type[typing.Any]]$ 0 0 $builtins.dict$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 $typing.List[pathlib.Path]$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import freqtrade [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from freqtrade . exchange import Exchange [EOL] import freqtrade . exchange as exchanges [EOL] from freqtrade . resolvers import IResolver [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ExchangeResolver ( IResolver ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , exchange_name , config ) : [EOL] [docstring] [EOL] exchange_name = exchange_name . title ( ) [EOL] try : [EOL] self . exchange = self . _load_exchange ( exchange_name , kwargs = { [string] : config } ) [EOL] except ImportError : [EOL] logger . info ( f" [string] { exchange_name } [string] " ) [EOL] if not hasattr ( self , [string] ) : [EOL] self . exchange = Exchange ( config ) [EOL] [EOL] def _load_exchange ( self , exchange_name , kwargs ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] ex_class = getattr ( exchanges , exchange_name ) [EOL] [EOL] exchange = ex_class ( kwargs [ [string] ] ) [EOL] if exchange : [EOL] logger . info ( f" [string] { exchange_name } [string] " ) [EOL] return exchange [EOL] except AttributeError : [EOL] [comment] [EOL] pass [EOL] [EOL] raise ImportError ( f" [string] { exchange_name } [string] " [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $freqtrade.exchange.Exchange$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.dict$ 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import freqtrade [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] from freqtrade import OperationalException [EOL] from freqtrade . pairlist . IPairList import IPairList [EOL] from freqtrade . resolvers import IResolver [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PairListResolver ( IResolver ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , pairlist_name , freqtrade , config ) : [EOL] [docstring] [EOL] self . pairlist = self . _load_pairlist ( pairlist_name , config , kwargs = { [string] : freqtrade , [string] : config } ) [EOL] [EOL] def _load_pairlist ( self , pairlist_name , config , kwargs ) : [EOL] [docstring] [EOL] current_path = Path ( __file__ ) . parent . parent . joinpath ( [string] ) . resolve ( ) [EOL] [EOL] abs_paths = [ config [ [string] ] . joinpath ( [string] ) , current_path , ] [EOL] [EOL] pairlist = self . _load_object ( paths = abs_paths , object_type = IPairList , object_name = pairlist_name , kwargs = kwargs ) [EOL] if pairlist : [EOL] return pairlist [EOL] raise OperationalException ( f" [string] { pairlist_name } [string] " [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $freqtrade.pairlist.IPairList.IPairList$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from typing import Dict [EOL] [EOL] import ccxt [EOL] [EOL] from freqtrade import ( DependencyException , InvalidOrderException , OperationalException , TemporaryError ) [EOL] from freqtrade . exchange import Exchange [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Binance ( Exchange ) : [EOL] [EOL] _ft_has = { [string] : True , [string] : [ [string] , [string] , [string] ] , } [EOL] [EOL] def get_order_book ( self , pair , limit = [number] ) : [EOL] [docstring] [EOL] limit_range = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [comment] [EOL] limit = min ( list ( filter ( lambda x : limit <= x , limit_range ) ) ) [EOL] [EOL] return super ( ) . get_order_book ( pair , limit ) [EOL] [EOL] def stoploss_limit ( self , pair , amount , stop_price , rate ) : [EOL] [docstring] [EOL] ordertype = [string] [EOL] [EOL] stop_price = self . symbol_price_prec ( pair , stop_price ) [EOL] [EOL] [comment] [EOL] if stop_price <= rate : [EOL] raise OperationalException ( [string] ) [EOL] [EOL] if self . _config [ [string] ] : [EOL] dry_order = self . dry_run_order ( pair , ordertype , [string] , amount , stop_price ) [EOL] return dry_order [EOL] [EOL] try : [EOL] params = self . _params . copy ( ) [EOL] params . update ( { [string] : stop_price } ) [EOL] [EOL] amount = self . symbol_amount_prec ( pair , amount ) [EOL] [EOL] rate = self . symbol_price_prec ( pair , rate ) [EOL] [EOL] order = self . _api . create_order ( pair , ordertype , [string] , amount , rate , params ) [EOL] logger . info ( [string] [string] , pair , stop_price , rate ) [EOL] return order [EOL] except ccxt . InsufficientFunds as e : [EOL] raise DependencyException ( f' [string] { ordertype } [string] { pair } [string] ' f' [string] { amount } [string] { rate } [string] ' f' [string] { e }' ) from e [EOL] except ccxt . InvalidOrder as e : [EOL] [comment] [EOL] [comment] [EOL] raise InvalidOrderException ( f' [string] { ordertype } [string] { pair } [string] ' f' [string] { amount } [string] { rate } [string] ' f' [string] { e }' ) from e [EOL] except ( ccxt . NetworkError , ccxt . ExchangeError ) as e : [EOL] raise TemporaryError ( f' [string] { e . __class__ . __name__ } [string] { e }' ) from e [EOL] except ccxt . BaseError as e : [EOL] raise OperationalException ( e ) from e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $typing.Dict$ 0 0 0 $builtins.str$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from typing import Dict [EOL] [EOL] from freqtrade . exchange import Exchange [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Kraken ( Exchange ) : [EOL] [EOL] _params = { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0
from freqtrade . exchange . exchange import Exchange [comment] [EOL] from freqtrade . exchange . exchange import ( get_exchange_bad_reason , is_exchange_bad , is_exchange_available , is_exchange_officially_supported , available_exchanges ) [EOL] from freqtrade . exchange . exchange import ( timeframe_to_seconds , timeframe_to_minutes , timeframe_to_msecs , timeframe_to_next_date , timeframe_to_prev_date ) [EOL] from freqtrade . exchange . kraken import Kraken [comment] [EOL] from freqtrade . exchange . binance import Binance [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Literal , List , Tuple , Any [EOL] import typing [EOL] import builtins [EOL] import typing_extensions [EOL] import freqtrade [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from typing import Dict , Any [EOL] from tabulate import tabulate [EOL] from freqtrade import constants [EOL] from freqtrade . edge import Edge [EOL] [EOL] from freqtrade . configuration import TimeRange [EOL] from freqtrade . exchange import Exchange [EOL] from freqtrade . resolvers import StrategyResolver [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class EdgeCli ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] self . config = config [EOL] [EOL] [comment] [EOL] self . config [ [string] ] [ [string] ] = [string] [EOL] self . config [ [string] ] [ [string] ] = [string] [EOL] self . config [ [string] ] [ [string] ] = [string] [EOL] self . config [ [string] ] [ [string] ] = [string] [EOL] self . config [ [string] ] = constants . UNLIMITED_STAKE_AMOUNT [EOL] self . config [ [string] ] = True [EOL] self . exchange = Exchange ( self . config ) [EOL] self . strategy = StrategyResolver ( self . config ) . strategy [EOL] [EOL] self . edge = Edge ( config , self . exchange , self . strategy ) [EOL] self . edge . _refresh_pairs = self . config . get ( [string] , False ) [EOL] [EOL] self . timerange = TimeRange . parse_timerange ( None if self . config . get ( [string] ) is None else str ( self . config . get ( [string] ) ) ) [EOL] [EOL] self . edge . _timerange = self . timerange [EOL] [EOL] def _generate_edge_table ( self , results ) : [EOL] [EOL] floatfmt = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] tabular_data = [ ] [EOL] headers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] for result in results . items ( ) : [EOL] if result [ [number] ] . nb_trades > [number] : [EOL] tabular_data . append ( [ result [ [number] ] , result [ [number] ] . stoploss , result [ [number] ] . winrate , result [ [number] ] . risk_reward_ratio , result [ [number] ] . required_risk_reward , result [ [number] ] . expectancy , result [ [number] ] . nb_trades , round ( result [ [number] ] . avg_trade_duration ) ] ) [EOL] [EOL] [comment] [EOL] return tabulate ( tabular_data , headers = headers , floatfmt = floatfmt , tablefmt = [string] ) [EOL] [EOL] def start ( self ) : [EOL] result = self . edge . calculate ( ) [EOL] if result : [EOL] print ( [string] ) [comment] [EOL] print ( self . _generate_edge_table ( self . edge . _cached_pairs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any , List , Optional [EOL] import pathlib [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import skopt [EOL] import freqtrade [EOL] import pandas [EOL] [docstring] [EOL] [EOL] import logging [EOL] import sys [EOL] [EOL] from collections import OrderedDict [EOL] from operator import itemgetter [EOL] from pathlib import Path [EOL] from pprint import pprint [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import rapidjson [EOL] [EOL] from colorama import init as colorama_init [EOL] from colorama import Fore , Style [EOL] from joblib import Parallel , delayed , dump , load , wrap_non_picklable_objects , cpu_count [EOL] from pandas import DataFrame [EOL] from skopt import Optimizer [EOL] from skopt . space import Dimension [EOL] [EOL] from freqtrade . configuration import TimeRange [EOL] from freqtrade . data . history import load_data , get_timeframe [EOL] from freqtrade . misc import round_dict [EOL] from freqtrade . optimize . backtesting import Backtesting [EOL] [comment] [EOL] from freqtrade . optimize . hyperopt_interface import IHyperOpt [comment] [EOL] from freqtrade . optimize . hyperopt_loss_interface import IHyperOptLoss [comment] [EOL] from freqtrade . resolvers . hyperopt_resolver import HyperOptResolver , HyperOptLossResolver [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] INITIAL_POINTS = [number] [EOL] MAX_LOSS = [number] [comment] [EOL] [EOL] [EOL] class Hyperopt : [EOL] [docstring] [EOL] def __init__ ( self , config ) : [EOL] self . config = config [EOL] self . backtesting = Backtesting ( self . config ) [EOL] [EOL] self . custom_hyperopt = HyperOptResolver ( self . config ) . hyperopt [EOL] [EOL] self . custom_hyperoptloss = HyperOptLossResolver ( self . config ) . hyperoptloss [EOL] self . calculate_loss = self . custom_hyperoptloss . hyperopt_loss_function [EOL] [EOL] self . trials_file = ( self . config [ [string] ] / [string] / [string] ) [EOL] self . tickerdata_pickle = ( self . config [ [string] ] / [string] / [string] ) [EOL] self . total_epochs = config . get ( [string] , [number] ) [EOL] [EOL] self . current_best_loss = [number] [EOL] [EOL] if not self . config . get ( [string] ) : [EOL] self . clean_hyperopt ( ) [EOL] else : [EOL] logger . info ( [string] ) [EOL] [EOL] [comment] [EOL] self . trials = [ ] [EOL] [EOL] [comment] [EOL] if hasattr ( self . custom_hyperopt , [string] ) : [EOL] self . backtesting . advise_buy = self . custom_hyperopt . populate_buy_trend [comment] [EOL] [EOL] if hasattr ( self . custom_hyperopt , [string] ) : [EOL] self . backtesting . advise_sell = self . custom_hyperopt . populate_sell_trend [comment] [EOL] [EOL] [comment] [EOL] if self . config . get ( [string] , True ) : [EOL] self . max_open_trades = self . config [ [string] ] [EOL] else : [EOL] logger . debug ( [string] ) [EOL] self . max_open_trades = [number] [EOL] self . position_stacking = self . config . get ( [string] , False ) , [EOL] [EOL] if self . has_space ( [string] ) : [EOL] [comment] [EOL] if [string] not in self . config : [EOL] self . config [ [string] ] = { } [EOL] self . config [ [string] ] [ [string] ] = True [EOL] [EOL] @ staticmethod def get_lock_filename ( config ) : [EOL] [EOL] return str ( config [ [string] ] / [string] ) [EOL] [EOL] def clean_hyperopt ( self ) : [EOL] [docstring] [EOL] for f in [ self . tickerdata_pickle , self . trials_file ] : [EOL] p = Path ( f ) [EOL] if p . is_file ( ) : [EOL] logger . info ( f" [string] { p } [string] " ) [EOL] p . unlink ( ) [EOL] [EOL] def get_args ( self , params ) : [EOL] dimensions = self . hyperopt_space ( ) [EOL] [comment] [EOL] [comment] [EOL] if len ( params ) != len ( dimensions ) : [EOL] raise ValueError ( [string] f' [string] { len ( dimensions ) } [string] { len ( params ) }' ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] arg_dict = { dim . name : value for dim , value in zip ( dimensions , params ) } [EOL] return arg_dict [EOL] [EOL] def save_trials ( self ) : [EOL] [docstring] [EOL] if self . trials : [EOL] logger . info ( [string] , len ( self . trials ) , self . trials_file ) [EOL] dump ( self . trials , self . trials_file ) [EOL] [EOL] def read_trials ( self ) : [EOL] [docstring] [EOL] logger . info ( [string] , self . trials_file ) [EOL] trials = load ( self . trials_file ) [EOL] self . trials_file . unlink ( ) [EOL] return trials [EOL] [EOL] def log_trials_result ( self ) : [EOL] [docstring] [EOL] results = sorted ( self . trials , key = itemgetter ( [string] ) ) [EOL] best_result = results [ [number] ] [EOL] params = best_result [ [string] ] [EOL] log_str = self . format_results_logstring ( best_result ) [EOL] print ( f" [string] { log_str } [string] " ) [EOL] [EOL] if self . config . get ( [string] ) : [EOL] result_dict = { } [EOL] if self . has_space ( [string] ) or self . has_space ( [string] ) : [EOL] result_dict [ [string] ] = { } [EOL] if self . has_space ( [string] ) : [EOL] result_dict [ [string] ] . update ( { p . name : params . get ( p . name ) for p in self . hyperopt_space ( [string] ) } ) [EOL] if self . has_space ( [string] ) : [EOL] result_dict [ [string] ] . update ( { p . name : params . get ( p . name ) for p in self . hyperopt_space ( [string] ) } ) [EOL] if self . has_space ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] result_dict [ [string] ] = OrderedDict ( ( str ( k ) , v ) for k , v in self . custom_hyperopt . generate_roi_table ( params ) . items ( ) ) [EOL] if self . has_space ( [string] ) : [EOL] result_dict [ [string] ] = params . get ( [string] ) [EOL] print ( rapidjson . dumps ( result_dict , default = str , number_mode = rapidjson . NM_NATIVE ) ) [EOL] else : [EOL] if self . has_space ( [string] ) : [EOL] print ( [string] ) [EOL] pprint ( { p . name : params . get ( p . name ) for p in self . hyperopt_space ( [string] ) } , indent = [number] ) [EOL] if self . has_space ( [string] ) : [EOL] print ( [string] ) [EOL] pprint ( { p . name : params . get ( p . name ) for p in self . hyperopt_space ( [string] ) } , indent = [number] ) [EOL] if self . has_space ( [string] ) : [EOL] print ( [string] ) [EOL] [comment] [EOL] pprint ( round_dict ( self . custom_hyperopt . generate_roi_table ( params ) , [number] ) , indent = [number] ) [EOL] if self . has_space ( [string] ) : [EOL] [comment] [EOL] print ( f" [string] { round ( params . get ( [string] ) , [number] ) }" ) [EOL] [EOL] def log_results ( self , results ) : [EOL] [docstring] [EOL] print_all = self . config . get ( [string] , False ) [EOL] is_best_loss = results [ [string] ] < self . current_best_loss [EOL] if print_all or is_best_loss : [EOL] if is_best_loss : [EOL] self . current_best_loss = results [ [string] ] [EOL] log_str = self . format_results_logstring ( results ) [EOL] [comment] [EOL] if self . config . get ( [string] , False ) : [EOL] if results [ [string] ] > [number] : [EOL] log_str = Fore . GREEN + log_str [EOL] if print_all and is_best_loss : [EOL] log_str = Style . BRIGHT + log_str [EOL] if print_all : [EOL] print ( log_str ) [EOL] else : [EOL] print ( [string] + log_str ) [EOL] else : [EOL] print ( [string] , end = [string] ) [EOL] sys . stdout . flush ( ) [EOL] [EOL] def format_results_logstring ( self , results ) : [EOL] [comment] [EOL] current = results [ [string] ] + [number] [EOL] total = self . total_epochs [EOL] res = results [ [string] ] [EOL] loss = results [ [string] ] [EOL] log_str = f'{ current : [string] } [string] { total } [string] { res } [string] { loss : [string] }' [EOL] log_str = f' [string] { log_str }' if results [ [string] ] else f' [string] { log_str }' [EOL] return log_str [EOL] [EOL] def has_space ( self , space ) : [EOL] [docstring] [EOL] return any ( s in self . config [ [string] ] for s in [ space , [string] ] ) [EOL] [EOL] def hyperopt_space ( self , space = None ) : [EOL] [docstring] [EOL] spaces = [ ] [EOL] if space == [string] or ( space is None and self . has_space ( [string] ) ) : [EOL] logger . debug ( [string] ) [EOL] spaces += self . custom_hyperopt . indicator_space ( ) [EOL] if space == [string] or ( space is None and self . has_space ( [string] ) ) : [EOL] logger . debug ( [string] ) [EOL] spaces += self . custom_hyperopt . sell_indicator_space ( ) [EOL] if space == [string] or ( space is None and self . has_space ( [string] ) ) : [EOL] logger . debug ( [string] ) [EOL] spaces += self . custom_hyperopt . roi_space ( ) [EOL] if space == [string] or ( space is None and self . has_space ( [string] ) ) : [EOL] logger . debug ( [string] ) [EOL] spaces += self . custom_hyperopt . stoploss_space ( ) [EOL] return spaces [EOL] [EOL] def generate_optimizer ( self , _params ) : [EOL] [docstring] [EOL] params = self . get_args ( _params ) [EOL] if self . has_space ( [string] ) : [EOL] self . backtesting . strategy . minimal_roi = self . custom_hyperopt . generate_roi_table ( params ) [EOL] [EOL] if self . has_space ( [string] ) : [EOL] self . backtesting . advise_buy = self . custom_hyperopt . buy_strategy_generator ( params ) [EOL] [EOL] if self . has_space ( [string] ) : [EOL] self . backtesting . advise_sell = self . custom_hyperopt . sell_strategy_generator ( params ) [EOL] [EOL] if self . has_space ( [string] ) : [EOL] self . backtesting . strategy . stoploss = params [ [string] ] [EOL] [EOL] processed = load ( self . tickerdata_pickle ) [EOL] [EOL] min_date , max_date = get_timeframe ( processed ) [EOL] [EOL] results = self . backtesting . backtest ( { [string] : self . config [ [string] ] , [string] : processed , [string] : self . max_open_trades , [string] : self . position_stacking , [string] : min_date , [string] : max_date , } ) [EOL] results_explanation = self . format_results ( results ) [EOL] [EOL] trade_count = len ( results . index ) [EOL] total_profit = results . profit_abs . sum ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if trade_count < self . config [ [string] ] : [EOL] return { [string] : MAX_LOSS , [string] : params , [string] : results_explanation , [string] : total_profit , } [EOL] [EOL] loss = self . calculate_loss ( results = results , trade_count = trade_count , min_date = min_date . datetime , max_date = max_date . datetime ) [EOL] [EOL] return { [string] : loss , [string] : params , [string] : results_explanation , [string] : total_profit , } [EOL] [EOL] def format_results ( self , results ) : [EOL] [docstring] [EOL] trades = len ( results . index ) [EOL] avg_profit = results . profit_percent . mean ( ) * [number] [EOL] total_profit = results . profit_abs . sum ( ) [EOL] stake_cur = self . config [ [string] ] [EOL] profit = results . profit_percent . sum ( ) * [number] [EOL] duration = results . trade_duration . mean ( ) [EOL] [EOL] return ( f'{ trades : [string] } [string] { avg_profit : [string] } [string] ' f' [string] { total_profit : [string] } [string] { stake_cur } [string] ' f' [string] { profit : [string] } [string] { duration : [string] } [string] ' ) [EOL] [EOL] def get_optimizer ( self , cpu_count ) : [EOL] return Optimizer ( self . hyperopt_space ( ) , base_estimator = [string] , acq_optimizer = [string] , n_initial_points = INITIAL_POINTS , acq_optimizer_kwargs = { [string] : cpu_count } , random_state = self . config . get ( [string] , None ) ) [EOL] [EOL] def run_optimizer_parallel ( self , parallel , asked ) : [EOL] return parallel ( delayed ( wrap_non_picklable_objects ( self . generate_optimizer ) ) ( v ) for v in asked ) [EOL] [EOL] def load_previous_results ( self ) : [EOL] [docstring] [EOL] if self . trials_file . is_file ( ) and self . trials_file . stat ( ) . st_size > [number] : [EOL] self . trials = self . read_trials ( ) [EOL] logger . info ( [string] , len ( self . trials ) ) [EOL] [EOL] def start ( self ) : [EOL] timerange = TimeRange . parse_timerange ( None if self . config . get ( [string] ) is None else str ( self . config . get ( [string] ) ) ) [EOL] data = load_data ( datadir = Path ( self . config [ [string] ] ) if self . config . get ( [string] ) else None , pairs = self . config [ [string] ] [ [string] ] , ticker_interval = self . backtesting . ticker_interval , refresh_pairs = self . config . get ( [string] , False ) , exchange = self . backtesting . exchange , timerange = timerange ) [EOL] [EOL] if not data : [EOL] logger . critical ( [string] ) [EOL] return [EOL] [EOL] min_date , max_date = get_timeframe ( data ) [EOL] [EOL] logger . info ( [string] , min_date . isoformat ( ) , max_date . isoformat ( ) , ( max_date - min_date ) . days ) [EOL] [EOL] self . backtesting . strategy . advise_indicators = self . custom_hyperopt . populate_indicators [comment] [EOL] [EOL] preprocessed = self . backtesting . strategy . tickerdata_to_dataframe ( data ) [EOL] [EOL] dump ( preprocessed , self . tickerdata_pickle ) [EOL] [EOL] [comment] [EOL] self . backtesting . exchange = None [comment] [EOL] [EOL] self . load_previous_results ( ) [EOL] [EOL] cpus = cpu_count ( ) [EOL] logger . info ( f" [string] { cpus } [string] " ) [EOL] config_jobs = self . config . get ( [string] , - [number] ) [EOL] logger . info ( f' [string] { config_jobs }' ) [EOL] [EOL] opt = self . get_optimizer ( config_jobs ) [EOL] [EOL] if self . config . get ( [string] , False ) : [EOL] colorama_init ( autoreset = True ) [EOL] [EOL] try : [EOL] with Parallel ( n_jobs = config_jobs ) as parallel : [EOL] jobs = parallel . _effective_n_jobs ( ) [EOL] logger . info ( f' [string] { jobs }' ) [EOL] EVALS = max ( self . total_epochs // jobs , [number] ) [EOL] for i in range ( EVALS ) : [EOL] asked = opt . ask ( n_points = jobs ) [EOL] f_val = self . run_optimizer_parallel ( parallel , asked ) [EOL] opt . tell ( asked , [ v [ [string] ] for v in f_val ] ) [EOL] for j in range ( jobs ) : [EOL] current = i * jobs + j [EOL] val = f_val [ j ] [EOL] val [ [string] ] = current [EOL] val [ [string] ] = current < INITIAL_POINTS [EOL] self . log_results ( val ) [EOL] self . trials . append ( val ) [EOL] logger . debug ( f" [string] { val }" ) [EOL] except KeyboardInterrupt : [EOL] print ( [string] ) [EOL] [EOL] self . save_trials ( ) [EOL] self . log_trials_result ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $freqtrade.optimize.backtesting.Backtesting$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $freqtrade.optimize.backtesting.Backtesting$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $freqtrade.optimize.backtesting.Backtesting$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 $typing.Dict$ 0 0 0 $typing.Dict$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $builtins.int$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $skopt.Optimizer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pandas [EOL] import datetime [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from datetime import datetime [EOL] [EOL] from pandas import DataFrame [EOL] import numpy as np [EOL] [EOL] from freqtrade . optimize . hyperopt import IHyperOptLoss [EOL] [EOL] [EOL] class SharpeHyperOptLoss ( IHyperOptLoss ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def hyperopt_loss_function ( results , trade_count , min_date , max_date , * args , ** kwargs ) : [EOL] [docstring] [EOL] total_profit = results . profit_percent [EOL] days_period = ( max_date - min_date ) . days [EOL] [EOL] [comment] [EOL] total_profit = total_profit - [number] [EOL] expected_yearly_return = total_profit . sum ( ) / days_period [EOL] [EOL] if ( np . std ( total_profit ) != [number] ) : [EOL] sharp_ratio = expected_yearly_return / np . std ( total_profit ) * np . sqrt ( [number] ) [EOL] else : [EOL] [comment] [EOL] sharp_ratio = - [number] [EOL] [EOL] [comment] [EOL] return - sharp_ratio [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $pandas.DataFrame$ 0 $builtins.int$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $pandas.DataFrame$ 0 0 0 $builtins.int$ 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0
from typing import Dict , Any , List , Callable [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import skopt [EOL] import pandas [EOL] [docstring] [EOL] import logging [EOL] import math [EOL] [EOL] from abc import ABC , abstractmethod [EOL] from typing import Dict , Any , Callable , List [EOL] [EOL] from pandas import DataFrame [EOL] from skopt . space import Dimension , Integer , Real [EOL] [EOL] from freqtrade . exchange import timeframe_to_minutes [EOL] from freqtrade . misc import round_dict [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class IHyperOpt ( ABC ) : [EOL] [docstring] [EOL] ticker_interval = ... [EOL] [EOL] @ staticmethod @ abstractmethod def populate_indicators ( dataframe , metadata ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod @ abstractmethod def buy_strategy_generator ( params ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod @ abstractmethod def sell_strategy_generator ( params ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod @ abstractmethod def indicator_space ( ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod @ abstractmethod def sell_indicator_space ( ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def generate_roi_table ( params ) : [EOL] [docstring] [EOL] roi_table = { } [EOL] roi_table [ [number] ] = params [ [string] ] + params [ [string] ] + params [ [string] ] [EOL] roi_table [ params [ [string] ] ] = params [ [string] ] + params [ [string] ] [EOL] roi_table [ params [ [string] ] + params [ [string] ] ] = params [ [string] ] [EOL] roi_table [ params [ [string] ] + params [ [string] ] + params [ [string] ] ] = [number] [EOL] [EOL] return roi_table [EOL] [EOL] @ staticmethod def roi_space ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] roi_t_alpha = [number] [EOL] roi_p_alpha = [number] [EOL] [EOL] ticker_interval_mins = timeframe_to_minutes ( IHyperOpt . ticker_interval ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] roi_t_scale = ticker_interval_mins / [number] [EOL] roi_p_scale = math . log1p ( ticker_interval_mins ) / math . log1p ( [number] ) [EOL] roi_limits = { [string] : int ( [number] * roi_t_scale * roi_t_alpha ) , [string] : int ( [number] * roi_t_scale * roi_t_alpha ) , [string] : int ( [number] * roi_t_scale * roi_t_alpha ) , [string] : int ( [number] * roi_t_scale * roi_t_alpha ) , [string] : int ( [number] * roi_t_scale * roi_t_alpha ) , [string] : int ( [number] * roi_t_scale * roi_t_alpha ) , [string] : [number] * roi_p_scale * roi_p_alpha , [string] : [number] * roi_p_scale * roi_p_alpha , [string] : [number] * roi_p_scale * roi_p_alpha , [string] : [number] * roi_p_scale * roi_p_alpha , [string] : [number] * roi_p_scale * roi_p_alpha , [string] : [number] * roi_p_scale * roi_p_alpha , } [EOL] logger . debug ( f" [string] { roi_limits }" ) [EOL] p = { [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , } [EOL] logger . info ( f" [string] { round_dict ( IHyperOpt . generate_roi_table ( p ) , [number] ) }" ) [EOL] p = { [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , [string] : roi_limits [ [string] ] , } [EOL] logger . info ( f" [string] { round_dict ( IHyperOpt . generate_roi_table ( p ) , [number] ) }" ) [EOL] [EOL] return [ Integer ( roi_limits [ [string] ] , roi_limits [ [string] ] , name = [string] ) , Integer ( roi_limits [ [string] ] , roi_limits [ [string] ] , name = [string] ) , Integer ( roi_limits [ [string] ] , roi_limits [ [string] ] , name = [string] ) , Real ( roi_limits [ [string] ] , roi_limits [ [string] ] , name = [string] ) , Real ( roi_limits [ [string] ] , roi_limits [ [string] ] , name = [string] ) , Real ( roi_limits [ [string] ] , roi_limits [ [string] ] , name = [string] ) , ] [EOL] [EOL] @ staticmethod def stoploss_space ( ) : [EOL] [docstring] [EOL] return [ Real ( - [number] , - [number] , name = [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def __getstate__ ( self ) : [EOL] state = self . __dict__ . copy ( ) [EOL] state [ [string] ] = self . ticker_interval [EOL] return state [EOL] [EOL] def __setstate__ ( self , state ) : [EOL] self . __dict__ . update ( state ) [EOL] IHyperOpt . ticker_interval = state [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 $pandas.DataFrame$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 $typing.Dict$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict$ 0 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[skopt.space.Dimension]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import Any [EOL] import pandas [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from math import exp [EOL] [EOL] from pandas import DataFrame [EOL] [EOL] from freqtrade . optimize . hyperopt import IHyperOptLoss [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] TARGET_TRADES = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] EXPECTED_MAX_PROFIT = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] MAX_ACCEPTED_TRADE_DURATION = [number] [EOL] [EOL] [EOL] class DefaultHyperOptLoss ( IHyperOptLoss ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def hyperopt_loss_function ( results , trade_count , * args , ** kwargs ) : [EOL] [docstring] [EOL] total_profit = results . profit_percent . sum ( ) [EOL] trade_duration = results . trade_duration . mean ( ) [EOL] [EOL] trade_loss = [number] - [number] * exp ( - ( trade_count - TARGET_TRADES ) ** [number] / [number] ** [number] ) [EOL] profit_loss = max ( [number] , [number] - total_profit / EXPECTED_MAX_PROFIT ) [EOL] duration_loss = [number] * min ( trade_duration / MAX_ACCEPTED_TRADE_DURATION , [number] ) [EOL] result = trade_loss + profit_loss + duration_loss [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $pandas.DataFrame$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.float$ 0
[comment] [EOL] [EOL] from typing import Dict , Type , Any , Union [EOL] import freqtrade [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import talib . abstract as ta [EOL] from pandas import DataFrame [EOL] [EOL] import freqtrade . vendor . qtpylib . indicators as qtpylib [EOL] from freqtrade . indicator_helpers import fishers_inverse [EOL] from freqtrade . strategy . interface import IStrategy [EOL] [EOL] [EOL] class DefaultStrategy ( IStrategy ) : [EOL] [docstring] [EOL] INTERFACE_VERSION = [number] [EOL] [EOL] [comment] [EOL] minimal_roi = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] [comment] [EOL] stoploss = - [number] [EOL] [EOL] [comment] [EOL] ticker_interval = [string] [EOL] [EOL] [comment] [EOL] order_types = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : False } [EOL] [EOL] [comment] [EOL] order_time_in_force = { [string] : [string] , [string] : [string] , } [EOL] [EOL] def informative_pairs ( self ) : [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] def populate_indicators ( self , dataframe , metadata ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . ADX ( dataframe ) [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = qtpylib . awesome_oscillator ( dataframe ) [EOL] [docstring] [EOL] [comment] [EOL] macd = ta . MACD ( dataframe ) [EOL] dataframe [ [string] ] = macd [ [string] ] [EOL] dataframe [ [string] ] = macd [ [string] ] [EOL] dataframe [ [string] ] = macd [ [string] ] [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . MFI ( dataframe ) [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . MINUS_DM ( dataframe ) [EOL] dataframe [ [string] ] = ta . MINUS_DI ( dataframe ) [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . PLUS_DM ( dataframe ) [EOL] dataframe [ [string] ] = ta . PLUS_DI ( dataframe ) [EOL] dataframe [ [string] ] = ta . MINUS_DI ( dataframe ) [EOL] [EOL] [docstring] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . RSI ( dataframe ) [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = fishers_inverse ( dataframe [ [string] ] ) [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = [number] * ( dataframe [ [string] ] + [number] ) [EOL] [EOL] [comment] [EOL] stoch = ta . STOCH ( dataframe ) [EOL] dataframe [ [string] ] = stoch [ [string] ] [EOL] dataframe [ [string] ] = stoch [ [string] ] [EOL] [EOL] [comment] [EOL] stoch_fast = ta . STOCHF ( dataframe ) [EOL] dataframe [ [string] ] = stoch_fast [ [string] ] [EOL] dataframe [ [string] ] = stoch_fast [ [string] ] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . BBANDS ( dataframe , nbdevup = [number] , nbdevdn = [number] ) [ [string] ] [EOL] [EOL] [comment] [EOL] bollinger = qtpylib . bollinger_bands ( qtpylib . typical_price ( dataframe ) , window = [number] , stds = [number] ) [EOL] dataframe [ [string] ] = bollinger [ [string] ] [EOL] dataframe [ [string] ] = bollinger [ [string] ] [EOL] dataframe [ [string] ] = bollinger [ [string] ] [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . EMA ( dataframe , timeperiod = [number] ) [EOL] dataframe [ [string] ] = ta . EMA ( dataframe , timeperiod = [number] ) [EOL] dataframe [ [string] ] = ta . EMA ( dataframe , timeperiod = [number] ) [EOL] dataframe [ [string] ] = ta . EMA ( dataframe , timeperiod = [number] ) [EOL] dataframe [ [string] ] = ta . EMA ( dataframe , timeperiod = [number] ) [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . SAR ( dataframe ) [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . SMA ( dataframe , timeperiod = [number] ) [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . TEMA ( dataframe , timeperiod = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] hilbert = ta . HT_SINE ( dataframe ) [EOL] dataframe [ [string] ] = hilbert [ [string] ] [EOL] dataframe [ [string] ] = hilbert [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] heikinashi = qtpylib . heikinashi ( dataframe ) [EOL] dataframe [ [string] ] = heikinashi [ [string] ] [EOL] dataframe [ [string] ] = heikinashi [ [string] ] [EOL] dataframe [ [string] ] = heikinashi [ [string] ] [EOL] dataframe [ [string] ] = heikinashi [ [string] ] [EOL] [EOL] return dataframe [EOL] [EOL] def populate_buy_trend ( self , dataframe , metadata ) : [EOL] [docstring] [EOL] dataframe . loc [ ( ( dataframe [ [string] ] < [number] ) & ( dataframe [ [string] ] < [number] ) & ( dataframe [ [string] ] > [number] ) & ( dataframe [ [string] ] > [number] ) ) | ( ( dataframe [ [string] ] > [number] ) & ( dataframe [ [string] ] > [number] ) ) , [string] ] = [number] [EOL] [EOL] return dataframe [EOL] [EOL] def populate_sell_trend ( self , dataframe , metadata ) : [EOL] [docstring] [EOL] dataframe . loc [ ( ( ( qtpylib . crossed_above ( dataframe [ [string] ] , [number] ) ) | ( qtpylib . crossed_above ( dataframe [ [string] ] , [number] ) ) ) & ( dataframe [ [string] ] > [number] ) & ( dataframe [ [string] ] > [number] ) ) | ( ( dataframe [ [string] ] > [number] ) & ( dataframe [ [string] ] > [number] ) ) , [string] ] = [number] [EOL] return dataframe [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 $builtins.dict$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 $builtins.dict$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from freqtrade . configuration import TimeRange [EOL] [EOL] [EOL] def test_parse_timerange_incorrect ( ) : [EOL] assert TimeRange ( None , [string] , [number] , - [number] ) == TimeRange . parse_timerange ( [string] ) [EOL] assert TimeRange ( [string] , None , [number] , [number] ) == TimeRange . parse_timerange ( [string] ) [EOL] assert TimeRange ( [string] , [string] , [number] , [number] ) == TimeRange . parse_timerange ( [string] ) [EOL] [EOL] assert TimeRange ( [string] , None , [number] , [number] ) == TimeRange . parse_timerange ( [string] ) [EOL] assert TimeRange ( None , [string] , [number] , [number] ) == TimeRange . parse_timerange ( [string] ) [EOL] timerange = TimeRange . parse_timerange ( [string] ) [EOL] assert timerange == TimeRange ( [string] , [string] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] assert TimeRange ( [string] , None , [number] , [number] ) == TimeRange . parse_timerange ( [string] ) [EOL] assert TimeRange ( None , [string] , [number] , [number] ) == TimeRange . parse_timerange ( [string] ) [EOL] timerange = TimeRange . parse_timerange ( [string] ) [EOL] assert TimeRange ( [string] , [string] , [number] , [number] ) == timerange [EOL] [EOL] [comment] [EOL] timerange = TimeRange . parse_timerange ( [string] ) [EOL] assert TimeRange ( [string] , [string] , [number] , [number] ) != timerange [EOL] [EOL] with pytest . raises ( Exception , match = [string] ) : [EOL] TimeRange . parse_timerange ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] from pathlib import Path [EOL] from unittest . mock import MagicMock [EOL] [EOL] from freqtrade . data . converter import parse_ticker_dataframe [EOL] from freqtrade . data . history import pair_data_filename [EOL] from freqtrade . misc import ( datesarray_to_datetimearray , file_dump_json , file_load_json , format_ms_time , shorten_date ) [EOL] [EOL] [EOL] def test_shorten_date ( ) : [EOL] str_data = [string] [EOL] str_shorten_data = [string] [EOL] assert shorten_date ( str_data ) == str_shorten_data [EOL] [EOL] [EOL] def test_datesarray_to_datetimearray ( ticker_history_list ) : [EOL] dataframes = parse_ticker_dataframe ( ticker_history_list , [string] , pair = [string] , fill_missing = True ) [EOL] dates = datesarray_to_datetimearray ( dataframes [ [string] ] ) [EOL] [EOL] assert isinstance ( dates [ [number] ] , datetime . datetime ) [EOL] assert dates [ [number] ] . year == [number] [EOL] assert dates [ [number] ] . month == [number] [EOL] assert dates [ [number] ] . day == [number] [EOL] assert dates [ [number] ] . hour == [number] [EOL] assert dates [ [number] ] . minute == [number] [EOL] [EOL] date_len = len ( dates ) [EOL] assert date_len == [number] [EOL] [EOL] [EOL] def test_file_dump_json ( mocker ) : [EOL] file_open = mocker . patch ( [string] , MagicMock ( ) ) [EOL] json_dump = mocker . patch ( [string] , MagicMock ( ) ) [EOL] file_dump_json ( Path ( [string] ) , [ [number] , [number] , [number] ] ) [EOL] assert file_open . call_count == [number] [EOL] assert json_dump . call_count == [number] [EOL] file_open = mocker . patch ( [string] , MagicMock ( ) ) [EOL] json_dump = mocker . patch ( [string] , MagicMock ( ) ) [EOL] file_dump_json ( Path ( [string] ) , [ [number] , [number] , [number] ] , True ) [EOL] assert file_open . call_count == [number] [EOL] assert json_dump . call_count == [number] [EOL] [EOL] [EOL] def test_file_load_json ( mocker ) : [EOL] [EOL] [comment] [EOL] ret = file_load_json ( pair_data_filename ( None , [string] , [string] ) ) [EOL] assert not ret [EOL] [comment] [EOL] ret = file_load_json ( pair_data_filename ( None , [string] , [string] ) ) [EOL] assert ret [EOL] [comment] [EOL] ret = file_load_json ( pair_data_filename ( None , [string] , [string] ) ) [EOL] assert ret [EOL] [EOL] [EOL] def test_format_ms_time ( ) : [EOL] [comment] [EOL] date_in_epoch_ms = [number] [EOL] date = format_ms_time ( date_in_epoch_ms ) [EOL] assert type ( date ) is str [EOL] res = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = datetime . timezone . utc ) [EOL] assert date == res . astimezone ( None ) . strftime ( [string] ) [EOL] res = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = datetime . timezone . utc ) [EOL] [comment] [EOL] date_in_epoch_ms = [number] [EOL] assert format_ms_time ( date_in_epoch_ms ) == res . astimezone ( None ) . strftime ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any , List , Union [EOL] import unittest [EOL] import freqtrade [EOL] import typing [EOL] import math [EOL] import random [EOL] from pathlib import Path [EOL] from unittest . mock import MagicMock [EOL] [EOL] import numpy as np [EOL] import pandas as pd [EOL] import pytest [EOL] from arrow import Arrow [EOL] [EOL] from freqtrade import DependencyException , OperationalException , constants [EOL] from freqtrade . configuration import TimeRange [EOL] from freqtrade . data import history [EOL] from freqtrade . data . btanalysis import evaluate_result_multi [EOL] from freqtrade . data . converter import parse_ticker_dataframe [EOL] from freqtrade . data . dataprovider import DataProvider [EOL] from freqtrade . data . history import get_timeframe [EOL] from freqtrade . optimize import setup_configuration , start_backtesting [EOL] from freqtrade . optimize . backtesting import Backtesting [EOL] from freqtrade . state import RunMode [EOL] from freqtrade . strategy . default_strategy import DefaultStrategy [EOL] from freqtrade . strategy . interface import SellType [EOL] from freqtrade . tests . conftest import ( get_args , log_has , log_has_re , patch_exchange , patched_configuration_load_config_file ) [EOL] [EOL] [EOL] def trim_dictlist ( dict_list , num ) : [EOL] new = { } [EOL] for pair , pair_data in dict_list . items ( ) : [EOL] new [ pair ] = pair_data [ num : ] . reset_index ( ) [EOL] return new [EOL] [EOL] [EOL] def load_data_test ( what ) : [EOL] timerange = TimeRange ( None , [string] , [number] , - [number] ) [EOL] pair = history . load_tickerdata_file ( None , ticker_interval = [string] , pair = [string] , timerange = timerange ) [EOL] datalen = len ( pair ) [EOL] [EOL] base = [number] [EOL] if what == [string] : [EOL] data = [ [ pair [ x ] [ [number] ] , x * base , x * base + [number] , x * base - [number] , x * base , pair [ x ] [ [number] ] , ] for x in range ( [number] , datalen ) ] [EOL] if what == [string] : [EOL] data = [ [ pair [ x ] [ [number] ] , [number] - x * base , [number] - x * base + [number] , [number] - x * base - [number] , [number] - x * base , pair [ x ] [ [number] ] ] for x in range ( [number] , datalen ) ] [EOL] if what == [string] : [EOL] hz = [number] [comment] [EOL] data = [ [ pair [ x ] [ [number] ] , math . sin ( x * hz ) / [number] + base , math . sin ( x * hz ) / [number] + base + [number] , math . sin ( x * hz ) / [number] + base - [number] , math . sin ( x * hz ) / [number] + base , pair [ x ] [ [number] ] ] for x in range ( [number] , datalen ) ] [EOL] return { [string] : parse_ticker_dataframe ( data , [string] , pair = [string] , fill_missing = True ) } [EOL] [EOL] [EOL] def simple_backtest ( config , contour , num_results , mocker ) : [EOL] patch_exchange ( mocker ) [EOL] config [ [string] ] = [string] [EOL] backtesting = Backtesting ( config ) [EOL] [EOL] data = load_data_test ( contour ) [EOL] processed = backtesting . strategy . tickerdata_to_dataframe ( data ) [EOL] min_date , max_date = get_timeframe ( processed ) [EOL] assert isinstance ( processed , dict ) [EOL] results = backtesting . backtest ( { [string] : config [ [string] ] , [string] : processed , [string] : [number] , [string] : False , [string] : min_date , [string] : max_date , } ) [EOL] [comment] [EOL] assert len ( results ) == num_results [EOL] [EOL] [EOL] def mocked_load_data ( datadir , pairs = [ ] , ticker_interval = [string] , refresh_pairs = False , timerange = None , exchange = None , live = False ) : [EOL] tickerdata = history . load_tickerdata_file ( datadir , [string] , [string] , timerange = timerange ) [EOL] pairdata = { [string] : parse_ticker_dataframe ( tickerdata , [string] , pair = [string] , fill_missing = True ) } [EOL] return pairdata [EOL] [EOL] [EOL] [comment] [EOL] def _load_pair_as_ticks ( pair , tickfreq ) : [EOL] ticks = history . load_tickerdata_file ( None , ticker_interval = tickfreq , pair = pair ) [EOL] ticks = ticks [ - [number] : ] [EOL] return ticks [EOL] [EOL] [EOL] [comment] [EOL] def _make_backtest_conf ( mocker , conf = None , pair = [string] , record = None ) : [EOL] data = history . load_data ( datadir = None , ticker_interval = [string] , pairs = [ pair ] ) [EOL] data = trim_dictlist ( data , - [number] ) [EOL] patch_exchange ( mocker ) [EOL] backtesting = Backtesting ( conf ) [EOL] processed = backtesting . strategy . tickerdata_to_dataframe ( data ) [EOL] min_date , max_date = get_timeframe ( processed ) [EOL] return { [string] : conf [ [string] ] , [string] : processed , [string] : [number] , [string] : False , [string] : record , [string] : min_date , [string] : max_date , } [EOL] [EOL] [EOL] def _trend ( signals , buy_value , sell_value ) : [EOL] n = len ( signals [ [string] ] ) [EOL] buy = np . zeros ( n ) [EOL] sell = np . zeros ( n ) [EOL] for i in range ( [number] , len ( signals [ [string] ] ) ) : [EOL] if random . random ( ) > [number] : [comment] [EOL] buy [ i ] = buy_value [EOL] sell [ i ] = sell_value [EOL] signals [ [string] ] = buy [EOL] signals [ [string] ] = sell [EOL] return signals [EOL] [EOL] [EOL] def _trend_alternate ( dataframe = None , metadata = None ) : [EOL] signals = dataframe [EOL] low = signals [ [string] ] [EOL] n = len ( low ) [EOL] buy = np . zeros ( n ) [EOL] sell = np . zeros ( n ) [EOL] for i in range ( [number] , len ( buy ) ) : [EOL] if i % [number] == [number] : [EOL] buy [ i ] = [number] [EOL] else : [EOL] sell [ i ] = [number] [EOL] signals [ [string] ] = buy [EOL] signals [ [string] ] = sell [EOL] return dataframe [EOL] [EOL] [EOL] [comment] [EOL] def test_setup_configuration_without_arguments ( mocker , default_conf , caplog ) : [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] config = setup_configuration ( get_args ( args ) , RunMode . BACKTEST ) [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [ [string] ] [EOL] assert [string] in config [EOL] assert log_has ( [string] . format ( config [ [string] ] ) , caplog ) [EOL] assert [string] in config [EOL] assert not log_has_re ( [string] , caplog ) [EOL] [EOL] assert [string] not in config [EOL] assert not log_has ( [string] , caplog ) [EOL] [EOL] assert [string] not in config [EOL] assert not log_has ( [string] , caplog ) [EOL] [EOL] assert [string] not in config [EOL] assert [string] not in config [EOL] assert [string] in config [EOL] assert config [ [string] ] == RunMode . BACKTEST [EOL] [EOL] [EOL] @ pytest . mark . filterwarnings ( [string] ) def test_setup_bt_configuration_with_arguments ( mocker , default_conf , caplog ) : [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] mocker . patch ( [string] , lambda c , x : x ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] config = setup_configuration ( get_args ( args ) , RunMode . BACKTEST ) [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [ [string] ] [EOL] assert [string] in config [EOL] assert config [ [string] ] == RunMode . BACKTEST [EOL] [EOL] assert log_has ( [string] . format ( config [ [string] ] ) , caplog ) [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] . format ( config [ [string] ] ) , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] . format ( config [ [string] ] ) , caplog ) [EOL] assert [string] in config [EOL] assert log_has ( [string] . format ( config [ [string] ] ) , caplog ) [EOL] [EOL] [EOL] def test_setup_configuration_unlimited_stake_amount ( mocker , default_conf , caplog ) : [EOL] default_conf [ [string] ] = constants . UNLIMITED_STAKE_AMOUNT [EOL] [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] with pytest . raises ( DependencyException , match = [string] ) : [EOL] setup_configuration ( get_args ( args ) , RunMode . BACKTEST ) [EOL] [EOL] [EOL] def test_start ( mocker , fee , default_conf , caplog ) : [EOL] start_mock = MagicMock ( ) [EOL] mocker . patch ( [string] , fee ) [EOL] patch_exchange ( mocker ) [EOL] mocker . patch ( [string] , start_mock ) [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] ] [EOL] args = get_args ( args ) [EOL] start_backtesting ( args ) [EOL] assert log_has ( [string] , caplog ) [EOL] assert start_mock . call_count == [number] [EOL] [EOL] [EOL] ORDER_TYPES = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : False } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : True } ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ORDER_TYPES ) def test_backtesting_init ( mocker , default_conf , order_types ) : [EOL] [docstring] [EOL] default_conf [ [string] ] = order_types [EOL] patch_exchange ( mocker ) [EOL] get_fee = mocker . patch ( [string] , MagicMock ( return_value = [number] ) ) [EOL] backtesting = Backtesting ( default_conf ) [EOL] assert backtesting . config == default_conf [EOL] assert backtesting . ticker_interval == [string] [EOL] assert callable ( backtesting . strategy . tickerdata_to_dataframe ) [EOL] assert callable ( backtesting . advise_buy ) [EOL] assert callable ( backtesting . advise_sell ) [EOL] assert isinstance ( backtesting . strategy . dp , DataProvider ) [EOL] get_fee . assert_called ( ) [EOL] assert backtesting . fee == [number] [EOL] assert not backtesting . strategy . order_types [ [string] ] [EOL] [EOL] [EOL] def test_backtesting_init_no_ticker_interval ( mocker , default_conf , caplog ) : [EOL] [docstring] [EOL] patch_exchange ( mocker ) [EOL] del default_conf [ [string] ] [EOL] default_conf [ [string] ] = [ [string] , [string] ] [EOL] [EOL] mocker . patch ( [string] , MagicMock ( return_value = [number] ) ) [EOL] with pytest . raises ( OperationalException ) : [EOL] Backtesting ( default_conf ) [EOL] log_has ( [string] [string] , caplog ) [EOL] [EOL] [EOL] def test_tickerdata_to_dataframe_bt ( default_conf , mocker ) : [EOL] patch_exchange ( mocker ) [EOL] timerange = TimeRange ( None , [string] , [number] , - [number] ) [EOL] tick = history . load_tickerdata_file ( None , [string] , [string] , timerange = timerange ) [EOL] tickerlist = { [string] : parse_ticker_dataframe ( tick , [string] , pair = [string] , fill_missing = True ) } [EOL] [EOL] backtesting = Backtesting ( default_conf ) [EOL] data = backtesting . strategy . tickerdata_to_dataframe ( tickerlist ) [EOL] assert len ( data [ [string] ] ) == [number] [EOL] [EOL] [comment] [EOL] strategy = DefaultStrategy ( default_conf ) [EOL] data2 = strategy . tickerdata_to_dataframe ( tickerlist ) [EOL] assert data [ [string] ] . equals ( data2 [ [string] ] ) [EOL] [EOL] [EOL] def test_generate_text_table ( default_conf , mocker ) : [EOL] patch_exchange ( mocker ) [EOL] default_conf [ [string] ] = [number] [EOL] backtesting = Backtesting ( default_conf ) [EOL] [EOL] results = pd . DataFrame ( { [string] : [ [string] , [string] ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] } ) [EOL] [EOL] result_str = ( [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] assert backtesting . _generate_text_table ( data = { [string] : { } } , results = results ) == result_str [EOL] [EOL] [EOL] def test_generate_text_table_sell_reason ( default_conf , mocker ) : [EOL] patch_exchange ( mocker ) [EOL] backtesting = Backtesting ( default_conf ) [EOL] [EOL] results = pd . DataFrame ( { [string] : [ [string] , [string] , [string] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ SellType . ROI , SellType . ROI , SellType . STOP_LOSS ] } ) [EOL] [EOL] result_str = ( [string] [string] [string] [string] ) [EOL] assert backtesting . _generate_text_table_sell_reason ( data = { [string] : { } } , results = results ) == result_str [EOL] [EOL] [EOL] def test_generate_text_table_strategyn ( default_conf , mocker ) : [EOL] [docstring] [EOL] patch_exchange ( mocker ) [EOL] default_conf [ [string] ] = [number] [EOL] backtesting = Backtesting ( default_conf ) [EOL] results = { } [EOL] results [ [string] ] = pd . DataFrame ( { [string] : [ [string] , [string] , [string] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ SellType . ROI , SellType . ROI , SellType . STOP_LOSS ] } ) [EOL] results [ [string] ] = pd . DataFrame ( { [string] : [ [string] , [string] , [string] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ SellType . ROI , SellType . ROI , SellType . STOP_LOSS ] } ) [EOL] [EOL] result_str = ( [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] print ( backtesting . _generate_text_table_strategy ( all_results = results ) ) [EOL] assert backtesting . _generate_text_table_strategy ( all_results = results ) == result_str [EOL] [EOL] [EOL] def test_backtesting_start ( default_conf , mocker , caplog ) : [EOL] def get_timeframe ( input1 ) : [EOL] return Arrow ( [number] , [number] , [number] , [number] , [number] ) , Arrow ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] mocker . patch ( [string] , mocked_load_data ) [EOL] mocker . patch ( [string] , get_timeframe ) [EOL] mocker . patch ( [string] , MagicMock ( ) ) [EOL] patch_exchange ( mocker ) [EOL] mocker . patch . multiple ( [string] , backtest = MagicMock ( ) , _generate_text_table = MagicMock ( return_value = [string] ) , ) [EOL] [EOL] default_conf [ [string] ] [ [string] ] = [ [string] ] [EOL] default_conf [ [string] ] = [string] [EOL] default_conf [ [string] ] = None [EOL] default_conf [ [string] ] = None [EOL] default_conf [ [string] ] = [string] [EOL] [EOL] backtesting = Backtesting ( default_conf ) [EOL] backtesting . start ( ) [EOL] [comment] [EOL] exists = [ [string] , [string] , [string] [string] ] [EOL] for line in exists : [EOL] assert log_has ( line , caplog ) [EOL] [EOL] [EOL] def test_backtesting_start_no_data ( default_conf , mocker , caplog ) : [EOL] def get_timeframe ( input1 ) : [EOL] return Arrow ( [number] , [number] , [number] , [number] , [number] ) , Arrow ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] mocker . patch ( [string] , MagicMock ( return_value = { } ) ) [EOL] mocker . patch ( [string] , get_timeframe ) [EOL] mocker . patch ( [string] , MagicMock ( ) ) [EOL] patch_exchange ( mocker ) [EOL] mocker . patch . multiple ( [string] , backtest = MagicMock ( ) , _generate_text_table = MagicMock ( return_value = [string] ) , ) [EOL] [EOL] default_conf [ [string] ] [ [string] ] = [ [string] ] [EOL] default_conf [ [string] ] = [string] [EOL] default_conf [ [string] ] = None [EOL] default_conf [ [string] ] = None [EOL] default_conf [ [string] ] = [string] [EOL] [EOL] backtesting = Backtesting ( default_conf ) [EOL] backtesting . start ( ) [EOL] [comment] [EOL] [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] [EOL] def test_backtest ( default_conf , fee , mocker ) : [EOL] mocker . patch ( [string] , fee ) [EOL] patch_exchange ( mocker ) [EOL] backtesting = Backtesting ( default_conf ) [EOL] pair = [string] [EOL] timerange = TimeRange ( None , [string] , [number] , - [number] ) [EOL] data = history . load_data ( datadir = None , ticker_interval = [string] , pairs = [ [string] ] , timerange = timerange ) [EOL] data_processed = backtesting . strategy . tickerdata_to_dataframe ( data ) [EOL] min_date , max_date = get_timeframe ( data_processed ) [EOL] results = backtesting . backtest ( { [string] : default_conf [ [string] ] , [string] : data_processed , [string] : [number] , [string] : False , [string] : min_date , [string] : max_date , } ) [EOL] assert not results . empty [EOL] assert len ( results ) == [number] [EOL] [EOL] expected = pd . DataFrame ( { [string] : [ pair , pair ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : pd . to_datetime ( [ Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime , Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime ] , utc = True ) , [string] : pd . to_datetime ( [ Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime , Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime ] , utc = True ) , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ False , False ] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] , [string] : [ SellType . ROI , SellType . ROI ] } ) [EOL] pd . testing . assert_frame_equal ( results , expected ) [EOL] data_pair = data_processed [ pair ] [EOL] for _ , t in results . iterrows ( ) : [EOL] ln = data_pair . loc [ data_pair [ [string] ] == t [ [string] ] ] [EOL] [comment] [EOL] assert ln is not None [EOL] assert round ( ln . iloc [ [number] ] [ [string] ] , [number] ) == round ( t [ [string] ] , [number] ) [EOL] [comment] [EOL] ln = data_pair . loc [ data_pair [ [string] ] == t [ [string] ] ] [EOL] assert ( round ( ln . iloc [ [number] ] [ [string] ] , [number] ) == round ( t [ [string] ] , [number] ) or round ( ln . iloc [ [number] ] [ [string] ] , [number] ) < round ( t [ [string] ] , [number] ) < round ( ln . iloc [ [number] ] [ [string] ] , [number] ) ) [EOL] [EOL] [EOL] def test_backtest_1min_ticker_interval ( default_conf , fee , mocker ) : [EOL] mocker . patch ( [string] , fee ) [EOL] patch_exchange ( mocker ) [EOL] backtesting = Backtesting ( default_conf ) [EOL] [EOL] [comment] [EOL] timerange = TimeRange ( None , [string] , [number] , - [number] ) [EOL] data = history . load_data ( datadir = None , ticker_interval = [string] , pairs = [ [string] ] , timerange = timerange ) [EOL] processed = backtesting . strategy . tickerdata_to_dataframe ( data ) [EOL] min_date , max_date = get_timeframe ( processed ) [EOL] results = backtesting . backtest ( { [string] : default_conf [ [string] ] , [string] : processed , [string] : [number] , [string] : False , [string] : min_date , [string] : max_date , } ) [EOL] assert not results . empty [EOL] assert len ( results ) == [number] [EOL] [EOL] [EOL] def test_processed ( default_conf , mocker ) : [EOL] patch_exchange ( mocker ) [EOL] backtesting = Backtesting ( default_conf ) [EOL] [EOL] dict_of_tickerrows = load_data_test ( [string] ) [EOL] dataframes = backtesting . strategy . tickerdata_to_dataframe ( dict_of_tickerrows ) [EOL] dataframe = dataframes [ [string] ] [EOL] cols = dataframe . columns [EOL] [comment] [EOL] for col in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] assert col in cols [EOL] [EOL] [EOL] def test_backtest_pricecontours ( default_conf , fee , mocker ) : [EOL] [comment] [EOL] mocker . patch ( [string] , fee ) [EOL] tests = [ [ [string] , [number] ] , [ [string] , [number] ] , [ [string] , [number] ] ] [EOL] [comment] [EOL] default_conf [ [string] ] = { [string] : True } [EOL] [EOL] for [ contour , numres ] in tests : [EOL] simple_backtest ( default_conf , contour , numres , mocker ) [EOL] [EOL] [EOL] def test_backtest_clash_buy_sell ( mocker , default_conf ) : [EOL] [comment] [EOL] def fun ( dataframe = None , pair = None ) : [EOL] buy_value = [number] [EOL] sell_value = [number] [EOL] return _trend ( dataframe , buy_value , sell_value ) [EOL] [EOL] backtest_conf = _make_backtest_conf ( mocker , conf = default_conf ) [EOL] backtesting = Backtesting ( default_conf ) [EOL] backtesting . advise_buy = fun [comment] [EOL] backtesting . advise_sell = fun [comment] [EOL] results = backtesting . backtest ( backtest_conf ) [EOL] assert results . empty [EOL] [EOL] [EOL] def test_backtest_only_sell ( mocker , default_conf ) : [EOL] [comment] [EOL] def fun ( dataframe = None , pair = None ) : [EOL] buy_value = [number] [EOL] sell_value = [number] [EOL] return _trend ( dataframe , buy_value , sell_value ) [EOL] [EOL] backtest_conf = _make_backtest_conf ( mocker , conf = default_conf ) [EOL] backtesting = Backtesting ( default_conf ) [EOL] backtesting . advise_buy = fun [comment] [EOL] backtesting . advise_sell = fun [comment] [EOL] results = backtesting . backtest ( backtest_conf ) [EOL] assert results . empty [EOL] [EOL] [EOL] def test_backtest_alternate_buy_sell ( default_conf , fee , mocker ) : [EOL] mocker . patch ( [string] , fee ) [EOL] mocker . patch ( [string] , MagicMock ( ) ) [EOL] backtest_conf = _make_backtest_conf ( mocker , conf = default_conf , pair = [string] ) [EOL] [comment] [EOL] default_conf [ [string] ] = { [string] : True } [EOL] default_conf [ [string] ] = [string] [EOL] backtesting = Backtesting ( default_conf ) [EOL] backtesting . advise_buy = _trend_alternate [comment] [EOL] backtesting . advise_sell = _trend_alternate [comment] [EOL] results = backtesting . backtest ( backtest_conf ) [EOL] backtesting . _store_backtest_result ( [string] , results ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert len ( results ) == [number] [EOL] [comment] [EOL] assert len ( results . loc [ results . open_at_end ] ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_backtest_multi_pair ( default_conf , fee , mocker , tres , pair ) : [EOL] [EOL] def _trend_alternate_hold ( dataframe = None , metadata = None ) : [EOL] [docstring] [EOL] if metadata [ [string] ] in ( [string] , [string] ) : [EOL] multi = [number] [EOL] else : [EOL] multi = [number] [EOL] dataframe [ [string] ] = np . where ( dataframe . index % multi == [number] , [number] , [number] ) [EOL] dataframe [ [string] ] = np . where ( ( dataframe . index + multi - [number] ) % multi == [number] , [number] , [number] ) [EOL] return dataframe [EOL] [EOL] mocker . patch ( [string] , fee ) [EOL] patch_exchange ( mocker ) [EOL] [EOL] pairs = [ [string] , [string] , [string] , [string] , [string] ] [EOL] data = history . load_data ( datadir = None , ticker_interval = [string] , pairs = pairs ) [EOL] [comment] [EOL] data = trim_dictlist ( data , - [number] ) [EOL] [EOL] [comment] [EOL] data [ pair ] = data [ pair ] [ tres : ] . reset_index ( ) [EOL] [comment] [EOL] default_conf [ [string] ] = { [string] : True } [EOL] default_conf [ [string] ] = [string] [EOL] [EOL] backtesting = Backtesting ( default_conf ) [EOL] backtesting . advise_buy = _trend_alternate_hold [comment] [EOL] backtesting . advise_sell = _trend_alternate_hold [comment] [EOL] [EOL] data_processed = backtesting . strategy . tickerdata_to_dataframe ( data ) [EOL] min_date , max_date = get_timeframe ( data_processed ) [EOL] backtest_conf = { [string] : default_conf [ [string] ] , [string] : data_processed , [string] : [number] , [string] : False , [string] : min_date , [string] : max_date , } [EOL] [EOL] results = backtesting . backtest ( backtest_conf ) [EOL] [EOL] [comment] [EOL] assert len ( evaluate_result_multi ( results , [string] , [number] ) ) > [number] [EOL] [comment] [EOL] assert len ( evaluate_result_multi ( results , [string] , [number] ) ) == [number] [EOL] [EOL] backtest_conf = { [string] : default_conf [ [string] ] , [string] : data_processed , [string] : [number] , [string] : False , [string] : min_date , [string] : max_date , } [EOL] results = backtesting . backtest ( backtest_conf ) [EOL] assert len ( evaluate_result_multi ( results , [string] , [number] ) ) == [number] [EOL] [EOL] [EOL] def test_backtest_record ( default_conf , fee , mocker ) : [EOL] names = [ ] [EOL] records = [ ] [EOL] patch_exchange ( mocker ) [EOL] mocker . patch ( [string] , fee ) [EOL] mocker . patch ( [string] , new = lambda n , r : ( names . append ( n ) , records . append ( r ) ) ) [EOL] [EOL] backtesting = Backtesting ( default_conf ) [EOL] results = pd . DataFrame ( { [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime , Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime , Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime , Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime ] , [string] : [ Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime , Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime , Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime , Arrow ( [number] , [number] , [number] , [number] , [number] , [number] ) . datetime ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ False , False , False , True ] , [string] : [ SellType . ROI , SellType . STOP_LOSS , SellType . ROI , SellType . FORCE_SELL ] } ) [EOL] backtesting . _store_backtest_result ( [string] , results ) [EOL] assert len ( results ) == [number] [EOL] [comment] [EOL] assert names == [ [string] ] [EOL] records = records [ [number] ] [EOL] [comment] [EOL] assert len ( records ) == [number] [EOL] [EOL] [comment] [EOL] names = [ ] [EOL] records = [ ] [EOL] backtesting . _store_backtest_result ( Path ( [string] ) , results , [string] ) [EOL] assert len ( results ) == [number] [EOL] [comment] [EOL] assert names == [ Path ( [string] ) ] [EOL] records = records [ [number] ] [EOL] [comment] [EOL] assert len ( records ) == [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] oix = None [EOL] for ( pair , profit , date_buy , date_sell , buy_index , dur , openr , closer , open_at_end , sell_reason ) in records : [EOL] assert pair == [string] [EOL] assert isinstance ( profit , float ) [EOL] [comment] [EOL] assert isinstance ( date_buy , float ) [EOL] assert isinstance ( date_sell , float ) [EOL] assert isinstance ( openr , float ) [EOL] assert isinstance ( closer , float ) [EOL] assert isinstance ( open_at_end , bool ) [EOL] assert isinstance ( sell_reason , str ) [EOL] isinstance ( buy_index , pd . _libs . tslib . Timestamp ) [EOL] if oix : [EOL] assert buy_index > oix [EOL] oix = buy_index [EOL] assert dur > [number] [EOL] [EOL] [EOL] def test_backtest_start_timerange ( default_conf , mocker , caplog ) : [EOL] default_conf [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] async def load_pairs ( pair , timeframe , since ) : [EOL] return _load_pair_as_ticks ( pair , timeframe ) [EOL] [EOL] api_mock = MagicMock ( ) [EOL] api_mock . fetch_ohlcv = load_pairs [EOL] [EOL] patch_exchange ( mocker , api_mock ) [EOL] mocker . patch ( [string] , MagicMock ( ) ) [EOL] mocker . patch ( [string] , MagicMock ( ) ) [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] args = get_args ( args ) [EOL] start_backtesting ( args ) [EOL] [comment] [EOL] exists = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] [string] , [string] ] [EOL] [EOL] for line in exists : [EOL] assert log_has ( line , caplog ) [EOL] [EOL] [EOL] def test_backtest_start_multi_strat ( default_conf , mocker , caplog ) : [EOL] default_conf [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] async def load_pairs ( pair , timeframe , since ) : [EOL] return _load_pair_as_ticks ( pair , timeframe ) [EOL] api_mock = MagicMock ( ) [EOL] api_mock . fetch_ohlcv = load_pairs [EOL] [EOL] patch_exchange ( mocker , api_mock ) [EOL] backtestmock = MagicMock ( ) [EOL] mocker . patch ( [string] , backtestmock ) [EOL] gen_table_mock = MagicMock ( ) [EOL] mocker . patch ( [string] , gen_table_mock ) [EOL] gen_strattable_mock = MagicMock ( ) [EOL] mocker . patch ( [string] , gen_strattable_mock ) [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] args = get_args ( args ) [EOL] start_backtesting ( args ) [EOL] [comment] [EOL] assert backtestmock . call_count == [number] [EOL] assert gen_table_mock . call_count == [number] [EOL] assert gen_strattable_mock . call_count == [number] [EOL] [EOL] [comment] [EOL] exists = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] [string] , [string] , [string] , [string] , ] [EOL] [EOL] for line in exists : [EOL] assert log_has ( line , caplog ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Dict , List , Union , Any , Tuple , Type [EOL] import unittest [EOL] import freqtrade [EOL] import typing [EOL] import os [EOL] from datetime import datetime [EOL] from unittest . mock import MagicMock , PropertyMock [EOL] [EOL] import pandas as pd [EOL] import pytest [EOL] from arrow import Arrow [EOL] from filelock import Timeout [EOL] from pathlib import Path [EOL] [EOL] from freqtrade import DependencyException , OperationalException [EOL] from freqtrade . data . converter import parse_ticker_dataframe [EOL] from freqtrade . data . history import load_tickerdata_file [EOL] from freqtrade . optimize import setup_configuration , start_hyperopt [EOL] from freqtrade . optimize . default_hyperopt import DefaultHyperOpts [EOL] from freqtrade . optimize . default_hyperopt_loss import DefaultHyperOptLoss [EOL] from freqtrade . optimize . hyperopt import Hyperopt [EOL] from freqtrade . resolvers . hyperopt_resolver import HyperOptResolver , HyperOptLossResolver [EOL] from freqtrade . state import RunMode [EOL] from freqtrade . strategy . interface import SellType [EOL] from freqtrade . tests . conftest import ( get_args , log_has , log_has_re , patch_exchange , patched_configuration_load_config_file ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def hyperopt ( default_conf , mocker ) : [EOL] default_conf . update ( { [string] : [ [string] ] } ) [EOL] patch_exchange ( mocker ) [EOL] return Hyperopt ( default_conf ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def hyperopt_results ( ) : [EOL] return pd . DataFrame ( { [string] : [ [string] , [string] , [string] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ SellType . ROI , SellType . ROI , SellType . STOP_LOSS ] } ) [EOL] [EOL] [EOL] [comment] [EOL] def create_trials ( mocker , hyperopt ) : [EOL] [docstring] [EOL] hyperopt . trials_file = Path ( [string] ) [EOL] [EOL] mocker . patch . object ( Path , [string] , MagicMock ( return_value = False ) ) [EOL] stat_mock = MagicMock ( ) [EOL] stat_mock . st_size = PropertyMock ( return_value = [number] ) [EOL] mocker . patch . object ( Path , [string] , MagicMock ( return_value = False ) ) [EOL] [EOL] mocker . patch . object ( Path , [string] , MagicMock ( return_value = True ) ) [EOL] mocker . patch ( [string] , return_value = None ) [EOL] [EOL] return [ { [string] : [number] , [string] : [string] , [string] : { } } ] [EOL] [EOL] [EOL] def test_setup_hyperopt_configuration_without_arguments ( mocker , default_conf , caplog ) : [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] [EOL] args = [ [string] , [string] , [string] ] [EOL] [EOL] config = setup_configuration ( get_args ( args ) , RunMode . HYPEROPT ) [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [ [string] ] [EOL] assert [string] in config [EOL] assert log_has ( [string] . format ( config [ [string] ] ) , caplog ) [EOL] assert [string] in config [EOL] assert not log_has_re ( [string] , caplog ) [EOL] [EOL] assert [string] not in config [EOL] assert not log_has ( [string] , caplog ) [EOL] [EOL] assert [string] not in config [EOL] assert not log_has ( [string] , caplog ) [EOL] [EOL] assert [string] not in config [EOL] assert [string] in config [EOL] assert config [ [string] ] == RunMode . HYPEROPT [EOL] [EOL] [EOL] @ pytest . mark . filterwarnings ( [string] ) def test_setup_hyperopt_configuration_with_arguments ( mocker , default_conf , caplog ) : [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] mocker . patch ( [string] , lambda c , x : x ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] config = setup_configuration ( get_args ( args ) , RunMode . HYPEROPT ) [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [EOL] assert [string] in config [ [string] ] [EOL] assert [string] in config [EOL] assert config [ [string] ] == RunMode . HYPEROPT [EOL] [EOL] assert log_has ( [string] . format ( config [ [string] ] ) , caplog ) [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] . format ( config [ [string] ] ) , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] assert [string] in config [EOL] assert log_has ( [string] . format ( config [ [string] ] ) , caplog ) [EOL] assert [string] in config [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] [EOL] def test_hyperoptresolver ( mocker , default_conf , caplog ) : [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] [EOL] hyperopts = DefaultHyperOpts [EOL] delattr ( hyperopts , [string] ) [EOL] delattr ( hyperopts , [string] ) [EOL] mocker . patch ( [string] , MagicMock ( return_value = hyperopts ) ) [EOL] x = HyperOptResolver ( default_conf , ) . hyperopt [EOL] assert not hasattr ( x , [string] ) [EOL] assert not hasattr ( x , [string] ) [EOL] assert log_has ( [string] [string] , caplog ) [EOL] assert log_has ( [string] [string] , caplog ) [EOL] assert hasattr ( x , [string] ) [EOL] [EOL] [EOL] def test_hyperoptresolver_wrongname ( mocker , default_conf , caplog ) : [EOL] default_conf . update ( { [string] : [string] } ) [EOL] [EOL] with pytest . raises ( OperationalException , match = [string] ) : [EOL] HyperOptResolver ( default_conf , ) . hyperopt [EOL] [EOL] [EOL] def test_hyperoptlossresolver ( mocker , default_conf , caplog ) : [EOL] [EOL] hl = DefaultHyperOptLoss [EOL] mocker . patch ( [string] , MagicMock ( return_value = hl ) ) [EOL] x = HyperOptLossResolver ( default_conf , ) . hyperoptloss [EOL] assert hasattr ( x , [string] ) [EOL] [EOL] [EOL] def test_hyperoptlossresolver_wrongname ( mocker , default_conf , caplog ) : [EOL] default_conf . update ( { [string] : [string] } ) [EOL] [EOL] with pytest . raises ( OperationalException , match = [string] ) : [EOL] HyperOptLossResolver ( default_conf , ) . hyperopt [EOL] [EOL] [EOL] def test_start ( mocker , default_conf , caplog ) : [EOL] start_mock = MagicMock ( ) [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] mocker . patch ( [string] , start_mock ) [EOL] patch_exchange ( mocker ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] ] [EOL] args = get_args ( args ) [EOL] start_hyperopt ( args ) [EOL] [EOL] import pprint [EOL] pprint . pprint ( caplog . record_tuples ) [EOL] [EOL] assert log_has ( [string] , caplog ) [EOL] assert start_mock . call_count == [number] [EOL] [EOL] [EOL] def test_start_no_data ( mocker , default_conf , caplog ) : [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] mocker . patch ( [string] , MagicMock ( return_value = { } ) ) [EOL] mocker . patch ( [string] , MagicMock ( return_value = ( datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) ) ) [EOL] [EOL] patch_exchange ( mocker ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] ] [EOL] args = get_args ( args ) [EOL] start_hyperopt ( args ) [EOL] [EOL] import pprint [EOL] pprint . pprint ( caplog . record_tuples ) [EOL] [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] [EOL] def test_start_failure ( mocker , default_conf , caplog ) : [EOL] start_mock = MagicMock ( ) [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] mocker . patch ( [string] , start_mock ) [EOL] patch_exchange ( mocker ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] args = get_args ( args ) [EOL] with pytest . raises ( DependencyException ) : [EOL] start_hyperopt ( args ) [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] [EOL] def test_start_filelock ( mocker , default_conf , caplog ) : [EOL] start_mock = MagicMock ( side_effect = Timeout ( Hyperopt . get_lock_filename ( default_conf ) ) ) [EOL] patched_configuration_load_config_file ( mocker , default_conf ) [EOL] mocker . patch ( [string] , start_mock ) [EOL] patch_exchange ( mocker ) [EOL] [EOL] args = [ [string] , [string] , [string] , [string] , [string] ] [EOL] args = get_args ( args ) [EOL] start_hyperopt ( args ) [EOL] assert log_has ( [string] , caplog ) [EOL] [EOL] [EOL] def test_loss_calculation_prefer_correct_trade_count ( default_conf , hyperopt_results ) : [EOL] hl = HyperOptLossResolver ( default_conf ) . hyperoptloss [EOL] correct = hl . hyperopt_loss_function ( hyperopt_results , [number] ) [EOL] over = hl . hyperopt_loss_function ( hyperopt_results , [number] + [number] ) [EOL] under = hl . hyperopt_loss_function ( hyperopt_results , [number] - [number] ) [EOL] assert over > correct [EOL] assert under > correct [EOL] [EOL] [EOL] def test_loss_calculation_prefer_shorter_trades ( default_conf , hyperopt_results ) : [EOL] resultsb = hyperopt_results . copy ( ) [EOL] resultsb . loc [ [number] , [string] ] = [number] [EOL] [EOL] hl = HyperOptLossResolver ( default_conf ) . hyperoptloss [EOL] longer = hl . hyperopt_loss_function ( hyperopt_results , [number] ) [EOL] shorter = hl . hyperopt_loss_function ( resultsb , [number] ) [EOL] assert shorter < longer [EOL] [EOL] [EOL] def test_loss_calculation_has_limited_profit ( default_conf , hyperopt_results ) : [EOL] results_over = hyperopt_results . copy ( ) [EOL] results_over [ [string] ] = hyperopt_results [ [string] ] * [number] [EOL] results_under = hyperopt_results . copy ( ) [EOL] results_under [ [string] ] = hyperopt_results [ [string] ] / [number] [EOL] [EOL] hl = HyperOptLossResolver ( default_conf ) . hyperoptloss [EOL] correct = hl . hyperopt_loss_function ( hyperopt_results , [number] ) [EOL] over = hl . hyperopt_loss_function ( results_over , [number] ) [EOL] under = hl . hyperopt_loss_function ( results_under , [number] ) [EOL] assert over < correct [EOL] assert under > correct [EOL] [EOL] [EOL] def test_sharpe_loss_prefers_higher_profits ( default_conf , hyperopt_results ) : [EOL] results_over = hyperopt_results . copy ( ) [EOL] results_over [ [string] ] = hyperopt_results [ [string] ] * [number] [EOL] results_under = hyperopt_results . copy ( ) [EOL] results_under [ [string] ] = hyperopt_results [ [string] ] / [number] [EOL] [EOL] default_conf . update ( { [string] : [string] } ) [EOL] hl = HyperOptLossResolver ( default_conf ) . hyperoptloss [EOL] correct = hl . hyperopt_loss_function ( hyperopt_results , len ( hyperopt_results ) , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) [EOL] over = hl . hyperopt_loss_function ( results_over , len ( hyperopt_results ) , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) [EOL] under = hl . hyperopt_loss_function ( results_under , len ( hyperopt_results ) , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) [EOL] assert over < correct [EOL] assert under > correct [EOL] [EOL] [EOL] def test_onlyprofit_loss_prefers_higher_profits ( default_conf , hyperopt_results ) : [EOL] results_over = hyperopt_results . copy ( ) [EOL] results_over [ [string] ] = hyperopt_results [ [string] ] * [number] [EOL] results_under = hyperopt_results . copy ( ) [EOL] results_under [ [string] ] = hyperopt_results [ [string] ] / [number] [EOL] [EOL] default_conf . update ( { [string] : [string] } ) [EOL] hl = HyperOptLossResolver ( default_conf ) . hyperoptloss [EOL] correct = hl . hyperopt_loss_function ( hyperopt_results , len ( hyperopt_results ) , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) [EOL] over = hl . hyperopt_loss_function ( results_over , len ( hyperopt_results ) , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) [EOL] under = hl . hyperopt_loss_function ( results_under , len ( hyperopt_results ) , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) [EOL] assert over < correct [EOL] assert under > correct [EOL] [EOL] [EOL] def test_log_results_if_loss_improves ( hyperopt , capsys ) : [EOL] hyperopt . current_best_loss = [number] [EOL] hyperopt . total_epochs = [number] [EOL] hyperopt . log_results ( { [string] : [number] , [string] : [number] , [string] : [string] , [string] : False } ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in out [EOL] [EOL] [EOL] def test_no_log_if_loss_does_not_improve ( hyperopt , caplog ) : [EOL] hyperopt . current_best_loss = [number] [EOL] hyperopt . log_results ( { [string] : [number] , } ) [EOL] assert caplog . record_tuples == [ ] [EOL] [EOL] [EOL] def test_save_trials_saves_trials ( mocker , hyperopt , caplog ) : [EOL] trials = create_trials ( mocker , hyperopt ) [EOL] mock_dump = mocker . patch ( [string] , return_value = None ) [EOL] hyperopt . trials = trials [EOL] hyperopt . save_trials ( ) [EOL] [EOL] trials_file = os . path . join ( [string] , [string] , [string] , [string] ) [EOL] assert log_has ( [string] . format ( trials_file ) , caplog ) [EOL] mock_dump . assert_called_once ( ) [EOL] [EOL] [EOL] def test_read_trials_returns_trials_file ( mocker , hyperopt , caplog ) : [EOL] trials = create_trials ( mocker , hyperopt ) [EOL] mock_load = mocker . patch ( [string] , return_value = trials ) [EOL] hyperopt_trial = hyperopt . read_trials ( ) [EOL] trials_file = os . path . join ( [string] , [string] , [string] , [string] ) [EOL] assert log_has ( [string] . format ( trials_file ) , caplog ) [EOL] assert hyperopt_trial == trials [EOL] mock_load . assert_called_once ( ) [EOL] [EOL] [EOL] def test_roi_table_generation ( hyperopt ) : [EOL] params = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] assert hyperopt . custom_hyperopt . generate_roi_table ( params ) == { [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] } [EOL] [EOL] [EOL] def test_start_calls_optimizer ( mocker , default_conf , caplog , capsys ) : [EOL] dumper = mocker . patch ( [string] , MagicMock ( ) ) [EOL] mocker . patch ( [string] , MagicMock ( ) ) [EOL] mocker . patch ( [string] , MagicMock ( return_value = ( datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) ) ) [EOL] [EOL] parallel = mocker . patch ( [string] , MagicMock ( return_value = [ { [string] : [number] , [string] : [string] , [string] : { [string] : { } , [string] : { } , [string] : { } , [string] : [number] } } ] ) ) [EOL] patch_exchange ( mocker ) [EOL] [EOL] default_conf . update ( { [string] : [string] , [string] : [number] , [string] : None , [string] : [string] , [string] : [number] , } ) [EOL] [EOL] hyperopt = Hyperopt ( default_conf ) [EOL] hyperopt . backtesting . strategy . tickerdata_to_dataframe = MagicMock ( ) [EOL] hyperopt . custom_hyperopt . generate_roi_table = MagicMock ( return_value = { } ) [EOL] [EOL] hyperopt . start ( ) [EOL] [EOL] parallel . assert_called_once ( ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in out [EOL] assert dumper . called [EOL] [comment] [EOL] assert dumper . call_count == [number] [EOL] assert hasattr ( hyperopt . backtesting , [string] ) [EOL] assert hasattr ( hyperopt . backtesting , [string] ) [EOL] assert hasattr ( hyperopt , [string] ) [EOL] assert hyperopt . max_open_trades == default_conf [ [string] ] [EOL] assert hasattr ( hyperopt , [string] ) [EOL] [EOL] [EOL] def test_format_results ( hyperopt ) : [EOL] [comment] [EOL] trades = [ ( [string] , [number] , [number] , [number] ) , ( [string] , [number] , [number] , [number] ) , ( [string] , - [number] , - [number] , - [number] ) ] [EOL] labels = [ [string] , [string] , [string] , [string] ] [EOL] df = pd . DataFrame . from_records ( trades , columns = labels ) [EOL] [EOL] result = hyperopt . format_results ( df ) [EOL] assert result . find ( [string] ) [EOL] assert result . find ( [string] ) [EOL] assert result . find ( [string] ) [EOL] [EOL] [comment] [EOL] trades = [ ( [string] , [number] , [number] , [number] ) , ( [string] , [number] , [number] , [number] ) , ( [string] , - [number] , - [number] , - [number] ) ] [EOL] df = pd . DataFrame . from_records ( trades , columns = labels ) [EOL] result = hyperopt . format_results ( df ) [EOL] assert result . find ( [string] ) [EOL] [EOL] [EOL] def test_has_space ( hyperopt ) : [EOL] hyperopt . config . update ( { [string] : [ [string] , [string] ] } ) [EOL] assert hyperopt . has_space ( [string] ) [EOL] assert hyperopt . has_space ( [string] ) [EOL] assert not hyperopt . has_space ( [string] ) [EOL] [EOL] hyperopt . config . update ( { [string] : [ [string] ] } ) [EOL] assert hyperopt . has_space ( [string] ) [EOL] [EOL] [EOL] def test_populate_indicators ( hyperopt ) : [EOL] tick = load_tickerdata_file ( None , [string] , [string] ) [EOL] tickerlist = { [string] : parse_ticker_dataframe ( tick , [string] , pair = [string] , fill_missing = True ) } [EOL] dataframes = hyperopt . backtesting . strategy . tickerdata_to_dataframe ( tickerlist ) [EOL] dataframe = hyperopt . custom_hyperopt . populate_indicators ( dataframes [ [string] ] , { [string] : [string] } ) [EOL] [EOL] [comment] [EOL] assert [string] in dataframe [EOL] assert [string] in dataframe [EOL] assert [string] in dataframe [EOL] [EOL] [EOL] def test_buy_strategy_generator ( hyperopt ) : [EOL] tick = load_tickerdata_file ( None , [string] , [string] ) [EOL] tickerlist = { [string] : parse_ticker_dataframe ( tick , [string] , pair = [string] , fill_missing = True ) } [EOL] dataframes = hyperopt . backtesting . strategy . tickerdata_to_dataframe ( tickerlist ) [EOL] dataframe = hyperopt . custom_hyperopt . populate_indicators ( dataframes [ [string] ] , { [string] : [string] } ) [EOL] [EOL] populate_buy_trend = hyperopt . custom_hyperopt . buy_strategy_generator ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : True , [string] : True , [string] : True , [string] : True , [string] : [string] } ) [EOL] result = populate_buy_trend ( dataframe , { [string] : [string] } ) [EOL] [comment] [EOL] assert [string] in result [EOL] assert [number] in result [ [string] ] [EOL] [EOL] [EOL] def test_generate_optimizer ( mocker , default_conf ) : [EOL] default_conf . update ( { [string] : [string] } ) [EOL] default_conf . update ( { [string] : None } ) [EOL] default_conf . update ( { [string] : [string] } ) [EOL] default_conf . update ( { [string] : [number] } ) [EOL] [EOL] trades = [ ( [string] , [number] , [number] , [number] ) ] [EOL] labels = [ [string] , [string] , [string] , [string] ] [EOL] backtest_result = pd . DataFrame . from_records ( trades , columns = labels ) [EOL] [EOL] mocker . patch ( [string] , MagicMock ( return_value = backtest_result ) ) [EOL] mocker . patch ( [string] , MagicMock ( return_value = ( Arrow ( [number] , [number] , [number] ) , Arrow ( [number] , [number] , [number] ) ) ) ) [EOL] patch_exchange ( mocker ) [EOL] mocker . patch ( [string] , MagicMock ( ) ) [EOL] [EOL] optimizer_param = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : False , [string] : True , [string] : False , [string] : False , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : False , [string] : True , [string] : False , [string] : False , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : - [number] , } [EOL] response_expected = { [string] : [number] , [string] : [string] [string] , [string] : optimizer_param , [string] : [number] } [EOL] [EOL] hyperopt = Hyperopt ( default_conf ) [EOL] generate_optimizer_value = hyperopt . generate_optimizer ( list ( optimizer_param . values ( ) ) ) [EOL] assert generate_optimizer_value == response_expected [EOL] [EOL] [EOL] def test_clean_hyperopt ( mocker , default_conf , caplog ) : [EOL] patch_exchange ( mocker ) [EOL] default_conf . update ( { [string] : [string] , [string] : [number] , [string] : None , [string] : [string] , [string] : [number] , } ) [EOL] mocker . patch ( [string] , MagicMock ( return_value = True ) ) [EOL] unlinkmock = mocker . patch ( [string] , MagicMock ( ) ) [EOL] h = Hyperopt ( default_conf ) [EOL] [EOL] assert unlinkmock . call_count == [number] [EOL] assert log_has ( f" [string] { h . tickerdata_pickle } [string] " , caplog ) [EOL] [EOL] [EOL] def test_continue_hyperopt ( mocker , default_conf , caplog ) : [EOL] patch_exchange ( mocker ) [EOL] default_conf . update ( { [string] : [string] , [string] : [number] , [string] : None , [string] : [string] , [string] : [number] , [string] : True } ) [EOL] mocker . patch ( [string] , MagicMock ( return_value = True ) ) [EOL] unlinkmock = mocker . patch ( [string] , MagicMock ( ) ) [EOL] Hyperopt ( default_conf ) [EOL] [EOL] assert unlinkmock . call_count == [number] [EOL] assert log_has ( f" [string] " , caplog ) [EOL] [EOL] [EOL] def test_print_json_spaces_all ( mocker , default_conf , caplog , capsys ) : [EOL] dumper = mocker . patch ( [string] , MagicMock ( ) ) [EOL] mocker . patch ( [string] , MagicMock ( ) ) [EOL] mocker . patch ( [string] , MagicMock ( return_value = ( datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) ) ) [EOL] [EOL] parallel = mocker . patch ( [string] , MagicMock ( return_value = [ { [string] : [number] , [string] : [string] , [string] : { } } ] ) ) [EOL] patch_exchange ( mocker ) [EOL] [EOL] default_conf . update ( { [string] : [string] , [string] : [number] , [string] : None , [string] : [string] , [string] : [number] , [string] : True , } ) [EOL] [EOL] hyperopt = Hyperopt ( default_conf ) [EOL] hyperopt . backtesting . strategy . tickerdata_to_dataframe = MagicMock ( ) [EOL] hyperopt . custom_hyperopt . generate_roi_table = MagicMock ( return_value = { } ) [EOL] [EOL] hyperopt . start ( ) [EOL] [EOL] parallel . assert_called_once ( ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in out [comment] [EOL] assert dumper . called [EOL] [comment] [EOL] assert dumper . call_count == [number] [EOL] [EOL] [EOL] def test_print_json_spaces_roi_stoploss ( mocker , default_conf , caplog , capsys ) : [EOL] dumper = mocker . patch ( [string] , MagicMock ( ) ) [EOL] mocker . patch ( [string] , MagicMock ( ) ) [EOL] mocker . patch ( [string] , MagicMock ( return_value = ( datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ) ) ) [EOL] [EOL] parallel = mocker . patch ( [string] , MagicMock ( return_value = [ { [string] : [number] , [string] : [string] , [string] : { } } ] ) ) [EOL] patch_exchange ( mocker ) [EOL] [EOL] default_conf . update ( { [string] : [string] , [string] : [number] , [string] : None , [string] : [string] , [string] : [number] , [string] : True , } ) [EOL] [EOL] hyperopt = Hyperopt ( default_conf ) [EOL] hyperopt . backtesting . strategy . tickerdata_to_dataframe = MagicMock ( ) [EOL] hyperopt . custom_hyperopt . generate_roi_table = MagicMock ( return_value = { } ) [EOL] [EOL] hyperopt . start ( ) [EOL] [EOL] parallel . assert_called_once ( ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in out [EOL] assert dumper . called [EOL] [comment] [EOL] assert dumper . call_count == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] [comment] [EOL] import builtins [EOL] from typing import Dict , Type , Any [EOL] import freqtrade [EOL] import pandas [EOL] import typing [EOL] from freqtrade . strategy . interface import IStrategy [EOL] from pandas import DataFrame [EOL] [comment] [EOL] [EOL] [comment] [EOL] import talib . abstract as ta [EOL] import freqtrade . vendor . qtpylib . indicators as qtpylib [EOL] import numpy [comment] [EOL] [EOL] [EOL] [comment] [EOL] class TestStrategyLegacy ( IStrategy ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] minimal_roi = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] [comment] [EOL] [comment] [EOL] stoploss = - [number] [EOL] [EOL] [comment] [EOL] ticker_interval = [string] [EOL] [EOL] def populate_indicators ( self , dataframe ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . ADX ( dataframe ) [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] bollinger = qtpylib . bollinger_bands ( qtpylib . typical_price ( dataframe ) , window = [number] , stds = [number] ) [EOL] dataframe [ [string] ] = bollinger [ [string] ] [EOL] dataframe [ [string] ] = bollinger [ [string] ] [EOL] dataframe [ [string] ] = bollinger [ [string] ] [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] dataframe [ [string] ] = ta . TEMA ( dataframe , timeperiod = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] hilbert = ta . HT_SINE ( dataframe ) [EOL] dataframe [ [string] ] = hilbert [ [string] ] [EOL] dataframe [ [string] ] = hilbert [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] return dataframe [EOL] [EOL] def populate_buy_trend ( self , dataframe ) : [EOL] [docstring] [EOL] dataframe . loc [ ( ( dataframe [ [string] ] > [number] ) & ( dataframe [ [string] ] <= dataframe [ [string] ] ) & ( dataframe [ [string] ] > dataframe [ [string] ] . shift ( [number] ) ) ) , [string] ] = [number] [EOL] [EOL] return dataframe [EOL] [EOL] def populate_sell_trend ( self , dataframe ) : [EOL] [docstring] [EOL] dataframe . loc [ ( ( dataframe [ [string] ] > [number] ) & ( dataframe [ [string] ] > dataframe [ [string] ] ) & ( dataframe [ [string] ] < dataframe [ [string] ] . shift ( [number] ) ) ) , [string] ] = [number] [EOL] return dataframe [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pandas.DataFrame$ 0
	0
from typing import Dict [EOL] import freqtrade [EOL] import typing [EOL] import json [EOL] [EOL] import pytest [EOL] from pandas import DataFrame [EOL] [EOL] from freqtrade . data . converter import parse_ticker_dataframe [EOL] from freqtrade . strategy . default_strategy import DefaultStrategy [EOL] [EOL] [EOL] @ pytest . fixture def result ( ) : [EOL] with open ( [string] ) as data_file : [EOL] return parse_ticker_dataframe ( json . load ( data_file ) , [string] , pair = [string] , fill_missing = True ) [EOL] [EOL] [EOL] def test_default_strategy_structure ( ) : [EOL] assert hasattr ( DefaultStrategy , [string] ) [EOL] assert hasattr ( DefaultStrategy , [string] ) [EOL] assert hasattr ( DefaultStrategy , [string] ) [EOL] assert hasattr ( DefaultStrategy , [string] ) [EOL] assert hasattr ( DefaultStrategy , [string] ) [EOL] assert hasattr ( DefaultStrategy , [string] ) [EOL] [EOL] [EOL] def test_default_strategy ( result ) : [EOL] strategy = DefaultStrategy ( { } ) [EOL] [EOL] metadata = { [string] : [string] } [EOL] assert type ( strategy . minimal_roi ) is dict [EOL] assert type ( strategy . stoploss ) is float [EOL] assert type ( strategy . ticker_interval ) is str [EOL] indicators = strategy . populate_indicators ( result , metadata ) [EOL] assert type ( indicators ) is DataFrame [EOL] assert type ( strategy . populate_buy_trend ( indicators , metadata ) ) is DataFrame [EOL] assert type ( strategy . populate_sell_trend ( indicators , metadata ) ) is DataFrame [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0