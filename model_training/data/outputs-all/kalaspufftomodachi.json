from typing import List , Any , Dict [EOL] import proto_build [EOL] import typing [EOL] import base64 [EOL] import json [EOL] import os [EOL] import signal [EOL] import time [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] from google . protobuf . json_format import MessageToJson [EOL] [EOL] from proto_build . message_pb2 import Person [EOL] from run_test_service_helper import start_service [EOL] from tomodachi . protocol . proto_build . protobuf . sns_sqs_message_pb2 import SNSSQSMessage [EOL] from tomodachi . validation . validation import RegexMissmatchException , validate_field_regex [EOL] [EOL] [EOL] def test_json_base ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] async def _async ( ) : [EOL] data = { [string] : [string] } [EOL] t1 = time . time ( ) [EOL] json_message = await instance . message_protocol . build_message ( instance , [string] , data ) [EOL] t2 = time . time ( ) [EOL] result , message_uuid , timestamp = await instance . message_protocol . parse_message ( json_message ) [EOL] assert result . get ( [string] ) == data [EOL] assert result . get ( [string] , { } ) . get ( [string] ) == [string] [EOL] assert len ( json . dumps ( result . get ( [string] ) ) ) == len ( json . dumps ( data ) ) [EOL] assert json . dumps ( result . get ( [string] ) ) == json . dumps ( data ) [EOL] assert len ( message_uuid ) == [number] [EOL] assert message_uuid [ [number] : [number] ] == instance . uuid [EOL] assert timestamp >= t1 [EOL] assert timestamp <= t2 [EOL] [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_json_base_large_message ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] async def _async ( ) : [EOL] data = [ [string] . format ( i ) for i in range ( [number] , [number] ) ] [EOL] assert len ( json . dumps ( data ) ) > [number] [EOL] t1 = time . time ( ) [EOL] json_message = await instance . message_protocol . build_message ( instance , [string] , data ) [EOL] assert len ( json . dumps ( json_message ) ) < [number] [EOL] t2 = time . time ( ) [EOL] result , message_uuid , timestamp = await instance . message_protocol . parse_message ( json_message ) [EOL] assert result . get ( [string] , { } ) . get ( [string] ) == [string] [EOL] assert len ( json . dumps ( result . get ( [string] ) ) ) == len ( json . dumps ( data ) ) [EOL] assert json . dumps ( result . get ( [string] ) ) == json . dumps ( data ) [EOL] assert len ( message_uuid ) == [number] [EOL] assert message_uuid [ [number] : [number] ] == instance . uuid [EOL] assert timestamp >= t1 [EOL] assert timestamp <= t2 [EOL] [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_protobuf_base ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] async def _async ( ) : [EOL] data = Person ( ) [EOL] data . name = [string] [EOL] data . id = [string] [EOL] t1 = time . time ( ) [EOL] protobuf_message = await instance . message_protocol . build_message ( instance , [string] , data ) [EOL] t2 = time . time ( ) [EOL] result , message_uuid , timestamp = await instance . message_protocol . parse_message ( protobuf_message , Person ) [EOL] assert type ( result . get ( [string] ) ) is Person [EOL] assert result . get ( [string] ) == data [EOL] assert result . get ( [string] , { } ) . get ( [string] ) == [string] [EOL] assert result . get ( [string] ) == data [EOL] assert result . get ( [string] ) . name == data . name [EOL] assert result . get ( [string] ) . id == data . id [EOL] assert len ( MessageToJson ( result . get ( [string] ) ) ) == len ( MessageToJson ( data ) ) [EOL] assert MessageToJson ( result . get ( [string] ) ) == MessageToJson ( data ) [EOL] assert len ( message_uuid ) == [number] [EOL] assert message_uuid [ [number] : [number] ] == instance . uuid [EOL] assert timestamp >= t1 [EOL] assert timestamp <= t2 [EOL] [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_protobuf_base_no_proto_class ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] async def _async ( ) : [EOL] data = Person ( ) [EOL] data . name = [string] [EOL] data . id = [string] [EOL] protobuf_message = await instance . message_protocol . build_message ( instance , [string] , data ) [EOL] result , message_uuid , timestamp = await instance . message_protocol . parse_message ( protobuf_message ) [EOL] assert type ( result . get ( [string] ) ) is not Person [EOL] assert type ( result . get ( [string] ) ) is bytes [EOL] assert result . get ( [string] ) != data [EOL] assert result . get ( [string] ) == [string] [EOL] [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_protobuf_base_bad_proto_class ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] async def _async ( ) : [EOL] data = Person ( ) [EOL] data . name = [string] [EOL] data . id = [string] [EOL] json_message = await instance . message_protocol . build_message ( instance , [string] , data ) [EOL] await instance . message_protocol . parse_message ( json_message , str ) [EOL] [EOL] with pytest . raises ( AttributeError ) : [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_protobuf_validation_no_proto_class ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] async def _async ( ) : [EOL] instance . message_protocol . validate ( ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_protobuf_validation_bad_proto_class ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] async def _async ( ) : [EOL] instance . message_protocol . validate ( proto_class = str ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_protobuf_object_validation_function ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] def test_validator ( person ) : [EOL] validate_field_regex ( person . name , [string] ) [EOL] [EOL] async def _async ( ) : [EOL] data = Person ( ) [EOL] data . name = [string] [EOL] data . id = [string] [EOL] protobuf_message = await instance . message_protocol . build_message ( instance , [string] , data ) [EOL] await instance . message_protocol . parse_message ( protobuf_message , Person , test_validator ) [EOL] [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_protobuf_object_static_validation_function ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] def test_static_validator ( person ) : [EOL] validate_field_regex ( person . name , [string] ) [EOL] [EOL] async def _async ( ) : [EOL] data = Person ( ) [EOL] data . name = [string] [EOL] data . id = [string] [EOL] protobuf_message = await instance . message_protocol . build_message ( instance , [string] , data ) [EOL] [EOL] await instance . message_protocol . parse_message ( protobuf_message , Person , test_static_validator ) [EOL] [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_protobuf_object_validation_function_fail ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] def test_validator ( person ) : [EOL] validate_field_regex ( person . name , [string] ) [EOL] [EOL] async def _async ( ) : [EOL] data = Person ( ) [EOL] data . name = [string] [EOL] data . id = [string] [EOL] protobuf_message = await instance . message_protocol . build_message ( instance , [string] , data ) [EOL] await instance . message_protocol . parse_message ( protobuf_message , Person , test_validator ) [EOL] [EOL] with pytest . raises ( RegexMissmatchException ) : [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_protobuf_object_static_validation_function_fail ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] def test_static_validator ( person ) : [EOL] validate_field_regex ( person . name , [string] ) [EOL] [EOL] async def _async ( ) : [EOL] data = Person ( ) [EOL] data . name = [string] [EOL] data . id = [string] [EOL] protobuf_message = await instance . message_protocol . build_message ( instance , [string] , data ) [EOL] [EOL] await instance . message_protocol . parse_message ( protobuf_message , Person , test_static_validator ) [EOL] [EOL] with pytest . raises ( RegexMissmatchException ) : [EOL] loop . run_until_complete ( _async ( ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Optional , Union , Any , Dict [EOL] import decimal [EOL] import typing [EOL] from decimal import Decimal [EOL] [EOL] from tomodachi . config import merge_dicts , parse_config_files [EOL] [EOL] [EOL] def test_merge_dicts ( ) : [EOL] dict1 = { [string] : [ [number] , [number] , [number] ] , [string] : [string] , [string] : { [string] : True } , [string] : [number] } [EOL] [EOL] dict2 = { [string] : [ [number] , [number] ] , [string] : { [string] : Decimal ( [number] ) } , [string] : [number] } [EOL] [EOL] result = merge_dicts ( dict1 , dict2 ) [EOL] expected_result = { [string] : [ [number] , [number] , [number] , [number] , [number] ] , [string] : [string] , [string] : { [string] : True , [string] : Decimal ( [number] ) } , [string] : [number] } [EOL] assert result == expected_result [EOL] [EOL] [EOL] def test_parse_config_file ( ) : [EOL] result = parse_config_files ( [ [string] ] ) [EOL] expected_result = { [string] : { [string] : { [string] : [number] , [string] : True } } , [string] : [string] } [EOL] assert result == expected_result [EOL] [EOL] [EOL] def test_parse_no_config_file ( ) : [EOL] result = parse_config_files ( [ ] ) [EOL] assert result is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_exception_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] loop . run_until_complete ( future ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL] [EOL] [EOL] def test_exception_service_in_init ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] loop . run_until_complete ( future ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] from typing import Any [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_schedule_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] assert instance . uuid is not None [EOL] [EOL] async def _async ( loop ) : [EOL] seconds = instance . seconds_triggered [EOL] third_seconds_triggered = instance . third_seconds_triggered [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] assert instance . seconds_triggered > seconds [EOL] assert instance . third_seconds_triggered == third_seconds_triggered [EOL] [EOL] seconds = instance . seconds_triggered [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] assert instance . seconds_triggered > seconds [EOL] assert instance . third_seconds_triggered > third_seconds_triggered [EOL] [EOL] loop . run_until_complete ( _async ( loop ) ) [EOL] instance . stop_service ( ) [EOL] loop . run_until_complete ( future ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Type [EOL] import tomodachi [EOL] import typing [EOL] import asyncio [EOL] import os [EOL] import signal [EOL] [EOL] import tomodachi [EOL] from tomodachi . discovery . dummy_registry import DummyRegistry [EOL] from tomodachi . protocol . json_base import JsonBase [EOL] [EOL] [EOL] @ tomodachi . service class AutoClosingService ( tomodachi . Service ) : [EOL] name = [string] [EOL] discovery = [ DummyRegistry ] [EOL] message_protocol = JsonBase [EOL] [EOL] start = False [EOL] started = False [EOL] stop = False [EOL] [EOL] async def _start_service ( self ) : [EOL] self . log ( [string] ) [EOL] self . start = True [EOL] [EOL] async def _started_service ( self ) : [EOL] self . log ( [string] ) [EOL] self . started = True [EOL] await asyncio . sleep ( [number] ) [EOL] os . kill ( os . getpid ( ) , signal . SIGTERM ) [EOL] [EOL] async def _stop_service ( self ) : [EOL] self . log ( [string] ) [EOL] self . stop = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Type[tomodachi.discovery.dummy_registry.DummyRegistry]]$ 0 0 0 0 0 $typing.Type[tomodachi.protocol.json_base.JsonBase]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_invalid_filename ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( SystemExit ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL] [EOL] [EOL] def test_invalid_service ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( NameError ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL] [EOL] [EOL] def test_syntax_error_service ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( SyntaxError ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL] [EOL] [EOL] def test_import_error ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( ImportError ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from tomodachi . validation . validation import ( RegexMissmatchException , TooLargeException , TooSmallException , validate_field_length , validate_field_regex , ) [EOL] [EOL] [EOL] def test_regex_success ( ) : [EOL] validate_field_regex ( [string] , [string] ) [EOL] [EOL] [EOL] def test_regex_failure ( ) : [EOL] with pytest . raises ( RegexMissmatchException ) : [EOL] validate_field_regex ( [string] , [string] ) [EOL] [EOL] [EOL] def test_string_length_success_1 ( ) : [EOL] validate_field_length ( [string] , [number] , [number] ) [EOL] [EOL] [EOL] def test_string_length_success_2 ( ) : [EOL] validate_field_length ( [string] , [number] , [number] ) [EOL] [EOL] [EOL] def test_string_length_success_3 ( ) : [EOL] validate_field_length ( [string] ) [EOL] [EOL] [EOL] def test_string_length_success_4 ( ) : [EOL] validate_field_length ( [string] ) [EOL] [EOL] [EOL] def test_string_length_too_large ( ) : [EOL] with pytest . raises ( TooLargeException ) : [EOL] validate_field_length ( [string] , [number] , [number] ) [EOL] [EOL] [EOL] def test_string_length_too_small ( ) : [EOL] with pytest . raises ( TooSmallException ) : [EOL] validate_field_length ( [string] , [number] , [number] ) [EOL] [EOL] [EOL] def test_string_length_empty ( ) : [EOL] with pytest . raises ( TooSmallException ) : [EOL] validate_field_length ( [string] , [number] ) [EOL] [EOL] [EOL] def test_list_length_success_1 ( ) : [EOL] validate_field_length ( [ [string] , [string] , [string] , [string] , [string] ] , [number] , [number] ) [EOL] [EOL] [EOL] def test_list_length_success_2 ( ) : [EOL] validate_field_length ( [ [string] , [string] ] , [number] , [number] ) [EOL] [EOL] [EOL] def test_list_length_success_3 ( ) : [EOL] validate_field_length ( [ ] ) [EOL] [EOL] [EOL] def test_list_length_success_4 ( ) : [EOL] validate_field_length ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def test_list_length_too_large ( ) : [EOL] with pytest . raises ( TooLargeException ) : [EOL] validate_field_length ( [ [string] , [string] , [string] , [string] , [string] , [string] ] , [number] , [number] ) [EOL] [EOL] [EOL] def test_list_length_too_small ( ) : [EOL] with pytest . raises ( TooSmallException ) : [EOL] validate_field_length ( [ [string] ] , [number] , [number] ) [EOL] [EOL] [EOL] def test_list_length_empty ( ) : [EOL] with pytest . raises ( TooSmallException ) : [EOL] validate_field_length ( [ ] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] from typing import Any [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_logging_service ( monkeypatch , capsys , loop ) : [EOL] log_path = [string] [EOL] [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] loop . run_until_complete ( future ) [EOL] [EOL] log_content = str ( open ( log_path ) . read ( ) . strip ( ) ) [EOL] assert [string] in log_content [EOL] assert [string] in log_content [EOL] assert [string] in log_content [EOL] [EOL] try : [EOL] os . remove ( log_path ) [EOL] except OSError : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import aiohttp [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_decorated_functions_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] instance = services . get ( [string] ) [EOL] port = instance . context . get ( [string] ) [EOL] [EOL] async def _async ( loop ) : [EOL] assert instance . invocation_count == [number] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == str ( instance . invocation_count ) [EOL] assert instance . invocation_count == [number] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == str ( instance . invocation_count ) [EOL] assert instance . invocation_count == [number] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == str ( instance . invocation_count ) [EOL] assert instance . invocation_count == [number] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == str ( instance . invocation_count ) [EOL] assert instance . invocation_count == [number] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == str ( instance . invocation_count ) [EOL] assert instance . invocation_count == [number] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == str ( instance . invocation_count ) [EOL] assert instance . invocation_count == [number] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert instance . invocation_count == [number] [EOL] [EOL] loop . run_until_complete ( _async ( loop ) ) [EOL] instance . stop_service ( ) [EOL] loop . run_until_complete ( future ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] from typing import Generator [EOL] [EOL] import pytest [EOL] import uvloop [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def loop ( ) : [EOL] asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ( ) ) [EOL] loop = asyncio . new_event_loop ( ) [EOL] asyncio . set_event_loop ( loop ) [EOL] yield loop [EOL] try : [EOL] if loop and not loop . is_closed ( ) : [EOL] loop . close ( ) [EOL] except RuntimeWarning : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import services . mock_decorator_service [EOL] [EOL] [EOL] def test_without_mocked_invoker_function ( loop ) : [EOL] service = services . mock_decorator_service . MockDecoratorService ( ) [EOL] [EOL] loop . run_until_complete ( service . test ( ) ) [EOL] assert service . function_tested is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import signal [EOL] import sys [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] import tomodachi [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_non_named_sub_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] assert instance . start is True [EOL] assert instance . started is True [EOL] assert instance . stop is False [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] assert instance . stop is True [EOL] [EOL] [EOL] def test_non_named_sub_service_without_py_ending ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_non_named_same_named_sub_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] assert instance . start is True [EOL] assert instance . started is True [EOL] assert instance . stop is False [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] assert instance . stop is True [EOL] [EOL] [EOL] def test_non_named_same_named_sub_service_without_py_ending ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( sys . version_info >= ( [number] , [number] , [number] ) , reason = [string] ) def test_sub_service ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( tomodachi . importer . ServicePackageError ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( sys . version_info >= ( [number] , [number] , [number] ) , reason = [string] ) def test_sub_service_without_py_ending ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( tomodachi . importer . ServicePackageError ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( sys . version_info >= ( [number] , [number] , [number] ) , reason = [string] ) def test_same_named_sub_service ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( tomodachi . importer . ServicePackageError ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( sys . version_info >= ( [number] , [number] , [number] ) , reason = [string] ) def test_same_named_sub_service_without_py_ending ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( tomodachi . importer . ServicePackageError ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] [EOL] def test_sub_service_with_reserved_name ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( tomodachi . importer . ServicePackageError ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] [EOL] def test_sub_service_with_reserved_name_without_py_ending ( monkeypatch , capsys , loop ) : [EOL] with pytest . raises ( tomodachi . importer . ServicePackageError ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] from typing import Any [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_start_process_schedule ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] assert instance . uuid is not None [EOL] [EOL] async def _async ( loop ) : [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] loop . run_until_complete ( _async ( loop ) ) [EOL] instance . stop_service ( ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] assert instance . function_order == [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_start_amqp_service_invalid_credentials ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] assert instance . uuid is not None [EOL] instance . stop_service ( ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL] assert out == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import io [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] import mimetypes [EOL] import os [EOL] import pathlib [EOL] from typing import Any [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] from multidict import CIMultiDictProxy [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_start_http_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] port = instance . context . get ( [string] ) [EOL] assert port is not None [EOL] assert port != [number] [EOL] assert instance . uuid is not None [EOL] instance . stop_service ( ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_conflicting_port_http_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] port1 = instance . context . get ( [string] ) [EOL] assert instance . uuid is not None [EOL] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] port2 = instance . context . get ( [string] ) [EOL] assert instance . uuid is not None [EOL] [EOL] assert bool ( port1 and port2 ) is False [EOL] [EOL] loop . run_until_complete ( future ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err or [string] in err [EOL] [EOL] [EOL] def test_request_http_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] instance = services . get ( [string] ) [EOL] port = instance . context . get ( [string] ) [EOL] [EOL] async def _async ( loop ) : [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . post ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . head ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert isinstance ( response . headers , CIMultiDictProxy ) [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert isinstance ( response . headers , CIMultiDictProxy ) [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert isinstance ( response . headers , CIMultiDictProxy ) [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert isinstance ( response . headers , CIMultiDictProxy ) [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] _id = [string] [EOL] response = await client . get ( [string] . format ( port , _id ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] . format ( _id ) [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert isinstance ( response . headers , CIMultiDictProxy ) [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = None [EOL] with pytest . raises ( asyncio . TimeoutError ) : [EOL] response = await asyncio . shield ( client . get ( [string] . format ( port ) , timeout = [number] ) ) [EOL] assert response is None [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] assert instance . slow_request is False [EOL] response = None [EOL] with pytest . raises ( asyncio . TimeoutError ) : [EOL] response = await asyncio . shield ( client . get ( [string] . format ( port ) , timeout = [number] ) ) [EOL] assert response is None [EOL] assert instance . slow_request is False [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] assert instance . slow_request is True [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) , timeout = [number] ) [EOL] assert response is not None [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert response . headers . get ( [string] ) . strip ( ) == [string] . strip ( ) [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) , headers = { [string] : [string] } ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) , headers = { [string] : [string] } ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) , headers = { [string] : [string] } ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] assert instance . middleware_called is False [EOL] response = await client . get ( [string] . format ( port ) , headers = { [string] : [string] } ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert instance . middleware_called is True [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] assert instance . function_triggered is False [EOL] response = await client . get ( [string] . format ( port ) , headers = { [string] : [string] } ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert instance . function_triggered is False [EOL] [EOL] response = await client . get ( [string] . format ( port ) , headers = { [string] : [string] } ) [EOL] assert response . status == [number] [EOL] assert await response . text ( ) == [string] [EOL] assert instance . function_triggered is True [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] f = pathlib . Path ( [string] . format ( os . path . realpath ( os . getcwd ( ) ) ) ) . open ( [string] ) [EOL] ct , encoding = mimetypes . guess_type ( str ( f . name ) ) [EOL] [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] assert response . headers . get ( [string] ) == ct [EOL] [EOL] with open ( str ( f . name ) , [string] ) as fobj : [EOL] data = fobj . read ( [number] ) [EOL] assert ( await response . read ( ) ) == data [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] f = pathlib . Path ( [string] . format ( os . path . realpath ( os . getcwd ( ) ) ) ) . open ( [string] ) [EOL] ct , encoding = mimetypes . guess_type ( str ( f . name ) ) [EOL] [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] assert response . headers . get ( [string] ) == [string] [EOL] assert response . headers . get ( [string] ) == ct [EOL] [EOL] with open ( str ( f . name ) , [string] ) as fobj : [EOL] data = fobj . read ( [number] ) [EOL] assert ( await response . read ( ) ) == data [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] [EOL] assert instance . websocket_connected is False [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] async with client . ws_connect ( [string] . format ( port ) ) as ws : [EOL] await ws . close ( ) [EOL] assert instance . websocket_connected is True [EOL] [EOL] assert instance . websocket_header is None [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] async with client . ws_connect ( [string] . format ( port ) ) as ws : [EOL] await ws . close ( ) [EOL] assert instance . websocket_header is not None [EOL] assert [string] in instance . websocket_header [EOL] assert [string] in instance . websocket_header [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] async with client . ws_connect ( [string] . format ( port ) ) as ws : [EOL] data = [string] [EOL] assert instance . websocket_received_data != data [EOL] await ws . send_str ( data ) [EOL] await ws . close ( ) [EOL] assert instance . websocket_received_data == data [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop , headers = { [string] : [string] } ) as client : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] assert response is not None [EOL] assert response . status == [number] [EOL] [EOL] loop . run_until_complete ( _async ( loop ) ) [EOL] instance . stop_service ( ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] [EOL] def test_access_log ( monkeypatch , loop ) : [EOL] log_path = [string] [EOL] [EOL] logging . basicConfig ( format = [string] , level = logging . INFO ) [EOL] logging . Formatter ( fmt = [string] , datefmt = [string] ) [EOL] [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] instance = services . get ( [string] ) [EOL] port = instance . context . get ( [string] ) [EOL] [EOL] assert os . path . exists ( log_path ) is True [EOL] with open ( log_path ) as file : [EOL] content = file . read ( ) [EOL] assert content == [string] . format ( port ) [EOL] [EOL] async def _async ( loop ) : [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] await client . get ( [string] . format ( port ) ) [EOL] with open ( log_path ) as file : [EOL] content = file . read ( ) [EOL] assert [string] not in content [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . post ( [string] . format ( port ) , data = [string] ) [EOL] assert await response . read ( ) == [string] [EOL] with open ( log_path ) as file : [EOL] content = file . read ( ) [EOL] assert [string] not in content [EOL] assert [string] not in content [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] response = await client . post ( [string] . format ( port ) ) [EOL] assert await response . read ( ) == [string] [EOL] with open ( log_path ) as file : [EOL] content = file . read ( ) [EOL] assert [string] not in content [EOL] assert [string] not in content [EOL] assert [string] in content [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] await client . get ( [string] . format ( port ) ) [EOL] with open ( log_path ) as file : [EOL] content = file . read ( ) [EOL] assert [string] in content [EOL] assert [string] not in content [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] await client . get ( [string] . format ( port ) ) [EOL] with open ( log_path ) as file : [EOL] content = file . read ( ) [EOL] assert [string] in content [EOL] assert [string] in content [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] await client . post ( [string] . format ( port ) , data = [string] ) [EOL] with open ( log_path ) as file : [EOL] content = file . read ( ) [EOL] assert [string] in content [EOL] [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] await client . post ( [string] . format ( port ) , data = [string] ) [EOL] with open ( log_path ) as file : [EOL] content = file . read ( ) [EOL] assert [string] in content [EOL] [EOL] with open ( log_path ) as file : [EOL] content = file . read ( ) [EOL] assert content == [string] . format ( port ) [EOL] [EOL] loop . run_until_complete ( _async ( loop ) ) [EOL] instance . stop_service ( ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] assert os . path . exists ( log_path ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] from typing import Any [EOL] [EOL] import aiohttp [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_start_process_http_early_request ( monkeypatch , capsys , loop ) : [EOL] func , future = start_service ( [string] , monkeypatch , wait = False ) [EOL] port = [number] [EOL] [EOL] async def _async ( loop ) : [EOL] await asyncio . sleep ( [number] ) [EOL] async with aiohttp . ClientSession ( loop = loop ) as client : [EOL] try : [EOL] response = await client . get ( [string] . format ( port ) ) [EOL] except Exception : [EOL] response = False [EOL] [EOL] assert response is False [EOL] [EOL] loop . run_until_complete ( _async ( loop ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] services = func ( ) [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] assert instance . uuid is not None [EOL] [EOL] assert instance . function_order == [ [string] , [string] , [string] ] [EOL] [EOL] instance . stop_service ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import signal [EOL] from typing import Any [EOL] [EOL] import tomodachi [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_dummy_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] assert instance . start is True [EOL] assert instance . started is True [EOL] assert instance . stop is False [EOL] [EOL] assert tomodachi . get_instance ( ) == instance [EOL] assert tomodachi . get_service ( ) == instance [EOL] assert tomodachi . get_service ( [string] ) == instance [EOL] assert tomodachi . get_service ( [string] ) is None [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] assert instance . stop is True [EOL] [EOL] [EOL] def test_dummy_service_without_py_ending ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] import datetime [EOL] [EOL] import pytest [EOL] import pytz [EOL] [EOL] from tomodachi . helpers . crontab import get_next_datetime [EOL] [EOL] [EOL] def test_aliases ( ) : [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_parser ( ) : [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_isoweekday ( ) : [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] get_next_datetime ( [string] , t ) [EOL] [EOL] [EOL] def test_days_with_isoweekday ( ) : [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_timezones ( ) : [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = pytz . UTC ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] , tzinfo = pytz . UTC ) [EOL] [EOL] t = pytz . timezone ( [string] ) . localize ( datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] assert get_next_datetime ( [string] , t ) == pytz . timezone ( [string] ) . localize ( datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) ) [EOL] assert get_next_datetime ( [string] , t ) == pytz . timezone ( [string] ) . localize ( datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) ) [EOL] [EOL] [EOL] def test_advanced_parsing ( ) : [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] ) [EOL] [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] ) [EOL] [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) == datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_impossible_dates ( ) : [EOL] t = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert get_next_datetime ( [string] , t ) is None [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] get_next_datetime ( [string] , t ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] get_next_datetime ( [string] , t ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] get_next_datetime ( [string] , t ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] get_next_datetime ( [string] , t ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] get_next_datetime ( [string] , t ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] get_next_datetime ( [string] , t ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] get_next_datetime ( [string] , t ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] get_next_datetime ( [string] , t ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Dict [EOL] import builtins [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] import functools [EOL] import logging [EOL] import signal [EOL] from typing import Any , Dict , Tuple [EOL] [EOL] import uvloop [EOL] [EOL] from tomodachi . container import ServiceContainer [EOL] from tomodachi . importer import ServiceImporter [EOL] [EOL] [EOL] def start_service ( filename , monkeypatch = None , wait = True ) : [EOL] if monkeypatch : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [comment] [EOL] service = None [comment] [EOL] [EOL] def stop_services ( loop = None ) : [EOL] if not loop : [EOL] loop = asyncio . get_event_loop ( ) [EOL] asyncio . ensure_future ( _stop_services ( ) ) [EOL] [EOL] def force_stop_services ( loop = None ) : [EOL] if not loop : [EOL] loop = asyncio . get_event_loop ( ) [EOL] asyncio . ensure_future ( _force_stop_services ( ) ) [EOL] [EOL] async def _stop_services ( ) : [EOL] service . stop_service ( ) [EOL] [EOL] async def _force_stop_services ( ) : [EOL] if not service . started_waiter . done ( ) : [EOL] service . started_waiter . set_result ( [ ] ) [EOL] [EOL] for signame in ( [string] , [string] ) : [EOL] loop . add_signal_handler ( getattr ( signal , signame ) , functools . partial ( stop_services , loop ) ) [EOL] [EOL] try : [EOL] service = ServiceContainer ( ServiceImporter . import_service_file ( filename ) ) [EOL] assert service is not None [EOL] [EOL] async def _async ( ) : [EOL] loop = asyncio . get_event_loop ( ) [comment] [EOL] try : [EOL] await service . run_until_complete ( ) [EOL] except Exception : [EOL] loop = asyncio . get_event_loop ( ) [EOL] stop_services ( loop ) [EOL] force_stop_services ( loop ) [EOL] raise [EOL] [EOL] future = asyncio . ensure_future ( _async ( ) ) [EOL] if wait : [EOL] loop . run_until_complete ( asyncio . wait ( [ service . started_waiter ] ) ) [EOL] except Exception : [EOL] for signame in ( [string] , [string] ) : [EOL] loop . remove_signal_handler ( getattr ( signal , signame ) ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] if service : [EOL] stop_services ( loop ) [EOL] raise [EOL] [EOL] services = { } [EOL] if wait : [EOL] for service_name , instance , log_level in service . started_waiter . result ( ) : [EOL] services [ service_name ] = instance [EOL] else : [EOL] def get_services ( ) : [EOL] loop . run_until_complete ( asyncio . wait ( [ service . started_waiter ] ) ) [EOL] return { service_name : instance for service_name , instance , log_level in service . started_waiter . result ( ) } [EOL] [EOL] return get_services , future [EOL] [EOL] return services , future [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import os [EOL] import time [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not os . environ . get ( [string] ) or not os . environ . get ( [string] ) , reason = [string] ) def test_start_aws_sns_sqs_service_with_credentials ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] assert services is not None [EOL] assert len ( services ) == [number] [EOL] instance = services . get ( [string] ) [EOL] assert instance is not None [EOL] [EOL] assert instance . uuid is not None [EOL] [EOL] async def _async ( loop ) : [EOL] loop_until = time . time ( ) + [number] [EOL] while loop_until > time . time ( ) : [EOL] if instance . test_topic_data_received and instance . test_topic_metadata_topic and instance . test_topic_service_uuid and instance . wildcard_topic_data_received and instance . test_topic_specified_queue_name_data_received : [EOL] break [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] assert instance . test_topic_data_received [EOL] assert instance . test_topic_metadata_topic == [string] [EOL] assert instance . test_topic_service_uuid == instance . uuid [EOL] assert instance . wildcard_topic_data_received [EOL] assert instance . test_topic_specified_queue_name_data_received [EOL] [EOL] loop . run_until_complete ( _async ( loop ) ) [EOL] instance . stop_service ( ) [EOL] loop . run_until_complete ( future ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import signal [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] from run_test_service_helper import start_service [EOL] from tomodachi . transport . amqp import AmqpException , AmqpTransport [EOL] [EOL] [EOL] def test_routing_key ( monkeypatch ) : [EOL] routing_key = AmqpTransport . get_routing_key ( [string] , { } ) [EOL] assert routing_key == [string] [EOL] [EOL] routing_key = AmqpTransport . get_routing_key ( [string] , { [string] : { [string] : { [string] : [string] } } } ) [EOL] assert routing_key == [string] [EOL] [EOL] [EOL] def test_encode_routing_key ( monkeypatch ) : [EOL] routing_key = AmqpTransport . encode_routing_key ( [string] ) [EOL] assert routing_key == [string] [EOL] [EOL] routing_key = AmqpTransport . encode_routing_key ( [string] ) [EOL] assert routing_key == [string] [EOL] [EOL] [EOL] def test_decode_routing_key ( monkeypatch ) : [EOL] routing_key = AmqpTransport . decode_routing_key ( [string] ) [EOL] assert routing_key == [string] [EOL] [EOL] routing_key = AmqpTransport . decode_routing_key ( [string] ) [EOL] assert routing_key == [string] [EOL] [EOL] [EOL] def test_queue_name ( monkeypatch ) : [EOL] _uuid = [string] [EOL] queue_name = AmqpTransport . get_queue_name ( [string] , [string] , _uuid , False , { } ) [EOL] assert queue_name == [string] [EOL] [EOL] queue_name = AmqpTransport . get_queue_name ( [string] , [string] , _uuid , False , { } ) [EOL] assert queue_name != [string] [EOL] [EOL] queue_name = AmqpTransport . get_queue_name ( [string] , [string] , _uuid , False , { [string] : { [string] : { [string] : [string] } } } ) [EOL] assert queue_name == [string] [EOL] [EOL] queue_name = AmqpTransport . get_queue_name ( [string] , [string] , _uuid , True , { } ) [EOL] assert queue_name == [string] [EOL] [EOL] queue_name = AmqpTransport . get_queue_name ( [string] , [string] , _uuid , True , { } ) [EOL] assert queue_name == [string] [EOL] [EOL] queue_name = AmqpTransport . get_queue_name ( [string] , [string] , _uuid , True , { [string] : { [string] : { [string] : [string] } } } ) [EOL] assert queue_name == [string] [EOL] [EOL] [EOL] def test_publish_invalid_credentials ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] with pytest . raises ( AmqpException ) : [EOL] loop . run_until_complete ( AmqpTransport . publish ( instance , [string] , [string] , wait = True ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL] assert out == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import tomodachi [EOL] import typing [EOL] import logging [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] import tomodachi [EOL] import tomodachi . cli [EOL] [EOL] [EOL] def test_cli_help_command_method ( capsys ) : [EOL] cli = tomodachi . cli . CLI ( ) [EOL] with pytest . raises ( SystemExit ) : [EOL] cli . help_command ( ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert err == [string] [EOL] assert out == cli . help_command_usage ( ) + [string] [EOL] [EOL] [EOL] def test_cli_version_command_method ( capsys ) : [EOL] cli = tomodachi . cli . CLI ( ) [EOL] with pytest . raises ( SystemExit ) : [EOL] cli . version_command ( ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert err == [string] [EOL] assert out == [string] . format ( tomodachi . __version__ ) + [string] [EOL] [EOL] [EOL] def test_cli_run_command_method_no_args ( capsys ) : [EOL] cli = tomodachi . cli . CLI ( ) [EOL] with pytest . raises ( SystemExit ) : [EOL] cli . run_command ( [ ] ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert err == [string] [EOL] assert out == cli . run_command_usage ( ) + [string] [EOL] [EOL] [EOL] def test_cli_entrypoint_no_arguments ( monkeypatch , capsys ) : [EOL] cli = tomodachi . cli . CLI ( ) [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err == [string] [EOL] assert out == cli . help_command_usage ( ) + [string] [EOL] [EOL] [EOL] def test_cli_entrypoint_print_help ( monkeypatch , capsys ) : [EOL] cli = tomodachi . cli . CLI ( ) [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err == [string] [EOL] assert out == cli . help_command_usage ( ) + [string] [EOL] [EOL] [EOL] def test_cli_entrypoint_print_dependency_versions ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err == [string] [EOL] assert out != [string] . format ( tomodachi . __version__ ) + [string] [EOL] [EOL] import aiobotocore [EOL] assert [string] . format ( aiobotocore . __version__ ) + [string] in out [EOL] [EOL] [EOL] def test_cli_entrypoint_print_version ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err == [string] [EOL] assert out == [string] . format ( tomodachi . __version__ ) + [string] [EOL] [EOL] [EOL] def test_cli_entrypoint_invalid_arguments_show_help ( monkeypatch , capsys ) : [EOL] cli = tomodachi . cli . CLI ( ) [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err == [string] [EOL] assert out == cli . help_command_usage ( ) + [string] [EOL] [EOL] [EOL] def test_cli_entrypoint_invalid_subcommand_show_help ( monkeypatch , capsys ) : [EOL] cli = tomodachi . cli . CLI ( ) [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err == [string] [EOL] assert out == cli . help_command_usage ( ) + [string] [EOL] [EOL] [EOL] def test_cli_start_service_stopped_with_sigterm ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err != [string] [EOL] assert [string] in out [EOL] assert [string] . format ( tomodachi . __version__ ) in out [EOL] [EOL] [EOL] def test_cli_start_service_stopped_with_sigint ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err != [string] [EOL] assert [string] in out [EOL] assert [string] . format ( tomodachi . __version__ ) in out [EOL] [EOL] [EOL] def test_cli_start_exception_service ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err != [string] [EOL] assert [string] in out [EOL] assert [string] . format ( tomodachi . __version__ ) in out [EOL] assert [string] in err [EOL] [EOL] [EOL] def test_cli_start_exception_service_init ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err != [string] [EOL] assert [string] in out [EOL] assert [string] . format ( tomodachi . __version__ ) in out [EOL] assert [string] in err [EOL] [EOL] [EOL] def test_cli_start_service_production_mode ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert err != [string] [EOL] assert out == [string] [EOL] [EOL] [EOL] def test_cli_start_service_with_config ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in out [EOL] assert [string] . format ( tomodachi . __version__ ) in out [EOL] [EOL] [EOL] def test_cli_start_service_with_non_existing_config ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] not in out [EOL] assert [string] . format ( tomodachi . __version__ ) not in out [EOL] assert [string] in out [EOL] [EOL] [EOL] def test_cli_start_service_with_invalid_config ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] not in out [EOL] assert [string] . format ( tomodachi . __version__ ) not in out [EOL] assert [string] in out [EOL] [EOL] [EOL] def test_cli_start_service_without_config_arguments ( monkeypatch , capsys ) : [EOL] monkeypatch . setattr ( logging . root , [string] , [ ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] tomodachi . cli . cli_entrypoint ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] not in out [EOL] assert [string] . format ( tomodachi . __version__ ) not in out [EOL] assert [string] in out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import signal [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] from run_test_service_helper import start_service [EOL] from tomodachi . transport . aws_sns_sqs import AWSSNSSQSException , AWSSNSSQSTransport [EOL] [EOL] [EOL] def test_topic_name ( monkeypatch ) : [EOL] topic_name = AWSSNSSQSTransport . get_topic_name ( [string] , { } ) [EOL] assert topic_name == [string] [EOL] [EOL] topic_name = AWSSNSSQSTransport . get_topic_name ( [string] , { [string] : { [string] : { [string] : [string] } } } ) [EOL] assert topic_name == [string] [EOL] [EOL] [EOL] def test_encode_topic ( monkeypatch ) : [EOL] topic_name = AWSSNSSQSTransport . encode_topic ( [string] ) [EOL] assert topic_name == [string] [EOL] [EOL] topic_name = AWSSNSSQSTransport . encode_topic ( [string] ) [EOL] assert topic_name == [string] [EOL] [EOL] [EOL] def test_decode_topic ( monkeypatch ) : [EOL] topic_name = AWSSNSSQSTransport . decode_topic ( [string] ) [EOL] assert topic_name == [string] [EOL] [EOL] topic_name = AWSSNSSQSTransport . decode_topic ( [string] ) [EOL] assert topic_name == [string] [EOL] [EOL] [EOL] def test_queue_name ( monkeypatch ) : [EOL] _uuid = [string] [EOL] queue_name = AWSSNSSQSTransport . get_queue_name ( [string] , [string] , _uuid , False , { } ) [EOL] assert queue_name == [string] [EOL] [EOL] queue_name = AWSSNSSQSTransport . get_queue_name ( [string] , [string] , _uuid , False , { } ) [EOL] assert queue_name != [string] [EOL] [EOL] queue_name = AWSSNSSQSTransport . get_queue_name ( [string] , [string] , _uuid , False , { [string] : { [string] : { [string] : [string] } } } ) [EOL] assert queue_name == [string] [EOL] [EOL] queue_name = AWSSNSSQSTransport . get_queue_name ( [string] , [string] , _uuid , True , { } ) [EOL] assert queue_name == [string] [EOL] [EOL] queue_name = AWSSNSSQSTransport . get_queue_name ( [string] , [string] , _uuid , True , { } ) [EOL] assert queue_name == [string] [EOL] [EOL] queue_name = AWSSNSSQSTransport . get_queue_name ( [string] , [string] , _uuid , True , { [string] : { [string] : { [string] : [string] } } } ) [EOL] assert queue_name == [string] [EOL] [EOL] [EOL] def test_publish_invalid_credentials ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] instance = services . get ( [string] ) [EOL] [EOL] with pytest . raises ( AWSSNSSQSException ) : [EOL] loop . run_until_complete ( AWSSNSSQSTransport . publish ( instance , [string] , [string] , wait = True ) ) [EOL] [EOL] async def _async_kill ( ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGINT ) [EOL] [EOL] loop . create_task ( _async_kill ( ) ) [EOL] loop . run_until_complete ( future ) [EOL] [EOL] if not future . done ( ) : [EOL] future . set_result ( None ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL] assert out == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tomodachi [EOL] [EOL] [EOL] def test_version_exists ( ) : [EOL] assert tomodachi . __version__ is not None [EOL]	0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] from run_test_service_helper import start_service [EOL] [EOL] [EOL] def test_empty_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] loop . run_until_complete ( future ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL] [EOL] [EOL] def test_non_decorated_service ( monkeypatch , capsys , loop ) : [EOL] services , future = start_service ( [string] , monkeypatch ) [EOL] [EOL] loop . run_until_complete ( future ) [EOL] [EOL] out , err = capsys . readouterr ( ) [EOL] assert [string] in err [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import tomodachi [EOL] from tomodachi . transport . aws_sns_sqs import aws_sns_sqs [EOL] [EOL] [EOL] @ tomodachi . service class MockDecoratorService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] function_tested = False [EOL] [EOL] @ aws_sns_sqs ( [string] ) async def test ( self , default_value = True ) : [EOL] self . function_tested = default_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0
import asyncio [EOL] import os [EOL] import signal [EOL] [EOL] [EOL] class NonDecoratedService ( object ) : [EOL] name = [string] [EOL] [EOL] async def _started_service ( self ) : [EOL] await asyncio . sleep ( [number] ) [EOL] os . kill ( os . getpid ( ) , signal . SIGTERM ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tomodachi [EOL] [EOL] from . relative_import . import_file import noop [EOL] [EOL] [EOL] @ tomodachi . service class RelativeService ( tomodachi . Service ) : [EOL] name = [string] [EOL] [EOL] start = False [EOL] started = False [EOL] stop = False [EOL] [EOL] async def _start_service ( self ) : [EOL] noop ( ) [EOL] self . start = True [EOL] [EOL] async def _started_service ( self ) : [EOL] self . started = True [EOL] [EOL] async def _stop_service ( self ) : [EOL] self . stop = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
import tomodachi [EOL] [EOL] [EOL] @ tomodachi . service class EmptyService ( tomodachi . Service ) : [EOL] name = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
import tomodachi [EOL] [EOL] [EOL] @ tomodachi . service class ExceptionService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] async def _start_service ( self ) : [EOL] raise Exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0
import tomodachi [EOL] [EOL] [EOL] @ tomodachi . service class ExceptionService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] [EOL] async def _start_service ( self ) : [EOL] raise Exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import tomodachi [EOL] [EOL] [EOL] @ tomodachi . service class InvalidService ( tomodachi . Service ) : [EOL] name = [string] [EOL] [EOL] def syntax_error ( self ) : [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $error$ 0 0 0 0 0 0 0 0
import asyncio [EOL] import logging [EOL] import os [EOL] import signal [EOL] [EOL] import tomodachi [EOL] [EOL] [EOL] @ tomodachi . service class LoggingService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_path = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] try : [EOL] os . remove ( self . log_path ) [EOL] except OSError : [EOL] pass [EOL] [EOL] async def _start_service ( self ) : [EOL] self . log_setup ( filename = self . log_path ) [EOL] self . log ( [string] , level = logging . INFO ) [EOL] [EOL] async def _started_service ( self ) : [EOL] self . log ( [string] , level = logging . INFO ) [EOL] await asyncio . sleep ( [number] ) [EOL] os . kill ( os . getpid ( ) , signal . SIGTERM ) [EOL] [EOL] async def _stop_service ( self ) : [EOL] self . log ( [string] , level = logging . INFO ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import builtins [EOL] import typing [EOL] import aiohttp [EOL] from aiohttp import web [EOL] [EOL] import tomodachi [EOL] from tomodachi . transport . http import http [EOL] [EOL] [EOL] @ tomodachi . service class HttpServiceOne ( tomodachi . Service ) : [EOL] name = [string] [EOL] options = { [string] : { [string] : [number] , } } [EOL] [EOL] @ http ( [string] , [string] ) async def test ( self , request ) : [EOL] return [string] [EOL] [EOL] [EOL] @ tomodachi . service class HttpServiceTwo ( tomodachi . Service ) : [EOL] name = [string] [EOL] options = { [string] : { [string] : [number] , } } [EOL] [EOL] @ http ( [string] , [string] ) async def test ( self , request ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0
[comment] [EOL] import noservicewiththisname [EOL]	0 0 0 0 0
def test_func ( ) : [EOL] pass [EOL]	0 $None$ 0 0 0 0 0 0
	0
def test_func ( ) : [EOL] pass [EOL]	0 $None$ 0 0 0 0 0 0
def noop ( ) : [EOL] pass [EOL]	0 $None$ 0 0 0 0 0 0
	0
import builtins [EOL] from typing import List , Type , Union , Dict [EOL] import tomodachi [EOL] import typing [EOL] import tomodachi [EOL] from tomodachi . discovery . dummy_registry import DummyRegistry [EOL] from tomodachi . protocol . json_base import JsonBase [EOL] [EOL] from . code import test_func [EOL] [EOL] [EOL] @ tomodachi . service class DummyService ( tomodachi . Service ) : [EOL] name = [string] [EOL] discovery = [ DummyRegistry ] [EOL] message_protocol = JsonBase [EOL] options = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] } } [EOL] [EOL] start = False [EOL] started = False [EOL] stop = False [EOL] [EOL] async def _start_service ( self ) : [EOL] test_func ( ) [EOL] self . start = True [EOL] [EOL] async def _started_service ( self ) : [EOL] self . started = True [EOL] [EOL] async def _stop_service ( self ) : [EOL] self . stop = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
def test_func ( ) : [EOL] pass [EOL]	0 $None$ 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
	0
import builtins [EOL] from typing import Type [EOL] import examples [EOL] import tomodachi [EOL] import typing [EOL] import uuid [EOL] from typing import Any [EOL] [EOL] import tomodachi [EOL] from tomodachi import aws_sns_sqs_publish , schedule [EOL] from tomodachi . protocol import JsonBase [EOL] [EOL] [EOL] @ tomodachi . service class ServiceSendMessage ( tomodachi . Service ) : [EOL] name = [string] [EOL] message_protocol = JsonBase [EOL] [EOL] options = { [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None } } [EOL] [EOL] @ schedule ( interval = [number] , immediately = True ) async def send_message_interval ( self ) : [EOL] data = str ( uuid . uuid4 ( ) ) [EOL] self . log ( [string] . format ( data ) ) [EOL] await aws_sns_sqs_publish ( self , data , topic = [string] , wait = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import examples [EOL] import tomodachi [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import tomodachi [EOL] from tomodachi import aws_sns_sqs [EOL] from tomodachi . protocol import JsonBase [EOL] [EOL] [EOL] @ tomodachi . service class ServiceB ( tomodachi . Service ) : [EOL] name = [string] [EOL] message_protocol = JsonBase [EOL] [EOL] options = { [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None } } [EOL] [EOL] @ aws_sns_sqs ( [string] , competing = True ) async def callback ( self , data ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] [EOL] async def _started_service ( self ) : [EOL] self . log ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Type [EOL] import examples [EOL] import tomodachi [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import tomodachi [EOL] from tomodachi import aws_sns_sqs , aws_sns_sqs_publish [EOL] from tomodachi . protocol import JsonBase [EOL] [EOL] [EOL] @ tomodachi . service class ServiceA ( tomodachi . Service ) : [EOL] name = [string] [EOL] message_protocol = JsonBase [EOL] [EOL] options = { [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None } } [EOL] [EOL] @ aws_sns_sqs ( [string] , competing = True ) async def new_message ( self , data ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] [EOL] callback_data = [string] . format ( data ) [EOL] await aws_sns_sqs_publish ( self , callback_data , topic = [string] , wait = True ) [EOL] [EOL] async def _started_service ( self ) : [EOL] self . log ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Type , Union , Callable , Tuple , Dict [EOL] import tomodachi [EOL] import examples [EOL] import aiohttp [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] import os [EOL] from typing import Callable , Tuple , Union [EOL] [EOL] from aiohttp import web [EOL] [EOL] import tomodachi [EOL] from tomodachi import HttpResponse , http , http_error , http_static , websocket [EOL] from tomodachi . discovery import DummyRegistry [EOL] [EOL] [EOL] @ tomodachi . service class ExampleHttpService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] uuid = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] discovery = [ DummyRegistry ] [EOL] [EOL] [comment] [EOL] options = { [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : True } } [EOL] [EOL] @ http ( [string] , [string] ) async def example ( self , request ) : [EOL] await asyncio . sleep ( [number] ) [EOL] return [string] [comment] [EOL] [EOL] @ http ( [string] , [string] ) async def example_with_id ( self , request , id ) : [EOL] return [string] . format ( id ) [EOL] [EOL] @ http ( [string] , [string] ) async def response_object ( self , request ) : [EOL] return HttpResponse ( body = [string] , status = [number] , content_type = [string] ) [EOL] [EOL] @ http_static ( [string] , [string] ) async def static_files ( self ) : [EOL] [comment] [EOL] pass [EOL] [EOL] @ websocket ( [string] ) async def websocket_connection ( self , websocket ) : [EOL] [comment] [EOL] self . log ( [string] ) [EOL] [EOL] async def _receive ( data ) : [EOL] [comment] [EOL] self . log ( [string] . format ( data ) ) [EOL] await websocket . send_str ( [string] ) [EOL] [EOL] async def _close ( ) : [EOL] [comment] [EOL] self . log ( [string] ) [EOL] [EOL] [comment] [EOL] return _receive , _close [EOL] [EOL] @ http_error ( status_code = [number] ) async def error_404 ( self , request ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type[tomodachi.discovery.dummy_registry.DummyRegistry]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $tomodachi.HttpResponse$ 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.WebSocketResponse$ 0 0 0 0 0 $typing.Tuple[typing.Callable,typing.Callable]$ 0 0 0 $aiohttp.web.WebSocketResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Union[builtins.str,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0
from typing import Any , Type , Dict , List [EOL] import builtins [EOL] import examples [EOL] import tomodachi [EOL] import typing [EOL] import os [EOL] from typing import Any , Dict [EOL] [EOL] import tomodachi [EOL] from tomodachi import amqp , amqp_publish [EOL] from tomodachi . discovery import DummyRegistry [EOL] from tomodachi . protocol import JsonBase [EOL] [EOL] [EOL] @ tomodachi . service class ExampleAmqpService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] uuid = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] discovery = [ DummyRegistry ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] message_protocol = JsonBase [EOL] [EOL] [comment] [EOL] options = { [string] : { [string] : [number] } } [EOL] [EOL] @ amqp ( [string] ) async def route1a ( self , data ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] [EOL] @ amqp ( [string] ) async def route1b ( self , data ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] [EOL] @ amqp ( [string] ) async def route2 ( self , data ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] [EOL] @ amqp ( [string] ) async def wildcard_route ( self , metadata , data ) : [EOL] self . log ( [string] . format ( metadata . get ( [string] , [string] ) , data ) ) [EOL] [EOL] async def _started_service ( self ) : [EOL] async def publish ( data , routing_key ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] await amqp_publish ( self , data , routing_key = routing_key ) [EOL] [EOL] await publish ( [string] , [string] ) [EOL] await publish ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type[tomodachi.discovery.dummy_registry.DummyRegistry]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tomodachi.protocol.json_base.JsonBase]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Union , Dict [EOL] import builtins [EOL] import aiohttp [EOL] import examples [EOL] import typing [EOL] import asyncio [EOL] import os [EOL] import uuid [EOL] from typing import Any [EOL] [EOL] from aiohttp import web [EOL] [EOL] import tomodachi [EOL] from tomodachi import HttpResponse , http [EOL] [EOL] [EOL] @ tomodachi . decorator async def require_auth_token ( instance , request ) : [EOL] post_body = await request . read ( ) if request . body_exists else None [EOL] if not post_body or post_body . decode ( ) != instance . allowed_token : [EOL] return HttpResponse ( body = [string] , status = [number] ) [EOL] [EOL] [EOL] @ tomodachi . service class ExampleHttpAuthService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] allowed_token = str ( uuid . uuid4 ( ) ) [EOL] uuid = os . environ . get ( [string] ) [EOL] [EOL] options = { [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : True } } [EOL] [EOL] @ http ( [string] , [string] ) async def get_token ( self , request ) : [EOL] return self . allowed_token [EOL] [EOL] @ http ( [string] , [string] ) @ require_auth_token async def validate ( self , request ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0
from typing import Type , Any , Union , Callable , Dict [EOL] import builtins [EOL] import aiohttp [EOL] import examples [EOL] import typing [EOL] import asyncio [EOL] import os [EOL] from typing import Any , Callable , Dict , Tuple , Union [EOL] [EOL] from aiohttp import web [EOL] [EOL] import tomodachi [EOL] from tomodachi import HttpResponse , http , http_error , http_static , websocket [EOL] from tomodachi . discovery import DummyRegistry [EOL] [EOL] [EOL] async def middleware_function ( func , service , request , context , * args , ** kwargs ) : [EOL] [comment] [EOL] service . log ( [string] ) [EOL] [EOL] return_value = await func ( * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] service . log ( [string] ) [EOL] [EOL] return return_value [EOL] [EOL] [EOL] @ tomodachi . service class ExampleHttpMiddlewareService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] uuid = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] http_middleware = [ middleware_function ] [EOL] [EOL] [comment] [EOL] options = { [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : True } } [EOL] [EOL] @ http ( [string] , [string] ) async def example ( self , request , ** kwargs ) : [EOL] await asyncio . sleep ( [number] ) [EOL] return [string] [comment] [EOL] [EOL] @ http ( [string] , [string] ) async def example_with_id ( self , request , id , ** kwargs ) : [EOL] return [string] . format ( id ) [EOL] [EOL] @ http_error ( status_code = [number] ) async def error_404 ( self , request , ** kwargs ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $aiohttp.web.Request$ 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Type [EOL] import examples [EOL] import typing [EOL] import os [EOL] [EOL] import tomodachi [EOL] from tomodachi import hourly , minutely , schedule [EOL] [EOL] [EOL] @ tomodachi . service class SchedulerService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] uuid = os . environ . get ( [string] ) [EOL] [EOL] @ schedule ( interval = [string] ) async def every_second ( self ) : [EOL] self . log ( [string] ) [EOL] [EOL] @ minutely async def every_minute ( self ) : [EOL] self . log ( [string] ) [EOL] [EOL] @ hourly async def every_hour ( self ) : [EOL] self . log ( [string] ) [EOL] [EOL] @ schedule ( interval = [string] ) async def every_second_minute ( self ) : [EOL] self . log ( [string] ) [EOL] [EOL] @ schedule ( interval = [string] ) async def work_hours ( self ) : [EOL] self . log ( [string] ) [EOL] [EOL] @ schedule ( interval = [string] ) async def advanced_cron_notation_scheduling ( self ) : [EOL] self . log ( [string] ) [EOL] [EOL] @ schedule ( timestamp = [string] ) async def as_timestamp ( self ) : [EOL] self . log ( [string] ) [EOL] [EOL] @ schedule ( timestamp = [string] , timezone = [string] ) async def midnight_in_sweden ( self ) : [EOL] self . log ( [string] ) [EOL] [EOL] @ schedule ( interval = [number] ) async def every_twenty_seconds ( self ) : [EOL] self . log ( [string] ) [EOL] [EOL] @ schedule ( interval = [number] , immediately = True ) async def every_twenty_seconds_and_immediately ( self ) : [EOL] self . log ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Dict , List [EOL] import builtins [EOL] import examples [EOL] import tomodachi [EOL] import typing [EOL] import os [EOL] from typing import Any , Dict [EOL] [EOL] import tomodachi [EOL] from tomodachi import aws_sns_sqs , aws_sns_sqs_publish [EOL] from tomodachi . discovery import AWSSNSRegistration [EOL] from tomodachi . protocol import JsonBase [EOL] [EOL] [EOL] @ tomodachi . service class ExampleAWSSNSSQSService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] uuid = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] discovery = [ AWSSNSRegistration ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] message_protocol = JsonBase [EOL] [EOL] [comment] [EOL] options = { [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None } } [EOL] [EOL] @ aws_sns_sqs ( [string] ) async def route1a ( self , data ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] [EOL] @ aws_sns_sqs ( [string] ) async def route1b ( self , data ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] [EOL] @ aws_sns_sqs ( [string] ) async def route2 ( self , data ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] [EOL] @ aws_sns_sqs ( [string] ) async def wildcard_route ( self , metadata , data ) : [EOL] self . log ( [string] . format ( metadata . get ( [string] , [string] ) , data ) ) [EOL] [EOL] async def _started_service ( self ) : [EOL] async def publish ( data , topic ) : [EOL] self . log ( [string] . format ( data ) ) [EOL] await aws_sns_sqs_publish ( self , data , topic = topic , wait = False ) [EOL] [EOL] await publish ( [string] , [string] ) [EOL] await publish ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict [EOL] import examples [EOL] import tomodachi [EOL] import typing [EOL] import os [EOL] from typing import Dict [EOL] [EOL] import tomodachi [EOL] from tomodachi import aws_sns_sqs [EOL] from tomodachi . protocol import JsonBase [EOL] [EOL] [EOL] class AWSSNSRegistrationService ( tomodachi . Service ) : [EOL] name = [string] [EOL] log_level = [string] [EOL] uuid = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] message_protocol = JsonBase [EOL] [EOL] [comment] [EOL] options = { [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None } } [EOL] [EOL] @ aws_sns_sqs ( [string] , queue_name = [string] , competing = True ) async def register ( self , data ) : [EOL] self . log ( [string] . format ( data . get ( [string] ) , data . get ( [string] ) ) ) [EOL] [EOL] @ aws_sns_sqs ( [string] , queue_name = [string] , competing = True ) async def deregister ( self , data ) : [EOL] self . log ( [string] . format ( data . get ( [string] ) , data . get ( [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import tomodachi [EOL] [EOL] [EOL] @ tomodachi . service class Service ( tomodachi . Service ) : [EOL] name = [string] [EOL] options = { [string] : { [string] : [number] } } [EOL] [EOL] @ tomodachi . http ( [string] , [string] ) async def index_endpoint ( self , request ) : [EOL] return [string] [EOL] [EOL] @ tomodachi . http ( [string] , [string] ) async def health_check ( self , request ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0