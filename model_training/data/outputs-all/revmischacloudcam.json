[comment] [EOL] [EOL] from typing import Dict , List , Any [EOL] import axis [EOL] import argparse [EOL] import urllib [EOL] import typing [EOL] import argparse [EOL] import urllib . request , urllib . parse [EOL] from sys import exit [EOL] from pprint import pprint [EOL] [EOL] [EOL] DEBUG = True [EOL] [EOL] def debug ( msg ) : [EOL] global DEBUG [EOL] if DEBUG : [EOL] print ( msg ) [EOL] [EOL] class CloudCam : [EOL] NTP_SERVER = [string] [EOL] [EOL] def setup ( self ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] if not args . password : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] self . param_url = [string] . format ( args . address ) [EOL] [EOL] [comment] [EOL] passman = urllib . request . HTTPPasswordMgrWithDefaultRealm ( ) [EOL] passman . add_password ( None , self . param_url , args . username , args . password ) [EOL] auth_handler = urllib . request . HTTPDigestAuthHandler ( passman ) [EOL] opener = urllib . request . build_opener ( auth_handler ) [EOL] urllib . request . install_opener ( opener ) [EOL] [EOL] self . setNTP ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( [string] % ( args . address , args . password ) ) [EOL] f . close ( ) [EOL] except FileExistsError as e : [EOL] pass [EOL] [EOL] [EOL] def request ( self , data = { } ) : [EOL] r = None [EOL] try : [EOL] r = urllib . request . urlopen ( self . param_url , urllib . parse . urlencode ( data ) . encode ( [string] ) ) [EOL] except urllib . error . HTTPError as e : [EOL] if e . code == [number] : [EOL] print ( [string] ) [EOL] exit ( [number] ) [EOL] else : [EOL] [comment] [EOL] raise (e) [EOL] [EOL] data = r . read ( ) [EOL] r . close ( ) [EOL] return data . decode ( [string] ) [EOL] [EOL] def setNTP ( self ) : [EOL] [comment] [EOL] [EOL] fetch_config_params = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] dec = urllib . parse . parse_qs ( self . request ( fetch_config_params ) ) [EOL] if not [string] in dec : [EOL] print ( [string] , dec ) [EOL] exit ( [number] ) [EOL] [EOL] server = dec [ [string] ] [ [number] ] . strip ( ) [EOL] if server == self . NTP_SERVER : [EOL] debug ( [string] ) [EOL] params = { [string] : [string] , [string] : self . NTP_SERVER } [EOL] res = self . request ( params ) [EOL] if res == [string] : [EOL] debug ( [string] ) [EOL] else : [EOL] print ( [string] , data ) [EOL] [EOL] cc = CloudCam ( ) [EOL] cc . setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $urllib.request.HTTPPasswordMgrWithDefaultRealm$ 0 0 0 0 0 0 0 0 0 $urllib.request.HTTPPasswordMgrWithDefaultRealm$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $urllib.request.HTTPDigestAuthHandler$ 0 0 0 0 0 0 0 $urllib.request.HTTPPasswordMgrWithDefaultRealm$ 0 0 $urllib.request.OpenerDirector$ 0 0 0 0 0 0 0 $urllib.request.HTTPDigestAuthHandler$ 0 0 0 0 0 0 0 0 $urllib.request.OpenerDirector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $axis.cam_setup.CloudCam$ 0 0 0 0 0 $axis.cam_setup.CloudCam$ 0 0 0 0 0
import logging [EOL] import string [EOL] import random [EOL] [EOL] from botocore . exceptions import ClientError [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def ignore_resource_already_exists ( method , ** kwargs ) : [EOL] try : [EOL] return method ( ** kwargs ) [EOL] except ClientError as e : [EOL] if e . response [ [string] ] [ [string] ] == [string] : [EOL] pass [EOL] else : [EOL] raise [EOL] [EOL] [EOL] def ignore_resource_not_found ( method , ** kwargs ) : [EOL] try : [EOL] return method ( ** kwargs ) [EOL] except ClientError as e : [EOL] if e . response [ [string] ] [ [string] ] == [string] : [EOL] pass [EOL] else : [EOL] raise [EOL] [EOL] [EOL] def ignore_all ( method , ** kwargs ) : [EOL] try : [EOL] return method ( ** kwargs ) [EOL] except ClientError as e : [EOL] pass [EOL] [EOL] [EOL] def rand_string ( size = [number] , chars = string . ascii_uppercase + string . ascii_uppercase + string . digits ) : [EOL] return [string] . join ( random . choice ( chars ) for _ in range ( size ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import json [EOL] import logging [EOL] import os [EOL] import random [EOL] import time [EOL] import boto3 [EOL] import base64 [EOL] from cloudcam . tools import rand_string [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] lightsail_azs = [ x . strip ( ) for x in os . environ [ [string] ] . split ( [string] ) ] [EOL] lightsail_blueprint_id = os . environ [ [string] ] [EOL] lightsail_bundle_id = os . environ [ [string] ] [EOL] lightsail_janus_image = os . environ [ [string] ] [EOL] janus_hosted_zone_id = os . environ [ [string] ] [EOL] janus_hosted_zone_domain = os . environ [ [string] ] [EOL] janus_instance_name_prefix = os . environ [ [string] ] [EOL] [EOL] [comment] [EOL] janus_ssl_cert_pem = [string] [EOL] [EOL] [comment] [EOL] janus_kms_key_alias = [string] [EOL] janus_encrypted_ssl_key_pem = [string] [EOL] [EOL] lightsail = boto3 . client ( [string] ) [EOL] route53 = boto3 . client ( [string] ) [EOL] cloudwatch_us_east_1 = boto3 . client ( [string] , region_name = [string] ) [comment] [EOL] kms = boto3 . client ( [string] ) [EOL] sts = boto3 . client ( [string] ) [EOL] [EOL] aws_account_id = sts . get_caller_identity ( ) [ [string] ] [EOL] [EOL] [comment] [EOL] janus_health_check_alarms_topic_arn = f' [string] { aws_account_id } [string] ' [EOL] [EOL] [EOL] def get_lightsail_init_script ( ) : [EOL] [comment] [EOL] [comment] [EOL] janus_ssl_key_pem = kms . decrypt ( CiphertextBlob = base64 . b64decode ( janus_encrypted_ssl_key_pem ) ) [ [string] ] . decode ( [string] ) [EOL] return [string] . format ( janus_ssl_cert_pem , janus_ssl_key_pem , lightsail_janus_image ) [EOL] [EOL] [EOL] def get_janus_instances ( ) : [EOL] [docstring] [EOL] return list ( filter ( lambda instance : instance [ [string] ] . startswith ( janus_instance_name_prefix ) , lightsail . get_instances ( ) [ [string] ] ) ) [EOL] [EOL] [EOL] def open_instance_public_tcp_port ( instance_name , port ) : [EOL] lightsail . open_instance_public_ports ( instanceName = instance_name , portInfo = { [string] : port , [string] : port , [string] : [string] } ) [EOL] [EOL] [EOL] def open_instance_public_udp_port_range ( instance_name , from_port , to_port ) : [EOL] lightsail . open_instance_public_ports ( instanceName = instance_name , portInfo = { [string] : from_port , [string] : to_port , [string] : [string] } ) [EOL] [EOL] [EOL] def get_instance_status ( instance_name ) : [EOL] instance = lightsail . get_instance ( instanceName = instance_name ) [EOL] return instance [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def create_janus_instance ( ) : [EOL] [docstring] [EOL] [comment] [EOL] lightsail_az = random . choice ( lightsail_azs ) [EOL] instance_name = f'{ janus_instance_name_prefix } [string] { lightsail_az } [string] { rand_string ( [number] ) }' . lower ( ) [EOL] logger . info ( f' [string] { instance_name } [string] { lightsail_az } [string] { lightsail_blueprint_id } [string] { lightsail_bundle_id }' ) [EOL] [comment] [EOL] lightsail . create_instances ( instanceNames = [ instance_name ] , availabilityZone = lightsail_az , blueprintId = lightsail_blueprint_id , bundleId = lightsail_bundle_id , userData = get_lightsail_init_script ( ) ) [EOL] [comment] [EOL] for _ in range ( [number] ) : [EOL] time . sleep ( [number] ) [EOL] if get_instance_status ( instance_name ) == [string] : [EOL] break [EOL] logger . info ( f' [string] { instance_name } [string] ' ) [EOL] [comment] [EOL] for port in [ [number] , [number] , [number] , [number] , [number] ] : [EOL] open_instance_public_tcp_port ( instance_name , port ) [EOL] open_instance_public_udp_port_range ( instance_name , [number] , [number] ) [EOL] open_instance_public_udp_port_range ( instance_name , [number] , [number] ) [EOL] [comment] [EOL] instance = lightsail . get_instance ( instanceName = instance_name ) [EOL] ipv4_address = instance [ [string] ] [ [string] ] [EOL] domain_name = f'{ instance_name } [string] { janus_hosted_zone_domain }' [EOL] [comment] [EOL] route53 . change_resource_record_sets ( HostedZoneId = janus_hosted_zone_id , ChangeBatch = { [string] : [ { [string] : [string] , [string] : { [string] : domain_name , [string] : [string] , [string] : [number] , [string] : [ { [string] : ipv4_address } ] } } ] } ) [EOL] logger . info ( f' [string] { domain_name } [string] { instance_name } [string] ' ) [EOL] [comment] [EOL] healthcheck_id = route53 . create_health_check ( CallerReference = domain_name , HealthCheckConfig = { [string] : [number] , [string] : [string] , [string] : [string] , [string] : domain_name , [string] : [number] , [string] : [number] , [string] : False } ) [ [string] ] [ [string] ] [EOL] route53 . change_tags_for_resource ( ResourceType = [string] , ResourceId = healthcheck_id , AddTags = [ { [string] : [string] , [string] : f' [string] { domain_name } [string] ' } ] ) [EOL] [comment] [EOL] cloudwatch_us_east_1 . put_metric_alarm ( AlarmName = f'{ domain_name }' , AlarmDescription = f' [string] { domain_name } [string] ' , ActionsEnabled = True , AlarmActions = [ janus_health_check_alarms_topic_arn ] , MetricName = [string] , Namespace = [string] , Statistic = [string] , Dimensions = [ { [string] : [string] , [string] : healthcheck_id } ] , Period = [number] , EvaluationPeriods = [number] , Threshold = [number] , ComparisonOperator = [string] ) [EOL] logger . info ( f' [string] { healthcheck_id }' ) [EOL] return { [string] : instance_name } [EOL] [EOL] [EOL] def remove_health_checks ( domain_name ) : [EOL] [docstring] [EOL] paginator = route53 . get_paginator ( [string] ) [EOL] response_iterator = paginator . paginate ( ) [EOL] for page in response_iterator : [EOL] for health_check in page [ [string] ] : [EOL] health_check_id = health_check [ [string] ] [EOL] health_check_config = health_check [ [string] ] [EOL] if health_check_config [ [string] ] == domain_name : [EOL] logger . info ( f' [string] { health_check_id } [string] ' ) [EOL] route53 . delete_health_check ( HealthCheckId = health_check_id ) [EOL] cloudwatch_us_east_1 . delete_alarms ( AlarmNames = [ f'{ domain_name }' ] ) [EOL] [EOL] [EOL] def remove_janus_instance ( instance_name ) : [EOL] [docstring] [EOL] logger . info ( f' [string] { instance_name }' ) [EOL] [comment] [EOL] domain_name = f'{ instance_name } [string] { janus_hosted_zone_domain }' [EOL] [comment] [EOL] ipv4_address = route53 . test_dns_answer ( HostedZoneId = janus_hosted_zone_id , RecordName = domain_name , RecordType = [string] ) [ [string] ] [ [number] ] [EOL] [comment] [EOL] remove_health_checks ( domain_name ) [EOL] [comment] [EOL] route53 . change_resource_record_sets ( HostedZoneId = janus_hosted_zone_id , ChangeBatch = { [string] : [ { [string] : [string] , [string] : { [string] : domain_name , [string] : [string] , [string] : [number] , [string] : [ { [string] : ipv4_address } ] } } ] } ) [EOL] [comment] [EOL] lightsail . delete_instance ( instanceName = instance_name ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] [docstring] [EOL] logger . info ( json . dumps ( event , sort_keys = True , indent = [number] ) ) [EOL] [EOL] [comment] [EOL] required_instance_count = event . get ( [string] ) [EOL] alarms = list ( filter ( None , map ( lambda record : json . loads ( record . get ( [string] , { } ) . get ( [string] , [string] ) ) , event . get ( [string] , [ ] ) ) ) ) [EOL] [EOL] instances = get_janus_instances ( ) [EOL] current_instance_count = len ( instances ) [EOL] [EOL] [comment] [EOL] deleted_instance = False [EOL] created_instance = False [EOL] if required_instance_count is not None : [EOL] logger . info ( f' [string] { required_instance_count } [string] { current_instance_count }' ) [EOL] if current_instance_count > required_instance_count : [EOL] for _ in range ( current_instance_count - required_instance_count ) : [EOL] remove_janus_instance ( instances [ - [number] ] [ [string] ] ) [EOL] instances . pop ( ) [EOL] deleted_instance = True [EOL] elif current_instance_count < required_instance_count : [EOL] for _ in range ( required_instance_count - current_instance_count ) : [EOL] create_janus_instance ( ) [EOL] created_instance = True [EOL] [EOL] [comment] [EOL] if alarms : [EOL] logger . info ( f' [string] { alarms }' ) [EOL] for alarm in alarms : [EOL] domain_name = alarm [ [string] ] [EOL] matching_instances = list ( filter ( lambda instance : instance [ [string] ] in domain_name , instances ) ) [EOL] for matching_instance in matching_instances : [EOL] instance_name = matching_instance [ [string] ] [EOL] logger . info ( f' [string] { instance_name } [string] ' ) [EOL] remove_janus_instance ( instance_name ) [EOL] create_janus_instance ( ) [EOL] [EOL] [EOL] return { [string] : current_instance_count , [string] : deleted_instance , [string] : created_instance , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import boto3 [EOL] from botocore . exceptions import ClientError [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] iot = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def thing_exists_p ( thing_name ) : [EOL] try : [EOL] iot . describe_thing ( thingName = thing_name ) [EOL] return True [EOL] except ClientError as e : [EOL] if e . response [ [string] ] [ [string] ] == [string] : [EOL] return False [EOL] else : [EOL] raise [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] [docstring] [EOL] [comment] [EOL] identity_id = context . identity . cognito_identity_id [EOL] if not identity_id : [EOL] raise Exception ( [string] ) [EOL] [EOL] logger . info ( f' [string] { identity_id }' ) [EOL] [EOL] [comment] [EOL] thing_names = iot . list_principal_things ( maxResults = [number] , principal = identity_id , ) [ [string] ] [EOL] [EOL] return { [string] : thing_names , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , IO , Literal , Union , Any [EOL] import requests [EOL] import logging [EOL] import typing_extensions [EOL] import cloudcam [EOL] import typing [EOL] import boto3 [EOL] [comment] [EOL] import unittest [EOL] import logging [EOL] import time [EOL] import os [EOL] import requests [EOL] import tempfile [EOL] import ssl [EOL] from functools import partial [EOL] from AWSIoTPythonSDK . MQTTLib import AWSIoTMQTTClient [EOL] from AWSIoTPythonSDK . exception . AWSIoTExceptions import connectTimeoutException [EOL] [EOL] [EOL] boto3 . set_stream_logger ( [string] , logging . WARN ) [EOL] log = logging . getLogger ( [string] ) [EOL] log . setLevel ( logging . DEBUG ) [EOL] [EOL] iotcore = logging . getLogger ( [string] ) [EOL] iotcore . setLevel ( logging . DEBUG ) [EOL] [EOL] [EOL] class Client ( ) : [EOL] def __init__ ( self , iot_client = None , iot_data_client = None , credentials = None , ca_path = None , privkey_path = None , cert_path = None ) : [EOL] assert ca_path , [string] [EOL] if not iot_client : [EOL] iot_client = boto3 . client ( [string] ) [EOL] if not iot_data_client : [EOL] iot_data_client = boto3 . client ( [string] ) [EOL] self . iot_client = iot_client [EOL] self . iot_data_client = iot_data_client [EOL] self . cert_path = cert_path [EOL] self . privkey_path = privkey_path [EOL] self . ca_path = ca_path [EOL] self . credentials = credentials [EOL] self . init_mqtt_client ( ) [EOL] [EOL] def init_mqtt_client ( self ) : [EOL] endpoint = self . iot_client . describe_endpoint ( ) [EOL] use_websocket = True if self . credentials else False [EOL] endpoint_port = [number] if use_websocket else [number] [EOL] self . mqtt_client = AWSIoTMQTTClient ( [string] , useWebsocket = use_websocket ) [EOL] self . mqtt_client . configureEndpoint ( endpoint [ [string] ] , endpoint_port ) [EOL] self . mqtt_client . configureOfflinePublishQueueing ( - [number] ) [EOL] self . mqtt_client . configureConnectDisconnectTimeout ( [number] ) [EOL] self . mqtt_client . configureMQTTOperationTimeout ( [number] ) [EOL] self . configure_credentials ( ) [EOL] log . debug ( [string] . format ( ssl . OPENSSL_VERSION ) ) [EOL] log . debug ( [string] . format ( endpoint [ [string] ] , endpoint_port ) ) [EOL] try : [EOL] self . mqtt_client . connect ( ) [EOL] log . debug ( [string] ) [EOL] except connectTimeoutException : [EOL] log . error ( [string] ) [EOL] self . mqtt_client = None [EOL] [EOL] def configure_credentials ( self ) : [EOL] if self . credentials : [EOL] self . mqtt_client . configureIAMCredentials ( * ( self . credentials . values ( ) ) ) [EOL] self . mqtt_client . configureCredentials ( self . ca_path ) [EOL] elif self . privkey_path and self . cert_path : [EOL] log . debug ( [string] , str ( self . ca_path ) , str ( self . privkey_path ) , str ( self . cert_path ) ) [EOL] self . mqtt_client . configureCredentials ( self . ca_path , self . privkey_path , self . cert_path ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] class Source ( Client ) : [EOL] def __init__ ( self , thing_name , ** kw ) : [EOL] self . thing_name = thing_name [EOL] Client . __init__ ( self , ** kw ) [EOL] if self . mqtt_client : [EOL] self . mqtt_client . subscribe ( [string] , [number] , partial ( self . snapshot_requested_handler ) ) [EOL] else : [EOL] log . warn ( [string] ) [EOL] [EOL] def req_thumb_update ( self , cb ) : [EOL] if cb : [EOL] setattr ( self , [string] , cb ) [EOL] self . iot_data_client . publish ( topic = [string] , ) [EOL] [EOL] def snapshot_requested_handler ( self , client , userdata , message ) : [EOL] log . debug ( [string] , message ) [EOL] cb = getattr ( self , [string] ) [EOL] if cb : [EOL] cb ( client , userdata , message ) [EOL] delattr ( self , [string] ) [EOL] [EOL] [EOL] class TestCloudcamSource ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] [comment] [EOL] sts = boto3 . client ( [string] ) [EOL] self . acct_id = sts . get_caller_identity ( ) . get ( [string] ) [EOL] self . region_name = boto3 . session . Session ( ) . region_name [EOL] [comment] [EOL] self . master_iot_client = boto3 . client ( [string] ) [EOL] self . create_test_certificate ( ) [EOL] self . create_test_policy ( ) [EOL] self . thing_name = self . create_test_thing ( ) [EOL] assume_creds = self . assume_source_role ( ) [EOL] self . iot_client = boto3 . client ( [string] , ** assume_creds ) [EOL] self . iot_data_client = boto3 . client ( [string] , ** assume_creds ) [EOL] self . source = Source ( self . thing_name , ca_path = self . ca_path , privkey_path = self . privkey_path , cert_path = self . cert_path , iot_client = self . iot_client , iot_data_client = self . iot_data_client , ) [EOL] if not self . source . mqtt_client : [EOL] [comment] [EOL] self . tearDown ( ) [EOL] self . fail ( [string] ) [EOL] [comment] [EOL] [EOL] def tearDown ( self ) : [EOL] print ( [string] ) [EOL] log . info ( [string] ) [EOL] if self . source . mqtt_client : [EOL] self . source . mqtt_client . disconnect ( ) [EOL] self . delete_test_policy ( ) [EOL] self . delete_test_thing ( ) [EOL] self . delete_test_certificate ( ) [EOL] [EOL] [comment] [EOL] [EOL] def create_test_certificate ( self ) : [EOL] [comment] [EOL] self . cert = self . master_iot_client . create_keys_and_certificate ( setAsActive = True ) [EOL] self . iot_principal = self . cert [ [string] ] [EOL] cert = self . cert [ [string] ] [EOL] privkey = self . cert [ [string] ] [ [string] ] [EOL] self . cert_path = self . write_temp ( cert ) [EOL] self . privkey_path = self . write_temp ( privkey ) [EOL] [comment] [EOL] r = requests . get ( [string] ) [EOL] verisign = r . content [EOL] self . ca_path = self . write_temp ( verisign ) [EOL] [comment] [EOL] [EOL] def delete_test_policy ( self , policy_name = [string] ) : [EOL] iot = self . master_iot_client [EOL] [comment] [EOL] policies = iot . list_policies ( ) [ [string] ] [EOL] policy_names = [ p [ [string] ] for p in policies ] [EOL] if policy_name not in policy_names : [EOL] return [EOL] policy = iot . get_policy ( policyName = policy_name ) [EOL] if policy : [EOL] principals = iot . list_policy_principals ( policyName = policy_name ) [ [string] ] [EOL] [comment] [EOL] for principal in principals : [EOL] iot . detach_principal_policy ( policyName = policy_name , principal = principal , ) [EOL] iot . delete_policy ( policyName = policy_name ) [EOL] [EOL] def create_test_policy ( self ) : [EOL] policy_name = [string] [EOL] iot = self . master_iot_client [EOL] self . delete_test_policy ( policy_name ) [EOL] [comment] [EOL] policy_document = [string] . format ( aid = self . acct_id , region = self . region_name ) [EOL] iot . create_policy ( policyName = policy_name , policyDocument = policy_document , ) [EOL] iot . attach_principal_policy ( principal = self . iot_principal , policyName = policy_name , ) [EOL] [EOL] def write_temp ( self , content ) : [EOL] [comment] [EOL] f = tempfile . NamedTemporaryFile ( delete = False ) [EOL] f . write ( content ) [EOL] f . flush ( ) [EOL] return f . name [EOL] [EOL] def delete_test_certificate ( self ) : [EOL] self . master_iot_client . update_certificate ( certificateId = self . cert [ [string] ] , newStatus = [string] ) [EOL] self . master_iot_client . delete_certificate ( certificateId = self . cert [ [string] ] ) [EOL] [comment] [EOL] os . unlink ( self . ca_path ) [EOL] os . unlink ( self . cert_path ) [EOL] os . unlink ( self . privkey_path ) [EOL] [EOL] def create_test_thing ( self ) : [EOL] res = self . master_iot_client . create_thing ( thingName = [string] , thingTypeName = [string] , attributePayload = { } , ) [EOL] thing_name = res [ [string] ] [EOL] self . master_iot_client . attach_thing_principal ( thingName = thing_name , principal = self . iot_principal , ) [EOL] return thing_name [EOL] [EOL] def assume_source_role ( self ) : [EOL] [comment] [EOL] sts = boto3 . client ( [string] ) [EOL] assume_res = sts . assume_role ( RoleArn = [string] . format ( self . acct_id ) , RoleSessionName = [string] , ) [EOL] credentials = assume_res [ [string] ] [EOL] assume_creds = dict ( aws_access_key_id = credentials [ [string] ] , aws_secret_access_key = credentials [ [string] ] , aws_session_token = credentials [ [string] ] , ) [EOL] return assume_creds [EOL] [EOL] def delete_test_thing ( self ) : [EOL] principals = self . master_iot_client . list_thing_principals ( thingName = self . thing_name ) [ [string] ] [EOL] [comment] [EOL] for principal in principals : [EOL] log . debug ( [string] . format ( self . thing_name , principal ) ) [EOL] self . master_iot_client . detach_thing_principal ( thingName = self . thing_name , principal = principal , ) [EOL] self . master_iot_client . delete_thing ( thingName = self . thing_name ) [EOL] [EOL] [comment] [EOL] [EOL] def test_iot_thumb ( self ) : [EOL] self . iot_client . update_thing ( thingName = self . thing_name , attributePayload = { } , ) [EOL] [EOL] [comment] [EOL] self . thumb_update_res = None [EOL] [EOL] def thumb_updated ( client , userdata , message ) : [EOL] log . debug ( [string] , message ) [EOL] self . thumb_update_res = message [EOL] self . source . req_thumb_update ( thumb_updated ) [EOL] [EOL] [comment] [EOL] start = time . time ( ) [EOL] while not self . thumb_update_res and time . time ( ) < start + [number] : [EOL] time . sleep ( [number] ) [EOL] [EOL] if not self . thumb_update_res : [EOL] self . fail ( [string] ) [EOL] return [EOL] print ( self . thumb_update_res ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $cloudcam.test.Source$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cloudcam.test.Source$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import boto3 [EOL] import logging [EOL] import os [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] log . setLevel ( logging . DEBUG ) [EOL] iot = boto3 . client ( [string] ) [EOL] [EOL] user_iot_policy_name = os . getenv ( [string] ) [EOL] if not user_iot_policy_name : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] [docstring] [EOL] log . debug ( f" [string] { event } [string] { context }" ) [EOL] [EOL] [comment] [EOL] if not hasattr ( context , [string] ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] identity_id = context . identity . cognito_identity_id [EOL] print ( f" [string] { identity_id }" ) [EOL] iot . attach_policy ( policyName = user_iot_policy_name , target = identity_id ) [EOL] print ( [string] ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List , Any [EOL] import typing [EOL] import logging [EOL] import json [EOL] import logging [EOL] import boto3 [EOL] from cloudcam import tools [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] iot = boto3 . client ( [string] ) [EOL] sts = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] logger . info ( json . dumps ( event , sort_keys = True , indent = [number] ) ) [EOL] [EOL] iot_endpoint = iot . describe_endpoint ( ) [EOL] region = iot_endpoint [ [string] ] . split ( [string] ) [ [number] ] [EOL] account_id = sts . get_caller_identity ( ) [ [string] ] [EOL] [EOL] identity_id = context . identity . cognito_identity_id [EOL] thing_name = event [ [string] ] [EOL] [EOL] logger . info ( f' [string] { identity_id } [string] { thing_name }' ) [EOL] [EOL] if not identity_id : [EOL] raise Exception ( [string] ) [EOL] [EOL] if not thing_name : [EOL] raise Exception ( [string] ) [EOL] [EOL] policy = { [string] : [string] , [string] : [ { [string] : [string] , [string] : [ [string] ] , [string] : [ f" [string] { region } [string] { account_id } [string] " ] } , { [string] : [string] , [string] : [ [string] , [string] ] , [string] : [ f" [string] { region } [string] { account_id } [string] { thing_name }" ] } , { [string] : [string] , [string] : [ [string] ] , [string] : [ f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " ] } , { [string] : [string] , [string] : [ [string] , [string] ] , [string] : [ f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " , f" [string] { region } [string] { account_id } [string] { thing_name } [string] " ] } ] } [EOL] policy_name = f'{ identity_id } [string] { thing_name }' . replace ( [string] , [string] ) [EOL] [EOL] logger . info ( f' [string] { policy_name } [string] { policy }' ) [EOL] [EOL] tools . ignore_all ( iot . detach_principal_policy , policyName = policy_name , principal = identity_id ) [EOL] tools . ignore_all ( iot . delete_policy , policyName = policy_name ) [EOL] [EOL] tools . ignore_resource_already_exists ( iot . create_policy , policyName = policy_name , policyDocument = json . dumps ( policy ) ) [EOL] iot . attach_principal_policy ( policyName = policy_name , principal = identity_id ) [EOL] [EOL] iot . update_thing ( thingName = thing_name , attributePayload = { [string] : { f' [string] { identity_id }' : [string] } , [string] : True } ) [EOL] [EOL] return { [string] : thing_name , [string] : identity_id , [string] : policy_name } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Optional [EOL] import typing [EOL] import logging [EOL] from __future__ import print_function [EOL] [EOL] import json [EOL] import boto3 [EOL] import logging [EOL] import os [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] log . setLevel ( logging . DEBUG ) [EOL] [EOL] thumb_bucket_name = os . getenv ( [string] ) [EOL] [EOL] iot_data = boto3 . client ( [string] ) [EOL] s3 = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] [docstring] [EOL] [comment] [EOL] thing_names = event [ [string] ] [EOL] if not thing_names : [EOL] raise Exception ( [string] ) [EOL] [EOL] [comment] [EOL] for thing_name in thing_names : [EOL] [comment] [EOL] [comment] [EOL] iot_data . publish ( topic = f' [string] { thing_name } [string] ' , qos = [number] , payload = json . dumps ( { [string] : [string] , [string] : gen_upload_url ( thing_name ) , [string] : gen_download_url ( thing_name ) } ) . encode ( [string] ) ) [EOL] return { } [EOL] [EOL] [EOL] def gen_upload_url ( thing_name ) : [EOL] [docstring] [EOL] return s3 . generate_presigned_url ( [string] , Params = { [string] : thumb_bucket_name , [string] : f' [string] { thing_name } [string] ' } , ExpiresIn = [number] , HttpMethod = [string] ) [EOL] [EOL] [EOL] def gen_download_url ( thing_name ) : [EOL] [docstring] [EOL] return s3 . generate_presigned_url ( [string] , Params = { [string] : thumb_bucket_name , [string] : f' [string] { thing_name } [string] ' } , ExpiresIn = [number] , HttpMethod = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import json [EOL] import logging [EOL] [EOL] import boto3 [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] iot = boto3 . client ( [string] ) [EOL] iot_data = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] [docstring] [EOL] logger . info ( json . dumps ( event , sort_keys = True , indent = [number] ) ) [EOL] [EOL] [comment] [EOL] thing_name = event [ [string] ] [EOL] logger . info ( thing_name ) [EOL] [EOL] [comment] [EOL] thing_shadow = json . loads ( iot_data . get_thing_shadow ( thingName = thing_name ) [ [string] ] . read ( ) . decode ( [string] ) ) [EOL] logger . info ( json . dumps ( thing_shadow , indent = [number] ) ) [EOL] [EOL] [comment] [EOL] streams = thing_shadow [ [string] ] [ [string] ] . get ( [string] ) [EOL] logger . info ( f' [string] { streams }' ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] iot_data . update_thing_shadow ( thingName = thing_name , payload = json . dumps ( { [string] : { [string] : { [string] : streams } } } ) . encode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import requests [EOL] import typing [EOL] import logging [EOL] import json [EOL] import logging [EOL] import random [EOL] from time import time [EOL] import os [EOL] from cloudcam . tools import rand_string [EOL] [EOL] import boto3 [EOL] import requests [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] janus_verify_https = False [EOL] janus_connect_timeout = [number] [EOL] janus_rtp_port_range = range ( [number] , [number] , [number] ) [EOL] janus_hosted_zone_domain = os . environ [ [string] ] [EOL] janus_instance_name_prefix = os . environ [ [string] ] [EOL] [EOL] lightsail = boto3 . client ( [string] ) [EOL] [EOL] iot = boto3 . client ( [string] ) [EOL] iot_data = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def get_lightsail_public_dns_name ( instance ) : [EOL] return f'{ instance [ [string] ] } [string] { janus_hosted_zone_domain }' [EOL] [EOL] [EOL] def translate_lightsail_instance ( instance ) : [EOL] return { [string] : instance [ [string] ] , [string] : get_lightsail_public_dns_name ( instance ) } [EOL] [EOL] [EOL] def get_janus_instances ( ) : [EOL] [docstring] [EOL] return list ( map ( translate_lightsail_instance , filter ( lambda instance : instance [ [string] ] . startswith ( janus_instance_name_prefix ) , lightsail . get_instances ( ) [ [string] ] ) ) ) [EOL] [EOL] [EOL] def janus_create_session ( s , url ) : [EOL] [docstring] [EOL] response = s . post ( url , data = json . dumps ( { [string] : [string] , [string] : rand_string ( ) } ) , verify = janus_verify_https , timeout = janus_connect_timeout ) . json ( ) [EOL] if response [ [string] ] != [string] : [EOL] raise RuntimeError ( f' [string] { response }' ) [EOL] return url + [string] + str ( response [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] def janus_attach_plugin ( s , session_url , plugin ) : [EOL] [docstring] [EOL] response = s . post ( session_url , data = json . dumps ( { [string] : [string] , [string] : plugin , [string] : rand_string ( ) } ) , verify = janus_verify_https , timeout = janus_connect_timeout ) . json ( ) [EOL] if response [ [string] ] != [string] : [EOL] raise RuntimeError ( f' [string] { response }' ) [EOL] return session_url + [string] + str ( response [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] def janus_send_plugin_message ( s , plugin_url , body ) : [EOL] [docstring] [EOL] response = s . post ( plugin_url , data = json . dumps ( { [string] : [string] , [string] : body , [string] : rand_string ( ) } ) , verify = janus_verify_https , timeout = janus_connect_timeout ) . json ( ) [EOL] if response [ [string] ] != [string] : [EOL] raise RuntimeError ( f' [string] { response }' ) [EOL] return response [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def janus_allocate_stream ( janus_gateway_dns_name , stream ) : [EOL] [docstring] [EOL] janus_rest_url = f' [string] { janus_gateway_dns_name } [string] ' [EOL] logger . info ( janus_rest_url ) [EOL] [EOL] [comment] [EOL] s = requests . Session ( ) [EOL] [EOL] [comment] [EOL] session_url = janus_create_session ( s , janus_rest_url ) [EOL] logger . info ( session_url ) [EOL] [EOL] [comment] [EOL] streaming_plugin_url = janus_attach_plugin ( s , session_url , [string] ) [EOL] logger . info ( streaming_plugin_url ) [EOL] [EOL] [comment] [EOL] streams = janus_send_plugin_message ( s , streaming_plugin_url , { [string] : [string] } ) [ [string] ] [EOL] logger . info ( streams ) [EOL] [EOL] rtp_port = None [EOL] stream_id = None [EOL] stream_name = None [EOL] stream_secret = None [EOL] stream_pin = None [EOL] [EOL] [comment] [EOL] if stream and stream [ [string] ] : [EOL] for st in streams : [EOL] if st . get ( [string] ) == stream [ [string] ] and st . get ( [string] ) == stream [ [string] ] : [EOL] rtp_port = stream [ [string] ] [EOL] stream_id = stream [ [string] ] [EOL] stream_name = stream [ [string] ] [EOL] stream_secret = stream [ [string] ] [EOL] stream_pin = stream [ [string] ] [EOL] [EOL] [comment] [EOL] if not ( rtp_port or stream_id or stream_name or stream_secret or stream_pin ) : [EOL] used_rtp_ports = set ( [ o [ [string] ] for o in streams ] ) [EOL] rtp_port = None [EOL] for p in janus_rtp_port_range : [EOL] if p not in used_rtp_ports : [EOL] rtp_port = p [EOL] break [EOL] [EOL] if not rtp_port : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] stream_id = rtp_port [EOL] stream_name = f' [string] { stream_id } [string] { rand_string ( size = [number] ) }' [EOL] stream_secret = rand_string ( size = [number] ) [EOL] stream_pin = rand_string ( size = [number] ) [EOL] [EOL] logger . info ( f' [string] { rtp_port } [string] { stream_name }' ) [EOL] [EOL] [comment] [EOL] data = janus_send_plugin_message ( s , streaming_plugin_url , { [string] : [string] , [string] : [string] , [string] : False , [string] : stream_id , [string] : stream_name , [string] : False , [string] : True , [string] : False , [string] : rtp_port , [string] : [number] , [string] : [string] , [string] : [string] } ) [EOL] logger . info ( data ) [EOL] [EOL] if data . get ( [string] ) or data . get ( [string] ) : [EOL] raise RuntimeError ( f' [string] { data . get ( [string] ) } [string] { data . get ( [string] ) }' ) [EOL] [EOL] streams = janus_send_plugin_message ( s , streaming_plugin_url , { [string] : [string] } ) [ [string] ] [EOL] logger . info ( streams ) [EOL] [EOL] return { [string] : janus_gateway_dns_name , [string] : janus_rest_url , [string] : session_url , [string] : streaming_plugin_url , [string] : stream_id , [string] : stream_name , [string] : stream_secret , [string] : stream_pin , [string] : rtp_port , [string] : [number] , [string] : True , [string] : int ( time ( ) ) } [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] [docstring] [EOL] logger . info ( json . dumps ( event , sort_keys = True , indent = [number] ) ) [EOL] [EOL] [comment] [EOL] thing_name = event [ [string] ] [EOL] logger . info ( thing_name ) [EOL] [EOL] [comment] [EOL] thing_shadow = json . loads ( iot_data . get_thing_shadow ( thingName = thing_name ) [ [string] ] . read ( ) . decode ( [string] ) ) [EOL] logger . info ( json . dumps ( thing_shadow , indent = [number] ) ) [EOL] [EOL] [comment] [EOL] streams = thing_shadow [ [string] ] . get ( [string] , { } ) . get ( [string] ) or { } [EOL] [EOL] [comment] [EOL] janus_instances = get_janus_instances ( ) [EOL] for instance in janus_instances : [EOL] instance_id = instance [ [string] ] [EOL] public_dns_name = instance [ [string] ] [EOL] logger . info ( f' [string] { instance_id } [string] { public_dns_name }' ) [EOL] [EOL] [comment] [EOL] primary_gateway = random . choice ( janus_instances ) [EOL] primary_gateway_dns_name = primary_gateway [ [string] ] [EOL] [EOL] standby_janus_instances = janus_instances [ : ] . remove ( primary_gateway ) [EOL] standby_gateway_dns_name = standby_janus_instances and random . choice ( standby_janus_instances ) [ [string] ] [EOL] [EOL] logger . info ( f' [string] { primary_gateway_dns_name } [string] { standby_gateway_dns_name }' ) [EOL] [EOL] [comment] [EOL] primary_stream = janus_allocate_stream ( primary_gateway_dns_name , streams . get ( [string] ) ) [EOL] standby_stream = standby_gateway_dns_name and janus_allocate_stream ( standby_gateway_dns_name , streams . get ( [string] ) ) [EOL] current_stream = streams . get ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] iot_data . update_thing_shadow ( thingName = thing_name , payload = json . dumps ( { [string] : { [string] : { [string] : { [string] : primary_stream , [string] : standby_stream , [string] : current_stream } } } } ) . encode ( [string] ) ) [EOL] [EOL] return { [string] : primary_stream , [string] : standby_stream , [string] : current_stream } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] import logging [EOL] import boto3 [EOL] import logging [EOL] import os [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] log . setLevel ( logging . DEBUG ) [EOL] [EOL] iot = boto3 . client ( [string] ) [EOL] [EOL] user_iot_policy_name = os . getenv ( [string] ) [EOL] if not user_iot_policy_name : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] [docstring] [EOL] log . debug ( f" [string] { event }" ) [EOL] event [ [string] ] = { [string] : True , [string] : True } [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] identity = f"{ event [ [string] ] } [string] { event [ [string] ] }" [EOL] print ( f" [string] { identity }" ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0