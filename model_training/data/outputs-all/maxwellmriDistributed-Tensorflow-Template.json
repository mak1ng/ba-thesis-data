from typing import List [EOL] import typing [EOL] from setuptools import find_packages [EOL] from setuptools import setup [EOL] [EOL] [comment] [EOL] REQUIRED_PACKAGES = [ [string] ] [EOL] [EOL] setup ( name = [string] , version = [string] , install_requires = REQUIRED_PACKAGES , packages = find_packages ( ) , include_package_data = True , description = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Tuple , Dict , Any [EOL] import builtins [EOL] import tensorflow [EOL] import typing [EOL] from base . data_loader import DataLoader [EOL] import tensorflow as tf [EOL] import multiprocessing [EOL] from typing import Tuple , Dict [EOL] import random [EOL] [EOL] [EOL] class TFRecordDataLoader ( DataLoader ) : [EOL] def __init__ ( self , config , mode ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( config , mode ) [EOL] [EOL] [comment] [EOL] if self . mode == [string] : [EOL] self . file_names = self . config [ [string] ] [EOL] self . batch_size = self . config [ [string] ] [EOL] elif self . mode == [string] : [EOL] self . file_names = self . config [ [string] ] [EOL] self . batch_size = self . config [ [string] ] [EOL] else : [EOL] self . file_names = self . config [ [string] ] [EOL] [EOL] def input_fn ( self ) : [EOL] [docstring] [EOL] dataset = tf . data . TFRecordDataset ( self . file_names ) [EOL] [comment] [EOL] dataset = dataset . map ( map_func = self . _parse_example , num_parallel_calls = multiprocessing . cpu_count ( ) ) [EOL] [EOL] [comment] [EOL] if self . mode == [string] : [EOL] [comment] [EOL] dataset = dataset . apply ( tf . contrib . data . shuffle_and_repeat ( buffer_size = len ( self ) // self . config [ [string] ] ) ) [EOL] else : [EOL] dataset = dataset . repeat ( self . config [ [string] ] ) [EOL] [comment] [EOL] dataset = dataset . batch ( batch_size = self . batch_size ) [EOL] return dataset [EOL] [EOL] def _parse_example ( self , example ) : [EOL] [docstring] [EOL] [comment] [EOL] with tf . device ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] features = { [string] : tf . FixedLenFeature ( shape = [ [number] , [number] , [number] ] , dtype = tf . float32 ) , [string] : tf . FixedLenFeature ( shape = [ [number] ] , dtype = tf . int64 ) , } [EOL] example = tf . parse_single_example ( example , features = features ) [EOL] [EOL] [comment] [EOL] if self . mode == [string] : [EOL] input_data = self . _augment ( example [ [string] ] ) [EOL] else : [EOL] input_data = example [ [string] ] [EOL] [EOL] return { [string] : input_data } , example [ [string] ] [EOL] [EOL] @ staticmethod def _augment ( example ) : [EOL] [docstring] [EOL] [comment] [EOL] if random . uniform ( [number] , [number] ) > [number] : [EOL] example = tf . contrib . image . rotate ( example , tf . random_uniform ( ( ) , minval = - [number] , maxval = [number] ) ) [EOL] [comment] [EOL] if random . uniform ( [number] , [number] ) > [number] : [EOL] [comment] [EOL] noise = tf . random_normal ( shape = tf . shape ( example ) , mean = [number] , stddev = [number] , dtype = tf . float32 ) [EOL] example = example + noise [EOL] example = tf . clip_by_value ( example , [number] , [number] ) [EOL] [comment] [EOL] example = tf . image . random_flip_up_down ( example ) [EOL] return tf . image . random_flip_left_right ( example ) [EOL] [EOL] def __len__ ( self ) : [EOL] [docstring] [EOL] return sum ( [number] for fn in self . file_names for _ in tf . python_io . tf_record_iterator ( fn ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $tensorflow.data.Dataset$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.Dict[builtins.str,tensorflow.Tensor],tensorflow.Tensor]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tensorflow.Tensor$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0