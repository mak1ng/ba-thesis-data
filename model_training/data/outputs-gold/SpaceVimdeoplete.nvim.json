import os [EOL] import sys [EOL] [EOL] BASE_DIR = os . path . dirname ( os . path . dirname ( __file__ ) ) [EOL] sys . path . insert ( [number] , os . path . join ( BASE_DIR , [string] ) ) [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
import deoplete . util as util [EOL] from deoplete . filter . converter_remove_overlap import overlap_length [EOL] [EOL] def test_fuzzy_escapse ( ) : [EOL] assert util . fuzzy_escape ( [string] , [number] ) == [string] [EOL] assert util . fuzzy_escape ( [string] , [number] ) == [string] [EOL] assert util . fuzzy_escape ( [string] , [number] ) == [string] [EOL] [EOL] def test_overlap_length ( ) : [EOL] assert overlap_length ( [string] , [string] ) == [number] [EOL] assert overlap_length ( [string] , [string] ) == [number] [EOL] assert overlap_length ( [string] , [string] ) == [number] [EOL] assert overlap_length ( [string] , [string] ) == [number] [EOL] assert overlap_length ( [string] , [string] ) == len ( [string] ) [EOL] [EOL] def test_charwidth ( ) : [EOL] assert util . charwidth ( [string] ) == [number] [EOL] assert util . charwidth ( [string] ) == [number] [EOL] [EOL] def test_strwidth ( ) : [EOL] assert util . strwidth ( [string] ) == [number] [EOL] assert util . strwidth ( [string] ) == [number] [EOL] assert util . strwidth ( [string] ) == [number] [EOL] [EOL] def test_truncate ( ) : [EOL] assert util . truncate ( [string] , [number] ) == [string] [EOL] assert util . truncate ( [string] , [number] ) == [string] [EOL] assert util . truncate ( [string] , [number] ) == [string] [EOL] assert util . truncate ( [string] , [number] ) == [string] [EOL] [EOL] def test_skipping ( ) : [EOL] assert util . truncate_skipping ( [string] , [number] , [string] , [number] ) == [string] [EOL] assert util . truncate_skipping ( [string] , [number] , [string] , [number] ) == [string] [EOL] assert util . truncate_skipping ( [string] , [number] , [string] , [number] ) == [string] [EOL] assert util . truncate_skipping ( [string] , [number] , [string] , [number] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Union , List , Type , Tuple , Literal , Any , Set , Dict [EOL] import msgpack [EOL] import deoplete [EOL] import builtins [EOL] import typing [EOL] import queue [EOL] import typing_extensions [EOL] import time [EOL] import os [EOL] import msgpack [EOL] import subprocess [EOL] import sys [EOL] import typing [EOL] from abc import abstractmethod [EOL] from functools import partial [EOL] from pathlib import Path [EOL] from queue import Queue [EOL] [EOL] from deoplete import logger [EOL] from deoplete . process import Process [EOL] from deoplete . util import error_tb , error , Nvim [EOL] [EOL] UserContext = typing . Dict [ str , typing . Any ] [EOL] [EOL] [EOL] class _Parent ( logger . LoggingMixin ) : [EOL] def __init__ ( self , vim ) : [EOL] self . name = [string] [EOL] [EOL] self . _vim = vim [EOL] self . _loaded_filters = set ( ) [EOL] [EOL] self . _start_process ( ) [EOL] [EOL] def enable_logging ( self ) : [EOL] self . _put ( [string] , [ ] ) [EOL] self . is_debug_enabled = True [EOL] [EOL] def add_source ( self , path ) : [EOL] self . _put ( [string] , [ path ] ) [EOL] [EOL] def add_filter ( self , path ) : [EOL] if path in self . _loaded_filters : [EOL] return [EOL] self . _loaded_filters . add ( path ) [EOL] [EOL] self . _put ( [string] , [ path ] ) [EOL] [EOL] def set_source_attributes ( self , context ) : [EOL] self . _put ( [string] , [ context ] ) [EOL] [EOL] def set_custom ( self , custom ) : [EOL] self . _put ( [string] , [ custom ] ) [EOL] [EOL] def on_event ( self , context ) : [EOL] self . _put ( [string] , [ context ] ) [EOL] [EOL] @ abstractmethod def _start_process ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def _put ( self , name , args ) : [EOL] pass [EOL] [EOL] [EOL] class SyncParent ( _Parent ) : [EOL] def _start_process ( self ) : [EOL] from deoplete . child import Child [EOL] self . _child = Child ( self . _vim ) [EOL] [EOL] def merge_results ( self , context ) : [EOL] results = self . _child . _merge_results ( context , queue_id = None ) [EOL] ret = ( results [ [string] ] , results [ [string] ] , results [ [string] ] ) if results else ( False , [ ] ) [EOL] return ret [comment] [EOL] [EOL] def _put ( self , name , args ) : [EOL] self . _child . main ( name , args , queue_id = None ) [EOL] return None [EOL] [EOL] [EOL] class AsyncParent ( _Parent ) : [EOL] def _get_python_executable ( self ) : [EOL] [docstring] [EOL] exe = sys . executable [EOL] if not os . path . basename ( exe ) . lower ( ) . startswith ( [string] ) : [EOL] check = ... [EOL] if os . name == [string] : [EOL] checks = ( [string] , [string] ) [EOL] else : [EOL] checks = ( [string] % ( sys . version_info [ [number] ] , sys . version [ [number] ] ) , [string] % ( sys . version_info [ [number] ] ) , [string] , ) [EOL] for check in checks : [comment] [EOL] guess = os . path . join ( sys . exec_prefix , check ) [comment] [EOL] if os . path . isfile ( str ( guess ) ) : [EOL] return str ( guess ) [EOL] return str ( self . _vim . vars . get ( [string] , [string] ) ) [EOL] return exe [EOL] [EOL] def _start_process ( self ) : [EOL] self . _stdin = None [EOL] self . _queue_id = [string] [EOL] self . _queue_in = Queue ( ) [comment] [EOL] self . _queue_out = Queue ( ) [comment] [EOL] self . _queue_err = Queue ( ) [comment] [EOL] self . _packer = msgpack . Packer ( use_bin_type = True , encoding = [string] , unicode_errors = [string] ) [EOL] self . _unpacker = msgpack . Unpacker ( encoding = [string] , unicode_errors = [string] ) [EOL] self . _prev_pos = [ ] [EOL] [EOL] info = None [EOL] if os . name == [string] : [EOL] info = subprocess . STARTUPINFO ( ) [EOL] info . dwFlags |= subprocess . STARTF_USESHOWWINDOW [EOL] [EOL] main = str ( Path ( __file__ ) . parent . parent . parent . parent . joinpath ( [string] , [string] , [string] ) ) [EOL] [EOL] self . _hnd = self . _vim . loop . create_task ( self . _vim . loop . subprocess_exec ( partial ( Process , self ) , self . _get_python_executable ( ) , main , self . _vim . vars [ [string] ] , startupinfo = info ) ) [EOL] [EOL] def _print_error ( self , message ) : [EOL] error ( self . _vim , message ) [EOL] [EOL] def _connect_stdin ( self , stdin ) : [EOL] self . _stdin = stdin [EOL] return self . _unpacker [EOL] [EOL] def merge_results ( self , context ) : [EOL] if ( context [ [string] ] == [string] and context [ [string] ] == self . _prev_pos and self . _queue_id ) : [EOL] [comment] [EOL] queue_id = self . _queue_id [EOL] else : [EOL] queue_id = self . _put ( [string] , [ context ] ) [comment] [EOL] if not queue_id : [EOL] return ( False , False , [ ] ) [EOL] [EOL] get = self . _get ( queue_id ) [EOL] if not get : [EOL] [comment] [EOL] self . _queue_id = queue_id [EOL] self . _prev_pos = context [ [string] ] [EOL] return ( True , False , [ ] ) [EOL] self . _queue_id = [string] [EOL] results = get [ [number] ] [EOL] return ( results [ [string] ] , results [ [string] ] , results [ [string] ] ) if results else ( False , [ ] ) [EOL] [EOL] def _put ( self , name , args ) : [EOL] if not self . _hnd : [EOL] return None [EOL] [EOL] queue_id = str ( time . time ( ) ) [EOL] msg = self . _packer . pack ( { [string] : name , [string] : args , [string] : queue_id } ) [EOL] self . _queue_in . put ( msg ) [EOL] [EOL] if self . _stdin : [EOL] try : [EOL] while not self . _queue_in . empty ( ) : [EOL] self . _stdin . write ( self . _queue_in . get_nowait ( ) ) [EOL] except BrokenPipeError : [EOL] error_tb ( self . _vim , [string] ) [EOL] error ( self . _vim , [string] + str ( self . _proc . read_error ( ) ) ) [comment] [EOL] self . _hnd = None [EOL] return queue_id [EOL] [EOL] def _get ( self , queue_id ) : [EOL] if not self . _hnd : [EOL] return [ ] [EOL] [EOL] check_stderr = self . _vim . call ( [string] , [string] ) [EOL] while check_stderr and not self . _queue_err . empty ( ) : [EOL] self . _print_error ( self . _queue_err . get_nowait ( ) ) [EOL] [EOL] outs = [ ] [EOL] while not self . _queue_out . empty ( ) : [EOL] outs . append ( self . _queue_out . get_nowait ( ) ) [EOL] try : [EOL] return [ x for x in outs if x [ [string] ] == queue_id ] [EOL] except TypeError : [EOL] error_tb ( self . _vim , [string] [string] ) [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $msgpack.Unpacker$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $UserContext$ 0 0 0 0 0 $UserContext$ 0 0 0 0 0 0 $UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class SourceInitError ( Exception ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Dict , Any , Match [EOL] import builtins [EOL] import deoplete [EOL] import typing [EOL] import re [EOL] import typing [EOL] [EOL] from deoplete . base . source import Base [EOL] from deoplete . util import ( convert2list , set_pattern , convert2candidates ) [EOL] from deoplete . util import Nvim , UserContext , Candidates [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . mark = [string] [EOL] self . rank = [number] [EOL] self . is_bytepos = True [EOL] self . min_pattern_length = [number] [EOL] [EOL] input_patterns = { } [EOL] set_pattern ( input_patterns , [string] , [ [string] , [string] , [string] ] ) [EOL] self . vars = { [string] : input_patterns , [string] : { } , } [EOL] [EOL] def get_complete_position ( self , context ) : [EOL] current_ft = self . get_buf_option ( [string] ) [EOL] [EOL] for filetype in list ( set ( [ context [ [string] ] ] + context [ [string] ] . split ( [string] ) ) ) : [EOL] pos = self . _get_complete_position ( context , current_ft , filetype ) [EOL] if pos >= [number] : [EOL] return pos [EOL] return - [number] [EOL] [EOL] def _get_complete_position ( self , context , current_ft , filetype ) : [EOL] for omnifunc in convert2list ( self . get_filetype_var ( filetype , [string] ) ) : [EOL] if omnifunc == [string] and ( filetype == current_ft or filetype in [ [string] , [string] ] ) : [EOL] omnifunc = self . get_buf_option ( [string] ) [EOL] if omnifunc == [string] : [EOL] continue [EOL] self . _omnifunc = omnifunc [EOL] for input_pattern in convert2list ( self . get_filetype_var ( filetype , [string] ) ) : [EOL] [EOL] m = re . search ( [string] + input_pattern + [string] , context [ [string] ] ) [EOL] [comment] [EOL] [comment] [EOL] if input_pattern == [string] or ( context [ [string] ] != [string] and m is None ) : [EOL] continue [EOL] [EOL] if self . _omnifunc in [ [string] , [string] , [string] , [string] ] : [EOL] [comment] [EOL] return - [number] [EOL] try : [EOL] complete_pos = int ( self . vim . call ( self . _omnifunc , [number] , [string] ) ) [EOL] except Exception : [EOL] self . print_error ( [string] + self . _omnifunc ) [EOL] return - [number] [EOL] return complete_pos [EOL] return - [number] [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] try : [EOL] candidates = self . vim . call ( self . _omnifunc , [number] , [string] ) [EOL] if isinstance ( candidates , dict ) : [EOL] candidates = candidates [ [string] ] [EOL] elif not isinstance ( candidates , list ) : [EOL] candidates = [ ] [EOL] except Exception : [EOL] candidates = [ ] [EOL] [EOL] candidates = convert2candidates ( candidates ) [EOL] [EOL] for candidate in candidates : [EOL] candidate [ [string] ] = [number] [EOL] candidate [ [string] ] = [number] [EOL] [EOL] return candidates [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 0 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $deoplete.util.UserContext$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $deoplete.util.UserContext$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $deoplete.util.UserContext$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $deoplete.util.Candidates$ 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import deoplete [EOL] from deoplete . base . source import Base as _Base [EOL] from deoplete . util import Nvim [EOL] [EOL] [EOL] class Base ( _Base ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 0 0 0 0 $deoplete.util.Nvim$ 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import deoplete [EOL] from deoplete . base . filter import Base as _Base [EOL] from deoplete . util import Nvim [EOL] [EOL] [EOL] class Base ( _Base ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 0 0 0 0 $deoplete.util.Nvim$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern [EOL] import typing [EOL] import deoplete [EOL] import re [EOL] [EOL] from deoplete . base . filter import Base [EOL] from deoplete . util import Nvim , UserContext , Candidates [EOL] [EOL] [EOL] class Filter ( Base ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . description = [string] [EOL] [EOL] def filter ( self , context ) : [EOL] p1 = re . compile ( [string] ) [EOL] p2 = re . compile ( [string] ) [EOL] for candidate in [ x for x in context [ [string] ] if not p1 . search ( x [ [string] ] ) and ( ( [string] in x and p2 . search ( x [ [string] ] ) ) or ( [string] in x and p2 . search ( x [ [string] ] ) ) ) ] : [EOL] candidate [ [string] ] += [string] [EOL] return context [ [string] ] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 0 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $deoplete.util.Candidates$ 0 0 0 $deoplete.util.UserContext$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , TextIO [EOL] import typing [EOL] import sys [EOL] import io [EOL] [EOL] from importlib . util import find_spec [EOL] if find_spec ( [string] ) : [EOL] from pynvim import attach [EOL] else : [EOL] from neovim import attach [EOL] [EOL] [EOL] def attach_vim ( serveraddr ) : [EOL] if len ( serveraddr . split ( [string] ) ) == [number] : [EOL] serveraddr , port = serveraddr . split ( [string] ) [EOL] port = int ( port ) [EOL] vim = attach ( [string] , address = serveraddr , port = port ) [EOL] else : [EOL] vim = attach ( [string] , path = serveraddr ) [EOL] [EOL] [comment] [EOL] for path in vim . call ( [string] , vim . options [ [string] ] , [string] , [number] ) . split ( [string] ) : [EOL] sys . path . append ( path ) [EOL] [comment] [EOL] del sys . path [ [number] ] [EOL] [EOL] return vim [EOL] [EOL] [EOL] class RedirectStream ( io . IOBase ) : [EOL] def __init__ ( self , handler ) : [EOL] self . handler = handler [EOL] [EOL] def write ( self , line ) : [EOL] self . handler ( line ) [EOL] [EOL] def writelines ( self , lines ) : [EOL] self . handler ( [string] . join ( lines ) ) [EOL] [EOL] [EOL] def main ( serveraddr ) : [EOL] vim = attach_vim ( serveraddr ) [EOL] from deoplete . child import Child [EOL] from deoplete . util import error_tb [EOL] stdout = sys . stdout [EOL] sys . stdout = RedirectStream ( lambda data : vim . out_write ( data ) ) [EOL] sys . stderr = RedirectStream ( lambda data : vim . err_write ( data ) ) [EOL] try : [EOL] child = Child ( vim ) [EOL] child . main_loop ( stdout ) [EOL] except Exception as exc : [EOL] error_tb ( vim , [string] % exc ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0