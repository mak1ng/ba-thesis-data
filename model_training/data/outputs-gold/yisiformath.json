from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] def method_1 ( boundary , steps ) : [EOL] [comment] [EOL] [comment] [EOL] h = ( boundary [ [number] ] - boundary [ [number] ] ) / steps [EOL] a = boundary [ [number] ] [EOL] b = boundary [ [number] ] [EOL] x_i = make_points ( a , b , h ) [EOL] y = [number] [EOL] y += ( h / [number] ) * f ( a ) [EOL] for i in x_i : [EOL] [comment] [EOL] y += h * f ( i ) [EOL] y += ( h / [number] ) * f ( b ) [EOL] return y [EOL] [EOL] def make_points ( a , b , h ) : [EOL] x = a + h [EOL] while x < ( b - h ) : [EOL] yield x [EOL] x = x + h [EOL] [EOL] def f ( x ) : [comment] [EOL] y = ( x - [number] ) * ( x - [number] ) [EOL] return y [EOL] [EOL] def main ( ) : [EOL] a = [number] [comment] [EOL] b = [number] [comment] [EOL] steps = [number] [comment] [EOL] boundary = [ a , b ] [comment] [EOL] y = method_1 ( boundary , steps ) [EOL] print ( [string] . format ( y ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] def abs_val ( num ) : [EOL] [docstring] [EOL] if num < [number] : [EOL] return - num [EOL] [EOL] [comment] [EOL] return num [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] print ( abs_val ( - [number] ) ) [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def fact ( n ) : [EOL] [docstring] [EOL] return [number] if n <= [number] else n * fact ( n - [number] ) [EOL] [EOL] [EOL] [docstring] [EOL] for i in range ( [number] , [number] ) : [EOL] print ( i , [string] , fact ( i ) , sep = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] import decimal [EOL] [docstring] [EOL] import math [EOL] import functools [EOL] import time [EOL] from decimal import getcontext , Decimal [EOL] [EOL] getcontext ( ) . prec = [number] [EOL] [EOL] [EOL] def timer_decorator ( func ) : [EOL] @ functools . wraps ( func ) def timer_wrapper ( * args , ** kwargs ) : [EOL] start = time . time ( ) [EOL] func ( * args , ** kwargs ) [EOL] end = time . time ( ) [EOL] if int ( end - start ) > [number] : [EOL] print ( f' [string] { func . __name__ } [string] { ( end - start ) : [string] } [string] ' ) [EOL] else : [EOL] print ( f' [string] { func . __name__ } [string] { ( end - start ) * [number] : [string] } [string] ' ) [EOL] return func ( * args , ** kwargs ) [EOL] return timer_wrapper [EOL] [EOL] [EOL] [comment] [EOL] class Error ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ValueTooLargeError ( Error ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ValueTooSmallError ( Error ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ValueLessThanZero ( Error ) : [EOL] [docstring] [EOL] [EOL] [EOL] def _check_number_input ( n , min_thresh , max_thresh = None ) : [EOL] [docstring] [EOL] try : [EOL] if n >= min_thresh and max_thresh is None : [EOL] return True [EOL] elif min_thresh <= n <= max_thresh : [EOL] return True [EOL] elif n < [number] : [EOL] raise ValueLessThanZero [EOL] elif n < min_thresh : [EOL] raise ValueTooSmallError [EOL] elif n > max_thresh : [EOL] raise ValueTooLargeError [EOL] except ValueLessThanZero : [EOL] print ( [string] ) [EOL] except ValueTooSmallError : [EOL] print ( f' [string] { min_thresh } [string] ' ) [EOL] except ValueTooLargeError : [EOL] print ( f' [string] { max_thresh } [string] ' ) [EOL] return False [EOL] [EOL] [EOL] @ timer_decorator def fib_iterative ( n ) : [EOL] [docstring] [EOL] n = int ( n ) [EOL] if _check_number_input ( n , [number] ) : [EOL] seq_out = [ [number] , [number] ] [EOL] a , b = [number] , [number] [EOL] for _ in range ( n - len ( seq_out ) ) : [EOL] a , b = b , a + b [EOL] seq_out . append ( b ) [EOL] return seq_out [EOL] [EOL] [EOL] @ timer_decorator def fib_formula ( n ) : [EOL] [docstring] [EOL] seq_out = [ [number] , [number] ] [EOL] n = int ( n ) [EOL] if _check_number_input ( n , [number] , [number] ) : [EOL] sqrt = Decimal ( math . sqrt ( [number] ) ) [EOL] phi_1 = Decimal ( [number] + sqrt ) / Decimal ( [number] ) [EOL] phi_2 = Decimal ( [number] - sqrt ) / Decimal ( [number] ) [EOL] for i in range ( [number] , n ) : [EOL] temp_out = ( ( phi_1 ** Decimal ( i ) ) - ( phi_2 ** Decimal ( i ) ) ) * ( Decimal ( sqrt ) ** Decimal ( - [number] ) ) [EOL] seq_out . append ( int ( temp_out ) ) [EOL] return seq_out [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] num = [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] fib_iterative ( num ) [EOL] fib_formula ( num ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0
[EOL]	0
[comment] [EOL] [EOL] def recur_luc ( n ) : [EOL] if n == [number] : [EOL] return n [EOL] if n == [number] : [EOL] return [number] [EOL] return ( recur_luc ( n - [number] ) + recur_luc ( n - [number] ) ) [EOL] [EOL] limit = int ( input ( [string] ) ) [EOL] print ( [string] ) [EOL] for i in range ( limit ) : [EOL] print ( recur_luc ( i ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] def find_min ( x ) : [EOL] min_num = x [ [number] ] [EOL] for i in x : [EOL] if min_num > i : [EOL] min_num = i [EOL] return min_num [EOL] [EOL] print ( find_min ( [ [number] , [number] , [number] , [number] , [number] , [number] , - [number] , [number] , - [number] ] ) ) [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [comment] [EOL] NUM = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] FACTORIAL = [number] [EOL] [EOL] [comment] [EOL] if NUM < [number] : [EOL] print ( [string] ) [EOL] elif NUM == [number] : [EOL] print ( [string] ) [EOL] else : [EOL] for i in range ( [number] , NUM + [number] ) : [EOL] FACTORIAL = FACTORIAL * i [EOL] print ( [string] , NUM , [string] , FACTORIAL ) [EOL]	0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def find_max ( nums ) : [EOL] max = nums [ [number] ] [EOL] for x in nums : [EOL] if x > max : [EOL] max = x [EOL] print ( max ) [EOL] [EOL] def main ( ) : [EOL] find_max ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def gcd ( a , b ) : [EOL] [docstring] [EOL] return b if a == [number] else gcd ( b % a , a ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] try : [EOL] nums = input ( [string] ) . split ( [string] ) [EOL] num_1 = int ( nums [ [number] ] ) [EOL] num_2 = int ( nums [ [number] ] ) [EOL] except ( IndexError , UnboundLocalError , ValueError ) : [EOL] print ( [string] ) [EOL] print ( f" [string] { num_1 } [string] { num_2 } [string] { gcd ( num_1 , num_2 ) }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import numpy [EOL] [EOL] [EOL] def LUDecompose ( table ) : [EOL] [comment] [EOL] [comment] [EOL] rows , columns = numpy . shape ( table ) [EOL] L = numpy . zeros ( ( rows , columns ) ) [EOL] U = numpy . zeros ( ( rows , columns ) ) [EOL] if rows != columns : [EOL] return [ ] [EOL] for i in range ( columns ) : [EOL] for j in range ( i - [number] ) : [EOL] sum = [number] [EOL] for k in range ( j - [number] ) : [EOL] sum += L [ i ] [ k ] * U [ k ] [ j ] [EOL] L [ i ] [ j ] = ( table [ i ] [ j ] - sum ) / U [ j ] [ j ] [EOL] L [ i ] [ i ] = [number] [EOL] for j in range ( i - [number] , columns ) : [EOL] sum1 = [number] [EOL] for k in range ( i - [number] ) : [EOL] sum1 += L [ i ] [ k ] * U [ k ] [ j ] [EOL] U [ i ] [ j ] = table [ i ] [ j ] - sum1 [EOL] return L , U [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] matrix = numpy . array ( [ [ [number] , - [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] L , U = LUDecompose ( matrix ) [EOL] print ( L ) [EOL] print ( U ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import math [EOL] [EOL] [EOL] def bisection ( function , a , b ) : [comment] [EOL] [EOL] start = a [EOL] end = b [EOL] if function ( a ) == [number] : [comment] [EOL] return a [EOL] elif function ( b ) == [number] : [EOL] return b [EOL] elif function ( a ) * function ( b ) > [number] : [comment] [EOL] [comment] [EOL] print ( [string] ) [EOL] return [EOL] else : [EOL] mid = start + ( end - start ) / [number] [EOL] while abs ( start - mid ) > [number] ** - [number] : [comment] [EOL] if function ( mid ) == [number] : [EOL] return mid [EOL] elif function ( mid ) * function ( start ) < [number] : [EOL] end = mid [EOL] else : [EOL] start = mid [EOL] mid = start + ( end - start ) / [number] [EOL] return mid [EOL] [EOL] [EOL] def f ( x ) : [EOL] return math . pow ( x , [number] ) - [number] * x - [number] [EOL] [EOL] if __name__ == [string] : [EOL] print ( bisection ( f , [number] , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] [EOL] def _print_dist ( dist , v ) : [EOL] print ( [string] ) [EOL] for i in range ( v ) : [EOL] for j in range ( v ) : [EOL] if dist [ i ] [ j ] != float ( [string] ) : [EOL] print ( int ( dist [ i ] [ j ] ) , end = [string] ) [EOL] else : [EOL] print ( [string] , end = [string] ) [EOL] print ( ) [EOL] [EOL] [EOL] [EOL] def floyd_warshall ( graph , v ) : [EOL] [docstring] [EOL] [EOL] dist = [ [ float ( [string] ) for _ in range ( v ) ] for _ in range ( v ) ] [EOL] [EOL] for i in range ( v ) : [EOL] for j in range ( v ) : [EOL] dist [ i ] [ j ] = graph [ i ] [ j ] [EOL] [EOL] [comment] [EOL] for k in range ( v ) : [EOL] [comment] [EOL] for i in range ( v ) : [EOL] [comment] [EOL] for j in range ( v ) : [EOL] if dist [ i ] [ k ] != float ( [string] ) and dist [ k ] [ j ] != float ( [string] ) and dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] : [EOL] dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] [EOL] [EOL] _print_dist ( dist , v ) [EOL] return dist , v [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] v = int ( input ( [string] ) ) [EOL] e = int ( input ( [string] ) ) [EOL] [EOL] graph = [ [ float ( [string] ) for i in range ( v ) ] for j in range ( v ) ] [EOL] [EOL] for i in range ( v ) : [EOL] graph [ i ] [ i ] = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( e ) : [EOL] print ( [string] , i + [number] ) [EOL] src = int ( input ( [string] ) ) [EOL] dst = int ( input ( [string] ) ) [EOL] weight = float ( input ( [string] ) ) [EOL] graph [ src ] [ dst ] = weight [EOL] [EOL] floyd_warshall ( graph , v ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 $builtins.float$ 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] from typing import List [EOL] [EOL] def rod_cutting ( prices , length ) : [EOL] [docstring] [EOL] [EOL] prices . insert ( [number] , [number] ) [EOL] if not isinstance ( length , int ) : [EOL] raise TypeError ( [string] . format ( type ( length ) . __name__ ) ) [EOL] if length < [number] : [EOL] raise ValueError ( [string] . format ( length ) ) [EOL] assert len ( prices ) - [number] >= length , [string] . format ( length ) [EOL] [EOL] return rod_cutting_recursive ( prices , length ) [EOL] [EOL] def rod_cutting_recursive ( prices , length ) : [EOL] [comment] [EOL] if length == [number] : [EOL] return [number] [EOL] value = float ( [string] ) [EOL] for firstCutLocation in range ( [number] , length + [number] ) : [EOL] value = max ( value , prices [ firstCutLocation ] + rod_cutting_recursive ( prices , length - firstCutLocation ) ) [EOL] return value [EOL] [EOL] [EOL] def main ( ) : [EOL] assert rod_cutting ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) == [number] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] def climb_stairs ( n ) : [EOL] [docstring] [EOL] assert isinstance ( n , int ) and n > [number] , [string] . format ( [number] ) [EOL] if n == [number] : return [number] [EOL] dp = [ [number] ] * ( n + [number] ) [EOL] dp [ [number] ] , dp [ [number] ] = ( [number] , [number] ) [EOL] for i in range ( [number] , n + [number] ) : [EOL] dp [ i ] = dp [ i - [number] ] + dp [ i - [number] ] [EOL] return dp [ n ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import numpy as np [EOL] import matplotlib . pyplot as plt [EOL] [EOL] [comment] [EOL] [EOL] from sklearn import datasets [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] def sigmoid_function ( z ) : [EOL] return [number] / ( [number] + np . exp ( - z ) ) [EOL] [EOL] [EOL] def cost_function ( h , y ) : [EOL] return ( - y * np . log ( h ) - ( [number] - y ) * np . log ( [number] - h ) ) . mean ( ) [EOL] [EOL] def log_likelihood ( X , Y , weights ) : [EOL] scores = np . dot ( X , weights ) [EOL] return np . sum ( Y * scores - np . log ( [number] + np . exp ( scores ) ) ) [EOL] [EOL] [comment] [EOL] def logistic_reg ( alpha , X , y , num_steps , max_iterations = [number] , ) : [EOL] converged = False [EOL] iterations = [number] [EOL] theta = np . zeros ( X . shape [ [number] ] ) [EOL] [EOL] while not converged : [EOL] z = np . dot ( X , theta ) [EOL] h = sigmoid_function ( z ) [EOL] gradient = np . dot ( X . T , h - y ) / y . size [EOL] theta = theta - alpha * gradient [EOL] z = np . dot ( X , theta ) [EOL] h = sigmoid_function ( z ) [EOL] J = cost_function ( h , y ) [EOL] iterations += [number] [comment] [EOL] weights = np . zeros ( X . shape [ [number] ] ) [EOL] for step in range ( num_steps ) : [EOL] scores = np . dot ( X , weights ) [EOL] predictions = sigmoid_function ( scores ) [EOL] if step % [number] == [number] : [EOL] print ( log_likelihood ( X , y , weights ) ) [comment] [EOL] return weights [EOL] [EOL] if iterations == max_iterations : [EOL] print ( [string] ) [EOL] print ( [string] , J ) [EOL] converged = True [EOL] return theta [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] iris = datasets . load_iris ( ) [EOL] X = iris . data [ : , : [number] ] [EOL] y = ( iris . target != [number] ) * [number] [EOL] [EOL] alpha = [number] [EOL] theta = logistic_reg ( alpha , X , y , max_iterations = [number] , num_steps = [number] ) [EOL] print ( theta ) [EOL] [EOL] [EOL] def predict_prob ( X ) : [EOL] return sigmoid_function ( np . dot ( X , theta ) ) [comment] [EOL] [EOL] [EOL] plt . figure ( figsize = ( [number] , [number] ) ) [EOL] plt . scatter ( X [ y == [number] ] [ : , [number] ] , X [ y == [number] ] [ : , [number] ] , color = [string] , label = [string] ) [EOL] plt . scatter ( X [ y == [number] ] [ : , [number] ] , X [ y == [number] ] [ : , [number] ] , color = [string] , label = [string] ) [EOL] ( x1_min , x1_max ) = ( X [ : , [number] ] . min ( ) , X [ : , [number] ] . max ( ) ) [EOL] ( x2_min , x2_max ) = ( X [ : , [number] ] . min ( ) , X [ : , [number] ] . max ( ) ) [EOL] ( xx1 , xx2 ) = np . meshgrid ( np . linspace ( x1_min , x1_max ) , np . linspace ( x2_min , x2_max ) ) [EOL] grid = np . c_ [ xx1 . ravel ( ) , xx2 . ravel ( ) ] [EOL] probs = predict_prob ( grid ) . reshape ( xx1 . shape ) [EOL] plt . contour ( xx1 , xx2 , probs , [ [number] ] , linewidths = [number] , colors = [string] , ) [EOL] [EOL] plt . legend ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import argparse [EOL] import sorts [EOL] import os [EOL] import argparse [EOL] [EOL] class FileSplitter ( object ) : [EOL] BLOCK_FILENAME_FORMAT = [string] [EOL] [EOL] def __init__ ( self , filename ) : [EOL] self . filename = filename [EOL] self . block_filenames = [ ] [EOL] [EOL] def write_block ( self , data , block_number ) : [EOL] filename = self . BLOCK_FILENAME_FORMAT . format ( block_number ) [EOL] with open ( filename , [string] ) as file : [EOL] file . write ( data ) [EOL] self . block_filenames . append ( filename ) [EOL] [EOL] def get_block_filenames ( self ) : [EOL] return self . block_filenames [EOL] [EOL] def split ( self , block_size , sort_key = None ) : [EOL] i = [number] [EOL] with open ( self . filename ) as file : [EOL] while True : [EOL] lines = file . readlines ( block_size ) [EOL] [EOL] if lines == [ ] : [EOL] break [EOL] [EOL] if sort_key is None : [EOL] lines . sort ( ) [EOL] else : [EOL] lines . sort ( key = sort_key ) [EOL] [EOL] self . write_block ( [string] . join ( lines ) , i ) [EOL] i += [number] [EOL] [EOL] def cleanup ( self ) : [EOL] map ( lambda f : os . remove ( f ) , self . block_filenames ) [EOL] [EOL] [EOL] class NWayMerge ( object ) : [EOL] def select ( self , choices ) : [EOL] min_index = - [number] [EOL] min_str = None [EOL] [EOL] for i in range ( len ( choices ) ) : [EOL] if min_str is None or choices [ i ] < min_str : [EOL] min_index = i [EOL] [EOL] return min_index [EOL] [EOL] [EOL] class FilesArray ( object ) : [EOL] def __init__ ( self , files ) : [EOL] self . files = files [EOL] self . empty = set ( ) [EOL] self . num_buffers = len ( files ) [EOL] self . buffers = { i : None for i in range ( self . num_buffers ) } [EOL] [EOL] def get_dict ( self ) : [EOL] return { i : self . buffers [ i ] for i in range ( self . num_buffers ) if i not in self . empty } [EOL] [EOL] def refresh ( self ) : [EOL] for i in range ( self . num_buffers ) : [EOL] if self . buffers [ i ] is None and i not in self . empty : [EOL] self . buffers [ i ] = self . files [ i ] . readline ( ) [EOL] [EOL] if self . buffers [ i ] == [string] : [EOL] self . empty . add ( i ) [EOL] self . files [ i ] . close ( ) [EOL] [EOL] if len ( self . empty ) == self . num_buffers : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def unshift ( self , index ) : [EOL] value = self . buffers [ index ] [EOL] self . buffers [ index ] = None [EOL] [EOL] return value [EOL] [EOL] [EOL] class FileMerger ( object ) : [EOL] def __init__ ( self , merge_strategy ) : [EOL] self . merge_strategy = merge_strategy [EOL] [EOL] def merge ( self , filenames , outfilename , buffer_size ) : [EOL] buffers = FilesArray ( self . get_file_handles ( filenames , buffer_size ) ) [EOL] with open ( outfilename , [string] , buffer_size ) as outfile : [EOL] while buffers . refresh ( ) : [EOL] min_index = self . merge_strategy . select ( buffers . get_dict ( ) ) [EOL] outfile . write ( buffers . unshift ( min_index ) ) [EOL] [EOL] def get_file_handles ( self , filenames , buffer_size ) : [EOL] files = { } [EOL] [EOL] for i in range ( len ( filenames ) ) : [EOL] files [ i ] = open ( filenames [ i ] , [string] , buffer_size ) [EOL] [EOL] return files [EOL] [EOL] [EOL] [EOL] class ExternalSort ( object ) : [EOL] def __init__ ( self , block_size ) : [EOL] self . block_size = block_size [EOL] [EOL] def sort ( self , filename , sort_key = None ) : [EOL] num_blocks = self . get_number_blocks ( filename , self . block_size ) [EOL] splitter = FileSplitter ( filename ) [EOL] splitter . split ( self . block_size , sort_key ) [EOL] [EOL] merger = FileMerger ( NWayMerge ( ) ) [EOL] buffer_size = self . block_size / ( num_blocks + [number] ) [EOL] merger . merge ( splitter . get_block_filenames ( ) , filename + [string] , buffer_size ) [EOL] [EOL] splitter . cleanup ( ) [EOL] [EOL] def get_number_blocks ( self , filename , block_size ) : [EOL] return ( os . stat ( filename ) . st_size / block_size ) + [number] [EOL] [EOL] [EOL] def parse_memory ( string ) : [EOL] if string [ - [number] ] . lower ( ) == [string] : [EOL] return int ( string [ : - [number] ] ) * [number] [EOL] elif string [ - [number] ] . lower ( ) == [string] : [EOL] return int ( string [ : - [number] ] ) * [number] * [number] [EOL] elif string [ - [number] ] . lower ( ) == [string] : [EOL] return int ( string [ : - [number] ] ) * [number] * [number] * [number] [EOL] else : [EOL] return int ( string ) [EOL] [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , default = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , nargs = [number] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] sorter = ExternalSort ( parse_memory ( args . mem ) ) [EOL] sorter . sort ( args . filename [ [number] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sorts.external_sort.FilesArray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sorts.external_sort.FilesArray$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $sorts.external_sort.FilesArray$ 0 0 0 0 0 0 0 0 0 0 $sorts.external_sort.FilesArray$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $sorts.external_sort.FileSplitter$ 0 0 0 0 0 0 $sorts.external_sort.FileSplitter$ 0 0 0 0 0 0 0 0 0 0 0 $sorts.external_sort.FileMerger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $sorts.external_sort.FileMerger$ 0 0 0 $sorts.external_sort.FileSplitter$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $sorts.external_sort.FileSplitter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] def infix_2_postfix ( Infix ) : [EOL] Stack = [ ] [EOL] Postfix = [ ] [EOL] priority = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [comment] [EOL] print_width = len ( Infix ) if( len ( Infix ) > [number] ) else [number] [EOL] [EOL] [comment] [EOL] print ( [string] . center ( [number] ) , [string] . center ( print_width ) , [string] . center ( print_width ) , sep = [string] ) [EOL] print ( [string] * ( print_width * [number] + [number] ) ) [EOL] [EOL] for x in Infix : [EOL] if ( x . isalpha ( ) or x . isdigit ( ) ) : Postfix . append ( x ) [comment] [EOL] elif ( x == [string] ) : Stack . append ( x ) [comment] [EOL] elif ( x == [string] ) : [comment] [EOL] while ( Stack [ - [number] ] != [string] ) : [EOL] Postfix . append ( Stack . pop ( ) ) [comment] [EOL] Stack . pop ( ) [EOL] else : [EOL] if ( len ( Stack ) == [number] ) : Stack . append ( x ) [comment] [EOL] else : [EOL] while ( len ( Stack ) > [number] and priority [ x ] <= priority [ Stack [ - [number] ] ] ) : [comment] [EOL] Postfix . append ( Stack . pop ( ) ) [comment] [EOL] Stack . append ( x ) [comment] [EOL] [EOL] print ( x . center ( [number] ) , ( [string] . join ( Stack ) ) . ljust ( print_width ) , ( [string] . join ( Postfix ) ) . ljust ( print_width ) , sep = [string] ) [comment] [EOL] [EOL] while ( len ( Stack ) > [number] ) : [comment] [EOL] Postfix . append ( Stack . pop ( ) ) [comment] [EOL] print ( [string] . center ( [number] ) , ( [string] . join ( Stack ) ) . ljust ( print_width ) , ( [string] . join ( Postfix ) ) . ljust ( print_width ) , sep = [string] ) [comment] [EOL] [EOL] return [string] . join ( Postfix ) [comment] [EOL] [EOL] def infix_2_prefix ( Infix ) : [EOL] Infix = list ( Infix [ : : - [number] ] ) [comment] [EOL] [EOL] for i in range ( len ( Infix ) ) : [EOL] if ( Infix [ i ] == [string] ) : Infix [ i ] = [string] [comment] [EOL] elif ( Infix [ i ] == [string] ) : Infix [ i ] = [string] [comment] [EOL] [EOL] return ( infix_2_postfix ( [string] . join ( Infix ) ) ) [ : : - [number] ] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] Infix = input ( [string] ) [comment] [EOL] Infix = [string] . join ( Infix . split ( ) ) [comment] [EOL] print ( [string] , Infix , [string] , infix_2_prefix ( Infix ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] from __future__ import print_function [EOL] [docstring] [EOL] [EOL] try : [EOL] xrange [EOL] except NameError : [EOL] xrange = range [EOL] [EOL] total = [number] [EOL] for i in xrange ( [number] , [number] ) : [EOL] total += i ** i [EOL] [EOL] [EOL] print ( str ( total ) [ - [number] : ] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] def isprime ( number ) : [EOL] for i in range ( [number] , int ( number ** [number] ) + [number] ) : [EOL] if number % i == [number] : [EOL] return False [EOL] return True [EOL] n = int ( input ( [string] ) ) [comment] [EOL] primes = [ ] [EOL] num = [number] [EOL] while len ( primes ) < n : [EOL] if isprime ( num ) : [EOL] primes . append ( num ) [EOL] num += [number] [EOL] else : [EOL] num += [number] [EOL] print ( primes [ len ( primes ) - [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0
sum = [number] [EOL] with open ( [string] , [string] ) as f : [EOL] for line in f : [EOL] sum += int ( line ) [EOL] print ( str ( sum ) [ : [number] ] ) [EOL]	$builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] n = int ( input ( ) . strip ( ) ) [EOL] [EOL] array = [ ] [EOL] for i in range ( n ) : [EOL] array . append ( int ( input ( ) . strip ( ) ) ) [EOL] [EOL] print ( str ( sum ( array ) ) [ : [number] ] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def fibonacci_genrator ( ) : [EOL] a , b = [number] , [number] [EOL] while True : [EOL] a , b = b , a + b [EOL] yield b [EOL] answer = [number] [EOL] gen = fibonacci_genrator ( ) [EOL] while len ( str ( next ( gen ) ) ) < [number] : [EOL] answer += [number] [EOL] assert answer + [number] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0
from typing import Any , Type [EOL] import typing [EOL] from __future__ import print_function [EOL] [docstring] [EOL] try : [EOL] xrange [comment] [EOL] except NameError : [EOL] xrange = range [comment] [EOL] [EOL] def is_palindrome ( n ) : [EOL] n = str ( n ) [EOL] [EOL] if n == n [ : : - [number] ] : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] total = [number] [EOL] [EOL] for i in xrange ( [number] , [number] ) : [EOL] if is_palindrome ( i ) and is_palindrome ( bin ( i ) . split ( [string] ) [ [number] ] ) : [EOL] total += i [EOL] [EOL] print ( total )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0
[comment] [EOL] from typing import Any , Callable [EOL] import typing [EOL] from __future__ import print_function [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [docstring] [EOL] [EOL] [EOL] def one_pence ( ) : [EOL] return [number] [EOL] [EOL] [EOL] def two_pence ( x ) : [EOL] return [number] if x < [number] else two_pence ( x - [number] ) + one_pence ( ) [EOL] [EOL] [EOL] def five_pence ( x ) : [EOL] return [number] if x < [number] else five_pence ( x - [number] ) + two_pence ( x ) [EOL] [EOL] [EOL] def ten_pence ( x ) : [EOL] return [number] if x < [number] else ten_pence ( x - [number] ) + five_pence ( x ) [EOL] [EOL] [EOL] def twenty_pence ( x ) : [EOL] return [number] if x < [number] else twenty_pence ( x - [number] ) + ten_pence ( x ) [EOL] [EOL] [EOL] def fifty_pence ( x ) : [EOL] return [number] if x < [number] else fifty_pence ( x - [number] ) + twenty_pence ( x ) [EOL] [EOL] [EOL] def one_pound ( x ) : [EOL] return [number] if x < [number] else one_pound ( x - [number] ) + fifty_pence ( x ) [EOL] [EOL] [EOL] def two_pound ( x ) : [EOL] return [number] if x < [number] else two_pound ( x - [number] ) + one_pound ( x ) [EOL] [EOL] [EOL] print ( two_pound ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] from __future__ import print_function [EOL] from math import sqrt [EOL] [EOL] try : [EOL] xrange [comment] [EOL] except NameError : [EOL] xrange = range [comment] [EOL] [EOL] def is_prime ( n ) : [EOL] for i in xrange ( [number] , int ( sqrt ( n ) ) + [number] ) : [EOL] if n % i == [number] : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def sum_of_primes ( n ) : [EOL] if n > [number] : [EOL] sumOfPrimes = [number] [EOL] else : [EOL] return [number] [EOL] [EOL] for i in xrange ( [number] , n , [number] ) : [EOL] if is_prime ( i ) : [EOL] sumOfPrimes += i [EOL] [EOL] return sumOfPrimes [EOL] [EOL] if __name__ == [string] : [EOL] import sys [EOL] [EOL] if len ( sys . argv ) == [number] : [EOL] print ( sum_of_primes ( [number] ) ) [EOL] else : [EOL] try : [EOL] n = int ( sys . argv [ [number] ] ) [EOL] print ( sum_of_primes ( n ) ) [EOL] except ValueError : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0
from math import factorial [EOL] def main ( ) : [EOL] print ( sum ( [ int ( x ) for x in str ( factorial ( [number] ) ) ] ) ) [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
a = [number] [EOL] result = [number] [EOL] while a < [number] : [EOL] if ( a % [number] == [number] or a % [number] == [number] ) : [EOL] result += a [EOL] elif ( a % [number] == [number] ) : [EOL] result -= a [EOL] a += [number] [EOL] print ( result ) [EOL]	$builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0
import builtins [EOL] from typing import Any , Callable [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] n = int ( raw_input ( ) . strip ( ) ) [EOL] print ( sum ( [ e for e in range ( [number] , n ) if e % [number] == [number] or e % [number] == [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] suma = [number] [EOL] sumb = [number] [EOL] n = int ( input ( ) ) [EOL] for i in range ( [number] , n + [number] ) : [EOL] suma += i ** [number] [EOL] sumb += i [EOL] sum = sumb ** [number] - suma [EOL] print ( sum ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [docstring] [EOL] from __future__ import print_function [EOL] n = int ( input ( ) ) [EOL] suma = n * ( n + [number] ) / [number] [EOL] suma **= [number] [EOL] sumb = n * ( n + [number] ) * ( [number] * n + [number] ) / [number] [EOL] print ( suma - sumb ) [EOL]	0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0
[docstring] [EOL] from __future__ import print_function [EOL] import math [EOL] def problem6 ( number = [number] ) : [EOL] sum_of_squares = sum ( [ i * i for i in range ( [number] , number + [number] ) ] ) [EOL] square_of_sum = int ( math . pow ( sum ( range ( [number] , number + [number] ) ) , [number] ) ) [EOL] return square_of_sum - sum_of_squares [EOL] def main ( ) : [EOL] print ( problem6 ( ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] def main ( ) : [EOL] with open ( [string] , [string] ) as f : [EOL] l = [ ] [EOL] for i in range ( [number] ) : [EOL] l . append ( [ int ( x ) for x in f . readline ( ) . split ( ) ] ) [EOL] [EOL] maximum = [number] [EOL] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] for j in range ( [number] ) : [EOL] temp = l [ i ] [ j ] * l [ i ] [ j + [number] ] * l [ i ] [ j + [number] ] * l [ i ] [ j + [number] ] [EOL] if temp > maximum : [EOL] maximum = temp [EOL] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] for j in range ( [number] ) : [EOL] temp = l [ i ] [ j ] * l [ i + [number] ] [ j ] * l [ i + [number] ] [ j ] * l [ i + [number] ] [ j ] [EOL] if temp > maximum : [EOL] maximum = temp [EOL] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] for j in range ( [number] ) : [EOL] temp = l [ i ] [ j ] * l [ i + [number] ] [ j + [number] ] * l [ i + [number] ] [ j + [number] ] * l [ i + [number] ] [ j + [number] ] [EOL] if temp > maximum : [EOL] maximum = temp [EOL] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] for j in range ( [number] , [number] ) : [EOL] temp = l [ i ] [ j ] * l [ i + [number] ] [ j - [number] ] * l [ i + [number] ] [ j - [number] ] * l [ i + [number] ] [ j - [number] ] [EOL] if temp > maximum : [EOL] maximum = temp [EOL] print ( maximum ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import typing [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] collectPowers = set ( ) [EOL] [EOL] currentPow = [number] [EOL] [EOL] N = [number] [comment] [EOL] [EOL] for a in range ( [number] , N ) : [EOL] for b in range ( [number] , N ) : [EOL] currentPow = a ** b [comment] [EOL] collectPowers . add ( currentPow ) [comment] [EOL] [EOL] print ( [string] , len ( collectPowers ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] def fib ( n ) : [EOL] [docstring] [EOL] ls = [ ] [EOL] a , b = [number] , [number] [EOL] while b < n : [EOL] if b % [number] == [number] : [EOL] ls . append ( b ) [EOL] a , b = b , a + b [EOL] return ls [EOL] [EOL] if __name__ == [string] : [EOL] n = int ( input ( [string] ) . strip ( ) ) [EOL] print ( sum ( fib ( n ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0
[docstring] [EOL] from __future__ import print_function [EOL] [EOL] n = int ( input ( ) ) [EOL] i = [number] [EOL] while [number] : [EOL] i += n * ( n - [number] ) [EOL] nfound = [number] [EOL] for j in range ( [number] , n ) : [EOL] if ( i % j != [number] ) : [EOL] nfound = [number] [EOL] break [EOL] if ( nfound == [number] ) : [EOL] if ( i == [number] ) : [EOL] i = [number] [EOL] print ( i ) [EOL] break [EOL]	0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0
from typing import List [EOL] import typing [EOL] from itertools import permutations [EOL] def main ( ) : [EOL] result = list ( map ( [string] . join , permutations ( [string] ) ) ) [EOL] print ( result [ [number] ] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import print_function [EOL] n = [number] ** [number] [EOL] r = [number] [EOL] while n : [EOL] r , n = r + n % [number] , n // [number] [EOL] print ( r ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] def b_expo ( a , b ) : [EOL] res = [number] [EOL] while b > [number] : [EOL] if b & [number] : [EOL] res += a [EOL] [EOL] a += a [EOL] b >>= [number] [EOL] [EOL] return res [EOL] [EOL] [EOL] def b_expo_mod ( a , b , c ) : [EOL] res = [number] [EOL] while b > [number] : [EOL] if b & [number] : [EOL] res = ( ( res % c ) + ( a % c ) ) % c [EOL] [EOL] a += a [EOL] b >>= [number] [EOL] [EOL] return res [EOL] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] import numpy as np [EOL] import random , sys [EOL] from matplotlib import pyplot as plt [EOL] from matplotlib . colors import ListedColormap [EOL] [EOL] usage_doc = [string] [EOL] [EOL] choice = [ [number] ] * [number] + [ [number] ] * [number] [EOL] random . shuffle ( choice ) [EOL] [EOL] def create_canvas ( size ) : [EOL] canvas = [ [ False for i in range ( size ) ] for j in range ( size ) ] [EOL] return canvas [EOL] [EOL] def seed ( canvas ) : [EOL] for i , row in enumerate ( canvas ) : [EOL] for j , _ in enumerate ( row ) : [EOL] canvas [ i ] [ j ] = bool ( random . getrandbits ( [number] ) ) [EOL] [EOL] def run ( canvas ) : [EOL] [docstring] [EOL] canvas = np . array ( canvas ) [EOL] next_gen_canvas = np . array ( create_canvas ( canvas . shape [ [number] ] ) ) [EOL] for r , row in enumerate ( canvas ) : [EOL] for c , pt in enumerate ( row ) : [EOL] [comment] [EOL] next_gen_canvas [ r ] [ c ] = __judge_point ( pt , canvas [ r - [number] : r + [number] , c - [number] : c + [number] ] ) [EOL] [EOL] canvas = next_gen_canvas [EOL] del next_gen_canvas [comment] [EOL] return canvas . tolist ( ) [EOL] [EOL] def __judge_point ( pt , neighbours ) : [EOL] dead = [number] [EOL] alive = [number] [EOL] [comment] [EOL] for i in neighbours : [EOL] for status in i : [EOL] if status : alive += [number] [EOL] else : dead += [number] [EOL] [EOL] [comment] [EOL] if pt : alive -= [number] [EOL] else : dead -= [number] [EOL] [EOL] [comment] [EOL] state = pt [EOL] if pt : [EOL] if alive < [number] : [EOL] state = False [EOL] elif alive == [number] or alive == [number] : [EOL] state = True [EOL] elif alive > [number] : [EOL] state = False [EOL] else : [EOL] if alive == [number] : [EOL] state = True [EOL] [EOL] return state [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) != [number] : raise Exception ( usage_doc ) [EOL] [EOL] canvas_size = int ( sys . argv [ [number] ] ) [EOL] [comment] [EOL] c = create_canvas ( canvas_size ) [EOL] seed ( c ) [EOL] fig , ax = plt . subplots ( ) [EOL] fig . show ( ) [EOL] cmap = ListedColormap ( [ [string] , [string] ] ) [EOL] try : [EOL] while True : [EOL] c = run ( c ) [EOL] ax . matshow ( c , cmap = cmap ) [EOL] fig . canvas . draw ( ) [EOL] ax . cla ( ) [EOL] except KeyboardInterrupt : [EOL] [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] from __future__ import print_function [EOL] import pprint , time [EOL] [EOL] def getWordPattern ( word ) : [EOL] word = word . upper ( ) [EOL] nextNum = [number] [EOL] letterNums = { } [EOL] wordPattern = [ ] [EOL] [EOL] for letter in word : [EOL] if letter not in letterNums : [EOL] letterNums [ letter ] = str ( nextNum ) [EOL] nextNum += [number] [EOL] wordPattern . append ( letterNums [ letter ] ) [EOL] return [string] . join ( wordPattern ) [EOL] [EOL] def main ( ) : [EOL] startTime = time . time ( ) [EOL] allPatterns = { } [EOL] [EOL] with open ( [string] ) as fo : [EOL] wordList = fo . read ( ) . split ( [string] ) [EOL] [EOL] for word in wordList : [EOL] pattern = getWordPattern ( word ) [EOL] [EOL] if pattern not in allPatterns : [EOL] allPatterns [ pattern ] = [ word ] [EOL] else : [EOL] allPatterns [ pattern ] . append ( word ) [EOL] [EOL] with open ( [string] , [string] ) as fo : [EOL] fo . write ( pprint . pformat ( allPatterns ) ) [EOL] [EOL] totalTime = round ( time . time ( ) - startTime , [number] ) [EOL] print ( ( [string] , totalTime , [string] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , Dict , List [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] [EOL] def is_balanced ( S ) : [EOL] [EOL] stack = [ ] [EOL] open_brackets = set ( { [string] , [string] , [string] } ) [EOL] closed_brackets = set ( { [string] , [string] , [string] } ) [EOL] open_to_closed = dict ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] for i in range ( len ( S ) ) : [EOL] [EOL] if S [ i ] in open_brackets : [EOL] stack . append ( S [ i ] ) [EOL] [EOL] elif S [ i ] in closed_brackets : [EOL] if len ( stack ) == [number] or ( len ( stack ) > [number] and open_to_closed [ stack . pop ( ) ] != S [ i ] ) : [EOL] return False [EOL] [EOL] return len ( stack ) == [number] [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] S = input ( [string] ) [EOL] [EOL] if is_balanced ( S ) : [EOL] print ( ( S , [string] ) ) [EOL] [EOL] else : [EOL] print ( ( S , [string] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0