	0
	0
[comment] [EOL] [EOL] import builtins [EOL] import typing [EOL] class Message ( object ) : [EOL] message = [string] [EOL] message_args = ( ) [EOL] def __init__ ( self , filename , lineno , col = None ) : [EOL] self . filename = filename [EOL] self . lineno = lineno [EOL] self . col = col [EOL] def __str__ ( self ) : [EOL] if self . col is not None : [EOL] return [string] % ( self . filename , self . lineno , self . col , self . message % self . message_args ) [EOL] else : [EOL] return [string] % ( self . filename , self . lineno , self . message % self . message_args ) [EOL] [EOL] [EOL] class UnusedImport ( Message ) : [EOL] message = [string] [EOL] def __init__ ( self , filename , lineno , name ) : [EOL] Message . __init__ ( self , filename , lineno ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class RedefinedWhileUnused ( Message ) : [EOL] message = [string] [EOL] def __init__ ( self , filename , lineno , col , name , orig_lineno ) : [EOL] Message . __init__ ( self , filename , lineno ) [EOL] self . message_args = ( name , orig_lineno ) [EOL] [EOL] [EOL] class ImportShadowedByLoopVar ( Message ) : [EOL] message = [string] [EOL] def __init__ ( self , filename , lineno , col , name , orig_lineno ) : [EOL] Message . __init__ ( self , filename , lineno , col ) [EOL] self . message_args = ( name , orig_lineno ) [EOL] [EOL] [EOL] class ImportStarUsed ( Message ) : [EOL] message = [string] [EOL] def __init__ ( self , filename , lineno , col , modname ) : [EOL] Message . __init__ ( self , filename , lineno , col ) [EOL] self . message_args = ( modname , ) [EOL] [EOL] [EOL] class UndefinedName ( Message ) : [EOL] message = [string] [EOL] def __init__ ( self , filename , lineno , col , name ) : [EOL] Message . __init__ ( self , filename , lineno , col ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class UndefinedLocal ( Message ) : [EOL] message = [string] [EOL] def __init__ ( self , filename , lineno , col , name , orig_lineno , orig_col ) : [EOL] Message . __init__ ( self , filename , lineno ) [EOL] self . message_args = ( name , orig_lineno ) [EOL] [EOL] [EOL] class DuplicateArgument ( Message ) : [EOL] message = [string] [EOL] def __init__ ( self , filename , lineno , col , name ) : [EOL] Message . __init__ ( self , filename , lineno , col ) [EOL] self . message_args = ( name , ) [EOL] [EOL] [EOL] class RedefinedFunction ( Message ) : [EOL] message = [string] [EOL] def __init__ ( self , filename , lineno , name , orig_lineno ) : [EOL] Message . __init__ ( self , filename , lineno ) [EOL] self . message_args = ( name , orig_lineno ) [EOL] [EOL] [EOL] class LateFutureImport ( Message ) : [EOL] message = [string] [EOL] def __init__ ( self , filename , lineno , col , names ) : [EOL] Message . __init__ ( self , filename , lineno ) [EOL] self . message_args = ( names , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Type , Tuple , Any , List [EOL] import vim [EOL] import typing [EOL] import ast [EOL] import _ast [EOL] import ast [EOL] from pyflakes import messages [EOL] import __builtin__ [EOL] [EOL] [EOL] allowed_before_future = ( ast . Module , ast . ImportFrom , ast . Expr , ast . Str ) [EOL] defined_names = set ( ( [string] , [string] ) ) [EOL] [EOL] class Binding ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , name , source ) : [EOL] self . name = name [EOL] self . source = source [EOL] self . used = False [EOL] [EOL] def __str__ ( self ) : [EOL] return self . name [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . name , self . source . lineno , id ( self ) ) [EOL] [EOL] class UnBinding ( Binding ) : [EOL] [docstring] [EOL] [EOL] class Importation ( Binding ) : [EOL] def __init__ ( self , name , source ) : [EOL] name = name . split ( [string] ) [ [number] ] [EOL] super ( Importation , self ) . __init__ ( name , source ) [EOL] [EOL] class Assignment ( Binding ) : [EOL] pass [EOL] [EOL] class FunctionDefinition ( Binding ) : [EOL] pass [EOL] [EOL] [EOL] class Scope ( dict ) : [EOL] import_starred = False [comment] [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , id ( self ) , dict . __repr__ ( self ) ) [EOL] [EOL] def __init__ ( self ) : [EOL] super ( Scope , self ) . __init__ ( ) [EOL] [EOL] class ClassScope ( Scope ) : [EOL] pass [EOL] [EOL] [EOL] [EOL] class FunctionScope ( Scope ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] super ( FunctionScope , self ) . __init__ ( ) [EOL] self . globals = { } [EOL] [EOL] [EOL] [EOL] class ModuleScope ( Scope ) : [EOL] pass [EOL] [EOL] class Checker ( ast . NodeVisitor ) : [EOL] def __init__ ( self , tree , filename = [string] , builtins = None ) : [EOL] ast . NodeVisitor . __init__ ( self ) [EOL] [EOL] self . deferred = [ ] [EOL] self . dead_scopes = [ ] [EOL] self . messages = [ ] [EOL] self . filename = filename [EOL] self . scope_stack = [ ModuleScope ( ) ] [EOL] self . futures_allowed = True [EOL] self . builtins = frozenset ( builtins or [ ] ) [EOL] [EOL] self . visit ( tree ) [EOL] for handler , scope in self . deferred : [EOL] self . scope_stack = scope [EOL] handler ( ) [EOL] del self . scope_stack [ [number] : ] [EOL] self . pop_scope ( ) [EOL] self . check_dead_scopes ( ) [EOL] [EOL] def defer ( self , callable ) : [EOL] [docstring] [EOL] self . deferred . append ( ( callable , self . scope_stack [ : ] ) ) [EOL] [EOL] def check_dead_scopes ( self ) : [EOL] [comment] [EOL] for scope in self . dead_scopes : [EOL] for importation in scope . itervalues ( ) : [EOL] if isinstance ( importation , Importation ) and not importation . used : [EOL] self . report ( messages . UnusedImport , importation . source . lineno , importation . name ) [EOL] [EOL] def push_function_scope ( self ) : [EOL] self . scope_stack . append ( FunctionScope ( ) ) [EOL] [EOL] def push_class_scope ( self ) : [EOL] self . scope_stack . append ( ClassScope ( ) ) [EOL] [EOL] def pop_scope ( self ) : [EOL] scope = self . scope_stack . pop ( ) [EOL] self . dead_scopes . append ( scope ) [EOL] [EOL] @ property def scope ( self ) : [EOL] return self . scope_stack [ - [number] ] [EOL] [EOL] def report ( self , message_class , * args , ** kwargs ) : [EOL] self . messages . append ( message_class ( self . filename , * args , ** kwargs ) ) [EOL] [EOL] def visit_Import ( self , node ) : [EOL] for name_node in node . names : [EOL] [comment] [EOL] name = name_node . asname or name_node . name [EOL] self . add_binding ( node , Importation ( name , node ) ) [EOL] [EOL] def visit_GeneratorExp ( self , node ) : [EOL] for generator in node . generators : [EOL] self . visit ( generator . iter ) [EOL] self . assign_vars ( generator . target ) [EOL] [EOL] for generator in node . generators : [EOL] if hasattr ( node , [string] ) : [EOL] self . visit ( node . elt ) [EOL] [EOL] self . visit_nodes ( generator . ifs ) [EOL] [EOL] visit_ListComp = visit_GeneratorExp [EOL] [EOL] def visit_For ( self , node ) : [EOL] [docstring] [EOL] self . visit_nodes ( node . iter ) [EOL] [EOL] for var in self . flatten ( node . target ) : [EOL] upval = self . scope . get ( var . id ) [EOL] if isinstance ( upval , Importation ) and upval . used : [EOL] self . report ( messages . ImportShadowedByLoopVar , node . lineno , node . col_offset , var . id , upval . source . lineno ) [EOL] [EOL] self . add_binding ( var , Assignment ( var . id , var ) ) [EOL] [EOL] self . visit_nodes ( node . body + node . orelse ) [EOL] [EOL] def visit_FunctionDef ( self , node ) : [EOL] [EOL] try : [EOL] decorators = node . decorator_list [EOL] except AttributeError : [EOL] [comment] [EOL] decorators = node . decorators [EOL] [EOL] self . visit_nodes ( decorators ) [EOL] self . add_binding ( node , FunctionDefinition ( node . name , node ) ) [EOL] self . visit_Lambda ( node ) [EOL] [EOL] def visit_Lambda ( self , node ) : [EOL] self . visit_nodes ( node . args . defaults ) [EOL] [EOL] def run_function ( ) : [EOL] self . push_function_scope ( ) [EOL] [EOL] [comment] [EOL] argnames = set ( ) [EOL] for arg in self . flatten ( node . args . args ) : [EOL] if arg . id in argnames : [EOL] self . report ( messages . DuplicateArgument , arg . lineno , arg . col_offset , arg . id ) [EOL] argnames . add ( arg . id ) [EOL] [EOL] self . assign_vars ( node . args . args , report_redef = False ) [EOL] if node . args . vararg is not None : [EOL] self . add_binding ( node , Assignment ( node . args . vararg , node ) , False ) [EOL] if node . args . kwarg is not None : [EOL] self . add_binding ( node , Assignment ( node . args . kwarg , node ) , False ) [EOL] self . visit_nodes ( node . body ) [EOL] self . pop_scope ( ) [EOL] [EOL] self . defer ( run_function ) [EOL] [EOL] def visit_Name ( self , node ) : [EOL] [docstring] [EOL] scope , name = self . scope , node . id [EOL] [EOL] [comment] [EOL] import_starred = scope . import_starred [EOL] try : [EOL] scope [ name ] . used = ( scope , node . lineno , node . col_offset ) [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] return [EOL] [EOL] [comment] [EOL] for func_scope in self . scope_stack [ - [number] : [number] : - [number] ] : [EOL] import_starred = import_starred or func_scope . import_starred [EOL] if not isinstance ( func_scope , FunctionScope ) : [EOL] continue [EOL] try : [EOL] func_scope [ name ] . used = ( scope , node . lineno , node . col_offset ) [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] return [EOL] [EOL] [comment] [EOL] import_starred = import_starred or self . scope_stack [ [number] ] . import_starred [EOL] try : [EOL] self . scope_stack [ [number] ] [ node . id ] . used = ( scope , node . lineno , node . col_offset ) [EOL] except KeyError : [EOL] if not import_starred and not self . is_builtin ( name ) : [EOL] self . report ( messages . UndefinedName , node . lineno , node . col_offset , name ) [EOL] [EOL] def assign_vars ( self , targets , report_redef = True ) : [EOL] scope = self . scope [EOL] [EOL] for target in self . flatten ( targets ) : [EOL] name = target . id [EOL] [comment] [EOL] if isinstance ( scope , FunctionScope ) and name not in scope : [EOL] [comment] [EOL] for upscope in self . scope_stack [ : - [number] ] : [EOL] if not isinstance ( upscope , ( FunctionScope , ModuleScope ) ) : [EOL] continue [EOL] [EOL] upval = upscope . get ( name ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if upval is not None : [EOL] if upval . used and upval . used [ [number] ] is scope and name not in scope . globals : [EOL] [comment] [EOL] self . report ( messages . UndefinedLocal , upval . used [ [number] ] , upval . used [ [number] ] , name , upval . source . lineno , upval . source . col_offset ) [EOL] [EOL] self . add_binding ( target , Assignment ( name , target ) , report_redef ) [EOL] [EOL] def visit_Assign ( self , node ) : [EOL] for target in node . targets : [EOL] self . visit_nodes ( node . value ) [EOL] self . assign_vars ( node . targets ) [EOL] [EOL] def visit_Delete ( self , node ) : [EOL] for target in self . flatten ( node . targets ) : [EOL] if isinstance ( self . scope , FunctionScope ) and target . id in self . scope . globals : [EOL] del self . scope . globals [ target . id ] [EOL] else : [EOL] self . add_binding ( target , UnBinding ( target . id , target ) ) [EOL] [EOL] def visit_With ( self , node ) : [EOL] self . visit ( node . context_expr ) [EOL] [EOL] [comment] [EOL] if node . optional_vars is not None : [EOL] self . assign_vars ( node . optional_vars ) [EOL] [EOL] self . visit_nodes ( node . body ) [EOL] [EOL] def visit_ImportFrom ( self , node ) : [EOL] if node . module == [string] : [EOL] if not self . futures_allowed : [EOL] self . report ( messages . LateFutureImport , node . lineno , node . col_offset , [ alias . name for alias in node . names ] ) [EOL] else : [EOL] self . futures_allowed = False [EOL] [EOL] for alias in node . names : [EOL] if alias . name == [string] : [EOL] self . scope . import_starred = True [EOL] self . report ( messages . ImportStarUsed , node . lineno , node . col_offset , node . module ) [EOL] continue [EOL] name = alias . asname or alias . name [EOL] importation = Importation ( name , node ) [EOL] if node . module == [string] : [EOL] importation . used = ( self . scope , node . lineno , node . col_offset ) [EOL] self . add_binding ( node , importation ) [EOL] [EOL] def visit_Global ( self , node ) : [EOL] [docstring] [EOL] scope = self . scope [EOL] if isinstance ( scope , FunctionScope ) : [EOL] scope . globals . update ( dict . fromkeys ( node . names ) ) [EOL] [EOL] def visit_ClassDef ( self , node ) : [EOL] self . add_binding ( node , Assignment ( node . name , node ) ) [EOL] self . visit_nodes ( node . bases ) [EOL] [EOL] self . push_class_scope ( ) [EOL] self . visit_nodes ( node . body ) [EOL] self . pop_scope ( ) [EOL] [EOL] def visit_excepthandler ( self , node ) : [EOL] if node . type is not None : [EOL] self . visit ( node . type ) [EOL] if node . name is not None : [EOL] self . assign_vars ( node . name ) [EOL] self . visit_nodes ( node . body ) [EOL] [EOL] visit_ExceptHandler = visit_excepthandler [comment] [EOL] [EOL] def flatten ( self , nodes ) : [EOL] if isinstance ( nodes , ast . Attribute ) : [EOL] self . visit ( nodes ) [EOL] return [ ] [EOL] elif isinstance ( nodes , ast . Subscript ) : [EOL] self . visit ( nodes . value ) [EOL] self . visit ( nodes . slice ) [EOL] return [ ] [EOL] elif isinstance ( nodes , ast . Name ) : [EOL] return [ nodes ] [EOL] elif isinstance ( nodes , ( ast . Tuple , ast . List ) ) : [EOL] return self . flatten ( nodes . elts ) [EOL] [EOL] flattened_nodes = [ ] [EOL] for node in nodes : [EOL] if hasattr ( node , [string] ) : [EOL] flattened_nodes += self . flatten ( node . elts ) [EOL] elif node is not None : [EOL] flattened_nodes += self . flatten ( node ) [EOL] [EOL] return flattened_nodes [EOL] [EOL] def add_binding ( self , node , value , report_redef = True ) : [EOL] line , col , scope , name = node . lineno , node . col_offset , self . scope , value . name [EOL] [EOL] [comment] [EOL] func = scope . get ( name ) [EOL] if ( isinstance ( func , FunctionDefinition ) and isinstance ( value , FunctionDefinition ) ) : [EOL] self . report ( messages . RedefinedFunction , line , name , func . source . lineno ) [EOL] [EOL] [comment] [EOL] if report_redef and not isinstance ( scope , ClassScope ) : [EOL] for up_scope in self . scope_stack [ : : - [number] ] : [EOL] upval = up_scope . get ( name ) [EOL] if isinstance ( upval , Importation ) and not upval . used : [EOL] self . report ( messages . RedefinedWhileUnused , line , col , name , upval . source . lineno ) [EOL] [EOL] [comment] [EOL] if isinstance ( value , UnBinding ) : [EOL] try : [EOL] del scope [ name ] [EOL] except KeyError : [EOL] self . report ( messages . UndefinedName , line , col , name ) [EOL] else : [EOL] scope [ name ] = value [EOL] [EOL] def visit ( self , node ) : [EOL] if not isinstance ( node , allowed_before_future ) : [EOL] self . futures_allowed = False [EOL] [EOL] return super ( Checker , self ) . visit ( node ) [EOL] [EOL] def visit_nodes ( self , nodes ) : [EOL] try : [EOL] nodes = list ( getattr ( nodes , [string] , nodes ) ) [EOL] except TypeError : [EOL] nodes = [ nodes ] [EOL] [EOL] for node in nodes : [EOL] self . visit ( node ) [EOL] [EOL] def is_builtin ( self , name ) : [EOL] if hasattr ( __builtin__ , name ) : [EOL] return True [EOL] if name in defined_names : [EOL] return True [EOL] if name in self . builtins : [EOL] return True [EOL] [EOL] return False [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[_ast.Module],typing.Type[_ast.ImportFrom],typing.Type[_ast.Expr],typing.Type[ast.Str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vim.ftplugin.python.shared.pyflakes.checker.Importation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vim.ftplugin.python.shared.pyflakes.checker.Importation$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vim.ftplugin.python.shared.pyflakes.checker.Importation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[_ast.Module],typing.Type[_ast.ImportFrom],typing.Type[_ast.Expr],typing.Type[ast.Str]]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from typing import TextIO , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] from StringIO import StringIO [EOL] [EOL] from twisted . python . filepath import FilePath [EOL] from twisted . trial . unittest import TestCase [EOL] [EOL] from pyflakes . scripts . pyflakes import checkPath [EOL] [EOL] def withStderrTo ( stderr , f ) : [EOL] [docstring] [EOL] ( outer , sys . stderr ) = ( sys . stderr , stderr ) [EOL] try : [EOL] return f ( ) [EOL] finally : [EOL] sys . stderr = outer [EOL] [EOL] [EOL] [EOL] class CheckTests ( TestCase ) : [EOL] [docstring] [EOL] def test_missingTrailingNewline ( self ) : [EOL] [docstring] [EOL] fName = self . mktemp ( ) [EOL] FilePath ( fName ) . setContent ( [string] ) [EOL] self . assertFalse ( checkPath ( fName ) ) [EOL] [EOL] [EOL] def test_checkPathNonExisting ( self ) : [EOL] [docstring] [EOL] err = StringIO ( ) [EOL] count = withStderrTo ( err , lambda : checkPath ( [string] ) ) [EOL] self . assertEquals ( err . getvalue ( ) , [string] ) [EOL] self . assertEquals ( count , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
	0
[EOL] from typing import Type , Any , List [EOL] import typing [EOL] import textwrap [EOL] [EOL] from twisted . trial import unittest [EOL] [EOL] from pyflakes import checker , ast [EOL] [EOL] [EOL] class Test ( unittest . TestCase ) : [EOL] [EOL] def flakes ( self , input , * expectedOutputs ) : [EOL] w = checker . Checker ( ast . parse ( textwrap . dedent ( input ) ) ) [EOL] outputs = [ type ( o ) for o in w . messages ] [EOL] expectedOutputs = list ( expectedOutputs ) [EOL] outputs . sort ( ) [EOL] expectedOutputs . sort ( ) [EOL] self . assert_ ( outputs == expectedOutputs , [string] % ( input , repr ( expectedOutputs ) , [string] . join ( [ str ( o ) for o in w . messages ] ) ) ) [EOL] return w [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Type[typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type[typing.Any]]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [EOL] from __future__ import print_function [EOL] from sys import argv , exit [EOL] [EOL] [EOL] if len ( argv ) != [number] : [EOL] exit ( [number] ) [EOL] [EOL] try : [EOL] compile ( open ( argv [ [number] ] ) . read ( ) , argv [ [number] ] , [string] , [number] , [number] ) [EOL] except SyntaxError as err : [EOL] print ( [string] % ( err . filename , err . lineno , err . offset , err . msg ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , Union , Any , List , Literal [EOL] import typing [EOL] import subprocess [EOL] import typing_extensions [EOL] import os [EOL] import subprocess [EOL] import json [EOL] import denite . util [EOL] from . base import Base [EOL] [EOL] DECLS_SYNTAX_HIGHLIGHT = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : True } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : True } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : True } , ] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = [string] [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] bin_path = self . vim . call ( [string] , [string] ) [EOL] if bin_path == [string] : [EOL] return [ ] [EOL] [EOL] expand = context [ [string] ] [ [number] ] if context [ [string] ] else [string] [EOL] target = self . vim . funcs . expand ( expand ) [EOL] [EOL] if os . path . isdir ( target ) : [EOL] mode = [string] [EOL] elif os . path . isfile ( target ) : [EOL] mode = [string] [EOL] else : [EOL] return [ ] [EOL] [EOL] if self . vim . funcs . exists ( [string] ) : [EOL] include = self . vim . eval ( [string] ) [EOL] else : [EOL] include = [string] [EOL] [EOL] command = [ bin_path , [string] , [string] , [string] , include , [string] + mode , target ] [EOL] [EOL] try : [EOL] cmd = subprocess . run ( command , stdout = subprocess . PIPE , check = True ) [EOL] except subprocess . CalledProcessError as err : [EOL] denite . util . error ( self . vim , [string] + str ( err ) ) [EOL] return [ ] [EOL] [EOL] txt = cmd . stdout . decode ( [string] ) [EOL] output = json . loads ( txt , encoding = [string] ) [EOL] [EOL] def make_candidates ( row ) : [EOL] name = self . vim . funcs . fnamemodify ( row [ [string] ] , [string] ) [EOL] return { [string] : [string] . format ( name , row [ [string] ] , row [ [string] ] ) , [string] : row [ [string] ] , [string] : row [ [string] ] , [string] : row [ [string] ] , } [EOL] return list ( map ( make_candidates , output [ [string] ] ) ) [EOL] [EOL] def highlight ( self ) : [EOL] for syn in DECLS_SYNTAX_HIGHLIGHT : [EOL] containedin = self . syntax_name [EOL] containedin += [string] + syn [ [string] ] if [string] in syn else [string] [EOL] conceal = [string] if [string] in syn else [string] [EOL] [EOL] self . vim . command ( [string] . format ( self . syntax_name , syn [ [string] ] , syn [ [string] ] , containedin , conceal ) ) [EOL] [EOL] if [string] in syn : [EOL] self . vim . command ( [string] . format ( self . syntax_name , syn [ [string] ] , syn [ [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Literal , Union , Any , List [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import typing_extensions [EOL] from setuptools import setup [EOL] import sys [EOL] import os [EOL] [EOL] assert sys . version_info >= ( [number] , [number] , [number] ) , [string] [EOL] from pathlib import Path [comment] [EOL] [EOL] CURRENT_DIR = Path ( __file__ ) . parent [EOL] sys . path . insert ( [number] , str ( CURRENT_DIR ) ) [comment] [EOL] [EOL] [EOL] def get_long_description ( ) : [EOL] readme_md = CURRENT_DIR / [string] [EOL] with open ( readme_md , encoding = [string] ) as ld_file : [EOL] return ld_file . read ( ) [EOL] [EOL] [EOL] USE_MYPYC = False [EOL] [comment] [EOL] if len ( sys . argv ) > [number] and sys . argv [ [number] ] == [string] : [EOL] sys . argv . pop ( [number] ) [EOL] USE_MYPYC = True [EOL] if os . getenv ( [string] , None ) == [string] : [EOL] USE_MYPYC = True [EOL] [EOL] if USE_MYPYC : [EOL] mypyc_targets = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] from mypyc . build import mypycify [EOL] [EOL] opt_level = os . getenv ( [string] , [string] ) [EOL] ext_modules = mypycify ( mypyc_targets , opt_level = opt_level ) [EOL] else : [EOL] ext_modules = [ ] [EOL] [EOL] setup ( name = [string] , use_scm_version = { [string] : [string] , [string] : [string] , } , description = [string] , long_description = get_long_description ( ) , long_description_content_type = [string] , keywords = [string] , author = [string] , author_email = [string] , url = [string] , license = [string] , py_modules = [ [string] , [string] , [string] ] , ext_modules = ext_modules , packages = [ [string] , [string] ] , package_data = { [string] : [ [string] ] } , python_requires = [string] , zip_safe = False , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , extras_require = { [string] : [ [string] , [string] ] } , test_suite = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , entry_points = { [string] : [ [string] , [string] , ] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import builtins [EOL] from typing import Dict , Tuple , Any , Union , List [EOL] import pathlib [EOL] import typing [EOL] import io [EOL] from pathlib import Path [EOL] import regex as re [EOL] import shutil [EOL] import string [EOL] [EOL] from setuptools_scm import get_version [EOL] from recommonmark . parser import CommonMarkParser [EOL] [EOL] [EOL] CURRENT_DIR = Path ( __file__ ) . parent [EOL] [EOL] [EOL] def make_pypi_svg ( version ) : [EOL] template = CURRENT_DIR / [string] / [string] [EOL] target = CURRENT_DIR / [string] / [string] [EOL] with open ( str ( template ) , [string] , encoding = [string] ) as f : [EOL] svg = string . Template ( f . read ( ) ) . substitute ( version = version ) [EOL] with open ( str ( target ) , [string] , encoding = [string] ) as f : [EOL] f . write ( svg ) [EOL] [EOL] [EOL] def make_filename ( line ) : [EOL] non_letters = re . compile ( [string] ) [EOL] filename = line [ [number] : ] . rstrip ( ) . lower ( ) [EOL] filename = non_letters . sub ( [string] , filename ) [EOL] if filename . startswith ( [string] ) : [EOL] filename = filename [ [number] : ] [EOL] if filename . endswith ( [string] ) : [EOL] filename = filename [ : - [number] ] [EOL] return filename + [string] [EOL] [EOL] [EOL] def generate_sections_from_readme ( ) : [EOL] target_dir = CURRENT_DIR / [string] / [string] [EOL] readme = CURRENT_DIR / [string] / [string] [EOL] shutil . rmtree ( str ( target_dir ) , ignore_errors = True ) [EOL] target_dir . mkdir ( parents = True ) [EOL] [EOL] output = None [EOL] target_dir = target_dir . relative_to ( CURRENT_DIR ) [EOL] with open ( str ( readme ) , [string] , encoding = [string] ) as f : [EOL] for line in f : [EOL] if line . startswith ( [string] ) : [EOL] if output is not None : [EOL] output . close ( ) [EOL] filename = make_filename ( line ) [EOL] output_path = CURRENT_DIR / filename [EOL] if output_path . is_symlink ( ) or output_path . is_file ( ) : [EOL] output_path . unlink ( ) [EOL] output_path . symlink_to ( target_dir / filename ) [EOL] output = open ( str ( output_path ) , [string] , encoding = [string] ) [EOL] output . write ( [string] ) [EOL] [EOL] if output is None : [EOL] continue [EOL] [EOL] if line . startswith ( [string] ) : [EOL] line = line [ [number] : ] [EOL] [EOL] output . write ( line ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] release = get_version ( root = CURRENT_DIR . parent ) [EOL] [comment] [EOL] version = release [EOL] for sp in [string] : [EOL] version = version . split ( sp ) [ [number] ] [EOL] make_pypi_svg ( release ) [EOL] generate_sections_from_readme ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] source_parsers = { [string] : CommonMarkParser } [EOL] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] html_sidebars = { [string] : [ [string] , [string] , [string] , [string] , [string] , ] } [EOL] [EOL] html_theme_options = { [string] : False , [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : True , [string] : [string] , [string] : True , } [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] , ) ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] , ) ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_title = project [EOL] epub_author = author [EOL] epub_publisher = author [EOL] epub_copyright = copyright [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_exclude_files = [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] autodoc_member_order = [string] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] intersphinx_mapping = { [string] : None } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , TypeVar , Iterator , Tuple , Any , List , BinaryIO , TextIO , Generator [EOL] import aiohttp [EOL] import typing [EOL] import builtins [EOL] import click [EOL] import io [EOL] import functools [EOL] import unittest [EOL] import vim [EOL] import pathlib [EOL] import asyncio [EOL] import asyncio [EOL] import logging [EOL] from concurrent . futures import ThreadPoolExecutor [EOL] from contextlib import contextmanager [EOL] from functools import partial [EOL] from io import BytesIO , TextIOWrapper [EOL] import os [EOL] from pathlib import Path [EOL] import regex as re [EOL] import sys [EOL] from tempfile import TemporaryDirectory [EOL] from typing import Any , BinaryIO , Generator , List , Tuple , Iterator , TypeVar [EOL] import unittest [EOL] from unittest . mock import patch , MagicMock [EOL] [EOL] from click import unstyle [EOL] from click . testing import CliRunner [EOL] [EOL] import black [EOL] from black import Feature , TargetVersion [EOL] [EOL] try : [EOL] import blackd [EOL] from aiohttp . test_utils import AioHTTPTestCase , unittest_run_loop [EOL] from aiohttp import web [EOL] except ImportError : [EOL] has_blackd_deps = False [EOL] else : [EOL] has_blackd_deps = True [EOL] [EOL] from pathspec import PathSpec [EOL] [EOL] ff = partial ( black . format_file_in_place , mode = black . FileMode ( ) , fast = True ) [EOL] fs = partial ( black . format_str , mode = black . FileMode ( ) ) [EOL] THIS_FILE = Path ( __file__ ) [EOL] THIS_DIR = THIS_FILE . parent [EOL] DETERMINISTIC_HEADER = [string] [EOL] EMPTY_LINE = [string] + [string] [EOL] PY36_ARGS = [ f" [string] { version . name . lower ( ) }" for version in black . PY36_VERSIONS ] [EOL] T = TypeVar ( [string] ) [EOL] R = TypeVar ( [string] ) [EOL] [EOL] [EOL] def dump_to_stderr ( * output ) : [EOL] return [string] + [string] . join ( output ) + [string] [EOL] [EOL] [EOL] def read_data ( name , data = True ) : [EOL] [docstring] [EOL] if not name . endswith ( ( [string] , [string] , [string] , [string] ) ) : [EOL] name += [string] [EOL] _input = [ ] [EOL] _output = [ ] [EOL] base_dir = THIS_DIR / [string] if data else THIS_DIR [EOL] with open ( base_dir / name , [string] , encoding = [string] ) as test : [EOL] lines = test . readlines ( ) [EOL] result = _input [EOL] for line in lines : [EOL] line = line . replace ( EMPTY_LINE , [string] ) [EOL] if line . rstrip ( ) == [string] : [EOL] result = _output [EOL] continue [EOL] [EOL] result . append ( line ) [EOL] if _input and not _output : [EOL] [comment] [EOL] _output = _input [ : ] [EOL] return [string] . join ( _input ) . strip ( ) + [string] , [string] . join ( _output ) . strip ( ) + [string] [EOL] [EOL] [EOL] @ contextmanager def cache_dir ( exists = True ) : [EOL] with TemporaryDirectory ( ) as workspace : [EOL] cache_dir = Path ( workspace ) [EOL] if not exists : [EOL] cache_dir = cache_dir / [string] [EOL] with patch ( [string] , cache_dir ) : [EOL] yield cache_dir [EOL] [EOL] [EOL] @ contextmanager def event_loop ( close ) : [EOL] policy = asyncio . get_event_loop_policy ( ) [EOL] loop = policy . new_event_loop ( ) [EOL] asyncio . set_event_loop ( loop ) [EOL] try : [EOL] yield [EOL] [EOL] finally : [EOL] if close : [EOL] loop . close ( ) [EOL] [EOL] [EOL] @ contextmanager def skip_if_exception ( e ) : [EOL] try : [EOL] yield [EOL] except Exception as exc : [EOL] if exc . __class__ . __name__ == e : [EOL] unittest . skip ( f" [string] { exc } [string] " ) [EOL] else : [EOL] raise [EOL] [EOL] [EOL] class BlackRunner ( CliRunner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . stderrbuf = BytesIO ( ) [EOL] self . stdoutbuf = BytesIO ( ) [EOL] self . stdout_bytes = [string] [EOL] self . stderr_bytes = [string] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] @ contextmanager def isolation ( self , * args , ** kwargs ) : [EOL] with super ( ) . isolation ( * args , ** kwargs ) as output : [EOL] try : [EOL] hold_stderr = sys . stderr [EOL] sys . stderr = TextIOWrapper ( self . stderrbuf , encoding = self . charset ) [EOL] yield output [EOL] finally : [EOL] self . stdout_bytes = sys . stdout . buffer . getvalue ( ) [comment] [EOL] self . stderr_bytes = sys . stderr . buffer . getvalue ( ) [comment] [EOL] sys . stderr = hold_stderr [EOL] [EOL] [EOL] class BlackTestCase ( unittest . TestCase ) : [EOL] maxDiff = None [EOL] [EOL] def assertFormatEqual ( self , expected , actual ) : [EOL] if actual != expected and not os . environ . get ( [string] ) : [EOL] bdv = ... [EOL] black . out ( [string] , fg = [string] ) [EOL] try : [EOL] exp_node = black . lib2to3_parse ( expected ) [EOL] bdv = black . DebugVisitor ( ) [EOL] list ( bdv . visit ( exp_node ) ) [EOL] except Exception as ve : [EOL] black . err ( str ( ve ) ) [EOL] black . out ( [string] , fg = [string] ) [EOL] try : [EOL] exp_node = black . lib2to3_parse ( actual ) [EOL] bdv = black . DebugVisitor ( ) [EOL] list ( bdv . visit ( exp_node ) ) [EOL] except Exception as ve : [EOL] black . err ( str ( ve ) ) [EOL] self . assertEqual ( expected , actual ) [EOL] [EOL] def invokeBlack ( self , args , exit_code = [number] , ignore_config = True ) : [EOL] runner = BlackRunner ( ) [EOL] if ignore_config : [EOL] args = [ [string] , str ( THIS_DIR / [string] ) , * args ] [EOL] result = runner . invoke ( black . main , args ) [EOL] self . assertEqual ( result . exit_code , exit_code , msg = runner . stderr_bytes . decode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def checkSourceFile ( self , name ) : [EOL] path = THIS_DIR . parent / name [EOL] source , expected = read_data ( str ( path ) , data = False ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] self . assertFalse ( ff ( path ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_empty ( self ) : [EOL] source = expected = [string] [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] def test_empty_ff ( self ) : [EOL] expected = [string] [EOL] tmp_file = Path ( black . dump_to_file ( ) ) [EOL] try : [EOL] self . assertFalse ( ff ( tmp_file , write_back = black . WriteBack . YES ) ) [EOL] with open ( tmp_file , encoding = [string] ) as f : [EOL] actual = f . read ( ) [EOL] finally : [EOL] os . unlink ( tmp_file ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] [EOL] def test_self ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_black ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_pygram ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_pytree ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_conv ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_driver ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_grammar ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_literals ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_parse ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_pgen ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_tokenize ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_token ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_setup ( self ) : [EOL] self . checkSourceFile ( [string] ) [EOL] [EOL] def test_piping ( self ) : [EOL] source , expected = read_data ( [string] , data = False ) [EOL] result = BlackRunner ( ) . invoke ( black . main , [ [string] , [string] , f" [string] { black . DEFAULT_LINE_LENGTH }" ] , input = BytesIO ( source . encode ( [string] ) ) , ) [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL] self . assertFormatEqual ( expected , result . output ) [EOL] black . assert_equivalent ( source , result . output ) [EOL] black . assert_stable ( source , result . output , black . FileMode ( ) ) [EOL] [EOL] def test_piping_diff ( self ) : [EOL] diff_header = re . compile ( rf" [string] " rf" [string] " ) [EOL] source , _ = read_data ( [string] ) [EOL] expected , _ = read_data ( [string] ) [EOL] config = THIS_DIR / [string] / [string] [EOL] args = [ [string] , [string] , f" [string] { black . DEFAULT_LINE_LENGTH }" , [string] , f" [string] { config }" , ] [EOL] result = BlackRunner ( ) . invoke ( black . main , args , input = BytesIO ( source . encode ( [string] ) ) ) [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL] actual = diff_header . sub ( DETERMINISTIC_HEADER , result . output ) [EOL] actual = actual . rstrip ( ) + [string] [comment] [EOL] self . assertEqual ( expected , actual ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_function ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_function2 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_function_trailing_comma ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_expression ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_pep_572 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] black . assert_equivalent ( source , actual ) [EOL] [EOL] def test_pep_572_version_detection ( self ) : [EOL] source , _ = read_data ( [string] ) [EOL] root = black . lib2to3_parse ( source ) [EOL] features = black . get_features_used ( root ) [EOL] self . assertIn ( black . Feature . ASSIGNMENT_EXPRESSIONS , features ) [EOL] versions = black . detect_target_versions ( root ) [EOL] self . assertIn ( black . TargetVersion . PY38 , versions ) [EOL] [EOL] def test_expression_ff ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] tmp_file = Path ( black . dump_to_file ( source ) ) [EOL] try : [EOL] self . assertTrue ( ff ( tmp_file , write_back = black . WriteBack . YES ) ) [EOL] with open ( tmp_file , encoding = [string] ) as f : [EOL] actual = f . read ( ) [EOL] finally : [EOL] os . unlink ( tmp_file ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] with patch ( [string] , dump_to_stderr ) : [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] def test_expression_diff ( self ) : [EOL] source , _ = read_data ( [string] ) [EOL] expected , _ = read_data ( [string] ) [EOL] tmp_file = Path ( black . dump_to_file ( source ) ) [EOL] diff_header = re . compile ( rf"{ re . escape ( str ( tmp_file ) ) } [string] " rf" [string] " ) [EOL] try : [EOL] result = BlackRunner ( ) . invoke ( black . main , [ [string] , str ( tmp_file ) ] ) [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL] finally : [EOL] os . unlink ( tmp_file ) [EOL] actual = result . output [EOL] actual = diff_header . sub ( DETERMINISTIC_HEADER , actual ) [EOL] actual = actual . rstrip ( ) + [string] [comment] [EOL] if expected != actual : [EOL] dump = black . dump_to_file ( actual ) [EOL] msg = ( f" [string] " f" [string] " f" [string] { dump }" ) [EOL] self . assertEqual ( expected , actual , msg ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_fstring ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_pep_570 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] if sys . version_info >= ( [number] , [number] ) : [EOL] black . assert_equivalent ( source , actual ) [EOL] [EOL] def test_detect_pos_only_arguments ( self ) : [EOL] source , _ = read_data ( [string] ) [EOL] root = black . lib2to3_parse ( source ) [EOL] features = black . get_features_used ( root ) [EOL] self . assertIn ( black . Feature . POS_ONLY_ARGUMENTS , features ) [EOL] versions = black . detect_target_versions ( root ) [EOL] self . assertIn ( black . TargetVersion . PY38 , versions ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_string_quotes ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] mode = black . FileMode ( string_normalization = False ) [EOL] not_normalized = fs ( source , mode = mode ) [EOL] self . assertFormatEqual ( source , not_normalized ) [EOL] black . assert_equivalent ( source , not_normalized ) [EOL] black . assert_stable ( source , not_normalized , mode = mode ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_slices ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_comments ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_comments2 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_comments3 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_comments4 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_comments5 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_comments6 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_comments7 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_comment_after_escaped_newline ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_cantfit ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_import_spacing ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_composition ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_empty_lines ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_remove_parens ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_string_prefixes ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_numeric_literals ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] mode = black . FileMode ( target_versions = black . PY36_VERSIONS ) [EOL] actual = fs ( source , mode = mode ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , mode ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_numeric_literals_ignoring_underscores ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] mode = black . FileMode ( target_versions = black . PY36_VERSIONS ) [EOL] actual = fs ( source , mode = mode ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , mode ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_numeric_literals_py2 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_python2 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_python2_print_function ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] mode = black . FileMode ( target_versions = { TargetVersion . PY27 } ) [EOL] actual = fs ( source , mode = mode ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , mode ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_python2_unicode_literals ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_stub ( self ) : [EOL] mode = black . FileMode ( is_pyi = True ) [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source , mode = mode ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_stable ( source , actual , mode ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_async_as_identifier ( self ) : [EOL] source_path = ( THIS_DIR / [string] / [string] ) . resolve ( ) [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] major , minor = sys . version_info [ : [number] ] [EOL] if major < [number] or ( major <= [number] and minor < [number] ) : [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [comment] [EOL] self . invokeBlack ( [ str ( source_path ) , [string] , [string] ] ) [EOL] [comment] [EOL] self . invokeBlack ( [ str ( source_path ) , [string] , [string] ] , exit_code = [number] ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_python37 ( self ) : [EOL] source_path = ( THIS_DIR / [string] / [string] ) . resolve ( ) [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] major , minor = sys . version_info [ : [number] ] [EOL] if major > [number] or ( major == [number] and minor >= [number] ) : [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [comment] [EOL] self . invokeBlack ( [ str ( source_path ) , [string] , [string] ] ) [EOL] [comment] [EOL] self . invokeBlack ( [ str ( source_path ) , [string] , [string] ] , exit_code = [number] ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_fmtonoff ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_fmtonoff2 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_fmtonoff3 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_remove_empty_parentheses_after_class ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_new_line_between_class_and_code ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_bracket_match ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_tuple_assign ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] @ patch ( [string] , dump_to_stderr ) def test_beginning_backslash ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] def test_tab_comment_indentation ( self ) : [EOL] contents_tab = [string] [EOL] contents_spc = [string] [EOL] self . assertFormatEqual ( contents_spc , fs ( contents_spc ) ) [EOL] self . assertFormatEqual ( contents_spc , fs ( contents_tab ) ) [EOL] [EOL] contents_tab = [string] [EOL] contents_spc = [string] [EOL] self . assertFormatEqual ( contents_spc , fs ( contents_spc ) ) [EOL] self . assertFormatEqual ( contents_spc , fs ( contents_tab ) ) [EOL] [EOL] [comment] [EOL] contents_tab = [string] [EOL] contents_spc = [string] [EOL] self . assertFormatEqual ( contents_spc , fs ( contents_spc ) ) [EOL] self . assertFormatEqual ( contents_spc , fs ( contents_tab ) ) [EOL] [EOL] contents_tab = [string] [EOL] contents_spc = [string] [EOL] self . assertFormatEqual ( contents_spc , fs ( contents_spc ) ) [EOL] self . assertFormatEqual ( contents_spc , fs ( contents_tab ) ) [EOL] [EOL] def test_report_verbose ( self ) : [EOL] report = black . Report ( verbose = True ) [EOL] out_lines = [ ] [EOL] err_lines = [ ] [EOL] [EOL] def out ( msg , ** kwargs ) : [EOL] out_lines . append ( msg ) [EOL] [EOL] def err ( msg , ** kwargs ) : [EOL] err_lines . append ( msg ) [EOL] [EOL] with patch ( [string] , out ) , patch ( [string] , err ) : [EOL] report . done ( Path ( [string] ) , black . Changed . NO ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( out_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . done ( Path ( [string] ) , black . Changed . YES ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( out_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] ) [EOL] report . done ( Path ( [string] ) , black . Changed . CACHED ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( out_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . check = True [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . check = False [EOL] report . failed ( Path ( [string] ) , [string] ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( err_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . done ( Path ( [string] ) , black . Changed . YES ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( out_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . failed ( Path ( [string] ) , [string] ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( err_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . path_ignored ( Path ( [string] ) , [string] ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( out_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . done ( Path ( [string] ) , black . Changed . NO ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( out_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . check = True [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] [EOL] def test_report_quiet ( self ) : [EOL] report = black . Report ( quiet = True ) [EOL] out_lines = [ ] [EOL] err_lines = [ ] [EOL] [EOL] def out ( msg , ** kwargs ) : [EOL] out_lines . append ( msg ) [EOL] [EOL] def err ( msg , ** kwargs ) : [EOL] err_lines . append ( msg ) [EOL] [EOL] with patch ( [string] , out ) , patch ( [string] , err ) : [EOL] report . done ( Path ( [string] ) , black . Changed . NO ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . done ( Path ( [string] ) , black . Changed . YES ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] ) [EOL] report . done ( Path ( [string] ) , black . Changed . CACHED ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . check = True [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . check = False [EOL] report . failed ( Path ( [string] ) , [string] ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( err_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . done ( Path ( [string] ) , black . Changed . YES ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . failed ( Path ( [string] ) , [string] ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( err_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . path_ignored ( Path ( [string] ) , [string] ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . done ( Path ( [string] ) , black . Changed . NO ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . check = True [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] [EOL] def test_report_normal ( self ) : [EOL] report = black . Report ( ) [EOL] out_lines = [ ] [EOL] err_lines = [ ] [EOL] [EOL] def out ( msg , ** kwargs ) : [EOL] out_lines . append ( msg ) [EOL] [EOL] def err ( msg , ** kwargs ) : [EOL] err_lines . append ( msg ) [EOL] [EOL] with patch ( [string] , out ) , patch ( [string] , err ) : [EOL] report . done ( Path ( [string] ) , black . Changed . NO ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . done ( Path ( [string] ) , black . Changed . YES ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( out_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] ) [EOL] report . done ( Path ( [string] ) , black . Changed . CACHED ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( out_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . check = True [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . check = False [EOL] report . failed ( Path ( [string] ) , [string] ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( err_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . done ( Path ( [string] ) , black . Changed . YES ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( out_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . failed ( Path ( [string] ) , [string] ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( err_lines [ - [number] ] , [string] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . path_ignored ( Path ( [string] ) , [string] ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . done ( Path ( [string] ) , black . Changed . NO ) [EOL] self . assertEqual ( len ( out_lines ) , [number] ) [EOL] self . assertEqual ( len ( err_lines ) , [number] ) [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] self . assertEqual ( report . return_code , [number] ) [EOL] report . check = True [EOL] self . assertEqual ( unstyle ( str ( report ) ) , [string] [string] , ) [EOL] [EOL] def test_lib2to3_parse ( self ) : [EOL] with self . assertRaises ( black . InvalidInput ) : [EOL] black . lib2to3_parse ( [string] ) [EOL] [EOL] straddling = [string] [EOL] black . lib2to3_parse ( straddling ) [EOL] black . lib2to3_parse ( straddling , { TargetVersion . PY27 } ) [EOL] black . lib2to3_parse ( straddling , { TargetVersion . PY36 } ) [EOL] black . lib2to3_parse ( straddling , { TargetVersion . PY27 , TargetVersion . PY36 } ) [EOL] [EOL] py2_only = [string] [EOL] black . lib2to3_parse ( py2_only ) [EOL] black . lib2to3_parse ( py2_only , { TargetVersion . PY27 } ) [EOL] with self . assertRaises ( black . InvalidInput ) : [EOL] black . lib2to3_parse ( py2_only , { TargetVersion . PY36 } ) [EOL] with self . assertRaises ( black . InvalidInput ) : [EOL] black . lib2to3_parse ( py2_only , { TargetVersion . PY27 , TargetVersion . PY36 } ) [EOL] [EOL] py3_only = [string] [EOL] black . lib2to3_parse ( py3_only ) [EOL] with self . assertRaises ( black . InvalidInput ) : [EOL] black . lib2to3_parse ( py3_only , { TargetVersion . PY27 } ) [EOL] black . lib2to3_parse ( py3_only , { TargetVersion . PY36 } ) [EOL] black . lib2to3_parse ( py3_only , { TargetVersion . PY27 , TargetVersion . PY36 } ) [EOL] [EOL] def test_get_features_used ( self ) : [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( black . get_features_used ( node ) , set ( ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( black . get_features_used ( node ) , { Feature . TRAILING_COMMA_IN_DEF } ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( black . get_features_used ( node ) , { Feature . TRAILING_COMMA_IN_CALL } ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( black . get_features_used ( node ) , { Feature . F_STRINGS } ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( black . get_features_used ( node ) , { Feature . NUMERIC_UNDERSCORES } ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( black . get_features_used ( node ) , set ( ) ) [EOL] source , expected = read_data ( [string] ) [EOL] node = black . lib2to3_parse ( source ) [EOL] expected_features = { Feature . TRAILING_COMMA_IN_CALL , Feature . TRAILING_COMMA_IN_DEF , Feature . F_STRINGS , } [EOL] self . assertEqual ( black . get_features_used ( node ) , expected_features ) [EOL] node = black . lib2to3_parse ( expected ) [EOL] self . assertEqual ( black . get_features_used ( node ) , expected_features ) [EOL] source , expected = read_data ( [string] ) [EOL] node = black . lib2to3_parse ( source ) [EOL] self . assertEqual ( black . get_features_used ( node ) , set ( ) ) [EOL] node = black . lib2to3_parse ( expected ) [EOL] self . assertEqual ( black . get_features_used ( node ) , set ( ) ) [EOL] [EOL] def test_get_future_imports ( self ) : [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( set ( ) , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( { [string] } , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( { [string] , [string] } , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( { [string] , [string] } , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( { [string] , [string] } , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( { [string] } , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( { [string] } , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( set ( ) , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( set ( ) , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( { [string] } , black . get_future_imports ( node ) ) [EOL] node = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( { [string] , [string] } , black . get_future_imports ( node ) ) [EOL] [EOL] def test_debug_visitor ( self ) : [EOL] source , _ = read_data ( [string] ) [EOL] expected , _ = read_data ( [string] ) [EOL] out_lines = [ ] [EOL] err_lines = [ ] [EOL] [EOL] def out ( msg , ** kwargs ) : [EOL] out_lines . append ( msg ) [EOL] [EOL] def err ( msg , ** kwargs ) : [EOL] err_lines . append ( msg ) [EOL] [EOL] with patch ( [string] , out ) , patch ( [string] , err ) : [EOL] black . DebugVisitor . show ( source ) [EOL] actual = [string] . join ( out_lines ) + [string] [EOL] log_name = [string] [EOL] if expected != actual : [EOL] log_name = black . dump_to_file ( * out_lines ) [EOL] self . assertEqual ( expected , actual , f" [string] { log_name }" , ) [EOL] [EOL] def test_format_file_contents ( self ) : [EOL] empty = [string] [EOL] mode = black . FileMode ( ) [EOL] with self . assertRaises ( black . NothingChanged ) : [EOL] black . format_file_contents ( empty , mode = mode , fast = False ) [EOL] just_nl = [string] [EOL] with self . assertRaises ( black . NothingChanged ) : [EOL] black . format_file_contents ( just_nl , mode = mode , fast = False ) [EOL] same = [string] [EOL] with self . assertRaises ( black . NothingChanged ) : [EOL] black . format_file_contents ( same , mode = mode , fast = False ) [EOL] different = [string] [EOL] expected = same [EOL] actual = black . format_file_contents ( different , mode = mode , fast = False ) [EOL] self . assertEqual ( expected , actual ) [EOL] invalid = [string] [EOL] with self . assertRaises ( black . InvalidInput ) as e : [EOL] black . format_file_contents ( invalid , mode = mode , fast = False ) [EOL] self . assertEqual ( str ( e . exception ) , [string] ) [EOL] [EOL] def test_endmarker ( self ) : [EOL] n = black . lib2to3_parse ( [string] ) [EOL] self . assertEqual ( n . type , black . syms . file_input ) [EOL] self . assertEqual ( len ( n . children ) , [number] ) [EOL] self . assertEqual ( n . children [ [number] ] . type , black . token . ENDMARKER ) [EOL] [EOL] @ unittest . skipIf ( os . environ . get ( [string] ) , [string] ) def test_assertFormatEqual ( self ) : [EOL] out_lines = [ ] [EOL] err_lines = [ ] [EOL] [EOL] def out ( msg , ** kwargs ) : [EOL] out_lines . append ( msg ) [EOL] [EOL] def err ( msg , ** kwargs ) : [EOL] err_lines . append ( msg ) [EOL] [EOL] with patch ( [string] , out ) , patch ( [string] , err ) : [EOL] with self . assertRaises ( AssertionError ) : [EOL] self . assertFormatEqual ( [string] , [string] ) [EOL] [EOL] out_str = [string] . join ( out_lines ) [EOL] self . assertTrue ( [string] in out_str ) [EOL] self . assertTrue ( [string] in out_str ) [EOL] self . assertEqual ( [string] . join ( err_lines ) , [string] ) [EOL] [EOL] def test_cache_broken_file ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( ) as workspace : [EOL] cache_file = black . get_cache_file ( mode ) [EOL] with cache_file . open ( [string] ) as fobj : [EOL] fobj . write ( [string] ) [EOL] self . assertEqual ( black . read_cache ( mode ) , { } ) [EOL] src = ( workspace / [string] ) . resolve ( ) [EOL] with src . open ( [string] ) as fobj : [EOL] fobj . write ( [string] ) [EOL] self . invokeBlack ( [ str ( src ) ] ) [EOL] cache = black . read_cache ( mode ) [EOL] self . assertIn ( src , cache ) [EOL] [EOL] def test_cache_single_file_already_cached ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( ) as workspace : [EOL] src = ( workspace / [string] ) . resolve ( ) [EOL] with src . open ( [string] ) as fobj : [EOL] fobj . write ( [string] ) [EOL] black . write_cache ( { } , [ src ] , mode ) [EOL] self . invokeBlack ( [ str ( src ) ] ) [EOL] with src . open ( [string] ) as fobj : [EOL] self . assertEqual ( fobj . read ( ) , [string] ) [EOL] [EOL] @ event_loop ( close = False ) def test_cache_multiple_files ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( ) as workspace , patch ( [string] , new = ThreadPoolExecutor ) : [EOL] one = ( workspace / [string] ) . resolve ( ) [EOL] with one . open ( [string] ) as fobj : [EOL] fobj . write ( [string] ) [EOL] two = ( workspace / [string] ) . resolve ( ) [EOL] with two . open ( [string] ) as fobj : [EOL] fobj . write ( [string] ) [EOL] black . write_cache ( { } , [ one ] , mode ) [EOL] self . invokeBlack ( [ str ( workspace ) ] ) [EOL] with one . open ( [string] ) as fobj : [EOL] self . assertEqual ( fobj . read ( ) , [string] ) [EOL] with two . open ( [string] ) as fobj : [EOL] self . assertEqual ( fobj . read ( ) , [string] ) [EOL] cache = black . read_cache ( mode ) [EOL] self . assertIn ( one , cache ) [EOL] self . assertIn ( two , cache ) [EOL] [EOL] def test_no_cache_when_writeback_diff ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( ) as workspace : [EOL] src = ( workspace / [string] ) . resolve ( ) [EOL] with src . open ( [string] ) as fobj : [EOL] fobj . write ( [string] ) [EOL] self . invokeBlack ( [ str ( src ) , [string] ] ) [EOL] cache_file = black . get_cache_file ( mode ) [EOL] self . assertFalse ( cache_file . exists ( ) ) [EOL] [EOL] def test_no_cache_when_stdin ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( ) : [EOL] result = CliRunner ( ) . invoke ( black . main , [ [string] ] , input = BytesIO ( [string] ) ) [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL] cache_file = black . get_cache_file ( mode ) [EOL] self . assertFalse ( cache_file . exists ( ) ) [EOL] [EOL] def test_read_cache_no_cachefile ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( ) : [EOL] self . assertEqual ( black . read_cache ( mode ) , { } ) [EOL] [EOL] def test_write_cache_read_cache ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( ) as workspace : [EOL] src = ( workspace / [string] ) . resolve ( ) [EOL] src . touch ( ) [EOL] black . write_cache ( { } , [ src ] , mode ) [EOL] cache = black . read_cache ( mode ) [EOL] self . assertIn ( src , cache ) [EOL] self . assertEqual ( cache [ src ] , black . get_cache_info ( src ) ) [EOL] [EOL] def test_filter_cached ( self ) : [EOL] with TemporaryDirectory ( ) as workspace : [EOL] path = Path ( workspace ) [EOL] uncached = ( path / [string] ) . resolve ( ) [EOL] cached = ( path / [string] ) . resolve ( ) [EOL] cached_but_changed = ( path / [string] ) . resolve ( ) [EOL] uncached . touch ( ) [EOL] cached . touch ( ) [EOL] cached_but_changed . touch ( ) [EOL] cache = { cached : black . get_cache_info ( cached ) , cached_but_changed : ( [number] , [number] ) } [EOL] todo , done = black . filter_cached ( cache , { uncached , cached , cached_but_changed } ) [EOL] self . assertEqual ( todo , { uncached , cached_but_changed } ) [EOL] self . assertEqual ( done , { cached } ) [EOL] [EOL] def test_write_cache_creates_directory_if_needed ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( exists = False ) as workspace : [EOL] self . assertFalse ( workspace . exists ( ) ) [EOL] black . write_cache ( { } , [ ] , mode ) [EOL] self . assertTrue ( workspace . exists ( ) ) [EOL] [EOL] @ event_loop ( close = False ) def test_failed_formatting_does_not_get_cached ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( ) as workspace , patch ( [string] , new = ThreadPoolExecutor ) : [EOL] failing = ( workspace / [string] ) . resolve ( ) [EOL] with failing . open ( [string] ) as fobj : [EOL] fobj . write ( [string] ) [EOL] clean = ( workspace / [string] ) . resolve ( ) [EOL] with clean . open ( [string] ) as fobj : [EOL] fobj . write ( [string] ) [EOL] self . invokeBlack ( [ str ( workspace ) ] , exit_code = [number] ) [EOL] cache = black . read_cache ( mode ) [EOL] self . assertNotIn ( failing , cache ) [EOL] self . assertIn ( clean , cache ) [EOL] [EOL] def test_write_cache_write_fail ( self ) : [EOL] mode = black . FileMode ( ) [EOL] with cache_dir ( ) , patch . object ( Path , [string] ) as mock : [EOL] mock . side_effect = OSError [EOL] black . write_cache ( { } , [ ] , mode ) [EOL] [EOL] @ event_loop ( close = False ) def test_check_diff_use_together ( self ) : [EOL] with cache_dir ( ) : [EOL] [comment] [EOL] src1 = ( THIS_DIR / [string] / [string] ) . resolve ( ) [EOL] self . invokeBlack ( [ str ( src1 ) , [string] , [string] ] , exit_code = [number] ) [EOL] [comment] [EOL] src2 = ( THIS_DIR / [string] / [string] ) . resolve ( ) [EOL] self . invokeBlack ( [ str ( src2 ) , [string] , [string] ] ) [EOL] [comment] [EOL] self . invokeBlack ( [ str ( src1 ) , str ( src2 ) , [string] , [string] ] , exit_code = [number] ) [EOL] [EOL] def test_no_files ( self ) : [EOL] with cache_dir ( ) : [EOL] [comment] [EOL] self . invokeBlack ( [ ] ) [EOL] [EOL] def test_broken_symlink ( self ) : [EOL] with cache_dir ( ) as workspace : [EOL] symlink = workspace / [string] [EOL] try : [EOL] symlink . symlink_to ( [string] ) [EOL] except OSError as e : [EOL] self . skipTest ( f" [string] { e }" ) [EOL] self . invokeBlack ( [ str ( workspace . resolve ( ) ) ] ) [EOL] [EOL] def test_read_cache_line_lengths ( self ) : [EOL] mode = black . FileMode ( ) [EOL] short_mode = black . FileMode ( line_length = [number] ) [EOL] with cache_dir ( ) as workspace : [EOL] path = ( workspace / [string] ) . resolve ( ) [EOL] path . touch ( ) [EOL] black . write_cache ( { } , [ path ] , mode ) [EOL] one = black . read_cache ( mode ) [EOL] self . assertIn ( path , one ) [EOL] two = black . read_cache ( short_mode ) [EOL] self . assertNotIn ( path , two ) [EOL] [EOL] def test_tricky_unicode_symbols ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] def test_single_file_force_pyi ( self ) : [EOL] reg_mode = black . FileMode ( ) [EOL] pyi_mode = black . FileMode ( is_pyi = True ) [EOL] contents , expected = read_data ( [string] ) [EOL] with cache_dir ( ) as workspace : [EOL] path = ( workspace / [string] ) . resolve ( ) [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( contents ) [EOL] self . invokeBlack ( [ str ( path ) , [string] ] ) [EOL] with open ( path , [string] ) as fh : [EOL] actual = fh . read ( ) [EOL] [comment] [EOL] pyi_cache = black . read_cache ( pyi_mode ) [EOL] self . assertIn ( path , pyi_cache ) [EOL] normal_cache = black . read_cache ( reg_mode ) [EOL] self . assertNotIn ( path , normal_cache ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] @ event_loop ( close = False ) def test_multi_file_force_pyi ( self ) : [EOL] reg_mode = black . FileMode ( ) [EOL] pyi_mode = black . FileMode ( is_pyi = True ) [EOL] contents , expected = read_data ( [string] ) [EOL] with cache_dir ( ) as workspace : [EOL] paths = [ ( workspace / [string] ) . resolve ( ) , ( workspace / [string] ) . resolve ( ) , ] [EOL] for path in paths : [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( contents ) [EOL] self . invokeBlack ( [ str ( p ) for p in paths ] + [ [string] ] ) [EOL] for path in paths : [EOL] with open ( path , [string] ) as fh : [EOL] actual = fh . read ( ) [EOL] self . assertEqual ( actual , expected ) [EOL] [comment] [EOL] pyi_cache = black . read_cache ( pyi_mode ) [EOL] normal_cache = black . read_cache ( reg_mode ) [EOL] for path in paths : [EOL] self . assertIn ( path , pyi_cache ) [EOL] self . assertNotIn ( path , normal_cache ) [EOL] [EOL] def test_pipe_force_pyi ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] result = CliRunner ( ) . invoke ( black . main , [ [string] , [string] , [string] ] , input = BytesIO ( source . encode ( [string] ) ) ) [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL] actual = result . output [EOL] self . assertFormatEqual ( actual , expected ) [EOL] [EOL] def test_single_file_force_py36 ( self ) : [EOL] reg_mode = black . FileMode ( ) [EOL] py36_mode = black . FileMode ( target_versions = black . PY36_VERSIONS ) [EOL] source , expected = read_data ( [string] ) [EOL] with cache_dir ( ) as workspace : [EOL] path = ( workspace / [string] ) . resolve ( ) [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( source ) [EOL] self . invokeBlack ( [ str ( path ) , * PY36_ARGS ] ) [EOL] with open ( path , [string] ) as fh : [EOL] actual = fh . read ( ) [EOL] [comment] [EOL] py36_cache = black . read_cache ( py36_mode ) [EOL] self . assertIn ( path , py36_cache ) [EOL] normal_cache = black . read_cache ( reg_mode ) [EOL] self . assertNotIn ( path , normal_cache ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] @ event_loop ( close = False ) def test_multi_file_force_py36 ( self ) : [EOL] reg_mode = black . FileMode ( ) [EOL] py36_mode = black . FileMode ( target_versions = black . PY36_VERSIONS ) [EOL] source , expected = read_data ( [string] ) [EOL] with cache_dir ( ) as workspace : [EOL] paths = [ ( workspace / [string] ) . resolve ( ) , ( workspace / [string] ) . resolve ( ) , ] [EOL] for path in paths : [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( source ) [EOL] self . invokeBlack ( [ str ( p ) for p in paths ] + PY36_ARGS ) [EOL] for path in paths : [EOL] with open ( path , [string] ) as fh : [EOL] actual = fh . read ( ) [EOL] self . assertEqual ( actual , expected ) [EOL] [comment] [EOL] pyi_cache = black . read_cache ( py36_mode ) [EOL] normal_cache = black . read_cache ( reg_mode ) [EOL] for path in paths : [EOL] self . assertIn ( path , pyi_cache ) [EOL] self . assertNotIn ( path , normal_cache ) [EOL] [EOL] def test_collections ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] actual = fs ( source ) [EOL] self . assertFormatEqual ( expected , actual ) [EOL] black . assert_equivalent ( source , actual ) [EOL] black . assert_stable ( source , actual , black . FileMode ( ) ) [EOL] [EOL] def test_pipe_force_py36 ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] result = CliRunner ( ) . invoke ( black . main , [ [string] , [string] , [string] ] , input = BytesIO ( source . encode ( [string] ) ) , ) [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL] actual = result . output [EOL] self . assertFormatEqual ( actual , expected ) [EOL] [EOL] def test_include_exclude ( self ) : [EOL] path = THIS_DIR / [string] / [string] [EOL] include = re . compile ( [string] ) [EOL] exclude = re . compile ( [string] ) [EOL] report = black . Report ( ) [EOL] gitignore = PathSpec . from_lines ( [string] , [ ] ) [EOL] sources = [ ] [EOL] expected = [ Path ( path / [string] ) , Path ( path / [string] ) , ] [EOL] this_abs = THIS_DIR . resolve ( ) [EOL] sources . extend ( black . gen_python_files_in_dir ( path , this_abs , include , exclude , report , gitignore ) ) [EOL] self . assertEqual ( sorted ( expected ) , sorted ( sources ) ) [EOL] [EOL] def test_gitignore_exclude ( self ) : [EOL] path = THIS_DIR / [string] / [string] [EOL] include = re . compile ( [string] ) [EOL] exclude = re . compile ( [string] ) [EOL] report = black . Report ( ) [EOL] gitignore = PathSpec . from_lines ( [string] , [ [string] , [string] ] ) [EOL] sources = [ ] [EOL] expected = [ Path ( path / [string] ) , Path ( path / [string] ) , ] [EOL] this_abs = THIS_DIR . resolve ( ) [EOL] sources . extend ( black . gen_python_files_in_dir ( path , this_abs , include , exclude , report , gitignore ) ) [EOL] self . assertEqual ( sorted ( expected ) , sorted ( sources ) ) [EOL] [EOL] def test_empty_include ( self ) : [EOL] path = THIS_DIR / [string] / [string] [EOL] report = black . Report ( ) [EOL] gitignore = PathSpec . from_lines ( [string] , [ ] ) [EOL] empty = re . compile ( [string] ) [EOL] sources = [ ] [EOL] expected = [ Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , ] [EOL] this_abs = THIS_DIR . resolve ( ) [EOL] sources . extend ( black . gen_python_files_in_dir ( path , this_abs , empty , re . compile ( black . DEFAULT_EXCLUDES ) , report , gitignore , ) ) [EOL] self . assertEqual ( sorted ( expected ) , sorted ( sources ) ) [EOL] [EOL] def test_empty_exclude ( self ) : [EOL] path = THIS_DIR / [string] / [string] [EOL] report = black . Report ( ) [EOL] gitignore = PathSpec . from_lines ( [string] , [ ] ) [EOL] empty = re . compile ( [string] ) [EOL] sources = [ ] [EOL] expected = [ Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , Path ( path / [string] ) , ] [EOL] this_abs = THIS_DIR . resolve ( ) [EOL] sources . extend ( black . gen_python_files_in_dir ( path , this_abs , re . compile ( black . DEFAULT_INCLUDES ) , empty , report , gitignore , ) ) [EOL] self . assertEqual ( sorted ( expected ) , sorted ( sources ) ) [EOL] [EOL] def test_invalid_include_exclude ( self ) : [EOL] for option in [ [string] , [string] ] : [EOL] self . invokeBlack ( [ [string] , option , [string] ] , exit_code = [number] ) [EOL] [EOL] def test_preserves_line_endings ( self ) : [EOL] with TemporaryDirectory ( ) as workspace : [EOL] test_file = Path ( workspace ) / [string] [EOL] for nl in [ [string] , [string] ] : [EOL] contents = nl . join ( [ [string] , [string] ] ) [EOL] test_file . write_bytes ( contents . encode ( ) ) [EOL] ff ( test_file , write_back = black . WriteBack . YES ) [EOL] updated_contents = test_file . read_bytes ( ) [EOL] self . assertIn ( nl . encode ( ) , updated_contents ) [EOL] if nl == [string] : [EOL] self . assertNotIn ( [string] , updated_contents ) [EOL] [EOL] def test_preserves_line_endings_via_stdin ( self ) : [EOL] for nl in [ [string] , [string] ] : [EOL] contents = nl . join ( [ [string] , [string] ] ) [EOL] runner = BlackRunner ( ) [EOL] result = runner . invoke ( black . main , [ [string] , [string] ] , input = BytesIO ( contents . encode ( [string] ) ) ) [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL] output = runner . stdout_bytes [EOL] self . assertIn ( nl . encode ( [string] ) , output ) [EOL] if nl == [string] : [EOL] self . assertNotIn ( [string] , output ) [EOL] [EOL] def test_assert_equivalent_different_asts ( self ) : [EOL] with self . assertRaises ( AssertionError ) : [EOL] black . assert_equivalent ( [string] , [string] ) [EOL] [EOL] def test_symlink_out_of_root_directory ( self ) : [EOL] path = MagicMock ( ) [EOL] root = THIS_DIR [EOL] child = MagicMock ( ) [EOL] include = re . compile ( black . DEFAULT_INCLUDES ) [EOL] exclude = re . compile ( black . DEFAULT_EXCLUDES ) [EOL] report = black . Report ( ) [EOL] gitignore = PathSpec . from_lines ( [string] , [ ] ) [EOL] [comment] [EOL] [comment] [EOL] path . iterdir . return_value = [ child ] [EOL] child . resolve . return_value = Path ( [string] ) [EOL] child . as_posix . return_value = [string] [EOL] child . is_symlink . return_value = True [EOL] try : [EOL] list ( black . gen_python_files_in_dir ( path , root , include , exclude , report , gitignore ) ) [EOL] except ValueError as ve : [EOL] self . fail ( f" [string] { ve }" ) [EOL] path . iterdir . assert_called_once ( ) [EOL] child . resolve . assert_called_once ( ) [EOL] child . is_symlink . assert_called_once ( ) [EOL] [comment] [EOL] [comment] [EOL] child . is_symlink . return_value = False [EOL] with self . assertRaises ( ValueError ) : [EOL] list ( black . gen_python_files_in_dir ( path , root , include , exclude , report , gitignore ) ) [EOL] path . iterdir . assert_called ( ) [EOL] self . assertEqual ( path . iterdir . call_count , [number] ) [EOL] child . resolve . assert_called ( ) [EOL] self . assertEqual ( child . resolve . call_count , [number] ) [EOL] child . is_symlink . assert_called ( ) [EOL] self . assertEqual ( child . is_symlink . call_count , [number] ) [EOL] [EOL] def test_shhh_click ( self ) : [EOL] try : [EOL] from click import _unicodefun [comment] [EOL] except ModuleNotFoundError : [EOL] self . skipTest ( [string] ) [EOL] if not hasattr ( _unicodefun , [string] ) : [EOL] self . skipTest ( [string] ) [EOL] [comment] [EOL] with patch ( [string] ) as gpe : [EOL] gpe . return_value = [string] [EOL] with self . assertRaises ( RuntimeError ) : [EOL] _unicodefun . _verify_python3_env ( ) [EOL] [comment] [EOL] black . patch_click ( ) [EOL] [comment] [EOL] with patch ( [string] ) as gpe : [EOL] gpe . return_value = [string] [EOL] try : [EOL] _unicodefun . _verify_python3_env ( ) [EOL] except RuntimeError as re : [EOL] self . fail ( f" [string] { re }" ) [EOL] [EOL] def test_root_logger_not_used_directly ( self ) : [EOL] def fail ( * args , ** kwargs ) : [EOL] self . fail ( [string] ) [EOL] [EOL] with patch . multiple ( logging . root , debug = fail , info = fail , warning = fail , error = fail , critical = fail , log = fail , ) : [EOL] ff ( THIS_FILE ) [EOL] [EOL] @ unittest . skipUnless ( has_blackd_deps , [string] ) def test_blackd_main ( self ) : [EOL] with patch ( [string] ) : [EOL] result = CliRunner ( ) . invoke ( blackd . main , [ ] ) [EOL] if result . exception is not None : [EOL] raise result . exception [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL] [EOL] [EOL] class BlackDTestCase ( AioHTTPTestCase ) : [EOL] async def get_application ( self ) : [EOL] return blackd . make_app ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_request_needs_formatting ( self ) : [EOL] response = await self . client . post ( [string] , data = [string] ) [EOL] self . assertEqual ( response . status , [number] ) [EOL] self . assertEqual ( response . charset , [string] ) [EOL] self . assertEqual ( await response . read ( ) , [string] ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_request_no_change ( self ) : [EOL] response = await self . client . post ( [string] , data = [string] ) [EOL] self . assertEqual ( response . status , [number] ) [EOL] self . assertEqual ( await response . read ( ) , [string] ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_request_syntax_error ( self ) : [EOL] response = await self . client . post ( [string] , data = [string] ) [EOL] self . assertEqual ( response . status , [number] ) [EOL] content = await response . text ( ) [EOL] self . assertTrue ( content . startswith ( [string] ) , msg = f" [string] { repr ( content ) }" , ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_unsupported_version ( self ) : [EOL] response = await self . client . post ( [string] , data = [string] , headers = { blackd . PROTOCOL_VERSION_HEADER : [string] } ) [EOL] self . assertEqual ( response . status , [number] ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_supported_version ( self ) : [EOL] response = await self . client . post ( [string] , data = [string] , headers = { blackd . PROTOCOL_VERSION_HEADER : [string] } ) [EOL] self . assertEqual ( response . status , [number] ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_invalid_python_variant ( self ) : [EOL] async def check ( header_value , expected_status = [number] ) : [EOL] response = await self . client . post ( [string] , data = [string] , headers = { blackd . PYTHON_VARIANT_HEADER : header_value } ) [EOL] self . assertEqual ( response . status , expected_status ) [EOL] [EOL] await check ( [string] ) [EOL] await check ( [string] ) [EOL] await check ( [string] ) [EOL] await check ( [string] ) [EOL] await check ( [string] ) [EOL] await check ( [string] ) [EOL] await check ( [string] ) [EOL] await check ( [string] ) [EOL] await check ( [string] ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_pyi ( self ) : [EOL] source , expected = read_data ( [string] ) [EOL] response = await self . client . post ( [string] , data = source , headers = { blackd . PYTHON_VARIANT_HEADER : [string] } ) [EOL] self . assertEqual ( response . status , [number] ) [EOL] self . assertEqual ( await response . text ( ) , expected ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_diff ( self ) : [EOL] diff_header = re . compile ( rf" [string] " rf" [string] " ) [EOL] [EOL] source , _ = read_data ( [string] ) [EOL] expected , _ = read_data ( [string] ) [EOL] [EOL] response = await self . client . post ( [string] , data = source , headers = { blackd . DIFF_HEADER : [string] } ) [EOL] self . assertEqual ( response . status , [number] ) [EOL] [EOL] actual = await response . text ( ) [EOL] actual = diff_header . sub ( DETERMINISTIC_HEADER , actual ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_python_variant ( self ) : [EOL] code = ( [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] async def check ( header_value , expected_status ) : [EOL] response = await self . client . post ( [string] , data = code , headers = { blackd . PYTHON_VARIANT_HEADER : header_value } ) [EOL] self . assertEqual ( response . status , expected_status , msg = await response . text ( ) ) [EOL] [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] await check ( [string] , [number] ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_line_length ( self ) : [EOL] response = await self . client . post ( [string] , data = [string] , headers = { blackd . LINE_LENGTH_HEADER : [string] } ) [EOL] self . assertEqual ( response . status , [number] ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_invalid_line_length ( self ) : [EOL] response = await self . client . post ( [string] , data = [string] , headers = { blackd . LINE_LENGTH_HEADER : [string] } ) [EOL] self . assertEqual ( response . status , [number] ) [EOL] [EOL] @ skip_if_exception ( [string] ) @ unittest . skipUnless ( has_blackd_deps , [string] ) @ unittest_run_loop async def test_blackd_response_black_version_header ( self ) : [EOL] response = await self . client . post ( [string] ) [EOL] self . assertIsNotNone ( response . headers . get ( blackd . BLACK_VERSION_HEADER ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( module = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import io [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import regex as re [EOL] [EOL] [comment] [EOL] from pgen2 import grammar , token [EOL] [EOL] [EOL] class Converter ( grammar . Grammar ) : [EOL] [docstring] [EOL] [EOL] def run ( self , graminit_h , graminit_c ) : [EOL] [docstring] [EOL] self . parse_graminit_h ( graminit_h ) [EOL] self . parse_graminit_c ( graminit_c ) [EOL] self . finish_off ( ) [EOL] [EOL] def parse_graminit_h ( self , filename ) : [EOL] [docstring] [EOL] try : [EOL] f = open ( filename ) [EOL] except OSError as err : [EOL] print ( [string] % ( filename , err ) ) [EOL] return False [EOL] self . symbol2number = { } [EOL] self . number2symbol = { } [EOL] lineno = [number] [EOL] for line in f : [EOL] lineno += [number] [EOL] mo = re . match ( [string] , line ) [EOL] if not mo and line . strip ( ) : [EOL] print ( [string] % ( filename , lineno , line . strip ( ) ) ) [EOL] else : [EOL] symbol , number = mo . groups ( ) [EOL] number = int ( number ) [EOL] assert symbol not in self . symbol2number [EOL] assert number not in self . number2symbol [EOL] self . symbol2number [ symbol ] = number [EOL] self . number2symbol [ number ] = symbol [EOL] return True [EOL] [EOL] def parse_graminit_c ( self , filename ) : [EOL] [docstring] [EOL] try : [EOL] f = open ( filename ) [EOL] except OSError as err : [EOL] print ( [string] % ( filename , err ) ) [EOL] return False [EOL] [comment] [EOL] lineno = [number] [EOL] [EOL] [comment] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] [EOL] [comment] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] allarcs = { } [EOL] states = [ ] [EOL] while line . startswith ( [string] ) : [EOL] while line . startswith ( [string] ) : [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] n , m , k = list ( map ( int , mo . groups ( ) ) ) [EOL] arcs = [ ] [EOL] for _ in range ( k ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] i , j = list ( map ( int , mo . groups ( ) ) ) [EOL] arcs . append ( ( i , j ) ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] allarcs [ ( n , m ) ] = arcs [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] s , t = list ( map ( int , mo . groups ( ) ) ) [EOL] assert s == len ( states ) , ( lineno , line ) [EOL] state = [ ] [EOL] for _ in range ( t ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] k , n , m = list ( map ( int , mo . groups ( ) ) ) [EOL] arcs = allarcs [ n , m ] [EOL] assert k == len ( arcs ) , ( lineno , line ) [EOL] state . append ( arcs ) [EOL] states . append ( state ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] self . states = states [EOL] [EOL] [comment] [EOL] dfas = { } [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] ndfas = int ( mo . group ( [number] ) ) [EOL] for i in range ( ndfas ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] symbol = mo . group ( [number] ) [EOL] number , x , y , z = list ( map ( int , mo . group ( [number] , [number] , [number] , [number] ) ) ) [EOL] assert self . symbol2number [ symbol ] == number , ( lineno , line ) [EOL] assert self . number2symbol [ number ] == symbol , ( lineno , line ) [EOL] assert x == [number] , ( lineno , line ) [EOL] state = states [ z ] [EOL] assert y == len ( state ) , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] first = { } [EOL] rawbitset = eval ( mo . group ( [number] ) ) [EOL] for i , c in enumerate ( rawbitset ) : [EOL] byte = ord ( c ) [EOL] for j in range ( [number] ) : [EOL] if byte & ( [number] << j ) : [EOL] first [ i * [number] + j ] = [number] [EOL] dfas [ number ] = ( state , first ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] self . dfas = dfas [EOL] [EOL] [comment] [EOL] labels = [ ] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] nlabels = int ( mo . group ( [number] ) ) [EOL] for i in range ( nlabels ) : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] x , y = mo . groups ( ) [EOL] x = int ( x ) [EOL] if y == [string] : [EOL] y = None [EOL] else : [EOL] y = eval ( y ) [EOL] labels . append ( ( x , y ) ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] self . labels = labels [EOL] [EOL] [comment] [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] ndfas = int ( mo . group ( [number] ) ) [EOL] assert ndfas == len ( self . dfas ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] nlabels = int ( mo . group ( [number] ) ) [EOL] assert nlabels == len ( self . labels ) , ( lineno , line ) [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] mo = re . match ( [string] , line ) [EOL] assert mo , ( lineno , line ) [EOL] start = int ( mo . group ( [number] ) ) [EOL] assert start in self . number2symbol , ( lineno , line ) [EOL] self . start = start [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] assert line == [string] , ( lineno , line ) [EOL] try : [EOL] lineno , line = lineno + [number] , next ( f ) [EOL] except StopIteration : [EOL] pass [EOL] else : [EOL] assert [number] , ( lineno , line ) [EOL] [EOL] def finish_off ( self ) : [EOL] [docstring] [EOL] self . keywords = { } [comment] [EOL] self . tokens = { } [comment] [EOL] for ilabel , ( type , value ) in enumerate ( self . labels ) : [EOL] if type == token . NAME and value is not None : [EOL] self . keywords [ value ] = ilabel [EOL] elif value is None : [EOL] self . tokens [ type ] = ilabel [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Optional , Match , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] [EOL] from typing import Dict , Match , Text [EOL] [EOL] [EOL] simple_escapes = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def escape ( m ) : [EOL] all , tail = m . group ( [number] , [number] ) [EOL] assert all . startswith ( [string] ) [EOL] esc = simple_escapes . get ( tail ) [EOL] if esc is not None : [EOL] return esc [EOL] if tail . startswith ( [string] ) : [EOL] hexes = tail [ [number] : ] [EOL] if len ( hexes ) < [number] : [EOL] raise ValueError ( [string] % tail ) [EOL] try : [EOL] i = int ( hexes , [number] ) [EOL] except ValueError : [EOL] raise ValueError ( [string] % tail ) from None [EOL] else : [EOL] try : [EOL] i = int ( tail , [number] ) [EOL] except ValueError : [EOL] raise ValueError ( [string] % tail ) from None [EOL] return chr ( i ) [EOL] [EOL] [EOL] def evalString ( s ) : [EOL] assert s . startswith ( [string] ) or s . startswith ( [string] ) , repr ( s [ : [number] ] ) [EOL] q = s [ [number] ] [EOL] if s [ : [number] ] == q * [number] : [EOL] q = q * [number] [EOL] assert s . endswith ( q ) , repr ( s [ - len ( q ) : ] ) [EOL] assert len ( s ) >= [number] * len ( q ) [EOL] s = s [ len ( q ) : - len ( q ) ] [EOL] return re . sub ( [string] , escape , s ) [EOL] [EOL] [EOL] def test ( ) : [EOL] for i in range ( [number] ) : [EOL] c = chr ( i ) [EOL] s = repr ( c ) [EOL] e = evalString ( s ) [EOL] if e != c : [EOL] print ( i , c , s , e ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Dict , TypeVar , Type , Tuple , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import os [EOL] import pickle [EOL] import tempfile [EOL] from typing import Any , Dict , List , Optional , Text , Tuple , TypeVar , Union [EOL] [EOL] [comment] [EOL] from . import token [EOL] [EOL] _P = TypeVar ( [string] , bound = [string] ) [EOL] Label = Tuple [ int , Optional [ Text ] ] [EOL] DFA = List [ List [ Tuple [ int , int ] ] ] [EOL] DFAS = Tuple [ DFA , Dict [ int , int ] ] [EOL] Path = Union [ str , [string] ] [EOL] [EOL] [EOL] class Grammar ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . symbol2number = { } [EOL] self . number2symbol = { } [EOL] self . states = [ ] [EOL] self . dfas = { } [EOL] self . labels = [ ( [number] , [string] ) ] [EOL] self . keywords = { } [EOL] self . tokens = { } [EOL] self . symbol2label = { } [EOL] self . start = [number] [EOL] [comment] [EOL] self . async_keywords = False [EOL] [EOL] def dump ( self , filename ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if hasattr ( self , [string] ) : [EOL] d = self . __dict__ [EOL] else : [EOL] d = self . __getstate__ ( ) [comment] [EOL] [EOL] with tempfile . NamedTemporaryFile ( dir = os . path . dirname ( filename ) , delete = False ) as f : [EOL] pickle . dump ( d , f , pickle . HIGHEST_PROTOCOL ) [EOL] os . replace ( f . name , filename ) [EOL] [EOL] def _update ( self , attrs ) : [EOL] for k , v in attrs . items ( ) : [EOL] setattr ( self , k , v ) [EOL] [EOL] def load ( self , filename ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as f : [EOL] d = pickle . load ( f ) [EOL] self . _update ( d ) [EOL] [EOL] def loads ( self , pkl ) : [EOL] [docstring] [EOL] self . _update ( pickle . loads ( pkl ) ) [EOL] [EOL] def copy ( self ) : [EOL] [docstring] [EOL] new = self . __class__ ( ) [EOL] for dict_attr in ( [string] , [string] , [string] , [string] , [string] , [string] , ) : [EOL] setattr ( new , dict_attr , getattr ( self , dict_attr ) . copy ( ) ) [EOL] new . labels = self . labels [ : ] [EOL] new . states = self . states [ : ] [EOL] new . start = self . start [EOL] new . async_keywords = self . async_keywords [EOL] return new [EOL] [EOL] def report ( self ) : [EOL] [docstring] [EOL] from pprint import pprint [EOL] [EOL] print ( [string] ) [EOL] pprint ( self . symbol2number ) [EOL] print ( [string] ) [EOL] pprint ( self . number2symbol ) [EOL] print ( [string] ) [EOL] pprint ( self . states ) [EOL] print ( [string] ) [EOL] pprint ( self . dfas ) [EOL] print ( [string] ) [EOL] pprint ( self . labels ) [EOL] print ( [string] , self . start ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] opmap_raw = [string] [EOL] [EOL] opmap = { } [EOL] for line in opmap_raw . splitlines ( ) : [EOL] if line : [EOL] op , name = line . split ( ) [EOL] opmap [ op ] = getattr ( token , name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0