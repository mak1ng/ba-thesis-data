[comment] [EOL] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] import sys [EOL] import subprocess [EOL] from typing import List , Any [EOL] from setuptools import Command , setup [EOL] [EOL] class TestCommand ( Command ) : [EOL] [docstring] [EOL] user_options = [ ] [EOL] [EOL] def initialize_options ( self ) : [EOL] pass [EOL] [EOL] def finalize_options ( self ) : [EOL] pass [EOL] [EOL] def run ( self ) : [EOL] raise SystemExit ( subprocess . call ( [ sys . executable , [string] , [string] ] ) ) [EOL] [EOL] class LintCommand ( Command ) : [EOL] [docstring] [EOL] user_options = [ ] [EOL] [EOL] def initialize_options ( self ) : [EOL] pass [EOL] [EOL] def finalize_options ( self ) : [EOL] pass [EOL] [EOL] def run ( self ) : [EOL] commands = ( [ sys . executable , [string] , [string] , [string] , [string] ] , [ sys . executable , [string] , [string] , [string] ] , ) [EOL] for cmd in commands : [EOL] code = subprocess . call ( cmd ) [EOL] if code != [number] : [EOL] raise SystemExit ( code ) [EOL] raise SystemExit ( [number] ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , author = [string] , author_email = [string] , url = [string] , packages = [ [string] ] , install_requires = [ [string] ] , cmdclass = { [string] : LintCommand , [string] : TestCommand , } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.str],typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.str],typing.List[builtins.str]]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] @ pytest . fixture def db ( ) : [EOL] from phonygres import Database [EOL] return Database ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import phonygres [EOL] from phonygres import execute_sql , Database [EOL] [EOL] def test_empty_create ( db ) : [EOL] execute_sql ( db , [string] ) [EOL] [EOL] def test_basic_create ( db ) : [EOL] execute_sql ( db , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class PhonygresError ( BaseException ) : [EOL] code = ... [EOL] message = ... [EOL] [EOL] def __init__ ( self , code , message ) : [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] self . code = code [EOL] self . message = message [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0
from typing import Iterator , List [EOL] import sqlparse [EOL] import typing [EOL] from typing import Iterator [EOL] [EOL] from sqlparse . sql import Token , TokenList [EOL] [EOL] def skip_whitespace ( tokens ) : [EOL] [docstring] [EOL] for token in tokens : [EOL] if not token . is_whitespace : [EOL] yield token [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[sqlparse.sql.Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import phonygres [EOL] import typing [EOL] from typing import Dict [EOL] [EOL] from . ddl import Schema [EOL] [EOL] class Database : [EOL] schemas = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . schemas = { [string] : Schema ( [string] ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,ddl.Schema]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,phonygres.ddl.schema.Schema]$ 0 0 0 0 0 0 0 0 0 0 0
import phonygres [EOL] import builtins [EOL] import database [EOL] from . database import Database [EOL] from . errors import PhonygresError [EOL] from . parser import parse_sql [EOL] from . transaction import Transaction [EOL] from . engine import execute [EOL] [EOL] def execute_sql ( db , sql ) : [EOL] tx = None [EOL] for statement in parse_sql ( sql ) : [EOL] tx = Transaction ( ) [EOL] execute ( tx , statement , db ) [EOL] if tx . autocommit : [EOL] tx . commit ( ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class Transaction : [EOL] current_schema = ... [EOL] autocommit = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . current_schema = [string] [EOL] self . autocommit = True [EOL] [EOL] def begin ( self ) : [EOL] self . autocommit = False [EOL] [EOL] def commit ( self ) : [EOL] pass [EOL] [EOL] def rollback ( self ) : [EOL] pass [EOL]	0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Type , Any , Callable [EOL] import typing [EOL] import transaction [EOL] import database [EOL] from typing import Dict , Type , Any , Callable [EOL] [EOL] from . . ast import * [EOL] from . . transaction import Transaction [EOL] from . . database import Database [EOL] from . . ddl import Table [EOL] [EOL] visitors = { StartTransaction : lambda tx , st , db : None , Commit : lambda tx , st , db : None , CreateTable : lambda tx , st , db : db . schemas [ tx . current_schema ] . add_table ( Table ( st . name , st . columns ) ) , } [EOL] [EOL] def execute ( tx , statement , target ) : [EOL] return visitors [ statement . __class__ ] ( tx , statement , target ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . executor import execute [EOL]	0 0 0 0 0 0
from typing import Tuple , List , Optional , Union [EOL] import util [EOL] import sqlparse [EOL] import typing [EOL] import builtins [EOL] import ast [EOL] import phonygres [EOL] from typing import Optional , Tuple , List [EOL] [EOL] from sqlparse import parse as sql_parse [EOL] from sqlparse . sql import Statement as ParseStatement [EOL] [EOL] from . util import StatementIter [EOL] from . parse_create import parse_create [EOL] from . . ast import Statement [EOL] from . . errors import PhonygresError [EOL] [EOL] [EOL] def parse_sql ( sql ) : [EOL] parse_ast = sql_parse ( sql ) [EOL] statements = [ ] [EOL] [EOL] for statement in parse_ast : [EOL] it = StatementIter ( statement ) [EOL] [EOL] statement . _pprint_tree ( ) [EOL] [EOL] parsed = parse_statement ( it ) [EOL] if parsed is not None : [EOL] statements . append ( parsed ) [EOL] [EOL] return statements [EOL] [EOL] def parse_statement ( it ) : [EOL] t = it . next_opt ( ) [EOL] if t is None : [EOL] return None [EOL] [EOL] if t . normalized == [string] : [EOL] return parse_create ( it ) [EOL] else : [EOL] raise PhonygresError ( [string] , f' [string] { t } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Optional [EOL] import typing [EOL] import builtins [EOL] import sqlparse [EOL] from typing import Iterator , Optional [EOL] [EOL] from sqlparse . sql import Token , Statement [EOL] from sqlparse . tokens import Punctuation [EOL] [EOL] from . . errors import PhonygresError [EOL] [EOL] class StatementIter : [EOL] statement = ... [EOL] iter = ... [EOL] peek_val = ... [EOL] [EOL] def __init__ ( self , statement ) : [EOL] self . statement = statement [EOL] self . peek_val = None [EOL] self . iter = self . _iter ( ) [EOL] [EOL] def _iter ( self ) : [EOL] idx = [number] [EOL] [EOL] while True : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] while self . peek_val is not None : [EOL] v = self . peek_val [EOL] self . peek_val = None [EOL] yield v [EOL] [EOL] idx , t = self . statement . token_next ( idx , skip_ws = True , skip_cm = True ) [EOL] [EOL] if t is None : [EOL] return [EOL] elif t . ttype == Punctuation : [EOL] continue [EOL] else : [EOL] yield t [EOL] [EOL] def peek ( self ) : [EOL] if self . peek_val is not None : [EOL] return self . peek_val [EOL] [EOL] self . peek_val = self . next ( ) [EOL] return self . peek_val [EOL] [EOL] def next ( self ) : [EOL] try : [EOL] return next ( self . iter ) [EOL] except StopIteration : [EOL] raise PhonygresError ( [string] , f' [string] ' ) [EOL] [EOL] def next_opt ( self ) : [EOL] try : [EOL] return next ( self . iter ) [EOL] except StopIteration : [EOL] return None [EOL] [EOL] def has_next ( self ) : [EOL] t = self . next_opt ( ) [EOL] if t is None : [EOL] return False [EOL] else : [EOL] self . peek_val = t [EOL] return True [EOL] [EOL] def assert_next ( self , value ) : [EOL] t = self . next ( ) [EOL] if t . normalized != value : [EOL] raise PhonygresError ( [string] , f' [string] { t . value } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlparse.sql.Statement$ 0 0 0 $typing.Iterator[sqlparse.sql.Token]$ 0 0 0 $typing.Optional[sqlparse.sql.Token]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[sqlparse.sql.Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlparse.sql.Token$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlparse.sql.Token$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[sqlparse.sql.Token]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Any , List [EOL] import util [EOL] import ddl [EOL] import typing [EOL] import sqlparse [EOL] import ast [EOL] import phonygres [EOL] from typing import cast , List , Any [EOL] [EOL] from sqlparse import tokens , sql [EOL] [EOL] from . util import StatementIter [EOL] from . . errors import PhonygresError [EOL] from . . ast import CreateStatement , CreateTable [EOL] from . . ddl import Column [EOL] from . . ddl . data_types import aliases , DataType [EOL] [EOL] def parse_create ( it ) : [EOL] t = it . next ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] while t . normalized in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] t = it . next ( ) [EOL] [EOL] tv = t . normalized [EOL] if tv == [string] : [EOL] it . assert_next ( [string] ) [EOL] return None [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] it . assert_next ( [string] ) [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] it . assert_next ( [string] ) [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] return parse_create_table ( it ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] elif tv == [string] : [EOL] raise NotImplementedError ( ) [EOL] else : [EOL] raise PhonygresError ( [string] , f' [string] { t . value } [string] ' ) [EOL] [EOL] def parse_create_table ( it ) : [EOL] if_not_exists = False [EOL] [EOL] name = it . next ( ) [EOL] if name . ttype == tokens . Keyword : [EOL] if name . normalized != [string] : [EOL] raise PhonygresError ( [string] , f' [string] { name . value } [string] ' ) [EOL] it . assert_next ( [string] ) [EOL] it . assert_next ( [string] ) [EOL] if_not_exists = True [EOL] name = it . next ( ) [EOL] [EOL] statement = CreateTable ( name = name . value , if_not_exists = if_not_exists , columns = parse_columns ( it ) ) [EOL] [EOL] return statement [EOL] [EOL] def parse_columns ( it ) : [EOL] [comment] [EOL] root = it . next ( ) [EOL] if not isinstance ( root , sql . Parenthesis ) : [EOL] raise PhonygresError ( [string] , f' [string] { root . value } [string] ' ) [EOL] [EOL] columns = [ ] [EOL] sub_it = StatementIter ( cast ( sql . Statement , root ) ) [EOL] [EOL] while True : [EOL] [comment] [EOL] name = sub_it . next_opt ( ) [EOL] if name is None : [EOL] break [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not isinstance ( name , sql . Identifier ) : [EOL] break [comment] [EOL] [EOL] [comment] [EOL] data_type_parts = [ ] [EOL] args = [ ] [comment] [EOL] while sub_it . has_next ( ) and sub_it . peek ( ) . ttype is tokens . Name . Builtin : [EOL] data_type_parts . append ( sub_it . next ( ) ) [EOL] data_type_str = [string] . join ( [ t . normalized for t in data_type_parts ] ) . lower ( ) [EOL] [comment] [EOL] data_type = aliases . get ( data_type_str ) ( * args ) [comment] [EOL] if data_type is None : [EOL] raise PhonygresError ( [string] , f' [string] { data_type_str } [string] ' ) [EOL] [EOL] [comment] [EOL] collate = None [EOL] if sub_it . has_next ( ) and sub_it . peek ( ) . normalized == [string] : [EOL] sub_it . next ( ) [comment] [EOL] collate = sub_it . next ( ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] columns . append ( Column ( name . value , data_type , collate . normalized if collate is not None else None ) ) [EOL] [EOL] return columns [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ddl.Column]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . parse import parse_sql [EOL]	0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from enum import Enum [EOL] from typing import NamedTuple , Union [EOL] [EOL] class IsolationLevel ( Enum ) : [EOL] serializable = [string] [EOL] repeatable_read = [string] [EOL] read_committed = [string] [EOL] read_uncommited = [string] [EOL] [EOL] class StartTransaction ( NamedTuple ) : [EOL] deferrable = ... [EOL] read_only = ... [EOL] isolation_level = ... [EOL] [EOL] class Commit : [EOL] pass [EOL] [EOL] class Rollback : [EOL] pass [EOL] [EOL] class Savepoint ( NamedTuple ) : [EOL] name = ... [EOL] [EOL] class RollbackToSavepoint ( NamedTuple ) : [EOL] name = ... [EOL] [EOL] class ReleaseSavepoint ( NamedTuple ) : [EOL] name = ... [EOL] [EOL] TransactionStatement = Union [ StartTransaction , Commit , Rollback , Savepoint , RollbackToSavepoint , ReleaseSavepoint , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $IsolationLevel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from typing import Union [EOL] [EOL] from . create import * [EOL] from . transactions import * [EOL] [EOL] [EOL] Statement = Union [ CreateStatement , TransactionStatement , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import List , Union , NamedTuple [EOL] [EOL] from . . ddl import Column [EOL] [EOL] class CreateTable ( NamedTuple ) : [EOL] name = ... [EOL] if_not_exists = ... [EOL] columns = ... [EOL] [EOL] CreateStatement = Union [ CreateTable ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.List[ddl.Column]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Optional [EOL] import data_types [EOL] import phonygres [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from . data_types import DataType [EOL] [EOL] class Column : [EOL] name = ... [EOL] data_type = ... [EOL] collate = ... [EOL] [EOL] def __init__ ( self , name , data_type , collate = None ) : [EOL] self . name = name [EOL] self . data_type = data_type [EOL] self . collate = collate [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . name } [string] { self . data_type . __class__ . __name__ } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $data_types.DataType$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $phonygres.ddl.data_types.DataType$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $phonygres.ddl.data_types.DataType$ 0 $phonygres.ddl.data_types.DataType$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Type , Any , List [EOL] import builtins [EOL] import typing [EOL] from typing import Any , List , Dict , Type [EOL] [EOL] class DataType : [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , DataType ) : [EOL] return False [EOL] [EOL] return self . __dict__ == other . __dict__ [EOL] [EOL] class Unsupported : [EOL] def __new__ ( cls , * args , ** kwargs ) : [EOL] [comment] [EOL] raise Exception ( [string] ) [EOL] [EOL] class BigInt ( DataType ) : [EOL] pass [EOL] [EOL] class BigSerial ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Bit ( DataType , Unsupported ) : [EOL] length = ... [EOL] [EOL] def __init__ ( self , n ) : [EOL] self . length = n [EOL] [EOL] class BitVarying ( DataType , Unsupported ) : [EOL] length = ... [EOL] [EOL] def __init__ ( self , n ) : [EOL] self . length = n [EOL] [EOL] class Boolean ( DataType ) : [EOL] pass [EOL] [EOL] class Box ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class ByteA ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Character ( DataType , Unsupported ) : [EOL] length = ... [EOL] [EOL] def __init__ ( self , n ) : [EOL] self . length = n [EOL] [EOL] class CharacterVarying ( DataType ) : [EOL] pass [EOL] [EOL] class CIDR ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Circle ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Date ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class DoublePrecision ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class INet ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Integer ( DataType ) : [EOL] pass [EOL] [EOL] class Interval ( DataType , Unsupported ) : [EOL] fields = ... [EOL] p = ... [EOL] [EOL] def __init__ ( self , fields , p ) : [EOL] self . fields = fields [EOL] self . p = p [EOL] [EOL] class JSON ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class JSONB ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Line ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class LSeg ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class MacAddr ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class MacAddr8 ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Money ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Numeric ( DataType , Unsupported ) : [EOL] p = ... [EOL] s = ... [EOL] [EOL] def __init__ ( self , p , s ) : [EOL] self . p = p [EOL] self . s = s [EOL] [EOL] class Path ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class PGLSN ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Point ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Polygon ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Real ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class SmallInt ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class SmallSerial ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Serial ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Text ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class Time ( DataType , Unsupported ) : [EOL] p = ... [EOL] with_time_zone = ... [EOL] [EOL] def __init__ ( self , p , with_time_zone ) : [EOL] self . p = p [EOL] self . with_time_zone = with_time_zone [EOL] [EOL] class Timestamp ( DataType , Unsupported ) : [EOL] p = ... [EOL] with_time_zone = ... [EOL] [EOL] def __init__ ( self , p , with_time_zone ) : [EOL] self . p = p [EOL] self . with_time_zone = with_time_zone [EOL] [EOL] class TSQuery ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class TSVector ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class TXIDSnapshot ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class UUID ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] class XML ( DataType , Unsupported ) : [EOL] pass [EOL] [EOL] aliases = { [string] : BigInt , [string] : BigInt , [string] : BigSerial , [string] : BigSerial , [string] : Bit , [string] : BitVarying , [string] : BitVarying , [string] : Boolean , [string] : Boolean , [string] : Box , [string] : ByteA , [string] : Character , [string] : Character , [string] : CharacterVarying , [string] : CharacterVarying , [string] : CIDR , [string] : Circle , [string] : Date , [string] : DoublePrecision , [string] : DoublePrecision , [string] : INet , [string] : Integer , [string] : Integer , [string] : Integer , [string] : Interval , [string] : JSON , [string] : JSONB , [string] : Line , [string] : LSeg , [string] : MacAddr , [string] : MacAddr8 , [string] : Money , [string] : Numeric , [string] : Numeric , [string] : Path , [string] : PGLSN , [string] : Point , [string] : Polygon , [string] : Real , [string] : Real , [string] : SmallInt , [string] : SmallInt , [string] : SmallSerial , [string] : SmallSerial , [string] : Serial , [string] : Serial , [string] : Text , [string] : Time , [string] : Time , [string] : Time , [string] : Time , [string] : Timestamp , [string] : Timestamp , [string] : Timestamp , [string] : Timestamp , [string] : TSQuery , [string] : TSVector , [string] : TXIDSnapshot , [string] : UUID , [string] : XML , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[DataType]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import column [EOL] import phonygres [EOL] import builtins [EOL] import typing [EOL] from typing import List [EOL] [EOL] from . column import Column [EOL] [EOL] class Table : [EOL] columns = ... [EOL] [EOL] def __init__ ( self , name , columns ) : [EOL] self . name = name [EOL] self . columns = columns [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[column.Column]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[phonygres.ddl.column.Column]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[phonygres.ddl.column.Column]$ 0 $typing.List[phonygres.ddl.column.Column]$ 0
from . schema import Schema [EOL] from . table import Table [EOL] from . column import Column [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import phonygres [EOL] import builtins [EOL] import table [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import Dict [EOL] [EOL] from . table import Table [EOL] from . . errors import PhonygresError [EOL] [EOL] class Schema : [EOL] name = ... [EOL] tables = ... [EOL] [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] self . tables = { } [EOL] [EOL] def add_table ( self , table ) : [EOL] if table . name in self . tables : [EOL] raise PhonygresError ( [string] , f' [string] { table . name } [string] ' ) [EOL] [EOL] self . tables [ table . name ] = table [EOL] return self [EOL] [EOL] def drop_table ( self , table ) : [EOL] if table . name not in self . tables : [EOL] raise PhonygresError ( [string] , f' [string] { table . name } [string] ' ) [EOL] [EOL] del self . tables [ table . name ] [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,table.Table]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,phonygres.ddl.table.Table]$ 0 0 0 0 0 0 $Schema$ 0 0 0 $table.Table$ 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 $table.Table$ 0 0 0 0 $table.Table$ 0 0 0 0 0 0 $Schema$ 0 0 0 $table.Table$ 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $table.Table$ 0 0 0 0 0 0 0