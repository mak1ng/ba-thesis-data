[comment] [EOL] from typing import Any [EOL] import typing [EOL] import argparse [EOL] import json [EOL] import yaml [EOL] import sys [EOL] import argparse [EOL] from datetime import datetime , timezone [EOL] import dbt . clients . registry as registry [EOL] [EOL] [EOL] def yaml_type ( fname ) : [EOL] with open ( fname ) as f : [EOL] return yaml . load ( f ) [EOL] [EOL] [EOL] def parse_args ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = yaml_type , default = [string] ) [EOL] parser . add_argument ( [string] , required = True ) [EOL] return parser . parse_args ( ) [EOL] [EOL] [EOL] def get_full_name ( args ) : [EOL] return [string] . format ( args . namespace , args . project [ [string] ] ) [EOL] [EOL] [EOL] def init_project_in_packages ( args , packages ) : [EOL] full_name = get_full_name ( args ) [EOL] if full_name not in packages : [EOL] packages [ full_name ] = { [string] : args . project [ [string] ] , [string] : args . namespace , [string] : args . project [ [string] ] , [string] : { } , [string] : { } , } [EOL] return packages [ full_name ] [EOL] [EOL] [EOL] def add_version_to_package ( args , project_json ) : [EOL] project_json [ [string] ] [ args . project [ [string] ] ] = { [string] : [string] . format ( get_full_name ( args ) , args . project [ [string] ] ) , [string] : args . project [ [string] ] , [string] : args . project [ [string] ] , [string] : [string] , [string] : datetime . now ( timezone . utc ) . astimezone ( ) . isoformat ( ) , [string] : args . project . get ( [string] ) or [ ] , [string] : [ ] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , } [EOL] [EOL] [EOL] def main ( ) : [EOL] args = parse_args ( ) [EOL] packages = registry . packages ( ) [EOL] project_json = init_project_in_packages ( args , packages ) [EOL] if args . project [ [string] ] in project_json [ [string] ] : [EOL] raise Exception ( [string] . format ( args . project [ [string] ] ) , file = sys . stderr ) [EOL] add_version_to_package ( args , project_json ) [EOL] print ( json . dumps ( packages , indent = [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import os [EOL] import sys [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] from setuptools import setup [EOL] try : [EOL] from setuptools import find_namespace_packages [EOL] except ImportError : [EOL] [comment] [EOL] print ( [string] ) [EOL] print ( [string] [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def read ( fname ) : [EOL] return open ( os . path . join ( os . path . dirname ( __file__ ) , fname ) ) . read ( ) [EOL] [EOL] [EOL] package_name = [string] [EOL] package_version = [string] [EOL] description = [string] [EOL] [EOL] [EOL] setup ( name = package_name , version = package_version , description = description , long_description = description , author = [string] , author_email = [string] , url = [string] , packages = find_namespace_packages ( include = [ [string] , [string] ] ) , package_data = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] } , test_suite = [string] , entry_points = { [string] : [ [string] , ] , } , scripts = [ [string] , ] , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , zip_safe = False , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , python_requires = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , List [EOL] import typing [EOL] import argparse [EOL] import core [EOL] import pathlib [EOL] import argparse [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] PROJECT_TEMPLATE = [string] [EOL] [EOL] [EOL] SETUP_PY_TEMPLATE = [string] . lstrip ( ) [EOL] [EOL] ADAPTER_INIT_TEMPLATE = [string] . lstrip ( ) [EOL] [EOL] [EOL] ADAPTER_CONNECTIONS_TEMPLATE = [string] . lstrip ( ) [EOL] [EOL] [EOL] ADAPTER_IMPL_TEMPLATE = [string] . lstrip ( ) [EOL] [EOL] [EOL] CATALOG_MACRO_TEMPLATE = [string] [EOL] [EOL] [EOL] INCLUDE_INIT_TEXT = [string] . lstrip ( ) [EOL] [EOL] [EOL] class Builder : [EOL] def __init__ ( self , args ) : [EOL] self . args = args [EOL] self . adapter = self . args . adapter [EOL] self . dest = self . args . root / self . adapter [EOL] [comment] [EOL] self . dbt_dir = Path ( [string] ) [EOL] self . adapters = self . dbt_dir / [string] / self . adapter [EOL] self . include = self . dbt_dir / [string] / self . adapter [EOL] if self . dest . exists ( ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] def go ( self ) : [EOL] self . write_setup ( ) [EOL] self . write_adapter ( ) [EOL] self . write_include ( ) [EOL] [EOL] def include_paths ( self ) : [EOL] return [ self . include / [string] / [string] , self . include / [string] , ] [EOL] [EOL] def dest_path ( self , * paths ) : [EOL] return self . dest . joinpath ( * paths ) [EOL] [EOL] def write_setup ( self ) : [EOL] self . dest . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] dbt_core_str = [string] . format ( self . args . dbt_core_version ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] package_data = [string] . join ( [string] . format ( [number] * [string] , p . relative_to ( self . dbt_dir ) ) for p in self . include_paths ( ) ) [EOL] [EOL] setup_py_contents = SETUP_PY_TEMPLATE . format ( adapter = self . adapter , version = self . args . package_version , author_name = self . args . author , author_email = self . args . email , url = self . args . url , dbt_core_str = dbt_core_str , dependencies = self . args . dependency , package_data = package_data , ) [EOL] self . dest_path ( [string] ) . write_text ( setup_py_contents ) [EOL] [EOL] def _make_adapter_kwargs ( self ) : [EOL] if self . args . sql : [EOL] kwargs = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] else : [EOL] kwargs = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] kwargs . update ( { [string] : self . adapter . upper ( ) , [string] : self . args . title_case , [string] : self . adapter , } ) [EOL] [EOL] return kwargs [EOL] [EOL] def write_adapter ( self ) : [EOL] adapters_dest = self . dest_path ( self . adapters ) [EOL] adapters_dest . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] kwargs = self . _make_adapter_kwargs ( ) [EOL] [EOL] init_text = ADAPTER_INIT_TEMPLATE . format ( adapter = self . adapter , title_adapter = self . args . title_case ) [EOL] connections_text = ADAPTER_CONNECTIONS_TEMPLATE . format ( ** kwargs ) [EOL] impl_text = ADAPTER_IMPL_TEMPLATE . format ( ** kwargs ) [EOL] [EOL] ( adapters_dest / [string] ) . write_text ( init_text ) [EOL] ( adapters_dest / [string] ) . write_text ( connections_text ) [EOL] ( adapters_dest / [string] ) . write_text ( impl_text ) [EOL] [EOL] def write_include ( self ) : [EOL] include_dest = self . dest_path ( self . include ) [EOL] include_dest . mkdir ( parents = True , exist_ok = True ) [EOL] macros_dest = include_dest / [string] [EOL] macros_dest . mkdir ( exist_ok = True ) [EOL] [EOL] dbt_project_text = PROJECT_TEMPLATE . format ( adapter = self . adapter , version = self . args . project_version , ) [EOL] catalog_macro_text = CATALOG_MACRO_TEMPLATE . format ( adapter = self . adapter ) [EOL] [EOL] ( include_dest / [string] ) . write_text ( INCLUDE_INIT_TEXT ) [EOL] ( include_dest / [string] ) . write_text ( dbt_project_text ) [EOL] [comment] [EOL] ( macros_dest / [string] ) . write_text ( catalog_macro_text ) [EOL] [EOL] [EOL] def parse_args ( argv = None ) : [EOL] if argv is None : [EOL] argv = sys . argv [ [number] : ] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = Path ) [EOL] parser . add_argument ( [string] ) [EOL] parser . add_argument ( [string] , [string] , default = None ) [EOL] parser . add_argument ( [string] , action = [string] ) [EOL] parser . add_argument ( [string] , default = [string] ) [EOL] parser . add_argument ( [string] ) [EOL] parser . add_argument ( [string] ) [EOL] parser . add_argument ( [string] ) [EOL] parser . add_argument ( [string] , action = [string] ) [EOL] parser . add_argument ( [string] , default = [string] ) [EOL] parser . add_argument ( [string] , default = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] ) [EOL] parsed = parser . parse_args ( ) [EOL] [EOL] if parsed . title_case is None : [EOL] parsed . title_case = parsed . adapter . title ( ) [EOL] [EOL] if parsed . set_dependency : [EOL] [EOL] prefix = [string] [EOL] [EOL] if parsed . dependency : [EOL] [comment] [EOL] [EOL] parsed . dependency = prefix + prefix . join ( [string] . format ( d ) for d in parsed . dependency ) [EOL] else : [EOL] parsed . dependency = prefix + [string] [EOL] else : [EOL] parsed . dependency = [string] [EOL] [EOL] if parsed . email is not None : [EOL] parsed . email = [string] . format ( parsed . email ) [EOL] else : [EOL] parsed . email = [string] [EOL] if parsed . author is not None : [EOL] parsed . author = [string] . format ( parsed . author ) [EOL] else : [EOL] parsed . author = [string] [EOL] if parsed . url is not None : [EOL] parsed . url = [string] . format ( parsed . url ) [EOL] else : [EOL] parsed . url = [string] [EOL] return parsed [EOL] [EOL] [EOL] def main ( ) : [EOL] builder = Builder ( parse_args ( ) ) [EOL] builder . go ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] import os [EOL] import multiprocessing [EOL] from pathlib import Path [EOL] from typing import Optional [EOL] [EOL] [comment] [EOL] [comment] [EOL] STRICT_MODE = None [EOL] FULL_REFRESH = None [EOL] USE_CACHE = None [EOL] WARN_ERROR = None [EOL] TEST_NEW_PARSER = None [EOL] WRITE_JSON = None [EOL] PARTIAL_PARSE = None [EOL] USE_COLORS = None [EOL] [EOL] [EOL] def env_set_truthy ( key ) : [EOL] [docstring] [EOL] value = os . getenv ( key ) [EOL] if not value or value . lower ( ) in ( [string] , [string] , [string] ) : [EOL] return None [EOL] return value [EOL] [EOL] [EOL] def env_set_path ( key ) : [EOL] value = os . getenv ( key ) [EOL] if value is None : [EOL] return value [EOL] else : [EOL] return Path ( value ) [EOL] [EOL] [EOL] SINGLE_THREADED_WEBSERVER = env_set_truthy ( [string] ) [EOL] SINGLE_THREADED_HANDLER = env_set_truthy ( [string] ) [EOL] MACRO_DEBUGGING = env_set_truthy ( [string] ) [EOL] DEFER_MODE = env_set_truthy ( [string] ) [EOL] ARTIFACT_STATE_PATH = env_set_path ( [string] ) [EOL] [EOL] [EOL] def _get_context ( ) : [EOL] [comment] [EOL] return multiprocessing . get_context ( [string] ) [EOL] [EOL] [EOL] MP_CONTEXT = _get_context ( ) [EOL] [EOL] [EOL] def reset ( ) : [EOL] global STRICT_MODE , FULL_REFRESH , USE_CACHE , WARN_ERROR , TEST_NEW_PARSER , WRITE_JSON , PARTIAL_PARSE , MP_CONTEXT , USE_COLORS [EOL] [EOL] STRICT_MODE = False [EOL] FULL_REFRESH = False [EOL] USE_CACHE = True [EOL] WARN_ERROR = False [EOL] TEST_NEW_PARSER = False [EOL] WRITE_JSON = True [EOL] PARTIAL_PARSE = False [EOL] MP_CONTEXT = _get_context ( ) [EOL] USE_COLORS = True [EOL] [EOL] [EOL] def set_from_args ( args ) : [EOL] global STRICT_MODE , FULL_REFRESH , USE_CACHE , WARN_ERROR , TEST_NEW_PARSER , WRITE_JSON , PARTIAL_PARSE , MP_CONTEXT , USE_COLORS [EOL] [EOL] USE_CACHE = getattr ( args , [string] , USE_CACHE ) [EOL] [EOL] FULL_REFRESH = getattr ( args , [string] , FULL_REFRESH ) [EOL] STRICT_MODE = getattr ( args , [string] , STRICT_MODE ) [EOL] WARN_ERROR = ( STRICT_MODE or getattr ( args , [string] , STRICT_MODE or WARN_ERROR ) ) [EOL] [EOL] TEST_NEW_PARSER = getattr ( args , [string] , TEST_NEW_PARSER ) [EOL] WRITE_JSON = getattr ( args , [string] , WRITE_JSON ) [EOL] PARTIAL_PARSE = getattr ( args , [string] , None ) [EOL] MP_CONTEXT = _get_context ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] use_colors_override = getattr ( args , [string] ) [EOL] [EOL] if use_colors_override is not None : [EOL] USE_COLORS = use_colors_override [EOL] [EOL] [EOL] [comment] [EOL] reset ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 $None$ 0 $None$ 0 $None$ 0 $None$ 0 $None$ 0 $typing.Any$ 0 $None$ 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 $None$ 0 $None$ 0 $None$ 0 $None$ 0 $None$ 0 $typing.Any$ 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0
ProfileConfigDocs = [string] [EOL] SnowflakeQuotingDocs = [string] [EOL] IncrementalDocs = [string] [EOL] BigQueryNewPartitionBy = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from dbt . adapters . factory import get_adapter [EOL] from dbt . parser . manifest import load_manifest [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . config import RuntimeConfig [EOL] [EOL] [EOL] def get_full_manifest ( config , * , reset = False , ) : [EOL] [docstring] [EOL] adapter = get_adapter ( config ) [comment] [EOL] if reset : [EOL] config . clear_dependencies ( ) [EOL] adapter . clear_macro_manifest ( ) [EOL] [EOL] internal = adapter . load_macro_manifest ( ) [EOL] [EOL] return load_manifest ( config , internal , adapter . connections . set_query_header , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , List , Set , ContextManager , Dict , Optional , Type [EOL] import builtins [EOL] import core [EOL] import typing [EOL] import hologram [EOL] import logbook [EOL] import dbt . flags [EOL] import dbt . ui [EOL] [EOL] import json [EOL] import logging [EOL] import os [EOL] import sys [EOL] import time [EOL] import warnings [EOL] from dataclasses import dataclass [EOL] from datetime import datetime [EOL] from typing import Optional , List , ContextManager , Callable , Dict , Any , Set [EOL] [EOL] import colorama [EOL] import logbook [EOL] from hologram import JsonSchemaMixin [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] colorama_stdout = sys . stdout [EOL] colorama_wrap = True [EOL] [EOL] colorama . init ( wrap = colorama_wrap ) [EOL] [EOL] [EOL] if sys . platform == [string] and not os . getenv ( [string] ) : [EOL] colorama_wrap = False [EOL] colorama_stdout = colorama . AnsiToWin32 ( sys . stdout ) . stream [EOL] [EOL] elif sys . platform == [string] : [EOL] colorama_wrap = False [EOL] [EOL] colorama . init ( wrap = colorama_wrap ) [EOL] [EOL] [EOL] STDOUT_LOG_FORMAT = [string] [EOL] DEBUG_LOG_FORMAT = ( [string] [string] [string] ) [EOL] [EOL] [EOL] ExceptionInformation = str [EOL] Extras = Dict [ str , Any ] [EOL] [EOL] [EOL] @ dataclass class LogMessage ( JsonSchemaMixin ) : [EOL] timestamp = ... [EOL] message = ... [EOL] channel = ... [EOL] level = ... [EOL] levelname = ... [EOL] thread_name = ... [EOL] process = ... [EOL] extra = None [EOL] exc_info = None [EOL] [EOL] @ classmethod def from_record_formatted ( cls , record , message ) : [EOL] extra = dict ( record . extra ) [EOL] log_message = LogMessage ( timestamp = record . time , message = message , channel = record . channel , level = record . level , levelname = logbook . get_level_name ( record . level ) , extra = extra , thread_name = record . thread_name , process = record . process , exc_info = record . formatted_exception , ) [EOL] return log_message [EOL] [EOL] [EOL] class LogMessageFormatter ( logbook . StringFormatter ) : [EOL] def __call__ ( self , record , handler ) : [EOL] data = self . format_record ( record , handler ) [EOL] exc = self . format_exception ( record ) [EOL] if exc : [EOL] data . exc_info = exc [EOL] return data [EOL] [EOL] def format_record ( self , record , handler ) : [EOL] message = super ( ) . format_record ( record , handler ) [EOL] return LogMessage . from_record_formatted ( record , message ) [EOL] [EOL] [EOL] class JsonFormatter ( LogMessageFormatter ) : [EOL] def __call__ ( self , record , handler ) : [EOL] [docstring] [EOL] [comment] [EOL] import dbt . utils [EOL] log_message = super ( ) . __call__ ( record , handler ) [EOL] return json . dumps ( log_message . to_dict ( ) , cls = dbt . utils . JSONEncoder ) [EOL] [EOL] [EOL] class FormatterMixin : [EOL] def __init__ ( self , format_string ) : [EOL] self . _text_format_string = format_string [EOL] self . formatter_class = logbook . StringFormatter [EOL] [comment] [EOL] self . format_string = self . _text_format_string [EOL] [EOL] def format_json ( self ) : [EOL] [comment] [EOL] self . formatter_class = JsonFormatter [EOL] self . format_string = STDOUT_LOG_FORMAT [EOL] [EOL] def format_text ( self ) : [EOL] [comment] [EOL] self . formatter_class = logbook . StringFormatter [EOL] self . format_string = self . _text_format_string [EOL] [EOL] def reset ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [EOL] class OutputHandler ( logbook . StreamHandler , FormatterMixin ) : [EOL] [docstring] [EOL] def __init__ ( self , stream , level = logbook . INFO , format_string = STDOUT_LOG_FORMAT , bubble = True , ) : [EOL] self . _default_format = format_string [EOL] logbook . StreamHandler . __init__ ( self , stream = stream , level = level , format_string = format_string , bubble = bubble , ) [EOL] FormatterMixin . __init__ ( self , format_string ) [EOL] [EOL] def set_text_format ( self , format_string ) : [EOL] [docstring] [EOL] if self . formatter_class is logbook . StringFormatter : [EOL] [comment] [EOL] self . _text_format_string = format_string [EOL] self . format_text ( ) [EOL] [EOL] def reset ( self ) : [EOL] self . level = logbook . INFO [EOL] self . _text_format_string = self . _default_format [EOL] self . format_text ( ) [EOL] [EOL] def should_handle ( self , record ) : [EOL] if record . level < self . level : [EOL] return False [EOL] text_mode = self . formatter_class is logbook . StringFormatter [EOL] if text_mode and record . extra . get ( [string] , False ) : [EOL] return False [EOL] elif not text_mode and record . extra . get ( [string] , False ) : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] [EOL] def _redirect_std_logging ( ) : [EOL] logbook . compat . redirect_logging ( ) [EOL] [EOL] [EOL] def _root_channel ( record ) : [EOL] return record . channel . split ( [string] ) [ [number] ] [EOL] [EOL] [EOL] class Relevel ( logbook . Processor ) : [EOL] def __init__ ( self , allowed , min_level = logbook . WARNING , target_level = logbook . DEBUG , ) : [EOL] self . allowed = set ( allowed ) [EOL] self . min_level = min_level [EOL] self . target_level = target_level [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] if _root_channel ( record ) in self . allowed : [EOL] return [EOL] record . extra [ [string] ] = record . level [EOL] [comment] [EOL] if record . level < self . min_level : [EOL] record . level = logbook . NOTSET [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] record . level = self . target_level [EOL] [EOL] [EOL] class JsonOnly ( logbook . Processor ) : [EOL] def process ( self , record ) : [EOL] record . extra [ [string] ] = True [EOL] [EOL] [EOL] class TextOnly ( logbook . Processor ) : [EOL] def process ( self , record ) : [EOL] record . extra [ [string] ] = True [EOL] [EOL] [EOL] class TimingProcessor ( logbook . Processor ) : [EOL] def __init__ ( self , timing_info = None ) : [EOL] self . timing_info = timing_info [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] if self . timing_info is not None : [EOL] record . extra [ [string] ] = self . timing_info . to_dict ( ) [EOL] [EOL] [EOL] class DbtProcessState ( logbook . Processor ) : [EOL] def __init__ ( self , value ) : [EOL] self . value = value [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] overwrite = ( [string] not in record . extra or record . extra [ [string] ] == [string] ) [EOL] if overwrite : [EOL] record . extra [ [string] ] = self . value [EOL] [EOL] [EOL] class DbtModelState ( logbook . Processor ) : [EOL] def __init__ ( self , state ) : [EOL] self . state = state [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] record . extra . update ( self . state ) [EOL] [EOL] [EOL] class DbtStatusMessage ( logbook . Processor ) : [EOL] def process ( self , record ) : [EOL] record . extra [ [string] ] = True [EOL] [EOL] [EOL] class UniqueID ( logbook . Processor ) : [EOL] def __init__ ( self , unique_id ) : [EOL] self . unique_id = unique_id [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] record . extra [ [string] ] = self . unique_id [EOL] [EOL] [EOL] class NodeCount ( logbook . Processor ) : [EOL] def __init__ ( self , node_count ) : [EOL] self . node_count = node_count [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] record . extra [ [string] ] = self . node_count [EOL] [EOL] [EOL] class NodeMetadata ( logbook . Processor ) : [EOL] def __init__ ( self , node , index ) : [EOL] self . node = node [EOL] self . index = index [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def mapping_keys ( self ) : [EOL] return [ ] [EOL] [EOL] def process_keys ( self , record ) : [EOL] for attr , key in self . mapping_keys ( ) : [EOL] value = getattr ( self . node , attr , None ) [EOL] if value is not None : [EOL] record . extra [ key ] = value [EOL] [EOL] def process ( self , record ) : [EOL] self . process_keys ( record ) [EOL] record . extra [ [string] ] = self . index [EOL] [EOL] [EOL] class ModelMetadata ( NodeMetadata ) : [EOL] def mapping_keys ( self ) : [EOL] return [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] def process_config ( self , record ) : [EOL] if hasattr ( self . node , [string] ) : [EOL] materialized = getattr ( self . node . config , [string] , None ) [EOL] if materialized is not None : [EOL] record . extra [ [string] ] = materialized [EOL] [EOL] def process ( self , record ) : [EOL] super ( ) . process ( record ) [EOL] self . process_config ( record ) [EOL] [EOL] [EOL] class HookMetadata ( NodeMetadata ) : [EOL] def mapping_keys ( self ) : [EOL] return [ ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] [EOL] class TimestampNamed ( logbook . Processor ) : [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] super ( ) . process ( record ) [EOL] record . extra [ self . name ] = datetime . utcnow ( ) . isoformat ( ) [EOL] [EOL] [EOL] logger = logbook . Logger ( [string] ) [EOL] [comment] [EOL] CACHE_LOGGER = logbook . Logger ( [string] ) [EOL] CACHE_LOGGER . disable ( ) [EOL] [EOL] warnings . filterwarnings ( [string] , category = ResourceWarning , message = [string] ) [EOL] [EOL] initialized = False [EOL] [EOL] [EOL] def make_log_dir_if_missing ( log_dir ) : [EOL] import dbt . clients . system [EOL] dbt . clients . system . make_directory ( log_dir ) [EOL] [EOL] [EOL] class DebugWarnings ( logbook . compat . redirected_warnings ) : [EOL] [docstring] [EOL] def make_record ( self , message , exception , filename , lineno ) : [EOL] rv = super ( ) . make_record ( message , exception , filename , lineno ) [EOL] rv . level = logbook . DEBUG [EOL] rv . extra [ [string] ] = True [EOL] return rv [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] DebugWarnings ( ) . __enter__ ( ) [EOL] [comment] [EOL] _redirect_std_logging ( ) [EOL] [EOL] [EOL] class DelayedFileHandler ( logbook . RotatingFileHandler , FormatterMixin ) : [EOL] def __init__ ( self , log_dir = None , level = logbook . DEBUG , filter = None , bubble = True , max_size = [number] * [number] * [number] , backup_count = [number] , ) : [EOL] self . disabled = False [EOL] self . _msg_buffer = [ ] [EOL] [comment] [EOL] self . _bufmax = [number] [EOL] self . _log_path = None [EOL] [comment] [EOL] logbook . Handler . __init__ ( self , level , filter , bubble ) [EOL] if log_dir is not None : [EOL] self . set_path ( log_dir ) [EOL] self . _text_format_string = None [EOL] self . _max_size = max_size [EOL] self . _backup_count = backup_count [EOL] [EOL] def reset ( self ) : [EOL] if self . initialized : [EOL] self . close ( ) [EOL] self . _log_path = None [EOL] self . _msg_buffer = [ ] [EOL] self . disabled = False [EOL] [EOL] @ property def initialized ( self ) : [EOL] return self . _log_path is not None [EOL] [EOL] def set_path ( self , log_dir ) : [EOL] [docstring] [EOL] if self . disabled : [EOL] return [EOL] [EOL] assert not self . initialized , [string] [EOL] [EOL] if log_dir is None : [EOL] self . disabled = True [EOL] return [EOL] [EOL] make_log_dir_if_missing ( log_dir ) [EOL] log_path = os . path . join ( log_dir , [string] ) [EOL] self . _super_init ( log_path ) [EOL] self . _replay_buffered ( ) [EOL] self . _log_path = log_path [EOL] [EOL] def _super_init ( self , log_path ) : [EOL] logbook . RotatingFileHandler . __init__ ( self , filename = log_path , level = self . level , filter = self . filter , delay = True , max_size = self . _max_size , backup_count = self . _backup_count , bubble = self . bubble , format_string = DEBUG_LOG_FORMAT , ) [EOL] FormatterMixin . __init__ ( self , DEBUG_LOG_FORMAT ) [EOL] [EOL] def _replay_buffered ( self ) : [EOL] assert self . _msg_buffer is not None , [string] [EOL] for record in self . _msg_buffer : [EOL] super ( ) . emit ( record ) [EOL] self . _msg_buffer = None [EOL] [EOL] def format ( self , record ) : [EOL] msg = super ( ) . format ( record ) [EOL] subbed = str ( msg ) [EOL] for escape_sequence in dbt . ui . COLORS . values ( ) : [EOL] subbed = subbed . replace ( escape_sequence , [string] ) [EOL] return subbed [EOL] [EOL] def emit ( self , record ) : [EOL] [docstring] [EOL] if self . disabled : [EOL] return [EOL] elif self . initialized : [EOL] super ( ) . emit ( record ) [EOL] else : [EOL] assert self . _msg_buffer is not None , [string] [EOL] self . _msg_buffer . append ( record ) [EOL] assert len ( self . _msg_buffer ) < self . _bufmax , [string] [EOL] [EOL] [EOL] class LogManager ( logbook . NestedSetup ) : [EOL] def __init__ ( self , stdout = colorama_stdout , stderr = sys . stderr ) : [EOL] self . stdout = stdout [EOL] self . stderr = stderr [EOL] self . _null_handler = logbook . NullHandler ( ) [EOL] self . _output_handler = OutputHandler ( self . stdout ) [EOL] self . _file_handler = DelayedFileHandler ( ) [EOL] self . _relevel_processor = Relevel ( allowed = [ [string] , [string] ] ) [EOL] self . _state_processor = DbtProcessState ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _stack_depth = [number] [EOL] super ( ) . __init__ ( [ self . _null_handler , self . _output_handler , self . _file_handler , self . _relevel_processor , self . _state_processor , ] ) [EOL] [EOL] def push_application ( self ) : [EOL] self . _stack_depth += [number] [EOL] if self . _stack_depth == [number] : [EOL] super ( ) . push_application ( ) [EOL] [EOL] def pop_application ( self ) : [EOL] self . _stack_depth -= [number] [EOL] if self . _stack_depth == [number] : [EOL] super ( ) . pop_application ( ) [EOL] [EOL] def disable ( self ) : [EOL] self . add_handler ( logbook . NullHandler ( ) ) [EOL] [EOL] def add_handler ( self , handler ) : [EOL] [docstring] [EOL] self . objects . append ( handler ) [EOL] [EOL] [comment] [EOL] def stderr_console ( self ) : [EOL] [docstring] [EOL] self . _output_handler . stream = self . stderr [EOL] self . _output_handler . level = logbook . WARNING [EOL] [EOL] def stdout_console ( self ) : [EOL] [docstring] [EOL] self . _output_handler . stream = self . stdout [EOL] self . _output_handler . level = logbook . INFO [EOL] [EOL] def set_debug ( self ) : [EOL] self . _output_handler . set_text_format ( DEBUG_LOG_FORMAT ) [EOL] self . _output_handler . level = logbook . DEBUG [EOL] [EOL] def set_path ( self , path ) : [EOL] self . _file_handler . set_path ( path ) [EOL] [EOL] def initialized ( self ) : [EOL] return self . _file_handler . initialized [EOL] [EOL] def format_json ( self ) : [EOL] for handler in self . objects : [EOL] if isinstance ( handler , FormatterMixin ) : [EOL] handler . format_json ( ) [EOL] [EOL] def format_text ( self ) : [EOL] for handler in self . objects : [EOL] if isinstance ( handler , FormatterMixin ) : [EOL] handler . format_text ( ) [EOL] [EOL] def reset_handlers ( self ) : [EOL] [docstring] [EOL] self . stdout_console ( ) [EOL] for handler in self . objects : [EOL] if isinstance ( handler , FormatterMixin ) : [EOL] handler . reset ( ) [EOL] [EOL] def set_output_stream ( self , stream , error = None ) : [EOL] if error is None : [EOL] error = stream [EOL] [EOL] if self . _output_handler . stream is self . stdout : [EOL] self . _output_handler . stream = stream [EOL] elif self . _output_handler . stream is self . stderr : [EOL] self . _output_handler . stream = error [EOL] [EOL] self . stdout = stream [EOL] self . stderr = error [EOL] [EOL] [EOL] log_manager = LogManager ( ) [EOL] [EOL] [EOL] def log_cache_events ( flag ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] CACHE_LOGGER . disabled = not flag [EOL] [EOL] [EOL] GLOBAL_LOGGER = logger [EOL] [EOL] [EOL] class LogMessageHandler ( logbook . Handler ) : [EOL] formatter_class = LogMessageFormatter [EOL] [EOL] def format_logmessage ( self , record ) : [EOL] [docstring] [EOL] message = self . format ( record ) [EOL] return LogMessage . from_record_formatted ( record , message ) [EOL] [EOL] [EOL] class ListLogHandler ( LogMessageHandler ) : [EOL] def __init__ ( self , level = logbook . NOTSET , filter = None , bubble = False , lst = None ) : [EOL] super ( ) . __init__ ( level , filter , bubble ) [EOL] if lst is None : [EOL] lst = [ ] [EOL] self . records = lst [EOL] [EOL] def should_handle ( self , record ) : [EOL] [docstring] [EOL] if _root_channel ( record ) != [string] : [EOL] return False [EOL] return super ( ) . should_handle ( record ) [EOL] [EOL] def emit ( self , record ) : [EOL] as_dict = self . format_logmessage ( record ) [EOL] self . records . append ( as_dict ) [EOL] [EOL] [EOL] def _env_log_level ( var_name ) : [EOL] [comment] [EOL] if dbt . flags . env_set_truthy ( var_name ) : [EOL] return logging . DEBUG [EOL] else : [EOL] return logging . ERROR [EOL] [EOL] [EOL] LOG_LEVEL_GOOGLE = _env_log_level ( [string] ) [EOL] LOG_LEVEL_SNOWFLAKE = _env_log_level ( [string] ) [EOL] LOG_LEVEL_BOTOCORE = _env_log_level ( [string] ) [EOL] LOG_LEVEL_HTTP = _env_log_level ( [string] ) [EOL] LOG_LEVEL_WERKZEUG = _env_log_level ( [string] ) [EOL] [EOL] logging . getLogger ( [string] ) . setLevel ( LOG_LEVEL_BOTOCORE ) [EOL] logging . getLogger ( [string] ) . setLevel ( LOG_LEVEL_HTTP ) [EOL] logging . getLogger ( [string] ) . setLevel ( LOG_LEVEL_HTTP ) [EOL] logging . getLogger ( [string] ) . setLevel ( LOG_LEVEL_GOOGLE ) [EOL] logging . getLogger ( [string] ) . setLevel ( LOG_LEVEL_SNOWFLAKE ) [EOL] [EOL] logging . getLogger ( [string] ) . setLevel ( logging . ERROR ) [EOL] logging . getLogger ( [string] ) . setLevel ( LOG_LEVEL_WERKZEUG ) [EOL] [EOL] [EOL] def list_handler ( lst , level = logbook . NOTSET , ) : [EOL] [docstring] [EOL] return ListLogHandler ( lst = lst , level = level , bubble = True ) [EOL] [EOL] [EOL] def get_timestamp ( ) : [EOL] return time . strftime ( [string] ) [EOL] [EOL] [EOL] def print_timestamped_line ( msg , use_color = None ) : [EOL] if use_color is not None : [EOL] msg = dbt . ui . color ( msg , use_color ) [EOL] [EOL] GLOBAL_LOGGER . info ( [string] . format ( get_timestamp ( ) , msg ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[LogMessage]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logbook.LogRecord$ 0 0 0 $typing.Any$ 0 0 0 0 0 $logbook.LogRecord$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pstats [EOL] import cProfile [EOL] from contextlib import contextmanager [EOL] from cProfile import Profile [EOL] from pstats import Stats [EOL] [EOL] [EOL] @ contextmanager def profiler ( enable , outfile ) : [EOL] try : [EOL] if enable : [EOL] profiler = Profile ( ) [EOL] profiler . enable ( ) [EOL] [EOL] yield [EOL] finally : [EOL] if enable : [EOL] profiler . disable ( ) [EOL] stats = Stats ( profiler ) [EOL] stats . sort_stats ( [string] ) [EOL] stats . dump_stats ( outfile ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type , Tuple , AbstractSet [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import hologram [EOL] import pathlib [EOL] from dataclasses import dataclass [EOL] from datetime import timedelta [EOL] from pathlib import Path [EOL] from typing import NewType , Tuple , AbstractSet [EOL] [EOL] from hologram import ( FieldEncoder , JsonSchemaMixin , JsonDict , ValidationError ) [EOL] from hologram . helpers import StrEnum [EOL] [EOL] Port = NewType ( [string] , int ) [EOL] [EOL] [EOL] class PortEncoder ( FieldEncoder ) : [EOL] @ property def json_schema ( self ) : [EOL] return { [string] : [string] , [string] : [number] , [string] : [number] } [EOL] [EOL] [EOL] class TimeDeltaFieldEncoder ( FieldEncoder [ timedelta ] ) : [EOL] [docstring] [EOL] [EOL] def to_wire ( self , value ) : [EOL] return value . total_seconds ( ) [EOL] [EOL] def to_python ( self , value ) : [EOL] if isinstance ( value , timedelta ) : [EOL] return value [EOL] try : [EOL] return timedelta ( seconds = value ) [EOL] except TypeError : [EOL] raise ValidationError ( [string] . format ( value ) ) from None [EOL] [EOL] @ property def json_schema ( self ) : [EOL] return { [string] : [string] } [EOL] [EOL] [EOL] class PathEncoder ( FieldEncoder ) : [EOL] def to_wire ( self , value ) : [EOL] return str ( value ) [EOL] [EOL] def to_python ( self , value ) : [EOL] if isinstance ( value , Path ) : [EOL] return value [EOL] try : [EOL] return Path ( value ) [EOL] except TypeError : [EOL] raise ValidationError ( [string] . format ( value ) ) from None [EOL] [EOL] @ property def json_schema ( self ) : [EOL] return { [string] : [string] } [EOL] [EOL] [EOL] class NVEnum ( StrEnum ) : [EOL] novalue = [string] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , NVEnum ) [EOL] [EOL] [EOL] @ dataclass class NoValue ( JsonSchemaMixin ) : [EOL] [docstring] [EOL] novalue = NVEnum . novalue [EOL] [EOL] [EOL] JsonSchemaMixin . register_field_encoders ( { Port : PortEncoder ( ) , timedelta : TimeDeltaFieldEncoder ( ) , Path : PathEncoder ( ) , } ) [EOL] [EOL] [EOL] FQNPath = Tuple [ str , ... ] [EOL] PathSet = AbstractSet [ FQNPath ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterator , Optional [EOL] import builtins [EOL] import typing [EOL] import _importlib_modulespec [EOL] import requests [EOL] import importlib [EOL] import importlib . util [EOL] import os [EOL] import glob [EOL] import json [EOL] from typing import Iterator [EOL] [EOL] import requests [EOL] [EOL] import dbt . exceptions [EOL] import dbt . semver [EOL] [EOL] [EOL] PYPI_VERSION_URL = [string] [EOL] [EOL] [EOL] def get_latest_version ( ) : [EOL] try : [EOL] resp = requests . get ( PYPI_VERSION_URL ) [EOL] data = resp . json ( ) [EOL] version_string = data [ [string] ] [ [string] ] [EOL] except ( json . JSONDecodeError , KeyError , requests . RequestException ) : [EOL] return None [EOL] [EOL] return dbt . semver . VersionSpecifier . from_version_string ( version_string ) [EOL] [EOL] [EOL] def get_installed_version ( ) : [EOL] return dbt . semver . VersionSpecifier . from_version_string ( __version__ ) [EOL] [EOL] [EOL] def get_version_information ( ) : [EOL] installed = get_installed_version ( ) [EOL] latest = get_latest_version ( ) [EOL] [EOL] installed_s = installed . to_version_string ( skip_matcher = True ) [EOL] if latest is None : [EOL] latest_s = [string] [EOL] else : [EOL] latest_s = latest . to_version_string ( skip_matcher = True ) [EOL] [EOL] version_msg = ( [string] [string] . format ( installed_s , latest_s ) ) [EOL] [EOL] plugin_version_msg = [string] [EOL] for plugin_name , version in _get_dbt_plugins_info ( ) : [EOL] plugin_version_msg += [string] . format ( plugin_name = plugin_name , version = version ) [EOL] if latest is None : [EOL] return ( [string] [string] . format ( version_msg , PYPI_VERSION_URL , plugin_version_msg ) ) [EOL] [EOL] if installed == latest : [EOL] return [string] . format ( version_msg , plugin_version_msg ) [EOL] [EOL] elif installed > latest : [EOL] return ( [string] [string] . format ( version_msg , plugin_version_msg ) ) [EOL] [EOL] else : [EOL] return ( [string] [string] [string] . format ( version_msg , plugin_version_msg ) ) [EOL] [EOL] [EOL] def _get_adapter_plugin_names ( ) : [EOL] spec = importlib . util . find_spec ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] if spec is None or spec . submodule_search_locations is None : [EOL] return [EOL] for adapters_path in spec . submodule_search_locations : [EOL] version_glob = os . path . join ( adapters_path , [string] , [string] ) [EOL] for version_path in glob . glob ( version_glob ) : [EOL] [comment] [EOL] [comment] [EOL] plugin_root , _ = os . path . split ( version_path ) [EOL] _ , plugin_name = os . path . split ( plugin_root ) [EOL] yield plugin_name [EOL] [EOL] [EOL] def _get_dbt_plugins_info ( ) : [EOL] for plugin_name in _get_adapter_plugin_names ( ) : [EOL] if plugin_name == [string] : [EOL] continue [EOL] try : [EOL] mod = importlib . import_module ( f' [string] { plugin_name } [string] ' ) [EOL] except ImportError : [EOL] [comment] [EOL] continue [EOL] yield plugin_name , mod . version [EOL] [EOL] [EOL] __version__ = [string] [EOL] installed = get_installed_version ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Dict , Any , List , Optional [EOL] import core [EOL] import typing [EOL] import requests [EOL] from typing import Optional [EOL] [EOL] from dbt . clients import yaml_helper [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt import version as dbt_version [EOL] from snowplow_tracker import Subject , Tracker , Emitter , logger as sp_logger [EOL] from snowplow_tracker import SelfDescribingJson [EOL] from datetime import datetime [EOL] [EOL] import logbook [EOL] import pytz [EOL] import platform [EOL] import uuid [EOL] import requests [EOL] import yaml [EOL] import os [EOL] [EOL] sp_logger . setLevel ( [number] ) [EOL] [EOL] COLLECTOR_URL = [string] [EOL] COLLECTOR_PROTOCOL = [string] [EOL] [EOL] INVOCATION_SPEC = [string] [EOL] PLATFORM_SPEC = [string] [EOL] RUN_MODEL_SPEC = [string] [EOL] INVOCATION_ENV_SPEC = [string] [EOL] PACKAGE_INSTALL_SPEC = [string] [EOL] RPC_REQUEST_SPEC = [string] [EOL] DEPRECATION_WARN_SPEC = [string] [EOL] [EOL] DBT_INVOCATION_ENV = [string] [EOL] [EOL] [EOL] class TimeoutEmitter ( Emitter ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( COLLECTOR_URL , protocol = COLLECTOR_PROTOCOL , buffer_size = [number] , on_failure = self . handle_failure , method = [string] , byte_limit = None , ) [EOL] [EOL] @ staticmethod def handle_failure ( num_ok , unsent ) : [EOL] [comment] [EOL] [comment] [EOL] logger . warning ( [string] ) [EOL] disable_tracking ( ) [EOL] [EOL] def _log_request ( self , request , payload ) : [EOL] sp_logger . info ( f" [string] { request } [string] { self . endpoint } [string] " ) [EOL] sp_logger . debug ( f" [string] { payload }" ) [EOL] [EOL] def _log_result ( self , request , status_code ) : [EOL] msg = f"{ request } [string] { status_code }" [EOL] if self . is_good_status_code ( status_code ) : [EOL] sp_logger . info ( msg ) [EOL] else : [EOL] sp_logger . warning ( msg ) [EOL] [EOL] def http_post ( self , payload ) : [EOL] self . _log_request ( [string] , payload ) [EOL] [EOL] r = requests . post ( self . endpoint , data = payload , headers = { [string] : [string] } , timeout = [number] ) [EOL] [EOL] self . _log_result ( [string] , r . status_code ) [EOL] return r [EOL] [EOL] def http_get ( self , payload ) : [EOL] self . _log_request ( [string] , payload ) [EOL] [EOL] r = requests . get ( self . endpoint , params = payload , timeout = [number] ) [EOL] [EOL] self . _log_result ( [string] , r . status_code ) [EOL] return r [EOL] [EOL] [EOL] emitter = TimeoutEmitter ( ) [EOL] tracker = Tracker ( emitter , namespace = [string] , app_id = [string] , ) [EOL] [EOL] [EOL] class User : [EOL] [EOL] def __init__ ( self , cookie_dir ) : [EOL] self . do_not_track = True [EOL] self . cookie_dir = cookie_dir [EOL] [EOL] self . id = None [EOL] self . invocation_id = str ( uuid . uuid4 ( ) ) [EOL] self . run_started_at = datetime . now ( tz = pytz . utc ) [EOL] [EOL] def state ( self ) : [EOL] return [string] if self . do_not_track else [string] [EOL] [EOL] @ property def cookie_path ( self ) : [EOL] return os . path . join ( self . cookie_dir , [string] ) [EOL] [EOL] def initialize ( self ) : [EOL] self . do_not_track = False [EOL] [EOL] cookie = self . get_cookie ( ) [EOL] self . id = cookie . get ( [string] ) [EOL] [EOL] subject = Subject ( ) [EOL] subject . set_user_id ( self . id ) [EOL] tracker . set_subject ( subject ) [EOL] [EOL] def disable_tracking ( self ) : [EOL] self . do_not_track = True [EOL] self . id = None [EOL] self . cookie_dir = None [EOL] tracker . set_subject ( None ) [EOL] [EOL] def set_cookie ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] user = { [string] : str ( uuid . uuid4 ( ) ) } [EOL] [EOL] cookie_path = os . path . abspath ( self . cookie_dir ) [EOL] profiles_file = os . path . join ( cookie_path , [string] ) [EOL] if os . path . exists ( cookie_path ) and os . path . exists ( profiles_file ) : [EOL] with open ( self . cookie_path , [string] ) as fh : [EOL] yaml . dump ( user , fh ) [EOL] [EOL] return user [EOL] [EOL] def get_cookie ( self ) : [EOL] if not os . path . isfile ( self . cookie_path ) : [EOL] user = self . set_cookie ( ) [EOL] else : [EOL] with open ( self . cookie_path , [string] ) as fh : [EOL] try : [EOL] user = yaml_helper . safe_load ( fh ) [EOL] if user is None : [EOL] user = self . set_cookie ( ) [EOL] except yaml . reader . ReaderError : [EOL] user = self . set_cookie ( ) [EOL] return user [EOL] [EOL] [EOL] active_user = None [EOL] [EOL] [EOL] def get_run_type ( args ) : [EOL] return [string] [EOL] [EOL] [EOL] def get_invocation_context ( user , config , args ) : [EOL] try : [EOL] adapter_type = config . credentials . type [EOL] except Exception : [EOL] adapter_type = None [EOL] [EOL] return { [string] : None if config is None else config . hashed_name ( ) , [string] : user . id , [string] : user . invocation_id , [string] : args . which , [string] : None , [string] : str ( dbt_version . installed ) , [string] : get_run_type ( args ) , [string] : adapter_type , } [EOL] [EOL] [EOL] def get_invocation_start_context ( user , config , args ) : [EOL] data = get_invocation_context ( user , config , args ) [EOL] [EOL] start_data = { [string] : [string] , [string] : None , [string] : None } [EOL] [EOL] data . update ( start_data ) [EOL] return SelfDescribingJson ( INVOCATION_SPEC , data ) [EOL] [EOL] [EOL] def get_invocation_end_context ( user , config , args , result_type ) : [EOL] data = get_invocation_context ( user , config , args ) [EOL] [EOL] start_data = { [string] : [string] , [string] : result_type , [string] : None } [EOL] [EOL] data . update ( start_data ) [EOL] return SelfDescribingJson ( INVOCATION_SPEC , data ) [EOL] [EOL] [EOL] def get_invocation_invalid_context ( user , config , args , result_type ) : [EOL] data = get_invocation_context ( user , config , args ) [EOL] [EOL] start_data = { [string] : [string] , [string] : result_type , [string] : None } [EOL] [EOL] data . update ( start_data ) [EOL] return SelfDescribingJson ( INVOCATION_SPEC , data ) [EOL] [EOL] [EOL] def get_platform_context ( ) : [EOL] data = { [string] : platform . platform ( ) , [string] : platform . python_version ( ) , [string] : platform . python_implementation ( ) , } [EOL] [EOL] return SelfDescribingJson ( PLATFORM_SPEC , data ) [EOL] [EOL] [EOL] def get_dbt_env_context ( ) : [EOL] default = [string] [EOL] [EOL] dbt_invocation_env = os . getenv ( DBT_INVOCATION_ENV , default ) [EOL] if dbt_invocation_env == [string] : [EOL] dbt_invocation_env = default [EOL] [EOL] data = { [string] : dbt_invocation_env , } [EOL] [EOL] return SelfDescribingJson ( INVOCATION_ENV_SPEC , data ) [EOL] [EOL] [EOL] def track ( user , * args , ** kwargs ) : [EOL] if user . do_not_track : [EOL] return [EOL] else : [EOL] logger . debug ( [string] . format ( kwargs ) ) [EOL] try : [EOL] tracker . track_struct_event ( * args , ** kwargs ) [EOL] except Exception : [EOL] logger . debug ( [string] ) [EOL] [EOL] [EOL] def track_invocation_start ( config = None , args = None ) : [EOL] context = [ get_invocation_start_context ( active_user , config , args ) , get_platform_context ( ) , get_dbt_env_context ( ) ] [EOL] [EOL] track ( active_user , category = [string] , action = [string] , label = [string] , context = context ) [EOL] [EOL] [EOL] def track_model_run ( options ) : [EOL] context = [ SelfDescribingJson ( RUN_MODEL_SPEC , options ) ] [EOL] assert active_user is not None , [string] [EOL] [EOL] track ( active_user , category = [string] , action = [string] , label = active_user . invocation_id , context = context ) [EOL] [EOL] [EOL] def track_rpc_request ( options ) : [EOL] context = [ SelfDescribingJson ( RPC_REQUEST_SPEC , options ) ] [EOL] assert active_user is not None , [string] [EOL] [EOL] track ( active_user , category = [string] , action = [string] , label = active_user . invocation_id , context = context ) [EOL] [EOL] [EOL] def track_package_install ( config , args , options ) : [EOL] assert active_user is not None , [string] [EOL] [EOL] invocation_data = get_invocation_context ( active_user , config , args ) [EOL] [EOL] context = [ SelfDescribingJson ( INVOCATION_SPEC , invocation_data ) , SelfDescribingJson ( PACKAGE_INSTALL_SPEC , options ) ] [EOL] [EOL] track ( active_user , category = [string] , action = [string] , label = active_user . invocation_id , property_ = [string] , context = context ) [EOL] [EOL] [EOL] def track_deprecation_warn ( options ) : [EOL] [EOL] assert active_user is not None , [string] [EOL] [EOL] context = [ SelfDescribingJson ( DEPRECATION_WARN_SPEC , options ) ] [EOL] [EOL] track ( active_user , category = [string] , action = [string] , label = active_user . invocation_id , property_ = [string] , context = context ) [EOL] [EOL] [EOL] def track_invocation_end ( config = None , args = None , result_type = None ) : [EOL] user = active_user [EOL] context = [ get_invocation_end_context ( user , config , args , result_type ) , get_platform_context ( ) , get_dbt_env_context ( ) ] [EOL] [EOL] assert active_user is not None , [string] [EOL] [EOL] track ( active_user , category = [string] , action = [string] , label = [string] , context = context ) [EOL] [EOL] [EOL] def track_invalid_invocation ( config = None , args = None , result_type = None ) : [EOL] assert active_user is not None , [string] [EOL] [EOL] user = active_user [EOL] invocation_context = get_invocation_invalid_context ( user , config , args , result_type ) [EOL] [EOL] context = [ invocation_context , get_platform_context ( ) , get_dbt_env_context ( ) ] [EOL] [EOL] track ( active_user , category = [string] , action = [string] , label = [string] , context = context ) [EOL] [EOL] [EOL] def flush ( ) : [EOL] logger . debug ( [string] ) [EOL] tracker . flush ( ) [EOL] [EOL] [EOL] def disable_tracking ( ) : [EOL] global active_user [EOL] if active_user is not None : [EOL] active_user . disable_tracking ( ) [EOL] else : [EOL] active_user = User ( None ) [EOL] [EOL] [EOL] def do_not_track ( ) : [EOL] global active_user [EOL] active_user = User ( None ) [EOL] [EOL] [EOL] def initialize_tracking ( cookie_dir ) : [EOL] global active_user [EOL] active_user = User ( cookie_dir ) [EOL] try : [EOL] active_user . initialize ( ) [EOL] except Exception : [EOL] logger . debug ( [string] , exc_info = True ) [EOL] active_user = User ( None ) [EOL] [EOL] [EOL] class InvocationProcessor ( logbook . Processor ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] if active_user is not None : [EOL] record . extra . update ( { [string] : active_user . run_started_at . isoformat ( ) , [string] : active_user . invocation_id , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 $core.dbt.tracking.TimeoutEmitter$ 0 0 0 0 0 $typing.Any$ 0 0 0 $core.dbt.tracking.TimeoutEmitter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 $typing.Optional[User]$ 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[User]$ 0 0 0 0 0 0
from typing import Any , Iterable , AbstractSet , Callable , List , Tuple , Set , Union , Dict , Sequence , Mapping , Optional , Type , TypeVar , Iterator [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import concurrent [EOL] import collections [EOL] import concurrent . futures [EOL] import copy [EOL] import datetime [EOL] import decimal [EOL] import functools [EOL] import hashlib [EOL] import itertools [EOL] import json [EOL] import os [EOL] from contextlib import contextmanager [EOL] from enum import Enum [EOL] from typing_extensions import Protocol [EOL] from typing import ( Tuple , Type , Any , Optional , TypeVar , Dict , Union , Callable , List , Iterator , Mapping , Iterable , AbstractSet , Set , Sequence ) [EOL] [EOL] import dbt . exceptions [EOL] [EOL] from dbt . node_types import NodeType [EOL] [EOL] DECIMALS = ... [EOL] try : [EOL] import cdecimal [comment] [EOL] except ImportError : [EOL] DECIMALS = ( decimal . Decimal , ) [EOL] else : [EOL] DECIMALS = ( decimal . Decimal , cdecimal . Decimal ) [EOL] [EOL] [EOL] class ExitCodes ( int , Enum ) : [EOL] Success = [number] [EOL] ModelError = [number] [EOL] UnhandledError = [number] [EOL] [EOL] [EOL] def coalesce ( * args ) : [EOL] for arg in args : [EOL] if arg is not None : [EOL] return arg [EOL] return None [EOL] [EOL] [EOL] def get_profile_from_project ( project ) : [EOL] target_name = project . get ( [string] , { } ) [EOL] profile = project . get ( [string] , { } ) . get ( target_name , { } ) [EOL] return profile [EOL] [EOL] [EOL] def get_model_name_or_none ( model ) : [EOL] if model is None : [EOL] name = [string] [EOL] [EOL] elif isinstance ( model , str ) : [EOL] name = model [EOL] elif isinstance ( model , dict ) : [EOL] name = model . get ( [string] , model . get ( [string] ) ) [EOL] elif hasattr ( model , [string] ) : [EOL] name = model . alias [EOL] elif hasattr ( model , [string] ) : [EOL] name = model . name [EOL] else : [EOL] name = str ( model ) [EOL] return name [EOL] [EOL] [EOL] MACRO_PREFIX = [string] [EOL] DOCS_PREFIX = [string] [EOL] [EOL] [EOL] def get_dbt_macro_name ( name ) : [EOL] if name is None : [EOL] raise dbt . exceptions . InternalException ( [string] ) [EOL] return [string] . format ( MACRO_PREFIX , name ) [EOL] [EOL] [EOL] def get_dbt_docs_name ( name ) : [EOL] if name is None : [EOL] raise dbt . exceptions . InternalException ( [string] ) [EOL] return [string] . format ( DOCS_PREFIX , name ) [EOL] [EOL] [EOL] def get_materialization_macro_name ( materialization_name , adapter_type = None , with_prefix = True ) : [EOL] if adapter_type is None : [EOL] adapter_type = [string] [EOL] [EOL] name = [string] . format ( materialization_name , adapter_type ) [EOL] [EOL] if with_prefix : [EOL] return get_dbt_macro_name ( name ) [EOL] else : [EOL] return name [EOL] [EOL] [EOL] def get_docs_macro_name ( docs_name , with_prefix = True ) : [EOL] if with_prefix : [EOL] return get_dbt_docs_name ( docs_name ) [EOL] else : [EOL] return docs_name [EOL] [EOL] [EOL] def split_path ( path ) : [EOL] return path . split ( os . sep ) [EOL] [EOL] [EOL] def merge ( * args ) : [EOL] if len ( args ) == [number] : [EOL] return None [EOL] [EOL] if len ( args ) == [number] : [EOL] return args [ [number] ] [EOL] [EOL] lst = list ( args ) [EOL] last = lst . pop ( len ( lst ) - [number] ) [EOL] [EOL] return _merge ( merge ( * lst ) , last ) [EOL] [EOL] [EOL] def _merge ( a , b ) : [EOL] to_return = a . copy ( ) [EOL] to_return . update ( b ) [EOL] return to_return [EOL] [EOL] [EOL] [comment] [EOL] def deep_merge ( * args ) : [EOL] [docstring] [EOL] if len ( args ) == [number] : [EOL] return None [EOL] [EOL] if len ( args ) == [number] : [EOL] return copy . deepcopy ( args [ [number] ] ) [EOL] [EOL] lst = list ( args ) [EOL] last = copy . deepcopy ( lst . pop ( len ( lst ) - [number] ) ) [EOL] [EOL] return _deep_merge ( deep_merge ( * lst ) , last ) [EOL] [EOL] [EOL] def _deep_merge ( destination , source ) : [EOL] if isinstance ( source , dict ) : [EOL] for key , value in source . items ( ) : [EOL] deep_merge_item ( destination , key , value ) [EOL] return destination [EOL] [EOL] [EOL] def deep_merge_item ( destination , key , value ) : [EOL] if isinstance ( value , dict ) : [EOL] node = destination . setdefault ( key , { } ) [EOL] destination [ key ] = deep_merge ( node , value ) [EOL] elif isinstance ( value , tuple ) or isinstance ( value , list ) : [EOL] if key in destination : [EOL] destination [ key ] = list ( value ) + list ( destination [ key ] ) [EOL] else : [EOL] destination [ key ] = value [EOL] else : [EOL] destination [ key ] = value [EOL] [EOL] [EOL] def _deep_map ( func , value , keypath , ) : [EOL] atomic_types = ( int , float , str , type ( None ) , bool ) [EOL] [EOL] ret = ... [EOL] [EOL] if isinstance ( value , list ) : [EOL] ret = [ _deep_map ( func , v , ( keypath + ( idx , ) ) ) for idx , v in enumerate ( value ) ] [EOL] elif isinstance ( value , dict ) : [EOL] ret = { k : _deep_map ( func , v , ( keypath + ( str ( k ) , ) ) ) for k , v in value . items ( ) } [EOL] elif isinstance ( value , atomic_types ) : [EOL] ret = func ( value , keypath ) [EOL] else : [EOL] container_types = ( list , dict ) [EOL] ok_types = container_types + atomic_types [EOL] raise dbt . exceptions . DbtConfigError ( [string] . format ( ok_types , type ( value ) ) ) [EOL] [EOL] return ret [EOL] [EOL] [EOL] def deep_map ( func , value ) : [EOL] [docstring] [EOL] try : [EOL] return _deep_map ( func , value , ( ) ) [EOL] except RuntimeError as exc : [EOL] if [string] in str ( exc ) : [EOL] raise dbt . exceptions . RecursionException ( [string] ) [EOL] raise [EOL] [EOL] [EOL] class AttrDict ( dict ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . __dict__ = self [EOL] [EOL] [EOL] def get_pseudo_test_path ( node_name , source_path , test_type ) : [EOL] [docstring] [EOL] source_path_parts = split_path ( source_path ) [EOL] source_path_parts . pop ( ) [comment] [EOL] suffix = [ test_type , [string] . format ( node_name ) ] [EOL] pseudo_path_parts = source_path_parts + suffix [EOL] return os . path . join ( * pseudo_path_parts ) [EOL] [EOL] [EOL] def get_pseudo_hook_path ( hook_name ) : [EOL] path_parts = [ [string] , [string] . format ( hook_name ) ] [EOL] return os . path . join ( * path_parts ) [EOL] [EOL] [EOL] def md5 ( string ) : [EOL] return hashlib . md5 ( string . encode ( [string] ) ) . hexdigest ( ) [EOL] [EOL] [EOL] def get_hash ( model ) : [EOL] return hashlib . md5 ( model . unique_id . encode ( [string] ) ) . hexdigest ( ) [EOL] [EOL] [EOL] def get_hashed_contents ( model ) : [EOL] return hashlib . md5 ( model . raw_sql . encode ( [string] ) ) . hexdigest ( ) [EOL] [EOL] [EOL] def flatten_nodes ( dep_list ) : [EOL] return list ( itertools . chain . from_iterable ( dep_list ) ) [EOL] [EOL] [EOL] class memoized : [EOL] [docstring] [EOL] def __init__ ( self , func ) : [EOL] self . func = func [EOL] self . cache = { } [EOL] [EOL] def __call__ ( self , * args ) : [EOL] if not isinstance ( args , collections . abc . Hashable ) : [EOL] [comment] [EOL] [comment] [EOL] return self . func ( * args ) [EOL] if args in self . cache : [EOL] return self . cache [ args ] [EOL] value = self . func ( * args ) [EOL] self . cache [ args ] = value [EOL] return value [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return self . func . __doc__ [EOL] [EOL] def __get__ ( self , obj , objtype ) : [EOL] [docstring] [EOL] return functools . partial ( self . __call__ , obj ) [EOL] [EOL] [EOL] K_T = TypeVar ( [string] ) [EOL] V_T = TypeVar ( [string] ) [EOL] [EOL] [EOL] def filter_null_values ( input ) : [EOL] return { k : v for k , v in input . items ( ) if v is not None } [EOL] [EOL] [EOL] def add_ephemeral_model_prefix ( s ) : [EOL] return [string] . format ( s ) [EOL] [EOL] [EOL] def timestring ( ) : [EOL] [docstring] [EOL] [comment] [EOL] return datetime . datetime . utcnow ( ) . isoformat ( ) + [string] [EOL] [EOL] [EOL] class JSONEncoder ( json . JSONEncoder ) : [EOL] [docstring] [EOL] def default ( self , obj ) : [EOL] if isinstance ( obj , DECIMALS ) : [EOL] return float ( obj ) [EOL] if isinstance ( obj , ( datetime . datetime , datetime . date , datetime . time ) ) : [EOL] return obj . isoformat ( ) [EOL] if hasattr ( obj , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return obj . to_dict ( ) [EOL] return super ( ) . default ( obj ) [EOL] [EOL] [EOL] class ForgivingJSONEncoder ( JSONEncoder ) : [EOL] def default ( self , obj ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] return super ( ) . default ( obj ) [EOL] except TypeError : [EOL] return str ( obj ) [EOL] [EOL] [EOL] class Translator : [EOL] def __init__ ( self , aliases , recursive = False ) : [EOL] self . aliases = aliases [EOL] self . recursive = recursive [EOL] [EOL] def translate_mapping ( self , kwargs ) : [EOL] result = { } [EOL] [EOL] for key , value in kwargs . items ( ) : [EOL] canonical_key = self . aliases . get ( key , key ) [EOL] if canonical_key in result : [EOL] dbt . exceptions . raise_duplicate_alias ( kwargs , self . aliases , canonical_key ) [EOL] result [ canonical_key ] = self . translate_value ( value ) [EOL] return result [EOL] [EOL] def translate_sequence ( self , value ) : [EOL] return [ self . translate_value ( v ) for v in value ] [EOL] [EOL] def translate_value ( self , value ) : [EOL] if self . recursive : [EOL] if isinstance ( value , Mapping ) : [EOL] return self . translate_mapping ( value ) [EOL] elif isinstance ( value , ( list , tuple ) ) : [EOL] return self . translate_sequence ( value ) [EOL] return value [EOL] [EOL] def translate ( self , value ) : [EOL] try : [EOL] return self . translate_mapping ( value ) [EOL] except RuntimeError as exc : [EOL] if [string] in str ( exc ) : [EOL] raise dbt . exceptions . RecursionException ( [string] ) [EOL] raise [EOL] [EOL] [EOL] def translate_aliases ( kwargs , aliases , recurse = False , ) : [EOL] [docstring] [EOL] translator = Translator ( aliases , recurse ) [EOL] return translator . translate ( kwargs ) [EOL] [EOL] [EOL] def _pluralize ( string ) : [EOL] try : [EOL] convert = NodeType ( string ) [EOL] except ValueError : [EOL] return f'{ string } [string] ' [EOL] else : [EOL] return convert . pluralize ( ) [EOL] [EOL] [EOL] def pluralize ( count , string ) : [EOL] pluralized = str ( string ) [EOL] if count != [number] : [EOL] pluralized = _pluralize ( string ) [EOL] return f'{ count } [string] { pluralized }' [EOL] [EOL] [EOL] def restrict_to ( * restrictions ) : [EOL] [docstring] [EOL] return { [string] : list ( restrictions ) } [EOL] [EOL] [EOL] def coerce_dict_str ( value ) : [EOL] [docstring] [EOL] if ( isinstance ( value , dict ) and all ( isinstance ( k , str ) for k in value ) ) : [EOL] return value [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def lowercase ( value ) : [EOL] if value is None : [EOL] return None [EOL] else : [EOL] return value . lower ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class classproperty ( object ) : [EOL] def __init__ ( self , func ) : [EOL] self . func = func [EOL] [EOL] def __get__ ( self , obj , objtype ) : [EOL] return self . func ( objtype ) [EOL] [EOL] [EOL] def format_bytes ( num_bytes ) : [EOL] for unit in [ [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] if abs ( num_bytes ) < [number] : [EOL] return f"{ num_bytes : [string] } [string] { unit }" [EOL] num_bytes /= [number] [EOL] [EOL] num_bytes *= [number] [EOL] return f"{ num_bytes : [string] } [string] { unit }" [EOL] [EOL] [EOL] def format_rows_number ( rows_number ) : [EOL] for unit in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] if abs ( rows_number ) < [number] : [EOL] return f"{ rows_number : [string] }{ unit }" . strip ( ) [EOL] rows_number /= [number] [EOL] [EOL] rows_number *= [number] [EOL] return f"{ rows_number : [string] }{ unit }" . strip ( ) [EOL] [EOL] [EOL] class ConnectingExecutor ( concurrent . futures . Executor ) : [EOL] def submit_connected ( self , adapter , conn_name , func , * args , ** kwargs ) : [EOL] def connected ( conn_name , func , * args , ** kwargs ) : [EOL] with self . connection_named ( adapter , conn_name ) : [EOL] return func ( * args , ** kwargs ) [EOL] return self . submit ( connected , conn_name , func , * args , ** kwargs ) [EOL] [EOL] [EOL] [comment] [EOL] class SingleThreadedExecutor ( ConnectingExecutor ) : [EOL] def submit ( * args , ** kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] if len ( args ) >= [number] : [EOL] self , fn , * args = args [EOL] elif not args : [EOL] raise TypeError ( [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] [string] % ( len ( args ) - [number] ) ) [EOL] fut = concurrent . futures . Future ( ) [EOL] try : [EOL] result = fn ( * args , ** kwargs ) [EOL] except Exception as exc : [EOL] fut . set_exception ( exc ) [EOL] else : [EOL] fut . set_result ( result ) [EOL] return fut [EOL] [EOL] @ contextmanager def connection_named ( self , adapter , name ) : [EOL] yield [EOL] [EOL] [EOL] class MultiThreadedExecutor ( ConnectingExecutor , concurrent . futures . ThreadPoolExecutor , ) : [EOL] @ contextmanager def connection_named ( self , adapter , name ) : [EOL] with adapter . connection_named ( name ) : [EOL] yield [EOL] [EOL] [EOL] class ThreadedArgs ( Protocol ) : [EOL] single_threaded = ... [EOL] [EOL] [EOL] class HasThreadingConfig ( Protocol ) : [EOL] args = ... [EOL] threads = ... [EOL] [EOL] [EOL] def executor ( config ) : [EOL] if config . args . single_threaded : [EOL] return SingleThreadedExecutor ( ) [EOL] else : [EOL] return MultiThreadedExecutor ( max_workers = config . threads ) [EOL] [EOL] [EOL] def fqn_search ( root , fqn ) : [EOL] [docstring] [EOL] yield root [EOL] [EOL] for level in fqn : [EOL] level_config = root . get ( level , None ) [EOL] if not isinstance ( level_config , dict ) : [EOL] break [EOL] yield copy . deepcopy ( level_config ) [EOL] root = level_config [EOL] [EOL] [EOL] StringMap = Mapping [ str , Any ] [EOL] StringMapList = List [ StringMap ] [EOL] StringMapIter = Iterable [ StringMap ] [EOL] [EOL] [EOL] class MultiDict ( Mapping [ str , Any ] ) : [EOL] [docstring] [EOL] def __init__ ( self , sources = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . sources = ... [EOL] [EOL] if sources is None : [EOL] self . sources = [ ] [EOL] else : [EOL] self . sources = sources [EOL] [EOL] def add_from ( self , sources ) : [EOL] self . sources . extend ( sources ) [EOL] [EOL] def add ( self , source ) : [EOL] self . sources . append ( source ) [EOL] [EOL] def _keyset ( self ) : [EOL] [comment] [EOL] keys = set ( ) [EOL] for entry in self . _itersource ( ) : [EOL] keys . update ( entry ) [EOL] return keys [EOL] [EOL] def _itersource ( self ) : [EOL] return reversed ( self . sources ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [comment] [EOL] return iter ( self . _keyset ( ) ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _keyset ( ) ) [EOL] [EOL] def __getitem__ ( self , name ) : [EOL] for entry in self . _itersource ( ) : [EOL] if name in entry : [EOL] return entry [ name ] [EOL] raise KeyError ( name ) [EOL] [EOL] def __contains__ ( self , name ) : [EOL] return any ( ( name in entry for entry in self . _itersource ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,builtins.str]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,builtins.str]$ 0 $typing.Mapping[builtins.str,builtins.str]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $concurrent.futures._base.Future[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $ThreadedArgs$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Mapping[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Mapping[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Mapping[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.List[typing.Mapping[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Mapping[builtins.str,typing.Any]]$ 0 $typing.List[typing.Mapping[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $StringMapIter$ 0 0 0 0 0 $StringMapIter$ 0 0 0 $StringMapIter$ 0 0 0 0 0 0 0 0 $StringMap$ 0 0 0 0 0 0 0 0 0 $StringMap$ 0 0 0 0 $typing.AbstractSet[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $StringMapIter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict [EOL] import builtins [EOL] import typing [EOL] from hologram . helpers import StrEnum [EOL] import json [EOL] [EOL] from typing import Union , Dict , Any [EOL] [EOL] [EOL] class ModelHookType ( StrEnum ) : [EOL] PreHook = [string] [EOL] PostHook = [string] [EOL] [EOL] [EOL] def get_hook_dict ( source ) : [EOL] [docstring] [EOL] if isinstance ( source , dict ) : [EOL] return source [EOL] try : [EOL] return json . loads ( source ) [EOL] except ValueError : [EOL] return { [string] : source } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import argparse [EOL] from typing import List [EOL] from dbt . logger import GLOBAL_LOGGER as logger , log_cache_events , log_manager [EOL] [EOL] import argparse [EOL] import os . path [EOL] import sys [EOL] import traceback [EOL] from contextlib import contextmanager [EOL] from pathlib import Path [EOL] [EOL] import dbt . version [EOL] import dbt . flags as flags [EOL] import dbt . task . run as run_task [EOL] import dbt . task . compile as compile_task [EOL] import dbt . task . debug as debug_task [EOL] import dbt . task . clean as clean_task [EOL] import dbt . task . deps as deps_task [EOL] import dbt . task . init as init_task [EOL] import dbt . task . seed as seed_task [EOL] import dbt . task . test as test_task [EOL] import dbt . task . snapshot as snapshot_task [EOL] import dbt . task . generate as generate_task [EOL] import dbt . task . serve as serve_task [EOL] import dbt . task . freshness as freshness_task [EOL] import dbt . task . run_operation as run_operation_task [EOL] from dbt . profiler import profiler [EOL] from dbt . task . list import ListTask [EOL] from dbt . task . rpc . server import RPCServerTask [EOL] from dbt . adapters . factory import reset_adapters , cleanup_connections [EOL] [EOL] import dbt . tracking [EOL] [EOL] from dbt . utils import ExitCodes [EOL] from dbt . config import PROFILES_DIR , read_user_config [EOL] from dbt . exceptions import RuntimeException , InternalException [EOL] [EOL] [EOL] class DBTVersion ( argparse . Action ) : [EOL] [docstring] [EOL] def __init__ ( self , option_strings , version = None , dest = argparse . SUPPRESS , default = argparse . SUPPRESS , help = [string] ) : [EOL] super ( ) . __init__ ( option_strings = option_strings , dest = dest , default = default , nargs = [number] , help = help ) [EOL] [EOL] def __call__ ( self , parser , namespace , values , option_string = None ) : [EOL] formatter = argparse . RawTextHelpFormatter ( prog = parser . prog ) [EOL] formatter . add_text ( dbt . version . get_version_information ( ) ) [EOL] parser . exit ( message = formatter . format_help ( ) ) [EOL] [EOL] [EOL] class DBTArgumentParser ( argparse . ArgumentParser ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . register ( [string] , [string] , DBTVersion ) [EOL] [EOL] def add_optional_argument_inverse ( self , name , * , enable_help = None , disable_help = None , dest = None , no_name = None , default = None , ) : [EOL] mutex_group = self . add_mutually_exclusive_group ( ) [EOL] if not name . startswith ( [string] ) : [EOL] raise InternalException ( [string] f' [string] { name } [string] ' ) [EOL] if dest is None : [EOL] dest_name = name [ [number] : ] . replace ( [string] , [string] ) [EOL] else : [EOL] dest_name = dest [EOL] [EOL] if no_name is None : [EOL] no_name = f' [string] { name [ [number] : ] }' [EOL] [EOL] mutex_group . add_argument ( name , action = [string] , const = True , dest = dest_name , default = default , help = enable_help , ) [EOL] [EOL] mutex_group . add_argument ( f' [string] { name [ [number] : ] }' , action = [string] , const = False , dest = dest_name , default = default , help = disable_help , ) [EOL] [EOL] return mutex_group [EOL] [EOL] [EOL] class RPCArgumentParser ( DBTArgumentParser ) : [EOL] def exit ( self , status = [number] , message = None ) : [EOL] if status == [number] : [EOL] return [EOL] else : [EOL] raise TypeError ( message ) [EOL] [EOL] [EOL] def main ( args = None ) : [EOL] if args is None : [EOL] args = sys . argv [ [number] : ] [EOL] with log_manager . applicationbound ( ) : [EOL] try : [EOL] results , succeeded = handle_and_check ( args ) [EOL] if succeeded : [EOL] exit_code = ExitCodes . Success . value [EOL] else : [EOL] exit_code = ExitCodes . ModelError . value [EOL] [EOL] except KeyboardInterrupt : [EOL] logger . info ( [string] ) [EOL] exit_code = ExitCodes . UnhandledError . value [EOL] [EOL] [comment] [EOL] except SystemExit as e : [EOL] exit_code = e . code [EOL] [EOL] except BaseException as e : [EOL] logger . warning ( [string] ) [EOL] logger . warning ( str ( e ) ) [EOL] [EOL] if log_manager . initialized : [EOL] logger . debug ( traceback . format_exc ( ) ) [EOL] elif not isinstance ( e , RuntimeException ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] logger . error ( traceback . format_exc ( ) ) [EOL] exit_code = ExitCodes . UnhandledError . value [EOL] [EOL] sys . exit ( exit_code ) [EOL] [EOL] [EOL] [comment] [EOL] def handle ( args ) : [EOL] res , success = handle_and_check ( args ) [EOL] return res [EOL] [EOL] [EOL] def initialize_config_values ( parsed ) : [EOL] [docstring] [EOL] cfg = read_user_config ( parsed . profiles_dir ) [EOL] cfg . set_values ( parsed . profiles_dir ) [EOL] [EOL] [EOL] @ contextmanager def adapter_management ( ) : [EOL] reset_adapters ( ) [EOL] try : [EOL] yield [EOL] finally : [EOL] cleanup_connections ( ) [EOL] [EOL] [EOL] def handle_and_check ( args ) : [EOL] with log_manager . applicationbound ( ) : [EOL] parsed = parse_args ( args ) [EOL] [EOL] [comment] [EOL] if parsed . debug : [EOL] log_manager . set_debug ( ) [EOL] [EOL] profiler_enabled = False [EOL] [EOL] if parsed . record_timing_info : [EOL] profiler_enabled = True [EOL] [EOL] with profiler ( enable = profiler_enabled , outfile = parsed . record_timing_info ) : [EOL] [EOL] initialize_config_values ( parsed ) [EOL] [EOL] with adapter_management ( ) : [EOL] [EOL] task , res = run_from_args ( parsed ) [EOL] success = task . interpret_results ( res ) [EOL] [EOL] return res , success [EOL] [EOL] [EOL] @ contextmanager def track_run ( task ) : [EOL] dbt . tracking . track_invocation_start ( config = task . config , args = task . args ) [EOL] try : [EOL] yield [EOL] dbt . tracking . track_invocation_end ( config = task . config , args = task . args , result_type = [string] ) [EOL] except ( dbt . exceptions . NotImplementedException , dbt . exceptions . FailedToConnectException ) as e : [EOL] logger . error ( [string] . format ( e ) ) [EOL] dbt . tracking . track_invocation_end ( config = task . config , args = task . args , result_type = [string] ) [EOL] except Exception : [EOL] dbt . tracking . track_invocation_end ( config = task . config , args = task . args , result_type = [string] ) [EOL] raise [EOL] finally : [EOL] dbt . tracking . flush ( ) [EOL] [EOL] [EOL] def run_from_args ( parsed ) : [EOL] log_cache_events ( getattr ( parsed , [string] , False ) ) [EOL] flags . set_from_args ( parsed ) [EOL] [EOL] parsed . cls . pre_init_hook ( parsed ) [EOL] [comment] [EOL] [EOL] logger . info ( [string] . format ( dbt . version . installed ) ) [EOL] [EOL] [comment] [EOL] task = parsed . cls . from_args ( args = parsed ) [EOL] logger . debug ( [string] , parsed = str ( parsed ) ) [EOL] [EOL] log_path = None [EOL] if task . config is not None : [EOL] log_path = getattr ( task . config , [string] , None ) [EOL] [comment] [EOL] log_manager . set_path ( log_path ) [EOL] if dbt . tracking . active_user is not None : [comment] [EOL] logger . debug ( [string] . format ( dbt . tracking . active_user . state ( ) ) ) [EOL] [EOL] results = None [EOL] [EOL] with track_run ( task ) : [EOL] results = task . run ( ) [EOL] [EOL] return task , results [EOL] [EOL] [EOL] def _build_base_subparser ( ) : [EOL] base_subparser = argparse . ArgumentParser ( add_help = False ) [EOL] [EOL] base_subparser . add_argument ( [string] , default = None , type = str , help = [string] ) [EOL] [EOL] base_subparser . add_argument ( [string] , default = PROFILES_DIR , type = str , help = [string] . format ( PROFILES_DIR ) ) [EOL] [EOL] base_subparser . add_argument ( [string] , required = False , type = str , help = [string] ) [EOL] [EOL] base_subparser . add_argument ( [string] , [string] , default = None , type = str , help = [string] , ) [EOL] [EOL] base_subparser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] [EOL] [comment] [EOL] base_subparser . add_argument ( [string] , action = [string] , help = argparse . SUPPRESS , ) [EOL] [EOL] base_subparser . add_argument ( [string] , action = [string] , dest = [string] , help = [string] , ) [EOL] [EOL] base_subparser . set_defaults ( defer = None , state = None ) [EOL] return base_subparser [EOL] [EOL] [EOL] def _build_docs_subparser ( subparsers , base_subparser ) : [EOL] docs_sub = subparsers . add_parser ( [string] , help = [string] ) [EOL] return docs_sub [EOL] [EOL] [EOL] def _build_source_subparser ( subparsers , base_subparser ) : [EOL] source_sub = subparsers . add_parser ( [string] , help = [string] , ) [EOL] return source_sub [EOL] [EOL] [EOL] def _build_init_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] ) [EOL] sub . add_argument ( [string] , type = str , help = [string] , ) [EOL] sub . add_argument ( [string] , default = [string] , type = str , help = [string] , ) [EOL] sub . set_defaults ( cls = init_task . InitTask , which = [string] , rpc_method = None ) [EOL] return sub [EOL] [EOL] [EOL] def _build_clean_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] ) [EOL] sub . set_defaults ( cls = clean_task . CleanTask , which = [string] , rpc_method = None ) [EOL] return sub [EOL] [EOL] [EOL] def _build_debug_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] ) [EOL] sub . add_argument ( [string] , action = [string] , help = [string] ) [EOL] _add_version_check ( sub ) [EOL] sub . set_defaults ( cls = debug_task . DebugTask , which = [string] , rpc_method = None ) [EOL] return sub [EOL] [EOL] [EOL] def _build_deps_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] ) [EOL] sub . set_defaults ( cls = deps_task . DepsTask , which = [string] , rpc_method = [string] ) [EOL] return sub [EOL] [EOL] [EOL] def _build_snapshot_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] , ) [EOL] sub . add_argument ( [string] , type = int , required = False , help = [string] ) [EOL] sub . set_defaults ( cls = snapshot_task . SnapshotTask , which = [string] , rpc_method = [string] ) [EOL] return sub [EOL] [EOL] [EOL] def _build_run_subparser ( subparsers , base_subparser ) : [EOL] run_sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] ) [EOL] run_sub . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] [comment] [EOL] run_sub . add_optional_argument_inverse ( [string] , enable_help = [string] , disable_help = [string] , default = flags . DEFER_MODE , ) [EOL] [EOL] run_sub . set_defaults ( cls = run_task . RunTask , which = [string] , rpc_method = [string] ) [EOL] return run_sub [EOL] [EOL] [EOL] def _build_compile_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] ) [EOL] sub . set_defaults ( cls = compile_task . CompileTask , which = [string] , rpc_method = [string] ) [EOL] sub . add_argument ( [string] , action = [string] ) [EOL] return sub [EOL] [EOL] [EOL] def _build_docs_generate_subparser ( subparsers , base_subparser ) : [EOL] [comment] [EOL] [comment] [EOL] generate_sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] ) [EOL] generate_sub . set_defaults ( cls = generate_task . GenerateTask , which = [string] , rpc_method = [string] ) [EOL] generate_sub . add_argument ( [string] , action = [string] , dest = [string] , help = [string] , ) [EOL] return generate_sub [EOL] [EOL] [EOL] def _add_models_argument ( sub , help_override = None , ** kwargs ) : [EOL] help_str = [string] [EOL] if help_override is not None : [EOL] help_str = help_override [EOL] sub . add_argument ( [string] , [string] , dest = [string] , nargs = [string] , help = help_str , ** kwargs ) [EOL] [EOL] [EOL] def _add_select_argument ( sub , dest = [string] , help_override = None , ** kwargs ) : [EOL] help_str = [string] [EOL] if help_override is not None : [EOL] help_str = help_override [EOL] [EOL] sub . add_argument ( [string] , [string] , dest = dest , nargs = [string] , help = help_str , ** kwargs ) [EOL] [EOL] [EOL] def _add_common_selector_arguments ( sub ) : [EOL] sub . add_argument ( [string] , required = False , nargs = [string] , help = [string] , ) [EOL] sub . add_argument ( [string] , dest = [string] , metavar = [string] , help = [string] ) [EOL] sub . add_argument ( [string] , help = [string] , type = Path , default = flags . ARTIFACT_STATE_PATH , ) [EOL] [EOL] [EOL] def _add_selection_arguments ( * subparsers , ** kwargs ) : [EOL] models_name = kwargs . get ( [string] , [string] ) [EOL] for sub in subparsers : [EOL] if models_name == [string] : [EOL] _add_models_argument ( sub ) [EOL] elif models_name == [string] : [EOL] [comment] [EOL] [comment] [EOL] _add_select_argument ( sub ) [EOL] else : [EOL] raise InternalException ( f' [string] { models_name }' ) [EOL] _add_common_selector_arguments ( sub ) [EOL] [EOL] [EOL] def _add_table_mutability_arguments ( * subparsers ) : [EOL] for sub in subparsers : [EOL] sub . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] [EOL] def _add_version_check ( sub ) : [EOL] sub . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] [EOL] [EOL] def _add_common_arguments ( * subparsers ) : [EOL] for sub in subparsers : [EOL] sub . add_argument ( [string] , type = int , required = False , help = [string] ) [EOL] _add_version_check ( sub ) [EOL] [EOL] [EOL] def _build_seed_subparser ( subparsers , base_subparser ) : [EOL] seed_sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] , ) [EOL] seed_sub . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] seed_sub . add_argument ( [string] , action = [string] , help = [string] ) [EOL] seed_sub . set_defaults ( cls = seed_task . SeedTask , which = [string] , rpc_method = [string] ) [EOL] return seed_sub [EOL] [EOL] [EOL] def _build_docs_serve_subparser ( subparsers , base_subparser ) : [EOL] serve_sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] ) [EOL] serve_sub . add_argument ( [string] , default = [number] , type = int , help = [string] ) [EOL] serve_sub . add_argument ( [string] , dest = [string] , action = [string] , ) [EOL] serve_sub . set_defaults ( cls = serve_task . ServeTask , which = [string] , rpc_method = None ) [EOL] return serve_sub [EOL] [EOL] [EOL] def _build_test_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] ) [EOL] sub . add_argument ( [string] , action = [string] , help = [string] ) [EOL] sub . add_argument ( [string] , action = [string] , help = [string] ) [EOL] sub . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] sub . set_defaults ( cls = test_task . TestTask , which = [string] , rpc_method = [string] ) [EOL] return sub [EOL] [EOL] [EOL] def _build_source_snapshot_freshness_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] , ) [EOL] sub . add_argument ( [string] , [string] , required = False , nargs = [string] , help = [string] , dest = [string] ) [EOL] sub . add_argument ( [string] , [string] , required = False , help = [string] ) [EOL] sub . add_argument ( [string] , type = int , required = False , help = [string] ) [EOL] sub . set_defaults ( cls = freshness_task . FreshnessTask , which = [string] , rpc_method = [string] , ) [EOL] return sub [EOL] [EOL] [EOL] def _build_rpc_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] , ) [EOL] sub . add_argument ( [string] , default = [string] , help = [string] , ) [EOL] sub . add_argument ( [string] , default = [number] , type = int , help = [string] , ) [EOL] sub . set_defaults ( cls = RPCServerTask , which = [string] , rpc_method = None ) [EOL] [comment] [EOL] [comment] [EOL] sub . set_defaults ( models = None , exclude = None ) [EOL] return sub [EOL] [EOL] [EOL] def _build_list_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] , aliases = [ [string] ] , ) [EOL] sub . set_defaults ( cls = ListTask , which = [string] , rpc_method = None ) [EOL] resource_values = [ str ( s ) for s in ListTask . ALL_RESOURCE_VALUES ] + [ [string] , [string] ] [EOL] sub . add_argument ( [string] , choices = resource_values , action = [string] , default = [ ] , dest = [string] ) [EOL] sub . add_argument ( [string] , choices = [ [string] , [string] , [string] , [string] ] , default = [string] ) [EOL] [EOL] _add_models_argument ( sub , help_override = [string] , metavar = [string] , required = False ) [EOL] _add_select_argument ( sub , dest = [string] , metavar = [string] , required = False , ) [EOL] _add_common_selector_arguments ( sub ) [EOL] [EOL] return sub [EOL] [EOL] [EOL] def _build_run_operation_subparser ( subparsers , base_subparser ) : [EOL] sub = subparsers . add_parser ( [string] , parents = [ base_subparser ] , help = [string] ) [EOL] sub . add_argument ( [string] , help = [string] , ) [EOL] sub . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] sub . set_defaults ( cls = run_operation_task . RunOperationTask , which = [string] , rpc_method = [string] ) [EOL] return sub [EOL] [EOL] [EOL] def parse_args ( args , cls = DBTArgumentParser ) : [EOL] p = cls ( prog = [string] , description = [string] , epilog = [string] ) [EOL] [EOL] p . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] p . add_argument ( [string] , [string] , default = None , type = str , help = [string] ) [EOL] [EOL] p . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] p . add_argument ( [string] , choices = [ [string] , [string] , [string] ] , default = [string] , help = [string] ) [EOL] [EOL] p . add_argument ( [string] , action = [string] , dest = [string] , help = [string] ) [EOL] colors_flag = p . add_mutually_exclusive_group ( ) [EOL] colors_flag . add_argument ( [string] , action = [string] , const = True , dest = [string] , help = [string] ) [EOL] colors_flag . add_argument ( [string] , action = [string] , const = False , dest = [string] , help = [string] ) [EOL] [EOL] p . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] p . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] p . add_optional_argument_inverse ( [string] , enable_help = [string] , disable_help = [string] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] p . add_argument ( [string] , action = [string] , help = argparse . SUPPRESS , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] p . add_argument ( [string] , action = [string] , help = argparse . SUPPRESS ) [EOL] [EOL] subs = p . add_subparsers ( title = [string] ) [EOL] [EOL] base_subparser = _build_base_subparser ( ) [EOL] [EOL] [comment] [EOL] docs_sub = _build_docs_subparser ( subs , base_subparser ) [EOL] docs_subs = docs_sub . add_subparsers ( title = [string] ) [EOL] source_sub = _build_source_subparser ( subs , base_subparser ) [EOL] source_subs = source_sub . add_subparsers ( title = [string] ) [EOL] [EOL] _build_init_subparser ( subs , base_subparser ) [EOL] _build_clean_subparser ( subs , base_subparser ) [EOL] _build_debug_subparser ( subs , base_subparser ) [EOL] _build_deps_subparser ( subs , base_subparser ) [EOL] _build_list_subparser ( subs , base_subparser ) [EOL] [EOL] snapshot_sub = _build_snapshot_subparser ( subs , base_subparser ) [EOL] rpc_sub = _build_rpc_subparser ( subs , base_subparser ) [EOL] run_sub = _build_run_subparser ( subs , base_subparser ) [EOL] compile_sub = _build_compile_subparser ( subs , base_subparser ) [EOL] generate_sub = _build_docs_generate_subparser ( docs_subs , base_subparser ) [EOL] test_sub = _build_test_subparser ( subs , base_subparser ) [EOL] seed_sub = _build_seed_subparser ( subs , base_subparser ) [EOL] [comment] [EOL] _add_common_arguments ( run_sub , compile_sub , generate_sub , test_sub , rpc_sub , seed_sub ) [EOL] [comment] [EOL] [comment] [EOL] _add_selection_arguments ( run_sub , compile_sub , generate_sub , test_sub ) [EOL] _add_selection_arguments ( snapshot_sub , seed_sub , models_name = [string] ) [EOL] [comment] [EOL] _add_table_mutability_arguments ( run_sub , compile_sub ) [EOL] [EOL] _build_docs_serve_subparser ( docs_subs , base_subparser ) [EOL] _build_source_snapshot_freshness_subparser ( source_subs , base_subparser ) [EOL] _build_run_operation_subparser ( subs , base_subparser ) [EOL] [EOL] if len ( args ) == [number] : [EOL] p . print_help ( ) [EOL] sys . exit ( [number] ) [EOL] [EOL] parsed = p . parse_args ( args ) [EOL] [EOL] if hasattr ( parsed , [string] ) : [EOL] parsed . profiles_dir = os . path . expanduser ( parsed . profiles_dir ) [EOL] [EOL] if getattr ( parsed , [string] , None ) is not None : [EOL] expanded_user = os . path . expanduser ( parsed . project_dir ) [EOL] parsed . project_dir = os . path . abspath ( expanded_user ) [EOL] [EOL] if not hasattr ( parsed , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] p . print_help ( ) [EOL] p . exit ( [number] ) [EOL] [EOL] return parsed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.RawTextHelpFormatter$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.RawTextHelpFormatter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.RawTextHelpFormatter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import core [EOL] import typing [EOL] import pathlib [EOL] import renderer [EOL] from pathlib import Path [EOL] from typing import Dict , Any [EOL] [EOL] from hologram import ValidationError [EOL] [EOL] from . renderer import SelectorRenderer [EOL] [EOL] from dbt . clients . system import ( load_file_contents , path_exists , resolve_path_from_base , ) [EOL] from dbt . clients . yaml_helper import load_yaml_text [EOL] from dbt . contracts . selection import SelectorFile [EOL] from dbt . exceptions import DbtSelectorsError , RuntimeException [EOL] from dbt . graph import parse_from_selectors_definition , SelectionSpec [EOL] [EOL] MALFORMED_SELECTOR_ERROR = [string] [EOL] [EOL] [EOL] class SelectorConfig ( Dict [ str , SelectionSpec ] ) : [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] try : [EOL] selector_file = SelectorFile . from_dict ( data ) [EOL] selectors = parse_from_selectors_definition ( selector_file ) [EOL] except ( ValidationError , RuntimeException ) as exc : [EOL] raise DbtSelectorsError ( f' [string] { exc }' , result_type = [string] , ) from exc [EOL] [EOL] return cls ( selectors ) [EOL] [EOL] @ classmethod def render_from_dict ( cls , data , renderer , ) : [EOL] try : [EOL] rendered = renderer . render_data ( data ) [EOL] except ( ValidationError , RuntimeException ) as exc : [EOL] raise DbtSelectorsError ( f' [string] { exc }' , result_type = [string] , ) from exc [EOL] return cls . from_dict ( rendered ) [EOL] [EOL] @ classmethod def from_path ( cls , path , renderer , ) : [EOL] try : [EOL] data = load_yaml_text ( load_file_contents ( str ( path ) ) ) [EOL] except ( ValidationError , RuntimeException ) as exc : [EOL] raise DbtSelectorsError ( f' [string] { exc }' , result_type = [string] , path = path , ) from exc [EOL] [EOL] try : [EOL] return cls . render_from_dict ( data , renderer ) [EOL] except DbtSelectorsError as exc : [EOL] exc . path = path [EOL] raise [EOL] [EOL] [EOL] def selector_data_from_root ( project_root ) : [EOL] selector_filepath = resolve_path_from_base ( [string] , project_root ) [EOL] [EOL] if path_exists ( selector_filepath ) : [EOL] selectors_dict = load_yaml_text ( load_file_contents ( selector_filepath ) ) [EOL] else : [EOL] selectors_dict = None [EOL] return selectors_dict [EOL] [EOL] [EOL] def selector_config_from_data ( selectors_data ) : [EOL] if not selectors_data : [EOL] selectors_data = { [string] : [ ] } [EOL] [EOL] try : [EOL] selectors = SelectorConfig . from_dict ( selectors_data ) [EOL] except ValidationError as e : [EOL] raise DbtSelectorsError ( MALFORMED_SELECTOR_ERROR . format ( error = str ( e . message ) ) , result_type = [string] , ) from e [EOL] return selectors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'SelectorConfig'$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $'SelectorConfig'$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $renderer.SelectorRenderer$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $renderer.SelectorRenderer$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $'SelectorConfig'$ 0 0 0 0 0 $renderer.SelectorRenderer$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $renderer.SelectorRenderer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SelectorConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . profile import Profile , PROFILES_DIR , read_user_config [comment] [EOL] from . project import Project , IsFQNResource [comment] [EOL] from . runtime import RuntimeConfig , UnsetProfileConfig [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Type [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , Any [EOL] [EOL] from dbt . clients import yaml_helper [EOL] from dbt . exceptions import raise_compiler_error , ValidationException [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] [EOL] [EOL] def parse_cli_vars ( var_string ) : [EOL] try : [EOL] cli_vars = yaml_helper . load_yaml_text ( var_string ) [EOL] var_type = type ( cli_vars ) [EOL] if var_type is dict : [EOL] return cli_vars [EOL] else : [EOL] type_name = var_type . __name__ [EOL] raise_compiler_error ( [string] [string] . format ( type_name ) ) [EOL] except ValidationException : [EOL] logger . error ( [string] ) [EOL] raise [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , List , Set , Union , Dict , Optional , Type , Tuple [EOL] import core [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , Any , Tuple , Optional , Union , Callable [EOL] [EOL] from dbt . clients . jinja import get_rendered , catch_jinja [EOL] [EOL] from dbt . exceptions import ( DbtProjectError , CompilationException , RecursionException ) [EOL] from dbt . node_types import NodeType [EOL] from dbt . utils import deep_map [EOL] [EOL] [EOL] Keypath = Tuple [ Union [ str , int ] , ... ] [EOL] [EOL] [EOL] class BaseRenderer : [EOL] def __init__ ( self , context ) : [EOL] self . context = context [EOL] [EOL] @ property def name ( self ) : [EOL] return [string] [EOL] [EOL] def should_render_keypath ( self , keypath ) : [EOL] return True [EOL] [EOL] def render_entry ( self , value , keypath ) : [EOL] if not self . should_render_keypath ( keypath ) : [EOL] return value [EOL] [EOL] return self . render_value ( value , keypath ) [EOL] [EOL] def render_value ( self , value , keypath = None ) : [EOL] [comment] [EOL] [comment] [EOL] if not isinstance ( value , str ) : [EOL] return value [EOL] try : [EOL] with catch_jinja ( ) : [EOL] return get_rendered ( value , self . context , native = True ) [EOL] except CompilationException as exc : [EOL] msg = f' [string] { value } [string] { exc . msg }' [EOL] raise CompilationException ( msg ) from exc [EOL] [EOL] def render_data ( self , data ) : [EOL] try : [EOL] return deep_map ( self . render_entry , data ) [EOL] except RecursionException : [EOL] raise DbtProjectError ( f' [string] { self . name } [string] ' , project = data ) [EOL] [EOL] [EOL] def _list_if_none ( value ) : [EOL] if value is None : [EOL] value = [ ] [EOL] return value [EOL] [EOL] [EOL] def _dict_if_none ( value ) : [EOL] if value is None : [EOL] value = { } [EOL] return value [EOL] [EOL] [EOL] def _list_if_none_or_string ( value ) : [EOL] value = _list_if_none ( value ) [EOL] if isinstance ( value , str ) : [EOL] return [ value ] [EOL] return value [EOL] [EOL] [EOL] class ProjectPostprocessor ( Dict [ Keypath , Callable [ [ Any ] , Any ] ] ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self [ ( [string] , ) ] = _list_if_none_or_string [EOL] self [ ( [string] , ) ] = _list_if_none_or_string [EOL] [EOL] for k in ( [string] , [string] , [string] ) : [EOL] self [ ( k , ) ] = _dict_if_none [EOL] self [ ( k , [string] ) ] = _dict_if_none [EOL] self [ ( k , [string] ) ] = _list_if_none_or_string [EOL] self [ ( k , [string] ) ] = _list_if_none_or_string [EOL] self [ ( [string] , [string] ) ] = _dict_if_none [EOL] [EOL] def postprocess ( self , value , key ) : [EOL] if key in self : [EOL] handler = self [ key ] [EOL] return handler ( value ) [EOL] [EOL] return value [EOL] [EOL] [EOL] class DbtProjectYamlRenderer ( BaseRenderer ) : [EOL] _KEYPATH_HANDLERS = ProjectPostprocessor ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] [EOL] def get_package_renderer ( self ) : [EOL] return PackageRenderer ( self . context ) [EOL] [EOL] def get_selector_renderer ( self ) : [EOL] return SelectorRenderer ( self . context ) [EOL] [EOL] def render_project ( self , project , project_root , ) : [EOL] [docstring] [EOL] rendered_project = self . render_data ( project ) [EOL] rendered_project [ [string] ] = project_root [EOL] return rendered_project [EOL] [EOL] def render_packages ( self , packages ) : [EOL] [docstring] [EOL] package_renderer = self . get_package_renderer ( ) [EOL] return package_renderer . render_data ( packages ) [EOL] [EOL] def render_selectors ( self , selectors ) : [EOL] selector_renderer = self . get_selector_renderer ( ) [EOL] return selector_renderer . render_data ( selectors ) [EOL] [EOL] def render_entry ( self , value , keypath ) : [EOL] result = super ( ) . render_entry ( value , keypath ) [EOL] return self . _KEYPATH_HANDLERS . postprocess ( result , keypath ) [EOL] [EOL] def should_render_keypath ( self , keypath ) : [EOL] if not keypath : [EOL] return True [EOL] [EOL] first = keypath [ [number] ] [EOL] [comment] [EOL] if first in { [string] , [string] , [string] } : [EOL] return False [EOL] [EOL] [comment] [EOL] if first == [string] : [EOL] return False [EOL] [EOL] if first in { [string] , [string] , [string] , [string] } : [EOL] keypath_parts = { ( k . lstrip ( [string] ) if isinstance ( k , str ) else k ) for k in keypath } [EOL] [comment] [EOL] if [string] in keypath_parts or [string] in keypath_parts : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] class ProfileRenderer ( BaseRenderer ) : [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] class SchemaYamlRenderer ( BaseRenderer ) : [EOL] DOCUMENTABLE_NODES = frozenset ( n . pluralize ( ) for n in NodeType . documentable ( ) ) [EOL] [EOL] @ property def name ( self ) : [EOL] return [string] [EOL] [EOL] def _is_norender_key ( self , keypath ) : [EOL] [docstring] [EOL] if len ( keypath ) >= [number] and keypath [ [number] ] in ( [string] , [string] ) : [EOL] return True [EOL] [EOL] if ( len ( keypath ) >= [number] and keypath [ [number] ] == [string] and keypath [ [number] ] in ( [string] , [string] ) ) : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [comment] [EOL] def should_render_keypath ( self , keypath ) : [EOL] if len ( keypath ) < [number] : [EOL] return True [EOL] [EOL] if keypath [ [number] ] not in self . DOCUMENTABLE_NODES : [EOL] return True [EOL] [EOL] if len ( keypath ) < [number] : [EOL] return True [EOL] [EOL] if keypath [ [number] ] == NodeType . Source . pluralize ( ) : [EOL] if keypath [ [number] ] == [string] : [EOL] return False [EOL] if keypath [ [number] ] == [string] : [EOL] if self . _is_norender_key ( keypath [ [number] : ] ) : [EOL] return False [EOL] elif keypath [ [number] ] == NodeType . Macro . pluralize ( ) : [EOL] if keypath [ [number] ] == [string] : [EOL] if self . _is_norender_key ( keypath [ [number] : ] ) : [EOL] return False [EOL] elif self . _is_norender_key ( keypath [ [number] : ] ) : [EOL] return False [EOL] else : [comment] [EOL] if self . _is_norender_key ( keypath [ [number] : ] ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] class PackageRenderer ( BaseRenderer ) : [EOL] @ property def name ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class SelectorRenderer ( BaseRenderer ) : [EOL] @ property def name ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 $Keypath$ 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $Keypath$ 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Keypath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , List , Set , MutableSet , Dict , Mapping , Optional , Type , Tuple , Iterator [EOL] import profile [EOL] import project [EOL] import itertools [EOL] import builtins [EOL] import core [EOL] import dbt [EOL] import typing [EOL] import pathlib [EOL] import renderer [EOL] import itertools [EOL] import os [EOL] from copy import deepcopy [EOL] from dataclasses import dataclass , fields [EOL] from pathlib import Path [EOL] from typing import ( Dict , Any , Optional , Mapping , Iterator , Iterable , Tuple , List , MutableSet , Type ) [EOL] [EOL] from . profile import Profile [EOL] from . project import Project [EOL] from . renderer import DbtProjectYamlRenderer , ProfileRenderer [EOL] from . utils import parse_cli_vars [EOL] from dbt import tracking [EOL] from dbt . adapters . factory import get_relation_class_by_name , get_include_paths [EOL] from dbt . helper_types import FQNPath , PathSet [EOL] from dbt . context . base import generate_base_context [EOL] from dbt . context . target import generate_target_context [EOL] from dbt . contracts . connection import AdapterRequiredConfig , Credentials [EOL] from dbt . contracts . graph . manifest import ManifestMetadata [EOL] from dbt . contracts . relation import ComponentName [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt . ui import warning_tag [EOL] [EOL] from dbt . contracts . project import Configuration , UserConfig [EOL] from dbt . exceptions import ( RuntimeException , DbtProfileError , DbtProjectError , validator_error_message , warn_or_error , raise_compiler_error ) [EOL] [EOL] from hologram import ValidationError [EOL] [EOL] [EOL] def _project_quoting_dict ( proj , profile ) : [EOL] src = profile . credentials . translate_aliases ( proj . quoting ) [EOL] result = { } [EOL] for key in ComponentName : [EOL] if key in src : [EOL] value = src [ key ] [EOL] if isinstance ( value , bool ) : [EOL] result [ key ] = value [EOL] return result [EOL] [EOL] [EOL] @ dataclass class RuntimeConfig ( Project , Profile , AdapterRequiredConfig ) : [EOL] args = ... [EOL] profile_name = ... [EOL] cli_vars = ... [EOL] dependencies = None [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . validate ( ) [EOL] [EOL] @ classmethod def from_parts ( cls , project , profile , args , dependencies = None , ) : [EOL] [docstring] [EOL] quoting = ( get_relation_class_by_name ( profile . credentials . type ) . get_default_quote_policy ( ) . replace_dict ( _project_quoting_dict ( project , profile ) ) ) . to_dict ( ) [EOL] [EOL] cli_vars = parse_cli_vars ( getattr ( args , [string] , [string] ) ) [EOL] [EOL] return cls ( project_name = project . project_name , version = project . version , project_root = project . project_root , source_paths = project . source_paths , macro_paths = project . macro_paths , data_paths = project . data_paths , test_paths = project . test_paths , analysis_paths = project . analysis_paths , docs_paths = project . docs_paths , asset_paths = project . asset_paths , target_path = project . target_path , snapshot_paths = project . snapshot_paths , clean_targets = project . clean_targets , log_path = project . log_path , modules_path = project . modules_path , quoting = quoting , models = project . models , on_run_start = project . on_run_start , on_run_end = project . on_run_end , seeds = project . seeds , snapshots = project . snapshots , dbt_version = project . dbt_version , packages = project . packages , selectors = project . selectors , query_comment = project . query_comment , sources = project . sources , vars = project . vars , config_version = project . config_version , unrendered = project . unrendered , profile_name = profile . profile_name , target_name = profile . target_name , config = profile . config , threads = profile . threads , credentials = profile . credentials , args = args , cli_vars = cli_vars , dependencies = dependencies , ) [EOL] [EOL] def new_project ( self , project_root ) : [EOL] [docstring] [EOL] [comment] [EOL] profile = Profile ( ** self . to_profile_info ( ) ) [EOL] profile . validate ( ) [EOL] [EOL] [comment] [EOL] renderer = DbtProjectYamlRenderer ( generate_target_context ( profile , { } ) ) [EOL] [EOL] project = Project . from_project_root ( project_root , renderer , verify_version = getattr ( self . args , [string] , False ) , ) [EOL] [EOL] cfg = self . from_parts ( project = project , profile = profile , args = deepcopy ( self . args ) , ) [EOL] [comment] [EOL] cfg . quoting = deepcopy ( self . quoting ) [EOL] return cfg [EOL] [EOL] def serialize ( self ) : [EOL] [docstring] [EOL] result = self . to_project_config ( with_packages = True ) [EOL] result . update ( self . to_profile_info ( serialize_credentials = True ) ) [EOL] result [ [string] ] = deepcopy ( self . cli_vars ) [EOL] return result [EOL] [EOL] def validate ( self ) : [EOL] [docstring] [EOL] try : [EOL] Configuration . from_dict ( self . serialize ( ) ) [EOL] except ValidationError as e : [EOL] raise DbtProjectError ( validator_error_message ( e ) ) from e [EOL] [EOL] @ classmethod def _get_rendered_profile ( cls , args , profile_renderer , profile_name , ) : [EOL] return Profile . render_from_args ( args , profile_renderer , profile_name ) [EOL] [EOL] @ classmethod def collect_parts ( cls , args ) : [EOL] [comment] [EOL] project_root = args . project_dir if args . project_dir else os . getcwd ( ) [EOL] version_check = getattr ( args , [string] , False ) [EOL] partial = Project . partial_load ( project_root , verify_version = version_check ) [EOL] [EOL] [comment] [EOL] cli_vars = parse_cli_vars ( getattr ( args , [string] , [string] ) ) [EOL] profile_renderer = ProfileRenderer ( generate_base_context ( cli_vars ) ) [EOL] profile_name = partial . render_profile_name ( profile_renderer ) [EOL] [EOL] profile = cls . _get_rendered_profile ( args , profile_renderer , profile_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] ctx = generate_target_context ( profile , cli_vars ) [EOL] project_renderer = DbtProjectYamlRenderer ( ctx ) [EOL] project = partial . render ( project_renderer ) [EOL] return ( project , profile ) [EOL] [EOL] @ classmethod def from_args ( cls , args ) : [EOL] [docstring] [EOL] project , profile = cls . collect_parts ( args ) [EOL] [EOL] return cls . from_parts ( project = project , profile = profile , args = args , ) [EOL] [EOL] def get_metadata ( self ) : [EOL] return ManifestMetadata ( project_id = self . hashed_name ( ) , adapter_type = self . credentials . type ) [EOL] [EOL] def _get_v2_config_paths ( self , config , path , paths , ) : [EOL] for key , value in config . items ( ) : [EOL] if isinstance ( value , dict ) and not key . startswith ( [string] ) : [EOL] self . _get_v2_config_paths ( value , path + ( key , ) , paths ) [EOL] else : [EOL] paths . add ( path ) [EOL] return frozenset ( paths ) [EOL] [EOL] def _get_config_paths ( self , config , path = ( ) , paths = None , ) : [EOL] if paths is None : [EOL] paths = set ( ) [EOL] [EOL] for key , value in config . items ( ) : [EOL] if isinstance ( value , dict ) and not key . startswith ( [string] ) : [EOL] self . _get_v2_config_paths ( value , path + ( key , ) , paths ) [EOL] else : [EOL] paths . add ( path ) [EOL] return frozenset ( paths ) [EOL] [EOL] def get_resource_config_paths ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _get_config_paths ( self . models ) , [string] : self . _get_config_paths ( self . seeds ) , [string] : self . _get_config_paths ( self . snapshots ) , [string] : self . _get_config_paths ( self . sources ) , } [EOL] [EOL] def get_unused_resource_config_paths ( self , resource_fqns , disabled , ) : [EOL] [docstring] [EOL] disabled_fqns = frozenset ( tuple ( fqn ) for fqn in disabled ) [EOL] resource_config_paths = self . get_resource_config_paths ( ) [EOL] unused_resource_config_paths = [ ] [EOL] for resource_type , config_paths in resource_config_paths . items ( ) : [EOL] used_fqns = resource_fqns . get ( resource_type , frozenset ( ) ) [EOL] fqns = used_fqns | disabled_fqns [EOL] [EOL] for config_path in config_paths : [EOL] if not _is_config_used ( config_path , fqns ) : [EOL] unused_resource_config_paths . append ( ( resource_type , ) + config_path ) [EOL] return unused_resource_config_paths [EOL] [EOL] def warn_for_unused_resource_config_paths ( self , resource_fqns , disabled , ) : [EOL] unused = self . get_unused_resource_config_paths ( resource_fqns , disabled ) [EOL] if len ( unused ) == [number] : [EOL] return [EOL] [EOL] msg = UNUSED_RESOURCE_CONFIGURATION_PATH_MESSAGE . format ( len ( unused ) , [string] . join ( [string] . format ( [string] . join ( u ) ) for u in unused ) ) [EOL] [EOL] warn_or_error ( msg , log_fmt = warning_tag ( [string] ) ) [EOL] [EOL] def load_dependencies ( self ) : [EOL] if self . dependencies is None : [EOL] all_projects = { self . project_name : self } [EOL] internal_packages = get_include_paths ( self . credentials . type ) [EOL] project_paths = itertools . chain ( internal_packages , self . _get_project_directories ( ) ) [EOL] for project_name , project in self . load_projects ( project_paths ) : [EOL] if project_name in all_projects : [EOL] raise_compiler_error ( f' [string] ' f' [string] { project_name } [string] ' f' [string] ' f' [string] ' ) [EOL] all_projects [ project_name ] = project [EOL] self . dependencies = all_projects [EOL] return self . dependencies [EOL] [EOL] def clear_dependencies ( self ) : [EOL] self . dependencies = None [EOL] [EOL] def load_projects ( self , paths ) : [EOL] for path in paths : [EOL] try : [EOL] project = self . new_project ( str ( path ) ) [EOL] except DbtProjectError as e : [EOL] raise DbtProjectError ( f' [string] { e }' , result_type = [string] , path = path , ) from e [EOL] else : [EOL] yield project . project_name , project [EOL] [EOL] def _get_project_directories ( self ) : [EOL] root = Path ( self . project_root ) / self . modules_path [EOL] [EOL] if root . exists ( ) : [EOL] for path in root . iterdir ( ) : [EOL] if path . is_dir ( ) and not path . name . startswith ( [string] ) : [EOL] yield path [EOL] [EOL] [EOL] class UnsetCredentials ( Credentials ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] , [string] ) [EOL] [EOL] @ property def type ( self ) : [EOL] return None [EOL] [EOL] def connection_info ( self , * args , ** kwargs ) : [EOL] return { } [EOL] [EOL] def _connection_keys ( self ) : [EOL] return ( ) [EOL] [EOL] [EOL] class UnsetConfig ( UserConfig ) : [EOL] def __getattribute__ ( self , name ) : [EOL] if name in { f . name for f in fields ( UserConfig ) } : [EOL] raise AttributeError ( f" [string] { name }" ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { } [EOL] [EOL] [EOL] class UnsetProfile ( Profile ) : [EOL] def __init__ ( self ) : [EOL] self . credentials = UnsetCredentials ( ) [EOL] self . config = UnsetConfig ( ) [EOL] self . profile_name = [string] [EOL] self . target_name = [string] [EOL] self . threads = - [number] [EOL] [EOL] def to_target_dict ( self ) : [EOL] return { } [EOL] [EOL] def __getattribute__ ( self , name ) : [EOL] if name in { [string] , [string] , [string] } : [EOL] raise RuntimeException ( f' [string] { name } [string] ' ) [EOL] [EOL] return Profile . __getattribute__ ( self , name ) [EOL] [EOL] [EOL] @ dataclass class UnsetProfileConfig ( RuntimeConfig ) : [EOL] [docstring] [EOL] [EOL] def __post_init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] del self . profile_name [EOL] del self . target_name [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __getattribute__ ( self , name ) : [EOL] [comment] [EOL] if name in { [string] , [string] } : [EOL] raise RuntimeException ( f' [string] { name } [string] ' ) [EOL] [EOL] [comment] [EOL] return RuntimeConfig . __getattribute__ ( self , name ) [EOL] [EOL] def to_target_dict ( self ) : [EOL] [comment] [EOL] return { } [EOL] [EOL] @ classmethod def from_parts ( cls , project , profile , args , dependencies = None , ) : [EOL] [docstring] [EOL] cli_vars = parse_cli_vars ( getattr ( args , [string] , [string] ) ) [EOL] [EOL] return cls ( project_name = project . project_name , version = project . version , project_root = project . project_root , source_paths = project . source_paths , macro_paths = project . macro_paths , data_paths = project . data_paths , test_paths = project . test_paths , analysis_paths = project . analysis_paths , docs_paths = project . docs_paths , asset_paths = project . asset_paths , target_path = project . target_path , snapshot_paths = project . snapshot_paths , clean_targets = project . clean_targets , log_path = project . log_path , modules_path = project . modules_path , quoting = project . quoting , models = project . models , on_run_start = project . on_run_start , on_run_end = project . on_run_end , seeds = project . seeds , snapshots = project . snapshots , dbt_version = project . dbt_version , packages = project . packages , selectors = project . selectors , query_comment = project . query_comment , sources = project . sources , vars = project . vars , config_version = project . config_version , unrendered = project . unrendered , profile_name = [string] , target_name = [string] , config = UnsetConfig ( ) , threads = getattr ( args , [string] , [number] ) , credentials = UnsetCredentials ( ) , args = args , cli_vars = cli_vars , dependencies = dependencies , ) [EOL] [EOL] @ classmethod def _get_rendered_profile ( cls , args , profile_renderer , profile_name , ) : [EOL] try : [EOL] profile = Profile . render_from_args ( args , profile_renderer , profile_name ) [EOL] except ( DbtProjectError , DbtProfileError ) as exc : [EOL] logger . debug ( [string] , exc , exc_info = True ) [EOL] logger . info ( [string] , profile_name ) [EOL] [comment] [EOL] profile = UnsetProfile ( ) [EOL] [comment] [EOL] tracking . disable_tracking ( ) [EOL] return profile [EOL] [EOL] @ classmethod def from_args ( cls , args ) : [EOL] [docstring] [EOL] project , profile = cls . collect_parts ( args ) [EOL] if not isinstance ( profile , UnsetProfile ) : [EOL] [comment] [EOL] cls = RuntimeConfig [EOL] [EOL] return cls . from_parts ( project = project , profile = profile , args = args ) [EOL] [EOL] [EOL] UNUSED_RESOURCE_CONFIGURATION_PATH_MESSAGE = [string] [EOL] [EOL] [EOL] def _is_config_used ( path , fqns ) : [EOL] if fqns : [EOL] for fqn in fqns : [EOL] if len ( path ) <= len ( fqn ) and fqn [ : len ( path ) ] == path : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,'RuntimeConfig']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Mapping[builtins.str,core.dbt.config.runtime.RuntimeConfig]]$ 0 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.str,'RuntimeConfig']]$ 0 0 0 $typing.Iterable[pathlib.Path]$ 0 0 0 0 0 0 $typing.Iterable[pathlib.Path]$ 0 0 0 0 0 $core.dbt.config.runtime.RuntimeConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.config.runtime.RuntimeConfig$ 0 0 0 $core.dbt.config.runtime.RuntimeConfig$ 0 0 0 $typing.Iterator[pathlib.Path]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.config.runtime.UnsetCredentials$ 0 0 0 0 0 0 0 $core.dbt.config.runtime.UnsetConfig$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'RuntimeConfig'$ 0 0 0 $project.Project$ 0 $profile.Profile$ 0 $typing.Any$ 0 $typing.Optional[typing.Mapping[builtins.str,'RuntimeConfig']]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 $project.Project$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[typing.Mapping[builtins.str,'RuntimeConfig']]$ 0 $typing.Optional[typing.Mapping[builtins.str,'RuntimeConfig']]$ 0 0 0 0 0 0 0 $profile.Profile$ 0 0 0 $typing.Any$ 0 $renderer.ProfileRenderer$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $core.dbt.config.runtime.UnsetProfile$ 0 0 0 0 0 $typing.Any$ 0 $renderer.ProfileRenderer$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $core.dbt.config.runtime.UnsetProfile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.config.runtime.UnsetProfile$ 0 0 0 0 0 $'RuntimeConfig'$ 0 $typing.Type[core.dbt.config.runtime.RuntimeConfig]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Type[core.dbt.config.runtime.RuntimeConfig]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[core.dbt.config.runtime.RuntimeConfig]$ 0 0 0 0 0 $typing.Type[core.dbt.config.runtime.RuntimeConfig]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Match , Optional , Dict , ClassVar [EOL] import builtins [EOL] import typing [EOL] from dataclasses import dataclass [EOL] import re [EOL] [EOL] from hologram import JsonSchemaMixin [EOL] from dbt . exceptions import RuntimeException [EOL] [EOL] from typing import Dict , ClassVar , Any , Optional [EOL] [EOL] [EOL] @ dataclass class Column ( JsonSchemaMixin ) : [EOL] TYPE_LABELS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] column = ... [EOL] dtype = ... [EOL] char_size = None [EOL] numeric_precision = None [EOL] numeric_scale = None [EOL] [EOL] @ classmethod def translate_type ( cls , dtype ) : [EOL] return cls . TYPE_LABELS . get ( dtype . upper ( ) , dtype ) [EOL] [EOL] @ classmethod def create ( cls , name , label_or_dtype ) : [EOL] column_type = cls . translate_type ( label_or_dtype ) [EOL] return cls ( name , column_type ) [EOL] [EOL] @ property def name ( self ) : [EOL] return self . column [EOL] [EOL] @ property def quoted ( self ) : [EOL] return [string] . format ( self . column ) [EOL] [EOL] @ property def data_type ( self ) : [EOL] if self . is_string ( ) : [EOL] return Column . string_type ( self . string_size ( ) ) [EOL] elif self . is_numeric ( ) : [EOL] return Column . numeric_type ( self . dtype , self . numeric_precision , self . numeric_scale ) [EOL] else : [EOL] return self . dtype [EOL] [EOL] def is_string ( self ) : [EOL] return self . dtype . lower ( ) in [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def is_number ( self ) : [EOL] return any ( [ self . is_integer ( ) , self . is_numeric ( ) , self . is_float ( ) ] ) [EOL] [EOL] def is_float ( self ) : [EOL] return self . dtype . lower ( ) in [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def is_integer ( self ) : [EOL] return self . dtype . lower ( ) in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] def is_numeric ( self ) : [EOL] return self . dtype . lower ( ) in [ [string] , [string] ] [EOL] [EOL] def string_size ( self ) : [EOL] if not self . is_string ( ) : [EOL] raise RuntimeException ( [string] ) [EOL] [EOL] if self . dtype == [string] or self . char_size is None : [EOL] [comment] [EOL] return [number] [EOL] else : [EOL] return int ( self . char_size ) [EOL] [EOL] def can_expand_to ( self , other_column ) : [EOL] [docstring] [EOL] if not self . is_string ( ) or not other_column . is_string ( ) : [EOL] return False [EOL] [EOL] return other_column . string_size ( ) > self . string_size ( ) [EOL] [EOL] def literal ( self , value ) : [EOL] return [string] . format ( value , self . data_type ) [EOL] [EOL] @ classmethod def string_type ( cls , size ) : [EOL] return [string] . format ( size ) [EOL] [EOL] @ classmethod def numeric_type ( cls , dtype , precision , scale ) : [EOL] [comment] [EOL] [comment] [EOL] if precision is None or scale is None : [EOL] return dtype [EOL] else : [EOL] return [string] . format ( dtype , precision , scale ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . name , self . data_type ) [EOL] [EOL] @ classmethod def from_description ( cls , name , raw_data_type ) : [EOL] match = re . match ( [string] , raw_data_type ) [EOL] if match is None : [EOL] raise RuntimeException ( f' [string] { raw_data_type } [string] ' ) [EOL] data_type , size_info = match . groups ( ) [EOL] char_size = None [EOL] numeric_precision = None [EOL] numeric_scale = None [EOL] if size_info is not None : [EOL] [comment] [EOL] size_info = size_info [ [number] : - [number] ] [EOL] parts = size_info . split ( [string] ) [EOL] if len ( parts ) == [number] : [EOL] try : [EOL] char_size = int ( parts [ [number] ] ) [EOL] except ValueError : [EOL] raise RuntimeException ( f' [string] { raw_data_type } [string] ' f' [string] { parts [ [number] ] } [string] ' ) [EOL] elif len ( parts ) == [number] : [EOL] try : [EOL] numeric_precision = int ( parts [ [number] ] ) [EOL] except ValueError : [EOL] raise RuntimeException ( f' [string] { raw_data_type } [string] ' f' [string] { parts [ [number] ] } [string] ' ) [EOL] try : [EOL] numeric_scale = int ( parts [ [number] ] ) [EOL] except ValueError : [EOL] raise RuntimeException ( f' [string] { raw_data_type } [string] ' f' [string] { parts [ [number] ] } [string] ' ) [EOL] [EOL] return cls ( name , data_type , char_size , numeric_precision , numeric_scale ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $'Column'$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $'Column'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Column'$ 0 0 0 0 0 0 0 0 0 0 0 $'Column'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Column'$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0
from typing import Type , Any , List , Optional [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] from typing import List , Optional , Type [EOL] [EOL] from dbt . adapters . base import Credentials [EOL] from dbt . exceptions import CompilationException [EOL] from dbt . adapters . protocol import AdapterProtocol [EOL] [EOL] [EOL] def project_name_from_path ( include_path ) : [EOL] [comment] [EOL] from dbt . config . project import Project [EOL] partial = Project . partial_load ( include_path ) [EOL] if partial . project_name is None : [EOL] raise CompilationException ( f' [string] { include_path } [string] ' ) [EOL] return partial . project_name [EOL] [EOL] [EOL] class AdapterPlugin : [EOL] [docstring] [EOL] def __init__ ( self , adapter , credentials , include_path , dependencies = None ) : [EOL] [EOL] self . adapter = adapter [EOL] self . credentials = credentials [EOL] self . include_path = include_path [EOL] self . project_name = project_name_from_path ( include_path ) [EOL] self . dependencies = ... [EOL] if dependencies is None : [EOL] self . dependencies = [ ] [EOL] else : [EOL] self . dependencies = dependencies [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[dbt.adapters.protocol.AdapterProtocol]$ 0 $typing.Type[dbt.adapters.base.Credentials]$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Type[dbt.adapters.protocol.AdapterProtocol]$ 0 $typing.Type[dbt.adapters.protocol.AdapterProtocol]$ 0 0 0 $typing.Type[dbt.adapters.base.Credentials]$ 0 $typing.Type[dbt.adapters.base.Credentials]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0
from typing import Any , Generator , Iterable , Callable , List , Set , Dict , Mapping , Optional , Type , Tuple , Literal , Iterator [EOL] import typing_extensions [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import agate [EOL] import concurrent [EOL] import abc [EOL] from concurrent . futures import as_completed , Future [EOL] from contextlib import contextmanager [EOL] from datetime import datetime [EOL] from itertools import chain [EOL] from typing import ( Optional , Tuple , Callable , Iterable , Type , Dict , Any , List , Mapping , Iterator , Union , Set ) [EOL] [EOL] import agate [EOL] import pytz [EOL] [EOL] from dbt . exceptions import ( raise_database_error , raise_compiler_error , invalid_type_error , get_relation_returned_multiple_results , InternalException , NotImplementedException , RuntimeException , ) [EOL] from dbt import flags [EOL] [EOL] from dbt import deprecations [EOL] from dbt . adapters . protocol import ( AdapterConfig , ConnectionManagerProtocol , ) [EOL] from dbt . clients . agate_helper import empty_table , merge_tables , table_from_rows [EOL] from dbt . clients . jinja import MacroGenerator [EOL] from dbt . contracts . graph . compiled import ( CompileResultNode , CompiledSeedNode ) [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . graph . parsed import ParsedSeedNode [EOL] from dbt . exceptions import warn_or_error [EOL] from dbt . node_types import NodeType [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt . utils import filter_null_values , executor [EOL] [EOL] from dbt . adapters . base . connections import Connection [EOL] from dbt . adapters . base . meta import AdapterMeta , available [EOL] from dbt . adapters . base . relation import ( ComponentName , BaseRelation , InformationSchema , SchemaSearchMap ) [EOL] from dbt . adapters . base import Column as BaseColumn [EOL] from dbt . adapters . cache import RelationsCache [EOL] [EOL] [EOL] SeedModel = Union [ ParsedSeedNode , CompiledSeedNode ] [EOL] [EOL] [EOL] GET_CATALOG_MACRO_NAME = [string] [EOL] FRESHNESS_MACRO_NAME = [string] [EOL] [EOL] [EOL] def _expect_row_value ( key , row ) : [EOL] if key not in row . keys ( ) : [EOL] raise InternalException ( [string] . format ( key , row . keys ( ) ) ) [EOL] return row [ key ] [EOL] [EOL] [EOL] def _catalog_filter_schemas ( manifest ) : [EOL] [docstring] [EOL] schemas = frozenset ( ( d . lower ( ) , s . lower ( ) ) for d , s in manifest . get_used_schemas ( ) ) [EOL] [EOL] def test ( row ) : [EOL] table_database = _expect_row_value ( [string] , row ) [EOL] table_schema = _expect_row_value ( [string] , row ) [EOL] [comment] [EOL] [comment] [EOL] if table_schema is None : [EOL] return False [EOL] return ( table_database . lower ( ) , table_schema . lower ( ) ) in schemas [EOL] return test [EOL] [EOL] [EOL] def _utc ( dt , source , field_name ) : [EOL] [docstring] [EOL] if dt is None : [EOL] raise raise_database_error ( [string] [string] . format ( field_name , source ) ) [EOL] [EOL] elif not hasattr ( dt , [string] ) : [EOL] raise raise_database_error ( [string] [string] . format ( field_name , source , type ( dt ) . __name__ ) ) [EOL] [EOL] elif dt . tzinfo : [EOL] return dt . astimezone ( pytz . UTC ) [EOL] else : [EOL] return dt . replace ( tzinfo = pytz . UTC ) [EOL] [EOL] [EOL] def _relation_name ( rel ) : [EOL] if rel is None : [EOL] return [string] [EOL] else : [EOL] return str ( rel ) [EOL] [EOL] [EOL] class BaseAdapter ( metaclass = AdapterMeta ) : [EOL] [docstring] [EOL] Relation = BaseRelation [EOL] Column = BaseColumn [EOL] ConnectionManager = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] AdapterSpecificConfigs = AdapterConfig [EOL] [EOL] def __init__ ( self , config ) : [EOL] self . config = config [EOL] self . cache = RelationsCache ( ) [EOL] self . connections = self . ConnectionManager ( config ) [EOL] self . _macro_manifest_lazy = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def acquire_connection ( self , name = None ) : [EOL] return self . connections . set_connection_name ( name ) [EOL] [EOL] def release_connection ( self ) : [EOL] self . connections . release ( ) [EOL] [EOL] def cleanup_connections ( self ) : [EOL] self . connections . cleanup_all ( ) [EOL] [EOL] def clear_transaction ( self ) : [EOL] self . connections . clear_transaction ( ) [EOL] [EOL] def commit_if_has_connection ( self ) : [EOL] self . connections . commit_if_has_connection ( ) [EOL] [EOL] def nice_connection_name ( self ) : [EOL] conn = self . connections . get_if_exists ( ) [EOL] if conn is None or conn . name is None : [EOL] return [string] [EOL] return conn . name [EOL] [EOL] @ contextmanager def connection_named ( self , name , node = None ) : [EOL] try : [EOL] if self . connections . query_header is not None : [EOL] self . connections . query_header . set ( name , node ) [EOL] self . acquire_connection ( name ) [EOL] yield [EOL] finally : [EOL] self . release_connection ( ) [EOL] if self . connections . query_header is not None : [EOL] self . connections . query_header . reset ( ) [EOL] [EOL] @ contextmanager def connection_for ( self , node ) : [EOL] with self . connection_named ( node . unique_id , node ) : [EOL] yield [EOL] [EOL] @ available . parse ( lambda * a , ** k : ( [string] , empty_table ( ) ) ) def execute ( self , sql , auto_begin = False , fetch = False ) : [EOL] [docstring] [EOL] return self . connections . execute ( sql = sql , auto_begin = auto_begin , fetch = fetch ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ classmethod def type ( cls ) : [EOL] [docstring] [EOL] return cls . ConnectionManager . TYPE [EOL] [EOL] @ property def _macro_manifest ( self ) : [EOL] if self . _macro_manifest_lazy is None : [EOL] return self . load_macro_manifest ( ) [EOL] return self . _macro_manifest_lazy [EOL] [EOL] def check_macro_manifest ( self ) : [EOL] [docstring] [EOL] return self . _macro_manifest_lazy [EOL] [EOL] def load_macro_manifest ( self ) : [EOL] if self . _macro_manifest_lazy is None : [EOL] [comment] [EOL] from dbt . parser . manifest import load_macro_manifest [EOL] manifest = load_macro_manifest ( self . config , self . connections . set_query_header ) [EOL] self . _macro_manifest_lazy = manifest [EOL] return self . _macro_manifest_lazy [EOL] [EOL] def clear_macro_manifest ( self ) : [EOL] if self . _macro_manifest_lazy is not None : [EOL] self . _macro_manifest_lazy = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def _schema_is_cached ( self , database , schema ) : [EOL] [docstring] [EOL] [EOL] if flags . USE_CACHE is False : [EOL] return False [EOL] elif ( database , schema ) not in self . cache : [EOL] logger . debug ( [string] . format ( self . nice_connection_name ( ) , database , schema ) ) [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] def _get_cache_schemas ( self , manifest ) : [EOL] [docstring] [EOL] [comment] [EOL] return { self . Relation . create_from ( self . config , node ) . without_identifier ( ) for node in manifest . nodes . values ( ) if ( node . resource_type in NodeType . executable ( ) and not node . is_ephemeral_model ) } [EOL] [EOL] def _get_catalog_schemas ( self , manifest ) : [EOL] [docstring] [EOL] info_schema_name_map = SchemaSearchMap ( ) [EOL] nodes = chain ( manifest . nodes . values ( ) , manifest . sources . values ( ) , ) [EOL] for node in nodes : [EOL] relation = self . Relation . create_from ( self . config , node ) [EOL] info_schema_name_map . add ( relation ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return info_schema_name_map [EOL] [EOL] def _relations_cache_for_schemas ( self , manifest ) : [EOL] [docstring] [EOL] if not flags . USE_CACHE : [EOL] return [EOL] [EOL] cache_schemas = self . _get_cache_schemas ( manifest ) [EOL] with executor ( self . config ) as tpe : [EOL] futures = [ ] [EOL] for cache_schema in cache_schemas : [EOL] fut = tpe . submit_connected ( self , f' [string] { cache_schema . database } [string] { cache_schema . schema }' , self . list_relations_without_caching , cache_schema ) [EOL] futures . append ( fut ) [EOL] [EOL] for future in as_completed ( futures ) : [EOL] [comment] [EOL] [comment] [EOL] for relation in future . result ( ) : [EOL] self . cache . add ( relation ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cache_update = set ( ) [EOL] for relation in cache_schemas : [EOL] cache_update . add ( ( relation . database , relation . schema ) ) [EOL] self . cache . update_schemas ( cache_update ) [EOL] [EOL] def set_relations_cache ( self , manifest , clear = False ) : [EOL] [docstring] [EOL] if not flags . USE_CACHE : [EOL] return [EOL] [EOL] with self . cache . lock : [EOL] if clear : [EOL] self . cache . clear ( ) [EOL] self . _relations_cache_for_schemas ( manifest ) [EOL] [EOL] @ available def cache_added ( self , relation ) : [EOL] [docstring] [EOL] if relation is None : [EOL] name = self . nice_connection_name ( ) [EOL] raise_compiler_error ( [string] . format ( name ) ) [EOL] if flags . USE_CACHE : [EOL] self . cache . add ( relation ) [EOL] [comment] [EOL] return [string] [EOL] [EOL] @ available def cache_dropped ( self , relation ) : [EOL] [docstring] [EOL] if relation is None : [EOL] name = self . nice_connection_name ( ) [EOL] raise_compiler_error ( [string] . format ( name ) ) [EOL] if flags . USE_CACHE : [EOL] self . cache . drop ( relation ) [EOL] return [string] [EOL] [EOL] @ available def cache_renamed ( self , from_relation , to_relation , ) : [EOL] [docstring] [EOL] if from_relation is None or to_relation is None : [EOL] name = self . nice_connection_name ( ) [EOL] src_name = _relation_name ( from_relation ) [EOL] dst_name = _relation_name ( to_relation ) [EOL] raise_compiler_error ( [string] . format ( src_name , dst_name , name ) ) [EOL] [EOL] if flags . USE_CACHE : [EOL] self . cache . rename ( from_relation , to_relation ) [EOL] return [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ abc . abstractclassmethod def date_function ( cls ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractclassmethod def is_cancelable ( cls ) : [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ abc . abstractmethod def list_schemas ( self , database ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ available . parse ( lambda * a , ** k : False ) def check_schema_exists ( self , database , schema ) : [EOL] [docstring] [EOL] search = ( s . lower ( ) for s in self . list_schemas ( database = database ) ) [EOL] return schema . lower ( ) in search [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ abc . abstractmethod @ available . parse_none def drop_relation ( self , relation ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractmethod @ available . parse_none def truncate_relation ( self , relation ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractmethod @ available . parse_none def rename_relation ( self , from_relation , to_relation ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractmethod @ available . parse_list def get_columns_in_relation ( self , relation ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ available . deprecated ( [string] , lambda * a , ** k : [ ] ) def get_columns_in_table ( self , schema , identifier ) : [EOL] [docstring] [EOL] relation = self . Relation . create ( database = self . config . credentials . database , schema = schema , identifier = identifier , quote_policy = self . config . quoting ) [EOL] return self . get_columns_in_relation ( relation ) [EOL] [EOL] @ abc . abstractmethod def expand_column_types ( self , goal , current ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractmethod def list_relations_without_caching ( self , schema_relation ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ available . parse_list def get_missing_columns ( self , from_relation , to_relation ) : [EOL] [docstring] [EOL] if not isinstance ( from_relation , self . Relation ) : [EOL] invalid_type_error ( method_name = [string] , arg_name = [string] , got_value = from_relation , expected_type = self . Relation ) [EOL] [EOL] if not isinstance ( to_relation , self . Relation ) : [EOL] invalid_type_error ( method_name = [string] , arg_name = [string] , got_value = to_relation , expected_type = self . Relation ) [EOL] [EOL] from_columns = { col . name : col for col in self . get_columns_in_relation ( from_relation ) } [EOL] [EOL] to_columns = { col . name : col for col in self . get_columns_in_relation ( to_relation ) } [EOL] [EOL] missing_columns = set ( from_columns . keys ( ) ) - set ( to_columns . keys ( ) ) [EOL] [EOL] return [ col for ( col_name , col ) in from_columns . items ( ) if col_name in missing_columns ] [EOL] [EOL] @ available . parse_none def valid_snapshot_target ( self , relation ) : [EOL] [docstring] [EOL] if not isinstance ( relation , self . Relation ) : [EOL] invalid_type_error ( method_name = [string] , arg_name = [string] , got_value = relation , expected_type = self . Relation ) [EOL] [EOL] columns = self . get_columns_in_relation ( relation ) [EOL] names = set ( c . name . lower ( ) for c in columns ) [EOL] expanded_keys = ( [string] , [string] , [string] ) [EOL] extra = [ ] [EOL] missing = [ ] [EOL] for legacy in expanded_keys : [EOL] desired = [string] + legacy [EOL] if desired not in names : [EOL] missing . append ( desired ) [EOL] if legacy in names : [EOL] extra . append ( legacy ) [EOL] [EOL] if missing : [EOL] if extra : [EOL] msg = ( [string] [string] . format ( [string] . join ( extra ) , [string] . join ( missing ) ) ) [EOL] else : [EOL] msg = ( [string] . format ( [string] . join ( missing ) ) ) [EOL] raise_compiler_error ( msg ) [EOL] [EOL] @ available . parse_none def expand_target_column_types ( self , from_relation , to_relation ) : [EOL] if not isinstance ( from_relation , self . Relation ) : [EOL] invalid_type_error ( method_name = [string] , arg_name = [string] , got_value = from_relation , expected_type = self . Relation ) [EOL] [EOL] if not isinstance ( to_relation , self . Relation ) : [EOL] invalid_type_error ( method_name = [string] , arg_name = [string] , got_value = to_relation , expected_type = self . Relation ) [EOL] [EOL] self . expand_column_types ( from_relation , to_relation ) [EOL] [EOL] def list_relations ( self , database , schema ) : [EOL] if self . _schema_is_cached ( database , schema ) : [EOL] return self . cache . get_relations ( database , schema ) [EOL] [EOL] schema_relation = self . Relation . create ( database = database , schema = schema , identifier = [string] , quote_policy = self . config . quoting ) . without_identifier ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] relations = self . list_relations_without_caching ( schema_relation ) [EOL] [EOL] logger . debug ( [string] . format ( database , schema , relations ) ) [EOL] return relations [EOL] [EOL] def _make_match_kwargs ( self , database , schema , identifier ) : [EOL] quoting = self . config . quoting [EOL] if identifier is not None and quoting [ [string] ] is False : [EOL] identifier = identifier . lower ( ) [EOL] [EOL] if schema is not None and quoting [ [string] ] is False : [EOL] schema = schema . lower ( ) [EOL] [EOL] if database is not None and quoting [ [string] ] is False : [EOL] database = database . lower ( ) [EOL] [EOL] return filter_null_values ( { [string] : database , [string] : identifier , [string] : schema , } ) [EOL] [EOL] def _make_match ( self , relations_list , database , schema , identifier , ) : [EOL] [EOL] matches = [ ] [EOL] [EOL] search = self . _make_match_kwargs ( database , schema , identifier ) [EOL] [EOL] for relation in relations_list : [EOL] if relation . matches ( ** search ) : [EOL] matches . append ( relation ) [EOL] [EOL] return matches [EOL] [EOL] @ available . parse_none def get_relation ( self , database , schema , identifier ) : [EOL] relations_list = self . list_relations ( database , schema ) [EOL] [EOL] matches = self . _make_match ( relations_list , database , schema , identifier ) [EOL] [EOL] if len ( matches ) > [number] : [EOL] kwargs = { [string] : identifier , [string] : schema , [string] : database , } [EOL] get_relation_returned_multiple_results ( kwargs , matches ) [EOL] [EOL] elif matches : [EOL] return matches [ [number] ] [EOL] [EOL] return None [EOL] [EOL] @ available . deprecated ( [string] , lambda * a , ** k : False ) def already_exists ( self , schema , name ) : [EOL] [docstring] [EOL] database = self . config . credentials . database [EOL] relation = self . get_relation ( database , schema , name ) [EOL] return relation is not None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ abc . abstractmethod @ available . parse_none def create_schema ( self , relation ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractmethod @ available . parse_none def drop_schema ( self , relation ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ available @ abc . abstractclassmethod def quote ( cls , identifier ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ available def quote_as_configured ( self , identifier , quote_key ) : [EOL] [docstring] [EOL] try : [EOL] key = ComponentName ( quote_key ) [EOL] except ValueError : [EOL] return identifier [EOL] [EOL] default = self . Relation . get_default_quote_policy ( ) . get_part ( key ) [EOL] if self . config . quoting . get ( key , default ) : [EOL] return self . quote ( identifier ) [EOL] else : [EOL] return identifier [EOL] [EOL] @ available def quote_seed_column ( self , column , quote_config ) : [EOL] [comment] [EOL] quote_columns = False [EOL] if isinstance ( quote_config , bool ) : [EOL] quote_columns = quote_config [EOL] elif quote_config is None : [EOL] deprecations . warn ( [string] ) [EOL] else : [EOL] raise_compiler_error ( f' [string] ' f' [string] { type ( quote_config ) }' ) [EOL] [EOL] if quote_columns : [EOL] return self . quote ( column ) [EOL] else : [EOL] return column [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ abc . abstractclassmethod def convert_text_type ( cls , agate_table , col_idx ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractclassmethod def convert_number_type ( cls , agate_table , col_idx ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractclassmethod def convert_boolean_type ( cls , agate_table , col_idx ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractclassmethod def convert_datetime_type ( cls , agate_table , col_idx ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractclassmethod def convert_date_type ( cls , agate_table , col_idx ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ abc . abstractclassmethod def convert_time_type ( cls , agate_table , col_idx ) : [EOL] [docstring] [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] @ available @ classmethod def convert_type ( cls , agate_table , col_idx ) : [EOL] return cls . convert_agate_type ( agate_table , col_idx ) [EOL] [EOL] @ classmethod def convert_agate_type ( cls , agate_table , col_idx ) : [EOL] agate_type = agate_table . column_types [ col_idx ] [EOL] conversions = [ ( agate . Text , cls . convert_text_type ) , ( agate . Number , cls . convert_number_type ) , ( agate . Boolean , cls . convert_boolean_type ) , ( agate . DateTime , cls . convert_datetime_type ) , ( agate . Date , cls . convert_date_type ) , ( agate . TimeDelta , cls . convert_time_type ) , ] [EOL] for agate_cls , func in conversions : [EOL] if isinstance ( agate_type , agate_cls ) : [EOL] return func ( agate_table , col_idx ) [EOL] [EOL] return None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def execute_macro ( self , macro_name , manifest = None , project = None , context_override = None , kwargs = None , release = False , text_only_columns = None , ) : [EOL] [docstring] [EOL] if release is not False : [EOL] deprecations . warn ( [string] ) [EOL] if kwargs is None : [EOL] kwargs = { } [EOL] if context_override is None : [EOL] context_override = { } [EOL] [EOL] if manifest is None : [EOL] manifest = self . _macro_manifest [EOL] [EOL] macro = manifest . find_macro_by_name ( macro_name , self . config . project_name , project ) [EOL] if macro is None : [EOL] if project is None : [EOL] package_name = [string] [EOL] else : [EOL] package_name = [string] . format ( project ) [EOL] [EOL] raise RuntimeException ( [string] . format ( macro_name , package_name ) ) [EOL] [comment] [EOL] [comment] [EOL] from dbt . context . providers import generate_runtime_macro [EOL] macro_context = generate_runtime_macro ( macro = macro , config = self . config , manifest = manifest , package_name = project ) [EOL] macro_context . update ( context_override ) [EOL] [EOL] macro_function = MacroGenerator ( macro , macro_context ) [EOL] [EOL] with self . connections . exception_handler ( f' [string] { macro_name }' ) : [EOL] result = macro_function ( ** kwargs ) [EOL] return result [EOL] [EOL] @ classmethod def _catalog_filter_table ( cls , table , manifest ) : [EOL] [docstring] [EOL] [comment] [EOL] table = table_from_rows ( table . rows , table . column_names , text_only_columns = [ [string] , [string] , [string] ] ) [EOL] return table . where ( _catalog_filter_schemas ( manifest ) ) [EOL] [EOL] def _get_one_catalog ( self , information_schema , schemas , manifest , ) : [EOL] [EOL] kwargs = { [string] : information_schema , [string] : schemas } [EOL] table = self . execute_macro ( GET_CATALOG_MACRO_NAME , kwargs = kwargs , manifest = manifest , ) [EOL] [EOL] results = self . _catalog_filter_table ( table , manifest ) [EOL] return results [EOL] [EOL] def get_catalog ( self , manifest ) : [EOL] schema_map = self . _get_catalog_schemas ( manifest ) [EOL] [EOL] with executor ( self . config ) as tpe : [EOL] futures = [ ] [EOL] for info , schemas in schema_map . items ( ) : [EOL] if len ( schemas ) == [number] : [EOL] continue [EOL] name = [string] . join ( [ str ( info . database ) , [string] ] ) [EOL] [EOL] fut = tpe . submit_connected ( self , name , self . _get_one_catalog , info , schemas , manifest ) [EOL] futures . append ( fut ) [EOL] [EOL] catalogs , exceptions = catch_as_completed ( futures ) [EOL] [EOL] return catalogs , exceptions [EOL] [EOL] def cancel_open_connections ( self ) : [EOL] [docstring] [EOL] return self . connections . cancel_open ( ) [EOL] [EOL] def calculate_freshness ( self , source , loaded_at_field , filter , manifest = None ) : [EOL] [docstring] [EOL] kwargs = { [string] : source , [string] : loaded_at_field , [string] : filter , } [EOL] [EOL] [comment] [EOL] table = self . execute_macro ( FRESHNESS_MACRO_NAME , kwargs = kwargs , manifest = manifest ) [EOL] [comment] [EOL] [comment] [EOL] if len ( table ) != [number] or len ( table [ [number] ] ) != [number] : [EOL] raise_compiler_error ( [string] . format ( FRESHNESS_MACRO_NAME , [ tuple ( r ) for r in table ] ) ) [EOL] if table [ [number] ] [ [number] ] is None : [EOL] [comment] [EOL] [comment] [EOL] max_loaded_at = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = pytz . UTC ) [EOL] else : [EOL] max_loaded_at = _utc ( table [ [number] ] [ [number] ] , source , loaded_at_field ) [EOL] [EOL] snapshotted_at = _utc ( table [ [number] ] [ [number] ] , source , loaded_at_field ) [EOL] age = ( snapshotted_at - max_loaded_at ) . total_seconds ( ) [EOL] return { [string] : max_loaded_at , [string] : snapshotted_at , [string] : age , } [EOL] [EOL] def pre_model_hook ( self , config ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def post_model_hook ( self , config , context ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def get_compiler ( self ) : [EOL] from dbt . compilation import Compiler [EOL] return Compiler ( self . config ) [EOL] [EOL] [comment] [EOL] def update_column_sql ( self , dst_name , dst_column , clause , where_clause = None , ) : [EOL] clause = f' [string] { dst_name } [string] { dst_column } [string] { clause }' [EOL] if where_clause is not None : [EOL] clause += f' [string] { where_clause }' [EOL] return clause [EOL] [EOL] def timestamp_add_sql ( self , add_to , number = [number] , interval = [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return f"{ add_to } [string] { number } [string] { interval } [string] " [EOL] [EOL] def string_add_sql ( self , add_to , value , location = [string] , ) : [EOL] if location == [string] : [EOL] return f"{ add_to } [string] { value } [string] " [EOL] elif location == [string] : [EOL] return f" [string] { value } [string] { add_to }" [EOL] else : [EOL] raise RuntimeException ( f' [string] { location } [string] ' ) [EOL] [EOL] def get_rows_different_sql ( self , relation_a , relation_b , column_names = None , except_operator = [string] , ) : [EOL] [docstring] [EOL] [comment] [EOL] names = ... [EOL] if column_names is None : [EOL] columns = self . get_columns_in_relation ( relation_a ) [EOL] names = sorted ( ( self . quote ( c . name ) for c in columns ) ) [EOL] else : [EOL] names = sorted ( ( self . quote ( n ) for n in column_names ) ) [EOL] columns_csv = [string] . join ( names ) [EOL] [EOL] sql = COLUMNS_EQUAL_SQL . format ( columns = columns_csv , relation_a = str ( relation_a ) , relation_b = str ( relation_b ) , except_op = except_operator , ) [EOL] [EOL] return sql [EOL] [EOL] [EOL] COLUMNS_EQUAL_SQL = [string] . strip ( ) [EOL] [EOL] [EOL] def catch_as_completed ( futures ) : [EOL] [EOL] [comment] [EOL] tables = [ ] [EOL] exceptions = [ ] [EOL] [EOL] for future in as_completed ( futures ) : [EOL] exc = future . exception ( ) [EOL] [comment] [EOL] if exc is None : [EOL] catalog = future . result ( ) [EOL] tables . append ( catalog ) [EOL] elif ( isinstance ( exc , KeyboardInterrupt ) or not isinstance ( exc , Exception ) ) : [EOL] raise exc [EOL] else : [EOL] warn_or_error ( f' [string] { str ( exc ) }' ) [EOL] [comment] [EOL] exceptions . append ( exc ) [EOL] return merge_tables ( tables ) , exceptions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[dbt.adapters.protocol.ConnectionManagerProtocol]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $dbt.adapters.base.relation.BaseRelation$ 0 $dbt.adapters.base.relation.BaseRelation$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $dbt.adapters.base.relation.BaseRelation$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $dbt.adapters.base.relation.BaseRelation$ 0 0 0 $dbt.adapters.base.relation.BaseRelation$ 0 0 $dbt.adapters.base.relation.BaseRelation$ 0 0 0 $dbt.adapters.base.relation.BaseRelation$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Set , Union , Dict , Optional , Type , TypeVar , Iterator [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import typing [EOL] from collections . abc import Hashable [EOL] from dataclasses import dataclass [EOL] from typing import ( Optional , TypeVar , Any , Type , Dict , Union , Iterator , Tuple , Set ) [EOL] [EOL] from dbt . contracts . graph . compiled import CompiledNode [EOL] from dbt . contracts . graph . parsed import ParsedSourceDefinition , ParsedNode [EOL] from dbt . contracts . relation import ( RelationType , ComponentName , HasQuoting , FakeAPIObject , Policy , Path ) [EOL] from dbt . exceptions import InternalException [EOL] from dbt . node_types import NodeType [EOL] from dbt . utils import filter_null_values , deep_merge , classproperty [EOL] [EOL] import dbt . exceptions [EOL] [EOL] [EOL] Self = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True , eq = False , repr = False ) class BaseRelation ( FakeAPIObject , Hashable ) : [EOL] type = ... [EOL] path = ... [EOL] quote_character = [string] [EOL] include_policy = Policy ( ) [EOL] quote_policy = Policy ( ) [EOL] dbt_created = False [EOL] [EOL] def _is_exactish_match ( self , field , value ) : [EOL] if self . dbt_created and self . quote_policy . get_part ( field ) is False : [EOL] return self . path . get_lowered_part ( field ) == value . lower ( ) [EOL] else : [EOL] return self . path . get_part ( field ) == value [EOL] [EOL] @ classmethod def _get_field_named ( cls , field_name ) : [EOL] for field , _ in cls . _get_fields ( ) : [EOL] if field . name == field_name : [EOL] return field [EOL] [comment] [EOL] raise ValueError ( f' [string] { field_name } [string] ' ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , self . __class__ ) : [EOL] return False [EOL] return self . to_dict ( ) == other . to_dict ( ) [EOL] [EOL] @ classmethod def get_default_quote_policy ( cls ) : [EOL] return cls . _get_field_named ( [string] ) . default [EOL] [EOL] @ classmethod def get_default_include_policy ( cls ) : [EOL] return cls . _get_field_named ( [string] ) . default [EOL] [EOL] def get ( self , key , default = None ) : [EOL] [docstring] [EOL] if key == [string] : [EOL] return { [string] : self . __class__ . __name__ } [EOL] return super ( ) . get ( key , default ) [EOL] [EOL] def matches ( self , database = None , schema = None , identifier = None , ) : [EOL] search = filter_null_values ( { ComponentName . Database : database , ComponentName . Schema : schema , ComponentName . Identifier : identifier } ) [EOL] [EOL] if not search : [EOL] [comment] [EOL] raise dbt . exceptions . RuntimeException ( [string] ) [EOL] [EOL] exact_match = True [EOL] approximate_match = True [EOL] [EOL] for k , v in search . items ( ) : [EOL] if not self . _is_exactish_match ( k , v ) : [EOL] exact_match = False [EOL] [EOL] if self . path . get_lowered_part ( k ) != v . lower ( ) : [EOL] approximate_match = False [EOL] [EOL] if approximate_match and not exact_match : [EOL] target = self . create ( database = database , schema = schema , identifier = identifier ) [EOL] dbt . exceptions . approximate_relation_match ( target , self ) [EOL] [EOL] return exact_match [EOL] [EOL] def replace_path ( self , ** kwargs ) : [EOL] return self . replace ( path = self . path . replace ( ** kwargs ) ) [EOL] [EOL] def quote ( self , database = None , schema = None , identifier = None , ) : [EOL] policy = filter_null_values ( { ComponentName . Database : database , ComponentName . Schema : schema , ComponentName . Identifier : identifier } ) [EOL] [EOL] new_quote_policy = self . quote_policy . replace_dict ( policy ) [EOL] return self . replace ( quote_policy = new_quote_policy ) [EOL] [EOL] def include ( self , database = None , schema = None , identifier = None , ) : [EOL] policy = filter_null_values ( { ComponentName . Database : database , ComponentName . Schema : schema , ComponentName . Identifier : identifier } ) [EOL] [EOL] new_include_policy = self . include_policy . replace_dict ( policy ) [EOL] return self . replace ( include_policy = new_include_policy ) [EOL] [EOL] def information_schema ( self , view_name = None ) : [EOL] [comment] [EOL] if not isinstance ( view_name , str ) : [EOL] view_name = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] info_schema = InformationSchema . from_relation ( self , view_name ) [EOL] return info_schema . incorporate ( path = { [string] : None } ) [EOL] [EOL] def information_schema_only ( self ) : [EOL] return self . information_schema ( ) [EOL] [EOL] def without_identifier ( self ) : [EOL] [docstring] [EOL] return self . include ( identifier = False ) . replace_path ( identifier = None ) [EOL] [EOL] def _render_iterator ( self ) : [EOL] [EOL] for key in ComponentName : [EOL] path_part = None [EOL] if self . include_policy . get_part ( key ) : [EOL] path_part = self . path . get_part ( key ) [EOL] if path_part is not None and self . quote_policy . get_part ( key ) : [EOL] path_part = self . quoted ( path_part ) [EOL] yield key , path_part [EOL] [EOL] def render ( self ) : [EOL] [comment] [EOL] return [string] . join ( part for _ , part in self . _render_iterator ( ) if part is not None ) [EOL] [EOL] def quoted ( self , identifier ) : [EOL] return [string] . format ( quote_char = self . quote_character , identifier = identifier , ) [EOL] [EOL] @ classmethod def create_from_source ( cls , source , ** kwargs ) : [EOL] source_quoting = source . quoting . to_dict ( ) [EOL] source_quoting . pop ( [string] , None ) [EOL] quote_policy = deep_merge ( cls . get_default_quote_policy ( ) . to_dict ( ) , source_quoting , kwargs . get ( [string] , { } ) , ) [EOL] [EOL] return cls . create ( database = source . database , schema = source . schema , identifier = source . identifier , quote_policy = quote_policy , ** kwargs ) [EOL] [EOL] @ staticmethod def add_ephemeral_prefix ( name ) : [EOL] return f' [string] { name }' [EOL] [EOL] @ classmethod def create_ephemeral_from_node ( cls , config , node , ) : [EOL] [comment] [EOL] identifier = cls . add_ephemeral_prefix ( node . name ) [EOL] return cls . create ( type = cls . CTE , identifier = identifier , ) . quote ( identifier = False ) [EOL] [EOL] @ classmethod def create_from_node ( cls , config , node , quote_policy = None , ** kwargs , ) : [EOL] if quote_policy is None : [EOL] quote_policy = { } [EOL] [EOL] quote_policy = dbt . utils . merge ( config . quoting , quote_policy ) [EOL] [EOL] return cls . create ( database = node . database , schema = node . schema , identifier = node . alias , quote_policy = quote_policy , ** kwargs ) [EOL] [EOL] @ classmethod def create_from ( cls , config , node , ** kwargs , ) : [EOL] if node . resource_type == NodeType . Source : [EOL] if not isinstance ( node , ParsedSourceDefinition ) : [EOL] raise InternalException ( [string] . format ( type ( node ) ) ) [EOL] return cls . create_from_source ( node , ** kwargs ) [EOL] else : [EOL] if not isinstance ( node , ( ParsedNode , CompiledNode ) ) : [EOL] raise InternalException ( [string] [string] . format ( type ( node ) ) ) [EOL] return cls . create_from_node ( config , node , ** kwargs ) [EOL] [EOL] @ classmethod def create ( cls , database = None , schema = None , identifier = None , type = None , ** kwargs , ) : [EOL] kwargs . update ( { [string] : { [string] : database , [string] : schema , [string] : identifier , } , [string] : type , } ) [EOL] return cls . from_dict ( kwargs ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . __class__ . __name__ , self . render ( ) ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . render ( ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . render ( ) [EOL] [EOL] @ property def database ( self ) : [EOL] return self . path . database [EOL] [EOL] @ property def schema ( self ) : [EOL] return self . path . schema [EOL] [EOL] @ property def identifier ( self ) : [EOL] return self . path . identifier [EOL] [EOL] @ property def table ( self ) : [EOL] return self . path . identifier [EOL] [EOL] [comment] [EOL] @ property def name ( self ) : [EOL] return self . identifier [EOL] [EOL] @ property def is_table ( self ) : [EOL] return self . type == RelationType . Table [EOL] [EOL] @ property def is_cte ( self ) : [EOL] return self . type == RelationType . CTE [EOL] [EOL] @ property def is_view ( self ) : [EOL] return self . type == RelationType . View [EOL] [EOL] @ classproperty def Table ( cls ) : [EOL] return str ( RelationType . Table ) [EOL] [EOL] @ classproperty def CTE ( cls ) : [EOL] return str ( RelationType . CTE ) [EOL] [EOL] @ classproperty def View ( cls ) : [EOL] return str ( RelationType . View ) [EOL] [EOL] @ classproperty def External ( cls ) : [EOL] return str ( RelationType . External ) [EOL] [EOL] @ classproperty def get_relation_type ( cls ) : [EOL] return RelationType [EOL] [EOL] [EOL] Info = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True , eq = False , repr = False ) class InformationSchema ( BaseRelation ) : [EOL] information_schema_view = None [EOL] [EOL] def __post_init__ ( self ) : [EOL] if not isinstance ( self . information_schema_view , ( type ( None ) , str ) ) : [EOL] raise dbt . exceptions . CompilationException ( [string] . format ( self . information_schema_view ) ) [EOL] [EOL] @ classmethod def get_path ( cls , relation , information_schema_view ) : [EOL] return Path ( database = relation . database , schema = relation . schema , identifier = [string] , ) [EOL] [EOL] @ classmethod def get_include_policy ( cls , relation , information_schema_view , ) : [EOL] return relation . include_policy . replace ( database = relation . database is not None , schema = False , identifier = True , ) [EOL] [EOL] @ classmethod def get_quote_policy ( cls , relation , information_schema_view , ) : [EOL] return relation . quote_policy . replace ( identifier = False , ) [EOL] [EOL] @ classmethod def from_relation ( cls , relation , information_schema_view , ) : [EOL] include_policy = cls . get_include_policy ( relation , information_schema_view ) [EOL] quote_policy = cls . get_quote_policy ( relation , information_schema_view ) [EOL] path = cls . get_path ( relation , information_schema_view ) [EOL] return cls ( type = RelationType . View , path = path , include_policy = include_policy , quote_policy = quote_policy , information_schema_view = information_schema_view , ) [EOL] [EOL] def _render_iterator ( self ) : [EOL] for k , v in super ( ) . _render_iterator ( ) : [EOL] yield k , v [EOL] yield None , self . information_schema_view [EOL] [EOL] [EOL] class SchemaSearchMap ( Dict [ InformationSchema , Set [ Optional [ str ] ] ] ) : [EOL] [docstring] [EOL] def add ( self , relation ) : [EOL] key = relation . information_schema_only ( ) [EOL] if key not in self : [EOL] self [ key ] = set ( ) [EOL] schema = None [EOL] if relation . schema is not None : [EOL] schema = relation . schema . lower ( ) [EOL] self [ key ] . add ( schema ) [EOL] [EOL] def search ( self ) : [EOL] for information_schema_name , schemas in self . items ( ) : [EOL] for schema in schemas : [EOL] yield information_schema_name , schema [EOL] [EOL] def flatten ( self ) : [EOL] new = self . __class__ ( ) [EOL] [EOL] [comment] [EOL] seen = { r . database . lower ( ) for r in self if r . database } [EOL] if len ( seen ) > [number] : [EOL] dbt . exceptions . raise_compiler_error ( str ( seen ) ) [EOL] [EOL] for information_schema_name , schema in self . search ( ) : [EOL] path = { [string] : information_schema_name . database , [string] : schema } [EOL] new . add ( information_schema_name . incorporate ( path = path , quote_policy = { [string] : False } , include_policy = { [string] : False } , ) ) [EOL] [EOL] return new [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[dbt.contracts.relation.RelationType]$ 0 0 0 $dbt.contracts.relation.Path$ 0 0 0 $builtins.str$ 0 0 0 $dbt.contracts.relation.Policy$ 0 0 0 0 0 $dbt.contracts.relation.Policy$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $dbt.contracts.relation.ComponentName$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.relation.ComponentName$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.relation.ComponentName$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.relation.ComponentName$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.relation.Policy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.relation.Policy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $core.dbt.adapters.base.relation.BaseRelation$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $core.dbt.adapters.base.relation.BaseRelation$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Self$ 0 $Self$ 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 $typing.Any$ 0 $Self$ 0 0 0 0 0 $typing.Any$ 0 0 0 $Self$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $Self$ 0 $Self$ 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 $typing.Any$ 0 $Self$ 0 0 0 0 0 $typing.Any$ 0 0 0 $Self$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $'InformationSchema'$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $core.dbt.adapters.base.relation.InformationSchema$ 0 0 0 0 0 0 0 $None$ 0 0 0 $core.dbt.adapters.base.relation.InformationSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'InformationSchema'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'BaseRelation'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[typing.Optional[dbt.contracts.relation.ComponentName],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Self$ 0 $typing.Type[Self]$ 0 $dbt.contracts.graph.parsed.ParsedSourceDefinition$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $dbt.contracts.graph.parsed.ParsedSourceDefinition$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Type[Self]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[Self]$ 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedSourceDefinition$ 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedSourceDefinition$ 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedSourceDefinition$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $Self$ 0 $typing.Type[Self]$ 0 $dbt.contracts.relation.HasQuoting$ 0 $typing.Union[dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.compiled.CompiledNode]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[Self]$ 0 0 0 $typing.Union[dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.compiled.CompiledNode]$ 0 0 0 0 0 $typing.Type[Self]$ 0 0 0 0 0 $typing.Type[Self]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $Self$ 0 $typing.Type[Self]$ 0 $dbt.contracts.relation.HasQuoting$ 0 $typing.Union[dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.compiled.CompiledNode]$ 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 $dbt.contracts.relation.HasQuoting$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 $typing.Type[Self]$ 0 0 0 0 0 $typing.Union[dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.compiled.CompiledNode]$ 0 0 0 0 0 $typing.Union[dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.compiled.CompiledNode]$ 0 0 0 0 0 $typing.Union[dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.compiled.CompiledNode]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 $typing.Optional[typing.Dict[builtins.str,builtins.bool]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $Self$ 0 $typing.Type[Self]$ 0 $dbt.contracts.relation.HasQuoting$ 0 $typing.Union[dbt.contracts.graph.compiled.CompiledNode,dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.parsed.ParsedSourceDefinition]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Union[dbt.contracts.graph.compiled.CompiledNode,dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.parsed.ParsedSourceDefinition]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[dbt.contracts.graph.compiled.CompiledNode,dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.parsed.ParsedSourceDefinition]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[dbt.contracts.graph.compiled.CompiledNode,dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.parsed.ParsedSourceDefinition]$ 0 0 0 0 0 $typing.Type[Self]$ 0 0 0 $typing.Union[dbt.contracts.graph.compiled.CompiledNode,dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.parsed.ParsedSourceDefinition]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Union[dbt.contracts.graph.compiled.CompiledNode,dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.parsed.ParsedSourceDefinition]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[dbt.contracts.graph.compiled.CompiledNode,dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.parsed.ParsedSourceDefinition]$ 0 0 0 0 0 $typing.Type[Self]$ 0 0 0 $dbt.contracts.relation.HasQuoting$ 0 $typing.Union[dbt.contracts.graph.compiled.CompiledNode,dbt.contracts.graph.parsed.ParsedNode,dbt.contracts.graph.parsed.ParsedSourceDefinition]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $Self$ 0 $typing.Type[Self]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[dbt.contracts.relation.RelationType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[dbt.contracts.relation.RelationType]$ 0 0 0 0 0 $typing.Type[Self]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[dbt.contracts.relation.RelationType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.relation.Path$ 0 0 0 $BaseRelation$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $BaseRelation$ 0 0 0 0 0 $BaseRelation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.relation.Policy$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.relation.Policy$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Info$ 0 $typing.Type[Info]$ 0 $BaseRelation$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Type[Info]$ 0 0 0 $BaseRelation$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Type[Info]$ 0 0 0 $BaseRelation$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Type[Info]$ 0 0 0 $BaseRelation$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Type[Info]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BaseRelation$ 0 0 0 $core.dbt.adapters.base.relation.InformationSchema$ 0 $BaseRelation$ 0 0 0 0 0 0 $core.dbt.adapters.base.relation.InformationSchema$ 0 0 0 0 0 0 0 $core.dbt.adapters.base.relation.InformationSchema$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $BaseRelation$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $BaseRelation$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $core.dbt.adapters.base.relation.InformationSchema$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Iterator[typing.Tuple[InformationSchema,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.adapters.base.relation.SchemaSearchMap$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.adapters.base.relation.SchemaSearchMap$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.adapters.base.relation.SchemaSearchMap$ 0
[comment] [EOL] [EOL] [comment] [EOL] from dbt . contracts . connection import Credentials [comment] [EOL] from dbt . adapters . base . meta import available [comment] [EOL] from dbt . adapters . base . connections import BaseConnectionManager [comment] [EOL] from dbt . adapters . base . relation import ( BaseRelation , RelationType , SchemaSearchMap , ) [EOL] from dbt . adapters . base . column import Column [comment] [EOL] from dbt . adapters . base . impl import AdapterConfig , BaseAdapter [comment] [EOL] from dbt . adapters . base . plugin import AdapterPlugin [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , Dict , Optional , Type [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import abc [EOL] from functools import wraps [EOL] from typing import Callable , Optional , Any , FrozenSet , Dict , Set [EOL] [EOL] from dbt . deprecations import warn , renamed_method [EOL] [EOL] [EOL] Decorator = Callable [ [ Any ] , Callable ] [EOL] [EOL] [EOL] class _Available : [EOL] def __call__ ( self , func ) : [EOL] func . _is_available_ = True [comment] [EOL] return func [EOL] [EOL] def parse ( self , parse_replacement ) : [EOL] [docstring] [EOL] def inner ( func ) : [EOL] func . _parse_replacement_ = parse_replacement [EOL] return self ( func ) [EOL] return inner [EOL] [EOL] def deprecated ( self , supported_name , parse_replacement = None ) : [EOL] [docstring] [EOL] def wrapper ( func ) : [EOL] func_name = func . __name__ [EOL] renamed_method ( func_name , supported_name ) [EOL] [EOL] @ wraps ( func ) def inner ( * args , ** kwargs ) : [EOL] warn ( [string] . format ( func_name ) ) [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] if parse_replacement : [EOL] available_function = self . parse ( parse_replacement ) [EOL] else : [EOL] available_function = self [EOL] return available_function ( inner ) [EOL] return wrapper [EOL] [EOL] def parse_none ( self , func ) : [EOL] wrapper = self . parse ( lambda * a , ** k : None ) [EOL] return wrapper ( func ) [EOL] [EOL] def parse_list ( self , func ) : [EOL] wrapper = self . parse ( lambda * a , ** k : [ ] ) [EOL] return wrapper ( func ) [EOL] [EOL] [EOL] available = _Available ( ) [EOL] [EOL] [EOL] class AdapterMeta ( abc . ABCMeta ) : [EOL] _available_ = ... [EOL] _parse_replacements_ = ... [EOL] [EOL] def __new__ ( mcls , name , bases , namespace , ** kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cls = abc . ABCMeta . __new__ ( mcls , name , bases , namespace , ** kwargs ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] available = set ( ) [EOL] replacements = { } [EOL] [EOL] [comment] [EOL] for base in bases : [EOL] available . update ( getattr ( base , [string] , set ( ) ) ) [EOL] replacements . update ( getattr ( base , [string] , set ( ) ) ) [EOL] [EOL] [comment] [EOL] for name , value in namespace . items ( ) : [EOL] if getattr ( value , [string] , False ) : [EOL] available . add ( name ) [EOL] parse_replacement = getattr ( value , [string] , None ) [EOL] if parse_replacement is not None : [EOL] replacements [ name ] = parse_replacement [EOL] [EOL] cls . _available_ = frozenset ( available ) [EOL] [comment] [EOL] cls . _parse_replacements_ = replacements [EOL] return cls [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 $typing.Callable$ 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 $Decorator$ 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Decorator$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Callable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.adapters.base.meta._Available$ 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.adapters.base.meta._Available$ 0 0 0 0 $core.dbt.adapters.base.meta._Available$ 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 $typing.Callable$ 0 0 0 $typing.Callable[[typing.Any],typing.Callable[...,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],typing.Callable[...,typing.Any]]$ 0 $typing.Callable$ 0 0 0 0 $typing.Callable$ 0 0 0 $typing.Callable$ 0 0 0 $typing.Callable[[typing.Any],typing.Callable[...,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],typing.Callable[...,typing.Any]]$ 0 $typing.Callable$ 0 0 0 0 $core.dbt.adapters.base.meta._Available$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Callable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Type[typing.Any]$ 0
from typing import Any , Iterable , List , Optional , Dict , Tuple [EOL] import dbt [EOL] import agate [EOL] import builtins [EOL] import typing [EOL] import abc [EOL] import time [EOL] from typing import List , Optional , Tuple , Any , Iterable , Dict [EOL] [EOL] import agate [EOL] [EOL] import dbt . clients . agate_helper [EOL] import dbt . exceptions [EOL] from dbt . adapters . base import BaseConnectionManager [EOL] from dbt . contracts . connection import Connection , ConnectionState [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt import flags [EOL] [EOL] [EOL] class SQLConnectionManager ( BaseConnectionManager ) : [EOL] [docstring] [EOL] @ abc . abstractmethod def cancel ( self , connection ) : [EOL] [docstring] [EOL] raise dbt . exceptions . NotImplementedException ( [string] ) [EOL] [EOL] def cancel_open ( self ) : [EOL] names = [ ] [EOL] this_connection = self . get_if_exists ( ) [EOL] with self . lock : [EOL] for connection in self . thread_connections . values ( ) : [EOL] if connection is this_connection : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( connection . handle is not None and connection . state == ConnectionState . OPEN ) : [EOL] self . cancel ( connection ) [EOL] if connection . name is not None : [EOL] names . append ( connection . name ) [EOL] return names [EOL] [EOL] def add_query ( self , sql , auto_begin = True , bindings = None , abridge_sql_log = False ) : [EOL] connection = self . get_thread_connection ( ) [EOL] if auto_begin and connection . transaction_open is False : [EOL] self . begin ( ) [EOL] [EOL] logger . debug ( [string] . format ( self . TYPE , connection . name ) ) [EOL] [EOL] with self . exception_handler ( sql ) : [EOL] if abridge_sql_log : [EOL] log_sql = [string] . format ( sql [ : [number] ] ) [EOL] else : [EOL] log_sql = sql [EOL] [EOL] logger . debug ( [string] , connection_name = connection . name , sql = log_sql , ) [EOL] pre = time . time ( ) [EOL] [EOL] cursor = connection . handle . cursor ( ) [EOL] cursor . execute ( sql , bindings ) [EOL] [EOL] logger . debug ( [string] , status = self . get_status ( cursor ) , elapsed = ( time . time ( ) - pre ) ) [EOL] [EOL] return connection , cursor [EOL] [EOL] @ abc . abstractclassmethod def get_status ( cls , cursor ) : [EOL] [docstring] [EOL] raise dbt . exceptions . NotImplementedException ( [string] ) [EOL] [EOL] @ classmethod def process_results ( cls , column_names , rows ) : [EOL] [EOL] return [ dict ( zip ( column_names , row ) ) for row in rows ] [EOL] [EOL] @ classmethod def get_result_from_cursor ( cls , cursor ) : [EOL] data = [ ] [EOL] column_names = [ ] [EOL] [EOL] if cursor . description is not None : [EOL] column_names = [ col [ [number] ] for col in cursor . description ] [EOL] rows = cursor . fetchall ( ) [EOL] data = cls . process_results ( column_names , rows ) [EOL] [EOL] return dbt . clients . agate_helper . table_from_data_flat ( data , column_names ) [EOL] [EOL] def execute ( self , sql , auto_begin = False , fetch = False ) : [EOL] sql = self . _add_query_comment ( sql ) [EOL] _ , cursor = self . add_query ( sql , auto_begin ) [EOL] status = self . get_status ( cursor ) [EOL] if fetch : [EOL] table = self . get_result_from_cursor ( cursor ) [EOL] else : [EOL] table = dbt . clients . agate_helper . empty_table ( ) [EOL] return status , table [EOL] [EOL] def add_begin_query ( self ) : [EOL] return self . add_query ( [string] , auto_begin = False ) [EOL] [EOL] def add_commit_query ( self ) : [EOL] return self . add_query ( [string] , auto_begin = False ) [EOL] [EOL] def begin ( self ) : [EOL] connection = self . get_thread_connection ( ) [EOL] [EOL] if flags . STRICT_MODE : [EOL] if not isinstance ( connection , Connection ) : [EOL] raise dbt . exceptions . CompilerException ( f' [string] { connection } [string] ' ) [EOL] [EOL] if connection . transaction_open is True : [EOL] raise dbt . exceptions . InternalException ( [string] [string] . format ( connection . name ) ) [EOL] [EOL] self . add_begin_query ( ) [EOL] [EOL] connection . transaction_open = True [EOL] return connection [EOL] [EOL] def commit ( self ) : [EOL] connection = self . get_thread_connection ( ) [EOL] if flags . STRICT_MODE : [EOL] if not isinstance ( connection , Connection ) : [EOL] raise dbt . exceptions . CompilerException ( f' [string] { connection } [string] ' ) [EOL] [EOL] if connection . transaction_open is False : [EOL] raise dbt . exceptions . InternalException ( [string] [string] . format ( connection . name ) ) [EOL] [EOL] logger . debug ( [string] . format ( connection . name ) ) [EOL] self . add_commit_query ( ) [EOL] [EOL] connection . transaction_open = False [EOL] [EOL] return connection [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Tuple[dbt.contracts.connection.Connection,typing.Any]$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Iterable[builtins.str]$ 0 $typing.Iterable[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 $typing.Iterable[typing.Any]$ 0 0 0 0 0 0 $agate.Table$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Tuple[builtins.str,agate.Table]$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] from dbt . adapters . sql . connections import SQLConnectionManager [comment] [EOL] from dbt . adapters . sql . impl import SQLAdapter [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , Any [EOL] import dbt [EOL] import typing [EOL] from abc import abstractmethod [EOL] from typing import Generic , TypeVar [EOL] [EOL] import dbt . exceptions [EOL] from dbt . contracts . rpc import ( RemoteCompileResult , RemoteRunResult , ResultTable , ) [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt . task . compile import CompileRunner [EOL] from dbt . rpc . error import dbt_error , RPCException , server_error [EOL] [EOL] [EOL] RPCSQLResult = TypeVar ( [string] , bound = RemoteCompileResult ) [EOL] [EOL] [EOL] class GenericRPCRunner ( CompileRunner , Generic [ RPCSQLResult ] ) : [EOL] def __init__ ( self , config , adapter , node , node_index , num_nodes ) : [EOL] CompileRunner . __init__ ( self , config , adapter , node , node_index , num_nodes ) [EOL] [EOL] def handle_exception ( self , e , ctx ) : [EOL] logger . debug ( [string] . format ( e ) , exc_info = True ) [EOL] if isinstance ( e , dbt . exceptions . Exception ) : [EOL] if isinstance ( e , dbt . exceptions . RuntimeException ) : [EOL] e . add_node ( ctx . node ) [EOL] return dbt_error ( e ) [EOL] elif isinstance ( e , RPCException ) : [EOL] return e [EOL] else : [EOL] return server_error ( e ) [EOL] [EOL] def before_execute ( self ) : [EOL] pass [EOL] [EOL] def after_execute ( self , result ) : [EOL] pass [EOL] [EOL] def compile ( self , manifest ) : [EOL] compiler = self . adapter . get_compiler ( ) [EOL] return compiler . compile_node ( self . node , manifest , { } , write = False ) [EOL] [EOL] @ abstractmethod def execute ( self , compiled_node , manifest ) : [EOL] pass [EOL] [EOL] @ abstractmethod def from_run_result ( self , result , start_time , timing_info ) : [EOL] pass [EOL] [EOL] def error_result ( self , node , error , start_time , timing_info ) : [EOL] raise error [EOL] [EOL] def ephemeral_result ( self , node , start_time , timing_info ) : [EOL] raise dbt . exceptions . NotImplementedException ( [string] ) [EOL] [EOL] [EOL] class RPCCompileRunner ( GenericRPCRunner [ RemoteCompileResult ] ) : [EOL] def execute ( self , compiled_node , manifest ) : [EOL] return RemoteCompileResult ( raw_sql = compiled_node . raw_sql , compiled_sql = compiled_node . injected_sql , node = compiled_node , timing = [ ] , logs = [ ] , ) [EOL] [EOL] def from_run_result ( self , result , start_time , timing_info ) : [EOL] return RemoteCompileResult ( raw_sql = result . raw_sql , compiled_sql = result . compiled_sql , node = result . node , timing = timing_info , logs = [ ] , ) [EOL] [EOL] [EOL] class RPCExecuteRunner ( GenericRPCRunner [ RemoteRunResult ] ) : [EOL] def execute ( self , compiled_node , manifest ) : [EOL] _ , execute_result = self . adapter . execute ( compiled_node . injected_sql , fetch = True ) [EOL] [EOL] table = ResultTable ( column_names = list ( execute_result . column_names ) , rows = [ list ( row ) for row in execute_result ] , ) [EOL] [EOL] return RemoteRunResult ( raw_sql = compiled_node . raw_sql , compiled_sql = compiled_node . injected_sql , node = compiled_node , table = table , timing = [ ] , logs = [ ] , ) [EOL] [EOL] def from_run_result ( self , result , start_time , timing_info ) : [EOL] return RemoteRunResult ( raw_sql = result . raw_sql , compiled_sql = result . compiled_sql , node = result . node , table = result . table , timing = timing_info , logs = [ ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RPCSQLResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RPCSQLResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteCompileResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteCompileResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteRunResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteRunResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import signal [EOL] from datetime import datetime [EOL] from typing import Type , Union , Any , List , Dict [EOL] [EOL] import dbt . exceptions [EOL] from dbt . contracts . rpc import ( TaskTags , StatusParameters , LastParse , GCParameters , GCResult , GetManifestResult , KillParameters , KillResult , KillResultStatus , PSParameters , TaskRow , PSResult , RemoteExecutionResult , RemoteRunResult , RemoteCompileResult , RemoteCatalogResults , RemoteEmptyResult , RemoteRunOperationResult , PollParameters , PollResult , PollInProgressResult , PollKilledResult , PollExecuteCompleteResult , PollGetManifestResult , PollRunCompleteResult , PollCompileCompleteResult , PollCatalogCompleteResult , PollRemoteEmptyCompleteResult , PollRunOperationCompleteResult , TaskHandlerState , TaskTiming , ) [EOL] from dbt . logger import LogMessage [EOL] from dbt . rpc . error import dbt_error , RPCException [EOL] from dbt . rpc . method import RemoteBuiltinMethod [EOL] from dbt . rpc . task_handler import RequestTaskHandler [EOL] [EOL] [EOL] class GC ( RemoteBuiltinMethod [ GCParameters , GCResult ] ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] super ( ) . set_args ( params ) [EOL] [EOL] def handle_request ( self ) : [EOL] if self . params is None : [EOL] raise dbt . exceptions . InternalException ( [string] ) [EOL] return self . task_manager . gc_safe ( task_ids = self . params . task_ids , before = self . params . before , settings = self . params . settings , ) [EOL] [EOL] [EOL] class Kill ( RemoteBuiltinMethod [ KillParameters , KillResult ] ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] super ( ) . set_args ( params ) [EOL] [EOL] def handle_request ( self ) : [EOL] if self . params is None : [EOL] raise dbt . exceptions . InternalException ( [string] ) [EOL] result = KillResult ( ) [EOL] task = ... [EOL] try : [EOL] task = self . task_manager . get_request ( self . params . task_id ) [EOL] except dbt . exceptions . UnknownAsyncIDException : [EOL] [comment] [EOL] return result [EOL] [EOL] result . state = KillResultStatus . NotStarted [EOL] [EOL] if task . process is None : [EOL] return result [EOL] pid = task . process . pid [EOL] if pid is None : [EOL] return result [EOL] [EOL] if task . process . is_alive ( ) : [EOL] result . state = KillResultStatus . Killed [EOL] task . ended = datetime . utcnow ( ) [EOL] os . kill ( pid , signal . SIGINT ) [EOL] task . state = TaskHandlerState . Killed [EOL] else : [EOL] result . state = KillResultStatus . Finished [EOL] [comment] [EOL] [EOL] return result [EOL] [EOL] [EOL] class Status ( RemoteBuiltinMethod [ StatusParameters , LastParse ] ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] super ( ) . set_args ( params ) [EOL] [EOL] def handle_request ( self ) : [EOL] return self . task_manager . last_parse [EOL] [EOL] [EOL] class PS ( RemoteBuiltinMethod [ PSParameters , PSResult ] ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] super ( ) . set_args ( params ) [EOL] [EOL] def keep ( self , row ) : [EOL] if self . params is None : [EOL] raise dbt . exceptions . InternalException ( [string] ) [EOL] if row . state . finished and self . params . completed : [EOL] return True [EOL] elif not row . state . finished and self . params . active : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] def handle_request ( self ) : [EOL] rows = [ row for row in self . task_manager . task_table ( ) if self . keep ( row ) ] [EOL] rows . sort ( key = lambda r : ( r . state , r . start , r . method ) ) [EOL] result = PSResult ( rows = rows , logs = [ ] ) [EOL] return result [EOL] [EOL] [EOL] def poll_complete ( timing , result , tags , logs ) : [EOL] if timing . state not in ( TaskHandlerState . Success , TaskHandlerState . Failed ) : [EOL] raise dbt . exceptions . InternalException ( f' [string] { timing . state }' ) [EOL] [EOL] cls = ... [EOL] [EOL] if isinstance ( result , RemoteExecutionResult ) : [EOL] cls = PollExecuteCompleteResult [EOL] [comment] [EOL] elif isinstance ( result , RemoteRunResult ) : [EOL] cls = PollRunCompleteResult [EOL] elif isinstance ( result , RemoteCompileResult ) : [EOL] cls = PollCompileCompleteResult [EOL] elif isinstance ( result , RemoteCatalogResults ) : [EOL] cls = PollCatalogCompleteResult [EOL] elif isinstance ( result , RemoteEmptyResult ) : [EOL] cls = PollRemoteEmptyCompleteResult [EOL] elif isinstance ( result , RemoteRunOperationResult ) : [EOL] cls = PollRunOperationCompleteResult [EOL] elif isinstance ( result , GetManifestResult ) : [EOL] cls = PollGetManifestResult [EOL] else : [EOL] raise dbt . exceptions . InternalException ( [string] . format ( result ) ) [EOL] return cls . from_result ( result , tags , timing , logs ) [EOL] [EOL] [EOL] def _dict_logs ( logs ) : [EOL] return [ log . to_dict ( ) for log in logs ] [EOL] [EOL] [EOL] class Poll ( RemoteBuiltinMethod [ PollParameters , PollResult ] ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] super ( ) . set_args ( params ) [EOL] [EOL] def handle_request ( self ) : [EOL] if self . params is None : [EOL] raise dbt . exceptions . InternalException ( [string] ) [EOL] task_id = self . params . request_token [EOL] task = self . task_manager . get_request ( task_id ) [EOL] [EOL] task_logs = [ ] [EOL] if self . params . logs : [EOL] task_logs = task . logs [ self . params . logs_start : ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] timing = task . make_task_timing ( datetime . utcnow ( ) ) [EOL] state = timing . state [EOL] if state <= TaskHandlerState . Running : [EOL] return PollInProgressResult ( tags = task . tags , logs = task_logs , state = timing . state , start = timing . start , end = timing . end , elapsed = timing . elapsed , ) [EOL] elif state == TaskHandlerState . Error : [EOL] err = task . error [EOL] if err is None : [EOL] exc = dbt . exceptions . InternalException ( f' [string] { task_id } [string] ' ) [EOL] raise RPCException . from_error ( dbt_error ( exc , logs = _dict_logs ( task_logs ) ) ) [EOL] [comment] [EOL] [comment] [EOL] raise err [EOL] elif state in ( TaskHandlerState . Success , TaskHandlerState . Failed ) : [EOL] [EOL] if task . result is None : [EOL] exc = dbt . exceptions . InternalException ( f' [string] { task_id } [string] { state } [string] ' [string] ) [EOL] raise RPCException . from_error ( dbt_error ( exc , logs = _dict_logs ( task_logs ) ) ) [EOL] return poll_complete ( timing = timing , result = task . result , tags = task . tags , logs = task_logs ) [EOL] elif state == TaskHandlerState . Killed : [EOL] return PollKilledResult ( tags = task . tags , logs = task_logs , state = timing . state , start = timing . start , end = timing . end , elapsed = timing . elapsed , ) [EOL] else : [EOL] exc = dbt . exceptions . InternalException ( f' [string] { state } [string] { task_id }' ) [EOL] raise RPCException . from_error ( dbt_error ( exc , logs = _dict_logs ( task_logs ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.GCParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.GCParameters$ 0 0 0 0 $dbt.contracts.rpc.GCResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.KillParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.KillParameters$ 0 0 0 0 $dbt.contracts.rpc.KillResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.StatusParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.StatusParameters$ 0 0 0 0 $dbt.contracts.rpc.LastParse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.PSParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.PSParameters$ 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.TaskRow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.TaskRow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.TaskRow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.PSResult$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $dbt.contracts.rpc.PollResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.PollParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.PollParameters$ 0 0 0 0 $dbt.contracts.rpc.PollResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.task_handler.RequestTaskHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.task_handler.RequestTaskHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.task_handler.RequestTaskHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.task_handler.RequestTaskHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.task_handler.RequestTaskHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.task_handler.RequestTaskHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.task_handler.RequestTaskHandler$ 0 0 0 0 0 $dbt.rpc.task_handler.RequestTaskHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.task_handler.RequestTaskHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Optional [EOL] import builtins [EOL] import core [EOL] import typing [EOL] from typing import List , Dict , Any , Optional [EOL] [EOL] from jsonrpc . exceptions import JSONRPCDispatchException , JSONRPCInvalidParams [EOL] [EOL] import dbt . exceptions [EOL] [EOL] [EOL] class RPCException ( JSONRPCDispatchException ) : [EOL] def __init__ ( self , code = None , message = None , data = None , logs = None , tags = None ) : [EOL] if code is None : [EOL] code = - [number] [EOL] if message is None : [EOL] message = [string] [EOL] if data is None : [EOL] data = { } [EOL] [EOL] super ( ) . __init__ ( code = code , message = message , data = data ) [EOL] if logs is not None : [EOL] self . logs = logs [EOL] self . error . data [ [string] ] = tags [EOL] [EOL] def __str__ ( self ) : [EOL] return ( [string] . format ( self . error , self ) ) [EOL] [EOL] @ property def logs ( self ) : [EOL] return self . error . data . get ( [string] ) [EOL] [EOL] @ logs . setter def logs ( self , value ) : [EOL] if value is None : [EOL] return [EOL] self . error . data [ [string] ] = value [EOL] [EOL] @ property def tags ( self ) : [EOL] return self . error . data . get ( [string] ) [EOL] [EOL] @ tags . setter def tags ( self , value ) : [EOL] if value is None : [EOL] return [EOL] self . error . data [ [string] ] = value [EOL] [EOL] @ classmethod def from_error ( cls , err ) : [EOL] return cls ( code = err . code , message = err . message , data = err . data , logs = err . data . get ( [string] ) , tags = err . data . get ( [string] ) , ) [EOL] [EOL] [EOL] def invalid_params ( data ) : [EOL] return RPCException ( code = JSONRPCInvalidParams . CODE , message = JSONRPCInvalidParams . MESSAGE , data = data ) [EOL] [EOL] [EOL] def server_error ( err , logs = None , tags = None ) : [EOL] exc = dbt . exceptions . Exception ( str ( err ) ) [EOL] return dbt_error ( exc , logs , tags ) [EOL] [EOL] [EOL] def timeout_error ( timeout_value , logs = None , tags = None ) : [EOL] exc = dbt . exceptions . RPCTimeoutException ( timeout_value ) [EOL] return dbt_error ( exc , logs , tags ) [EOL] [EOL] [EOL] def dbt_error ( exc , logs = None , tags = None ) : [EOL] exc = RPCException ( code = exc . CODE , message = exc . MESSAGE , data = exc . data ( ) , logs = logs , tags = tags ) [EOL] return exc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , List , Set , Optional , Tuple [EOL] import dbt [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] import operator [EOL] from datetime import datetime , timedelta [EOL] from typing import Optional , List , Iterable , Tuple [EOL] [EOL] import dbt . exceptions [EOL] from dbt . contracts . rpc import ( GCSettings , GCResultState , GCResult , TaskID , ) [EOL] from dbt . rpc . task_handler_protocol import TaskHandlerMap [EOL] [EOL] [comment] [EOL] from dbt import helper_types [comment] [EOL] [EOL] [EOL] class GarbageCollector : [EOL] def __init__ ( self , active_tasks , settings = None , ) : [EOL] self . active_tasks = active_tasks [EOL] self . settings = ... [EOL] [EOL] if settings is None : [EOL] self . settings = GCSettings ( maxsize = [number] , reapsize = [number] , auto_reap_age = timedelta ( days = [number] ) ) [EOL] else : [EOL] self . settings = settings [EOL] [EOL] def _remove_task_if_finished ( self , task_id ) : [EOL] [docstring] [EOL] if task_id not in self . active_tasks : [EOL] return GCResultState . Missing [EOL] [EOL] task = self . active_tasks [ task_id ] [EOL] if not task . state . finished : [EOL] return GCResultState . Running [EOL] [EOL] del self . active_tasks [ task_id ] [EOL] return GCResultState . Deleted [EOL] [EOL] def _get_before_list ( self , when ) : [EOL] removals = [ ] [EOL] for task in self . active_tasks . values ( ) : [EOL] if not task . state . finished : [EOL] continue [EOL] elif task . ended is None : [EOL] continue [EOL] elif task . ended < when : [EOL] removals . append ( task . task_id ) [EOL] [EOL] return removals [EOL] [EOL] def _get_oldest_ended_list ( self , num ) : [EOL] candidates = [ ] [EOL] for task in self . active_tasks . values ( ) : [EOL] if not task . state . finished : [EOL] continue [EOL] elif task . ended is None : [EOL] continue [EOL] else : [EOL] candidates . append ( ( task . ended , task . task_id ) ) [EOL] candidates . sort ( key = operator . itemgetter ( [number] ) ) [EOL] return [ task_id for _ , task_id in candidates [ : num ] ] [EOL] [EOL] def collect_task_id ( self , result , task_id ) : [EOL] [docstring] [EOL] try : [EOL] state = self . _remove_task_if_finished ( task_id ) [EOL] except KeyError : [EOL] [comment] [EOL] [comment] [EOL] raise dbt . exceptions . InternalException ( [string] . format ( task_id ) ) [EOL] [EOL] return result . add_result ( task_id = task_id , state = state ) [EOL] [EOL] def collect_multiple_task_ids ( self , task_ids ) : [EOL] result = GCResult ( ) [EOL] for task_id in task_ids : [EOL] self . collect_task_id ( result , task_id ) [EOL] return result [EOL] [EOL] def collect_as_required ( self ) : [EOL] to_remove = [ ] [EOL] num_tasks = len ( self . active_tasks ) [EOL] if num_tasks > self . settings . maxsize : [EOL] num = self . settings . maxsize - num_tasks [EOL] to_remove = self . _get_oldest_ended_list ( num ) [EOL] elif num_tasks > self . settings . reapsize : [EOL] before = datetime . utcnow ( ) - self . settings . auto_reap_age [EOL] to_remove = self . _get_before_list ( before ) [EOL] [EOL] if to_remove : [EOL] self . collect_multiple_task_ids ( to_remove ) [EOL] [EOL] def collect_selected ( self , task_ids = None , before = None , settings = None , ) : [EOL] to_gc = set ( ) [EOL] [EOL] if task_ids is not None : [EOL] to_gc . update ( task_ids ) [EOL] if settings : [EOL] self . settings = settings [EOL] [comment] [EOL] if before is not None : [EOL] to_gc . update ( self . _get_before_list ( before ) ) [EOL] return self . collect_multiple_task_ids ( to_gc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.GCResult$ 0 0 0 $typing.Optional[typing.List[dbt.contracts.rpc.TaskID]]$ 0 0 0 $typing.Optional[datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Optional[typing.List[dbt.contracts.rpc.TaskID]]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Optional[typing.List[dbt.contracts.rpc.TaskID]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime.datetime]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0
from typing import Dict , Any , Callable [EOL] import builtins [EOL] import core [EOL] import dbt [EOL] import jsonrpc [EOL] import werkzeug [EOL] import typing [EOL] import json [EOL] from typing import Callable , Dict , Any [EOL] [EOL] from hologram import JsonSchemaMixin [EOL] from jsonrpc . exceptions import ( JSONRPCParseError , JSONRPCInvalidRequestException , JSONRPCInvalidRequest , ) [EOL] from jsonrpc import JSONRPCResponseManager [EOL] from jsonrpc . jsonrpc import JSONRPCRequest [EOL] from jsonrpc . jsonrpc2 import JSONRPC20Request , JSONRPC20Response [EOL] from werkzeug import Request as HTTPRequest [EOL] [EOL] import dbt . exceptions [EOL] import dbt . tracking [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt . rpc . logger import RequestContext [EOL] from dbt . rpc . task_handler import RequestTaskHandler [EOL] from dbt . rpc . method import RemoteMethod [EOL] from dbt . rpc . task_manager import TaskManager [EOL] [EOL] [EOL] def track_rpc_request ( task ) : [EOL] dbt . tracking . track_rpc_request ( { [string] : task } ) [EOL] [EOL] [EOL] SYNCHRONOUS_REQUESTS = False [EOL] [EOL] [EOL] class RequestDispatcher ( Dict [ str , Callable [ ... , Dict [ str , Any ] ] ] ) : [EOL] [docstring] [EOL] def __init__ ( self , http_request , json_rpc_request , manager , ) : [EOL] self . http_request = http_request [EOL] self . json_rpc_request = json_rpc_request [EOL] self . manager = manager [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] handler = self . manager . get_handler ( key , self . http_request , self . json_rpc_request , ) [EOL] if handler is None : [EOL] raise KeyError ( key ) [EOL] if callable ( handler ) : [EOL] [comment] [EOL] return handler [EOL] elif isinstance ( handler , RemoteMethod ) : [EOL] [comment] [EOL] [comment] [EOL] return RequestTaskHandler ( self . manager , handler , self . http_request , self . json_rpc_request ) [EOL] else : [EOL] raise dbt . exceptions . InternalException ( f' [string] ' f' [string] { handler }' ) [EOL] [EOL] [EOL] class ResponseManager ( JSONRPCResponseManager ) : [EOL] [docstring] [EOL] @ classmethod def handle_valid_request ( cls , http_request , request , task_manager , ) : [EOL] with RequestContext ( request ) : [EOL] logger . info ( [string] . format ( request . method ) ) [EOL] track_rpc_request ( request . method ) [EOL] [EOL] dispatcher = RequestDispatcher ( http_request , request , task_manager ) [EOL] [EOL] return cls . handle_request ( request , dispatcher ) [EOL] [EOL] @ classmethod def _get_responses ( cls , requests , dispatcher ) : [EOL] for output in super ( ) . _get_responses ( requests , dispatcher ) : [EOL] [comment] [EOL] [comment] [EOL] if hasattr ( output , [string] ) : [EOL] if isinstance ( output . result , JsonSchemaMixin ) : [EOL] output . result = output . result . to_dict ( omit_none = False ) [EOL] yield output [EOL] [EOL] @ classmethod def handle ( cls , http_request , task_manager , ) : [EOL] request_str = ... [EOL] if isinstance ( http_request . data , bytes ) : [EOL] request_str = http_request . data . decode ( [string] ) [EOL] else : [EOL] request_str = http_request . data [EOL] [EOL] try : [EOL] data = json . loads ( request_str ) [EOL] except ( TypeError , ValueError ) : [EOL] return JSONRPC20Response ( error = dict ( code = JSONRPCParseError . CODE , message = JSONRPCParseError . MESSAGE , ) ) [EOL] [EOL] if data . get ( [string] , None ) != [string] : [EOL] return JSONRPC20Response ( error = dict ( code = JSONRPCInvalidRequest . CODE , message = JSONRPCInvalidRequest . MESSAGE , ) ) [EOL] [EOL] try : [EOL] request = JSONRPCRequest . from_data ( data ) [EOL] except ( ValueError , JSONRPCInvalidRequestException ) : [EOL] return JSONRPC20Response ( error = dict ( code = JSONRPCInvalidRequest . CODE , message = JSONRPCInvalidRequest . MESSAGE , ) ) [EOL] [EOL] if not isinstance ( request , JSONRPC20Request ) : [EOL] return JSONRPC20Response ( error = dict ( code = JSONRPCInvalidRequest . CODE , message = JSONRPCInvalidRequest . MESSAGE , ) ) [EOL] [EOL] result = cls . handle_valid_request ( http_request , request , task_manager ) [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Request$ 0 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Request$ 0 $werkzeug.wrappers.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jsonrpc.jsonrpc2.JSONRPC20Response$ 0 0 0 $werkzeug.Request$ 0 $jsonrpc.jsonrpc2.JSONRPC20Request$ 0 $dbt.rpc.task_manager.TaskManager$ 0 0 0 0 0 0 0 $jsonrpc.jsonrpc2.JSONRPC20Request$ 0 0 0 0 0 0 0 0 0 0 0 $jsonrpc.jsonrpc2.JSONRPC20Request$ 0 0 0 0 0 0 0 $jsonrpc.jsonrpc2.JSONRPC20Request$ 0 0 0 0 0 $core.dbt.rpc.response_manager.RequestDispatcher$ 0 0 0 $werkzeug.Request$ 0 $jsonrpc.jsonrpc2.JSONRPC20Request$ 0 $dbt.rpc.task_manager.TaskManager$ 0 0 0 0 0 0 0 0 $jsonrpc.jsonrpc2.JSONRPC20Request$ 0 $core.dbt.rpc.response_manager.RequestDispatcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jsonrpc.jsonrpc2.JSONRPC20Response$ 0 0 0 $werkzeug.Request$ 0 $dbt.rpc.task_manager.TaskManager$ 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.Request$ 0 $typing.Any$ 0 0 0 0 0 0 0 $werkzeug.Request$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.Request$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.Request$ 0 $typing.Any$ 0 $dbt.rpc.task_manager.TaskManager$ 0 0 0 0 0 0
from typing import Any , Callable , List , Set , Union , Dict , Optional , Type [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import uuid [EOL] import threading [EOL] import uuid [EOL] from datetime import datetime [EOL] from typing import ( Any , Dict , Optional , List , Union , Set , Callable , Type ) [EOL] [EOL] [EOL] import dbt . exceptions [EOL] import dbt . flags as flags [EOL] from dbt . adapters . factory import reset_adapters , register_adapter [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . rpc import ( LastParse , ManifestStatus , GCSettings , GCResult , TaskRow , TaskID , ) [EOL] from dbt . logger import LogMessage , list_handler [EOL] from dbt . perf_utils import get_full_manifest [EOL] from dbt . rpc . error import dbt_error [EOL] from dbt . rpc . gc import GarbageCollector [EOL] from dbt . rpc . task_handler_protocol import TaskHandlerProtocol , TaskHandlerMap [EOL] from dbt . rpc . task_handler import set_parse_state_with [EOL] from dbt . rpc . method import ( RemoteMethod , RemoteManifestMethod , RemoteBuiltinMethod , TaskTypes , ) [EOL] [comment] [EOL] import dbt . rpc . builtins [comment] [EOL] [EOL] [EOL] [comment] [EOL] from dbt import helper_types [comment] [EOL] [EOL] [EOL] WrappedHandler = Callable [ ... , Dict [ str , Any ] ] [EOL] [EOL] [EOL] class UnconditionalError : [EOL] def __init__ ( self , exception ) : [EOL] self . exception = dbt_error ( exception ) [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] raise self . exception [EOL] [EOL] [EOL] class ParseError ( UnconditionalError ) : [EOL] def __init__ ( self , parse_error ) : [EOL] exception = dbt . exceptions . RPCLoadException ( parse_error ) [EOL] super ( ) . __init__ ( exception ) [EOL] [EOL] [EOL] class CurrentlyCompiling ( UnconditionalError ) : [EOL] def __init__ ( self ) : [EOL] exception = dbt . exceptions . RPCCompiling ( [string] ) [EOL] super ( ) . __init__ ( exception ) [EOL] [EOL] [EOL] class ManifestReloader ( threading . Thread ) : [EOL] def __init__ ( self , task_manager ) : [EOL] super ( ) . __init__ ( ) [EOL] self . task_manager = task_manager [EOL] [EOL] def reload_manifest ( self ) : [EOL] logs = [ ] [EOL] with set_parse_state_with ( self . task_manager , lambda : logs ) : [EOL] with list_handler ( logs ) : [EOL] self . task_manager . parse_manifest ( ) [EOL] [EOL] def run ( self ) : [EOL] try : [EOL] self . reload_manifest ( ) [EOL] except Exception : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] class TaskManager : [EOL] def __init__ ( self , args , config , task_types ) : [EOL] self . args = args [EOL] self . config = config [EOL] self . manifest = None [EOL] self . _task_types = task_types [EOL] self . active_tasks = { } [EOL] self . gc = GarbageCollector ( active_tasks = self . active_tasks ) [EOL] self . last_parse = LastParse ( state = ManifestStatus . Init ) [EOL] self . _lock = flags . MP_CONTEXT . Lock ( ) [EOL] self . _reloader = None [EOL] self . reload_manifest ( ) [EOL] [EOL] def single_threaded ( self ) : [EOL] return flags . SINGLE_THREADED_WEBSERVER or self . args . single_threaded [EOL] [EOL] def _reload_task_manager_thread ( self , reloader ) : [EOL] [docstring] [EOL] [comment] [EOL] reloader . start ( ) [EOL] [comment] [EOL] self . _reloader = reloader [EOL] [EOL] def _reload_task_manager_fg ( self , reloader ) : [EOL] [docstring] [EOL] [comment] [EOL] reloader . reload_manifest ( ) [EOL] [EOL] def reload_manifest ( self ) : [EOL] [docstring] [EOL] if not self . set_parsing ( ) : [EOL] return False [EOL] if self . _reloader is not None : [EOL] [comment] [EOL] self . _reloader . join ( ) [EOL] [comment] [EOL] reloader = ManifestReloader ( self ) [EOL] if self . single_threaded ( ) : [EOL] self . _reload_task_manager_fg ( reloader ) [EOL] else : [EOL] self . _reload_task_manager_thread ( reloader ) [EOL] return True [EOL] [EOL] def reload_config ( self ) : [EOL] config = self . config . from_args ( self . args ) [EOL] self . config = config [EOL] reset_adapters ( ) [EOL] register_adapter ( config ) [EOL] return config [EOL] [EOL] def add_request ( self , request_handler ) : [EOL] self . active_tasks [ request_handler . task_id ] = request_handler [EOL] [EOL] def get_request ( self , task_id ) : [EOL] try : [EOL] return self . active_tasks [ task_id ] [EOL] except KeyError : [EOL] [comment] [EOL] raise dbt . exceptions . UnknownAsyncIDException ( task_id ) from None [EOL] [EOL] def _get_manifest_callable ( self , task ) : [EOL] state = self . last_parse . state [EOL] if state == ManifestStatus . Compiling : [EOL] return CurrentlyCompiling ( ) [EOL] elif state == ManifestStatus . Error : [EOL] return ParseError ( self . last_parse . error ) [EOL] else : [EOL] if self . manifest is None : [EOL] raise dbt . exceptions . InternalException ( f' [string] ' f'{ state }' ) [EOL] return task ( self . args , self . config , self . manifest ) [EOL] [EOL] def rpc_task ( self , method_name ) : [EOL] with self . _lock : [EOL] task = self . _task_types [ method_name ] [EOL] if issubclass ( task , RemoteBuiltinMethod ) : [EOL] return task ( self ) [EOL] elif issubclass ( task , RemoteManifestMethod ) : [EOL] return self . _get_manifest_callable ( task ) [EOL] elif issubclass ( task , RemoteMethod ) : [EOL] return task ( self . args , self . config ) [EOL] else : [EOL] raise dbt . exceptions . InternalException ( f' [string] { task } [string] ' f' [string] { method_name } [string] { task . __class__ } [string] ' f' [string] ' ) [EOL] [EOL] def ready ( self ) : [EOL] with self . _lock : [EOL] return self . last_parse . state == ManifestStatus . Ready [EOL] [EOL] def set_parsing ( self ) : [EOL] with self . _lock : [EOL] if self . last_parse . state == ManifestStatus . Compiling : [EOL] return False [EOL] self . last_parse = LastParse ( state = ManifestStatus . Compiling ) [EOL] return True [EOL] [EOL] def parse_manifest ( self ) : [EOL] self . manifest = get_full_manifest ( self . config , reset = True ) [EOL] [EOL] def set_compile_exception ( self , exc , logs = List [ LogMessage ] ) : [EOL] assert self . last_parse . state == ManifestStatus . Compiling , f' [string] { self . last_parse . state }' [EOL] self . last_parse = LastParse ( error = { [string] : str ( exc ) } , state = ManifestStatus . Error , logs = logs ) [EOL] [EOL] def set_ready ( self , logs = List [ LogMessage ] ) : [EOL] assert self . last_parse . state == ManifestStatus . Compiling , f' [string] { self . last_parse . state }' [EOL] self . last_parse = LastParse ( state = ManifestStatus . Ready , logs = logs ) [EOL] [EOL] def methods ( self ) : [EOL] with self . _lock : [EOL] return set ( self . _task_types ) [EOL] [EOL] def currently_compiling ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] raise dbt_error ( dbt . exceptions . RPCCompiling ( [string] ) ) [EOL] [EOL] def compilation_error ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] raise dbt_error ( dbt . exceptions . RPCLoadException ( self . last_parse . error ) ) [EOL] [EOL] def get_handler ( self , method , http_request , json_rpc_request ) : [EOL] [comment] [EOL] self . gc_as_required ( ) [EOL] [EOL] if method not in self . _task_types : [EOL] return None [EOL] [EOL] task = self . rpc_task ( method ) [EOL] [EOL] return task [EOL] [EOL] def task_table ( self ) : [EOL] rows = [ ] [EOL] now = datetime . utcnow ( ) [EOL] with self . _lock : [EOL] for task in self . active_tasks . values ( ) : [EOL] rows . append ( task . make_task_row ( now ) ) [EOL] return rows [EOL] [EOL] def gc_as_required ( self ) : [EOL] with self . _lock : [EOL] return self . gc . collect_as_required ( ) [EOL] [EOL] def gc_safe ( self , task_ids = None , before = None , settings = None , ) : [EOL] with self . _lock : [EOL] return self . gc . collect_selected ( task_ids = task_ids , before = before , settings = settings , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.GCResult$ 0 0 0 $typing.Optional[typing.List[uuid.UUID]]$ 0 0 0 $typing.Optional[datetime.datetime.datetime]$ 0 0 0 $typing.Optional[dbt.contracts.rpc.GCSettings]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[uuid.UUID]]$ 0 $typing.Optional[typing.List[uuid.UUID]]$ 0 $typing.Optional[datetime.datetime.datetime]$ 0 $typing.Optional[datetime.datetime.datetime]$ 0 $typing.Optional[dbt.contracts.rpc.GCSettings]$ 0 $typing.Optional[dbt.contracts.rpc.GCSettings]$ 0 0 0
[docstring] [EOL]	0 0
from typing import Type , Any , Optional [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import jsonrpc [EOL] import typing [EOL] import datetime [EOL] import logbook [EOL] import logbook [EOL] import logbook . queues [EOL] from jsonrpc . exceptions import JSONRPCError [EOL] from hologram import JsonSchemaMixin [EOL] from hologram . helpers import StrEnum [EOL] [EOL] from dataclasses import dataclass , field [EOL] from datetime import datetime , timedelta [EOL] from queue import Empty [EOL] from typing import Optional , Any [EOL] [EOL] from dbt . contracts . rpc import ( RemoteResult , ) [EOL] from dbt . exceptions import InternalException [EOL] from dbt . utils import restrict_to [EOL] [EOL] [EOL] class QueueMessageType ( StrEnum ) : [EOL] Error = [string] [EOL] Result = [string] [EOL] Timeout = [string] [EOL] Log = [string] [EOL] [EOL] terminating = frozenset ( ( Error , Result , Timeout ) ) [EOL] [EOL] [EOL] @ dataclass class QueueMessage ( JsonSchemaMixin ) : [EOL] message_type = ... [EOL] [EOL] [EOL] @ dataclass class QueueLogMessage ( QueueMessage ) : [EOL] message_type = field ( metadata = restrict_to ( QueueMessageType . Log ) ) [EOL] record = ... [EOL] [EOL] @ classmethod def from_record ( cls , record ) : [EOL] return QueueLogMessage ( message_type = QueueMessageType . Log , record = record , ) [EOL] [EOL] [EOL] @ dataclass class QueueErrorMessage ( QueueMessage ) : [EOL] message_type = field ( metadata = restrict_to ( QueueMessageType . Error ) ) [EOL] error = ... [EOL] [EOL] @ classmethod def from_error ( cls , error ) : [EOL] return QueueErrorMessage ( message_type = QueueMessageType . Error , error = error , ) [EOL] [EOL] [EOL] @ dataclass class QueueResultMessage ( QueueMessage ) : [EOL] message_type = field ( metadata = restrict_to ( QueueMessageType . Result ) ) [EOL] result = ... [EOL] [EOL] @ classmethod def from_result ( cls , result ) : [EOL] return cls ( message_type = QueueMessageType . Result , result = result , ) [EOL] [EOL] [EOL] @ dataclass class QueueTimeoutMessage ( QueueMessage ) : [EOL] message_type = field ( metadata = restrict_to ( QueueMessageType . Timeout ) , ) [EOL] [EOL] @ classmethod def create ( cls ) : [EOL] return cls ( message_type = QueueMessageType . Timeout ) [EOL] [EOL] [EOL] class QueueLogHandler ( logbook . queues . MultiProcessingHandler ) : [EOL] def emit ( self , record ) : [EOL] [comment] [EOL] record . pull_information ( ) [EOL] self . queue . put_nowait ( QueueLogMessage . from_record ( record ) ) [EOL] [EOL] def emit_error ( self , error ) : [EOL] self . queue . put_nowait ( QueueErrorMessage . from_error ( error ) ) [EOL] [EOL] def emit_result ( self , result ) : [EOL] self . queue . put_nowait ( QueueResultMessage . from_result ( result ) ) [EOL] [EOL] [EOL] def _next_timeout ( started , timeout , ) : [EOL] if timeout is None : [EOL] return None [EOL] [EOL] end = started + timedelta ( seconds = timeout ) [EOL] message_timeout = end - datetime . utcnow ( ) [EOL] return message_timeout . total_seconds ( ) [EOL] [EOL] [EOL] class QueueSubscriber ( logbook . queues . MultiProcessingSubscriber ) : [EOL] def _recv_raw ( self , timeout ) : [EOL] if timeout is None : [EOL] return self . queue . get ( ) [EOL] [EOL] if timeout < [number] : [EOL] return QueueTimeoutMessage . create ( ) [EOL] [EOL] try : [EOL] return self . queue . get ( block = True , timeout = timeout ) [EOL] except Empty : [EOL] return QueueTimeoutMessage . create ( ) [EOL] [EOL] def recv ( self , timeout = None ) : [EOL] [docstring] [EOL] rv = self . _recv_raw ( timeout ) [EOL] if not isinstance ( rv , QueueMessage ) : [EOL] raise InternalException ( [string] . format ( rv ) ) [EOL] return rv [EOL] [EOL] def handle_message ( self , timeout ) : [EOL] msg = self . recv ( timeout ) [EOL] if isinstance ( msg , QueueLogMessage ) : [EOL] logbook . dispatch_record ( msg . record ) [EOL] return msg [EOL] elif msg . message_type in QueueMessageType . terminating : [EOL] return msg [EOL] else : [EOL] raise InternalException ( [string] . format ( msg . message_type ) ) [EOL] [EOL] def dispatch_until_exit ( self , started , timeout = None ) : [EOL] while True : [EOL] message_timeout = _next_timeout ( started , timeout ) [EOL] msg = self . handle_message ( message_timeout ) [EOL] if msg . message_type in QueueMessageType . terminating : [EOL] return msg [EOL] [EOL] [EOL] [comment] [EOL] class ServerContext ( logbook . Processor ) : [EOL] def process ( self , record ) : [EOL] [comment] [EOL] [comment] [EOL] if not record . extra [ [string] ] : [EOL] record . extra [ [string] ] = [string] [EOL] [EOL] [EOL] class HTTPRequest ( logbook . Processor ) : [EOL] def __init__ ( self , request ) : [EOL] self . request = request [EOL] [EOL] def process ( self , record ) : [EOL] record . extra [ [string] ] = self . request . remote_addr [EOL] record . extra [ [string] ] = self . request . method [EOL] [EOL] [EOL] class RPCRequest ( logbook . Processor ) : [EOL] def __init__ ( self , request ) : [EOL] self . request = request [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] record . extra [ [string] ] = self . request . _id [EOL] record . extra [ [string] ] = self . request . method [EOL] [EOL] [EOL] class RPCResponse ( logbook . Processor ) : [EOL] def __init__ ( self , response ) : [EOL] self . response = response [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def process ( self , record ) : [EOL] record . extra [ [string] ] = [number] [EOL] [comment] [EOL] record . extra [ [string] ] = getattr ( self . response . request , [string] , None ) [EOL] [EOL] [EOL] class RequestContext ( RPCRequest ) : [EOL] def process ( self , record ) : [EOL] super ( ) . process ( record ) [EOL] record . extra [ [string] ] = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $QueueMessageType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logbook.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jsonrpc.exceptions.JSONRPCError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $QueueMessageType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logbook.LogRecord$ 0 0 0 0 0 $logbook.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logbook.LogRecord$ 0 0 0 0 0 0 0 0 0 $jsonrpc.exceptions.JSONRPCError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $jsonrpc.exceptions.JSONRPCError$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $QueueMessage$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $QueueMessage$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 0 0 0 0 0 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 0 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 0 0 0 0 0 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 0 0 0 0 0 $QueueMessage$ 0 0 0 $datetime.datetime.datetime$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $datetime.datetime.datetime$ 0 $typing.Optional[builtins.float]$ 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 0 0 0 0 0 0 0 $core.dbt.rpc.logger.QueueMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , Callable , List , Set , Type , TypeVar , Iterator [EOL] import core [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from dataclasses import dataclass [EOL] from typing import ( List , Callable , Iterable , Set , Union , Iterator , TypeVar , Generic ) [EOL] [EOL] from dbt . clients . jinja import extract_toplevel_blocks , BlockTag [EOL] from dbt . clients . system import find_matching [EOL] from dbt . config import Project [EOL] from dbt . contracts . files import SourceFile , FilePath [EOL] from dbt . exceptions import CompilationException , InternalException [EOL] [EOL] [EOL] @ dataclass class FileBlock : [EOL] file = ... [EOL] [EOL] @ property def name ( self ) : [EOL] base = os . path . basename ( self . file . path . relative_path ) [EOL] name , _ = os . path . splitext ( base ) [EOL] return name [EOL] [EOL] @ property def contents ( self ) : [EOL] return self . file . contents [EOL] [EOL] @ property def path ( self ) : [EOL] return self . file . path [EOL] [EOL] [EOL] @ dataclass class BlockContents ( FileBlock ) : [EOL] file = ... [comment] [EOL] block = ... [EOL] [EOL] @ property def name ( self ) : [EOL] return self . block . block_name [EOL] [EOL] @ property def contents ( self ) : [EOL] return self . block . contents [EOL] [EOL] [EOL] @ dataclass class FullBlock ( FileBlock ) : [EOL] file = ... [comment] [EOL] block = ... [EOL] [EOL] @ property def name ( self ) : [EOL] return self . block . block_name [EOL] [EOL] @ property def contents ( self ) : [EOL] return self . block . full_block [EOL] [EOL] [EOL] class FilesystemSearcher ( Iterable [ FilePath ] ) : [EOL] def __init__ ( self , project , relative_dirs , extension ) : [EOL] self . project = project [EOL] self . relative_dirs = relative_dirs [EOL] self . extension = extension [EOL] [EOL] def __iter__ ( self ) : [EOL] ext = [string] + self . extension [EOL] [EOL] root = self . project . project_root [EOL] [EOL] for result in find_matching ( root , self . relative_dirs , ext ) : [EOL] if [string] not in result or [string] not in result : [EOL] raise InternalException ( [string] . format ( result ) ) [EOL] file_match = FilePath ( searched_path = result [ [string] ] , relative_path = result [ [string] ] , project_root = root , ) [EOL] yield file_match [EOL] [EOL] [EOL] Block = Union [ BlockContents , FullBlock ] [EOL] [EOL] BlockSearchResult = TypeVar ( [string] , BlockContents , FullBlock ) [EOL] [EOL] BlockSearchResultFactory = Callable [ [ SourceFile , BlockTag ] , BlockSearchResult ] [EOL] [EOL] [EOL] class BlockSearcher ( Generic [ BlockSearchResult ] , Iterable [ BlockSearchResult ] ) : [EOL] def __init__ ( self , source , allowed_blocks , source_tag_factory ) : [EOL] self . source = source [EOL] self . allowed_blocks = allowed_blocks [EOL] self . source_tag_factory = source_tag_factory [EOL] [EOL] def extract_blocks ( self , source_file ) : [EOL] try : [EOL] blocks = extract_toplevel_blocks ( source_file . contents , allowed_blocks = self . allowed_blocks , collect_raw_data = False ) [EOL] [comment] [EOL] for block in blocks : [EOL] assert isinstance ( block , BlockTag ) [EOL] yield block [EOL] [EOL] except CompilationException as exc : [EOL] if exc . node is None : [EOL] exc . add_node ( source_file ) [EOL] raise [EOL] [EOL] def __iter__ ( self ) : [EOL] for entry in self . source : [EOL] for block in self . extract_blocks ( entry ) : [EOL] yield self . source_tag_factory ( entry . file , block ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 $dbt.clients.jinja.BlockTag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 $dbt.clients.jinja.BlockTag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Iterator[dbt.contracts.files.FilePath]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[core.dbt.parser.search.FileBlock]$ 0 $typing.Set[builtins.str]$ 0 $BlockSearchResultFactory$ 0 0 0 0 0 $typing.List[core.dbt.parser.search.FileBlock]$ 0 $typing.List[core.dbt.parser.search.FileBlock]$ 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 $BlockSearchResultFactory$ 0 $BlockSearchResultFactory$ 0 0 0 $typing.Iterable[dbt.clients.jinja.BlockTag]$ 0 0 0 $FileBlock$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FileBlock$ 0 0 0 0 0 0 $typing.Iterator[BlockSearchResult]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import dbt [EOL] from dbt . context . context_config import ContextConfig [EOL] from dbt . contracts . files import SourceFile , FilePath [EOL] from dbt . contracts . graph . parsed import ParsedSeedNode [EOL] from dbt . node_types import NodeType [EOL] from dbt . parser . base import SimpleSQLParser [EOL] from dbt . parser . search import FileBlock , FilesystemSearcher [EOL] [EOL] [EOL] class SeedParser ( SimpleSQLParser [ ParsedSeedNode ] ) : [EOL] def get_paths ( self ) : [EOL] return FilesystemSearcher ( self . project , self . project . data_paths , [string] ) [EOL] [EOL] def parse_from_dict ( self , dct , validate = True ) : [EOL] return ParsedSeedNode . from_dict ( dct , validate = validate ) [EOL] [EOL] @ property def resource_type ( self ) : [EOL] return NodeType . Seed [EOL] [EOL] @ classmethod def get_compiled_path ( cls , block ) : [EOL] return block . path . relative_path [EOL] [EOL] def render_with_context ( self , parsed_node , config ) : [EOL] [docstring] [EOL] [EOL] def load_file ( self , match , * , set_contents = False ) : [EOL] if match . seed_too_large ( ) : [EOL] [comment] [EOL] return SourceFile . big_seed ( match ) [EOL] else : [EOL] [comment] [EOL] return super ( ) . load_file ( match , set_contents = set_contents ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedSeedNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.graph.parsed.ParsedSeedNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 $dbt.contracts.files.FilePath$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $dbt.contracts.files.FilePath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.FilePath$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.FilePath$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0
from typing import Any , TypeVar , List , Dict , Optional , Type , Tuple [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import hashlib [EOL] import re [EOL] from copy import deepcopy [EOL] from dataclasses import dataclass [EOL] from typing import ( Generic , TypeVar , Dict , Any , Tuple , Optional , List , ) [EOL] [EOL] from dbt . clients . jinja import get_rendered , SCHEMA_TEST_KWARGS_NAME [EOL] from dbt . contracts . graph . parsed import UnpatchedSourceDefinition [EOL] from dbt . contracts . graph . unparsed import ( TestDef , UnparsedAnalysisUpdate , UnparsedMacroUpdate , UnparsedNodeUpdate , UnparsedReport , ) [EOL] from dbt . exceptions import raise_compiler_error [EOL] from dbt . parser . search import FileBlock [EOL] [EOL] [EOL] def get_nice_schema_test_name ( test_type , test_name , args ) : [EOL] flat_args = [ ] [EOL] for arg_name in sorted ( args ) : [EOL] [comment] [EOL] if arg_name == [string] : [EOL] continue [EOL] arg_val = args [ arg_name ] [EOL] [EOL] if isinstance ( arg_val , dict ) : [EOL] parts = list ( arg_val . values ( ) ) [EOL] elif isinstance ( arg_val , ( list , tuple ) ) : [EOL] parts = list ( arg_val ) [EOL] else : [EOL] parts = [ arg_val ] [EOL] [EOL] flat_args . extend ( [ str ( part ) for part in parts ] ) [EOL] [EOL] clean_flat_args = [ re . sub ( [string] , [string] , arg ) for arg in flat_args ] [EOL] unique = [string] . join ( clean_flat_args ) [EOL] [EOL] cutoff = [number] [EOL] if len ( unique ) <= cutoff : [EOL] label = unique [EOL] else : [EOL] label = hashlib . md5 ( unique . encode ( [string] ) ) . hexdigest ( ) [EOL] [EOL] filename = [string] . format ( test_type , test_name , label ) [EOL] name = [string] . format ( test_type , test_name , unique ) [EOL] [EOL] return filename , name [EOL] [EOL] [EOL] @ dataclass class YamlBlock ( FileBlock ) : [EOL] data = ... [EOL] [EOL] @ classmethod def from_file_block ( cls , src , data ) : [EOL] return cls ( file = src . file , data = data , ) [EOL] [EOL] [EOL] Testable = TypeVar ( [string] , UnparsedNodeUpdate , UnpatchedSourceDefinition ) [EOL] [EOL] ColumnTarget = TypeVar ( [string] , UnparsedNodeUpdate , UnparsedAnalysisUpdate , UnpatchedSourceDefinition , ) [EOL] [EOL] Target = TypeVar ( [string] , UnparsedNodeUpdate , UnparsedMacroUpdate , UnparsedAnalysisUpdate , UnpatchedSourceDefinition , UnparsedReport , ) [EOL] [EOL] [EOL] @ dataclass class TargetBlock ( YamlBlock , Generic [ Target ] ) : [EOL] target = ... [EOL] [EOL] @ property def name ( self ) : [EOL] return self . target . name [EOL] [EOL] @ property def columns ( self ) : [EOL] return [ ] [EOL] [EOL] @ property def tests ( self ) : [EOL] return [ ] [EOL] [EOL] @ classmethod def from_yaml_block ( cls , src , target ) : [EOL] return cls ( file = src . file , data = src . data , target = target , ) [EOL] [EOL] [EOL] @ dataclass class TargetColumnsBlock ( TargetBlock [ ColumnTarget ] , Generic [ ColumnTarget ] ) : [EOL] @ property def columns ( self ) : [EOL] if self . target . columns is None : [EOL] return [ ] [EOL] else : [EOL] return self . target . columns [EOL] [EOL] [EOL] @ dataclass class TestBlock ( TargetColumnsBlock [ Testable ] , Generic [ Testable ] ) : [EOL] @ property def tests ( self ) : [EOL] if self . target . tests is None : [EOL] return [ ] [EOL] else : [EOL] return self . target . tests [EOL] [EOL] @ property def quote_columns ( self ) : [EOL] return self . target . quote_columns [EOL] [EOL] @ classmethod def from_yaml_block ( cls , src , target ) : [EOL] return cls ( file = src . file , data = src . data , target = target , ) [EOL] [EOL] [EOL] @ dataclass class SchemaTestBlock ( TestBlock [ Testable ] , Generic [ Testable ] ) : [EOL] test = ... [EOL] column_name = ... [EOL] tags = ... [EOL] [EOL] @ classmethod def from_test_block ( cls , src , test , column_name , tags , ) : [EOL] return cls ( file = src . file , data = src . data , target = src . target , test = test , column_name = column_name , tags = tags , ) [EOL] [EOL] [EOL] class TestBuilder ( Generic [ Testable ] ) : [EOL] [docstring] [EOL] TEST_NAME_PATTERN = re . compile ( [string] [string] ) [EOL] [comment] [EOL] MODIFIER_ARGS = { [string] : [string] , [string] : [ ] } [EOL] [EOL] def __init__ ( self , test , target , package_name , render_ctx , column_name = None , ) : [EOL] test_name , test_args = self . extract_test_args ( test , column_name ) [EOL] self . args = test_args [EOL] if [string] in self . args : [EOL] raise_compiler_error ( [string] , ) [EOL] self . package_name = package_name [EOL] self . target = target [EOL] [EOL] self . args [ [string] ] = self . build_model_str ( ) [EOL] [EOL] match = self . TEST_NAME_PATTERN . match ( test_name ) [EOL] if match is None : [EOL] raise_compiler_error ( [string] . format ( test_name ) ) [EOL] [EOL] groups = match . groupdict ( ) [EOL] self . name = groups [ [string] ] [EOL] self . namespace = groups [ [string] ] [EOL] self . modifiers = { } [EOL] for key , default in self . MODIFIER_ARGS . items ( ) : [EOL] value = self . args . pop ( key , default ) [EOL] if isinstance ( value , str ) : [EOL] value = get_rendered ( value , render_ctx ) [EOL] self . modifiers [ key ] = value [EOL] [EOL] if self . namespace is not None : [EOL] self . package_name = self . namespace [EOL] [EOL] compiled_name , fqn_name = self . get_test_name ( ) [EOL] self . compiled_name = compiled_name [EOL] self . fqn_name = fqn_name [EOL] [EOL] def _bad_type ( self ) : [EOL] return TypeError ( [string] . format ( type ( self . target ) ) ) [EOL] [EOL] @ staticmethod def extract_test_args ( test , name = None ) : [EOL] if not isinstance ( test , dict ) : [EOL] raise_compiler_error ( [string] . format ( type ( test ) , test ) ) [EOL] [EOL] test = list ( test . items ( ) ) [EOL] if len ( test ) != [number] : [EOL] raise_compiler_error ( [string] [string] . format ( test , len ( test ) ) ) [EOL] test_name , test_args = test [ [number] ] [EOL] [EOL] if not isinstance ( test_args , dict ) : [EOL] raise_compiler_error ( [string] . format ( type ( test_args ) , test_args ) ) [EOL] if not isinstance ( test_name , str ) : [EOL] raise_compiler_error ( [string] . format ( type ( test_name ) , test_name ) ) [EOL] test_args = deepcopy ( test_args ) [EOL] if name is not None : [EOL] test_args [ [string] ] = name [EOL] return test_name , test_args [EOL] [EOL] def severity ( self ) : [EOL] return self . modifiers . get ( [string] , [string] ) . upper ( ) [EOL] [EOL] def tags ( self ) : [EOL] tags = self . modifiers . get ( [string] , [ ] ) [EOL] if isinstance ( tags , str ) : [EOL] tags = [ tags ] [EOL] if not isinstance ( tags , list ) : [EOL] raise_compiler_error ( f' [string] { tags } [string] { type ( tags ) } [string] ' f' [string] ' ) [EOL] for tag in tags : [EOL] if not isinstance ( tag , str ) : [EOL] raise_compiler_error ( f' [string] { tag } [string] { type ( tag ) } [string] ' ) [EOL] return tags [ : ] [EOL] [EOL] def macro_name ( self ) : [EOL] macro_name = [string] . format ( self . name ) [EOL] if self . namespace is not None : [EOL] macro_name = [string] . format ( self . namespace , macro_name ) [EOL] return macro_name [EOL] [EOL] def get_test_name ( self ) : [EOL] if isinstance ( self . target , UnparsedNodeUpdate ) : [EOL] name = self . name [EOL] elif isinstance ( self . target , UnpatchedSourceDefinition ) : [EOL] name = [string] + self . name [EOL] else : [EOL] raise self . _bad_type ( ) [EOL] if self . namespace is not None : [EOL] name = [string] . format ( self . namespace , name ) [EOL] return get_nice_schema_test_name ( name , self . target . name , self . args ) [EOL] [EOL] def build_raw_sql ( self ) : [EOL] return ( [string] [string] ) . format ( macro = self . macro_name ( ) , severity = self . severity ( ) , kwargs_name = SCHEMA_TEST_KWARGS_NAME , ) [EOL] [EOL] def build_model_str ( self ) : [EOL] if isinstance ( self . target , UnparsedNodeUpdate ) : [EOL] fmt = [string] [EOL] elif isinstance ( self . target , UnpatchedSourceDefinition ) : [EOL] fmt = [string] [EOL] else : [EOL] raise self . _bad_type ( ) [EOL] return fmt . format ( self . target ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Target$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $Testable$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $Testable$ 0 $Testable$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.TypeError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Any , Pattern , Iterable [EOL] import builtins [EOL] import dbt [EOL] import typing [EOL] from typing import Iterable [EOL] [EOL] import re [EOL] [EOL] from dbt . clients . jinja import get_rendered [EOL] from dbt . contracts . graph . parsed import ParsedDocumentation [EOL] from dbt . node_types import NodeType [EOL] from dbt . parser . base import Parser [EOL] from dbt . parser . search import ( BlockContents , FileBlock , FilesystemSearcher , BlockSearcher ) [EOL] [EOL] [EOL] SHOULD_PARSE_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] class DocumentationParser ( Parser [ ParsedDocumentation ] ) : [EOL] def get_paths ( self ) : [EOL] return FilesystemSearcher ( project = self . project , relative_dirs = self . project . docs_paths , extension = [string] , ) [EOL] [EOL] @ property def resource_type ( self ) : [EOL] return NodeType . Documentation [EOL] [EOL] @ classmethod def get_compiled_path ( cls , block ) : [EOL] return block . path . relative_path [EOL] [EOL] def generate_unique_id ( self , resource_name ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] . format ( self . project . project_name , resource_name ) [EOL] [EOL] def parse_block ( self , block ) : [EOL] unique_id = self . generate_unique_id ( block . name ) [EOL] contents = get_rendered ( block . contents , { } ) . strip ( ) [EOL] [EOL] doc = ParsedDocumentation ( root_path = self . project . project_root , path = block . file . path . relative_path , original_file_path = block . path . original_file_path , package_name = self . project . project_name , unique_id = unique_id , name = block . name , block_contents = contents , ) [EOL] return [ doc ] [EOL] [EOL] def parse_file ( self , file_block ) : [EOL] searcher = BlockSearcher ( source = [ file_block ] , allowed_blocks = { [string] } , source_tag_factory = BlockContents , ) [EOL] for block in searcher : [EOL] for parsed in self . parse_block ( block ) : [EOL] self . results . add_doc ( file_block . file , parsed ) [EOL] [comment] [EOL] self . results . get_file ( file_block . file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Iterable[dbt.contracts.graph.parsed.ParsedDocumentation]$ 0 0 0 $dbt.parser.search.BlockContents$ 0 0 0 $builtins.str$ 0 0 0 0 0 $dbt.parser.search.BlockContents$ 0 0 0 0 $typing.Any$ 0 0 0 $dbt.parser.search.BlockContents$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.BlockContents$ 0 0 0 0 0 0 0 0 0 $dbt.parser.search.BlockContents$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $dbt.parser.search.BlockContents$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 $typing.Iterable[dbt.parser.search.BlockContents]$ 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[dbt.parser.search.BlockContents]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0
from . analysis import AnalysisParser [comment] [EOL] from . base import Parser , ConfiguredParser [comment] [EOL] from . data_test import DataTestParser [comment] [EOL] from . docs import DocumentationParser [comment] [EOL] from . hooks import HookParser [comment] [EOL] from . macros import MacroParser [comment] [EOL] from . models import ModelParser [comment] [EOL] from . results import ParseResult [comment] [EOL] from . schemas import SchemaParser [comment] [EOL] from . seeds import SeedParser [comment] [EOL] from . snapshots import SnapshotParser [comment] [EOL] [EOL] from . import ( analysis , base , data_test , docs , hooks , macros , models , results , schemas , snapshots ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable [EOL] import core [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from dataclasses import dataclass [EOL] from typing import Iterable [EOL] [EOL] from dbt . contracts . graph . manifest import SourceFile [EOL] from dbt . contracts . graph . parsed import ParsedRPCNode , ParsedMacro [EOL] from dbt . contracts . graph . unparsed import UnparsedMacro [EOL] from dbt . exceptions import InternalException [EOL] from dbt . node_types import NodeType [EOL] from dbt . parser . base import SimpleSQLParser [EOL] from dbt . parser . macros import MacroParser [EOL] from dbt . parser . search import FileBlock [EOL] [EOL] [EOL] @ dataclass class RPCBlock ( FileBlock ) : [EOL] rpc_name = ... [EOL] [EOL] @ property def name ( self ) : [EOL] return self . rpc_name [EOL] [EOL] [EOL] class RPCCallParser ( SimpleSQLParser [ ParsedRPCNode ] ) : [EOL] def get_paths ( self ) : [EOL] return [ ] [EOL] [EOL] def parse_from_dict ( self , dct , validate = True ) : [EOL] return ParsedRPCNode . from_dict ( dct , validate = validate ) [EOL] [EOL] @ property def resource_type ( self ) : [EOL] return NodeType . RPCCall [EOL] [EOL] def get_compiled_path ( cls , block ) : [EOL] [comment] [EOL] if not isinstance ( block , RPCBlock ) : [EOL] raise InternalException ( [string] [string] . format ( block ) ) [EOL] [EOL] return os . path . join ( [string] , block . name ) [EOL] [EOL] def parse_remote ( self , sql , name ) : [EOL] source_file = SourceFile . remote ( contents = sql ) [EOL] contents = RPCBlock ( rpc_name = name , file = source_file ) [EOL] return self . parse_node ( contents ) [EOL] [EOL] [EOL] class RPCMacroParser ( MacroParser ) : [EOL] def parse_remote ( self , contents ) : [EOL] base = UnparsedMacro ( path = [string] , original_file_path = [string] , package_name = self . project . project_name , raw_sql = contents , root_path = self . project . project_root , resource_type = NodeType . Macro , ) [EOL] for node in self . parse_unparsed_macros ( base ) : [EOL] yield node [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedRPCNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedRPCNode$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $core.dbt.parser.rpc.RPCBlock$ 0 $builtins.str$ 0 0 $core.dbt.parser.rpc.RPCBlock$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $core.dbt.parser.rpc.RPCBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[dbt.contracts.graph.parsed.ParsedMacro]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any , List , Union , Tuple , Iterator [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] from dataclasses import dataclass [EOL] from typing import Iterable , Iterator , Union , List , Tuple [EOL] [EOL] from dbt . context . context_config import ContextConfig [EOL] from dbt . contracts . files import FilePath [EOL] from dbt . contracts . graph . parsed import ParsedHookNode [EOL] from dbt . exceptions import InternalException [EOL] from dbt . node_types import NodeType , RunHookType [EOL] from dbt . parser . base import SimpleParser [EOL] from dbt . parser . search import FileBlock [EOL] from dbt . utils import get_pseudo_hook_path [EOL] [EOL] [EOL] @ dataclass class HookBlock ( FileBlock ) : [EOL] project = ... [EOL] value = ... [EOL] index = ... [EOL] hook_type = ... [EOL] [EOL] @ property def contents ( self ) : [EOL] return self . value [EOL] [EOL] @ property def name ( self ) : [EOL] return [string] . format ( self . project , self . hook_type , self . index ) [EOL] [EOL] [EOL] class HookSearcher ( Iterable [ HookBlock ] ) : [EOL] def __init__ ( self , project , source_file , hook_type ) : [EOL] self . project = project [EOL] self . source_file = source_file [EOL] self . hook_type = hook_type [EOL] [EOL] def _hook_list ( self , hooks ) : [EOL] if isinstance ( hooks , tuple ) : [EOL] hooks = list ( hooks ) [EOL] elif not isinstance ( hooks , list ) : [EOL] hooks = [ hooks ] [EOL] return hooks [EOL] [EOL] def get_hook_defs ( self ) : [EOL] if self . hook_type == RunHookType . Start : [EOL] hooks = self . project . on_run_start [EOL] elif self . hook_type == RunHookType . End : [EOL] hooks = self . project . on_run_end [EOL] else : [EOL] raise InternalException ( [string] . format ( RunHookType . Start , RunHookType . End , self . hook_type ) ) [EOL] return self . _hook_list ( hooks ) [EOL] [EOL] def __iter__ ( self ) : [EOL] hooks = self . get_hook_defs ( ) [EOL] for index , hook in enumerate ( hooks ) : [EOL] yield HookBlock ( file = self . source_file , project = self . project . project_name , value = hook , index = index , hook_type = self . hook_type , ) [EOL] [EOL] [EOL] class HookParser ( SimpleParser [ HookBlock , ParsedHookNode ] ) : [EOL] def transform ( self , node ) : [EOL] return node [EOL] [EOL] def get_paths ( self ) : [EOL] path = FilePath ( project_root = self . project . project_root , searched_path = [string] , relative_path = [string] , ) [EOL] return [ path ] [EOL] [EOL] def parse_from_dict ( self , dct , validate = True ) : [EOL] return ParsedHookNode . from_dict ( dct , validate = validate ) [EOL] [EOL] @ classmethod def get_compiled_path ( cls , block ) : [EOL] return get_pseudo_hook_path ( block . name ) [EOL] [EOL] def _create_parsetime_node ( self , block , path , config , fqn , name = None , ** kwargs , ) : [EOL] [EOL] return super ( ) . _create_parsetime_node ( block = block , path = path , config = config , fqn = fqn , index = block . index , name = name , tags = [ str ( block . hook_type ) ] ) [EOL] [EOL] @ property def resource_type ( self ) : [EOL] return NodeType . Operation [EOL] [EOL] def parse_file ( self , block ) : [EOL] for hook_type in RunHookType : [EOL] for hook in HookSearcher ( self . project , block . file , hook_type ) : [EOL] self . parse_node ( hook ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $dbt.node_types.RunHookType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[HookBlock]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[dbt.contracts.files.FilePath]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $dbt.contracts.graph.parsed.ParsedHookNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $HookBlock$ 0 0 0 0 0 0 $HookBlock$ 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedHookNode$ 0 0 0 $HookBlock$ 0 $builtins.str$ 0 $dbt.context.context_config.ContextConfig$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $HookBlock$ 0 $HookBlock$ 0 $builtins.str$ 0 $builtins.str$ 0 $dbt.context.context_config.ContextConfig$ 0 $dbt.context.context_config.ContextConfig$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $HookBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 $HookBlock$ 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , List , Set , MutableMapping , Dict , Mapping , Optional , Type [EOL] import core [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import pickle [EOL] from datetime import datetime [EOL] from typing import ( Dict , Optional , Mapping , Callable , Any , List , Type , Union , MutableMapping ) [EOL] [EOL] import dbt . exceptions [EOL] import dbt . flags as flags [EOL] [EOL] from dbt . adapters . factory import ( get_relation_class_by_name , ) [EOL] from dbt . helper_types import PathSet [EOL] from dbt . logger import GLOBAL_LOGGER as logger , DbtProcessState [EOL] from dbt . node_types import NodeType [EOL] from dbt . clients . jinja import get_rendered [EOL] from dbt . clients . system import make_directory [EOL] from dbt . config import Project , RuntimeConfig [EOL] from dbt . context . docs import generate_runtime_docs [EOL] from dbt . contracts . files import FilePath , FileHash [EOL] from dbt . contracts . graph . compiled import ManifestNode [EOL] from dbt . contracts . graph . manifest import Manifest , Disabled [EOL] from dbt . contracts . graph . parsed import ( ParsedSourceDefinition , ParsedNode , ParsedMacro , ColumnInfo , ParsedReport ) [EOL] from dbt . exceptions import ( ref_target_not_found , get_target_not_found_or_disabled_msg , source_target_not_found , get_source_not_found_or_disabled_msg , warn_or_error , ) [EOL] from dbt . parser . base import BaseParser , Parser [EOL] from dbt . parser . analysis import AnalysisParser [EOL] from dbt . parser . data_test import DataTestParser [EOL] from dbt . parser . docs import DocumentationParser [EOL] from dbt . parser . hooks import HookParser [EOL] from dbt . parser . macros import MacroParser [EOL] from dbt . parser . models import ModelParser [EOL] from dbt . parser . results import ParseResult [EOL] from dbt . parser . schemas import SchemaParser [EOL] from dbt . parser . search import FileBlock [EOL] from dbt . parser . seeds import SeedParser [EOL] from dbt . parser . snapshots import SnapshotParser [EOL] from dbt . parser . sources import patch_sources [EOL] from dbt . ui import warning_tag [EOL] from dbt . version import __version__ [EOL] [EOL] [EOL] PARTIAL_PARSE_FILE_NAME = [string] [EOL] PARSING_STATE = DbtProcessState ( [string] ) [EOL] DEFAULT_PARTIAL_PARSE = False [EOL] [EOL] [EOL] _parser_types = [ ModelParser , SnapshotParser , AnalysisParser , DataTestParser , HookParser , SeedParser , DocumentationParser , SchemaParser , ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def make_parse_result ( config , all_projects ) : [EOL] [docstring] [EOL] [comment] [EOL] vars_hash = FileHash . from_contents ( [string] . join ( [ getattr ( config . args , [string] , [string] ) or [string] , getattr ( config . args , [string] , [string] ) or [string] , getattr ( config . args , [string] , [string] ) or [string] , __version__ ] ) ) [EOL] profile_path = os . path . join ( config . args . profiles_dir , [string] ) [EOL] with open ( profile_path ) as fp : [EOL] profile_hash = FileHash . from_contents ( fp . read ( ) ) [EOL] [EOL] project_hashes = { } [EOL] for name , project in all_projects . items ( ) : [EOL] path = os . path . join ( project . project_root , [string] ) [EOL] with open ( path ) as fp : [EOL] project_hashes [ name ] = FileHash . from_contents ( fp . read ( ) ) [EOL] [EOL] return ParseResult ( vars_hash = vars_hash , profile_hash = profile_hash , project_hashes = project_hashes , ) [EOL] [EOL] [EOL] class ManifestLoader : [EOL] def __init__ ( self , root_project , all_projects , macro_hook = None , ) : [EOL] self . root_project = root_project [EOL] self . all_projects = all_projects [EOL] self . macro_hook = ... [EOL] if macro_hook is None : [EOL] self . macro_hook = lambda m : None [EOL] else : [EOL] self . macro_hook = macro_hook [EOL] [EOL] self . results = make_parse_result ( root_project , all_projects , ) [EOL] self . _loaded_file_cache = { } [EOL] [EOL] def parse_with_cache ( self , path , parser , old_results , ) : [EOL] block = self . _get_file ( path , parser ) [EOL] if not self . _get_cached ( block , old_results , parser ) : [EOL] parser . parse_file ( block ) [EOL] [EOL] def _get_cached ( self , block , old_results , parser , ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if old_results is None : [EOL] return False [EOL] if old_results . has_file ( block . file ) : [EOL] return self . results . sanitized_update ( block . file , old_results , parser . resource_type ) [EOL] return False [EOL] [EOL] def _get_file ( self , path , parser ) : [EOL] if path . search_key in self . _loaded_file_cache : [EOL] block = self . _loaded_file_cache [ path . search_key ] [EOL] else : [EOL] block = FileBlock ( file = parser . load_file ( path ) ) [EOL] self . _loaded_file_cache [ path . search_key ] = block [EOL] return block [EOL] [EOL] def parse_project ( self , project , macro_manifest , old_results , ) : [EOL] parsers = [ ] [EOL] for cls in _parser_types : [EOL] parser = cls ( self . results , project , self . root_project , macro_manifest ) [EOL] parsers . append ( parser ) [EOL] [EOL] [comment] [EOL] self . _loaded_file_cache . clear ( ) [EOL] [EOL] for parser in parsers : [EOL] for path in parser . search ( ) : [EOL] self . parse_with_cache ( path , parser , old_results ) [EOL] [EOL] def load_only_macros ( self ) : [EOL] old_results = self . read_parse_results ( ) [EOL] [EOL] for project in self . all_projects . values ( ) : [EOL] parser = MacroParser ( self . results , project ) [EOL] for path in parser . search ( ) : [EOL] self . parse_with_cache ( path , parser , old_results ) [EOL] [EOL] [comment] [EOL] macro_manifest = Manifest . from_macros ( macros = self . results . macros , files = self . results . files ) [EOL] self . macro_hook ( macro_manifest ) [EOL] return macro_manifest [EOL] [EOL] def load ( self , macro_manifest ) : [EOL] old_results = self . read_parse_results ( ) [EOL] if old_results is not None : [EOL] logger . debug ( [string] ) [EOL] self . results . macros . update ( macro_manifest . macros ) [EOL] self . results . files . update ( macro_manifest . files ) [EOL] [EOL] for project in self . all_projects . values ( ) : [EOL] [comment] [EOL] self . parse_project ( project , macro_manifest , old_results ) [EOL] [EOL] def write_parse_results ( self ) : [EOL] path = os . path . join ( self . root_project . target_path , PARTIAL_PARSE_FILE_NAME ) [EOL] make_directory ( self . root_project . target_path ) [EOL] with open ( path , [string] ) as fp : [EOL] pickle . dump ( self . results , fp ) [EOL] [EOL] def matching_parse_results ( self , result ) : [EOL] [docstring] [EOL] try : [EOL] if result . dbt_version != __version__ : [EOL] logger . debug ( [string] . format ( result . dbt_version , __version__ ) ) [EOL] return False [EOL] except AttributeError : [EOL] logger . debug ( [string] ) [EOL] return False [EOL] [EOL] valid = True [EOL] [EOL] if self . results . vars_hash != result . vars_hash : [EOL] logger . debug ( [string] ) [EOL] valid = False [EOL] if self . results . profile_hash != result . profile_hash : [EOL] logger . debug ( [string] ) [EOL] valid = False [EOL] [EOL] missing_keys = { k for k in self . results . project_hashes if k not in result . project_hashes } [EOL] if missing_keys : [EOL] logger . debug ( [string] . format ( missing_keys ) ) [EOL] valid = False [EOL] [EOL] for key , new_value in self . results . project_hashes . items ( ) : [EOL] if key in result . project_hashes : [EOL] old_value = result . project_hashes [ key ] [EOL] if new_value != old_value : [EOL] logger . debug ( [string] [string] . format ( key , old_value , new_value ) ) [EOL] valid = False [EOL] return valid [EOL] [EOL] def _partial_parse_enabled ( self ) : [EOL] [comment] [EOL] if flags . PARTIAL_PARSE is not None : [EOL] return flags . PARTIAL_PARSE [EOL] [comment] [EOL] elif self . root_project . config . partial_parse is not None : [EOL] return self . root_project . config . partial_parse [EOL] else : [EOL] return DEFAULT_PARTIAL_PARSE [EOL] [EOL] def read_parse_results ( self ) : [EOL] if not self . _partial_parse_enabled ( ) : [EOL] logger . debug ( [string] ) [EOL] return None [EOL] path = os . path . join ( self . root_project . target_path , PARTIAL_PARSE_FILE_NAME ) [EOL] [EOL] if os . path . exists ( path ) : [EOL] try : [EOL] with open ( path , [string] ) as fp : [EOL] result = pickle . load ( fp ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . matching_parse_results ( result ) : [EOL] return result [EOL] except Exception as exc : [EOL] logger . debug ( [string] . format ( path , exc ) , exc_info = True ) [EOL] [EOL] return None [EOL] [EOL] def process_manifest ( self , manifest ) : [EOL] project_name = self . root_project . project_name [EOL] process_sources ( manifest , project_name ) [EOL] process_refs ( manifest , project_name ) [EOL] process_docs ( manifest , self . root_project ) [EOL] [EOL] def create_manifest ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sources = patch_sources ( self . results , self . root_project ) [EOL] disabled = [ ] [EOL] for value in self . results . disabled . values ( ) : [EOL] disabled . extend ( value ) [EOL] [EOL] nodes = { k : v for k , v in self . results . nodes . items ( ) } [EOL] [EOL] manifest = Manifest ( nodes = nodes , sources = sources , macros = self . results . macros , docs = self . results . docs , reports = self . results . reports , generated_at = datetime . utcnow ( ) , metadata = self . root_project . get_metadata ( ) , disabled = disabled , files = self . results . files , ) [EOL] manifest . patch_nodes ( self . results . patches ) [EOL] manifest . patch_macros ( self . results . macro_patches ) [EOL] self . process_manifest ( manifest ) [EOL] return manifest [EOL] [EOL] @ classmethod def load_all ( cls , root_config , macro_manifest , macro_hook , ) : [EOL] with PARSING_STATE : [EOL] projects = root_config . load_dependencies ( ) [EOL] loader = cls ( root_config , projects , macro_hook ) [EOL] loader . load ( macro_manifest = macro_manifest ) [EOL] loader . write_parse_results ( ) [EOL] manifest = loader . create_manifest ( ) [EOL] _check_manifest ( manifest , root_config ) [EOL] manifest . build_flat_graph ( ) [EOL] return manifest [EOL] [EOL] @ classmethod def load_macros ( cls , root_config , macro_hook , ) : [EOL] with PARSING_STATE : [EOL] projects = root_config . load_dependencies ( ) [EOL] loader = cls ( root_config , projects , macro_hook ) [EOL] return loader . load_only_macros ( ) [EOL] [EOL] [EOL] def invalid_ref_fail_unless_test ( node , target_model_name , target_model_package , disabled ) : [EOL] [EOL] if node . resource_type == NodeType . Test : [EOL] msg = get_target_not_found_or_disabled_msg ( node , target_model_name , target_model_package , disabled ) [EOL] if disabled : [EOL] logger . debug ( warning_tag ( msg ) ) [EOL] else : [EOL] warn_or_error ( msg , log_fmt = warning_tag ( [string] ) ) [EOL] else : [EOL] ref_target_not_found ( node , target_model_name , target_model_package , disabled = disabled , ) [EOL] [EOL] [EOL] def invalid_source_fail_unless_test ( node , target_name , target_table_name , disabled ) : [EOL] if node . resource_type == NodeType . Test : [EOL] msg = get_source_not_found_or_disabled_msg ( node , target_name , target_table_name , disabled ) [EOL] if disabled : [EOL] logger . debug ( warning_tag ( msg ) ) [EOL] else : [EOL] warn_or_error ( msg , log_fmt = warning_tag ( [string] ) ) [EOL] else : [EOL] source_target_not_found ( node , target_name , target_table_name , disabled = disabled ) [EOL] [EOL] [EOL] def _check_resource_uniqueness ( manifest , config , ) : [EOL] names_resources = { } [EOL] alias_resources = { } [EOL] [EOL] for resource , node in manifest . nodes . items ( ) : [EOL] if node . resource_type not in NodeType . refable ( ) : [EOL] continue [EOL] [comment] [EOL] assert not isinstance ( node , ParsedSourceDefinition ) [EOL] [EOL] name = node . name [EOL] [comment] [EOL] relation_cls = get_relation_class_by_name ( config . credentials . type ) [EOL] relation = relation_cls . create_from ( config = config , node = node ) [EOL] full_node_name = str ( relation ) [EOL] [EOL] existing_node = names_resources . get ( name ) [EOL] if existing_node is not None : [EOL] dbt . exceptions . raise_duplicate_resource_name ( existing_node , node ) [EOL] [EOL] existing_alias = alias_resources . get ( full_node_name ) [EOL] if existing_alias is not None : [EOL] dbt . exceptions . raise_ambiguous_alias ( existing_alias , node , full_node_name ) [EOL] [EOL] names_resources [ name ] = node [EOL] alias_resources [ full_node_name ] = node [EOL] [EOL] [EOL] def _warn_for_unused_resource_config_paths ( manifest , config ) : [EOL] resource_fqns = manifest . get_resource_fqns ( ) [EOL] disabled_fqns = frozenset ( tuple ( n . fqn ) for n in manifest . disabled ) [EOL] config . warn_for_unused_resource_config_paths ( resource_fqns , disabled_fqns ) [EOL] [EOL] [EOL] def _check_manifest ( manifest , config ) : [EOL] _check_resource_uniqueness ( manifest , config ) [EOL] _warn_for_unused_resource_config_paths ( manifest , config ) [EOL] [EOL] [EOL] def _load_projects ( config , paths ) : [EOL] for path in paths : [EOL] try : [EOL] project = config . new_project ( path ) [EOL] except dbt . exceptions . DbtProjectError as e : [EOL] raise dbt . exceptions . DbtProjectError ( [string] . format ( path , e ) ) [EOL] else : [EOL] yield project . project_name , project [EOL] [EOL] [EOL] def _get_node_column ( node , column_name ) : [EOL] [docstring] [EOL] if column_name in node . columns : [EOL] column = node . columns [ column_name ] [EOL] else : [EOL] node . columns [ column_name ] = ColumnInfo ( name = column_name ) [EOL] node . columns [ column_name ] = column [EOL] [EOL] return column [EOL] [EOL] [EOL] DocsContextCallback = Callable [ [ Union [ ParsedNode , ParsedSourceDefinition ] ] , Dict [ str , Any ] ] [EOL] [EOL] [EOL] def _process_docs_for_node ( context , node , ) : [EOL] node . description = get_rendered ( node . description , context ) [EOL] for column_name , column in node . columns . items ( ) : [EOL] column . description = get_rendered ( column . description , context ) [EOL] [EOL] [EOL] def _process_docs_for_source ( context , source , ) : [EOL] table_description = source . description [EOL] source_description = source . source_description [EOL] table_description = get_rendered ( table_description , context ) [EOL] source_description = get_rendered ( source_description , context ) [EOL] source . description = table_description [EOL] source . source_description = source_description [EOL] [EOL] for column in source . columns . values ( ) : [EOL] column_desc = column . description [EOL] column_desc = get_rendered ( column_desc , context ) [EOL] column . description = column_desc [EOL] [EOL] [EOL] def _process_docs_for_macro ( context , macro ) : [EOL] macro . description = get_rendered ( macro . description , context ) [EOL] for arg in macro . arguments : [EOL] arg . description = get_rendered ( arg . description , context ) [EOL] [EOL] [EOL] def process_docs ( manifest , config ) : [EOL] for node in manifest . nodes . values ( ) : [EOL] ctx = generate_runtime_docs ( config , node , manifest , config . project_name , ) [EOL] _process_docs_for_node ( ctx , node ) [EOL] for source in manifest . sources . values ( ) : [EOL] ctx = generate_runtime_docs ( config , source , manifest , config . project_name , ) [EOL] _process_docs_for_source ( ctx , source ) [EOL] for macro in manifest . macros . values ( ) : [EOL] ctx = generate_runtime_docs ( config , macro , manifest , config . project_name , ) [EOL] _process_docs_for_macro ( ctx , macro ) [EOL] [EOL] [EOL] def _process_refs_for_report ( manifest , current_project , report ) : [EOL] [docstring] [EOL] for ref in report . refs : [EOL] target_model = None [EOL] target_model_name = ... [EOL] target_model_package = None [EOL] [EOL] if len ( ref ) == [number] : [EOL] target_model_name = ref [ [number] ] [EOL] elif len ( ref ) == [number] : [EOL] target_model_package , target_model_name = ref [EOL] else : [EOL] raise dbt . exceptions . InternalException ( f' [string] { len ( ref ) }' ) [EOL] [EOL] target_model = manifest . resolve_ref ( target_model_name , target_model_package , current_project , report . package_name , ) [EOL] [EOL] if target_model is None or isinstance ( target_model , Disabled ) : [EOL] [comment] [EOL] [comment] [EOL] invalid_ref_fail_unless_test ( report , target_model_name , target_model_package , disabled = ( isinstance ( target_model , Disabled ) ) ) [EOL] [EOL] continue [EOL] [EOL] target_model_id = target_model . unique_id [EOL] [EOL] report . depends_on . nodes . append ( target_model_id ) [EOL] manifest . update_report ( report ) [EOL] [EOL] [EOL] def _process_refs_for_node ( manifest , current_project , node ) : [EOL] [docstring] [EOL] for ref in node . refs : [EOL] target_model = None [EOL] target_model_name = ... [EOL] target_model_package = None [EOL] [EOL] if len ( ref ) == [number] : [EOL] target_model_name = ref [ [number] ] [EOL] elif len ( ref ) == [number] : [EOL] target_model_package , target_model_name = ref [EOL] else : [EOL] raise dbt . exceptions . InternalException ( f' [string] { len ( ref ) }' ) [EOL] [EOL] target_model = manifest . resolve_ref ( target_model_name , target_model_package , current_project , node . package_name , ) [EOL] [EOL] if target_model is None or isinstance ( target_model , Disabled ) : [EOL] [comment] [EOL] [comment] [EOL] node . config . enabled = False [EOL] invalid_ref_fail_unless_test ( node , target_model_name , target_model_package , disabled = ( isinstance ( target_model , Disabled ) ) ) [EOL] [EOL] continue [EOL] [EOL] target_model_id = target_model . unique_id [EOL] [EOL] node . depends_on . nodes . append ( target_model_id ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] manifest . update_node ( node ) [EOL] [EOL] [EOL] def process_refs ( manifest , current_project ) : [EOL] for node in manifest . nodes . values ( ) : [EOL] _process_refs_for_node ( manifest , current_project , node ) [EOL] for report in manifest . reports . values ( ) : [EOL] _process_refs_for_report ( manifest , current_project , report ) [EOL] return manifest [EOL] [EOL] [EOL] def _process_sources_for_report ( manifest , current_project , report ) : [EOL] target_source = None [EOL] for source_name , table_name in report . sources : [EOL] target_source = manifest . resolve_source ( source_name , table_name , current_project , report . package_name , ) [EOL] if target_source is None or isinstance ( target_source , Disabled ) : [EOL] invalid_source_fail_unless_test ( report , source_name , table_name , disabled = ( isinstance ( target_source , Disabled ) ) ) [EOL] continue [EOL] target_source_id = target_source . unique_id [EOL] report . depends_on . nodes . append ( target_source_id ) [EOL] manifest . update_report ( report ) [EOL] [EOL] [EOL] def _process_sources_for_node ( manifest , current_project , node ) : [EOL] target_source = None [EOL] for source_name , table_name in node . sources : [EOL] target_source = manifest . resolve_source ( source_name , table_name , current_project , node . package_name , ) [EOL] [EOL] if target_source is None or isinstance ( target_source , Disabled ) : [EOL] [comment] [EOL] node . config . enabled = False [EOL] invalid_source_fail_unless_test ( node , source_name , table_name , disabled = ( isinstance ( target_source , Disabled ) ) ) [EOL] continue [EOL] target_source_id = target_source . unique_id [EOL] node . depends_on . nodes . append ( target_source_id ) [EOL] manifest . update_node ( node ) [EOL] [EOL] [EOL] def process_sources ( manifest , current_project ) : [EOL] for node in manifest . nodes . values ( ) : [EOL] if node . resource_type == NodeType . Source : [EOL] continue [EOL] assert not isinstance ( node , ParsedSourceDefinition ) [EOL] _process_sources_for_node ( manifest , current_project , node ) [EOL] for report in manifest . reports . values ( ) : [EOL] _process_sources_for_report ( manifest , current_project , report ) [EOL] return manifest [EOL] [EOL] [EOL] def process_macro ( config , manifest , macro ) : [EOL] ctx = generate_runtime_docs ( config , macro , manifest , config . project_name , ) [EOL] _process_docs_for_macro ( ctx , macro ) [EOL] [EOL] [EOL] def process_node ( config , manifest , node ) : [EOL] [EOL] _process_sources_for_node ( manifest , config . project_name , node ) [EOL] _process_refs_for_node ( manifest , config . project_name , node ) [EOL] ctx = generate_runtime_docs ( config , node , manifest , config . project_name ) [EOL] _process_docs_for_node ( ctx , node ) [EOL] [EOL] [EOL] def load_macro_manifest ( config , macro_hook , ) : [EOL] return ManifestLoader . load_macros ( config , macro_hook ) [EOL] [EOL] [EOL] def load_manifest ( config , macro_manifest , macro_hook , ) : [EOL] return ManifestLoader . load_all ( config , macro_manifest , macro_hook ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.config.RuntimeConfig$ 0 $typing.Mapping[builtins.str,dbt.config.Project]$ 0 0 0 0 0 0 0 0 0 0 $dbt.config.RuntimeConfig$ 0 $dbt.config.RuntimeConfig$ 0 0 0 $typing.Mapping[builtins.str,dbt.config.Project]$ 0 $typing.Mapping[builtins.str,dbt.config.Project]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 $dbt.config.RuntimeConfig$ 0 $typing.Mapping[builtins.str,dbt.config.Project]$ 0 0 0 0 0 $typing.Dict[builtins.str,dbt.parser.search.FileBlock]$ 0 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.files.FilePath$ 0 $dbt.parser.base.BaseParser$ 0 $typing.Optional[dbt.parser.results.ParseResult]$ 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.FilePath$ 0 $dbt.parser.base.BaseParser$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[dbt.parser.results.ParseResult]$ 0 $dbt.parser.base.BaseParser$ 0 0 0 $dbt.parser.base.BaseParser$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $dbt.parser.search.FileBlock$ 0 $typing.Optional[dbt.parser.results.ParseResult]$ 0 $dbt.parser.base.BaseParser$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[dbt.parser.results.ParseResult]$ 0 0 0 0 0 0 0 0 $typing.Optional[dbt.parser.results.ParseResult]$ 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 $typing.Optional[dbt.parser.results.ParseResult]$ 0 $dbt.parser.base.BaseParser$ 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 $dbt.contracts.files.FilePath$ 0 $dbt.parser.base.BaseParser$ 0 0 0 0 $dbt.contracts.files.FilePath$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $dbt.contracts.files.FilePath$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $dbt.parser.base.BaseParser$ 0 0 0 $dbt.contracts.files.FilePath$ 0 0 0 0 0 0 0 $dbt.contracts.files.FilePath$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $dbt.config.Project$ 0 $dbt.contracts.graph.manifest.Manifest$ 0 $typing.Optional[dbt.parser.results.ParseResult]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $dbt.config.Project$ 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[dbt.parser.results.ParseResult]$ 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 $typing.Any$ 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[dbt.parser.results.ParseResult]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 $dbt.parser.results.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,dbt.contracts.graph.compiled.ManifestNode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,dbt.contracts.graph.compiled.ManifestNode]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.MutableMapping[builtins.str,dbt.contracts.graph.compiled.ManifestNode]$ 0 $typing.MutableMapping[builtins.str,dbt.contracts.graph.compiled.ManifestNode]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 $dbt.config.RuntimeConfig$ 0 $dbt.contracts.graph.manifest.Manifest$ 0 $typing.Callable[[dbt.contracts.graph.manifest.Manifest],typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $dbt.config.RuntimeConfig$ 0 0 0 0 0 $core.dbt.parser.manifest.ManifestLoader$ 0 0 0 $dbt.config.RuntimeConfig$ 0 $typing.Any$ 0 $typing.Callable[[dbt.contracts.graph.manifest.Manifest],typing.Any]$ 0 0 $core.dbt.parser.manifest.ManifestLoader$ 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 $core.dbt.parser.manifest.ManifestLoader$ 0 0 0 0 0 0 0 $core.dbt.parser.manifest.ManifestLoader$ 0 0 0 0 0 0 0 0 0 $dbt.config.RuntimeConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 $dbt.config.RuntimeConfig$ 0 $typing.Callable[[dbt.contracts.graph.manifest.Manifest],typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $dbt.config.RuntimeConfig$ 0 0 0 0 0 $core.dbt.parser.manifest.ManifestLoader$ 0 0 0 $dbt.config.RuntimeConfig$ 0 $typing.Any$ 0 $typing.Callable[[dbt.contracts.graph.manifest.Manifest],typing.Any]$ 0 0 0 $core.dbt.parser.manifest.ManifestLoader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import dbt [EOL] import os [EOL] [EOL] from dbt . contracts . graph . parsed import ParsedAnalysisNode [EOL] from dbt . node_types import NodeType [EOL] from dbt . parser . base import SimpleSQLParser [EOL] from dbt . parser . search import FilesystemSearcher , FileBlock [EOL] [EOL] [EOL] class AnalysisParser ( SimpleSQLParser [ ParsedAnalysisNode ] ) : [EOL] def get_paths ( self ) : [EOL] return FilesystemSearcher ( self . project , self . project . analysis_paths , [string] ) [EOL] [EOL] def parse_from_dict ( self , dct , validate = True ) : [EOL] return ParsedAnalysisNode . from_dict ( dct , validate = validate ) [EOL] [EOL] @ property def resource_type ( self ) : [EOL] return NodeType . Analysis [EOL] [EOL] @ classmethod def get_compiled_path ( cls , block ) : [EOL] return os . path . join ( [string] , block . path . relative_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedAnalysisNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0
import dbt [EOL] from dbt . contracts . graph . parsed import ParsedDataTestNode [EOL] from dbt . node_types import NodeType [EOL] from dbt . parser . base import SimpleSQLParser [EOL] from dbt . parser . search import FilesystemSearcher , FileBlock [EOL] from dbt . utils import get_pseudo_test_path [EOL] [EOL] [EOL] class DataTestParser ( SimpleSQLParser [ ParsedDataTestNode ] ) : [EOL] def get_paths ( self ) : [EOL] return FilesystemSearcher ( self . project , self . project . test_paths , [string] ) [EOL] [EOL] def parse_from_dict ( self , dct , validate = True ) : [EOL] return ParsedDataTestNode . from_dict ( dct , validate = validate ) [EOL] [EOL] @ property def resource_type ( self ) : [EOL] return NodeType . Test [EOL] [EOL] def transform ( self , node ) : [EOL] if [string] not in node . tags : [EOL] node . tags . append ( [string] ) [EOL] return node [EOL] [EOL] @ classmethod def get_compiled_path ( cls , block ) : [EOL] return get_pseudo_test_path ( block . name , block . path . relative_path , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedDataTestNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0
import dbt [EOL] from dbt . contracts . graph . parsed import ParsedModelNode [EOL] from dbt . node_types import NodeType [EOL] from dbt . parser . base import SimpleSQLParser [EOL] from dbt . parser . search import FilesystemSearcher , FileBlock [EOL] [EOL] [EOL] class ModelParser ( SimpleSQLParser [ ParsedModelNode ] ) : [EOL] def get_paths ( self ) : [EOL] return FilesystemSearcher ( self . project , self . project . source_paths , [string] ) [EOL] [EOL] def parse_from_dict ( self , dct , validate = True ) : [EOL] return ParsedModelNode . from_dict ( dct , validate = validate ) [EOL] [EOL] @ property def resource_type ( self ) : [EOL] return NodeType . Model [EOL] [EOL] @ classmethod def get_compiled_path ( cls , block ) : [EOL] return block . path . relative_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedModelNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0
from typing import Any , Iterable , List , Dict , TypeVar [EOL] import core [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] import abc [EOL] import itertools [EOL] import os [EOL] from typing import ( List , Dict , Any , Iterable , Generic , TypeVar ) [EOL] [EOL] from hologram import ValidationError [EOL] [EOL] from dbt import utils [EOL] from dbt . clients . jinja import MacroGenerator [EOL] from dbt . clients . system import load_file_contents [EOL] from dbt . context . providers import ( generate_parser_model , generate_generate_component_name_macro , ) [EOL] from dbt . adapters . factory import get_adapter [EOL] from dbt . clients . jinja import get_rendered [EOL] from dbt . config import Project , RuntimeConfig [EOL] from dbt . context . context_config import ( ContextConfig ) [EOL] from dbt . contracts . files import ( SourceFile , FilePath , FileHash ) [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . graph . parsed import HasUniqueID [EOL] from dbt . contracts . graph . unparsed import UnparsedNode [EOL] from dbt . exceptions import ( CompilationException , validator_error_message , InternalException ) [EOL] from dbt import hooks [EOL] from dbt . node_types import NodeType [EOL] from dbt . parser . results import ParseResult , ManifestNodes [EOL] from dbt . parser . search import FileBlock [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] FinalValue = TypeVar ( [string] , bound = HasUniqueID ) [EOL] IntermediateValue = TypeVar ( [string] , bound = HasUniqueID ) [EOL] [EOL] IntermediateNode = TypeVar ( [string] , bound = Any ) [EOL] FinalNode = TypeVar ( [string] , bound = ManifestNodes ) [EOL] [EOL] [EOL] ConfiguredBlockType = TypeVar ( [string] , bound = FileBlock ) [EOL] [EOL] [EOL] class BaseParser ( Generic [ FinalValue ] ) : [EOL] def __init__ ( self , results , project ) : [EOL] self . results = results [EOL] self . project = project [EOL] [comment] [EOL] [comment] [EOL] self . searched = [ ] [EOL] [EOL] @ abc . abstractmethod def get_paths ( self ) : [EOL] pass [EOL] [EOL] def search ( self ) : [EOL] self . searched = list ( self . get_paths ( ) ) [EOL] return self . searched [EOL] [EOL] @ abc . abstractmethod def parse_file ( self , block ) : [EOL] pass [EOL] [EOL] @ abc . abstractproperty def resource_type ( self ) : [EOL] pass [EOL] [EOL] def generate_unique_id ( self , resource_name ) : [EOL] [docstring] [EOL] return [string] . format ( self . resource_type , self . project . project_name , resource_name ) [EOL] [EOL] def load_file ( self , path , * , set_contents = True , ) : [EOL] file_contents = load_file_contents ( path . absolute_path , strip = False ) [EOL] checksum = FileHash . from_contents ( file_contents ) [EOL] source_file = SourceFile ( path = path , checksum = checksum ) [EOL] if set_contents : [EOL] source_file . contents = file_contents . strip ( ) [EOL] else : [EOL] source_file . contents = [string] [EOL] return source_file [EOL] [EOL] [EOL] class Parser ( BaseParser [ FinalValue ] , Generic [ FinalValue ] ) : [EOL] def __init__ ( self , results , project , root_project , macro_manifest , ) : [EOL] super ( ) . __init__ ( results , project ) [EOL] self . root_project = root_project [EOL] self . macro_manifest = macro_manifest [EOL] [EOL] [EOL] class RelationUpdate : [EOL] def __init__ ( self , config , manifest , component ) : [EOL] macro = manifest . find_generate_macro_by_name ( component = component , root_project_name = config . project_name , ) [EOL] if macro is None : [EOL] raise InternalException ( f' [string] { component } [string] ' ) [EOL] [EOL] root_context = generate_generate_component_name_macro ( macro , config , manifest ) [EOL] self . updater = MacroGenerator ( macro , root_context ) [EOL] self . component = component [EOL] [EOL] def __call__ ( self , parsed_node , config_dict ) : [EOL] override = config_dict . get ( self . component ) [EOL] new_value = self . updater ( override , parsed_node ) [EOL] if isinstance ( new_value , str ) : [EOL] new_value = new_value . strip ( ) [EOL] setattr ( parsed_node , self . component , new_value ) [EOL] [EOL] [EOL] class ConfiguredParser ( Parser [ FinalNode ] , Generic [ ConfiguredBlockType , IntermediateNode , FinalNode ] , ) : [EOL] def __init__ ( self , results , project , root_project , macro_manifest , ) : [EOL] super ( ) . __init__ ( results , project , root_project , macro_manifest ) [EOL] [EOL] self . _update_node_database = RelationUpdate ( manifest = macro_manifest , config = root_project , component = [string] ) [EOL] self . _update_node_schema = RelationUpdate ( manifest = macro_manifest , config = root_project , component = [string] ) [EOL] self . _update_node_alias = RelationUpdate ( manifest = macro_manifest , config = root_project , component = [string] ) [EOL] [EOL] @ abc . abstractclassmethod def get_compiled_path ( cls , block ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def parse_from_dict ( self , dict , validate = True ) : [EOL] pass [EOL] [EOL] @ abc . abstractproperty def resource_type ( self ) : [EOL] pass [EOL] [EOL] @ property def default_schema ( self ) : [EOL] return self . root_project . credentials . schema [EOL] [EOL] @ property def default_database ( self ) : [EOL] return self . root_project . credentials . database [EOL] [EOL] def get_fqn_prefix ( self , path ) : [EOL] no_ext = os . path . splitext ( path ) [ [number] ] [EOL] fqn = [ self . project . project_name ] [EOL] fqn . extend ( utils . split_path ( no_ext ) [ : - [number] ] ) [EOL] return fqn [EOL] [EOL] def get_fqn ( self , path , name ) : [EOL] [docstring] [EOL] fqn = self . get_fqn_prefix ( path ) [EOL] fqn . append ( name ) [EOL] return fqn [EOL] [EOL] def _mangle_hooks ( self , config ) : [EOL] [docstring] [EOL] [comment] [EOL] for key in hooks . ModelHookType : [EOL] if key in config : [EOL] config [ key ] = [ hooks . get_hook_dict ( h ) for h in config [ key ] ] [EOL] [EOL] def _create_error_node ( self , name , path , original_file_path , raw_sql , ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] return UnparsedNode ( name = name , resource_type = self . resource_type , path = path , original_file_path = original_file_path , root_path = self . project . project_root , package_name = self . project . project_name , raw_sql = raw_sql , ) [EOL] [EOL] def _create_parsetime_node ( self , block , path , config , fqn , name = None , ** kwargs , ) : [EOL] [docstring] [EOL] if name is None : [EOL] name = block . name [EOL] dct = { [string] : name , [string] : self . default_schema , [string] : self . default_database , [string] : fqn , [string] : name , [string] : self . project . project_root , [string] : self . resource_type , [string] : path , [string] : block . path . original_file_path , [string] : self . project . project_name , [string] : block . contents , [string] : self . generate_unique_id ( name ) , [string] : self . config_dict ( config ) , [string] : block . file . checksum . to_dict ( ) , } [EOL] dct . update ( kwargs ) [EOL] try : [EOL] return self . parse_from_dict ( dct ) [EOL] except ValidationError as exc : [EOL] msg = validator_error_message ( exc ) [EOL] [comment] [EOL] [comment] [EOL] node = self . _create_error_node ( name = block . name , path = path , original_file_path = block . path . original_file_path , raw_sql = block . contents , ) [EOL] raise CompilationException ( msg , node = node ) [EOL] [EOL] def _context_for ( self , parsed_node , config ) : [EOL] return generate_parser_model ( parsed_node , self . root_project , self . macro_manifest , config ) [EOL] [EOL] def render_with_context ( self , parsed_node , config ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] with get_adapter ( self . root_project ) . connection_for ( parsed_node ) : [EOL] context = self . _context_for ( parsed_node , config ) [EOL] [EOL] get_rendered ( parsed_node . raw_sql , context , parsed_node , capture_macros = True ) [EOL] [EOL] def update_parsed_node_config ( self , parsed_node , config_dict ) : [EOL] [comment] [EOL] final_config_dict = parsed_node . config . to_dict ( ) [EOL] final_config_dict . update ( config_dict ) [EOL] [comment] [EOL] self . _mangle_hooks ( final_config_dict ) [EOL] parsed_node . config = parsed_node . config . from_dict ( final_config_dict ) [EOL] [EOL] def update_parsed_node_name ( self , parsed_node , config_dict ) : [EOL] self . _update_node_database ( parsed_node , config_dict ) [EOL] self . _update_node_schema ( parsed_node , config_dict ) [EOL] self . _update_node_alias ( parsed_node , config_dict ) [EOL] [EOL] def update_parsed_node ( self , parsed_node , config ) : [EOL] [docstring] [EOL] config_dict = config . build_config_dict ( ) [EOL] [EOL] [comment] [EOL] model_tags = config_dict . get ( [string] , [ ] ) [EOL] parsed_node . tags . extend ( model_tags ) [EOL] [EOL] parsed_node . unrendered_config = config . build_config_dict ( rendered = False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . update_parsed_node_config ( parsed_node , config_dict ) [EOL] self . update_parsed_node_name ( parsed_node , config_dict ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] hooks = list ( itertools . chain ( parsed_node . config . pre_hook , parsed_node . config . post_hook ) ) [EOL] [comment] [EOL] if not hooks : [EOL] return [EOL] [comment] [EOL] [comment] [EOL] context = self . _context_for ( parsed_node , config ) [EOL] for hook in hooks : [EOL] get_rendered ( hook . sql , context , parsed_node , capture_macros = True ) [EOL] [EOL] def initial_config ( self , fqn ) : [EOL] config_version = min ( [ self . project . config_version , self . root_project . config_version ] ) [EOL] if config_version == [number] : [EOL] return ContextConfig ( self . root_project , fqn , self . resource_type , self . project . project_name , ) [EOL] else : [EOL] raise InternalException ( f' [string] { config_version } [string] ' f' [string] ' ) [EOL] [EOL] def config_dict ( self , config , ) : [EOL] config_dict = config . build_config_dict ( base = True ) [EOL] self . _mangle_hooks ( config_dict ) [EOL] return config_dict [EOL] [EOL] def render_update ( self , node , config ) : [EOL] try : [EOL] self . render_with_context ( node , config ) [EOL] self . update_parsed_node ( node , config ) [EOL] except ValidationError as exc : [EOL] [comment] [EOL] msg = validator_error_message ( exc ) [EOL] raise CompilationException ( msg , node = node ) from exc [EOL] [EOL] def add_result_node ( self , block , node ) : [EOL] if node . config . enabled : [EOL] self . results . add_node ( block . file , node ) [EOL] else : [EOL] self . results . add_disabled ( block . file , node ) [EOL] [EOL] def parse_node ( self , block ) : [EOL] compiled_path = self . get_compiled_path ( block ) [EOL] fqn = self . get_fqn ( compiled_path , block . name ) [EOL] [EOL] config = self . initial_config ( fqn ) [EOL] [EOL] node = self . _create_parsetime_node ( block = block , path = compiled_path , config = config , fqn = fqn , ) [EOL] self . render_update ( node , config ) [EOL] result = self . transform ( node ) [EOL] self . add_result_node ( block , result ) [EOL] return result [EOL] [EOL] @ abc . abstractmethod def parse_file ( self , file_block ) : [EOL] pass [EOL] [EOL] @ abc . abstractmethod def transform ( self , node ) : [EOL] pass [EOL] [EOL] [EOL] class SimpleParser ( ConfiguredParser [ ConfiguredBlockType , FinalNode , FinalNode ] , Generic [ ConfiguredBlockType , FinalNode ] ) : [EOL] def transform ( self , node ) : [EOL] return node [EOL] [EOL] [EOL] class SQLParser ( ConfiguredParser [ FileBlock , IntermediateNode , FinalNode ] , Generic [ IntermediateNode , FinalNode ] ) : [EOL] def parse_file ( self , file_block ) : [EOL] self . parse_node ( file_block ) [EOL] [EOL] [EOL] class SimpleSQLParser ( SQLParser [ FinalNode , FinalNode ] ) : [EOL] def transform ( self , node ) : [EOL] return node [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $IntermediateNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 $IntermediateNode$ 0 0 0 0 0 0 0 0 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 $None$ 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $IntermediateNode$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 $IntermediateNode$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $IntermediateNode$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $IntermediateNode$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $IntermediateNode$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $IntermediateNode$ 0 0 0 $IntermediateNode$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $IntermediateNode$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $IntermediateNode$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $IntermediateNode$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $IntermediateNode$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $None$ 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 $typing.Any$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $IntermediateNode$ 0 0 0 0 0 $typing.Any$ 0 0 0 $IntermediateNode$ 0 0 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $IntermediateNode$ 0 $typing.Any$ 0 0 0 0 0 0 $IntermediateNode$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $IntermediateNode$ 0 0 0 0 0 0 0 0 $dbt.context.context_config.ContextConfig$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 $typing.Any$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 0 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 $IntermediateNode$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $IntermediateNode$ 0 $IntermediateNode$ 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 $dbt.parser.results.ManifestNodes$ 0 0 0 0 $dbt.parser.results.ManifestNodes$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 $dbt.parser.results.ManifestNodes$ 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 $dbt.parser.results.ManifestNodes$ 0 0 0 0 $FinalNode$ 0 0 0 $ConfiguredBlockType$ 0 0 0 $builtins.str$ 0 0 0 0 0 $ConfiguredBlockType$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $ConfiguredBlockType$ 0 0 0 0 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $ConfiguredBlockType$ 0 $ConfiguredBlockType$ 0 0 0 $builtins.str$ 0 $dbt.context.context_config.ContextConfig$ 0 $dbt.context.context_config.ContextConfig$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $dbt.context.context_config.ContextConfig$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $ConfiguredBlockType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 $FinalNode$ 0 0 0 $IntermediateNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from typing import List [EOL] [EOL] from hologram import ValidationError [EOL] [EOL] from dbt . contracts . graph . parsed import ( IntermediateSnapshotNode , ParsedSnapshotNode ) [EOL] from dbt . exceptions import ( CompilationException , validator_error_message ) [EOL] from dbt . node_types import NodeType [EOL] from dbt . parser . base import SQLParser [EOL] from dbt . parser . search import ( FilesystemSearcher , BlockContents , BlockSearcher , FileBlock ) [EOL] from dbt . utils import split_path [EOL] [EOL] [EOL] class SnapshotParser ( SQLParser [ IntermediateSnapshotNode , ParsedSnapshotNode ] ) : [EOL] def get_paths ( self ) : [EOL] return FilesystemSearcher ( self . project , self . project . snapshot_paths , [string] ) [EOL] [EOL] def parse_from_dict ( self , dct , validate = True ) : [EOL] return IntermediateSnapshotNode . from_dict ( dct , validate = validate ) [EOL] [EOL] @ property def resource_type ( self ) : [EOL] return NodeType . Snapshot [EOL] [EOL] @ classmethod def get_compiled_path ( cls , block ) : [EOL] return block . path . relative_path [EOL] [EOL] def set_snapshot_attributes ( self , node ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if node . config . target_database : [EOL] node . database = node . config . target_database [EOL] elif not node . database : [EOL] node . database = self . root_project . credentials . database [EOL] [EOL] [comment] [EOL] [comment] [EOL] node . schema = node . config . target_schema [EOL] [EOL] return node [EOL] [EOL] def get_fqn ( self , path , name ) : [EOL] [docstring] [EOL] no_ext = os . path . splitext ( path ) [ [number] ] [EOL] fqn = [ self . project . project_name ] [EOL] fqn . extend ( split_path ( no_ext ) ) [EOL] fqn . append ( name ) [EOL] return fqn [EOL] [EOL] def transform ( self , node ) : [EOL] try : [EOL] parsed_node = ParsedSnapshotNode . from_dict ( node . to_dict ( ) ) [EOL] self . set_snapshot_attributes ( parsed_node ) [EOL] return parsed_node [EOL] except ValidationError as exc : [EOL] raise CompilationException ( validator_error_message ( exc ) , node ) [EOL] [EOL] def parse_file ( self , file_block ) : [EOL] blocks = BlockSearcher ( source = [ file_block ] , allowed_blocks = { [string] } , source_tag_factory = BlockContents , ) [EOL] for block in blocks : [EOL] self . parse_node ( block ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . results . get_file ( file_block . file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedSnapshotNode$ 0 0 0 $dbt.contracts.graph.parsed.IntermediateSnapshotNode$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $dbt.contracts.graph.parsed.IntermediateSnapshotNode$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.IntermediateSnapshotNode$ 0 0 0 0 $None$ 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0
from typing import Any , List , Tuple , MutableMapping , Mapping , Type , TypeVar [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] from dataclasses import dataclass , field [EOL] from typing import TypeVar , MutableMapping , Mapping , Union , List [EOL] [EOL] from hologram import JsonSchemaMixin [EOL] [EOL] from dbt . contracts . files import RemoteFile , FileHash , SourceFile [EOL] from dbt . contracts . graph . compiled import CompileResultNode [EOL] from dbt . contracts . graph . parsed import ( HasUniqueID , ParsedAnalysisNode , ParsedDataTestNode , ParsedDocumentation , ParsedHookNode , ParsedMacro , ParsedMacroPatch , ParsedModelNode , ParsedNodePatch , ParsedReport , ParsedRPCNode , ParsedSeedNode , ParsedSchemaTestNode , ParsedSnapshotNode , UnpatchedSourceDefinition , ) [EOL] from dbt . contracts . graph . unparsed import SourcePatch [EOL] from dbt . contracts . util import Writable , Replaceable , MacroKey , SourceKey [EOL] from dbt . exceptions import ( raise_duplicate_resource_name , raise_duplicate_patch_name , raise_duplicate_macro_patch_name , CompilationException , InternalException , raise_compiler_error , raise_duplicate_source_patch_name ) [EOL] from dbt . node_types import NodeType [EOL] from dbt . ui import line_wrap_message [EOL] from dbt . version import __version__ [EOL] [EOL] [EOL] [comment] [EOL] ParsedValueType = TypeVar ( [string] , bound = HasUniqueID ) [EOL] [EOL] [EOL] def _check_duplicates ( value , src ) : [EOL] if value . unique_id in src : [EOL] raise_duplicate_resource_name ( value , src [ value . unique_id ] ) [EOL] [EOL] [EOL] ManifestNodes = Union [ ParsedAnalysisNode , ParsedDataTestNode , ParsedHookNode , ParsedModelNode , ParsedRPCNode , ParsedSchemaTestNode , ParsedSeedNode , ParsedSnapshotNode , ] [EOL] [EOL] [EOL] def dict_field ( ) : [EOL] return field ( default_factory = dict ) [EOL] [EOL] [EOL] @ dataclass class ParseResult ( JsonSchemaMixin , Writable , Replaceable ) : [EOL] vars_hash = ... [EOL] profile_hash = ... [EOL] project_hashes = ... [EOL] nodes = dict_field ( ) [EOL] sources = dict_field ( ) [EOL] docs = dict_field ( ) [EOL] macros = dict_field ( ) [EOL] reports = dict_field ( ) [EOL] macro_patches = dict_field ( ) [EOL] patches = dict_field ( ) [EOL] source_patches = dict_field ( ) [EOL] files = dict_field ( ) [EOL] disabled = dict_field ( ) [EOL] dbt_version = __version__ [EOL] [EOL] def get_file ( self , source_file ) : [EOL] key = source_file . search_key [EOL] if key is None : [EOL] return source_file [EOL] if key not in self . files : [EOL] self . files [ key ] = source_file [EOL] return self . files [ key ] [EOL] [EOL] def add_source ( self , source_file , source ) : [EOL] [comment] [EOL] _check_duplicates ( source , self . sources ) [EOL] self . sources [ source . unique_id ] = source [EOL] self . get_file ( source_file ) . sources . append ( source . unique_id ) [EOL] [EOL] def add_node_nofile ( self , node ) : [EOL] [comment] [EOL] _check_duplicates ( node , self . nodes ) [EOL] self . nodes [ node . unique_id ] = node [EOL] [EOL] def add_node ( self , source_file , node ) : [EOL] self . add_node_nofile ( node ) [EOL] self . get_file ( source_file ) . nodes . append ( node . unique_id ) [EOL] [EOL] def add_report ( self , source_file , report ) : [EOL] _check_duplicates ( report , self . reports ) [EOL] self . reports [ report . unique_id ] = report [EOL] self . get_file ( source_file ) . reports . append ( report . unique_id ) [EOL] [EOL] def add_disabled_nofile ( self , node ) : [EOL] if node . unique_id in self . disabled : [EOL] self . disabled [ node . unique_id ] . append ( node ) [EOL] else : [EOL] self . disabled [ node . unique_id ] = [ node ] [EOL] [EOL] def add_disabled ( self , source_file , node ) : [EOL] self . add_disabled_nofile ( node ) [EOL] self . get_file ( source_file ) . nodes . append ( node . unique_id ) [EOL] [EOL] def add_macro ( self , source_file , macro ) : [EOL] if macro . unique_id in self . macros : [EOL] [comment] [EOL] other_path = self . macros [ macro . unique_id ] . original_file_path [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] msg = line_wrap_message ( f''' [string] { macro . name } [string] { macro . package_name } [string] { macro . original_file_path } [string] { other_path } [string] ''' , subtract = [number] ) [EOL] raise_compiler_error ( msg ) [EOL] [EOL] self . macros [ macro . unique_id ] = macro [EOL] self . get_file ( source_file ) . macros . append ( macro . unique_id ) [EOL] [EOL] def add_doc ( self , source_file , doc ) : [EOL] _check_duplicates ( doc , self . docs ) [EOL] self . docs [ doc . unique_id ] = doc [EOL] self . get_file ( source_file ) . docs . append ( doc . unique_id ) [EOL] [EOL] def add_patch ( self , source_file , patch ) : [EOL] [comment] [EOL] if patch . name in self . patches : [EOL] raise_duplicate_patch_name ( patch , self . patches [ patch . name ] ) [EOL] self . patches [ patch . name ] = patch [EOL] self . get_file ( source_file ) . patches . append ( patch . name ) [EOL] [EOL] def add_macro_patch ( self , source_file , patch ) : [EOL] [comment] [EOL] key = ( patch . package_name , patch . name ) [EOL] if key in self . macro_patches : [EOL] raise_duplicate_macro_patch_name ( patch , self . macro_patches [ key ] ) [EOL] self . macro_patches [ key ] = patch [EOL] self . get_file ( source_file ) . macro_patches . append ( key ) [EOL] [EOL] def add_source_patch ( self , source_file , patch ) : [EOL] [comment] [EOL] key = ( patch . overrides , patch . name ) [EOL] if key in self . source_patches : [EOL] raise_duplicate_source_patch_name ( patch , self . source_patches [ key ] ) [EOL] self . source_patches [ key ] = patch [EOL] self . get_file ( source_file ) . source_patches . append ( key ) [EOL] [EOL] def _get_disabled ( self , unique_id , match_file , ) : [EOL] if unique_id not in self . disabled : [EOL] raise InternalException ( [string] . format ( unique_id ) ) [EOL] return [ n for n in self . disabled [ unique_id ] if n . original_file_path == match_file . path . original_file_path ] [EOL] [EOL] def _process_node ( self , node_id , source_file , old_file , old_result , ) : [EOL] [docstring] [EOL] source_path = source_file . path . original_file_path [EOL] found = False [EOL] if node_id in old_result . nodes : [EOL] old_node = old_result . nodes [ node_id ] [EOL] if old_node . original_file_path == source_path : [EOL] self . add_node ( source_file , old_node ) [EOL] found = True [EOL] [EOL] if node_id in old_result . disabled : [EOL] matches = old_result . _get_disabled ( node_id , source_file ) [EOL] for match in matches : [EOL] self . add_disabled ( source_file , match ) [EOL] found = True [EOL] [EOL] if not found : [EOL] raise CompilationException ( [string] [string] . format ( node_id , old_file ) ) [EOL] [EOL] def sanitized_update ( self , source_file , old_result , resource_type , ) : [EOL] [docstring] [EOL] if isinstance ( source_file . path , RemoteFile ) : [EOL] return False [EOL] [EOL] old_file = old_result . get_file ( source_file ) [EOL] for doc_id in old_file . docs : [EOL] doc = _expect_value ( doc_id , old_result . docs , old_file , [string] ) [EOL] self . add_doc ( source_file , doc ) [EOL] [EOL] for macro_id in old_file . macros : [EOL] macro = _expect_value ( macro_id , old_result . macros , old_file , [string] ) [EOL] self . add_macro ( source_file , macro ) [EOL] [EOL] for source_id in old_file . sources : [EOL] source = _expect_value ( source_id , old_result . sources , old_file , [string] ) [EOL] self . add_source ( source_file , source ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for node_id in old_file . nodes : [EOL] [comment] [EOL] [comment] [EOL] if resource_type != node_id . split ( [string] ) [ [number] ] : [EOL] continue [EOL] self . _process_node ( node_id , source_file , old_file , old_result ) [EOL] [EOL] for report_id in old_file . reports : [EOL] report = _expect_value ( report_id , old_result . reports , old_file , [string] ) [EOL] self . add_report ( source_file , report ) [EOL] [EOL] patched = False [EOL] for name in old_file . patches : [EOL] patch = _expect_value ( name , old_result . patches , old_file , [string] ) [EOL] self . add_patch ( source_file , patch ) [EOL] patched = True [EOL] if patched : [EOL] self . get_file ( source_file ) . patches . sort ( ) [EOL] [EOL] macro_patched = False [EOL] for key in old_file . macro_patches : [EOL] macro_patch = _expect_value ( key , old_result . macro_patches , old_file , [string] ) [EOL] self . add_macro_patch ( source_file , macro_patch ) [EOL] macro_patched = True [EOL] if macro_patched : [EOL] self . get_file ( source_file ) . macro_patches . sort ( ) [EOL] [EOL] return True [EOL] [EOL] def has_file ( self , source_file ) : [EOL] key = source_file . search_key [EOL] if key is None : [EOL] return False [EOL] if key not in self . files : [EOL] return False [EOL] my_checksum = self . files [ key ] . checksum [EOL] return my_checksum == source_file . checksum [EOL] [EOL] @ classmethod def rpc ( cls ) : [EOL] [comment] [EOL] return cls ( FileHash . empty ( ) , FileHash . empty ( ) , { } ) [EOL] [EOL] [EOL] K_T = TypeVar ( [string] ) [EOL] V_T = TypeVar ( [string] ) [EOL] [EOL] [EOL] def _expect_value ( key , src , old_file , name ) : [EOL] if key not in src : [EOL] raise CompilationException ( [string] [string] . format ( key , name , old_file ) ) [EOL] return src [ key ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.FileHash$ 0 0 0 $dbt.contracts.files.FileHash$ 0 0 0 $typing.MutableMapping[builtins.str,dbt.contracts.files.FileHash]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[dbt.contracts.graph.compiled.CompileResultNode]$ 0 0 0 $builtins.str$ 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $dbt.contracts.files.SourceFile$ 0 $dbt.contracts.files.SourceFile$ 0 $'ParseResult'$ 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 $'ParseResult'$ 0 0 0 0 $typing.Any$ 0 $'ParseResult'$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 $'ParseResult'$ 0 0 0 0 0 0 $'ParseResult'$ 0 0 0 $builtins.str$ 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $dbt.contracts.files.SourceFile$ 0 $'ParseResult'$ 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $'ParseResult'$ 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $'ParseResult'$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $'ParseResult'$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $'ParseResult'$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 $'ParseResult'$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $'ParseResult'$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $'ParseResult'$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $'ParseResult'$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.files.SourceFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , Any , List , Optional [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] import abc [EOL] import os [EOL] import tempfile [EOL] from contextlib import contextmanager [EOL] from typing import List , Optional , Generic , TypeVar [EOL] [EOL] from dbt . clients import system [EOL] from dbt . contracts . project import ProjectPackageMetadata [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] [EOL] DOWNLOADS_PATH = None [EOL] [EOL] [EOL] def get_downloads_path ( ) : [EOL] return DOWNLOADS_PATH [EOL] [EOL] [EOL] @ contextmanager def downloads_directory ( ) : [EOL] global DOWNLOADS_PATH [EOL] remove_downloads = False [EOL] [comment] [EOL] [comment] [EOL] if DOWNLOADS_PATH is None : [EOL] DOWNLOADS_PATH = os . getenv ( [string] ) [EOL] remove_downloads = False [EOL] [comment] [EOL] [comment] [EOL] if DOWNLOADS_PATH is None : [EOL] DOWNLOADS_PATH = tempfile . mkdtemp ( prefix = [string] ) [EOL] remove_downloads = True [EOL] [EOL] system . make_directory ( DOWNLOADS_PATH ) [EOL] logger . debug ( [string] . format ( DOWNLOADS_PATH ) ) [EOL] [EOL] yield DOWNLOADS_PATH [EOL] [EOL] if remove_downloads : [EOL] system . rmtree ( DOWNLOADS_PATH ) [EOL] DOWNLOADS_PATH = None [EOL] [EOL] [EOL] class BasePackage ( metaclass = abc . ABCMeta ) : [EOL] @ abc . abstractproperty def name ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def all_names ( self ) : [EOL] return [ self . name ] [EOL] [EOL] @ abc . abstractmethod def source_type ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class PinnedPackage ( BasePackage ) : [EOL] def __init__ ( self ) : [EOL] self . _cached_metadata = None [EOL] [EOL] def __str__ ( self ) : [EOL] version = self . get_version ( ) [EOL] if not version : [EOL] return self . name [EOL] [EOL] return [string] . format ( self . name , version ) [EOL] [EOL] @ abc . abstractmethod def get_version ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abc . abstractmethod def _fetch_metadata ( self , project , renderer ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abc . abstractmethod def install ( self , project ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abc . abstractmethod def nice_version_name ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def fetch_metadata ( self , project , renderer ) : [EOL] if not self . _cached_metadata : [EOL] self . _cached_metadata = self . _fetch_metadata ( project , renderer ) [EOL] return self . _cached_metadata [EOL] [EOL] def get_project_name ( self , project , renderer ) : [EOL] metadata = self . fetch_metadata ( project , renderer ) [EOL] return metadata . name [EOL] [EOL] def get_installation_path ( self , project , renderer ) : [EOL] dest_dirname = self . get_project_name ( project , renderer ) [EOL] return os . path . join ( project . modules_path , dest_dirname ) [EOL] [EOL] [EOL] SomePinned = TypeVar ( [string] , bound = PinnedPackage ) [EOL] SomeUnpinned = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [EOL] class UnpinnedPackage ( Generic [ SomePinned ] , BasePackage ) : [EOL] @ abc . abstractclassmethod def from_contract ( cls , contract ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abc . abstractmethod def incorporate ( self , other ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abc . abstractmethod def resolved ( self ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[dbt.contracts.project.ProjectPackageMetadata]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SomeUnpinned$ 0 $SomeUnpinned$ 0 $SomeUnpinned$ 0 0 0 0 0 0 0 0 0 0 0 0 $SomePinned$ 0 0 0 0 0 0 0 0
from typing import Any , List , Set [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import hashlib [EOL] from typing import List [EOL] [EOL] from dbt . clients import git , system [EOL] from dbt . config import Project [EOL] from dbt . contracts . project import ( ProjectPackageMetadata , GitPackage , ) [EOL] from dbt . deps . base import PinnedPackage , UnpinnedPackage , get_downloads_path [EOL] from dbt . exceptions import ( ExecutableError , warn_or_error , raise_dependency_error ) [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt import ui [EOL] [EOL] PIN_PACKAGE_URL = [string] [comment] [EOL] [EOL] [EOL] def md5sum ( s ) : [EOL] return hashlib . md5 ( s . encode ( [string] ) ) . hexdigest ( ) [EOL] [EOL] [EOL] class GitPackageMixin : [EOL] def __init__ ( self , git ) : [EOL] super ( ) . __init__ ( ) [EOL] self . git = git [EOL] [EOL] @ property def name ( self ) : [EOL] return self . git [EOL] [EOL] def source_type ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class GitPinnedPackage ( GitPackageMixin , PinnedPackage ) : [EOL] def __init__ ( self , git , revision , warn_unpinned = True ) : [EOL] super ( ) . __init__ ( git ) [EOL] self . revision = revision [EOL] self . warn_unpinned = warn_unpinned [EOL] self . _checkout_name = md5sum ( self . git ) [EOL] [EOL] def get_version ( self ) : [EOL] return self . revision [EOL] [EOL] def nice_version_name ( self ) : [EOL] return [string] . format ( self . revision ) [EOL] [EOL] def _checkout ( self ) : [EOL] [docstring] [EOL] try : [EOL] dir_ = git . clone_and_checkout ( self . git , get_downloads_path ( ) , branch = self . revision , dirname = self . _checkout_name ) [EOL] except ExecutableError as exc : [EOL] if exc . cmd and exc . cmd [ [number] ] == [string] : [EOL] logger . error ( [string] [string] [string] ) [EOL] raise [EOL] return os . path . join ( get_downloads_path ( ) , dir_ ) [EOL] [EOL] def _fetch_metadata ( self , project , renderer ) : [EOL] path = self . _checkout ( ) [EOL] if self . revision == [string] and self . warn_unpinned : [EOL] warn_or_error ( [string] [string] . format ( self . git , PIN_PACKAGE_URL ) , log_fmt = ui . yellow ( [string] ) ) [EOL] loaded = Project . from_project_root ( path , renderer ) [EOL] return ProjectPackageMetadata . from_project ( loaded ) [EOL] [EOL] def install ( self , project , renderer ) : [EOL] dest_path = self . get_installation_path ( project , renderer ) [EOL] if os . path . exists ( dest_path ) : [EOL] if system . path_is_symlink ( dest_path ) : [EOL] system . remove_file ( dest_path ) [EOL] else : [EOL] system . rmdir ( dest_path ) [EOL] [EOL] system . move ( self . _checkout ( ) , dest_path ) [EOL] [EOL] [EOL] class GitUnpinnedPackage ( GitPackageMixin , UnpinnedPackage [ GitPinnedPackage ] ) : [EOL] def __init__ ( self , git , revisions , warn_unpinned = True ) : [EOL] super ( ) . __init__ ( git ) [EOL] self . revisions = revisions [EOL] self . warn_unpinned = warn_unpinned [EOL] [EOL] @ classmethod def from_contract ( cls , contract ) : [EOL] revisions = contract . get_revisions ( ) [EOL] [EOL] [comment] [EOL] warn_unpinned = contract . warn_unpinned is not False [EOL] return cls ( git = contract . git , revisions = revisions , warn_unpinned = warn_unpinned ) [EOL] [EOL] def all_names ( self ) : [EOL] if self . git . endswith ( [string] ) : [EOL] other = self . git [ : - [number] ] [EOL] else : [EOL] other = self . git + [string] [EOL] return [ self . git , other ] [EOL] [EOL] def incorporate ( self , other ) : [EOL] warn_unpinned = self . warn_unpinned and other . warn_unpinned [EOL] [EOL] return GitUnpinnedPackage ( git = self . git , revisions = self . revisions + other . revisions , warn_unpinned = warn_unpinned , ) [EOL] [EOL] def resolved ( self ) : [EOL] requested = set ( self . revisions ) [EOL] if len ( requested ) == [number] : [EOL] requested = { [string] } [EOL] elif len ( requested ) > [number] : [EOL] raise_dependency_error ( [string] [string] . format ( self . git , requested ) ) [EOL] [EOL] return GitPinnedPackage ( git = self . git , revision = requested . pop ( ) , warn_unpinned = self . warn_unpinned ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $dbt.contracts.project.ProjectPackageMetadata$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $'GitUnpinnedPackage'$ 0 0 0 $dbt.contracts.project.GitPackage$ 0 0 0 $typing.Any$ 0 $dbt.contracts.project.GitPackage$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $dbt.contracts.project.GitPackage$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.project.GitPackage$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $'GitUnpinnedPackage'$ 0 0 0 $'GitUnpinnedPackage'$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $'GitUnpinnedPackage'$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'GitUnpinnedPackage'$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $GitPinnedPackage$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from typing import List [EOL] [EOL] from dbt import semver [EOL] from dbt . clients import registry , system [EOL] from dbt . contracts . project import ( RegistryPackageMetadata , RegistryPackage , ) [EOL] from dbt . deps . base import PinnedPackage , UnpinnedPackage , get_downloads_path [EOL] from dbt . exceptions import ( package_version_not_found , VersionsNotCompatibleException , DependencyException , package_not_found , ) [EOL] [EOL] [EOL] class RegistryPackageMixin : [EOL] def __init__ ( self , package ) : [EOL] super ( ) . __init__ ( ) [EOL] self . package = package [EOL] [EOL] @ property def name ( self ) : [EOL] return self . package [EOL] [EOL] def source_type ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class RegistryPinnedPackage ( RegistryPackageMixin , PinnedPackage ) : [EOL] def __init__ ( self , package , version ) : [EOL] super ( ) . __init__ ( package ) [EOL] self . version = version [EOL] [EOL] @ property def name ( self ) : [EOL] return self . package [EOL] [EOL] def source_type ( self ) : [EOL] return [string] [EOL] [EOL] def get_version ( self ) : [EOL] return self . version [EOL] [EOL] def nice_version_name ( self ) : [EOL] return [string] . format ( self . version ) [EOL] [EOL] def _fetch_metadata ( self , project , renderer ) : [EOL] dct = registry . package_version ( self . package , self . version ) [EOL] return RegistryPackageMetadata . from_dict ( dct ) [EOL] [EOL] def install ( self , project , renderer ) : [EOL] metadata = self . fetch_metadata ( project , renderer ) [EOL] [EOL] tar_name = [string] . format ( self . package , self . version ) [EOL] tar_path = os . path . realpath ( os . path . join ( get_downloads_path ( ) , tar_name ) ) [EOL] system . make_directory ( os . path . dirname ( tar_path ) ) [EOL] [EOL] download_url = metadata . downloads . tarball [EOL] system . download ( download_url , tar_path ) [EOL] deps_path = project . modules_path [EOL] package_name = self . get_project_name ( project , renderer ) [EOL] system . untar_package ( tar_path , deps_path , package_name ) [EOL] [EOL] [EOL] class RegistryUnpinnedPackage ( RegistryPackageMixin , UnpinnedPackage [ RegistryPinnedPackage ] ) : [EOL] def __init__ ( self , package , versions ) : [EOL] super ( ) . __init__ ( package ) [EOL] self . versions = versions [EOL] [EOL] def _check_in_index ( self ) : [EOL] index = registry . index_cached ( ) [EOL] if self . package not in index : [EOL] package_not_found ( self . package ) [EOL] [EOL] @ classmethod def from_contract ( cls , contract ) : [EOL] raw_version = contract . get_versions ( ) [EOL] [EOL] versions = [ semver . VersionSpecifier . from_version_string ( v ) for v in raw_version ] [EOL] return cls ( package = contract . package , versions = versions ) [EOL] [EOL] def incorporate ( self , other ) : [EOL] return RegistryUnpinnedPackage ( package = self . package , versions = self . versions + other . versions , ) [EOL] [EOL] def resolved ( self ) : [EOL] self . _check_in_index ( ) [EOL] try : [EOL] range_ = semver . reduce_versions ( * self . versions ) [EOL] except VersionsNotCompatibleException as e : [EOL] new_msg = ( [string] . format ( self . name , e ) ) [EOL] raise DependencyException ( new_msg ) from e [EOL] [EOL] available = registry . get_available_versions ( self . package ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] target = semver . resolve_to_specific_version ( range_ , available ) [EOL] if not target : [EOL] package_version_not_found ( self . package , range_ , available ) [EOL] return RegistryPinnedPackage ( package = self . package , version = target ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.project.RegistryPackageMetadata$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $'RegistryUnpinnedPackage'$ 0 0 0 $dbt.contracts.project.RegistryPackage$ 0 0 0 $typing.Any$ 0 $dbt.contracts.project.RegistryPackage$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $dbt.contracts.project.RegistryPackage$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 $'RegistryUnpinnedPackage'$ 0 0 0 $'RegistryUnpinnedPackage'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'RegistryUnpinnedPackage'$ 0 0 0 0 0 0 0 $RegistryPinnedPackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] import shutil [EOL] [EOL] from dbt . clients import system [EOL] from dbt . deps . base import PinnedPackage , UnpinnedPackage [EOL] from dbt . contracts . project import ( ProjectPackageMetadata , LocalPackage , ) [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] [EOL] [EOL] class LocalPackageMixin : [EOL] def __init__ ( self , local ) : [EOL] super ( ) . __init__ ( ) [EOL] self . local = local [EOL] [EOL] @ property def name ( self ) : [EOL] return self . local [EOL] [EOL] def source_type ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class LocalPinnedPackage ( LocalPackageMixin , PinnedPackage ) : [EOL] def __init__ ( self , local ) : [EOL] super ( ) . __init__ ( local ) [EOL] [EOL] def get_version ( self ) : [EOL] return None [EOL] [EOL] def nice_version_name ( self ) : [EOL] return [string] . format ( self . local ) [EOL] [EOL] def resolve_path ( self , project ) : [EOL] return system . resolve_path_from_base ( self . local , project . project_root , ) [EOL] [EOL] def _fetch_metadata ( self , project , renderer ) : [EOL] loaded = project . from_project_root ( self . resolve_path ( project ) , renderer ) [EOL] return ProjectPackageMetadata . from_project ( loaded ) [EOL] [EOL] def install ( self , project , renderer ) : [EOL] src_path = self . resolve_path ( project ) [EOL] dest_path = self . get_installation_path ( project , renderer ) [EOL] [EOL] can_create_symlink = system . supports_symlinks ( ) [EOL] [EOL] if system . path_exists ( dest_path ) : [EOL] if not system . path_is_symlink ( dest_path ) : [EOL] system . rmdir ( dest_path ) [EOL] else : [EOL] system . remove_file ( dest_path ) [EOL] [EOL] if can_create_symlink : [EOL] logger . debug ( [string] ) [EOL] system . make_symlink ( src_path , dest_path ) [EOL] [EOL] else : [EOL] logger . debug ( [string] [string] ) [EOL] shutil . copytree ( src_path , dest_path ) [EOL] [EOL] [EOL] class LocalUnpinnedPackage ( LocalPackageMixin , UnpinnedPackage [ LocalPinnedPackage ] ) : [EOL] @ classmethod def from_contract ( cls , contract ) : [EOL] return cls ( local = contract . local ) [EOL] [EOL] def incorporate ( self , other ) : [EOL] return LocalUnpinnedPackage ( local = self . local ) [EOL] [EOL] def resolved ( self ) : [EOL] return LocalPinnedPackage ( local = self . local ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'LocalUnpinnedPackage'$ 0 0 0 $dbt.contracts.project.LocalPackage$ 0 0 0 0 0 0 0 0 $dbt.contracts.project.LocalPackage$ 0 0 0 0 0 0 $'LocalUnpinnedPackage'$ 0 0 0 $'LocalUnpinnedPackage'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LocalPinnedPackage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set , Dict , Type , NoReturn , Iterator [EOL] import core [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] from dataclasses import dataclass , field [EOL] from typing import Dict , List , NoReturn , Union , Type , Iterator , Set [EOL] [EOL] from dbt . exceptions import raise_dependency_error , InternalException [EOL] [EOL] from dbt . context . target import generate_target_context [EOL] from dbt . config import Project , RuntimeConfig [EOL] from dbt . config . renderer import DbtProjectYamlRenderer [EOL] from dbt . deps . base import BasePackage , PinnedPackage , UnpinnedPackage [EOL] from dbt . deps . local import LocalUnpinnedPackage [EOL] from dbt . deps . git import GitUnpinnedPackage [EOL] from dbt . deps . registry import RegistryUnpinnedPackage [EOL] [EOL] from dbt . contracts . project import ( LocalPackage , GitPackage , RegistryPackage , ) [EOL] [EOL] PackageContract = Union [ LocalPackage , GitPackage , RegistryPackage ] [EOL] [EOL] [EOL] @ dataclass class PackageListing : [EOL] packages = field ( default_factory = dict ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . packages ) [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( self . packages ) [EOL] [EOL] def _pick_key ( self , key ) : [EOL] for name in key . all_names ( ) : [EOL] if name in self . packages : [EOL] return name [EOL] return key . name [EOL] [EOL] def __contains__ ( self , key ) : [EOL] for name in key . all_names ( ) : [EOL] if name in self . packages : [EOL] return True [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] key_str = self . _pick_key ( key ) [EOL] return self . packages [ key_str ] [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] key_str = self . _pick_key ( key ) [EOL] self . packages [ key_str ] = value [EOL] [EOL] def _mismatched_types ( self , old , new ) : [EOL] raise_dependency_error ( f' [string] { new } [string] { new . __class__ . __name__ } [string] { old } [string] ' f' [string] { old . __class__ . __name__ } [string] ' ) [EOL] [EOL] def incorporate ( self , package ) : [EOL] key = self . _pick_key ( package ) [EOL] if key in self . packages : [EOL] existing = self . packages [ key ] [EOL] if not isinstance ( existing , type ( package ) ) : [EOL] self . _mismatched_types ( existing , package ) [EOL] self . packages [ key ] = existing . incorporate ( package ) [EOL] else : [EOL] self . packages [ key ] = package [EOL] [EOL] def update_from ( self , src ) : [EOL] pkg = ... [EOL] for contract in src : [EOL] if isinstance ( contract , LocalPackage ) : [EOL] pkg = LocalUnpinnedPackage . from_contract ( contract ) [EOL] elif isinstance ( contract , GitPackage ) : [EOL] pkg = GitUnpinnedPackage . from_contract ( contract ) [EOL] elif isinstance ( contract , RegistryPackage ) : [EOL] pkg = RegistryUnpinnedPackage . from_contract ( contract ) [EOL] else : [EOL] raise InternalException ( [string] . format ( type ( contract ) ) ) [EOL] self . incorporate ( pkg ) [EOL] [EOL] @ classmethod def from_contracts ( cls , src ) : [EOL] self = cls ( { } ) [EOL] self . update_from ( src ) [EOL] return self [EOL] [EOL] def resolved ( self ) : [EOL] return [ p . resolved ( ) for p in self . packages . values ( ) ] [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . packages . values ( ) ) [EOL] [EOL] [EOL] def _check_for_duplicate_project_names ( final_deps , config , renderer , ) : [EOL] seen = set ( ) [EOL] for package in final_deps : [EOL] project_name = package . get_project_name ( config , renderer ) [EOL] if project_name in seen : [EOL] raise_dependency_error ( f' [string] { project_name } [string] ' [string] [string] ) [EOL] elif project_name == config . project_name : [EOL] raise_dependency_error ( [string] f' [string] { project_name } [string] ' [string] ) [EOL] seen . add ( project_name ) [EOL] [EOL] [EOL] def resolve_packages ( packages , config ) : [EOL] pending = PackageListing . from_contracts ( packages ) [EOL] final = PackageListing ( ) [EOL] [EOL] ctx = generate_target_context ( config , config . cli_vars ) [EOL] renderer = DbtProjectYamlRenderer ( ctx ) [EOL] [EOL] while pending : [EOL] next_pending = PackageListing ( ) [EOL] [comment] [EOL] for package in pending : [EOL] final . incorporate ( package ) [EOL] target = final [ package ] . resolved ( ) . fetch_metadata ( config , renderer ) [EOL] next_pending . update_from ( target . packages ) [EOL] pending = next_pending [EOL] [EOL] resolved = final . resolved ( ) [EOL] _check_for_duplicate_project_names ( resolved , config , renderer ) [EOL] return resolved [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[dbt.deps.base.UnpinnedPackage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from dataclasses import dataclass [EOL] from hologram import JsonSchemaMixin [EOL] [EOL] from typing import List , Dict , Any , Union [EOL] [EOL] [EOL] @ dataclass class SelectorDefinition ( JsonSchemaMixin ) : [EOL] name = ... [EOL] definition = ... [EOL] [EOL] [EOL] @ dataclass class SelectorFile ( JsonSchemaMixin ) : [EOL] selectors = ... [EOL] version = [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[SelectorDefinition]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , Callable , List , Tuple , Set , Optional , Dict , ClassVar [EOL] import hologram [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import abc [EOL] import itertools [EOL] from dataclasses import dataclass , field [EOL] from typing import ( Any , ClassVar , Dict , Tuple , Iterable , Optional , NewType , List , Callable , ) [EOL] from typing_extensions import Protocol [EOL] [EOL] from hologram import JsonSchemaMixin [EOL] from hologram . helpers import ( StrEnum , register_pattern , ExtensibleJsonSchemaMixin ) [EOL] [EOL] from dbt . contracts . util import Replaceable [EOL] from dbt . exceptions import InternalException [EOL] from dbt . utils import translate_aliases [EOL] [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] [EOL] [EOL] Identifier = NewType ( [string] , str ) [EOL] register_pattern ( Identifier , [string] ) [EOL] [EOL] [EOL] class ConnectionState ( StrEnum ) : [EOL] INIT = [string] [EOL] OPEN = [string] [EOL] CLOSED = [string] [EOL] FAIL = [string] [EOL] [EOL] [EOL] @ dataclass ( init = False ) class Connection ( ExtensibleJsonSchemaMixin , Replaceable ) : [EOL] type = ... [EOL] name = ... [EOL] state = ConnectionState . INIT [EOL] transaction_open = False [EOL] [comment] [EOL] _handle = None [EOL] _credentials = field ( init = False ) [EOL] [EOL] def __init__ ( self , type , name , credentials , state = ConnectionState . INIT , transaction_open = False , handle = None , ) : [EOL] self . type = type [EOL] self . name = name [EOL] self . state = state [EOL] self . credentials = credentials [EOL] self . transaction_open = transaction_open [EOL] self . handle = handle [EOL] [EOL] @ property def credentials ( self ) : [EOL] return self . _credentials [EOL] [EOL] @ credentials . setter def credentials ( self , value ) : [EOL] self . _credentials = value [EOL] [EOL] @ property def handle ( self ) : [EOL] if isinstance ( self . _handle , LazyHandle ) : [EOL] try : [EOL] [comment] [EOL] self . _handle . resolve ( self ) [EOL] except RecursionError as exc : [EOL] raise InternalException ( [string] [string] ) from exc [EOL] return self . _handle [EOL] [EOL] @ handle . setter def handle ( self , value ) : [EOL] self . _handle = value [EOL] [EOL] [EOL] class LazyHandle : [EOL] [docstring] [EOL] def __init__ ( self , opener ) : [EOL] self . opener = opener [EOL] [EOL] def resolve ( self , connection ) : [EOL] logger . debug ( [string] . format ( connection . state ) ) [EOL] return self . opener ( connection ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ dataclass class Credentials ( ExtensibleJsonSchemaMixin , Replaceable , metaclass = abc . ABCMeta ) : [EOL] database = ... [EOL] schema = ... [EOL] _ALIASES = field ( default = { } , init = False ) [EOL] [EOL] @ abc . abstractproperty def type ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def connection_info ( self , * , with_aliases = False ) : [EOL] [docstring] [EOL] as_dict = self . to_dict ( omit_none = False , with_aliases = with_aliases ) [EOL] connection_keys = set ( self . _connection_keys ( ) ) [EOL] aliases = [ ] [EOL] if with_aliases : [EOL] aliases = [ k for k , v in self . _ALIASES . items ( ) if v in connection_keys ] [EOL] for key in itertools . chain ( self . _connection_keys ( ) , aliases ) : [EOL] if key in as_dict : [EOL] yield key , as_dict [ key ] [EOL] [EOL] @ abc . abstractmethod def _connection_keys ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] data = cls . translate_aliases ( data ) [EOL] return super ( ) . from_dict ( data ) [EOL] [EOL] @ classmethod def translate_aliases ( cls , kwargs , recurse = False ) : [EOL] return translate_aliases ( kwargs , cls . _ALIASES , recurse ) [EOL] [EOL] def to_dict ( self , omit_none = True , validate = False , * , with_aliases = False ) : [EOL] serialized = super ( ) . to_dict ( omit_none = omit_none , validate = validate ) [EOL] if with_aliases : [EOL] serialized . update ( { new_name : serialized [ canonical_name ] for new_name , canonical_name in self . _ALIASES . items ( ) if canonical_name in serialized } ) [EOL] return serialized [EOL] [EOL] [EOL] class UserConfigContract ( Protocol ) : [EOL] send_anonymous_usage_stats = ... [EOL] use_colors = ... [EOL] partial_parse = ... [EOL] printer_width = ... [EOL] [EOL] def set_values ( self , cookie_dir ) : [EOL] ... [EOL] [EOL] def to_dict ( self , omit_none = True , validate = False ) : [EOL] ... [EOL] [EOL] [EOL] class HasCredentials ( Protocol ) : [EOL] credentials = ... [EOL] profile_name = ... [EOL] config = ... [EOL] target_name = ... [EOL] threads = ... [EOL] [EOL] def to_target_dict ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [EOL] DEFAULT_QUERY_COMMENT = [string] [EOL] [EOL] [EOL] @ dataclass class QueryComment ( JsonSchemaMixin ) : [EOL] comment = DEFAULT_QUERY_COMMENT [EOL] append = False [EOL] [EOL] [EOL] class AdapterRequiredConfig ( HasCredentials , Protocol ) : [EOL] project_name = ... [EOL] query_comment = ... [EOL] cli_vars = ... [EOL] target_path = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Identifier$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $core.dbt.contracts.connection.Identifier$ 0 $typing.Optional[builtins.str]$ 0 0 0 $core.dbt.contracts.connection.ConnectionState$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.contracts.connection.Identifier$ 0 $core.dbt.contracts.connection.Identifier$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $core.dbt.contracts.connection.ConnectionState$ 0 $core.dbt.contracts.connection.ConnectionState$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[core.dbt.contracts.connection.Connection],core.dbt.contracts.connection.Connection]$ 0 0 0 0 0 $typing.Callable[[core.dbt.contracts.connection.Connection],core.dbt.contracts.connection.Connection]$ 0 $typing.Callable[[core.dbt.contracts.connection.Connection],core.dbt.contracts.connection.Connection]$ 0 0 0 $Connection$ 0 0 0 $Connection$ 0 0 0 0 0 0 0 0 0 0 0 $Connection$ 0 0 0 0 0 0 0 0 0 0 $Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.ClassVar[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Credentials$ 0 0 0 $builtins.str$ 0 0 0 $UserConfigContract$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $QueryComment$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List , Set , Union , Optional , Dict [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] from dbt . contracts . util import Replaceable , Mergeable , list_str [EOL] from dbt . contracts . connection import UserConfigContract , QueryComment [EOL] from dbt . helper_types import NoValue [EOL] from dbt . logger import GLOBAL_LOGGER as logger [comment] [EOL] from dbt import tracking [EOL] from dbt import ui [EOL] [EOL] from hologram import JsonSchemaMixin , ValidationError [EOL] from hologram . helpers import HyphenatedJsonSchemaMixin , register_pattern , ExtensibleJsonSchemaMixin [EOL] [EOL] from dataclasses import dataclass , field [EOL] from typing import Optional , List , Dict , Union , Any , NewType [EOL] [EOL] PIN_PACKAGE_URL = [string] [comment] [EOL] DEFAULT_SEND_ANONYMOUS_USAGE_STATS = True [EOL] [EOL] [EOL] Name = NewType ( [string] , str ) [EOL] register_pattern ( Name , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] SemverString = NewType ( [string] , str ) [EOL] register_pattern ( SemverString , [string] , ) [EOL] [EOL] [EOL] @ dataclass class Quoting ( JsonSchemaMixin , Mergeable ) : [EOL] identifier = ... [EOL] schema = ... [EOL] database = ... [EOL] project = ... [EOL] [EOL] [EOL] @ dataclass class Package ( Replaceable , HyphenatedJsonSchemaMixin ) : [EOL] pass [EOL] [EOL] [EOL] @ dataclass class LocalPackage ( Package ) : [EOL] local = ... [EOL] [EOL] [EOL] [comment] [EOL] RawVersion = Union [ str , float ] [EOL] [EOL] [EOL] @ dataclass class GitPackage ( Package ) : [EOL] git = ... [EOL] revision = ... [EOL] warn_unpinned = None [EOL] [EOL] def get_revisions ( self ) : [EOL] if self . revision is None : [EOL] return [ ] [EOL] else : [EOL] return [ str ( self . revision ) ] [EOL] [EOL] [EOL] @ dataclass class RegistryPackage ( Package ) : [EOL] package = ... [EOL] version = ... [EOL] [EOL] def get_versions ( self ) : [EOL] if isinstance ( self . version , list ) : [EOL] return [ str ( v ) for v in self . version ] [EOL] else : [EOL] return [ str ( self . version ) ] [EOL] [EOL] [EOL] PackageSpec = Union [ LocalPackage , GitPackage , RegistryPackage ] [EOL] [EOL] [EOL] @ dataclass class PackageConfig ( JsonSchemaMixin , Replaceable ) : [EOL] packages = ... [EOL] [EOL] [EOL] @ dataclass class ProjectPackageMetadata : [EOL] name = ... [EOL] packages = ... [EOL] [EOL] @ classmethod def from_project ( cls , project ) : [EOL] return cls ( name = project . project_name , packages = project . packages . packages ) [EOL] [EOL] [EOL] @ dataclass class Downloads ( ExtensibleJsonSchemaMixin , Replaceable ) : [EOL] tarball = ... [EOL] [EOL] [EOL] @ dataclass class RegistryPackageMetadata ( ExtensibleJsonSchemaMixin , ProjectPackageMetadata , ) : [EOL] downloads = ... [EOL] [EOL] [EOL] [comment] [EOL] BANNED_PROJECT_NAMES = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] [EOL] @ dataclass class Project ( HyphenatedJsonSchemaMixin , Replaceable ) : [EOL] name = ... [EOL] version = ... [EOL] config_version = ... [EOL] project_root = None [EOL] source_paths = None [EOL] macro_paths = None [EOL] data_paths = None [EOL] test_paths = None [EOL] analysis_paths = None [EOL] docs_paths = None [EOL] asset_paths = None [EOL] target_path = None [EOL] snapshot_paths = None [EOL] clean_targets = None [EOL] profile = None [EOL] log_path = None [EOL] modules_path = None [EOL] quoting = None [EOL] on_run_start = field ( default_factory = list_str ) [EOL] on_run_end = field ( default_factory = list_str ) [EOL] require_dbt_version = None [EOL] models = field ( default_factory = dict ) [EOL] seeds = field ( default_factory = dict ) [EOL] snapshots = field ( default_factory = dict ) [EOL] analyses = field ( default_factory = dict ) [EOL] sources = field ( default_factory = dict ) [EOL] vars = field ( default = None , metadata = dict ( description = [string] , ) , ) [EOL] packages = field ( default_factory = list ) [EOL] query_comment = NoValue ( ) [EOL] [EOL] @ classmethod def from_dict ( cls , data , validate = True ) : [EOL] result = super ( ) . from_dict ( data , validate = validate ) [EOL] if result . name in BANNED_PROJECT_NAMES : [EOL] raise ValidationError ( f' [string] { result . name } [string] ' ) [EOL] [EOL] return result [EOL] [EOL] [EOL] @ dataclass class UserConfig ( ExtensibleJsonSchemaMixin , Replaceable , UserConfigContract ) : [EOL] send_anonymous_usage_stats = DEFAULT_SEND_ANONYMOUS_USAGE_STATS [EOL] use_colors = None [EOL] partial_parse = None [EOL] printer_width = None [EOL] [EOL] def set_values ( self , cookie_dir ) : [EOL] if self . send_anonymous_usage_stats : [EOL] tracking . initialize_tracking ( cookie_dir ) [EOL] else : [EOL] tracking . do_not_track ( ) [EOL] [EOL] if self . use_colors is not None : [EOL] ui . use_colors ( self . use_colors ) [EOL] [EOL] if self . printer_width : [EOL] ui . printer_width ( self . printer_width ) [EOL] [EOL] [EOL] @ dataclass class ProfileConfig ( HyphenatedJsonSchemaMixin , Replaceable ) : [EOL] profile_name = field ( metadata = { [string] : True } ) [EOL] target_name = field ( metadata = { [string] : True } ) [EOL] config = ... [EOL] threads = ... [EOL] [comment] [EOL] credentials = ... [EOL] [EOL] [EOL] @ dataclass class ConfiguredQuoting ( Quoting , Replaceable ) : [EOL] identifier = ... [EOL] schema = ... [EOL] database = ... [EOL] project = ... [EOL] [EOL] [EOL] @ dataclass class Configuration ( Project , ProfileConfig ) : [EOL] cli_vars = field ( default_factory = dict , metadata = { [string] : True } , ) [EOL] quoting = None [EOL] [EOL] [EOL] @ dataclass class ProjectList ( JsonSchemaMixin ) : [EOL] projects = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[RawVersion]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[RawVersion,typing.List[RawVersion]]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[PackageSpec]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[PackageSpec]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Downloads$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Name$ 0 0 0 $typing.Union[SemverString,builtins.float]$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[Quoting]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[PackageSpec]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[dbt.contracts.connection.QueryComment,dbt.helper_types.NoValue,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $'Project'$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $UserConfig$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ConfiguredQuoting]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Project]$ 0 0 0
from typing import Optional [EOL] import core [EOL] import pathlib [EOL] import typing [EOL] from pathlib import Path [EOL] from . graph . manifest import WritableManifest [EOL] from typing import Optional [EOL] [EOL] [EOL] class PreviousState : [EOL] def __init__ ( self , path ) : [EOL] self . path = path [EOL] self . manifest = None [EOL] [EOL] manifest_path = self . path / [string] [EOL] if manifest_path . exists ( ) and manifest_path . is_file ( ) : [EOL] self . manifest = WritableManifest . read ( str ( manifest_path ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.Optional[core.dbt.contracts.graph.manifest.WritableManifest]$ 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.Optional[core.dbt.contracts.graph.manifest.WritableManifest]$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0
	0
from typing import Any , List , Dict , Type , Tuple [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import dataclasses [EOL] from typing import List , Tuple [EOL] [EOL] from dbt . clients . system import write_json , read_json [EOL] from dbt . exceptions import RuntimeException [EOL] [EOL] [EOL] MacroKey = Tuple [ str , str ] [EOL] SourceKey = Tuple [ str , str ] [EOL] [EOL] [EOL] def list_str ( ) : [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] [EOL] class Replaceable : [EOL] def replace ( self , ** kwargs ) : [EOL] return dataclasses . replace ( self , ** kwargs ) [EOL] [EOL] [EOL] class Mergeable ( Replaceable ) : [EOL] def merged ( self , * args ) : [EOL] [docstring] [EOL] replacements = { } [EOL] cls = type ( self ) [EOL] for arg in args : [EOL] for field in dataclasses . fields ( cls ) : [EOL] value = getattr ( arg , field . name ) [EOL] if value is not None : [EOL] replacements [ field . name ] = value [EOL] [EOL] return self . replace ( ** replacements ) [EOL] [EOL] [EOL] class Writable : [EOL] def write ( self , path , omit_none = False ) : [EOL] write_json ( path , self . to_dict ( omit_none = omit_none ) ) [comment] [EOL] [EOL] [EOL] class AdditionalPropertiesMixin : [EOL] [docstring] [EOL] ADDITIONAL_PROPERTIES = True [EOL] [EOL] @ classmethod def from_dict ( cls , data , validate = True ) : [EOL] self = super ( ) . from_dict ( data = data , validate = validate ) [EOL] keys = self . to_dict ( validate = False , omit_none = False ) [EOL] for key , value in data . items ( ) : [EOL] if key not in keys : [EOL] self . extra [ key ] = value [EOL] return self [EOL] [EOL] def to_dict ( self , omit_none = True , validate = False ) : [EOL] data = super ( ) . to_dict ( omit_none = omit_none , validate = validate ) [EOL] data . update ( self . extra ) [EOL] return data [EOL] [EOL] def replace ( self , ** kwargs ) : [EOL] dct = self . to_dict ( omit_none = False , validate = False ) [EOL] dct . update ( kwargs ) [EOL] return self . from_dict ( dct ) [EOL] [EOL] @ property def extra ( self ) : [EOL] return self . _extra [EOL] [EOL] [EOL] class Readable : [EOL] @ classmethod def read ( cls , path ) : [EOL] try : [EOL] data = read_json ( path ) [EOL] except ( EnvironmentError , ValueError ) as exc : [EOL] raise RuntimeException ( f' [string] { cls . __name__ } [string] { path } [string] { exc }' ) from exc [EOL] [EOL] return cls . from_dict ( data ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Type[core.dbt.contracts.util.Mergeable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[core.dbt.contracts.util.Mergeable]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Any , List , Dict , Optional , Type [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] from dbt . contracts . graph . parsed import ( HasTestMetadata , ParsedNode , ParsedAnalysisNode , ParsedDataTestNode , ParsedHookNode , ParsedModelNode , ParsedReport , ParsedResource , ParsedRPCNode , ParsedSchemaTestNode , ParsedSeedNode , ParsedSnapshotNode , ParsedSourceDefinition , SeedConfig , TestConfig , same_seeds , ) [EOL] from dbt . node_types import NodeType [EOL] from dbt . contracts . util import Replaceable [EOL] [EOL] from hologram import JsonSchemaMixin [EOL] from dataclasses import dataclass , field [EOL] from typing import Optional , List , Union , Dict , Type [EOL] [EOL] [EOL] @ dataclass class InjectedCTE ( JsonSchemaMixin , Replaceable ) : [EOL] id = ... [EOL] sql = ... [EOL] [EOL] [EOL] @ dataclass class CompiledNodeMixin ( JsonSchemaMixin ) : [EOL] [comment] [EOL] [comment] [EOL] compiled = ... [EOL] [EOL] [EOL] @ dataclass class CompiledNode ( ParsedNode , CompiledNodeMixin ) : [EOL] compiled_sql = None [EOL] extra_ctes_injected = False [EOL] extra_ctes = field ( default_factory = list ) [EOL] injected_sql = None [EOL] [EOL] def set_cte ( self , cte_id , sql ) : [EOL] [docstring] [EOL] for cte in self . extra_ctes : [EOL] if cte . id == cte_id : [EOL] cte . sql = sql [EOL] break [EOL] else : [EOL] self . extra_ctes . append ( InjectedCTE ( id = cte_id , sql = sql ) ) [EOL] [EOL] [EOL] @ dataclass class CompiledAnalysisNode ( CompiledNode ) : [EOL] resource_type = field ( metadata = { [string] : [ NodeType . Analysis ] } ) [EOL] [EOL] [EOL] @ dataclass class CompiledHookNode ( CompiledNode ) : [EOL] resource_type = field ( metadata = { [string] : [ NodeType . Operation ] } ) [EOL] index = None [EOL] [EOL] [EOL] @ dataclass class CompiledModelNode ( CompiledNode ) : [EOL] resource_type = field ( metadata = { [string] : [ NodeType . Model ] } ) [EOL] [EOL] [EOL] @ dataclass class CompiledRPCNode ( CompiledNode ) : [EOL] resource_type = field ( metadata = { [string] : [ NodeType . RPCCall ] } ) [EOL] [EOL] [EOL] @ dataclass class CompiledSeedNode ( CompiledNode ) : [EOL] [comment] [EOL] resource_type = field ( metadata = { [string] : [ NodeType . Seed ] } ) [EOL] config = field ( default_factory = SeedConfig ) [EOL] [EOL] @ property def empty ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] def same_body ( self , other ) : [EOL] return same_seeds ( self , other ) [EOL] [EOL] [EOL] @ dataclass class CompiledSnapshotNode ( CompiledNode ) : [EOL] resource_type = field ( metadata = { [string] : [ NodeType . Snapshot ] } ) [EOL] [EOL] [EOL] @ dataclass class CompiledDataTestNode ( CompiledNode ) : [EOL] resource_type = field ( metadata = { [string] : [ NodeType . Test ] } ) [EOL] config = field ( default_factory = TestConfig ) [EOL] [EOL] [EOL] @ dataclass class CompiledSchemaTestNode ( CompiledNode , HasTestMetadata ) : [EOL] [comment] [EOL] resource_type = field ( metadata = { [string] : [ NodeType . Test ] } ) [EOL] column_name = None [EOL] config = field ( default_factory = TestConfig ) [EOL] [EOL] def same_config ( self , other ) : [EOL] return ( self . unrendered_config . get ( [string] ) == other . unrendered_config . get ( [string] ) ) [EOL] [EOL] def same_column_name ( self , other ) : [EOL] return self . column_name == other . column_name [EOL] [EOL] def same_contents ( self , other ) : [EOL] if other is None : [EOL] return False [EOL] [EOL] return ( self . same_config ( other ) and self . same_fqn ( other ) and True ) [EOL] [EOL] [EOL] CompiledTestNode = Union [ CompiledDataTestNode , CompiledSchemaTestNode ] [EOL] [EOL] [EOL] PARSED_TYPES = { CompiledAnalysisNode : ParsedAnalysisNode , CompiledModelNode : ParsedModelNode , CompiledHookNode : ParsedHookNode , CompiledRPCNode : ParsedRPCNode , CompiledSeedNode : ParsedSeedNode , CompiledSnapshotNode : ParsedSnapshotNode , CompiledDataTestNode : ParsedDataTestNode , CompiledSchemaTestNode : ParsedSchemaTestNode , } [EOL] [EOL] [EOL] COMPILED_TYPES = { ParsedAnalysisNode : CompiledAnalysisNode , ParsedModelNode : CompiledModelNode , ParsedHookNode : CompiledHookNode , ParsedRPCNode : CompiledRPCNode , ParsedSeedNode : CompiledSeedNode , ParsedSnapshotNode : CompiledSnapshotNode , ParsedDataTestNode : CompiledDataTestNode , ParsedSchemaTestNode : CompiledSchemaTestNode , } [EOL] [EOL] [EOL] [comment] [EOL] CompiledType = Union [ Type [ CompiledNode ] , Type [ ParsedResource ] ] [EOL] CompiledResource = Union [ ParsedResource , CompiledNode ] [EOL] [EOL] [EOL] def compiled_type_for ( parsed ) : [EOL] if type ( parsed ) in COMPILED_TYPES : [EOL] return COMPILED_TYPES [ type ( parsed ) ] [EOL] else : [EOL] return type ( parsed ) [EOL] [EOL] [EOL] def parsed_instance_for ( compiled ) : [EOL] cls = PARSED_TYPES . get ( type ( compiled ) ) [EOL] if cls is None : [EOL] [comment] [EOL] raise ValueError ( [string] . format ( compiled . resource_type ) ) [EOL] [EOL] [comment] [EOL] return cls . from_dict ( compiled . to_dict ( ) , validate = False ) [EOL] [EOL] [EOL] NonSourceCompiledNode = Union [ CompiledAnalysisNode , CompiledDataTestNode , CompiledModelNode , CompiledHookNode , CompiledRPCNode , CompiledSchemaTestNode , CompiledSeedNode , CompiledSnapshotNode , ] [EOL] [EOL] NonSourceParsedNode = Union [ ParsedAnalysisNode , ParsedDataTestNode , ParsedHookNode , ParsedModelNode , ParsedRPCNode , ParsedSchemaTestNode , ParsedSeedNode , ParsedSnapshotNode , ] [EOL] [EOL] [EOL] [comment] [EOL] ManifestNode = Union [ NonSourceCompiledNode , NonSourceParsedNode , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] CompileResultNode = Union [ ManifestNode , ParsedSourceDefinition , ] [EOL] [EOL] [comment] [EOL] GraphMemberNode = Union [ CompileResultNode , ParsedReport , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.SeedConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.TestConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.node_types.NodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $dbt.contracts.graph.parsed.TestConfig$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import requests [EOL] from functools import wraps [EOL] import requests [EOL] from dbt . exceptions import RegistryException [EOL] from dbt . utils import memoized [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] import os [EOL] import time [EOL] [EOL] if os . getenv ( [string] ) : [EOL] DEFAULT_REGISTRY_BASE_URL = os . getenv ( [string] ) [EOL] else : [EOL] DEFAULT_REGISTRY_BASE_URL = [string] [EOL] [EOL] [EOL] def _get_url ( url , registry_base_url = None ) : [EOL] if registry_base_url is None : [EOL] registry_base_url = DEFAULT_REGISTRY_BASE_URL [EOL] [EOL] return [string] . format ( registry_base_url , url ) [EOL] [EOL] [EOL] def _wrap_exceptions ( fn ) : [EOL] @ wraps ( fn ) def wrapper ( * args , ** kwargs ) : [EOL] max_attempts = [number] [EOL] attempt = [number] [EOL] while True : [EOL] attempt += [number] [EOL] try : [EOL] return fn ( * args , ** kwargs ) [EOL] except requests . exceptions . ConnectionError as exc : [EOL] if attempt < max_attempts : [EOL] time . sleep ( [number] ) [EOL] continue [EOL] [EOL] raise RegistryException ( [string] ) from exc [EOL] return wrapper [EOL] [EOL] [EOL] @ _wrap_exceptions def _get ( path , registry_base_url = None ) : [EOL] url = _get_url ( path , registry_base_url ) [EOL] logger . debug ( [string] . format ( url ) ) [EOL] resp = requests . get ( url ) [EOL] logger . debug ( [string] . format ( url , resp . status_code ) ) [EOL] resp . raise_for_status ( ) [EOL] return resp . json ( ) [EOL] [EOL] [EOL] def index ( registry_base_url = None ) : [EOL] return _get ( [string] , registry_base_url ) [EOL] [EOL] [EOL] index_cached = memoized ( index ) [EOL] [EOL] [EOL] def packages ( registry_base_url = None ) : [EOL] return _get ( [string] , registry_base_url ) [EOL] [EOL] [EOL] def package ( name , registry_base_url = None ) : [EOL] return _get ( [string] . format ( name ) , registry_base_url ) [EOL] [EOL] [EOL] def package_version ( name , version , registry_base_url = None ) : [EOL] return _get ( [string] . format ( name , version ) , registry_base_url ) [EOL] [EOL] [EOL] def get_available_versions ( name ) : [EOL] response = package ( name ) [EOL] return list ( response [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Match , Optional [EOL] import typing [EOL] import re [EOL] import os . path [EOL] [EOL] from dbt . clients . system import run_cmd , rmdir [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] import dbt . exceptions [EOL] [EOL] [EOL] def clone ( repo , cwd , dirname = None , remove_git_dir = False , branch = None ) : [EOL] clone_cmd = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] if branch is not None : [EOL] clone_cmd . extend ( [ [string] , branch ] ) [EOL] [EOL] clone_cmd . append ( repo ) [EOL] [EOL] if dirname is not None : [EOL] clone_cmd . append ( dirname ) [EOL] [EOL] result = run_cmd ( cwd , clone_cmd , env = { [string] : [string] } ) [EOL] [EOL] if remove_git_dir : [EOL] rmdir ( os . path . join ( dirname , [string] ) ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def list_tags ( cwd ) : [EOL] out , err = run_cmd ( cwd , [ [string] , [string] , [string] ] , env = { [string] : [string] } ) [EOL] tags = out . decode ( [string] ) . strip ( ) . split ( [string] ) [EOL] return tags [EOL] [EOL] [EOL] def _checkout ( cwd , repo , branch ) : [EOL] logger . debug ( [string] . format ( branch ) ) [EOL] [EOL] run_cmd ( cwd , [ [string] , [string] , [string] , [string] , branch ] ) [EOL] run_cmd ( cwd , [ [string] , [string] , [string] , [string] , [string] , [string] , branch ] ) [EOL] [EOL] tags = list_tags ( cwd ) [EOL] [EOL] [comment] [EOL] if branch in tags : [EOL] spec = [string] . format ( branch ) [EOL] else : [EOL] spec = [string] . format ( branch ) [EOL] [EOL] out , err = run_cmd ( cwd , [ [string] , [string] , [string] , spec ] , env = { [string] : [string] } ) [EOL] return out , err [EOL] [EOL] [EOL] def checkout ( cwd , repo , branch = None ) : [EOL] if branch is None : [EOL] branch = [string] [EOL] try : [EOL] return _checkout ( cwd , repo , branch ) [EOL] except dbt . exceptions . CommandResultError as exc : [EOL] stderr = exc . stderr . decode ( [string] ) . strip ( ) [EOL] dbt . exceptions . bad_package_spec ( repo , branch , stderr ) [EOL] [EOL] [EOL] def get_current_sha ( cwd ) : [EOL] out , err = run_cmd ( cwd , [ [string] , [string] , [string] ] , env = { [string] : [string] } ) [EOL] [EOL] return out . decode ( [string] ) [EOL] [EOL] [EOL] def remove_remote ( cwd ) : [EOL] return run_cmd ( cwd , [ [string] , [string] , [string] , [string] ] , env = { [string] : [string] } ) [EOL] [EOL] [EOL] def clone_and_checkout ( repo , cwd , dirname = None , remove_git_dir = False , branch = None ) : [EOL] exists = None [EOL] try : [EOL] _ , err = clone ( repo , cwd , dirname = dirname , remove_git_dir = remove_git_dir ) [EOL] except dbt . exceptions . CommandResultError as exc : [EOL] err = exc . stderr . decode ( [string] ) [EOL] exists = re . match ( [string] , err ) [EOL] if not exists : [comment] [EOL] raise [EOL] [EOL] directory = None [EOL] start_sha = None [EOL] if exists : [EOL] directory = exists . group ( [number] ) [EOL] logger . debug ( [string] , directory ) [EOL] else : [EOL] matches = re . match ( [string] , err . decode ( [string] ) ) [EOL] if matches is None : [EOL] raise dbt . exceptions . RuntimeException ( f' [string] { repo } [string] ' ) [EOL] directory = matches . group ( [number] ) [EOL] logger . debug ( [string] , directory ) [EOL] full_path = os . path . join ( cwd , directory ) [EOL] start_sha = get_current_sha ( full_path ) [EOL] checkout ( full_path , repo , branch ) [EOL] end_sha = get_current_sha ( full_path ) [EOL] if exists : [EOL] if start_sha == end_sha : [EOL] logger . debug ( [string] , start_sha [ : [number] ] ) [EOL] else : [EOL] logger . debug ( [string] , start_sha [ : [number] ] , end_sha [ : [number] ] ) [EOL] else : [EOL] logger . debug ( [string] , end_sha [ : [number] ] ) [EOL] return directory [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import dbt . exceptions [EOL] [EOL] import yaml [EOL] import yaml . scanner [EOL] [EOL] [comment] [EOL] YamlLoader = ... [EOL] try : [EOL] from yaml import CSafeLoader as YamlLoader [EOL] except ImportError : [EOL] from yaml import SafeLoader as YamlLoader [EOL] [EOL] [EOL] YAML_ERROR_MESSAGE = [string] . strip ( ) [EOL] [EOL] [EOL] def line_no ( i , line , width = [number] ) : [EOL] line_number = str ( i ) . ljust ( width ) [EOL] return [string] . format ( line_number , line ) [EOL] [EOL] [EOL] def prefix_with_line_numbers ( string , no_start , no_end ) : [EOL] line_list = string . split ( [string] ) [EOL] [EOL] numbers = range ( no_start , no_end ) [EOL] relevant_lines = line_list [ no_start : no_end ] [EOL] [EOL] return [string] . join ( [ line_no ( i + [number] , line ) for ( i , line ) in zip ( numbers , relevant_lines ) ] ) [EOL] [EOL] [EOL] def contextualized_yaml_error ( raw_contents , error ) : [EOL] mark = error . problem_mark [EOL] [EOL] min_line = max ( mark . line - [number] , [number] ) [EOL] max_line = mark . line + [number] [EOL] [EOL] nice_error = prefix_with_line_numbers ( raw_contents , min_line , max_line ) [EOL] [EOL] return YAML_ERROR_MESSAGE . format ( line_number = mark . line + [number] , nice_error = nice_error , raw_error = error ) [EOL] [EOL] [EOL] def safe_load ( contents ) : [EOL] return yaml . load ( contents , Loader = YamlLoader ) [EOL] [EOL] [EOL] def load_yaml_text ( contents ) : [EOL] try : [EOL] return safe_load ( contents ) [EOL] except ( yaml . scanner . ScannerError , yaml . YAMLError ) as e : [EOL] if hasattr ( e , [string] ) : [EOL] error = contextualized_yaml_error ( contents , e ) [EOL] else : [EOL] error = str ( e ) [EOL] [EOL] raise dbt . exceptions . ValidationException ( error ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , List , Optional , Dict [EOL] import agate [EOL] import builtins [EOL] import typing [EOL] from codecs import BOM_UTF8 [EOL] [EOL] import agate [EOL] import datetime [EOL] import isodate [EOL] import json [EOL] import dbt . utils [EOL] from typing import Iterable , List , Dict , Union , Optional , Any [EOL] [EOL] from dbt . exceptions import RuntimeException [EOL] [EOL] [EOL] BOM = BOM_UTF8 . decode ( [string] ) [comment] [EOL] [EOL] [EOL] class ISODateTime ( agate . data_types . DateTime ) : [EOL] def cast ( self , d ) : [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( d , datetime . datetime ) or d is None : [EOL] return d [EOL] elif isinstance ( d , datetime . date ) : [EOL] return datetime . datetime . combine ( d , datetime . time ( [number] , [number] , [number] ) ) [EOL] elif isinstance ( d , str ) : [EOL] d = d . strip ( ) [EOL] if d . lower ( ) in self . null_values : [EOL] return None [EOL] try : [EOL] return isodate . parse_datetime ( d ) [EOL] except : [comment] [EOL] pass [EOL] [EOL] raise agate . exceptions . CastError ( [string] % d ) [EOL] [EOL] [EOL] def build_type_tester ( text_columns ) : [EOL] types = [ agate . data_types . Number ( null_values = ( [string] , [string] ) ) , agate . data_types . Date ( null_values = ( [string] , [string] ) , date_format = [string] ) , agate . data_types . DateTime ( null_values = ( [string] , [string] ) , datetime_format = [string] ) , ISODateTime ( null_values = ( [string] , [string] ) ) , agate . data_types . Boolean ( true_values = ( [string] , ) , false_values = ( [string] , ) , null_values = ( [string] , [string] ) ) , agate . data_types . Text ( null_values = ( [string] , [string] ) ) ] [EOL] force = { k : agate . data_types . Text ( null_values = ( [string] , [string] ) ) for k in text_columns } [EOL] return agate . TypeTester ( force = force , types = types ) [EOL] [EOL] [EOL] DEFAULT_TYPE_TESTER = build_type_tester ( ( ) ) [EOL] [EOL] [EOL] def table_from_rows ( rows , column_names , text_only_columns = None , ) : [EOL] if text_only_columns is None : [EOL] column_types = DEFAULT_TYPE_TESTER [EOL] else : [EOL] column_types = build_type_tester ( text_only_columns ) [EOL] return agate . Table ( rows , column_names , column_types = column_types ) [EOL] [EOL] [EOL] def table_from_data ( data , column_names ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if len ( data ) == [number] : [EOL] return agate . Table ( [ ] , column_names = column_names ) [EOL] else : [EOL] table = agate . Table . from_object ( data , column_types = DEFAULT_TYPE_TESTER ) [EOL] return table . select ( column_names ) [EOL] [EOL] [EOL] def table_from_data_flat ( data , column_names ) : [EOL] [docstring] [EOL] [EOL] rows = [ ] [EOL] for _row in data : [EOL] row = [ ] [EOL] for value in list ( _row . values ( ) ) : [EOL] if isinstance ( value , ( dict , list , tuple ) ) : [EOL] row . append ( json . dumps ( value , cls = dbt . utils . JSONEncoder ) ) [EOL] else : [EOL] row . append ( value ) [EOL] rows . append ( row ) [EOL] [EOL] return table_from_rows ( rows = rows , column_names = column_names ) [EOL] [EOL] [EOL] def empty_table ( ) : [EOL] [docstring] [EOL] [EOL] return agate . Table ( rows = [ ] ) [EOL] [EOL] [EOL] def as_matrix ( table ) : [EOL] [docstring] [EOL] [EOL] return [ r . values ( ) for r in table . rows . values ( ) ] [EOL] [EOL] [EOL] def from_csv ( abspath , text_columns ) : [EOL] type_tester = build_type_tester ( text_columns = text_columns ) [EOL] with open ( abspath , encoding = [string] ) as fp : [EOL] if fp . read ( [number] ) != BOM : [EOL] fp . seek ( [number] ) [EOL] return agate . Table . from_csv ( fp , column_types = type_tester ) [EOL] [EOL] [EOL] class _NullMarker : [EOL] pass [EOL] [EOL] [EOL] NullableAgateType = Union [ agate . data_types . DataType , _NullMarker ] [EOL] [EOL] [EOL] class ColumnTypeBuilder ( Dict [ str , NullableAgateType ] ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] if key not in self : [EOL] super ( ) . __setitem__ ( key , value ) [EOL] return [EOL] [EOL] existing_type = self [ key ] [EOL] if isinstance ( existing_type , _NullMarker ) : [EOL] [comment] [EOL] super ( ) . __setitem__ ( key , value ) [EOL] elif isinstance ( value , _NullMarker ) : [EOL] [comment] [EOL] return [EOL] elif not isinstance ( value , type ( existing_type ) ) : [EOL] [comment] [EOL] raise RuntimeException ( f' [string] { key } [string] ' f' [string] { value } [string] { existing_type } [string] ' ) [EOL] [EOL] def finalize ( self ) : [EOL] result = { } [EOL] for key , value in self . items ( ) : [EOL] if isinstance ( value , _NullMarker ) : [EOL] [comment] [EOL] result [ key ] = agate . data_types . Number ( ) [EOL] else : [EOL] result [ key ] = value [EOL] return result [EOL] [EOL] [EOL] def _merged_column_types ( tables ) : [EOL] [comment] [EOL] [comment] [EOL] new_columns = ColumnTypeBuilder ( ) [EOL] for table in tables : [EOL] for i in range ( len ( table . columns ) ) : [EOL] column_name = table . column_names [ i ] [EOL] column_type = table . column_types [ i ] [EOL] [comment] [EOL] if all ( x is None for x in table . columns [ column_name ] ) : [EOL] column_type = _NullMarker ( ) [EOL] new_columns [ column_name ] = column_type [EOL] [EOL] return new_columns . finalize ( ) [EOL] [EOL] [EOL] def merge_tables ( tables ) : [EOL] [docstring] [EOL] new_columns = _merged_column_types ( tables ) [EOL] column_names = tuple ( new_columns . keys ( ) ) [EOL] column_types = tuple ( new_columns . values ( ) ) [EOL] [EOL] rows = [ ] [EOL] for table in tables : [EOL] if ( table . column_names == column_names and table . column_types == column_types ) : [EOL] rows . extend ( table . rows ) [EOL] else : [EOL] for row in table . rows : [EOL] data = [ row . get ( name , None ) for name in column_names ] [EOL] rows . append ( agate . Row ( data , column_names ) ) [EOL] [comment] [EOL] return agate . Table ( rows , column_names , column_types , _is_fork = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $agate.TypeTester$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $agate.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $agate.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $agate.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,agate.data_types.DataType]$ 0 0 0 0 0 $typing.Dict[builtins.str,agate.data_types.DataType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,agate.data_types.DataType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,agate.data_types.DataType]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,agate.data_types.DataType]$ 0 0 0 0 $typing.Dict[builtins.str,agate.data_types.DataType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $agate.Table$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , Dict , Set [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import re [EOL] from collections import namedtuple [EOL] [EOL] import dbt . exceptions [EOL] [EOL] [EOL] def regex ( pat ) : [EOL] return re . compile ( pat , re . DOTALL | re . MULTILINE ) [EOL] [EOL] [EOL] class BlockData : [EOL] [docstring] [EOL] def __init__ ( self , contents ) : [EOL] self . block_type_name = [string] [EOL] self . contents = contents [EOL] self . full_block = contents [EOL] [EOL] [EOL] class BlockTag : [EOL] def __init__ ( self , block_type_name , block_name , contents = None , full_block = None , ** kw ) : [EOL] self . block_type_name = block_type_name [EOL] self . block_name = block_name [EOL] self . contents = contents [EOL] self . full_block = full_block [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . block_type_name , self . block_name ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self ) [EOL] [EOL] @ property def end_block_type_name ( self ) : [EOL] return [string] . format ( self . block_type_name ) [EOL] [EOL] def end_pat ( self ) : [EOL] [comment] [EOL] [comment] [EOL] pattern = [string] . join ( ( [string] , self . end_block_type_name , [string] , ) ) [EOL] return regex ( pattern ) [EOL] [EOL] [EOL] Tag = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] _NAME_PATTERN = [string] [EOL] [EOL] COMMENT_START_PATTERN = regex ( [string] ) [EOL] COMMENT_END_PATTERN = regex ( [string] ) [EOL] RAW_START_PATTERN = regex ( [string] ) [EOL] EXPR_START_PATTERN = regex ( [string] ) [EOL] EXPR_END_PATTERN = regex ( [string] ) [EOL] [EOL] BLOCK_START_PATTERN = regex ( [string] . join ( ( [string] , [string] . format ( _NAME_PATTERN ) , [string] . format ( _NAME_PATTERN ) , ) ) ) [EOL] [EOL] [EOL] RAW_BLOCK_PATTERN = regex ( [string] . join ( ( [string] , [string] , [string] , ) ) ) [EOL] [EOL] TAG_CLOSE_PATTERN = regex ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] STRING_PATTERN = regex ( [string] [string] ) [EOL] [EOL] QUOTE_START_PATTERN = regex ( [string] ) [EOL] [EOL] [EOL] class TagIterator : [EOL] def __init__ ( self , data ) : [EOL] self . data = data [EOL] self . blocks = [ ] [EOL] self . _parenthesis_stack = [ ] [EOL] self . pos = [number] [EOL] [EOL] def linepos ( self , end = None ) : [EOL] [docstring] [EOL] end_val = self . pos if end is None else end [EOL] data = self . data [ : end_val ] [EOL] [comment] [EOL] last_line_start = data . rfind ( [string] ) + [number] [EOL] [comment] [EOL] line_number = data . count ( [string] ) + [number] [EOL] return f'{ line_number } [string] { end_val - last_line_start }' [EOL] [EOL] def advance ( self , new_position ) : [EOL] self . pos = new_position [EOL] [EOL] def rewind ( self , amount = [number] ) : [EOL] self . pos -= amount [EOL] [EOL] def _search ( self , pattern ) : [EOL] return pattern . search ( self . data , self . pos ) [EOL] [EOL] def _match ( self , pattern ) : [EOL] return pattern . match ( self . data , self . pos ) [EOL] [EOL] def _first_match ( self , * patterns , ** kwargs ) : [EOL] matches = [ ] [EOL] for pattern in patterns : [EOL] [comment] [EOL] if kwargs . get ( [string] , [string] ) == [string] : [EOL] match = self . _search ( pattern ) [EOL] else : [EOL] match = self . _match ( pattern ) [EOL] if match : [EOL] matches . append ( match ) [EOL] if not matches : [EOL] return None [EOL] [comment] [EOL] [comment] [EOL] return min ( matches , key = lambda m : m . end ( ) ) [EOL] [EOL] def _expect_match ( self , expected_name , * patterns , ** kwargs ) : [EOL] match = self . _first_match ( * patterns , ** kwargs ) [EOL] if match is None : [EOL] msg = [string] . format ( expected_name , self . data [ self . pos : ] ) [EOL] dbt . exceptions . raise_compiler_error ( msg ) [EOL] return match [EOL] [EOL] def handle_expr ( self , match ) : [EOL] [docstring] [EOL] self . advance ( match . end ( ) ) [EOL] while True : [EOL] match = self . _expect_match ( [string] , EXPR_END_PATTERN , QUOTE_START_PATTERN ) [EOL] if match . groupdict ( ) . get ( [string] ) is not None : [EOL] break [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] match = self . _expect_match ( [string] , STRING_PATTERN ) [EOL] self . advance ( match . end ( ) ) [EOL] [EOL] self . advance ( match . end ( ) ) [EOL] [EOL] def handle_comment ( self , match ) : [EOL] self . advance ( match . end ( ) ) [EOL] match = self . _expect_match ( [string] , COMMENT_END_PATTERN ) [EOL] self . advance ( match . end ( ) ) [EOL] [EOL] def _expect_block_close ( self ) : [EOL] [docstring] [EOL] while True : [EOL] end_match = self . _expect_match ( [string] , QUOTE_START_PATTERN , TAG_CLOSE_PATTERN ) [EOL] self . advance ( end_match . end ( ) ) [EOL] if end_match . groupdict ( ) . get ( [string] ) is not None : [EOL] return [EOL] [comment] [EOL] self . rewind ( ) [EOL] string_match = self . _expect_match ( [string] , STRING_PATTERN ) [EOL] self . advance ( string_match . end ( ) ) [EOL] [EOL] def handle_raw ( self ) : [EOL] [comment] [EOL] match = self . _expect_match ( [string] , RAW_BLOCK_PATTERN ) [EOL] self . advance ( match . end ( ) ) [EOL] return match . end ( ) [EOL] [EOL] def handle_tag ( self , match ) : [EOL] [docstring] [EOL] groups = match . groupdict ( ) [EOL] [comment] [EOL] block_type_name = groups [ [string] ] [EOL] [comment] [EOL] block_name = groups . get ( [string] ) [EOL] start_pos = self . pos [EOL] if block_type_name == [string] : [EOL] match = self . _expect_match ( [string] , RAW_BLOCK_PATTERN ) [EOL] self . advance ( match . end ( ) ) [EOL] else : [EOL] self . advance ( match . end ( ) ) [EOL] self . _expect_block_close ( ) [EOL] return Tag ( block_type_name = block_type_name , block_name = block_name , start = start_pos , end = self . pos ) [EOL] [EOL] def find_tags ( self ) : [EOL] while True : [EOL] match = self . _first_match ( BLOCK_START_PATTERN , COMMENT_START_PATTERN , EXPR_START_PATTERN ) [EOL] if match is None : [EOL] break [EOL] [EOL] self . advance ( match . start ( ) ) [EOL] [comment] [EOL] [EOL] groups = match . groupdict ( ) [EOL] comment_start = groups . get ( [string] ) [EOL] expr_start = groups . get ( [string] ) [EOL] block_type_name = groups . get ( [string] ) [EOL] [EOL] if comment_start is not None : [EOL] self . handle_comment ( match ) [EOL] elif expr_start is not None : [EOL] self . handle_expr ( match ) [EOL] elif block_type_name is not None : [EOL] yield self . handle_tag ( match ) [EOL] else : [EOL] raise dbt . exceptions . InternalException ( [string] [string] ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return self . find_tags ( ) [EOL] [EOL] [EOL] duplicate_tags = ( [string] [string] [string] ) [EOL] [EOL] [EOL] _CONTROL_FLOW_TAGS = { [string] : [string] , [string] : [string] , } [EOL] [EOL] _CONTROL_FLOW_END_TAGS = { v : k for k , v in _CONTROL_FLOW_TAGS . items ( ) } [EOL] [EOL] [EOL] class BlockIterator : [EOL] def __init__ ( self , data ) : [EOL] self . tag_parser = TagIterator ( data ) [EOL] self . current = None [EOL] self . stack = [ ] [EOL] self . last_position = [number] [EOL] [EOL] @ property def current_end ( self ) : [EOL] if self . current is None : [EOL] return [number] [EOL] else : [EOL] return self . current . end [EOL] [EOL] @ property def data ( self ) : [EOL] return self . tag_parser . data [EOL] [EOL] def is_current_end ( self , tag ) : [EOL] return ( tag . block_type_name . startswith ( [string] ) and self . current is not None and tag . block_type_name [ [number] : ] == self . current . block_type_name ) [EOL] [EOL] def find_blocks ( self , allowed_blocks = None , collect_raw_data = True ) : [EOL] [docstring] [EOL] if allowed_blocks is None : [EOL] allowed_blocks = { [string] , [string] , [string] , [string] } [EOL] [EOL] for tag in self . tag_parser . find_tags ( ) : [EOL] if tag . block_type_name in _CONTROL_FLOW_TAGS : [EOL] self . stack . append ( tag . block_type_name ) [EOL] elif tag . block_type_name in _CONTROL_FLOW_END_TAGS : [EOL] found = None [EOL] if self . stack : [EOL] found = self . stack . pop ( ) [EOL] else : [EOL] expected = _CONTROL_FLOW_END_TAGS [ tag . block_type_name ] [EOL] dbt . exceptions . raise_compiler_error ( ( [string] [string] ) . format ( tag . block_type_name , expected , self . tag_parser . linepos ( tag . start ) ) ) [EOL] expected = _CONTROL_FLOW_TAGS [ found ] [EOL] if expected != tag . block_type_name : [EOL] dbt . exceptions . raise_compiler_error ( ( [string] [string] ) . format ( tag . block_type_name , expected , self . tag_parser . linepos ( tag . start ) ) ) [EOL] [EOL] if tag . block_type_name in allowed_blocks : [EOL] if self . stack : [EOL] dbt . exceptions . raise_compiler_error ( ( [string] [string] ) . format ( self . tag_parser . linepos ( tag . start ) ) ) [EOL] if self . current is not None : [EOL] dbt . exceptions . raise_compiler_error ( duplicate_tags . format ( outer = self . current , inner = tag ) ) [EOL] if collect_raw_data : [EOL] raw_data = self . data [ self . last_position : tag . start ] [EOL] self . last_position = tag . start [EOL] if raw_data : [EOL] yield BlockData ( raw_data ) [EOL] self . current = tag [EOL] [EOL] elif self . is_current_end ( tag ) : [EOL] self . last_position = tag . end [EOL] assert self . current is not None [EOL] yield BlockTag ( block_type_name = self . current . block_type_name , block_name = self . current . block_name , contents = self . data [ self . current . end : tag . start ] , full_block = self . data [ self . current . start : tag . end ] ) [EOL] self . current = None [EOL] [EOL] if self . current : [EOL] linecount = self . data [ : self . current . end ] . count ( [string] ) + [number] [EOL] dbt . exceptions . raise_compiler_error ( ( [string] [string] ) . format ( self . current . block_type_name , linecount ) ) [EOL] [EOL] if collect_raw_data : [EOL] raw_data = self . data [ self . last_position : ] [EOL] if raw_data : [EOL] yield BlockData ( raw_data ) [EOL] [EOL] def lex_for_blocks ( self , allowed_blocks = None , collect_raw_data = True ) : [EOL] return list ( self . find_blocks ( allowed_blocks = allowed_blocks , collect_raw_data = collect_raw_data ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Type[core.dbt.clients._jinja_blocks.Tag]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[core.dbt.clients._jinja_blocks.Tag]$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.clients._jinja_blocks.TagIterator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dbt . logger import GLOBAL_LOGGER as logger [EOL] import dbt . exceptions [EOL] from dbt . clients . system import run_cmd [EOL] [EOL] NOT_INSTALLED_MSG = [string] [EOL] [EOL] [EOL] def gcloud_installed ( ) : [EOL] try : [EOL] run_cmd ( [string] , [ [string] , [string] ] ) [EOL] return True [EOL] except OSError as e : [EOL] logger . debug ( e ) [EOL] return False [EOL] [EOL] [EOL] def setup_default_credentials ( ) : [EOL] if gcloud_installed ( ) : [EOL] run_cmd ( [string] , [ [string] , [string] , [string] , [string] ] ) [EOL] else : [EOL] raise dbt . exceptions . RuntimeException ( NOT_INSTALLED_MSG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import shutil [EOL] [EOL] import dbt . config [EOL] import dbt . clients . git [EOL] import dbt . clients . system [EOL] from dbt . adapters . factory import load_plugin , get_include_paths [EOL] from dbt . exceptions import RuntimeException [EOL] [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] [EOL] from dbt . task . base import BaseTask [EOL] [EOL] STARTER_REPO = [string] [EOL] STARTER_BRANCH = [string] [EOL] DOCS_URL = [string] [EOL] [EOL] ON_COMPLETE_MESSAGE = [string] [EOL] [EOL] [EOL] class InitTask ( BaseTask ) : [EOL] def clone_starter_repo ( self , project_name ) : [EOL] dbt . clients . git . clone ( STARTER_REPO , cwd = [string] , dirname = project_name , remove_git_dir = True , branch = STARTER_BRANCH , ) [EOL] [EOL] def create_profiles_dir ( self , profiles_dir ) : [EOL] if not os . path . exists ( profiles_dir ) : [EOL] dbt . clients . system . make_directory ( profiles_dir ) [EOL] return True [EOL] return False [EOL] [EOL] def create_profiles_file ( self , profiles_file , sample_adapter ) : [EOL] [comment] [EOL] load_plugin ( sample_adapter ) [EOL] adapter_path = get_include_paths ( sample_adapter ) [ [number] ] [EOL] sample_profiles_path = adapter_path / [string] [EOL] [EOL] if not sample_profiles_path . exists ( ) : [EOL] raise RuntimeException ( f' [string] { sample_adapter }' ) [EOL] [EOL] if not os . path . exists ( profiles_file ) : [EOL] shutil . copyfile ( sample_profiles_path , profiles_file ) [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def get_addendum ( self , project_name , profiles_path , sample_adapter ) : [EOL] open_cmd = dbt . clients . system . open_dir_cmd ( ) [EOL] [EOL] return ON_COMPLETE_MESSAGE . format ( open_cmd = open_cmd , project_name = project_name , sample_adapter = sample_adapter , profiles_path = profiles_path , docs_url = DOCS_URL ) [EOL] [EOL] def run ( self ) : [EOL] project_dir = self . args . project_name [EOL] sample_adapter = self . args . adapter [EOL] [EOL] profiles_dir = dbt . config . PROFILES_DIR [EOL] profiles_file = os . path . join ( profiles_dir , [string] ) [EOL] [EOL] msg = [string] [EOL] logger . info ( msg . format ( profiles_dir ) ) [EOL] [EOL] msg = [string] [EOL] logger . info ( msg . format ( sample_adapter ) ) [EOL] [EOL] self . create_profiles_dir ( profiles_dir ) [EOL] self . create_profiles_file ( profiles_file , sample_adapter ) [EOL] [EOL] if os . path . exists ( project_dir ) : [EOL] raise RuntimeError ( [string] . format ( project_dir ) ) [EOL] [EOL] self . clone_starter_repo ( project_dir ) [EOL] [EOL] addendum = self . get_addendum ( project_dir , profiles_dir , sample_adapter ) [EOL] logger . info ( addendum ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import dbt [EOL] import typing [EOL] from . runnable import GraphRunnableTask [EOL] from . base import BaseRunner [EOL] [EOL] from dbt . contracts . results import RunModelResult [EOL] from dbt . exceptions import InternalException [EOL] from dbt . graph import ResourceTypeSelector , SelectionSpec , parse_difference [EOL] from dbt . logger import print_timestamped_line [EOL] from dbt . node_types import NodeType [EOL] [EOL] [EOL] class CompileRunner ( BaseRunner ) : [EOL] def before_execute ( self ) : [EOL] pass [EOL] [EOL] def after_execute ( self , result ) : [EOL] pass [EOL] [EOL] def execute ( self , compiled_node , manifest ) : [EOL] return RunModelResult ( compiled_node ) [EOL] [EOL] def compile ( self , manifest ) : [EOL] compiler = self . adapter . get_compiler ( ) [EOL] return compiler . compile_node ( self . node , manifest , { } ) [EOL] [EOL] [EOL] class CompileTask ( GraphRunnableTask ) : [EOL] def raise_on_first_error ( self ) : [EOL] return True [EOL] [EOL] def get_selection_spec ( self ) : [EOL] if self . args . selector_name : [EOL] spec = self . config . get_selector ( self . args . selector_name ) [EOL] else : [EOL] spec = parse_difference ( self . args . models , self . args . exclude ) [EOL] return spec [EOL] [EOL] def get_node_selector ( self ) : [EOL] if self . manifest is None or self . graph is None : [EOL] raise InternalException ( [string] ) [EOL] return ResourceTypeSelector ( graph = self . graph , manifest = self . manifest , previous_state = self . previous_state , resource_types = NodeType . executable ( ) , ) [EOL] [EOL] def get_runner_type ( self ) : [EOL] return CompileRunner [EOL] [EOL] def task_end_messages ( self , results ) : [EOL] print_timestamped_line ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.graph.SelectionSpec$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $dbt.graph.ResourceTypeSelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import random [EOL] [EOL] from . run import ModelRunner , RunTask [EOL] from . printer import ( print_start_line , print_seed_result_line , print_run_end_messages , ) [EOL] [EOL] from dbt . exceptions import InternalException [EOL] from dbt . graph import ResourceTypeSelector [EOL] from dbt . logger import GLOBAL_LOGGER as logger , TextOnly [EOL] from dbt . node_types import NodeType [EOL] [EOL] [EOL] class SeedRunner ( ModelRunner ) : [EOL] def describe_node ( self ) : [EOL] return [string] . format ( self . get_node_representation ( ) ) [EOL] [EOL] def before_execute ( self ) : [EOL] description = self . describe_node ( ) [EOL] print_start_line ( description , self . node_index , self . num_nodes ) [EOL] [EOL] def _build_run_model_result ( self , model , context ) : [EOL] result = super ( ) . _build_run_model_result ( model , context ) [EOL] agate_result = context [ [string] ] ( [string] ) [EOL] result . agate_table = agate_result . table [EOL] return result [EOL] [EOL] def compile ( self , manifest ) : [EOL] return self . node [EOL] [EOL] def print_result_line ( self , result ) : [EOL] schema_name = self . node . schema [EOL] print_seed_result_line ( result , schema_name , self . node_index , self . num_nodes ) [EOL] [EOL] [EOL] class SeedTask ( RunTask ) : [EOL] def raise_on_first_error ( self ) : [EOL] return False [EOL] [EOL] def get_node_selector ( self ) : [EOL] if self . manifest is None or self . graph is None : [EOL] raise InternalException ( [string] ) [EOL] return ResourceTypeSelector ( graph = self . graph , manifest = self . manifest , previous_state = self . previous_state , resource_types = [ NodeType . Seed ] , ) [EOL] [EOL] def get_runner_type ( self ) : [EOL] return SeedRunner [EOL] [EOL] def task_end_messages ( self , results ) : [EOL] if self . args . show : [EOL] self . show_tables ( results ) [EOL] [EOL] print_run_end_messages ( results ) [EOL] [EOL] def show_table ( self , result ) : [EOL] table = result . agate_table [EOL] rand_table = table . order_by ( lambda x : random . random ( ) ) [EOL] [EOL] schema = result . node . schema [EOL] alias = result . node . alias [EOL] [EOL] header = [string] . format ( schema , alias ) [EOL] with TextOnly ( ) : [EOL] logger . info ( [string] ) [EOL] logger . info ( header ) [EOL] logger . info ( [string] * len ( header ) ) [EOL] rand_table . print_table ( max_rows = [number] , max_columns = None ) [EOL] with TextOnly ( ) : [EOL] logger . info ( [string] ) [EOL] [EOL] def show_tables ( self , results ) : [EOL] for result in results : [EOL] if result . error is None : [EOL] self . show_table ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Callable , List , Optional , Dict , Tuple [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , Optional , Tuple , Callable [EOL] from dbt . logger import ( GLOBAL_LOGGER as logger , DbtStatusMessage , TextOnly , get_timestamp , ) [EOL] from dbt . node_types import NodeType [EOL] [EOL] from dbt . tracking import InvocationProcessor [EOL] from dbt import ui [EOL] from dbt import utils [EOL] [EOL] [EOL] def print_fancy_output_line ( msg , status , logger_fn , index , total , execution_time = None , truncate = False ) : [EOL] if index is None or total is None : [EOL] progress = [string] [EOL] else : [EOL] progress = [string] . format ( index , total ) [EOL] prefix = [string] . format ( timestamp = get_timestamp ( ) , progress = progress , message = msg ) [EOL] [EOL] truncate_width = ui . PRINTER_WIDTH - [number] [EOL] justified = prefix . ljust ( ui . PRINTER_WIDTH , [string] ) [EOL] if truncate and len ( justified ) > truncate_width : [EOL] justified = justified [ : truncate_width ] + [string] [EOL] [EOL] if execution_time is None : [EOL] status_time = [string] [EOL] else : [EOL] status_time = [string] . format ( execution_time = execution_time ) [EOL] [EOL] output = [string] . format ( justified = justified , status = status , status_time = status_time ) [EOL] [EOL] logger_fn ( output ) [EOL] [EOL] [EOL] def get_counts ( flat_nodes ) : [EOL] counts = { } [EOL] [EOL] for node in flat_nodes : [EOL] t = node . resource_type [EOL] [EOL] if node . resource_type == NodeType . Model : [EOL] t = [string] . format ( node . get_materialization ( ) , t ) [EOL] elif node . resource_type == NodeType . Operation : [EOL] t = [string] [EOL] [EOL] counts [ t ] = counts . get ( t , [number] ) + [number] [EOL] [EOL] stat_line = [string] . join ( [ utils . pluralize ( v , k ) for k , v in counts . items ( ) ] ) [EOL] [EOL] return stat_line [EOL] [EOL] [EOL] def print_start_line ( description , index , total ) : [EOL] msg = [string] . format ( description ) [EOL] print_fancy_output_line ( msg , [string] , logger . info , index , total ) [EOL] [EOL] [EOL] def print_hook_start_line ( statement , index , total ) : [EOL] msg = [string] . format ( statement ) [EOL] print_fancy_output_line ( msg , [string] , logger . info , index , total , truncate = True ) [EOL] [EOL] [EOL] def print_hook_end_line ( statement , status , index , total , execution_time ) : [EOL] msg = [string] . format ( statement ) [EOL] [comment] [EOL] print_fancy_output_line ( msg , ui . green ( status ) , logger . info , index , total , execution_time = execution_time , truncate = True ) [EOL] [EOL] [EOL] def print_skip_line ( model , schema , relation , index , num_models ) : [EOL] msg = [string] . format ( schema , relation ) [EOL] print_fancy_output_line ( msg , ui . yellow ( [string] ) , logger . info , index , num_models ) [EOL] [EOL] [EOL] def print_cancel_line ( model ) : [EOL] msg = [string] . format ( model ) [EOL] print_fancy_output_line ( msg , ui . red ( [string] ) , logger . error , index = None , total = None ) [EOL] [EOL] [EOL] def get_printable_result ( result , success , error ) : [EOL] if result . error is not None : [EOL] info = [string] . format ( error ) [EOL] status = ui . red ( result . status ) [EOL] logger_fn = logger . error [EOL] else : [EOL] info = [string] . format ( success ) [EOL] status = ui . green ( result . status ) [EOL] logger_fn = logger . info [EOL] [EOL] return info , status , logger_fn [EOL] [EOL] [EOL] def print_test_result_line ( result , schema_name , index , total ) : [EOL] model = result . node [EOL] [EOL] if result . error is not None : [EOL] info = [string] [EOL] color = ui . red [EOL] logger_fn = logger . error [EOL] elif result . status == [number] : [EOL] info = [string] [EOL] color = ui . green [EOL] logger_fn = logger . info [EOL] elif result . warn : [EOL] info = [string] . format ( result . status ) [EOL] color = ui . yellow [EOL] logger_fn = logger . warning [EOL] elif result . fail : [EOL] info = [string] . format ( result . status ) [EOL] color = ui . red [EOL] logger_fn = logger . error [EOL] else : [EOL] raise RuntimeError ( [string] . format ( result . status ) ) [EOL] [EOL] print_fancy_output_line ( [string] . format ( info = info , name = model . name ) , color ( info ) , logger_fn , index , total , result . execution_time ) [EOL] [EOL] [EOL] def print_model_result_line ( result , description , index , total ) : [EOL] info , status , logger_fn = get_printable_result ( result , [string] , [string] ) [EOL] [EOL] print_fancy_output_line ( [string] . format ( info = info , description = description ) , status , logger_fn , index , total , result . execution_time ) [EOL] [EOL] [EOL] def print_snapshot_result_line ( result , description , index , total ) : [EOL] model = result . node [EOL] [EOL] info , status , logger_fn = get_printable_result ( result , [string] , [string] ) [EOL] cfg = model . config . to_dict ( ) [EOL] [EOL] msg = [string] . format ( info = info , description = description , ** cfg ) [EOL] print_fancy_output_line ( msg , status , logger_fn , index , total , result . execution_time ) [EOL] [EOL] [EOL] def print_seed_result_line ( result , schema_name , index , total ) : [EOL] model = result . node [EOL] [EOL] info , status , logger_fn = get_printable_result ( result , [string] , [string] ) [EOL] [EOL] print_fancy_output_line ( [string] . format ( info = info , schema = schema_name , relation = model . alias ) , status , logger_fn , index , total , result . execution_time ) [EOL] [EOL] [EOL] def print_freshness_result_line ( result , index , total ) : [EOL] if result . error : [EOL] info = [string] [EOL] color = ui . red [EOL] logger_fn = logger . error [EOL] elif result . status == [string] : [EOL] info = [string] [EOL] color = ui . red [EOL] logger_fn = logger . error [EOL] elif result . status == [string] : [EOL] info = [string] [EOL] color = ui . yellow [EOL] logger_fn = logger . warning [EOL] else : [EOL] info = [string] [EOL] color = ui . green [EOL] logger_fn = logger . info [EOL] [EOL] if hasattr ( result , [string] ) : [EOL] source_name = result . node . source_name [EOL] table_name = result . node . name [EOL] else : [EOL] source_name = result . source_name [EOL] table_name = result . table_name [EOL] [EOL] msg = [string] . format ( info = info , source_name = source_name , table_name = table_name ) [EOL] [EOL] print_fancy_output_line ( msg , color ( info ) , logger_fn , index , total , execution_time = result . execution_time ) [EOL] [EOL] [EOL] def interpret_run_result ( result ) : [EOL] if result . error is not None or result . fail : [EOL] return [string] [EOL] elif result . skipped : [EOL] return [string] [EOL] elif result . warn : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] def print_run_status_line ( results ) : [EOL] stats = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] for r in results : [EOL] result_type = interpret_run_result ( r ) [EOL] stats [ result_type ] += [number] [EOL] stats [ [string] ] += [number] [EOL] [EOL] stats_line = [string] [comment] [EOL] logger . info ( stats_line . format ( ** stats ) ) [EOL] [EOL] [EOL] def print_run_result_error ( result , newline = True , is_warning = False ) : [EOL] if newline : [EOL] with TextOnly ( ) : [EOL] logger . info ( [string] ) [EOL] [EOL] if result . fail or ( is_warning and result . warn ) : [EOL] if is_warning : [EOL] color = ui . yellow [EOL] info = [string] [EOL] logger_fn = logger . warning [EOL] else : [EOL] color = ui . red [EOL] info = [string] [EOL] logger_fn = logger . error [EOL] logger_fn ( color ( [string] ) . format ( info , result . node . resource_type , result . node . name , result . node . original_file_path ) ) [EOL] [EOL] try : [EOL] int ( result . status ) [EOL] except ValueError : [EOL] logger . error ( [string] . format ( result . status ) ) [EOL] else : [EOL] status = utils . pluralize ( result . status , [string] ) [EOL] logger . error ( [string] . format ( status ) ) [EOL] [EOL] if result . node . build_path is not None : [EOL] with TextOnly ( ) : [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] . format ( result . node . build_path ) ) [EOL] [EOL] else : [EOL] first = True [EOL] for line in result . error . split ( [string] ) : [EOL] if first : [EOL] logger . error ( ui . yellow ( line ) ) [EOL] first = False [EOL] else : [EOL] logger . error ( line ) [EOL] [EOL] [EOL] def print_skip_caused_by_error ( model , schema , relation , index , num_models , result ) : [EOL] msg = ( [string] . format ( schema , relation ) ) [EOL] print_fancy_output_line ( msg , ui . red ( [string] ) , logger . error , index , num_models ) [EOL] print_run_result_error ( result , newline = False ) [EOL] [EOL] [EOL] def print_end_of_run_summary ( num_errors , num_warnings , keyboard_interrupt = False ) : [EOL] error_plural = utils . pluralize ( num_errors , [string] ) [EOL] warn_plural = utils . pluralize ( num_warnings , [string] ) [EOL] if keyboard_interrupt : [EOL] message = ui . yellow ( [string] ) [EOL] elif num_errors > [number] : [EOL] message = ui . red ( [string] . format ( error_plural , warn_plural ) ) [EOL] elif num_warnings > [number] : [EOL] message = ui . yellow ( [string] . format ( warn_plural ) ) [EOL] else : [EOL] message = ui . green ( [string] ) [EOL] [EOL] with TextOnly ( ) : [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] . format ( message ) ) [EOL] [EOL] [EOL] def print_run_end_messages ( results , keyboard_interrupt = False ) : [EOL] errors = [ r for r in results if r . error is not None or r . fail ] [EOL] warnings = [ r for r in results if r . warn ] [EOL] with DbtStatusMessage ( ) , InvocationProcessor ( ) : [EOL] print_end_of_run_summary ( len ( errors ) , len ( warnings ) , keyboard_interrupt ) [EOL] [EOL] for error in errors : [EOL] print_run_result_error ( error , is_warning = False ) [EOL] [EOL] for warning in warnings : [EOL] print_run_result_error ( warning , is_warning = True ) [EOL] [EOL] print_run_status_line ( results ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,typing.Callable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import socketserver [EOL] import shutil [EOL] import os [EOL] import webbrowser [EOL] [EOL] from dbt . include . global_project import DOCS_INDEX_FILE_PATH [EOL] from http . server import SimpleHTTPRequestHandler [EOL] from socketserver import TCPServer [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] [EOL] from dbt . task . base import ConfiguredTask [EOL] [EOL] [EOL] class ServeTask ( ConfiguredTask ) : [EOL] def run ( self ) : [EOL] os . chdir ( self . config . target_path ) [EOL] [EOL] port = self . args . port [EOL] [EOL] shutil . copyfile ( DOCS_INDEX_FILE_PATH , [string] ) [EOL] [EOL] logger . info ( [string] . format ( port ) ) [EOL] logger . info ( [string] . format ( port ) ) [EOL] logger . info ( [string] ) [EOL] [EOL] [comment] [EOL] httpd = TCPServer ( ( [string] , port ) , SimpleHTTPRequestHandler ) [comment] [EOL] [EOL] if self . args . open_browser : [EOL] try : [EOL] webbrowser . open_new_tab ( f' [string] { port }' ) [EOL] except webbrowser . Error : [EOL] pass [EOL] [EOL] try : [EOL] httpd . serve_forever ( ) [comment] [EOL] finally : [EOL] httpd . shutdown ( ) [EOL] httpd . server_close ( ) [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socketserver.TCPServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socketserver.TCPServer$ 0 0 0 0 0 0 0 0 0 $socketserver.TCPServer$ 0 0 0 0 0 $socketserver.TCPServer$ 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import dbt . utils [EOL] import dbt . deprecations [EOL] import dbt . exceptions [EOL] [EOL] from dbt . config import UnsetProfileConfig [EOL] from dbt . config . renderer import DbtProjectYamlRenderer [EOL] from dbt . context . target import generate_target_context [EOL] from dbt . deps . base import downloads_directory [EOL] from dbt . deps . resolver import resolve_packages [EOL] [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt . clients import system [EOL] [EOL] from dbt . task . base import BaseTask , move_to_nearest_project_dir [EOL] [EOL] [EOL] class DepsTask ( BaseTask ) : [EOL] ConfigType = UnsetProfileConfig [EOL] [EOL] def __init__ ( self , args , config ) : [EOL] super ( ) . __init__ ( args = args , config = config ) [EOL] [EOL] def track_package_install ( self , package_name , source_type , version ) : [EOL] [comment] [EOL] [comment] [EOL] if source_type == [string] : [EOL] package_name = dbt . utils . md5 ( package_name ) [EOL] version = [string] [EOL] elif source_type != [string] : [EOL] package_name = dbt . utils . md5 ( package_name ) [EOL] version = dbt . utils . md5 ( version ) [EOL] [EOL] dbt . tracking . track_package_install ( self . config , self . config . args , { [string] : package_name , [string] : source_type , [string] : version } ) [EOL] [EOL] def run ( self ) : [EOL] system . make_directory ( self . config . modules_path ) [EOL] packages = self . config . packages . packages [EOL] if not packages : [EOL] logger . info ( [string] ) [EOL] return [EOL] [EOL] with downloads_directory ( ) : [EOL] final_deps = resolve_packages ( packages , self . config ) [EOL] [EOL] renderer = DbtProjectYamlRenderer ( generate_target_context ( self . config , self . config . cli_vars ) ) [EOL] [EOL] for package in final_deps : [EOL] logger . info ( [string] , package ) [EOL] package . install ( self . config , renderer ) [EOL] logger . info ( [string] , package . nice_version_name ( ) ) [EOL] [EOL] self . track_package_install ( package_name = package . name , source_type = package . source_type ( ) , version = package . get_version ( ) ) [EOL] [EOL] @ classmethod def from_args ( cls , args ) : [EOL] [comment] [EOL] [comment] [EOL] move_to_nearest_project_dir ( args ) [EOL] return super ( ) . from_args ( args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[core.dbt.task.deps.DepsTask]$ 0 0 0 0 0 0 0 0 0 0 0 $dbt.config.UnsetProfileConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.config.UnsetProfileConfig$ 0 $dbt.config.UnsetProfileConfig$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict , Optional , Type , Tuple [EOL] import core [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import threading [EOL] import time [EOL] import traceback [EOL] from abc import ABCMeta , abstractmethod [EOL] from typing import Type , Union , Dict , Any , Optional [EOL] [EOL] from dbt import tracking [EOL] from dbt import ui [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . results import ( RunModelResult , collect_timing_info ) [EOL] from dbt . exceptions import ( NotImplementedException , CompilationException , RuntimeException , InternalException ) [EOL] from dbt . logger import GLOBAL_LOGGER as logger , log_manager [EOL] from . printer import print_skip_caused_by_error , print_skip_line [EOL] [EOL] [EOL] from dbt . adapters . factory import register_adapter [EOL] from dbt . config import RuntimeConfig , Project [EOL] from dbt . config . profile import read_profile , PROFILES_DIR [EOL] import dbt . exceptions [EOL] [EOL] [EOL] class NoneConfig : [EOL] @ classmethod def from_args ( cls , args ) : [EOL] return None [EOL] [EOL] [EOL] def read_profiles ( profiles_dir = None ) : [EOL] [docstring] [EOL] if profiles_dir is None : [EOL] profiles_dir = PROFILES_DIR [EOL] [EOL] raw_profiles = read_profile ( profiles_dir ) [EOL] [EOL] if raw_profiles is None : [EOL] profiles = { } [EOL] else : [EOL] profiles = { k : v for ( k , v ) in raw_profiles . items ( ) if k != [string] } [EOL] [EOL] return profiles [EOL] [EOL] [EOL] PROFILES_HELP_MESSAGE = [string] [EOL] [EOL] [EOL] class BaseTask ( metaclass = ABCMeta ) : [EOL] ConfigType = NoneConfig [EOL] [EOL] def __init__ ( self , args , config ) : [EOL] self . args = args [EOL] self . config = config [EOL] [EOL] @ classmethod def pre_init_hook ( cls , args ) : [EOL] [docstring] [EOL] if args . log_format == [string] : [EOL] log_manager . format_json ( ) [EOL] else : [EOL] log_manager . format_text ( ) [EOL] [EOL] @ classmethod def from_args ( cls , args ) : [EOL] try : [EOL] config = cls . ConfigType . from_args ( args ) [EOL] except dbt . exceptions . DbtProjectError as exc : [EOL] logger . error ( [string] ) [EOL] logger . error ( [string] . format ( str ( exc ) ) ) [EOL] [EOL] tracking . track_invalid_invocation ( args = args , result_type = exc . result_type ) [EOL] raise dbt . exceptions . RuntimeException ( [string] ) from exc [EOL] except dbt . exceptions . DbtProfileError as exc : [EOL] logger . error ( [string] ) [EOL] logger . error ( [string] . format ( str ( exc ) ) ) [EOL] [EOL] all_profiles = read_profiles ( args . profiles_dir ) . keys ( ) [EOL] [EOL] if len ( all_profiles ) > [number] : [EOL] logger . info ( [string] ) [EOL] for profile in all_profiles : [EOL] logger . info ( [string] . format ( profile ) ) [EOL] else : [EOL] logger . info ( [string] [string] ) [EOL] [EOL] logger . info ( PROFILES_HELP_MESSAGE ) [EOL] [EOL] tracking . track_invalid_invocation ( args = args , result_type = exc . result_type ) [EOL] raise dbt . exceptions . RuntimeException ( [string] ) from exc [EOL] return cls ( args , config ) [EOL] [EOL] @ abstractmethod def run ( self ) : [EOL] raise dbt . exceptions . NotImplementedException ( [string] ) [EOL] [EOL] def interpret_results ( self , results ) : [EOL] return True [EOL] [EOL] [EOL] def get_nearest_project_dir ( args ) : [EOL] [comment] [EOL] [comment] [EOL] if args . project_dir : [EOL] project_file = os . path . join ( args . project_dir , [string] ) [EOL] if os . path . exists ( project_file ) : [EOL] return args . project_dir [EOL] else : [EOL] raise dbt . exceptions . RuntimeException ( [string] [string] ) [EOL] [EOL] root_path = os . path . abspath ( os . sep ) [EOL] cwd = os . getcwd ( ) [EOL] [EOL] while cwd != root_path : [EOL] project_file = os . path . join ( cwd , [string] ) [EOL] if os . path . exists ( project_file ) : [EOL] return cwd [EOL] cwd = os . path . dirname ( cwd ) [EOL] [EOL] raise dbt . exceptions . RuntimeException ( [string] [string] ) [EOL] [EOL] [EOL] def move_to_nearest_project_dir ( args ) : [EOL] nearest_project_dir = get_nearest_project_dir ( args ) [EOL] os . chdir ( nearest_project_dir ) [EOL] [EOL] [EOL] class ConfiguredTask ( BaseTask ) : [EOL] ConfigType = RuntimeConfig [EOL] [EOL] def __init__ ( self , args , config ) : [EOL] super ( ) . __init__ ( args , config ) [EOL] register_adapter ( self . config ) [EOL] [EOL] @ classmethod def from_args ( cls , args ) : [EOL] move_to_nearest_project_dir ( args ) [EOL] return super ( ) . from_args ( args ) [EOL] [EOL] [EOL] INTERNAL_ERROR_STRING = [string] . strip ( ) [EOL] [EOL] [EOL] class ExecutionContext : [EOL] [docstring] [EOL] def __init__ ( self , node ) : [EOL] self . timing = [ ] [EOL] self . node = node [EOL] [EOL] [EOL] class BaseRunner ( metaclass = ABCMeta ) : [EOL] def __init__ ( self , config , adapter , node , node_index , num_nodes ) : [EOL] self . config = config [EOL] self . adapter = adapter [EOL] self . node = node [EOL] self . node_index = node_index [EOL] self . num_nodes = num_nodes [EOL] [EOL] self . skip = False [EOL] self . skip_cause = None [EOL] [EOL] @ abstractmethod def compile ( self , manifest ) : [EOL] pass [EOL] [EOL] def get_result_status ( self , result ) : [EOL] if result . error : [EOL] return { [string] : [string] , [string] : str ( result . error ) } [EOL] elif result . skip : [EOL] return { [string] : [string] } [EOL] elif result . fail : [EOL] return { [string] : [string] } [EOL] elif result . warn : [EOL] return { [string] : [string] } [EOL] else : [EOL] return { [string] : [string] } [EOL] [EOL] def run_with_hooks ( self , manifest ) : [EOL] if self . skip : [EOL] return self . on_skip ( ) [EOL] [EOL] [comment] [EOL] if not self . node . is_ephemeral_model : [EOL] self . before_execute ( ) [EOL] [EOL] result = self . safe_run ( manifest ) [EOL] [EOL] if not self . node . is_ephemeral_model : [EOL] self . after_execute ( result ) [EOL] [EOL] return result [EOL] [EOL] def _build_run_result ( self , node , start_time , error , status , timing_info , skip = False , fail = None , warn = None , agate_table = None ) : [EOL] execution_time = time . time ( ) - start_time [EOL] thread_id = threading . current_thread ( ) . name [EOL] return RunModelResult ( node = node , error = error , skip = skip , status = status , fail = fail , warn = warn , execution_time = execution_time , thread_id = thread_id , timing = timing_info , agate_table = agate_table , ) [EOL] [EOL] def error_result ( self , node , error , start_time , timing_info ) : [EOL] return self . _build_run_result ( node = node , start_time = start_time , error = error , status = [string] , timing_info = timing_info ) [EOL] [EOL] def ephemeral_result ( self , node , start_time , timing_info ) : [EOL] return self . _build_run_result ( node = node , start_time = start_time , error = None , status = None , timing_info = timing_info ) [EOL] [EOL] def from_run_result ( self , result , start_time , timing_info ) : [EOL] return self . _build_run_result ( node = result . node , start_time = start_time , error = result . error , skip = result . skip , status = result . status , fail = result . fail , warn = result . warn , timing_info = timing_info , agate_table = result . agate_table , ) [EOL] [EOL] def compile_and_execute ( self , manifest , ctx ) : [EOL] result = None [EOL] with self . adapter . connection_for ( self . node ) : [EOL] with collect_timing_info ( [string] ) as timing_info : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ctx . node = self . compile ( manifest ) [EOL] ctx . timing . append ( timing_info ) [EOL] [EOL] [comment] [EOL] if not ctx . node . is_ephemeral_model : [EOL] with collect_timing_info ( [string] ) as timing_info : [EOL] result = self . run ( ctx . node , manifest ) [EOL] ctx . node = result . node [EOL] [EOL] ctx . timing . append ( timing_info ) [EOL] [EOL] return result [EOL] [EOL] def _handle_catchable_exception ( self , e , ctx ) : [EOL] if e . node is None : [EOL] e . add_node ( ctx . node ) [EOL] [EOL] logger . debug ( str ( e ) , exc_info = True ) [EOL] return str ( e ) [EOL] [EOL] def _handle_internal_exception ( self , e , ctx ) : [EOL] build_path = self . node . build_path [EOL] prefix = [string] . format ( build_path ) [EOL] [EOL] error = [string] . format ( prefix = ui . red ( prefix ) , error = str ( e ) . strip ( ) , note = INTERNAL_ERROR_STRING ) [EOL] logger . debug ( error , exc_info = True ) [EOL] return str ( e ) [EOL] [EOL] def _handle_generic_exception ( self , e , ctx ) : [EOL] node_description = self . node . build_path [EOL] if node_description is None : [EOL] node_description = self . node . unique_id [EOL] prefix = [string] . format ( node_description ) [EOL] error = [string] . format ( prefix = ui . red ( prefix ) , error = str ( e ) . strip ( ) ) [EOL] [EOL] logger . error ( error ) [EOL] logger . debug ( [string] , exc_info = True ) [EOL] return str ( e ) [EOL] [EOL] def handle_exception ( self , e , ctx ) : [EOL] catchable_errors = ( CompilationException , RuntimeException ) [EOL] if isinstance ( e , catchable_errors ) : [EOL] error = self . _handle_catchable_exception ( e , ctx ) [EOL] elif isinstance ( e , InternalException ) : [EOL] error = self . _handle_internal_exception ( e , ctx ) [EOL] else : [EOL] error = self . _handle_generic_exception ( e , ctx ) [EOL] return error [EOL] [EOL] def safe_run ( self , manifest ) : [EOL] started = time . time ( ) [EOL] ctx = ExecutionContext ( self . node ) [EOL] error = None [EOL] result = None [EOL] [EOL] try : [EOL] result = self . compile_and_execute ( manifest , ctx ) [EOL] except Exception as e : [EOL] error = self . handle_exception ( e , ctx ) [EOL] finally : [EOL] exc_str = self . _safe_release_connection ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( exc_str is not None and result is not None and result . error is None and error is None ) : [EOL] error = exc_str [EOL] [EOL] if error is not None : [EOL] [comment] [EOL] result = self . error_result ( ctx . node , error , started , [ ] ) [EOL] elif result is not None : [EOL] result = self . from_run_result ( result , started , ctx . timing ) [EOL] else : [EOL] result = self . ephemeral_result ( ctx . node , started , ctx . timing ) [EOL] return result [EOL] [EOL] def _safe_release_connection ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . adapter . release_connection ( ) [EOL] except Exception as exc : [EOL] logger . debug ( [string] . format ( self . node . name , exc , traceback . format_exc ( ) ) ) [EOL] return str ( exc ) [EOL] [EOL] return None [EOL] [EOL] def before_execute ( self ) : [EOL] raise NotImplementedException ( ) [EOL] [EOL] def execute ( self , compiled_node , manifest ) : [EOL] raise NotImplementedException ( ) [EOL] [EOL] def run ( self , compiled_node , manifest ) : [EOL] return self . execute ( compiled_node , manifest ) [EOL] [EOL] def after_execute ( self , result ) : [EOL] raise NotImplementedException ( ) [EOL] [EOL] def _skip_caused_by_ephemeral_failure ( self ) : [EOL] if self . skip_cause is None or self . skip_cause . node is None : [EOL] return False [EOL] return self . skip_cause . node . is_ephemeral_model [EOL] [EOL] def on_skip ( self ) : [EOL] schema_name = self . node . schema [EOL] node_name = self . node . name [EOL] [EOL] error = None [EOL] if not self . node . is_ephemeral_model : [EOL] [comment] [EOL] [comment] [EOL] if self . _skip_caused_by_ephemeral_failure ( ) : [EOL] print_skip_caused_by_error ( self . node , schema_name , node_name , self . node_index , self . num_nodes , self . skip_cause ) [EOL] if self . skip_cause is None : [comment] [EOL] raise InternalException ( [string] [string] ) [EOL] [comment] [EOL] error = ( [string] [string] . format ( self . node . unique_id , self . skip_cause . node . unique_id ) ) [EOL] else : [EOL] print_skip_line ( self . node , schema_name , node_name , self . node_index , self . num_nodes ) [EOL] [EOL] node_result = RunModelResult ( self . node , skip = True , error = error ) [EOL] return node_result [EOL] [EOL] def do_skip ( self , cause = None ) : [EOL] self . skip = True [EOL] self . skip_cause = cause [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Type[NoneConfig],typing.Type[dbt.config.Project]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[core.dbt.task.base.ConfiguredTask]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Optional[dbt.contracts.results.RunModelResult]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $core.dbt.task.base.ExecutionContext$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $core.dbt.task.base.ExecutionContext$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $core.dbt.task.base.ExecutionContext$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $core.dbt.task.base.ExecutionContext$ 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 $core.dbt.task.base.ExecutionContext$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $core.dbt.task.base.ExecutionContext$ 0 0 0 $builtins.float$ 0 $core.dbt.task.base.ExecutionContext$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple , Set [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , Any , Set [EOL] [EOL] from . compile import CompileRunner [EOL] from . run import RunTask [EOL] from . printer import print_start_line , print_test_result_line [EOL] [EOL] from dbt . contracts . graph . compiled import ( CompiledDataTestNode , CompiledSchemaTestNode , CompiledTestNode , ) [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . graph . parsed import ( ParsedDataTestNode , ParsedSchemaTestNode , ) [EOL] from dbt . contracts . results import RunModelResult [EOL] from dbt . exceptions import raise_compiler_error , InternalException [EOL] from dbt . graph import ( ResourceTypeSelector , SelectionSpec , UniqueId , parse_test_selectors , ) [EOL] from dbt . node_types import NodeType , RunHookType [EOL] from dbt import flags [EOL] [EOL] [EOL] class TestRunner ( CompileRunner ) : [EOL] def describe_node ( self ) : [EOL] node_name = self . node . name [EOL] return [string] . format ( node_name ) [EOL] [EOL] def print_result_line ( self , result ) : [EOL] schema_name = self . node . schema [EOL] print_test_result_line ( result , schema_name , self . node_index , self . num_nodes ) [EOL] [EOL] def print_start_line ( self ) : [EOL] description = self . describe_node ( ) [EOL] print_start_line ( description , self . node_index , self . num_nodes ) [EOL] [EOL] def execute_data_test ( self , test ) : [EOL] res , table = self . adapter . execute ( test . injected_sql , auto_begin = True , fetch = True ) [EOL] [EOL] num_rows = len ( table . rows ) [EOL] if num_rows != [number] : [EOL] num_cols = len ( table . columns ) [EOL] [comment] [EOL] [comment] [EOL] raise InternalException ( f" [string] { test . unique_id } [string] " f" [string] { num_rows } [string] { num_cols } [string] " f" [string] " ) [EOL] return table [ [number] ] [ [number] ] [EOL] [EOL] def execute_schema_test ( self , test ) : [EOL] res , table = self . adapter . execute ( test . injected_sql , auto_begin = True , fetch = True , ) [EOL] [EOL] num_rows = len ( table . rows ) [EOL] if num_rows != [number] : [EOL] num_cols = len ( table . columns ) [EOL] raise_compiler_error ( f" [string] { test . test_metadata . name } [string] " f" [string] { num_rows } [string] { num_cols } [string] " f" [string] " ) [EOL] return table [ [number] ] [ [number] ] [EOL] [EOL] def before_execute ( self ) : [EOL] self . print_start_line ( ) [EOL] [EOL] def execute ( self , test , manifest ) : [EOL] if isinstance ( test , CompiledDataTestNode ) : [EOL] failed_rows = self . execute_data_test ( test ) [EOL] elif isinstance ( test , CompiledSchemaTestNode ) : [EOL] failed_rows = self . execute_schema_test ( test ) [EOL] else : [EOL] [EOL] raise InternalException ( f' [string] ' f'{ type ( test ) }' ) [EOL] severity = test . config . severity . upper ( ) [EOL] [EOL] if failed_rows == [number] : [EOL] return RunModelResult ( test , status = failed_rows ) [EOL] elif severity == [string] or flags . WARN_ERROR : [EOL] return RunModelResult ( test , status = failed_rows , fail = True ) [EOL] else : [EOL] return RunModelResult ( test , status = failed_rows , warn = True ) [EOL] [EOL] def after_execute ( self , result ) : [EOL] self . print_result_line ( result ) [EOL] [EOL] [EOL] DATA_TEST_TYPES = ( CompiledDataTestNode , ParsedDataTestNode ) [EOL] SCHEMA_TEST_TYPES = ( CompiledSchemaTestNode , ParsedSchemaTestNode ) [EOL] [EOL] [EOL] class TestSelector ( ResourceTypeSelector ) : [EOL] def __init__ ( self , graph , manifest , previous_state ) : [EOL] super ( ) . __init__ ( graph = graph , manifest = manifest , previous_state = previous_state , resource_types = [ NodeType . Test ] , ) [EOL] [EOL] def expand_selection ( self , selected ) : [EOL] [comment] [EOL] selected_tests = set ( ) [EOL] for unique_id in self . graph . select_successors ( selected ) : [EOL] if unique_id in self . manifest . nodes : [EOL] node = self . manifest . nodes [ unique_id ] [EOL] if node . resource_type == NodeType . Test : [EOL] selected_tests . add ( unique_id ) [EOL] [EOL] return selected | selected_tests [EOL] [EOL] [EOL] class TestTask ( RunTask ) : [EOL] [docstring] [EOL] def raise_on_first_error ( self ) : [EOL] return False [EOL] [EOL] def safe_run_hooks ( self , adapter , hook_type , extra_context ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def get_selection_spec ( self ) : [EOL] base_spec = super ( ) . get_selection_spec ( ) [EOL] return parse_test_selectors ( data = self . args . data , schema = self . args . schema , base = base_spec ) [EOL] [EOL] def get_node_selector ( self ) : [EOL] if self . manifest is None or self . graph is None : [EOL] raise InternalException ( [string] ) [EOL] return TestSelector ( graph = self . graph , manifest = self . manifest , previous_state = self . previous_state , ) [EOL] [EOL] def get_runner_type ( self ) : [EOL] return TestRunner [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledDataTestNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledDataTestNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledDataTestNode$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledSchemaTestNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledSchemaTestNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledSchemaTestNode$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 0 0 0 $typing.Any$ 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.compiled.CompiledTestNode$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[dbt.graph.UniqueId]$ 0 0 0 $typing.Set[dbt.graph.UniqueId]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[dbt.graph.UniqueId]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[dbt.graph.UniqueId]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $dbt.node_types.RunHookType$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $dbt.graph.SelectionSpec$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TestSelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . run import ModelRunner , RunTask [EOL] from . printer import print_snapshot_result_line [EOL] [EOL] from dbt . exceptions import InternalException [EOL] from dbt . graph import ResourceTypeSelector [EOL] from dbt . node_types import NodeType [EOL] [EOL] [EOL] class SnapshotRunner ( ModelRunner ) : [EOL] def describe_node ( self ) : [EOL] return [string] . format ( self . get_node_representation ( ) ) [EOL] [EOL] def print_result_line ( self , result ) : [EOL] print_snapshot_result_line ( result , self . get_node_representation ( ) , self . node_index , self . num_nodes ) [EOL] [EOL] [EOL] class SnapshotTask ( RunTask ) : [EOL] def raise_on_first_error ( self ) : [EOL] return False [EOL] [EOL] def get_node_selector ( self ) : [EOL] if self . manifest is None or self . graph is None : [EOL] raise InternalException ( [string] ) [EOL] return ResourceTypeSelector ( graph = self . graph , manifest = self . manifest , previous_state = self . previous_state , resource_types = [ NodeType . Snapshot ] , ) [EOL] [EOL] def get_runner_type ( self ) : [EOL] return SnapshotRunner [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , AbstractSet , List , Set , Optional , Dict , Tuple [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import time [EOL] from abc import abstractmethod [EOL] from concurrent . futures import as_completed [EOL] from datetime import datetime [EOL] from multiprocessing . dummy import Pool as ThreadPool [EOL] from typing import Optional , Dict , List , Set , Tuple , Iterable , AbstractSet [EOL] [EOL] from . printer import ( print_run_result_error , print_run_end_messages , print_cancel_line , ) [EOL] from dbt import ui [EOL] from dbt . task . base import ConfiguredTask [EOL] from dbt . adapters . base import BaseRelation [EOL] from dbt . adapters . factory import get_adapter [EOL] from dbt . logger import ( GLOBAL_LOGGER as logger , DbtProcessState , TextOnly , UniqueID , TimestampNamed , DbtModelState , ModelMetadata , NodeCount , print_timestamped_line , ) [EOL] [EOL] from dbt . contracts . graph . compiled import CompileResultNode [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . graph . parsed import ParsedSourceDefinition [EOL] from dbt . contracts . results import ExecutionResult [EOL] from dbt . contracts . state import PreviousState [EOL] from dbt . exceptions import ( InternalException , NotImplementedException , RuntimeException , FailFastException ) [EOL] from dbt . graph import GraphQueue , NodeSelector , SelectionSpec , Graph [EOL] from dbt . perf_utils import get_full_manifest [EOL] [EOL] import dbt . exceptions [EOL] from dbt import flags [EOL] import dbt . utils [EOL] [EOL] RESULT_FILE_NAME = [string] [EOL] MANIFEST_FILE_NAME = [string] [EOL] RUNNING_STATE = DbtProcessState ( [string] ) [EOL] [EOL] [EOL] class ManifestTask ( ConfiguredTask ) : [EOL] def __init__ ( self , args , config ) : [EOL] super ( ) . __init__ ( args , config ) [EOL] self . manifest = None [EOL] self . graph = None [EOL] [EOL] def write_manifest ( self ) : [EOL] if flags . WRITE_JSON : [EOL] path = os . path . join ( self . config . target_path , MANIFEST_FILE_NAME ) [EOL] self . manifest . write ( path ) [EOL] [EOL] def load_manifest ( self ) : [EOL] self . manifest = get_full_manifest ( self . config ) [EOL] self . write_manifest ( ) [EOL] [EOL] def compile_manifest ( self ) : [EOL] if self . manifest is None : [EOL] raise InternalException ( [string] ) [EOL] adapter = get_adapter ( self . config ) [EOL] compiler = adapter . get_compiler ( ) [EOL] self . graph = compiler . compile ( self . manifest ) [EOL] [EOL] def _runtime_initialize ( self ) : [EOL] self . load_manifest ( ) [EOL] self . compile_manifest ( ) [EOL] [EOL] [EOL] class GraphRunnableTask ( ManifestTask ) : [EOL] def __init__ ( self , args , config ) : [EOL] super ( ) . __init__ ( args , config ) [EOL] self . job_queue = None [EOL] self . _flattened_nodes = None [EOL] [EOL] self . run_count = [number] [EOL] self . num_nodes = [number] [EOL] self . node_results = [ ] [EOL] self . _skipped_children = { } [EOL] self . _raise_next_tick = None [EOL] self . previous_state = None [EOL] self . set_previous_state ( ) [EOL] [EOL] def set_previous_state ( self ) : [EOL] if self . args . state is not None : [EOL] self . previous_state = PreviousState ( self . args . state ) [EOL] [EOL] def index_offset ( self , value ) : [EOL] return value [EOL] [EOL] @ abstractmethod def get_selection_spec ( self ) : [EOL] raise NotImplementedException ( f' [string] { type ( self ) }' ) [EOL] [EOL] @ abstractmethod def get_node_selector ( self ) : [EOL] raise NotImplementedException ( f' [string] { type ( self ) }' ) [EOL] [EOL] def get_graph_queue ( self ) : [EOL] selector = self . get_node_selector ( ) [EOL] spec = self . get_selection_spec ( ) [EOL] return selector . get_graph_queue ( spec ) [EOL] [EOL] def _runtime_initialize ( self ) : [EOL] super ( ) . _runtime_initialize ( ) [EOL] if self . manifest is None or self . graph is None : [EOL] raise InternalException ( [string] ) [EOL] [EOL] self . job_queue = self . get_graph_queue ( ) [EOL] [EOL] [comment] [EOL] self . _flattened_nodes = [ ] [EOL] for uid in self . job_queue . get_selected_nodes ( ) : [EOL] if uid in self . manifest . nodes : [EOL] self . _flattened_nodes . append ( self . manifest . nodes [ uid ] ) [EOL] elif uid in self . manifest . sources : [EOL] self . _flattened_nodes . append ( self . manifest . sources [ uid ] ) [EOL] else : [EOL] raise InternalException ( f' [string] { uid } [string] ' f' [string] ' ) [EOL] [EOL] self . num_nodes = len ( [ n for n in self . _flattened_nodes if not n . is_ephemeral_model ] ) [EOL] [EOL] def raise_on_first_error ( self ) : [EOL] return False [EOL] [EOL] def get_runner_type ( self ) : [EOL] raise NotImplementedException ( [string] ) [EOL] [EOL] def result_path ( self ) : [EOL] return os . path . join ( self . config . target_path , RESULT_FILE_NAME ) [EOL] [EOL] def get_runner ( self , node ) : [EOL] adapter = get_adapter ( self . config ) [EOL] [EOL] if node . is_ephemeral_model : [EOL] run_count = [number] [EOL] num_nodes = [number] [EOL] else : [EOL] self . run_count += [number] [EOL] run_count = self . run_count [EOL] num_nodes = self . num_nodes [EOL] [EOL] cls = self . get_runner_type ( ) [EOL] return cls ( self . config , adapter , node , run_count , num_nodes ) [EOL] [EOL] def call_runner ( self , runner ) : [EOL] uid_context = UniqueID ( runner . node . unique_id ) [EOL] with RUNNING_STATE , uid_context : [EOL] startctx = TimestampNamed ( [string] ) [EOL] index = self . index_offset ( runner . node_index ) [EOL] extended_metadata = ModelMetadata ( runner . node , index ) [EOL] with startctx , extended_metadata : [EOL] logger . debug ( [string] . format ( runner . node . unique_id ) ) [EOL] status = ... [EOL] try : [EOL] result = runner . run_with_hooks ( self . manifest ) [EOL] status = runner . get_result_status ( result ) [EOL] finally : [EOL] finishctx = TimestampNamed ( [string] ) [EOL] with finishctx , DbtModelState ( status ) : [EOL] logger . debug ( [string] . format ( runner . node . unique_id ) ) [EOL] [EOL] fail_fast = getattr ( self . config . args , [string] , False ) [EOL] [EOL] if ( result . fail is not None or result . error is not None ) and fail_fast : [EOL] self . _raise_next_tick = FailFastException ( message = [string] , result = result , node = getattr ( result , [string] , None ) ) [EOL] elif result . error is not None and self . raise_on_first_error ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _raise_next_tick = RuntimeException ( result . error ) [EOL] [EOL] return result [EOL] [EOL] def _submit ( self , pool , args , callback ) : [EOL] [docstring] [EOL] if self . config . args . single_threaded : [EOL] callback ( self . call_runner ( * args ) ) [EOL] else : [EOL] pool . apply_async ( self . call_runner , args = args , callback = callback ) [EOL] [EOL] def _raise_set_error ( self ) : [EOL] if self . _raise_next_tick is not None : [EOL] raise self . _raise_next_tick [EOL] [EOL] def run_queue ( self , pool ) : [EOL] [docstring] [EOL] if self . job_queue is None : [EOL] raise InternalException ( [string] ) [EOL] [EOL] def callback ( result ) : [EOL] [docstring] [EOL] self . _handle_result ( result ) [EOL] [EOL] if self . job_queue is None : [EOL] raise InternalException ( [string] ) [EOL] self . job_queue . mark_done ( result . node . unique_id ) [EOL] [EOL] while not self . job_queue . empty ( ) : [EOL] node = self . job_queue . get ( ) [EOL] self . _raise_set_error ( ) [EOL] runner = self . get_runner ( node ) [EOL] [comment] [EOL] [comment] [EOL] if runner . node . unique_id in self . _skipped_children : [EOL] cause = self . _skipped_children . pop ( runner . node . unique_id ) [EOL] runner . do_skip ( cause = cause ) [EOL] args = ( runner , ) [EOL] self . _submit ( pool , args , callback ) [EOL] [EOL] [comment] [EOL] if getattr ( self . config . args , [string] , False ) : [EOL] [comment] [EOL] [comment] [EOL] while self . job_queue . wait_until_something_was_done ( ) : [EOL] self . _raise_set_error ( ) [EOL] else : [EOL] [comment] [EOL] self . job_queue . join ( ) [EOL] [EOL] [comment] [EOL] self . _raise_set_error ( ) [EOL] [EOL] return [EOL] [EOL] def _handle_result ( self , result ) : [EOL] [docstring] [EOL] is_ephemeral = result . node . is_ephemeral_model [EOL] if not is_ephemeral : [EOL] self . node_results . append ( result ) [EOL] [EOL] node = result . node [EOL] [EOL] if self . manifest is None : [EOL] raise InternalException ( [string] ) [EOL] [EOL] if isinstance ( node , ParsedSourceDefinition ) : [EOL] self . manifest . update_source ( node ) [EOL] else : [EOL] self . manifest . update_node ( node ) [EOL] [EOL] if result . error is not None : [EOL] if is_ephemeral : [EOL] cause = result [EOL] else : [EOL] cause = None [EOL] self . _mark_dependent_errors ( node . unique_id , result , cause ) [EOL] [EOL] def _cancel_connections ( self , pool ) : [EOL] [docstring] [EOL] pool . close ( ) [EOL] pool . terminate ( ) [EOL] [EOL] adapter = get_adapter ( self . config ) [EOL] [EOL] if not adapter . is_cancelable ( ) : [EOL] msg = ( [string] [string] [string] . format ( adapter . type ( ) ) ) [EOL] [EOL] yellow = ui . COLOR_FG_YELLOW [EOL] print_timestamped_line ( msg , yellow ) [EOL] else : [EOL] with adapter . connection_named ( [string] ) : [EOL] for conn_name in adapter . cancel_open_connections ( ) : [EOL] if self . manifest is not None : [EOL] node = self . manifest . nodes . get ( conn_name ) [EOL] if node is not None and node . is_ephemeral_model : [EOL] continue [EOL] [comment] [EOL] [comment] [EOL] print_cancel_line ( conn_name ) [EOL] [EOL] pool . join ( ) [EOL] [EOL] def execute_nodes ( self ) : [EOL] num_threads = self . config . threads [EOL] target_name = self . config . target_name [EOL] [EOL] text = [string] [EOL] concurrency_line = text . format ( num_threads , target_name ) [EOL] with NodeCount ( self . num_nodes ) : [EOL] print_timestamped_line ( concurrency_line ) [EOL] with TextOnly ( ) : [EOL] print_timestamped_line ( [string] ) [EOL] [EOL] pool = ThreadPool ( num_threads ) [EOL] try : [EOL] self . run_queue ( pool ) [EOL] [EOL] except FailFastException as failure : [EOL] self . _cancel_connections ( pool ) [EOL] print_run_result_error ( failure . result ) [EOL] raise [EOL] [EOL] except KeyboardInterrupt : [EOL] self . _cancel_connections ( pool ) [EOL] print_run_end_messages ( self . node_results , keyboard_interrupt = True ) [EOL] raise [EOL] [EOL] pool . close ( ) [EOL] pool . join ( ) [EOL] [EOL] return self . node_results [EOL] [EOL] def _mark_dependent_errors ( self , node_id , result , cause ) : [EOL] if self . graph is None : [EOL] raise InternalException ( [string] ) [EOL] for dep_node_id in self . graph . get_dependent_nodes ( node_id ) : [EOL] self . _skipped_children [ dep_node_id ] = cause [EOL] [EOL] def populate_adapter_cache ( self , adapter ) : [EOL] adapter . set_relations_cache ( self . manifest ) [EOL] [EOL] def before_hooks ( self , adapter ) : [EOL] pass [EOL] [EOL] def before_run ( self , adapter , selected_uids ) : [EOL] with adapter . connection_named ( [string] ) : [EOL] self . populate_adapter_cache ( adapter ) [EOL] [EOL] def after_run ( self , adapter , results ) : [EOL] pass [EOL] [EOL] def after_hooks ( self , adapter , results , elapsed ) : [EOL] pass [EOL] [EOL] def execute_with_hooks ( self , selected_uids ) : [EOL] adapter = get_adapter ( self . config ) [EOL] try : [EOL] self . before_hooks ( adapter ) [EOL] started = time . time ( ) [EOL] self . before_run ( adapter , selected_uids ) [EOL] res = self . execute_nodes ( ) [EOL] self . after_run ( adapter , res ) [EOL] elapsed = time . time ( ) - started [EOL] self . after_hooks ( adapter , res , elapsed ) [EOL] [EOL] finally : [EOL] adapter . cleanup_connections ( ) [EOL] [EOL] result = self . get_result ( results = res , elapsed_time = elapsed , generated_at = datetime . utcnow ( ) ) [EOL] return result [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] self . _runtime_initialize ( ) [EOL] [EOL] if self . _flattened_nodes is None : [EOL] raise InternalException ( [string] ) [EOL] [EOL] if len ( self . _flattened_nodes ) == [number] : [EOL] logger . warning ( [string] [string] ) [EOL] return self . get_result ( results = [ ] , generated_at = datetime . utcnow ( ) , elapsed_time = [number] , ) [EOL] else : [EOL] with TextOnly ( ) : [EOL] logger . info ( [string] ) [EOL] [EOL] selected_uids = frozenset ( n . unique_id for n in self . _flattened_nodes ) [EOL] result = self . execute_with_hooks ( selected_uids ) [EOL] [EOL] if flags . WRITE_JSON : [EOL] result . write ( self . result_path ( ) ) [EOL] [EOL] self . task_end_messages ( result . results ) [EOL] return result [EOL] [EOL] def interpret_results ( self , results ) : [EOL] if results is None : [EOL] return False [EOL] [EOL] failures = [ r for r in results if r . error or r . fail ] [EOL] return len ( failures ) == [number] [EOL] [EOL] def get_model_schemas ( self , adapter , selected_uids ) : [EOL] if self . manifest is None : [EOL] raise InternalException ( [string] ) [EOL] result = set ( ) [EOL] [EOL] for node in self . manifest . nodes . values ( ) : [EOL] if node . unique_id not in selected_uids : [EOL] continue [EOL] if node . is_refable and not node . is_ephemeral : [EOL] relation = adapter . Relation . create_from ( self . config , node ) [EOL] result . add ( relation . without_identifier ( ) ) [EOL] [EOL] return result [EOL] [EOL] def create_schemas ( self , adapter , selected_uids ) : [EOL] required_schemas = self . get_model_schemas ( adapter , selected_uids ) [EOL] [comment] [EOL] required_databases = set ( ) [EOL] for required in required_schemas : [EOL] db_only = required . include ( database = True , schema = False , identifier = False ) [EOL] required_databases . add ( db_only ) [EOL] [EOL] existing_schemas_lowered = ... [EOL] existing_schemas_lowered = set ( ) [EOL] [EOL] def list_schemas ( db_only ) : [EOL] [comment] [EOL] database_quoted = ... [EOL] db_lowercase = dbt . utils . lowercase ( db_only . database ) [EOL] if db_only . database is None : [EOL] database_quoted = None [EOL] else : [EOL] database_quoted = str ( db_only ) [EOL] [EOL] [comment] [EOL] return [ ( db_lowercase , s . lower ( ) ) for s in adapter . list_schemas ( database_quoted ) if s is not None ] [EOL] [EOL] def create_schema ( relation ) : [EOL] db = relation . database or [string] [EOL] schema = relation . schema [EOL] with adapter . connection_named ( f' [string] { db } [string] { schema }' ) : [EOL] adapter . create_schema ( relation ) [EOL] [EOL] list_futures = [ ] [EOL] create_futures = [ ] [EOL] [EOL] with dbt . utils . executor ( self . config ) as tpe : [EOL] for req in required_databases : [EOL] if req . database is None : [EOL] name = [string] [EOL] else : [EOL] name = f' [string] { req . database }' [EOL] fut = tpe . submit_connected ( adapter , name , list_schemas , req ) [EOL] list_futures . append ( fut ) [EOL] [EOL] for ls_future in as_completed ( list_futures ) : [EOL] existing_schemas_lowered . update ( ls_future . result ( ) ) [EOL] [EOL] for info in required_schemas : [EOL] if info . schema is None : [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] db = info . database [EOL] db_lower = dbt . utils . lowercase ( db ) [EOL] schema = info . schema [EOL] [EOL] db_schema = ( db_lower , schema . lower ( ) ) [EOL] if db_schema not in existing_schemas_lowered : [EOL] existing_schemas_lowered . add ( db_schema ) [EOL] [EOL] fut = tpe . submit_connected ( adapter , f' [string] { info . database or [string] } [string] { info . schema }' , create_schema , info ) [EOL] create_futures . append ( fut ) [EOL] [EOL] for create_future in as_completed ( create_futures ) : [EOL] [comment] [EOL] create_future . result ( ) [EOL] [EOL] def get_result ( self , results , elapsed_time , generated_at ) : [EOL] return ExecutionResult ( results = results , elapsed_time = elapsed_time , generated_at = generated_at ) [EOL] [EOL] def task_end_messages ( self , results ) : [EOL] print_run_end_messages ( results ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[dbt.contracts.graph.manifest.Manifest]$ 0 0 0 0 0 $typing.Optional[dbt.graph.Graph]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[dbt.graph.Graph.Queue]$ 0 0 0 0 0 $typing.Optional[typing.List[dbt.contracts.graph.compiled.CompileResultNode]]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[dbt.contracts.state.PreviousState]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $dbt.graph.SelectionSpec$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.graph.NodeSelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.graph.Graph.Queue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Tuple[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.AbstractSet[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.frozenset[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.frozenset[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Set[dbt.adapters.base.BaseRelation]$ 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[dbt.adapters.base.BaseRelation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[dbt.adapters.base.BaseRelation]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Set[dbt.adapters.base.BaseRelation]$ 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 $typing.Set[dbt.adapters.base.BaseRelation]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Set[dbt.adapters.base.BaseRelation]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]]$ 0 0 0 $typing.Set[typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Optional[builtins.str],builtins.str]]$ 0 $dbt.adapters.base.BaseRelation$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $dbt.adapters.base.BaseRelation$ 0 0 0 0 0 $dbt.adapters.base.BaseRelation$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $dbt.adapters.base.BaseRelation$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 $dbt.adapters.base.BaseRelation$ 0 0 0 0 0 $dbt.adapters.base.BaseRelation$ 0 0 0 0 0 0 0 $dbt.adapters.base.BaseRelation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.adapters.base.BaseRelation$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[dbt.adapters.base.BaseRelation]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Set[typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Tuple[typing.Optional[builtins.str],builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],builtins.str]$ 0 0 $typing.Set[typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]]$ 0 0 $typing.Set[typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]]$ 0 0 0 $typing.Tuple[typing.Optional[builtins.str],builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import threading [EOL] import time [EOL] from typing import Dict [EOL] [EOL] from . base import BaseRunner [EOL] from . printer import ( print_start_line , print_freshness_result_line , print_run_result_error , ) [EOL] from . runnable import GraphRunnableTask [EOL] [EOL] from dbt . contracts . results import ( FreshnessExecutionResult , SourceFreshnessResult , PartialResult , ) [EOL] from dbt . exceptions import RuntimeException , InternalException [EOL] from dbt . logger import print_timestamped_line [EOL] from dbt . node_types import NodeType [EOL] [EOL] from dbt import utils [EOL] [EOL] from dbt . graph import NodeSelector , SelectionSpec , parse_difference [EOL] from dbt . contracts . graph . parsed import ParsedSourceDefinition [EOL] [EOL] [EOL] RESULT_FILE_NAME = [string] [EOL] [EOL] [EOL] class FreshnessRunner ( BaseRunner ) : [EOL] def on_skip ( self ) : [EOL] raise RuntimeException ( [string] ) [EOL] [EOL] def get_result_status ( self , result ) : [EOL] if result . error : [EOL] return { [string] : [string] , [string] : str ( result . error ) } [EOL] else : [EOL] return { [string] : str ( result . status ) } [EOL] [EOL] def before_execute ( self ) : [EOL] description = [string] . format ( self . node ) [EOL] print_start_line ( description , self . node_index , self . num_nodes ) [EOL] [EOL] def after_execute ( self , result ) : [EOL] print_freshness_result_line ( result , self . node_index , self . num_nodes ) [EOL] [EOL] def _build_run_result ( self , node , start_time , error , status , timing_info , skip = False , failed = None ) : [EOL] execution_time = time . time ( ) - start_time [EOL] thread_id = threading . current_thread ( ) . name [EOL] status = utils . lowercase ( status ) [EOL] return PartialResult ( node = node , status = status , error = error , execution_time = execution_time , thread_id = thread_id , timing = timing_info , ) [EOL] [EOL] def from_run_result ( self , result , start_time , timing_info ) : [EOL] result . execution_time = ( time . time ( ) - start_time ) [EOL] result . timing . extend ( timing_info ) [EOL] return result [EOL] [EOL] def execute ( self , compiled_node , manifest ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if compiled_node . loaded_at_field is None : [EOL] raise InternalException ( [string] [string] ) [EOL] [EOL] relation = self . adapter . Relation . create_from_source ( compiled_node ) [EOL] [comment] [EOL] with self . adapter . connection_for ( compiled_node ) : [EOL] self . adapter . clear_transaction ( ) [EOL] freshness = self . adapter . calculate_freshness ( relation , compiled_node . loaded_at_field , compiled_node . freshness . filter , manifest = manifest ) [EOL] [EOL] status = compiled_node . freshness . status ( freshness [ [string] ] ) [EOL] [EOL] return SourceFreshnessResult ( node = compiled_node , status = status , thread_id = threading . current_thread ( ) . name , ** freshness ) [EOL] [EOL] def compile ( self , manifest ) : [EOL] if self . node . resource_type != NodeType . Source : [EOL] [comment] [EOL] raise RuntimeException ( [string] ) [EOL] [comment] [EOL] return self . node [EOL] [EOL] [EOL] class FreshnessSelector ( NodeSelector ) : [EOL] def node_is_match ( self , node ) : [EOL] if not super ( ) . node_is_match ( node ) : [EOL] return False [EOL] if not isinstance ( node , ParsedSourceDefinition ) : [EOL] return False [EOL] return node . has_freshness [EOL] [EOL] [EOL] class FreshnessTask ( GraphRunnableTask ) : [EOL] def result_path ( self ) : [EOL] if self . args . output : [EOL] return os . path . realpath ( self . args . output ) [EOL] else : [EOL] return os . path . join ( self . config . target_path , RESULT_FILE_NAME ) [EOL] [EOL] def raise_on_first_error ( self ) : [EOL] return False [EOL] [EOL] def get_selection_spec ( self ) : [EOL] include = [ [string] . format ( s ) for s in ( self . args . selected or [ [string] ] ) ] [EOL] spec = parse_difference ( include , None ) [EOL] return spec [EOL] [EOL] def get_node_selector ( self ) : [EOL] if self . manifest is None or self . graph is None : [EOL] raise InternalException ( [string] ) [EOL] return FreshnessSelector ( graph = self . graph , manifest = self . manifest , previous_state = self . previous_state , ) [EOL] [EOL] def get_runner_type ( self ) : [EOL] return FreshnessRunner [EOL] [EOL] def get_result ( self , results , elapsed_time , generated_at ) : [EOL] return FreshnessExecutionResult ( elapsed_time = elapsed_time , generated_at = generated_at , results = results ) [EOL] [EOL] def task_end_messages ( self , results ) : [EOL] for result in results : [EOL] if result . error is not None : [EOL] print_run_result_error ( result ) [EOL] [EOL] print_timestamped_line ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.graph.SelectionSpec$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , List [EOL] import core [EOL] import typing [EOL] import os . path [EOL] import os [EOL] import shutil [EOL] [EOL] from dbt . task . base import BaseTask [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt . config import UnsetProfileConfig [EOL] [EOL] [EOL] class CleanTask ( BaseTask ) : [EOL] ConfigType = UnsetProfileConfig [EOL] [EOL] def __is_project_path ( self , path ) : [EOL] proj_path = os . path . abspath ( [string] ) [EOL] return not os . path . commonprefix ( [ proj_path , os . path . abspath ( path ) ] ) == proj_path [EOL] [EOL] def __is_protected_path ( self , path ) : [EOL] [docstring] [EOL] abs_path = os . path . abspath ( path ) [EOL] protected_paths = self . config . source_paths + self . config . test_paths + [ [string] ] [EOL] protected_abs_paths = [ os . path . abspath ( p ) for p in protected_paths ] [EOL] return abs_path in set ( protected_abs_paths ) or self . __is_project_path ( abs_path ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] for path in self . config . clean_targets : [EOL] logger . info ( [string] . format ( path ) ) [EOL] if not self . __is_protected_path ( path ) : [EOL] shutil . rmtree ( path , True ) [EOL] logger . info ( [string] . format ( path ) ) [EOL] else : [EOL] logger . info ( [string] [string] . format ( path ) ) [EOL] logger . info ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[core.dbt.task.clean.CleanTask]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , List , Optional [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import platform [EOL] import sys [EOL] from typing import Optional , Dict , Any , List [EOL] [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] import dbt . clients . system [EOL] import dbt . exceptions [EOL] from dbt . adapters . factory import get_adapter , register_adapter [EOL] from dbt . config import Project , Profile , PROFILES_DIR [EOL] from dbt . config . renderer import DbtProjectYamlRenderer , ProfileRenderer [EOL] from dbt . config . utils import parse_cli_vars [EOL] from dbt . context . base import generate_base_context [EOL] from dbt . context . target import generate_target_context [EOL] from dbt . clients . yaml_helper import load_yaml_text [EOL] from dbt . links import ProfileConfigDocs [EOL] from dbt . ui import green , red [EOL] from dbt . version import get_installed_version [EOL] [EOL] from dbt . task . base import BaseTask , get_nearest_project_dir [EOL] [EOL] PROFILE_DIR_MESSAGE = [string] [EOL] [EOL] ONLY_PROFILE_MESSAGE = [string] . lstrip ( ) [EOL] [EOL] MULTIPLE_PROFILE_MESSAGE = [string] . lstrip ( ) [EOL] [EOL] COULD_NOT_CONNECT_MESSAGE = [string] . lstrip ( ) [EOL] [EOL] [EOL] MISSING_PROFILE_MESSAGE = [string] . lstrip ( ) [EOL] [EOL] FILE_NOT_FOUND = [string] [EOL] [EOL] [EOL] class QueryCommentedProfile ( Profile ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . query_comment = None [EOL] [EOL] [EOL] class DebugTask ( BaseTask ) : [EOL] def __init__ ( self , args , config ) : [EOL] super ( ) . __init__ ( args , config ) [EOL] self . profiles_dir = getattr ( self . args , [string] , PROFILES_DIR ) [EOL] self . profile_path = os . path . join ( self . profiles_dir , [string] ) [EOL] try : [EOL] self . project_dir = get_nearest_project_dir ( self . args ) [EOL] except dbt . exceptions . Exception : [EOL] [comment] [EOL] [comment] [EOL] if args . project_dir : [EOL] self . project_dir = args . project_dir [EOL] else : [EOL] self . project_dir = os . getcwd ( ) [EOL] self . project_path = os . path . join ( self . project_dir , [string] ) [EOL] self . cli_vars = parse_cli_vars ( getattr ( self . args , [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] self . profile = None [EOL] self . profile_fail_details = [string] [EOL] self . raw_profile_data = None [EOL] self . profile_name = None [EOL] self . project = None [EOL] self . project_fail_details = [string] [EOL] self . messages = [ ] [EOL] [EOL] @ property def project_profile ( self ) : [EOL] if self . project is None : [EOL] return None [EOL] return self . project . profile_name [EOL] [EOL] def path_info ( self ) : [EOL] open_cmd = dbt . clients . system . open_dir_cmd ( ) [EOL] [EOL] message = PROFILE_DIR_MESSAGE . format ( open_cmd = open_cmd , profiles_dir = self . profiles_dir ) [EOL] [EOL] logger . info ( message ) [EOL] [EOL] def run ( self ) : [EOL] if self . args . config_dir : [EOL] self . path_info ( ) [EOL] return [EOL] [EOL] version = get_installed_version ( ) . to_version_string ( skip_matcher = True ) [EOL] print ( [string] . format ( version ) ) [EOL] print ( [string] . format ( sys . version . split ( ) [ [number] ] ) ) [EOL] print ( [string] . format ( sys . executable ) ) [EOL] print ( [string] . format ( platform . platform ( ) ) ) [EOL] print ( [string] . format ( self . profile_path ) ) [EOL] print ( [string] . format ( self . project_path ) ) [EOL] print ( [string] ) [EOL] self . test_configuration ( ) [EOL] self . test_dependencies ( ) [EOL] self . test_connection ( ) [EOL] [EOL] for message in self . messages : [EOL] print ( message ) [EOL] print ( [string] ) [EOL] [EOL] def _load_project ( self ) : [EOL] if not os . path . exists ( self . project_path ) : [EOL] self . project_fail_details = FILE_NOT_FOUND [EOL] return red ( [string] ) [EOL] [EOL] if self . profile is None : [EOL] ctx = generate_base_context ( self . cli_vars ) [EOL] else : [EOL] ctx = generate_target_context ( self . profile , self . cli_vars ) [EOL] [EOL] renderer = DbtProjectYamlRenderer ( ctx ) [EOL] [EOL] try : [EOL] self . project = Project . from_project_root ( self . project_dir , renderer , verify_version = getattr ( self . args , [string] , False ) , ) [EOL] except dbt . exceptions . DbtConfigError as exc : [EOL] self . project_fail_details = str ( exc ) [EOL] return red ( [string] ) [EOL] [EOL] return green ( [string] ) [EOL] [EOL] def _profile_found ( self ) : [EOL] if not self . raw_profile_data : [EOL] return red ( [string] ) [EOL] assert self . raw_profile_data is not None [EOL] if self . profile_name in self . raw_profile_data : [EOL] return green ( [string] ) [EOL] else : [EOL] return red ( [string] ) [EOL] [EOL] def _target_found ( self ) : [EOL] requirements = ( self . raw_profile_data and self . profile_name and self . target_name ) [EOL] if not requirements : [EOL] return red ( [string] ) [EOL] [comment] [EOL] assert self . raw_profile_data is not None [EOL] assert self . profile_name is not None [EOL] assert self . target_name is not None [EOL] if self . profile_name not in self . raw_profile_data : [EOL] return red ( [string] ) [EOL] profiles = self . raw_profile_data [ self . profile_name ] [ [string] ] [EOL] if self . target_name not in profiles : [EOL] return red ( [string] ) [EOL] return green ( [string] ) [EOL] [EOL] def _choose_profile_names ( self ) : [EOL] project_profile = None [EOL] if os . path . exists ( self . project_path ) : [EOL] try : [EOL] partial = Project . partial_load ( os . path . dirname ( self . project_path ) , verify_version = getattr ( self . args , [string] , False ) , ) [EOL] renderer = DbtProjectYamlRenderer ( generate_base_context ( self . cli_vars ) ) [EOL] project_profile = partial . render_profile_name ( renderer ) [EOL] except dbt . exceptions . DbtProjectError : [EOL] pass [EOL] [EOL] args_profile = getattr ( self . args , [string] , None ) [EOL] [EOL] try : [EOL] return [ Profile . pick_profile_name ( args_profile , project_profile ) ] [EOL] except dbt . exceptions . DbtConfigError : [EOL] pass [EOL] [comment] [EOL] [EOL] profiles = [ ] [EOL] if self . raw_profile_data : [EOL] profiles = [ k for k in self . raw_profile_data if k != [string] ] [EOL] if project_profile is None : [EOL] self . messages . append ( [string] ) [EOL] elif len ( profiles ) == [number] : [EOL] self . messages . append ( [string] ) [EOL] elif len ( profiles ) == [number] : [EOL] self . messages . append ( ONLY_PROFILE_MESSAGE . format ( profiles [ [number] ] ) ) [EOL] else : [EOL] self . messages . append ( MULTIPLE_PROFILE_MESSAGE . format ( [string] . join ( [string] . format ( o ) for o in profiles ) ) ) [EOL] return profiles [EOL] [EOL] def _choose_target_name ( self , profile_name ) : [EOL] has_raw_profile = ( self . raw_profile_data is not None and profile_name in self . raw_profile_data ) [EOL] [EOL] if not has_raw_profile : [EOL] return None [EOL] [EOL] [comment] [EOL] assert self . raw_profile_data is not None [EOL] raw_profile = self . raw_profile_data [ profile_name ] [EOL] [EOL] renderer = ProfileRenderer ( generate_base_context ( self . cli_vars ) ) [EOL] [EOL] target_name , _ = Profile . render_profile ( raw_profile = raw_profile , profile_name = profile_name , target_override = getattr ( self . args , [string] , None ) , renderer = renderer ) [EOL] return target_name [EOL] [EOL] def _load_profile ( self ) : [EOL] if not os . path . exists ( self . profile_path ) : [EOL] self . profile_fail_details = FILE_NOT_FOUND [EOL] self . messages . append ( MISSING_PROFILE_MESSAGE . format ( path = self . profile_path , url = ProfileConfigDocs ) ) [EOL] return red ( [string] ) [EOL] [EOL] try : [EOL] raw_profile_data = load_yaml_text ( dbt . clients . system . load_file_contents ( self . profile_path ) ) [EOL] except Exception : [EOL] pass [comment] [EOL] else : [EOL] if isinstance ( raw_profile_data , dict ) : [EOL] self . raw_profile_data = raw_profile_data [EOL] [EOL] profile_errors = [ ] [EOL] profile_names = self . _choose_profile_names ( ) [EOL] renderer = ProfileRenderer ( generate_base_context ( self . cli_vars ) ) [EOL] for profile_name in profile_names : [EOL] try : [EOL] profile = QueryCommentedProfile . render_from_args ( self . args , renderer , profile_name ) [EOL] except dbt . exceptions . DbtConfigError as exc : [EOL] profile_errors . append ( str ( exc ) ) [EOL] else : [EOL] if len ( profile_names ) == [number] : [EOL] [comment] [EOL] self . target_name = self . _choose_target_name ( profile_name ) [EOL] self . profile = profile [EOL] [EOL] if profile_errors : [EOL] self . profile_fail_details = [string] . join ( profile_errors ) [EOL] return red ( [string] ) [EOL] return green ( [string] ) [EOL] [EOL] def test_git ( self ) : [EOL] try : [EOL] dbt . clients . system . run_cmd ( os . getcwd ( ) , [ [string] , [string] ] ) [EOL] except dbt . exceptions . ExecutableError as exc : [EOL] self . messages . append ( [string] . format ( exc ) ) [EOL] return red ( [string] ) [EOL] return green ( [string] ) [EOL] [EOL] def test_dependencies ( self ) : [EOL] print ( [string] ) [EOL] print ( [string] . format ( self . test_git ( ) ) ) [EOL] print ( [string] ) [EOL] [EOL] def test_configuration ( self ) : [EOL] profile_status = self . _load_profile ( ) [EOL] project_status = self . _load_project ( ) [EOL] print ( [string] ) [EOL] print ( [string] . format ( profile_status ) ) [EOL] print ( [string] . format ( project_status ) ) [EOL] [comment] [EOL] if self . profile_name is not None : [EOL] print ( [string] . format ( self . profile_name , self . _profile_found ( ) ) ) [EOL] print ( [string] . format ( self . target_name , self . _target_found ( ) ) ) [EOL] print ( [string] ) [EOL] self . _log_project_fail ( ) [EOL] self . _log_profile_fail ( ) [EOL] [EOL] def _log_project_fail ( self ) : [EOL] if not self . project_fail_details : [EOL] return [EOL] if self . project_fail_details == FILE_NOT_FOUND : [EOL] return [EOL] print ( [string] ) [EOL] print ( self . project_fail_details ) [EOL] print ( [string] ) [EOL] [EOL] def _log_profile_fail ( self ) : [EOL] if not self . profile_fail_details : [EOL] return [EOL] if self . profile_fail_details == FILE_NOT_FOUND : [EOL] return [EOL] print ( [string] ) [EOL] print ( self . profile_fail_details ) [EOL] print ( [string] ) [EOL] [EOL] @ staticmethod def attempt_connection ( profile ) : [EOL] [docstring] [EOL] register_adapter ( profile ) [EOL] adapter = get_adapter ( profile ) [EOL] try : [EOL] with adapter . connection_named ( [string] ) : [EOL] adapter . execute ( [string] ) [EOL] except Exception as exc : [EOL] return COULD_NOT_CONNECT_MESSAGE . format ( err = str ( exc ) , url = ProfileConfigDocs , ) [EOL] [EOL] return None [EOL] [EOL] def _connection_result ( self ) : [EOL] result = self . attempt_connection ( self . profile ) [EOL] if result is not None : [EOL] self . messages . append ( result ) [EOL] return red ( [string] ) [EOL] return green ( [string] ) [EOL] [EOL] def test_connection ( self ) : [EOL] if not self . profile : [EOL] return [EOL] print ( [string] ) [EOL] for k , v in self . profile . credentials . connection_info ( ) : [EOL] print ( [string] . format ( k , v ) ) [EOL] print ( [string] . format ( self . _connection_result ( ) ) ) [EOL] print ( [string] ) [EOL] [EOL] @ classmethod def validate_connection ( cls , target_dict ) : [EOL] [docstring] [EOL] target_name = [string] [EOL] [comment] [EOL] profile_data = { [string] : { target_name : target_dict , } , } [EOL] [comment] [EOL] profile = Profile . from_raw_profile_info ( raw_profile = profile_data , profile_name = [string] , target_override = target_name , renderer = ProfileRenderer ( generate_base_context ( { } ) ) , ) [EOL] result = cls . attempt_connection ( profile ) [EOL] if result is not None : [EOL] raise dbt . exceptions . DbtProfileError ( result , result_type = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[dbt.config.Profile]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[dbt.config.Project]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Dict , Any [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import agate [EOL] from datetime import datetime [EOL] from typing import Dict , Any [EOL] [EOL] import agate [EOL] [EOL] from . runnable import ManifestTask [EOL] [EOL] import dbt . exceptions [EOL] from dbt . adapters . factory import get_adapter [EOL] from dbt . config . utils import parse_cli_vars [EOL] from dbt . contracts . results import RunOperationResult [EOL] from dbt . exceptions import InternalException [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] [EOL] [EOL] class RunOperationTask ( ManifestTask ) : [EOL] def _get_macro_parts ( self ) : [EOL] macro_name = self . args . macro [EOL] if [string] in macro_name : [EOL] package_name , macro_name = macro_name . split ( [string] , [number] ) [EOL] else : [EOL] package_name = None [EOL] [EOL] return package_name , macro_name [EOL] [EOL] def _get_kwargs ( self ) : [EOL] return parse_cli_vars ( self . args . args ) [EOL] [EOL] def compile_manifest ( self ) : [EOL] if self . manifest is None : [EOL] raise InternalException ( [string] ) [EOL] [EOL] def _run_unsafe ( self ) : [EOL] adapter = get_adapter ( self . config ) [EOL] [EOL] package_name , macro_name = self . _get_macro_parts ( ) [EOL] macro_kwargs = self . _get_kwargs ( ) [EOL] [EOL] with adapter . connection_named ( [string] . format ( macro_name ) ) : [EOL] adapter . clear_transaction ( ) [EOL] res = adapter . execute_macro ( macro_name , project = package_name , kwargs = macro_kwargs , manifest = self . manifest ) [EOL] [EOL] return res [EOL] [EOL] def run ( self ) : [EOL] start = datetime . utcnow ( ) [EOL] self . _runtime_initialize ( ) [EOL] try : [EOL] self . _run_unsafe ( ) [EOL] except dbt . exceptions . Exception as exc : [EOL] logger . error ( [string] . format ( exc ) ) [EOL] logger . debug ( [string] , exc_info = True ) [EOL] success = False [EOL] except Exception as exc : [EOL] logger . error ( [string] . format ( exc ) ) [EOL] logger . debug ( [string] , exc_info = True ) [EOL] success = False [EOL] else : [EOL] success = True [EOL] end = datetime . utcnow ( ) [EOL] return RunOperationResult ( results = [ ] , generated_at = end , elapsed_time = ( end - start ) . total_seconds ( ) , success = success ) [EOL] [EOL] def interpret_results ( self , results ) : [EOL] return results . success [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import dbt [EOL] from dbt . contracts . rpc import RemoteExecutionResult [EOL] from dbt . task . runnable import GraphRunnableTask [EOL] from dbt . rpc . method import RemoteManifestMethod , Parameters [EOL] [EOL] [EOL] class RPCTask ( GraphRunnableTask , RemoteManifestMethod [ Parameters , RemoteExecutionResult ] ) : [EOL] def __init__ ( self , args , config , manifest ) : [EOL] super ( ) . __init__ ( args , config ) [EOL] RemoteManifestMethod . __init__ ( self , args , config , manifest ) [EOL] [EOL] def load_manifest ( self ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def get_result ( self , results , elapsed_time , generated_at ) : [EOL] return RemoteExecutionResult ( results = results , elapsed_time = elapsed_time , generated_at = generated_at , logs = [ ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import dbt [EOL] import os [EOL] import shutil [EOL] [EOL] from dbt . contracts . rpc import ( RPCNoParameters , RemoteEmptyResult , RemoteMethodFlags , ) [EOL] from dbt . rpc . method import RemoteMethod [EOL] from dbt . task . deps import DepsTask [EOL] [EOL] [EOL] def _clean_deps ( config ) : [EOL] if os . path . exists ( config . modules_path ) : [EOL] shutil . rmtree ( config . modules_path ) [EOL] os . makedirs ( config . modules_path ) [EOL] [EOL] [EOL] class RemoteDepsTask ( RemoteMethod [ RPCNoParameters , RemoteEmptyResult ] , DepsTask , ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def get_flags ( self ) : [EOL] return ( RemoteMethodFlags . RequiresConfigReloadBefore | RemoteMethodFlags . RequiresManifestReloadAfter ) [EOL] [EOL] def set_args ( self , params ) : [EOL] pass [EOL] [EOL] def handle_request ( self ) : [EOL] _clean_deps ( self . config ) [EOL] self . run ( ) [EOL] return RemoteEmptyResult ( [ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $dbt.contracts.rpc.RemoteMethodFlags$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCNoParameters$ 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteEmptyResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , List , Optional [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] from typing import List , Optional , Union [EOL] [EOL] from dbt import flags [EOL] from dbt . contracts . graph . manifest import WritableManifest [EOL] from dbt . contracts . rpc import ( GetManifestParameters , GetManifestResult , RPCCompileParameters , RPCDocsGenerateParameters , RPCRunParameters , RPCRunOperationParameters , RPCSeedParameters , RPCTestParameters , RemoteCatalogResults , RemoteExecutionResult , RemoteRunOperationResult , RPCSnapshotParameters , RPCSourceFreshnessParameters , ) [EOL] from dbt . rpc . method import ( Parameters , RemoteManifestMethod ) [EOL] [EOL] from dbt . task . base import BaseTask [EOL] from dbt . task . compile import CompileTask [EOL] from dbt . task . freshness import FreshnessTask [EOL] from dbt . task . generate import GenerateTask [EOL] from dbt . task . run import RunTask [EOL] from dbt . task . run_operation import RunOperationTask [EOL] from dbt . task . seed import SeedTask [EOL] from dbt . task . snapshot import SnapshotTask [EOL] from dbt . task . test import TestTask [EOL] [EOL] from . base import RPCTask [EOL] from . cli import HasCLI [EOL] [EOL] [EOL] class RPCCommandTask ( RPCTask [ Parameters ] , HasCLI [ Parameters , RemoteExecutionResult ] , BaseTask , ) : [EOL] @ staticmethod def _listify ( value ) : [EOL] if value is None : [EOL] return None [EOL] elif isinstance ( value , str ) : [EOL] return [ value ] [EOL] else : [EOL] return value [EOL] [EOL] def handle_request ( self ) : [EOL] return self . run ( ) [EOL] [EOL] [EOL] def state_path ( state ) : [EOL] if state is not None : [EOL] return Path ( state ) [EOL] elif flags . ARTIFACT_STATE_PATH is not None : [EOL] return Path ( flags . ARTIFACT_STATE_PATH ) [EOL] else : [EOL] return None [EOL] [EOL] [EOL] class RemoteCompileProjectTask ( RPCCommandTask [ RPCCompileParameters ] , CompileTask ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] self . args . models = self . _listify ( params . models ) [EOL] self . args . exclude = self . _listify ( params . exclude ) [EOL] self . args . selector_name = params . selector [EOL] if params . threads is not None : [EOL] self . args . threads = params . threads [EOL] [EOL] self . args . state = state_path ( params . state ) [EOL] [EOL] self . set_previous_state ( ) [EOL] [EOL] [EOL] class RemoteRunProjectTask ( RPCCommandTask [ RPCRunParameters ] , RunTask ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] self . args . models = self . _listify ( params . models ) [EOL] self . args . exclude = self . _listify ( params . exclude ) [EOL] self . args . selector_name = params . selector [EOL] [EOL] if params . threads is not None : [EOL] self . args . threads = params . threads [EOL] if params . defer is None : [EOL] self . args . defer = flags . DEFER_MODE [EOL] else : [EOL] self . args . defer = params . defer [EOL] [EOL] self . args . state = state_path ( params . state ) [EOL] self . set_previous_state ( ) [EOL] [EOL] [EOL] class RemoteSeedProjectTask ( RPCCommandTask [ RPCSeedParameters ] , SeedTask ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] [comment] [EOL] self . args . models = self . _listify ( params . select ) [EOL] self . args . exclude = self . _listify ( params . exclude ) [EOL] self . args . selector_name = params . selector [EOL] if params . threads is not None : [EOL] self . args . threads = params . threads [EOL] self . args . show = params . show [EOL] [EOL] self . args . state = state_path ( params . state ) [EOL] self . set_previous_state ( ) [EOL] [EOL] [EOL] class RemoteTestProjectTask ( RPCCommandTask [ RPCTestParameters ] , TestTask ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] self . args . models = self . _listify ( params . models ) [EOL] self . args . exclude = self . _listify ( params . exclude ) [EOL] self . args . selector_name = params . selector [EOL] self . args . data = params . data [EOL] self . args . schema = params . schema [EOL] if params . threads is not None : [EOL] self . args . threads = params . threads [EOL] [EOL] self . args . state = state_path ( params . state ) [EOL] self . set_previous_state ( ) [EOL] [EOL] [EOL] class RemoteDocsGenerateProjectTask ( RPCCommandTask [ RPCDocsGenerateParameters ] , GenerateTask , ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] self . args . models = None [EOL] self . args . exclude = None [EOL] self . args . selector_name = None [EOL] self . args . compile = params . compile [EOL] [EOL] self . args . state = state_path ( params . state ) [EOL] [EOL] def get_catalog_results ( self , nodes , sources , generated_at , compile_results , errors ) : [EOL] return RemoteCatalogResults ( nodes = nodes , sources = sources , generated_at = datetime . utcnow ( ) , _compile_results = compile_results , errors = errors , logs = [ ] , ) [EOL] [EOL] [EOL] class RemoteRunOperationTask ( RunOperationTask , RemoteManifestMethod [ RPCRunOperationParameters , RemoteRunOperationResult ] , HasCLI [ RPCRunOperationParameters , RemoteRunOperationResult ] , ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def __init__ ( self , args , config , manifest ) : [EOL] super ( ) . __init__ ( args , config ) [EOL] RemoteManifestMethod . __init__ ( self , args , config , manifest ) [EOL] [EOL] def load_manifest ( self ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def set_args ( self , params ) : [EOL] self . args . macro = params . macro [EOL] self . args . args = params . args [EOL] [EOL] def _get_kwargs ( self ) : [EOL] if isinstance ( self . args . args , dict ) : [EOL] return self . args . args [EOL] else : [EOL] return RunOperationTask . _get_kwargs ( self ) [EOL] [EOL] def _runtime_initialize ( self ) : [EOL] return RunOperationTask . _runtime_initialize ( self ) [EOL] [EOL] def handle_request ( self ) : [EOL] base = RunOperationTask . run ( self ) [EOL] result = RemoteRunOperationResult ( results = base . results , generated_at = base . generated_at , logs = [ ] , success = base . success , elapsed_time = base . elapsed_time ) [EOL] return result [EOL] [EOL] def interpret_results ( self , results ) : [EOL] return results . success [EOL] [EOL] [EOL] class RemoteSnapshotTask ( RPCCommandTask [ RPCSnapshotParameters ] , SnapshotTask ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] [comment] [EOL] self . args . models = self . _listify ( params . select ) [EOL] self . args . exclude = self . _listify ( params . exclude ) [EOL] self . args . selector_name = params . selector [EOL] if params . threads is not None : [EOL] self . args . threads = params . threads [EOL] [EOL] self . args . state = state_path ( params . state ) [EOL] self . set_previous_state ( ) [EOL] [EOL] [EOL] class RemoteSourceFreshnessTask ( RPCCommandTask [ RPCSourceFreshnessParameters ] , FreshnessTask ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] self . args . selected = self . _listify ( params . select ) [EOL] if params . threads is not None : [EOL] self . args . threads = params . threads [EOL] self . args . output = None [EOL] [EOL] [EOL] [comment] [EOL] class GetManifest ( RemoteManifestMethod [ GetManifestParameters , GetManifestResult ] ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def set_args ( self , params ) : [EOL] self . args . models = None [EOL] self . args . exclude = None [EOL] self . args . selector_name = None [EOL] [EOL] def handle_request ( self ) : [EOL] task = RemoteCompileProjectTask ( self . args , self . config , self . manifest ) [EOL] task . handle_request ( ) [EOL] [EOL] manifest = None [EOL] if task . manifest is not None : [EOL] manifest = task . manifest . writable_manifest ( ) [EOL] [EOL] return GetManifestResult ( logs = [ ] , manifest = manifest , ) [EOL] [EOL] def interpret_results ( self , results ) : [EOL] return results . manifest is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.Union[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 $typing.Optional[typing.Union[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.str,typing.List[builtins.str]]]$ 0 0 0 $dbt.contracts.rpc.RemoteExecutionResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.RPCCompileParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCCompileParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCCompileParameters$ 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCCompileParameters$ 0 0 0 0 $dbt.contracts.rpc.RPCCompileParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCCompileParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCCompileParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.RPCRunParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCRunParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCRunParameters$ 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCRunParameters$ 0 0 0 0 0 $dbt.contracts.rpc.RPCRunParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCRunParameters$ 0 0 0 0 $dbt.contracts.rpc.RPCRunParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCRunParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCRunParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.RPCSeedParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSeedParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSeedParameters$ 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSeedParameters$ 0 0 0 0 $dbt.contracts.rpc.RPCSeedParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSeedParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSeedParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSeedParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.RPCTestParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCTestParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCTestParameters$ 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCTestParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCTestParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCTestParameters$ 0 0 0 0 $dbt.contracts.rpc.RPCTestParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCTestParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCTestParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.RPCDocsGenerateParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCDocsGenerateParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCDocsGenerateParameters$ 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteCatalogResults$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.RPCRunOperationParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCRunOperationParameters$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCRunOperationParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RemoteRunOperationResult$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.RPCSnapshotParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSnapshotParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSnapshotParameters$ 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSnapshotParameters$ 0 0 0 0 $dbt.contracts.rpc.RPCSnapshotParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSnapshotParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSnapshotParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.RPCSourceFreshnessParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSourceFreshnessParameters$ 0 0 0 0 0 $dbt.contracts.rpc.RPCSourceFreshnessParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.RPCSourceFreshnessParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.GetManifestParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.rpc.GetManifestResult$ 0 0 0 0 0 $core.dbt.task.rpc.project_commands.RemoteCompileProjectTask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $core.dbt.task.rpc.project_commands.RemoteCompileProjectTask$ 0 0 0 0 0 0 $None$ 0 0 0 0 $core.dbt.task.rpc.project_commands.RemoteCompileProjectTask$ 0 $None$ 0 0 0 0 0 $None$ 0 $core.dbt.task.rpc.project_commands.RemoteCompileProjectTask$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , List , Optional [EOL] import dbt [EOL] import typing [EOL] import abc [EOL] import shlex [EOL] import yaml [EOL] from typing import Type , Optional [EOL] [EOL] [EOL] from dbt . config . utils import parse_cli_vars [EOL] from dbt . contracts . rpc import RPCCliParameters [EOL] [EOL] from dbt . rpc . method import ( RemoteMethod , RemoteManifestMethod , Parameters , Result , ) [EOL] from dbt . exceptions import InternalException [EOL] from dbt . perf_utils import get_full_manifest [EOL] [EOL] from . base import RPCTask [EOL] [EOL] [EOL] class HasCLI ( RemoteMethod [ Parameters , Result ] ) : [EOL] @ classmethod def has_cli_parameters ( cls ) : [EOL] return True [EOL] [EOL] @ abc . abstractmethod def handle_request ( self ) : [EOL] pass [EOL] [EOL] [EOL] class RemoteRPCCli ( RPCTask [ RPCCliParameters ] ) : [EOL] METHOD_NAME = [string] [EOL] [EOL] def __init__ ( self , args , config , manifest ) : [EOL] super ( ) . __init__ ( args , config , manifest ) [EOL] self . task_type = None [EOL] self . real_task = None [EOL] [EOL] def set_config ( self , config ) : [EOL] super ( ) . set_config ( config ) [EOL] [EOL] if self . task_type is None : [EOL] raise InternalException ( [string] ) [EOL] if issubclass ( self . task_type , RemoteManifestMethod ) : [EOL] task_type = self . task_type [EOL] self . real_task = task_type ( self . args , self . config , self . manifest ) [EOL] else : [EOL] self . real_task = self . task_type ( self . args , self . config ) [EOL] [EOL] def set_args ( self , params ) : [EOL] [comment] [EOL] from dbt . main import parse_args , RPCArgumentParser [EOL] split = shlex . split ( params . cli ) [EOL] self . args = parse_args ( split , RPCArgumentParser ) [EOL] self . task_type = self . get_rpc_task_cls ( ) [EOL] [EOL] def get_flags ( self ) : [EOL] if self . task_type is None : [EOL] raise InternalException ( [string] ) [EOL] [comment] [EOL] return self . task_type . get_flags ( self ) [comment] [EOL] [EOL] def get_rpc_task_cls ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] candidate = ... [EOL] for candidate in HasCLI . recursive_subclasses ( ) : [EOL] if candidate . METHOD_NAME == self . args . rpc_method : [EOL] return candidate [EOL] [comment] [EOL] raise InternalException ( [string] . format ( self . args . rpc_method , self . args . which ) ) [EOL] [EOL] def load_manifest ( self ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def handle_request ( self ) : [EOL] if self . real_task is None : [EOL] raise InternalException ( [string] [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] self . config . cli_vars . update ( parse_cli_vars ( getattr ( self . args , [string] , [string] ) ) ) [EOL] [comment] [EOL] [comment] [EOL] dumped = yaml . safe_dump ( self . config . cli_vars ) [EOL] if dumped != self . args . vars : [EOL] self . real_task . args . vars = dumped [EOL] if isinstance ( self . real_task , RemoteManifestMethod ) : [EOL] self . real_task . manifest = get_full_manifest ( self . config , reset = True ) [EOL] [EOL] [comment] [EOL] return self . real_task . handle_request ( ) [EOL] [EOL] def get_selection_spec ( self ) : [EOL] return self . real_task . get_selection_spec ( ) [EOL] [EOL] def get_node_selector ( self ) : [EOL] return self . real_task . get_node_selector ( ) [EOL] [EOL] def interpret_results ( self , results ) : [EOL] if self . real_task is None : [EOL] [comment] [EOL] [comment] [EOL] return False [EOL] return self . real_task . interpret_results ( results ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.method.Result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Type[dbt.rpc.method.RemoteMethod]]$ 0 0 0 0 0 $typing.Optional[dbt.rpc.method.RemoteMethod]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[dbt.rpc.method.RemoteManifestMethod]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[dbt.rpc.method.RemoteManifestMethod]$ 0 0 0 0 0 $typing.Type[dbt.rpc.method.RemoteManifestMethod]$ 0 0 0 $typing.Type[dbt.rpc.method.RemoteManifestMethod]$ 0 0 0 0 0 $typing.Type[dbt.rpc.method.RemoteManifestMethod]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[dbt.rpc.method.RemoteManifestMethod]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.rpc.RPCCliParameters$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 $dbt.contracts.rpc.RPCCliParameters$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[HasCLI]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[HasCLI]$ 0 0 0 0 $typing.Type[HasCLI]$ 0 0 0 0 0 0 0 0 0 $typing.Type[HasCLI]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[HasCLI]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.rpc.method.Result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , List , Set , Union , Dict , Optional , Type , Iterator [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] from typing import ( Any , Dict , Iterable , Union , Optional , List , Iterator , Mapping , Set ) [EOL] [EOL] from dbt . clients . jinja import MacroGenerator , MacroStack [EOL] from dbt . contracts . graph . parsed import ParsedMacro [EOL] from dbt . include . global_project import PROJECT_NAME as GLOBAL_PROJECT_NAME [EOL] from dbt . exceptions import ( raise_duplicate_macro_name , raise_compiler_error ) [EOL] [EOL] [EOL] FlatNamespace = Dict [ str , MacroGenerator ] [EOL] NamespaceMember = Union [ FlatNamespace , MacroGenerator ] [EOL] FullNamespace = Dict [ str , NamespaceMember ] [EOL] [EOL] [EOL] class MacroNamespace ( Mapping ) : [EOL] def __init__ ( self , global_namespace , local_namespace , global_project_namespace , packages , ) : [EOL] self . global_namespace = global_namespace [EOL] self . local_namespace = local_namespace [EOL] self . packages = packages [EOL] self . global_project_namespace = global_project_namespace [EOL] [EOL] def _search_order ( self ) : [EOL] yield self . local_namespace [EOL] yield self . global_namespace [EOL] yield self . packages [EOL] yield { GLOBAL_PROJECT_NAME : self . global_project_namespace , } [EOL] yield self . global_project_namespace [EOL] [EOL] def _keys ( self ) : [EOL] keys = set ( ) [EOL] for search in self . _search_order ( ) : [EOL] keys . update ( search ) [EOL] return keys [EOL] [EOL] def __iter__ ( self ) : [EOL] for key in self . _keys ( ) : [EOL] yield key [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _keys ( ) ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] for dct in self . _search_order ( ) : [EOL] if key in dct : [EOL] return dct [ key ] [EOL] raise KeyError ( key ) [EOL] [EOL] def get_from_package ( self , package_name , name ) : [EOL] pkg = ... [EOL] if package_name is None : [EOL] return self . get ( name ) [EOL] elif package_name == GLOBAL_PROJECT_NAME : [EOL] return self . global_project_namespace . get ( name ) [EOL] elif package_name in self . packages : [EOL] return self . packages [ package_name ] . get ( name ) [EOL] else : [EOL] raise_compiler_error ( f" [string] { package_name } [string] " ) [EOL] [EOL] [EOL] class MacroNamespaceBuilder : [EOL] def __init__ ( self , root_package , search_package , thread_ctx , internal_packages , node = None , ) : [EOL] self . root_package = root_package [EOL] self . search_package = search_package [EOL] self . internal_package_names = set ( internal_packages ) [EOL] self . internal_package_names_order = internal_packages [EOL] self . globals = { } [EOL] self . locals = { } [EOL] self . internal_packages = { } [EOL] self . packages = { } [EOL] self . thread_ctx = thread_ctx [EOL] self . node = node [EOL] [EOL] def _add_macro_to ( self , heirarchy , macro , macro_func , ) : [EOL] if macro . package_name in heirarchy : [EOL] namespace = heirarchy [ macro . package_name ] [EOL] else : [EOL] namespace = { } [EOL] heirarchy [ macro . package_name ] = namespace [EOL] [EOL] if macro . name in namespace : [EOL] raise_duplicate_macro_name ( macro_func . macro , macro , macro . package_name ) [EOL] heirarchy [ macro . package_name ] [ macro . name ] = macro_func [EOL] [EOL] def add_macro ( self , macro , ctx ) : [EOL] macro_name = macro . name [EOL] [EOL] macro_func = MacroGenerator ( macro , ctx , self . node , self . thread_ctx ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if macro . package_name in self . internal_package_names : [EOL] self . _add_macro_to ( self . internal_packages , macro , macro_func ) [EOL] else : [EOL] self . _add_macro_to ( self . packages , macro , macro_func ) [EOL] [EOL] if macro . package_name == self . search_package : [EOL] self . locals [ macro_name ] = macro_func [EOL] elif macro . package_name == self . root_package : [EOL] self . globals [ macro_name ] = macro_func [EOL] [EOL] def add_macros ( self , macros , ctx ) : [EOL] for macro in macros : [EOL] self . add_macro ( macro , ctx ) [EOL] [EOL] def build_namespace ( self , macros , ctx ) : [EOL] self . add_macros ( macros , ctx ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] global_project_namespace = { } [EOL] for pkg in reversed ( self . internal_package_names_order ) : [EOL] if pkg in self . internal_packages : [EOL] global_project_namespace . update ( self . internal_packages [ pkg ] ) [EOL] [EOL] return MacroNamespace ( global_namespace = self . globals , local_namespace = self . locals , global_project_namespace = global_project_namespace , packages = self . packages , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FlatNamespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 0 0 $FlatNamespace$ 0 0 0 0 0 0 $FlatNamespace$ 0 0 0 0 0 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 $dbt.clients.jinja.MacroGenerator$ 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $dbt.clients.jinja.MacroGenerator$ 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 0 $typing.Dict[builtins.str,FlatNamespace]$ 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 0 $dbt.clients.jinja.MacroGenerator$ 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 0 $dbt.clients.jinja.MacroGenerator$ 0 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 $dbt.clients.jinja.MacroGenerator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 $dbt.clients.jinja.MacroGenerator$ 0 0 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $dbt.clients.jinja.MacroGenerator$ 0 0 $dbt.contracts.graph.parsed.ParsedMacro$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $dbt.clients.jinja.MacroGenerator$ 0 0 0 0 0 0 0 $typing.Iterable[dbt.contracts.graph.parsed.ParsedMacro]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Iterable[dbt.contracts.graph.parsed.ParsedMacro]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $MacroNamespace$ 0 0 0 $typing.Iterable[dbt.contracts.graph.parsed.ParsedMacro]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Iterable[dbt.contracts.graph.parsed.ParsedMacro]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $FlatNamespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FlatNamespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FlatNamespace$ 0 $FlatNamespace$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import typing [EOL] from typing import Any , Dict [EOL] [EOL] from dbt . contracts . connection import HasCredentials [EOL] [EOL] from dbt . context . base import ( BaseContext , contextproperty ) [EOL] [EOL] [EOL] class TargetContext ( BaseContext ) : [EOL] def __init__ ( self , config , cli_vars ) : [EOL] super ( ) . __init__ ( cli_vars = cli_vars ) [EOL] self . config = config [EOL] [EOL] @ contextproperty def target ( self ) : [EOL] [docstring] [EOL] return self . config . to_target_dict ( ) [EOL] [EOL] [EOL] def generate_target_context ( config , cli_vars ) : [EOL] ctx = TargetContext ( config , cli_vars ) [EOL] return ctx . to_dict ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import typing [EOL] from typing import ( Any , Dict , Union ) [EOL] [EOL] from dbt . exceptions import ( doc_invalid_args , doc_target_not_found , ) [EOL] from dbt . config . runtime import RuntimeConfig [EOL] from dbt . contracts . graph . compiled import CompileResultNode [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . graph . parsed import ParsedMacro [EOL] [EOL] from dbt . context . base import contextmember [EOL] from dbt . context . configured import SchemaYamlContext [EOL] [EOL] [EOL] class DocsRuntimeContext ( SchemaYamlContext ) : [EOL] def __init__ ( self , config , node , manifest , current_project , ) : [EOL] super ( ) . __init__ ( config , current_project ) [EOL] self . node = node [EOL] self . manifest = manifest [EOL] [EOL] @ contextmember def doc ( self , * args ) : [EOL] [docstring] [EOL] [comment] [EOL] if len ( args ) == [number] : [EOL] doc_package_name = None [EOL] doc_name = args [ [number] ] [EOL] elif len ( args ) == [number] : [EOL] doc_package_name , doc_name = args [EOL] else : [EOL] doc_invalid_args ( self . node , args ) [EOL] [EOL] target_doc = self . manifest . resolve_doc ( doc_name , doc_package_name , self . _project_name , self . node . package_name , ) [EOL] [EOL] if target_doc is None : [EOL] doc_target_not_found ( self . node , doc_name , doc_package_name ) [EOL] [EOL] return target_doc . block_contents [EOL] [EOL] [EOL] def generate_runtime_docs ( config , target , manifest , current_project , ) : [EOL] ctx = DocsRuntimeContext ( config , target , manifest , current_project ) [EOL] return ctx . to_dict ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.config.runtime.RuntimeConfig$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $dbt.config.runtime.RuntimeConfig$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import dbt [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import macros [EOL] from typing import List [EOL] [EOL] from dbt . clients . jinja import MacroStack [EOL] from dbt . contracts . connection import AdapterRequiredConfig [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] [EOL] [EOL] from . configured import ConfiguredContext [EOL] from . macros import MacroNamespaceBuilder [EOL] [EOL] [EOL] class ManifestContext ( ConfiguredContext ) : [EOL] [docstring] [EOL] def __init__ ( self , config , manifest , search_package , ) : [EOL] super ( ) . __init__ ( config ) [EOL] self . manifest = manifest [EOL] self . search_package = search_package [EOL] self . macro_stack = MacroStack ( ) [EOL] builder = self . _get_namespace_builder ( ) [EOL] self . namespace = builder . build_namespace ( self . manifest . macros . values ( ) , self . _ctx , ) [EOL] [EOL] def _get_namespace_builder ( self ) : [EOL] [comment] [EOL] from dbt . adapters . factory import get_adapter_package_names [EOL] internal_packages = get_adapter_package_names ( self . config . credentials . type ) [EOL] return MacroNamespaceBuilder ( self . config . project_name , self . search_package , self . macro_stack , internal_packages , None , ) [EOL] [EOL] def to_dict ( self ) : [EOL] dct = super ( ) . to_dict ( ) [EOL] dct . update ( self . namespace ) [EOL] return dct [EOL] [EOL] [EOL] class QueryHeaderContext ( ManifestContext ) : [EOL] def __init__ ( self , config , manifest ) : [EOL] super ( ) . __init__ ( config , manifest , config . project_name ) [EOL] [EOL] [EOL] def generate_query_header_context ( config , manifest ) : [EOL] ctx = QueryHeaderContext ( config , manifest ) [EOL] return ctx . to_dict ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $core.dbt.context.macros.MacroNamespaceBuilder$ 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.context.macros.MacroNamespaceBuilder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $macros.MacroNamespaceBuilder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 $dbt.contracts.graph.manifest.Manifest$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 $dbt.contracts.graph.manifest.Manifest$ 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import core [EOL] import dbt [EOL] import typing [EOL] import builtins [EOL] from typing import Any , Dict [EOL] [EOL] from dbt . contracts . connection import AdapterRequiredConfig [EOL] from dbt . node_types import NodeType [EOL] from dbt . utils import MultiDict [EOL] [EOL] from dbt . context . base import contextproperty , Var [EOL] from dbt . context . target import TargetContext [EOL] [EOL] [EOL] class ConfiguredContext ( TargetContext ) : [EOL] config = ... [EOL] [EOL] def __init__ ( self , config ) : [EOL] super ( ) . __init__ ( config , config . cli_vars ) [EOL] [EOL] @ contextproperty def project_name ( self ) : [EOL] return self . config . project_name [EOL] [EOL] [EOL] class FQNLookup : [EOL] def __init__ ( self , package_name ) : [EOL] self . package_name = package_name [EOL] self . fqn = [ package_name ] [EOL] self . resource_type = NodeType . Model [EOL] [EOL] [EOL] class ConfiguredVar ( Var ) : [EOL] def __init__ ( self , context , config , project_name , ) : [EOL] super ( ) . __init__ ( context , config . cli_vars ) [EOL] self . _config = config [EOL] self . _project_name = project_name [EOL] [EOL] def __call__ ( self , var_name , default = Var . _VAR_NOTSET ) : [EOL] my_config = self . _config . load_dependencies ( ) [ self . _project_name ] [EOL] [EOL] [comment] [EOL] if var_name in self . _config . cli_vars : [EOL] return self . _config . cli_vars [ var_name ] [EOL] [EOL] adapter_type = self . _config . credentials . type [EOL] lookup = FQNLookup ( self . _project_name ) [EOL] active_vars = self . _config . vars . vars_for ( lookup , adapter_type ) [EOL] all_vars = MultiDict ( [ active_vars ] ) [EOL] [EOL] if self . _config . project_name != my_config . project_name : [EOL] all_vars . add ( my_config . vars . vars_for ( lookup , adapter_type ) ) [EOL] [EOL] if var_name in all_vars : [EOL] return all_vars [ var_name ] [EOL] [EOL] if default is not Var . _VAR_NOTSET : [EOL] return default [EOL] [EOL] return self . get_missing_var ( var_name ) [EOL] [EOL] [EOL] class SchemaYamlContext ( ConfiguredContext ) : [EOL] def __init__ ( self , config , project_name ) : [EOL] super ( ) . __init__ ( config ) [EOL] self . _project_name = project_name [EOL] [EOL] @ contextproperty def var ( self ) : [EOL] return ConfiguredVar ( self . _ctx , self . config , self . _project_name ) [EOL] [EOL] [EOL] def generate_schema_yml ( config , project_name ) : [EOL] ctx = SchemaYamlContext ( config , project_name ) [EOL] return ctx . to_dict ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 0 0 0 0 $None$ 0 0 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 0 0 0 0 0 0 0 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 0 0 0 0 0 0 0 $dbt.contracts.connection.AdapterRequiredConfig$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.dbt.context.configured.FQNLookup$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $core.dbt.context.configured.FQNLookup$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $core.dbt.context.configured.FQNLookup$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $ConfiguredVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] PACKAGE_PATH = os . path . dirname ( __file__ ) [EOL] PROJECT_NAME = [string] [EOL] [EOL] DOCS_INDEX_FILE_PATH = os . path . normpath ( os . path . join ( PACKAGE_PATH , [string] , [string] ) ) [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
	0
	0
from typing import Dict , Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] class TestSnowflakeLateBindingViewDependency ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : False , } , [string] : { [string] : False , [string] : False } } [EOL] [EOL] [docstring] [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__changed_table_schema_for_downstream_view ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] ) [EOL] [EOL] [docstring] [EOL] @ use_profile ( [string] ) def test__snowflake__changed_table_schema_for_downstream_view_changed_to_table ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] ] ) [EOL] [EOL] expected_types = { [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] for result in results : [EOL] node_name = result . node . name [EOL] self . assertEqual ( result . node . config . materialized , expected_types [ node_name ] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] ) [EOL] [EOL] expected_types = { [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] for result in results : [EOL] node_name = result . node . name [EOL] self . assertEqual ( result . node . config . materialized , expected_types [ node_name ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__presto__changed_table_schema_for_downstream_view ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__presto__changed_table_schema_for_downstream_view_changed_to_table ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] ] ) [EOL] [EOL] expected_types = { [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] for result in results : [EOL] node_name = result . node . name [EOL] self . assertEqual ( result . node . config . materialized , expected_types [ node_name ] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] ) [EOL] [EOL] expected_types = { [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] for result in results : [EOL] node_name = result . node . name [EOL] self . assertEqual ( result . node . config . materialized , expected_types [ node_name ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import pytest [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] def env_set_truthy ( key ) : [EOL] [docstring] [EOL] value = os . getenv ( key ) [EOL] if not value or value . lower ( ) in ( [string] , [string] , [string] ) : [EOL] return None [EOL] return value [EOL] [EOL] [EOL] OAUTH_TESTS_DISABLED = env_set_truthy ( [string] ) [EOL] [EOL] [EOL] class TestSnowflakeOauth ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return path . lstrip ( [string] ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] def snowflake_profile ( self ) : [EOL] profile = super ( ) . snowflake_profile ( ) [EOL] profile [ [string] ] [ [string] ] = [string] [EOL] missing = [string] . join ( k for k in ( [string] , [string] , [string] ) if k not in profile [ [string] ] [ [string] ] [ [string] ] ) [EOL] if missing : [EOL] raise ValueError ( f' [string] { missing } [string] ' ) [EOL] del profile [ [string] ] [ [string] ] [ [string] ] [EOL] del profile [ [string] ] [ [string] ] [ [string] ] [EOL] return profile [EOL] [EOL] @ pytest . mark . skipif ( OAUTH_TESTS_DISABLED , reason = [string] ) @ use_profile ( [string] ) def test_snowflake_basic ( self ) : [EOL] self . run_dbt ( ) [EOL] self . assertManyRelationsEqual ( [ [ [string] ] , [ [string] ] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] import re [EOL] import yaml [EOL] [EOL] import pytest [EOL] [EOL] [EOL] class TestDebug ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( value ) : [EOL] return os . path . normpath ( value ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] def postgres_profile ( self ) : [EOL] profile = super ( TestDebug , self ) . postgres_profile ( ) [EOL] profile [ [string] ] [ [string] ] . update ( { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , [string] : None } ) [EOL] return profile [EOL] [EOL] @ pytest . fixture ( autouse = True ) def capsys ( self , capsys ) : [EOL] self . capsys = capsys [EOL] [EOL] def assertGotValue ( self , linepat , result ) : [EOL] found = False [EOL] output = self . capsys . readouterr ( ) . out [EOL] for line in output . split ( [string] ) : [EOL] if linepat . match ( line ) : [EOL] found = True [EOL] self . assertIn ( result , line , [string] . format ( result , linepat ) ) [EOL] self . assertTrue ( found , [string] . format ( linepat , output ) ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_ok ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertNotIn ( [string] , self . capsys . readouterr ( ) . out ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_nopass ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertGotValue ( re . compile ( [string] ) , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_wronguser ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertGotValue ( re . compile ( [string] ) , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_empty_target ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertGotValue ( re . compile ( [string] ) , [string] ) [EOL] [EOL] [EOL] class TestDebugProfileVariable ( TestDebug ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [string] } [EOL] [EOL] [EOL] class TestDebugInvalidProject ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( value ) : [EOL] return os . path . normpath ( value ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ pytest . fixture ( autouse = True ) def capsys ( self , capsys ) : [EOL] self . capsys = capsys [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_empty_project ( self ) : [EOL] with open ( [string] , [string] ) as f : [EOL] pass [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] splitout = self . capsys . readouterr ( ) . out . split ( [string] ) [EOL] for line in splitout : [EOL] if line . strip ( ) . startswith ( [string] ) : [EOL] self . assertIn ( [string] , line ) [EOL] elif line . strip ( ) . startswith ( [string] ) : [EOL] self . assertNotIn ( [string] , line ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_badproject ( self ) : [EOL] [comment] [EOL] self . use_default_project ( overrides = { [string] : [string] , } ) [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] splitout = self . capsys . readouterr ( ) . out . split ( [string] ) [EOL] for line in splitout : [EOL] if line . strip ( ) . startswith ( [string] ) : [EOL] self . assertIn ( [string] , line ) [EOL] elif line . strip ( ) . startswith ( [string] ) : [EOL] self . assertNotIn ( [string] , line ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_not_found_project_dir ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] splitout = self . capsys . readouterr ( ) . out . split ( [string] ) [EOL] for line in splitout : [EOL] if line . strip ( ) . startswith ( [string] ) : [EOL] self . assertIn ( [string] , line ) [EOL] elif line . strip ( ) . startswith ( [string] ) : [EOL] self . assertNotIn ( [string] , line ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_invalid_project_outside_current_dir ( self ) : [EOL] [comment] [EOL] project_config = { [string] : [string] } [EOL] os . makedirs ( [string] , exist_ok = True ) [EOL] with open ( [string] , [string] ) as f : [EOL] yaml . safe_dump ( project_config , f , default_flow_style = True ) [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] splitout = self . capsys . readouterr ( ) . out . split ( [string] ) [EOL] for line in splitout : [EOL] if line . strip ( ) . startswith ( [string] ) : [EOL] self . assertIn ( [string] , line ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from dbt . exceptions import CompilationException [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestDuplicateModelEnabled ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , } , [string] : [string] } } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_model_enabled ( self ) : [EOL] message = [string] [EOL] try : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertTrue ( False , [string] ) [EOL] except CompilationException as e : [EOL] self . assertTrue ( message in str ( e ) , [string] ) [EOL] [EOL] [EOL] class TestDuplicateModelDisabled ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , } , [string] : [string] } } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_model_disabled ( self ) : [EOL] try : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] except CompilationException : [EOL] self . fail ( [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] query = [string] . format ( schema = self . unique_schema ( ) ) [EOL] result = self . run_sql ( query , fetch = [string] ) [ [number] ] [EOL] self . assertEqual ( result , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_model_disabled_partial_parsing ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestDuplicateModelEnabledAcrossPackages ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_model_enabled_across_packages ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] message = [string] [EOL] try : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertTrue ( False , [string] ) [EOL] except CompilationException as e : [EOL] self . assertTrue ( message in str ( e ) , [string] ) [EOL] [EOL] [EOL] class TestDuplicateModelDisabledAcrossPackages ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_model_disabled_across_packages ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] try : [EOL] self . run_dbt ( [ [string] ] ) [EOL] except CompilationException : [EOL] self . fail ( [string] ) [EOL] query = [string] . format ( schema = self . unique_schema ( ) ) [EOL] result = self . run_sql ( query , fetch = [string] ) [ [number] ] [EOL] assert result == [number] [EOL] [EOL] [EOL] class TestModelTestOverlap ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . models ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_test_model_paths ( self ) : [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dbt . exceptions import CompilationException [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestDuplicateSourceEnabled ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , } , [string] : [string] } } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_model_enabled ( self ) : [EOL] message = [string] [EOL] try : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertTrue ( False , [string] ) [EOL] except CompilationException as e : [EOL] self . assertTrue ( message in str ( e ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
import os [EOL] from dbt . exceptions import CompilationException [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestDuplicateMacroEnabledSameFile ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_macros ( self ) : [EOL] with self . assertRaises ( CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( os . path . join ( [string] , [string] ) , str ( exc . exception ) ) [EOL] [EOL] [EOL] class TestDuplicateMacroEnabledDifferentFiles ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_macros ( self ) : [EOL] with self . assertRaises ( CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( os . path . join ( [string] , [string] ) , str ( exc . exception ) ) [EOL] self . assertIn ( os . path . join ( [string] , [string] ) , str ( exc . exception ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from freezegun import freeze_time [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestTimezones ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , } , [string] : [string] } } [EOL] [EOL] @ property def query ( self ) : [EOL] return [string] . format ( schema = self . unique_schema ( ) ) [EOL] [EOL] @ freeze_time ( [string] , tz_offset = [number] ) @ use_profile ( [string] ) def test_postgres_run_started_at ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] result = self . run_sql ( self . query , fetch = [string] ) [ [number] ] [EOL] est , utc = result [EOL] self . assertEqual ( utc , [string] ) [EOL] self . assertEqual ( est , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Literal [EOL] import typing_extensions [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] import shutil [EOL] import tempfile [EOL] import yaml [EOL] [EOL] [EOL] class ModelCopyingIntegrationTest ( DBTIntegrationTest ) : [EOL] [EOL] def _symlink_test_folders ( self ) : [EOL] [comment] [EOL] for entry in os . listdir ( self . test_original_source_path ) : [EOL] src = os . path . join ( self . test_original_source_path , entry ) [EOL] tst = os . path . join ( self . test_root_dir , entry ) [EOL] if entry == [string] : [EOL] shutil . copytree ( src , tst ) [EOL] elif entry == [string] : [EOL] continue [EOL] elif os . path . isdir ( entry ) or entry . endswith ( [string] ) : [EOL] os . symlink ( src , tst ) [EOL] [EOL] @ property def packages_config ( self ) : [EOL] path = os . path . join ( self . test_original_source_path , [string] ) [EOL] return { [string] : [ { [string] : path , } ] , } [EOL] [EOL] [EOL] class TestCLIInvocation ( ModelCopyingIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_toplevel_dbt_run ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_subdir_dbt_run ( self ) : [EOL] os . chdir ( os . path . join ( self . models , [string] ) ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [EOL] class TestCLIInvocationWithProfilesDir ( ModelCopyingIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] [EOL] self . run_sql ( f" [string] { self . custom_schema } [string] " ) [EOL] self . run_sql ( f" [string] { self . custom_schema } [string] " ) [EOL] [EOL] [comment] [EOL] if not os . path . exists ( [string] ) : [EOL] os . makedirs ( [string] ) [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] yaml . safe_dump ( self . custom_profile_config ( ) , f , default_flow_style = True ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . run_sql ( f" [string] { self . custom_schema } [string] " ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] def custom_profile_config ( self ) : [EOL] return { [string] : { [string] : False } , [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . custom_schema } , } , [string] : [string] , } } [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def custom_schema ( self ) : [EOL] return [string] . format ( self . unique_schema ( ) ) [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_toplevel_dbt_run_with_profile_dir_arg ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] , profiles_dir = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] actual = self . run_sql ( [string] . format ( self . custom_schema ) , fetch = [string] ) [EOL] [EOL] expected = ( [number] , ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] res = self . run_dbt ( [ [string] , [string] , [string] ] , profiles_dir = False ) [EOL] [EOL] [comment] [EOL] for test_result in res : [EOL] self . assertTrue ( self . custom_schema , test_result . node . injected_sql ) [EOL] [EOL] [EOL] class TestCLIInvocationWithProjectDir ( ModelCopyingIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_dbt_commands_with_cwd_as_project_dir ( self ) : [EOL] self . _run_simple_dbt_commands ( os . getcwd ( ) ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_dbt_commands_with_randomdir_as_project_dir ( self ) : [EOL] workdir = os . getcwd ( ) [EOL] with tempfile . TemporaryDirectory ( ) as tmpdir : [EOL] os . chdir ( tmpdir ) [EOL] self . _run_simple_dbt_commands ( workdir ) [EOL] os . chdir ( workdir ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_dbt_commands_with_relative_dir_as_project_dir ( self ) : [EOL] workdir = os . getcwd ( ) [EOL] with tempfile . TemporaryDirectory ( ) as tmpdir : [EOL] os . chdir ( tmpdir ) [EOL] self . _run_simple_dbt_commands ( os . path . relpath ( workdir , tmpdir ) ) [EOL] os . chdir ( workdir ) [EOL] [EOL] def _run_simple_dbt_commands ( self , project_dir ) : [EOL] self . run_dbt ( [ [string] , [string] , project_dir ] ) [EOL] self . run_dbt ( [ [string] , [string] , project_dir ] ) [EOL] self . run_dbt ( [ [string] , [string] , project_dir ] ) [EOL] self . run_dbt ( [ [string] , [string] , project_dir ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set , Union , Dict , Tuple [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] from dbt . logger import log_manager [EOL] [EOL] import json [EOL] [EOL] [EOL] class TestStrictUndefined ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( value ) : [EOL] return os . path . normpath ( value ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . dir ( [string] ) ] , [string] : [ self . dir ( [string] ) ] , [string] : [ self . dir ( [string] ) ] , [string] : [ self . dir ( [string] ) ] , [string] : [ self . dir ( [string] ) ] , [string] : { [string] : False , } , } [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . maxDiff = None [EOL] [EOL] def run_dbt_ls ( self , args = None , expect_pass = True ) : [EOL] log_manager . stdout_console ( ) [EOL] full_args = [ [string] ] [EOL] if args is not None : [EOL] full_args = full_args + args [EOL] [EOL] result = self . run_dbt ( args = full_args , expect_pass = expect_pass , strict = False , parser = False ) [EOL] [EOL] log_manager . stdout_console ( ) [EOL] return result [EOL] [EOL] def assertEqualJSON ( self , json_str , expected ) : [EOL] self . assertEqual ( json . loads ( json_str ) , expected ) [EOL] [EOL] def expect_given_output ( self , args , expectations ) : [EOL] for key , values in expectations . items ( ) : [EOL] ls_result = self . run_dbt_ls ( args + [ [string] , key ] ) [EOL] if not isinstance ( values , ( list , tuple ) ) : [EOL] values = [ values ] [EOL] self . assertEqual ( len ( ls_result ) , len ( values ) ) [EOL] for got , expected in zip ( ls_result , values ) : [EOL] if key == [string] : [EOL] self . assertEqualJSON ( got , expected ) [EOL] else : [EOL] self . assertEqual ( got , expected ) [EOL] [EOL] def expect_snapshot_output ( self ) : [EOL] expectations = { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [ ] , [string] : [ ] } , [string] : [ ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : self . default_database , [string] : self . unique_schema ( ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , [string] : self . dir ( [string] ) , } [EOL] self . expect_given_output ( [ [string] , [string] ] , expectations ) [EOL] [EOL] def expect_analyses_output ( self ) : [EOL] expectations = { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [ ] , [string] : [ ] } , [string] : [ ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , [string] : self . dir ( [string] ) , } [EOL] self . expect_given_output ( [ [string] , [string] ] , expectations ) [EOL] [EOL] def expect_model_output ( self ) : [EOL] expectations = { [string] : ( [string] , [string] , [string] , [string] ) , [string] : ( [string] , [string] , [string] , [string] ) , [string] : ( { [string] : [string] , [string] : [string] , [string] : { [string] : [ ] , [string] : [ ] } , [string] : [ ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] ] , [string] : [ [string] ] } , [string] : [ ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : [string] , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] ] , [string] : [ ] } , [string] : [ ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] ] , [string] : [ ] } , [string] : [ ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , ) , [string] : ( self . dir ( [string] ) , self . dir ( [string] ) , self . dir ( [string] ) , self . dir ( [string] ) ) , } [EOL] self . expect_given_output ( [ [string] , [string] ] , expectations ) [EOL] [EOL] [comment] [EOL] def expect_model_ephemeral_output ( self ) : [EOL] expectations = { [string] : ( [string] ) , [string] : ( [string] ) , [string] : ( { [string] : [string] , [string] : [string] , [string] : { [string] : [ ] , [string] : [ ] } , [string] : [ ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , ) , [string] : ( self . dir ( [string] ) , ) , } [EOL] self . expect_given_output ( [ [string] , [string] ] , expectations ) [EOL] [EOL] def expect_source_output ( self ) : [EOL] expectations = { [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : True , } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , } , [string] : self . dir ( [string] ) , } [EOL] [comment] [EOL] [comment] [EOL] self . expect_given_output ( [ [string] , [string] , [string] , [string] ] , expectations ) [EOL] [EOL] def expect_seed_output ( self ) : [EOL] expectations = { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [ ] , [string] : [ ] } , [string] : [ ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : False , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , [string] : self . dir ( [string] ) , } [EOL] self . expect_given_output ( [ [string] , [string] ] , expectations ) [EOL] [EOL] def expect_test_output ( self ) : [EOL] expectations = { [string] : ( [string] , [string] , [string] ) , [string] : ( [string] , [string] , [string] ) , [string] : ( { [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] ] , [string] : [ [string] ] } , [string] : [ [string] ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : { [string] : [ ] , [string] : [ ] } , [string] : [ [string] ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] ] , [string] : [ [string] ] } , [string] : [ [string] ] , [string] : { [string] : True , [string] : [string] , [string] : [ ] , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : None , [string] : None , [string] : None , } , [string] : [string] , [string] : [string] , } , ) , [string] : ( self . dir ( [string] ) , self . dir ( [string] ) , self . dir ( [string] ) ) , } [EOL] self . expect_given_output ( [ [string] , [string] ] , expectations ) [EOL] [EOL] def expect_all_output ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] expected_default = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [comment] [EOL] expected_all = expected_default | { [string] } [EOL] [EOL] results = self . run_dbt_ls ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( set ( results ) , expected_all ) [EOL] [EOL] results = self . run_dbt_ls ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( set ( results ) , expected_default ) [EOL] [EOL] results = self . run_dbt_ls ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( set ( results ) , expected_default ) [EOL] [EOL] results = self . run_dbt_ls [EOL] [EOL] def expect_select ( self ) : [EOL] results = self . run_dbt_ls ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( set ( results ) , { [string] , [string] } ) [EOL] [EOL] self . run_dbt_ls ( [ [string] , [string] , [string] , [string] ] , expect_pass = False ) [EOL] [EOL] results = self . run_dbt_ls ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( set ( results ) , { [string] , [string] } ) [EOL] [EOL] results = self . run_dbt_ls ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( set ( results ) , { [string] , [string] } ) [EOL] [EOL] results = self . run_dbt_ls ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( set ( results ) , { [string] , [string] , [string] } ) [EOL] [EOL] results = self . run_dbt_ls ( [ [string] , [string] ] ) [EOL] self . assertEqual ( set ( results ) , { [string] } ) [EOL] [EOL] self . run_dbt_ls ( [ [string] , [string] ] , expect_pass = False ) [EOL] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_ls ( self ) : [EOL] self . expect_snapshot_output ( ) [EOL] self . expect_analyses_output ( ) [EOL] self . expect_model_output ( ) [EOL] self . expect_source_output ( ) [EOL] self . expect_seed_output ( ) [EOL] self . expect_test_output ( ) [EOL] self . expect_select ( ) [EOL] self . expect_all_output ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Tuple[typing.Any,typing.Any,typing.Any,typing.Any],typing.Tuple[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Any]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[typing.Any],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[typing.Any],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]],typing.List[typing.Any],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]],typing.List[typing.Any],builtins.str]]],typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Tuple[typing.Any,typing.Any,typing.Any,typing.Any],typing.Tuple[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Any]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[typing.Any],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[typing.Any],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]],typing.List[typing.Any],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]],typing.List[typing.Any],builtins.str]]],typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,typing.Tuple[typing.Any],typing.Tuple[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Any]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[typing.Any],builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,typing.Tuple[typing.Any],typing.Tuple[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Any]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[typing.Any],builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Tuple[typing.Any,typing.Any,typing.Any],typing.Tuple[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[builtins.str],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Any]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[builtins.str],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[builtins.str],builtins.str]]],typing.Tuple[builtins.str,builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Tuple[typing.Any,typing.Any,typing.Any],typing.Tuple[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[builtins.str],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Any]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[builtins.str],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.str]],typing.List[builtins.str],builtins.str]]],typing.Tuple[builtins.str,builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestContextVars ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_json_data_tests_postgres ( self ) : [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] ] ) ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] import os [EOL] [EOL] import pytest [EOL] [EOL] import dbt . exceptions [EOL] [EOL] [EOL] class TestContextVars ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] os . environ [ [string] ] = [string] [EOL] [EOL] os . environ [ [string] ] = [string] [EOL] os . environ [ [string] ] = [string] [EOL] [EOL] self . fields = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } } , [string] : [string] } } [EOL] [EOL] def get_ctx_vars ( self ) : [EOL] field_list = [string] . join ( [ [string] . format ( f ) for f in self . fields ] ) [EOL] query = [string] . format ( field_list = field_list , schema = self . unique_schema ( ) ) [EOL] [EOL] vals = self . run_sql ( query , fetch = [string] ) [EOL] ctx = dict ( [ ( k , v ) for ( k , v ) in zip ( self . fields , vals [ [number] ] ) ] ) [EOL] [EOL] return ctx [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_env_vars_dev ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] ctx = self . get_ctx_vars ( ) [EOL] [EOL] this = [string] . format ( self . default_database , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , this ) [EOL] [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . database_host ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_env_vars_prod ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] ctx = self . get_ctx_vars ( ) [EOL] [EOL] this = [string] . format ( self . default_database , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , this ) [EOL] [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . database_host ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] [EOL] [EOL] class TestEmitWarning ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_warn ( self ) : [EOL] with pytest . raises ( dbt . exceptions . CompilationException ) : [EOL] self . run_dbt ( [ [string] ] , strict = True ) [EOL] self . run_dbt ( [ [string] ] , strict = False , expect_pass = True ) [EOL] [EOL] [EOL] class TestVarDependencyInheritance ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } , ] } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : [string] , [string] : { [string] : [string] , } , [string] : { [string] : [string] , } , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_var_mutual_overrides_v1_conversion ( self ) : [EOL] self . run_dbt ( [ [string] ] , strict = False ) [EOL] assert len ( self . run_dbt ( [ [string] ] , strict = False ) ) == [number] [EOL] assert len ( self . run_dbt ( [ [string] ] , strict = False ) ) == [number] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [EOL] class TestMissingVarGenerateNameMacro ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_generate_schema_name_var ( self ) : [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] assert [string] in str ( exc . exception ) [EOL] [EOL] [comment] [EOL] self . use_default_project ( { [string] : { [string] : [number] , } , [string] : [ [string] ] , } ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] self . use_default_project ( { [string] : { [string] : { [string] : [number] , } , } , [string] : [ [string] ] , } ) [EOL] self . run_dbt ( [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] [EOL] import json [EOL] [EOL] [EOL] class BasePersistDocsTest ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def _assert_common_comments ( self , * comments ) : [EOL] for comment in comments : [EOL] assert [string] in comment [EOL] assert [string] in comment [EOL] assert [string] in comment [EOL] assert [string] in comment [EOL] assert [string] in comment [EOL] if os . name == [string] : [EOL] assert [string] in comment or [string] in comment [EOL] else : [EOL] assert [string] in comment [EOL] [EOL] def _assert_has_table_comments ( self , table_node ) : [EOL] table_comment = table_node [ [string] ] [ [string] ] [EOL] assert table_comment . startswith ( [string] ) [EOL] [EOL] table_id_comment = table_node [ [string] ] [ [string] ] [ [string] ] [EOL] assert table_id_comment . startswith ( [string] ) [EOL] [EOL] table_name_comment = table_node [ [string] ] [ [string] ] [ [string] ] [EOL] assert table_name_comment . startswith ( [string] ) [EOL] [EOL] self . _assert_common_comments ( table_comment , table_id_comment , table_name_comment ) [EOL] [EOL] def _assert_has_view_comments ( self , view_node , has_node_comments = True , has_column_comments = True ) : [EOL] view_comment = view_node [ [string] ] [ [string] ] [EOL] if has_node_comments : [EOL] assert view_comment . startswith ( [string] ) [EOL] self . _assert_common_comments ( view_comment ) [EOL] else : [EOL] assert view_comment is None [EOL] [EOL] view_id_comment = view_node [ [string] ] [ [string] ] [ [string] ] [EOL] if has_column_comments : [EOL] assert view_id_comment . startswith ( [string] ) [EOL] self . _assert_common_comments ( view_id_comment ) [EOL] else : [EOL] assert view_id_comment is None [EOL] [EOL] view_name_comment = view_node [ [string] ] [ [string] ] [ [string] ] [EOL] assert view_name_comment is None [EOL] [EOL] [EOL] class TestPersistDocs ( BasePersistDocsTest ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : { [string] : True , [string] : True , } , } } } [EOL] [EOL] def run_has_comments_pglike ( self ) : [EOL] self . run_dbt ( ) [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] with open ( [string] ) as fp : [EOL] catalog_data = json . load ( fp ) [EOL] assert [string] in catalog_data [EOL] assert len ( catalog_data [ [string] ] ) == [number] [EOL] table_node = catalog_data [ [string] ] [ [string] ] [EOL] view_node = self . _assert_has_table_comments ( table_node ) [EOL] [EOL] view_node = catalog_data [ [string] ] [ [string] ] [EOL] self . _assert_has_view_comments ( view_node ) [EOL] [EOL] no_docs_node = catalog_data [ [string] ] [ [string] ] [EOL] self . _assert_has_view_comments ( no_docs_node , False , False ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_comments ( self ) : [EOL] self . run_has_comments_pglike ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_comments ( self ) : [EOL] self . run_has_comments_pglike ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_comments ( self ) : [EOL] self . run_dbt ( ) [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] with open ( [string] ) as fp : [EOL] catalog_data = json . load ( fp ) [EOL] assert [string] in catalog_data [EOL] assert len ( catalog_data [ [string] ] ) == [number] [EOL] table_node = catalog_data [ [string] ] [ [string] ] [EOL] table_comment = table_node [ [string] ] [ [string] ] [EOL] assert table_comment . startswith ( [string] ) [EOL] [EOL] table_id_comment = table_node [ [string] ] [ [string] ] [ [string] ] [EOL] assert table_id_comment . startswith ( [string] ) [EOL] [EOL] table_name_comment = table_node [ [string] ] [ [string] ] [ [string] ] [EOL] assert table_name_comment . startswith ( [string] ) [EOL] [EOL] [EOL] [EOL] class TestPersistDocsLateBinding ( BasePersistDocsTest ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : { [string] : True , [string] : True , } , [string] : { [string] : False , } } } } [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_late_binding_view ( self ) : [EOL] self . run_dbt ( ) [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] with open ( [string] ) as fp : [EOL] catalog_data = json . load ( fp ) [EOL] assert [string] in catalog_data [EOL] assert len ( catalog_data [ [string] ] ) == [number] [EOL] table_node = catalog_data [ [string] ] [ [string] ] [EOL] view_node = self . _assert_has_table_comments ( table_node ) [EOL] [EOL] view_node = catalog_data [ [string] ] [ [string] ] [EOL] self . _assert_has_view_comments ( view_node , False , False ) [EOL] [EOL] no_docs_node = catalog_data [ [string] ] [ [string] ] [EOL] self . _assert_has_view_comments ( no_docs_node , False , False ) [EOL] [EOL] [EOL] class TestPersistDocsSimple ( BasePersistDocsTest ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : { [string] : True , [string] : True , } , } } , [string] : { [string] : { [string] : { [string] : True , [string] : True , } , } } , } [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_persist_docs ( self ) : [EOL] self . run_dbt ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_persist_docs ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( ) [EOL] desc_map = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] for node_id in [ [string] , [string] , [string] ] : [EOL] with self . adapter . connection_named ( [string] ) : [EOL] client = self . adapter . connections . get_thread_connection ( ) . handle [EOL] [EOL] table_id = [string] . format ( self . default_database , self . unique_schema ( ) , node_id ) [EOL] bq_table = client . get_table ( table_id ) [EOL] [EOL] bq_schema = bq_table . schema [EOL] [EOL] assert bq_table . description . startswith ( desc_map [ node_id ] ) [EOL] assert bq_schema [ [number] ] . description . startswith ( [string] ) [EOL] if not node_id . startswith ( [string] ) : [EOL] assert bq_schema [ [number] ] . description . startswith ( [string] ) [EOL] [EOL] [EOL] class TestPersistDocsNested ( BasePersistDocsTest ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : { [string] : True , [string] : True , } , } } } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_persist_docs ( self ) : [EOL] [docstring] [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( ) [EOL] [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] with open ( [string] ) as fp : [EOL] catalog_data = json . load ( fp ) [EOL] assert [string] in catalog_data [EOL] assert len ( catalog_data [ [string] ] ) == [number] [comment] [EOL] [EOL] for node_id in [ [string] , [string] ] : [EOL] [comment] [EOL] with self . adapter . connection_named ( [string] ) : [EOL] client = self . adapter . connections . get_thread_connection ( ) . handle [EOL] [EOL] table_id = [string] . format ( self . default_database , self . unique_schema ( ) , node_id ) [EOL] bq_schema = client . get_table ( table_id ) . schema [EOL] [EOL] level_1_field = bq_schema [ [number] ] [EOL] assert level_1_field . description == [string] [EOL] [EOL] level_2_field = level_1_field . fields [ [number] ] [EOL] assert level_2_field . description == [string] [EOL] [EOL] level_3_field = level_2_field . fields [ [number] ] [EOL] assert level_3_field . description == [string] [EOL] [EOL] [comment] [EOL] node = catalog_data [ [string] ] [ [string] . format ( node_id ) ] [EOL] [EOL] level_1_column = node [ [string] ] [ [string] ] [EOL] assert level_1_column [ [string] ] == [string] [EOL] [EOL] level_2_column = node [ [string] ] [ [string] ] [EOL] assert level_2_column [ [string] ] == [string] [EOL] [EOL] level_3_column = node [ [string] ] [ [string] ] [EOL] assert level_3_column [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestConcurrency ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__concurrency ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results , output = self . run_dbt_and_capture ( expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] self . assertIn ( [string] , output ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__concurrency ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import dbt . exceptions [EOL] [EOL] [EOL] class BaseSimpleSnapshotTest ( DBTIntegrationTest ) : [EOL] NUM_SNAPSHOT_MODELS = [number] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_snapshot ( self ) : [EOL] return self . run_dbt ( [ [string] ] ) [EOL] [EOL] def dbt_run_seed_snapshot ( self ) : [EOL] if self . adapter_type == [string] : [EOL] self . run_sql_file ( [string] ) [EOL] else : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_snapshot ( ) [EOL] self . assertEqual ( len ( results ) , self . NUM_SNAPSHOT_MODELS ) [EOL] [EOL] def assert_case_tables_equal ( self , actual , expected ) : [EOL] if self . adapter_type == [string] : [EOL] actual = actual . upper ( ) [EOL] expected = expected . upper ( ) [EOL] [EOL] self . assertTablesEqual ( actual , expected ) [EOL] [EOL] def assert_expected ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assert_case_tables_equal ( [string] , [string] ) [EOL] [EOL] [EOL] class TestSimpleSnapshotFiles ( BaseSimpleSnapshotTest ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_ref_snapshot ( self ) : [EOL] self . dbt_run_seed_snapshot ( ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__simple_snapshot ( self ) : [EOL] self . dbt_run_seed_snapshot ( ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_snapshot ( ) [EOL] self . assertEqual ( len ( results ) , self . NUM_SNAPSHOT_MODELS ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__simple_snapshot ( self ) : [EOL] self . dbt_run_seed_snapshot ( ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_snapshot ( ) [EOL] self . assertEqual ( len ( results ) , self . NUM_SNAPSHOT_MODELS ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__redshift__simple_snapshot ( self ) : [EOL] self . dbt_run_seed_snapshot ( ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_snapshot ( ) [EOL] self . assertEqual ( len ( results ) , self . NUM_SNAPSHOT_MODELS ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] [EOL] class TestSimpleColumnSnapshotFiles ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , [string] : { [string] : False , } } [EOL] [EOL] def _run_snapshot_test ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] database = self . default_database [EOL] if self . adapter_type == [string] : [EOL] database = self . adapter . quote ( database ) [EOL] results = self . run_sql ( [string] . format ( database , self . unique_schema ( ) ) , fetch = [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] for result in results : [EOL] self . assertEqual ( len ( result ) , [number] ) [EOL] [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] results = self . run_sql ( [string] . format ( database , self . unique_schema ( ) ) , fetch = [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] for result in results : [EOL] [comment] [EOL] self . assertEqual ( len ( result ) , [number] ) [EOL] self . assertIsNotNone ( result [ - [number] ] ) [EOL] [EOL] results = self . run_sql ( [string] . format ( database , self . unique_schema ( ) ) , fetch = [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] for result in results : [EOL] [comment] [EOL] self . assertEqual ( len ( result ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_renamed_source ( self ) : [EOL] self . _run_snapshot_test ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_renamed_source ( self ) : [EOL] self . _run_snapshot_test ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_renamed_source ( self ) : [EOL] self . _run_snapshot_test ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_renamed_source ( self ) : [EOL] self . _run_snapshot_test ( ) [EOL] [EOL] [EOL] class TestCustomSnapshotFiles ( BaseSimpleSnapshotTest ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_ref_snapshot ( self ) : [EOL] self . dbt_run_seed_snapshot ( ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__simple_custom_snapshot ( self ) : [EOL] self . dbt_run_seed_snapshot ( ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_snapshot ( ) [EOL] self . assertEqual ( len ( results ) , self . NUM_SNAPSHOT_MODELS ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] [EOL] class TestNamespacedCustomSnapshotFiles ( BaseSimpleSnapshotTest ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__simple_custom_snapshot_namespaced ( self ) : [EOL] self . dbt_run_seed_snapshot ( ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_snapshot ( ) [EOL] self . assertEqual ( len ( results ) , self . NUM_SNAPSHOT_MODELS ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] [EOL] class TestInvalidNamespacedCustomSnapshotFiles ( BaseSimpleSnapshotTest ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , } [EOL] [EOL] def run_snapshot ( self ) : [EOL] return self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__simple_custom_snapshot_invalid_namespace ( self ) : [EOL] self . dbt_run_seed_snapshot ( ) [EOL] [EOL] [EOL] class TestSimpleSnapshotFileSelects ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_snapshots ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_exclude_snapshots ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_select_snapshots ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] [EOL] class TestConfiguredSnapshotFileSelects ( TestSimpleSnapshotFileSelects ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : { [string] : self . unique_schema ( ) , [string] : [string] , [string] : [string] , [string] : [string] , } , } , [string] : [ [string] ] , } [EOL] [EOL] [EOL] class TestSimpleSnapshotFilesBigquery ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] def assert_expected ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery__simple_snapshot ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assert_expected ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery__snapshot_with_new_field ( self ) : [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] [comment] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] expected_cols = self . get_table_columns ( database = self . default_database , schema = self . unique_schema ( ) , table = [string] ) [EOL] snapshotted_cols = self . get_table_columns ( database = self . default_database , schema = self . unique_schema ( ) , table = [string] ) [EOL] [EOL] self . assertTrue ( len ( expected_cols ) > [number] , [string] ) [EOL] self . assertEqual ( len ( expected_cols ) , len ( snapshotted_cols ) , [string] ) [EOL] [EOL] for ( expected_col , actual_col ) in zip ( expected_cols , snapshotted_cols ) : [EOL] expected_name , expected_type , _ = expected_col [EOL] actual_name , actual_type , _ = actual_col [EOL] self . assertTrue ( expected_name is not None ) [EOL] self . assertTrue ( expected_type is not None ) [EOL] [EOL] self . assertEqual ( expected_name , actual_name , [string] ) [EOL] self . assertEqual ( expected_type , actual_type , [string] ) [EOL] [EOL] [EOL] class TestCrossDBSnapshotFiles ( DBTIntegrationTest ) : [EOL] setup_alternate_db = True [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] if self . adapter_type == [string] : [EOL] paths = [ [string] ] [EOL] else : [EOL] paths = [ [string] ] [EOL] return { [string] : [number] , [string] : paths , [string] : [ [string] ] , } [EOL] [EOL] def run_snapshot ( self ) : [EOL] return self . run_dbt ( [ [string] , [string] , [string] . format ( self . alternative_database ) ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__cross_snapshot ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_snapshot ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] , table_b_db = self . alternative_database ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_snapshot ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] , table_b_db = self . alternative_database ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery__cross_snapshot ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . run_snapshot ( ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] , table_b_db = self . alternative_database ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . run_snapshot ( ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] , table_b_db = self . alternative_database ) [EOL] [EOL] [EOL] class TestCrossSchemaSnapshotFiles ( DBTIntegrationTest ) : [EOL] NUM_SNAPSHOT_MODELS = [number] [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . target_schema ( ) ) , ) [EOL] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] paths = [ [string] ] [EOL] return { [string] : [number] , [string] : paths , [string] : [ [string] ] , } [EOL] [EOL] def target_schema ( self ) : [EOL] return [string] . format ( self . unique_schema ( ) ) [EOL] [EOL] def run_snapshot ( self ) : [EOL] return self . run_dbt ( [ [string] , [string] , [string] . format ( self . target_schema ( ) ) ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__cross_schema_snapshot ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_snapshot ( ) [EOL] self . assertEqual ( len ( results ) , self . NUM_SNAPSHOT_MODELS ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] . format ( self . target_schema ( ) ) ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestBadSnapshot ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__invalid ( self ) : [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] [EOL] class TestCheckCols ( TestSimpleSnapshotFiles ) : [EOL] NUM_SNAPSHOT_MODELS = [number] [EOL] [EOL] def _assertTablesEqualSql ( self , relation_a , relation_b , columns = None ) : [EOL] [comment] [EOL] [comment] [EOL] if columns is None : [EOL] columns = [ c for c in self . get_relation_columns ( relation_a ) if not c [ [number] ] . lower ( ) . startswith ( [string] ) ] [EOL] return super ( ) . _assertTablesEqualSql ( relation_a , relation_b , columns = columns ) [EOL] [EOL] def assert_expected ( self ) : [EOL] super ( ) . assert_expected ( ) [EOL] self . assert_case_tables_equal ( [string] , [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] class TestConfiguredCheckCols ( TestCheckCols ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : { [string] : self . unique_schema ( ) , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } , } , [string] : [ [string] ] , } [EOL] [EOL] [EOL] class TestCheckColsBigquery ( TestSimpleSnapshotFilesBigquery ) : [EOL] def _assertTablesEqualSql ( self , relation_a , relation_b , columns = None ) : [EOL] [comment] [EOL] [comment] [EOL] if columns is None : [EOL] columns = [ c for c in self . get_relation_columns ( relation_a ) if not c [ [number] ] . lower ( ) . startswith ( [string] ) ] [EOL] return super ( ) . _assertTablesEqualSql ( relation_a , relation_b , columns = columns ) [EOL] [EOL] def assert_expected ( self ) : [EOL] super ( ) . assert_expected ( ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery__snapshot_with_new_field ( self ) : [EOL] self . use_default_project ( ) [EOL] self . use_profile ( [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] [comment] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] expected_cols = self . get_table_columns ( database = self . default_database , schema = self . unique_schema ( ) , table = [string] ) [EOL] snapshotted_cols = self . get_table_columns ( database = self . default_database , schema = self . unique_schema ( ) , table = [string] ) [EOL] snapshotted_all_cols = self . get_table_columns ( database = self . default_database , schema = self . unique_schema ( ) , table = [string] ) [EOL] [EOL] self . assertTrue ( len ( expected_cols ) > [number] , [string] ) [EOL] self . assertEqual ( len ( expected_cols ) , len ( snapshotted_cols ) , [string] ) [EOL] self . assertEqual ( len ( expected_cols ) , len ( snapshotted_all_cols ) ) [EOL] [EOL] for ( expected_col , actual_col ) in zip ( expected_cols , snapshotted_cols ) : [EOL] expected_name , expected_type , _ = expected_col [EOL] actual_name , actual_type , _ = actual_col [EOL] self . assertTrue ( expected_name is not None ) [EOL] self . assertTrue ( expected_type is not None ) [EOL] [EOL] self . assertEqual ( expected_name , actual_name , [string] ) [EOL] self . assertEqual ( expected_type , actual_type , [string] ) [EOL] [EOL] [EOL] class TestLongText ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_snapshot ( self ) : [EOL] return self . run_dbt ( [ [string] ] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__long_text ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] with self . adapter . connection_named ( [string] ) : [EOL] status , results = self . adapter . execute ( [string] . format ( self . default_database , self . unique_schema ( ) ) , fetch = True ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] got_names = set ( r . get ( [string] ) for r in results ) [EOL] self . assertEqual ( got_names , { [string] * [number] , [string] } ) [EOL] [EOL] [EOL] class TestSlowQuery ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_snapshot ( self ) : [EOL] return self . run_dbt ( [ [string] ] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__slow ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestChangingStrategy ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_snapshot ( self ) : [EOL] return self . run_dbt ( [ [string] ] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__changing_strategy ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import dbt . exceptions [EOL] [EOL] [EOL] class TestSimpleSnapshotFiles ( DBTIntegrationTest ) : [EOL] NUM_SNAPSHOT_MODELS = [number] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ ] , } [EOL] [EOL] def test_snapshot_check_cols_cycle ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] def assert_expected ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__simple_snapshot ( self ) : [EOL] self . test_snapshot_check_cols_cycle ( ) [EOL] self . assert_expected ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__simple_snapshot ( self ) : [EOL] self . test_snapshot_check_cols_cycle ( ) [EOL] self . assert_expected ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery__simple_snapshot ( self ) : [EOL] self . test_snapshot_check_cols_cycle ( ) [EOL] self . assert_expected ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__redshift__simple_snapshot ( self ) : [EOL] self . test_snapshot_check_cols_cycle ( ) [EOL] self . assert_expected ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] [EOL] [EOL] class BaseColumnQuotingTest ( DBTIntegrationTest ) : [EOL] def column_quoting ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( value ) : [EOL] return os . path . normpath ( value ) [EOL] [EOL] def _run_columnn_quotes ( self , strategy = [string] ) : [EOL] strategy_vars = [string] . format ( strategy ) [EOL] self . run_dbt ( [ [string] , [string] , strategy_vars ] ) [EOL] self . run_dbt ( [ [string] , [string] , strategy_vars ] ) [EOL] self . run_dbt ( [ [string] , [string] , strategy_vars ] ) [EOL] [EOL] [EOL] class TestColumnQuotingDefault ( BaseColumnQuotingTest ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] } [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] def run_dbt ( self , * args , ** kwargs ) : [EOL] return super ( ) . run_dbt ( * args , strict = False , ** kwargs ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( strategy = [string] ) [EOL] [EOL] [EOL] class TestColumnQuotingDisabled ( BaseColumnQuotingTest ) : [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_column_quotes_merged ( self ) : [EOL] self . _run_columnn_quotes ( strategy = [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_column_quotes_merged ( self ) : [EOL] self . _run_columnn_quotes ( strategy = [string] ) [EOL] [EOL] [EOL] class TestColumnQuotingEnabled ( BaseColumnQuotingTest ) : [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : True , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_column_quotes ( self ) : [EOL] self . _run_columnn_quotes ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_column_quotes_merged ( self ) : [EOL] self . _run_columnn_quotes ( strategy = [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_column_quotes_merged ( self ) : [EOL] self . _run_columnn_quotes ( strategy = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import threading [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import threading [EOL] from dbt . adapters . factory import FACTORY [EOL] [EOL] [EOL] def get_adapter_standalone ( config ) : [EOL] plugin = FACTORY . plugins [ config . credentials . type ] [EOL] cls = plugin . adapter [EOL] return cls ( config ) [EOL] [EOL] [EOL] class BaseTestConcurrentTransaction ( DBTIntegrationTest ) : [EOL] [EOL] def reset ( self ) : [EOL] self . query_state = { [string] : [string] , [string] : [string] , } [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . _secret_adapter = get_adapter_standalone ( self . config ) [EOL] self . reset ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . _secret_adapter . cleanup_connections ( ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] , ] , } [EOL] [EOL] def run_select_and_check ( self , rel , sql ) : [EOL] connection_name = [string] . format ( id ( threading . current_thread ( ) ) ) [EOL] try : [EOL] with self . _secret_adapter . connection_named ( connection_name ) : [EOL] conn = self . _secret_adapter . connections . get_thread_connection ( ) [EOL] res = self . run_sql_common ( self . transform_sql ( sql ) , [string] , conn ) [EOL] [EOL] [comment] [EOL] if res [ [number] ] : [EOL] self . query_state [ rel ] = [string] [EOL] else : [EOL] self . query_state [ rel ] = [string] [EOL] [EOL] except Exception as e : [EOL] if [string] in str ( e ) : [EOL] self . query_state [ rel ] = [string] . format ( e ) [EOL] else : [EOL] self . query_state [ rel ] = [string] . format ( e ) [EOL] [EOL] def async_select ( self , rel , sleep = [number] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] schema = self . unique_schema ( ) [EOL] query = [string] . format ( schema = schema , sleep = sleep , rel = rel ) [EOL] [EOL] thread = threading . Thread ( target = self . run_select_and_check , args = ( rel , query ) ) [EOL] thread . start ( ) [EOL] return thread [EOL] [EOL] def run_test ( self ) : [EOL] self . use_profile ( [string] ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( args = [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] t1 = self . async_select ( [string] , [number] ) [EOL] t2 = self . async_select ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] res = self . run_dbt ( args = [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( res ) , [number] ) [EOL] [EOL] [comment] [EOL] t1 . join ( ) [EOL] t2 . join ( ) [EOL] [EOL] self . assertTrue ( len ( res ) > [number] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( self . query_state [ [string] ] , [string] ) [EOL] self . assertEqual ( self . query_state [ [string] ] , [string] ) [EOL] [EOL] [EOL] class TableTestConcurrentTransaction ( BaseTestConcurrentTransaction ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test__redshift__concurrent_transaction_table ( self ) : [EOL] self . reset ( ) [EOL] self . run_test ( ) [EOL] [EOL] [EOL] class ViewTestConcurrentTransaction ( BaseTestConcurrentTransaction ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test__redshift__concurrent_transaction_view ( self ) : [EOL] self . reset ( ) [EOL] self . run_test ( ) [EOL] [EOL] [EOL] class IncrementalTestConcurrentTransaction ( BaseTestConcurrentTransaction ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test__redshift__concurrent_transaction_incremental ( self ) : [EOL] self . reset ( ) [EOL] self . run_test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] from dbt . adapters . factory import FACTORY [EOL] [EOL] class TestBaseCaching ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : False , [string] : False , } } [EOL] [EOL] def run_and_get_adapter ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] ) [EOL] return FACTORY . adapters [ self . adapter_type ] [EOL] [EOL] def cache_run ( self ) : [EOL] adapter = self . run_and_get_adapter ( ) [EOL] self . assertEqual ( len ( adapter . cache . relations ) , [number] ) [EOL] relation = next ( iter ( adapter . cache . relations . values ( ) ) ) [EOL] self . assertEqual ( relation . inner . schema , self . unique_schema ( ) ) [EOL] self . assertEqual ( relation . schema , self . unique_schema ( ) . lower ( ) ) [EOL] [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( adapter . cache . relations ) , [number] ) [EOL] second_relation = next ( iter ( adapter . cache . relations . values ( ) ) ) [EOL] self . assertEqual ( relation , second_relation ) [EOL] [EOL] class TestCachingLowercaseModel ( TestBaseCaching ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_cache ( self ) : [EOL] self . cache_run ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_cache ( self ) : [EOL] self . cache_run ( ) [EOL] [EOL] class TestCachingUppercaseModel ( TestBaseCaching ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_cache ( self ) : [EOL] self . cache_run ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_cache ( self ) : [EOL] self . cache_run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import os [EOL] [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestSimpleSeed ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : False , } } [EOL] [EOL] def use_full_refresh_project ( self , full_refresh ) : [EOL] overrides = { [string] : { [string] : False , [string] : full_refresh , } } [EOL] self . use_default_project ( overrides ) [EOL] [EOL] def _seed_and_run ( self ) : [EOL] assert len ( self . run_dbt ( [ [string] ] ) ) == [number] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] assert len ( self . run_dbt ( [ [string] ] ) ) == [number] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] def _after_seed_model_state ( self , cmd , exists ) : [EOL] assert len ( self . run_dbt ( cmd ) ) == [number] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] if exists : [EOL] self . assertTableDoesExist ( [string] ) [EOL] else : [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed ( self ) : [EOL] self . _seed_and_run ( ) [EOL] [EOL] [comment] [EOL] self . _after_seed_model_state ( [ [string] ] , exists = True ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed_full_refresh_flag ( self ) : [EOL] self . _seed_and_run ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _after_seed_model_state ( [ [string] , [string] ] , exists = False ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed_full_refresh_config ( self ) : [EOL] self . _seed_and_run ( ) [EOL] [EOL] [comment] [EOL] self . use_full_refresh_project ( False ) [EOL] [EOL] self . _after_seed_model_state ( [ [string] ] , exists = True ) [EOL] [comment] [EOL] [comment] [EOL] self . _after_seed_model_state ( [ [string] , [string] ] , exists = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . use_full_refresh_project ( True ) [EOL] self . _after_seed_model_state ( [ [string] ] , exists = False ) [EOL] [EOL] [EOL] class TestSimpleSeedCustomSchema ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . run_sql_file ( [string] ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . custom_schema_name ( ) ) ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : [string] , [string] : False , } , } [EOL] [EOL] def custom_schema_name ( self ) : [EOL] return [string] . format ( self . unique_schema ( ) , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed_with_schema ( self ) : [EOL] schema_name = self . custom_schema_name ( ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] , table_a_schema = schema_name ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] , table_a_schema = schema_name ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed_with_drop_and_schema ( self ) : [EOL] schema_name = [string] . format ( self . unique_schema ( ) , [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] , table_a_schema = schema_name ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] , table_a_schema = schema_name ) [EOL] [EOL] [EOL] class TestSimpleSeedDisabled ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : { [string] : True } , [string] : { [string] : False } } , [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed_with_disabled ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTableDoesExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed_selection ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTableDoesExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed_exclude ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesExist ( [string] ) [EOL] [EOL] [EOL] class TestSeedParsing ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_dbt_run_skips_seeds ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] ] ) ) , [number] ) [EOL] [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL] [EOL] [EOL] class TestSimpleSeedWithBOM ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed ( self ) : [EOL] [comment] [EOL] seed_path = os . path . join ( self . config . data_paths [ [number] ] , [string] ) [EOL] [comment] [EOL] with open ( seed_path , encoding = [string] ) as fp : [EOL] self . assertEqual ( fp . read ( [number] ) , [string] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [EOL] class TestSimpleSeedWithUnicode ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : False , } } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestSimpleSeedColumnOverride ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : { [string] : False , [string] : True , [string] : { [string] : True , [string] : self . seed_enabled_types ( ) } , [string] : { [string] : True , [string] : self . seed_tricky_types ( ) , } , } , } , } [EOL] [EOL] [EOL] class TestSimpleSeedColumnOverridePostgres ( TestSimpleSeedColumnOverride ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . postgres_profile ( ) [EOL] [EOL] def seed_enabled_types ( self ) : [EOL] return { [string] : [string] , [string] : [string] , } [EOL] [EOL] def seed_tricky_types ( self ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_seed_with_column_override_postgres ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestSimpleSeedColumnOverrideRedshift ( TestSimpleSeedColumnOverride ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . redshift_profile ( ) [EOL] [EOL] def seed_enabled_types ( self ) : [EOL] return { [string] : [string] , [string] : [string] , } [EOL] [EOL] def seed_tricky_types ( self ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_simple_seed_with_column_override_redshift ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestSimpleSeedColumnOverrideSnowflake ( TestSimpleSeedColumnOverride ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def seed_enabled_types ( self ) : [EOL] return { [string] : [string] , [string] : [string] , } [EOL] [EOL] def seed_tricky_types ( self ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . snowflake_profile ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_simple_seed_with_column_override_snowflake ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestSimpleSeedColumnOverrideBQ ( TestSimpleSeedColumnOverride ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def seed_enabled_types ( self ) : [EOL] return { [string] : [string] , [string] : [string] , } [EOL] [EOL] def seed_tricky_types ( self ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . bigquery_profile ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_simple_seed_with_column_override_bigquery ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[docstring] [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import textwrap [EOL] import yaml [EOL] [EOL] [EOL] class TestBigqueryAdapterSpecific ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . bigquery_profile ( ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return yaml . safe_load ( textwrap . dedent ( [string] ) ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_hours_to_expiration ( self ) : [EOL] _ , stdout = self . run_dbt_and_capture ( [ [string] , [string] ] ) [EOL] [EOL] self . assertIn ( [string] [string] , stdout ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] [EOL] [EOL] class TestBigqueryErrorHandling ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] self . valid_location = os . getenv ( [string] , [string] ) [EOL] self . invalid_location = os . getenv ( [string] , [string] ) [EOL] self . location = self . valid_location [EOL] super ( ) . setUp ( ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def bigquery_profile ( self ) : [EOL] result = super ( ) . bigquery_profile ( ) [EOL] result [ [string] ] [ [string] ] [ [string] ] [ [string] ] = self . location [EOL] return result [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_location_invalid ( self ) : [EOL] self . run_dbt ( ) [EOL] self . location = self . invalid_location [EOL] self . use_profile ( [string] ) [EOL] _ , stdout = self . run_dbt_and_capture ( expect_pass = False ) [EOL] assert [string] not in stdout [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import json [EOL] [EOL] class TestBaseBigQueryRun ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_fetch_nested_records ( self ) : [EOL] sql = [string] [EOL] [EOL] [EOL] status , res = self . adapter . execute ( sql , fetch = True ) [EOL] [EOL] self . assertEqual ( len ( res ) , [number] , [string] ) [EOL] [EOL] expected = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } [EOL] [EOL] for i , key in enumerate ( expected ) : [EOL] line = [string] . format ( i , key , expected [ key ] [ i ] , res [ i ] [ key ] ) [EOL] [comment] [EOL] v1 = expected [ key ] [ i ] [EOL] v2 = res [ i ] [ key ] [EOL] self . assertEqual ( json . loads ( v1 ) , json . loads ( v2 ) , line ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestBaseBigQueryResults ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_type_inference ( self ) : [EOL] result = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertTrue ( result . success ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Union , Any , Dict , Optional [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , FakeArgs , use_profile [EOL] import json [EOL] [EOL] [EOL] class TestChangingPartitions ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_changes ( self , before , after ) : [EOL] results = self . run_dbt ( [ [string] , [string] , json . dumps ( before ) ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , json . dumps ( after ) ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_add_partition ( self ) : [EOL] before = { [string] : None , [string] : None } [EOL] after = { [string] : { [string] : [string] , [string] : [string] } , [string] : None } [EOL] self . run_changes ( before , after ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_remove_partition ( self ) : [EOL] before = { [string] : { [string] : [string] , [string] : [string] } , [string] : None } [EOL] after = { [string] : None , [string] : None } [EOL] self . run_changes ( before , after ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_change_partitions ( self ) : [EOL] before = { [string] : { [string] : [string] , [string] : [string] } , [string] : None } [EOL] after = { [string] : { [string] : [string] } , [string] : None } [EOL] self . run_changes ( before , after ) [EOL] self . run_changes ( after , before ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_change_partitions_from_int ( self ) : [EOL] before = { [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] } } , [string] : None } [EOL] after = { [string] : { [string] : [string] , [string] : [string] } , [string] : None } [EOL] self . run_changes ( before , after ) [EOL] self . run_changes ( after , before ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_add_clustering ( self ) : [EOL] before = { [string] : { [string] : [string] , [string] : [string] } , [string] : None } [EOL] after = { [string] : { [string] : [string] } , [string] : [string] } [EOL] self . run_changes ( before , after ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_remove_clustering ( self ) : [EOL] before = { [string] : { [string] : [string] , [string] : [string] } , [string] : [string] } [EOL] after = { [string] : { [string] : [string] } , [string] : None } [EOL] self . run_changes ( before , after ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_change_clustering ( self ) : [EOL] before = { [string] : { [string] : [string] , [string] : [string] } , [string] : [string] } [EOL] after = { [string] : { [string] : [string] } , [string] : [string] } [EOL] self . run_changes ( before , after ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_change_clustering_strict ( self ) : [EOL] before = { [string] : { [string] : [string] , [string] : [string] } , [string] : [string] } [EOL] after = { [string] : { [string] : [string] , [string] : [string] } , [string] : [string] } [EOL] self . run_changes ( before , after ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]]]$ 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Optional[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , FakeArgs , use_profile [EOL] import yaml [EOL] [EOL] [EOL] class TestBigqueryAdapterFunctions ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . bigquery_profile ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_adapter_functions ( self ) : [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] test_results = self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assertTrue ( len ( test_results ) > [number] ) [EOL] for result in test_results : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] [comment] [EOL] self . assertEqual ( result . status , [number] ) [EOL] [EOL] [EOL] class TestBigqueryAdapterMacros ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def _create_schema_named ( self , database , schema ) : [EOL] [comment] [EOL] pass [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_run_create_drop_schema ( self ) : [EOL] schema_args = yaml . safe_dump ( { [string] : self . default_database , [string] : self . unique_schema ( ) , } ) [EOL] self . run_dbt ( [ [string] , [string] , [string] , schema_args ] ) [EOL] relation_args = yaml . safe_dump ( { [string] : self . default_database , [string] : self . unique_schema ( ) , [string] : [string] , } ) [EOL] self . run_dbt ( [ [string] , [string] , [string] , relation_args ] ) [EOL] [comment] [EOL] self . run_dbt ( [ [string] , [string] , [string] , schema_args ] ) [EOL] [comment] [EOL] schema_relation = self . adapter . Relation . create ( database = self . default_database , schema = self . unique_schema ( ) ) . without_identifier ( ) [EOL] with self . adapter . connection_named ( [string] ) : [EOL] results = self . adapter . list_relations_without_caching ( schema_relation ) [EOL] assert len ( results ) == [number] [EOL] [EOL] self . run_dbt ( [ [string] , [string] , [string] , schema_args ] ) [EOL] with self . adapter . connection_named ( [string] ) : [EOL] results = self . adapter . list_relations_without_caching ( schema_relation ) [EOL] assert len ( results ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , FakeArgs , use_profile [EOL] [EOL] class TestBigQueryScripting ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . bigquery_profile ( ) [EOL] [EOL] def assert_incrementals ( self ) : [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import random [EOL] import time [EOL] [EOL] [EOL] class TestBaseBigQueryRun ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : False , } , } [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . bigquery_profile ( ) [EOL] [EOL] def assert_nondupes_pass ( self ) : [EOL] [comment] [EOL] test_results = self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL] [EOL] for result in test_results : [EOL] if [string] in result . node . name : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] self . assertTrue ( result . status > [number] ) [EOL] [EOL] [comment] [EOL] else : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] [comment] [EOL] self . assertEqual ( result . status , [number] ) [EOL] [EOL] [EOL] class TestSimpleBigQueryRun ( TestBaseBigQueryRun ) : [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_simple_run ( self ) : [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] results = self . run_dbt ( ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assert_nondupes_pass ( ) [EOL] [EOL] [EOL] class TestUnderscoreBigQueryRun ( TestBaseBigQueryRun ) : [EOL] prefix = [string] . format ( int ( time . time ( ) ) , random . randint ( [number] , [number] ) ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_run_twice ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assert_nondupes_pass ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import textwrap [EOL] import yaml [EOL] [EOL] [EOL] class TestBigqueryDatePartitioning ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . bigquery_profile ( ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return yaml . safe_load ( textwrap . dedent ( [string] ) ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_date_partitioning ( self ) : [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] test_results = self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assertTrue ( len ( test_results ) > [number] ) [EOL] for result in test_results : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] [comment] [EOL] self . assertEqual ( result . status , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestCaseSensitiveModelBigQueryRun ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_double_run_fails ( self ) : [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . run_dbt ( expect_pass = False ) [EOL] [EOL] [EOL] class TestCaseSensitiveSchemaBigQueryRun ( TestCaseSensitiveModelBigQueryRun ) : [EOL] [comment] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] def unique_schema ( self ) : [EOL] schema = self . schema [EOL] [EOL] to_return = [string] . format ( self . prefix , schema ) [EOL] return to_return [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import textwrap [EOL] import yaml [EOL] [EOL] [EOL] class TestBigqueryCopyTableFails ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return self . bigquery_profile ( ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return yaml . safe_load ( textwrap . dedent ( [string] ) ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_copy_table_fails ( self ) : [EOL] results = self . run_dbt ( expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTrue ( results [ [number] ] . error ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestBigqueryUpdateColumnPolicyTag ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : self . policy_tag } } [EOL] [EOL] @ property def policy_tag ( self ) : [EOL] return os . environ . get ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_update_column_policy_tag ( self ) : [EOL] if self . policy_tag : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] with self . get_connection ( ) as conn : [EOL] client = conn . handle [EOL] [EOL] table = client . get_table ( self . adapter . connections . get_bq_table ( self . default_database , self . unique_schema ( ) , [string] ) ) [EOL] [EOL] for schema_field in table . schema : [EOL] self . assertEquals ( schema_field . policy_tags . names , ( self . policy_tag , ) ) [EOL] [EOL] [EOL] class TestBigqueryUpdateColumnDescription ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : self . field_description } } [EOL] [EOL] @ property def field_description ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_update_column_description ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] with self . get_connection ( ) as conn : [EOL] client = conn . handle [EOL] [EOL] table = client . get_table ( self . adapter . connections . get_bq_table ( self . default_database , self . unique_schema ( ) , [string] ) ) [EOL] [EOL] for schema_field in table . schema : [EOL] self . assertEquals ( schema_field . description , self . field_description ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import yaml [EOL] [EOL] [EOL] class TestOperations ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] def run_operation ( self , macro , expect_pass = True , extra_args = None , ** kwargs ) : [EOL] args = [ [string] , macro ] [EOL] if kwargs : [EOL] args . extend ( ( [string] , yaml . safe_dump ( kwargs ) ) ) [EOL] if extra_args : [EOL] args . extend ( extra_args ) [EOL] return self . run_dbt ( args , expect_pass = expect_pass ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_macro_noargs ( self ) : [EOL] self . run_operation ( [string] ) [EOL] self . assertTableDoesExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_macro_args ( self ) : [EOL] self . run_operation ( [string] , table_name = [string] ) [EOL] self . assertTableDoesExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_macro_exception ( self ) : [EOL] self . run_operation ( [string] , False ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_macro_missing ( self ) : [EOL] self . run_operation ( [string] , False ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_cannot_connect ( self ) : [EOL] self . run_operation ( [string] , extra_args = [ [string] , [string] ] , expect_pass = False ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_vacuum ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] self . run_operation ( [string] , table_name = [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_vacuum_ref ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] self . run_operation ( [string] , ref_target = [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_select ( self ) : [EOL] self . run_operation ( [string] , name = [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_access_graph ( self ) : [EOL] self . run_operation ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestCustomSchema ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . v2_schema ( ) ) ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . xf_schema ( ) ) ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def v2_schema ( self ) : [EOL] return f"{ self . unique_schema ( ) } [string] " [EOL] [EOL] def xf_schema ( self ) : [EOL] return f"{ self . unique_schema ( ) } [string] " [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__custom_schema_no_prefix ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] schema = self . unique_schema ( ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . v2_schema ( ) ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . xf_schema ( ) ) [EOL] [EOL] [EOL] class TestCustomProjectSchemaWithPrefix ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . v1_schema ( ) ) ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . v2_schema ( ) ) ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . xf_schema ( ) ) ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) , } } , [string] : [string] } } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : [string] } , } [EOL] [EOL] def v1_schema ( self ) : [EOL] return f"{ self . unique_schema ( ) } [string] " [EOL] [EOL] def v2_schema ( self ) : [EOL] return f"{ self . unique_schema ( ) } [string] " [EOL] [EOL] def xf_schema ( self ) : [EOL] return f"{ self . unique_schema ( ) } [string] " [EOL] [EOL] def _list_schemas ( self ) : [EOL] with self . get_connection ( ) : [EOL] return set ( self . adapter . list_schemas ( self . default_database ) ) [EOL] [EOL] def assert_schemas_created ( self , expected ) : [EOL] assert self . _list_schemas ( ) . intersection ( expected ) == expected [EOL] [EOL] def assert_schemas_not_created ( self , expected ) : [EOL] assert not self . _list_schemas ( ) . intersection ( expected ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__custom_schema_with_prefix ( self ) : [EOL] schema = self . unique_schema ( ) [EOL] new_schemas = { self . v1_schema ( ) , self . v2_schema ( ) , self . xf_schema ( ) } [EOL] [EOL] self . assert_schemas_not_created ( new_schemas ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assert_schemas_not_created ( new_schemas ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assert_schemas_not_created ( new_schemas ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assert_schemas_created ( new_schemas ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . v1_schema ( ) ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . v2_schema ( ) ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . xf_schema ( ) ) [EOL] [EOL] [EOL] class TestCustomProjectSchemaWithPrefixSnowflake ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . v1_schema ( ) ) ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . v2_schema ( ) ) ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . xf_schema ( ) ) ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : [string] } } [EOL] [EOL] def v1_schema ( self ) : [EOL] return f"{ self . unique_schema ( ) } [string] " [EOL] [EOL] def v2_schema ( self ) : [EOL] return f"{ self . unique_schema ( ) } [string] " [EOL] [EOL] def xf_schema ( self ) : [EOL] return f"{ self . unique_schema ( ) } [string] " [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__custom_schema_with_prefix ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] schema = self . unique_schema ( ) . upper ( ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . v1_schema ( ) ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . v2_schema ( ) ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . xf_schema ( ) ) [EOL] [EOL] [EOL] class TestCustomSchemaWithCustomMacro ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . v1_schema ( ) ) ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . v2_schema ( ) ) ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . xf_schema ( ) ) ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) , } } , [string] : [string] } } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : [string] , } } [EOL] [EOL] def v1_schema ( self ) : [EOL] return f" [string] { self . unique_schema ( ) } [string] " [EOL] [EOL] def v2_schema ( self ) : [EOL] return f" [string] { self . unique_schema ( ) } [string] " [EOL] [EOL] def xf_schema ( self ) : [EOL] return f" [string] { self . unique_schema ( ) } [string] " [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__custom_schema_from_macro ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] schema = self . unique_schema ( ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . v1_schema ( ) ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . v2_schema ( ) ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , self . xf_schema ( ) ) [EOL] [EOL] [EOL] class TestCustomSchemaWithCustomMacroConfigs ( TestCustomSchemaWithCustomMacro ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : [string] } , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__custom_schema_from_macro ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] schema = self . unique_schema ( ) [EOL] v1_schema = [string] . format ( schema ) [EOL] v2_schema = [string] . format ( schema ) [EOL] xf_schema = [string] . format ( schema ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] , schema , v1_schema ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , v2_schema ) [EOL] self . assertTablesEqual ( [string] , [string] , schema , xf_schema ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestOverrideDatabase ( DBTIntegrationTest ) : [EOL] setup_alternate_db = True [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_override_generate_db_name ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] self . assertTableDoesExist ( [string] , schema = self . unique_schema ( ) , database = self . default_database ) [EOL] self . assertTableDoesExist ( [string] , schema = self . unique_schema ( ) , database = self . default_database ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTableDoesExist ( [string] , schema = self . unique_schema ( ) , database = self . default_database ) [EOL] self . assertTableDoesExist ( [string] , schema = self . unique_schema ( ) , database = self . alternative_database ) [EOL] self . assertTableDoesExist ( [string] , schema = self . unique_schema ( ) , database = self . alternative_database ) [EOL] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] , table_b_db = self . default_database ) [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] , table_b_db = self . alternative_database ) [EOL] self . assertTablesEqual ( [string] , [string] , table_b_db = self . alternative_database ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] [EOL] [EOL] class BaseTestCustomMaterialization ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( value ) : [EOL] return os . path . normpath ( value ) [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class TestOverrideAdapterDependency ( BaseTestCustomMaterialization ) : [EOL] [comment] [EOL] [comment] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_adapter_dependency ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL] [EOL] [EOL] class TestOverrideDefaultDependency ( BaseTestCustomMaterialization ) : [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_default_dependency ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL] [EOL] [EOL] class TestOverrideAdapterDependencyPassing ( BaseTestCustomMaterialization ) : [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_default_dependency ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] [EOL] class TestOverrideAdapterLocal ( BaseTestCustomMaterialization ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } ] } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_default_dependency ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import test [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , FakeArgs , use_profile [EOL] import os [EOL] [EOL] from dbt . task . test import TestTask [EOL] from dbt . exceptions import CompilationException [EOL] [EOL] [EOL] class TestSchemaTests ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_schema_validations ( self ) : [EOL] args = FakeArgs ( ) [EOL] [EOL] test_task = TestTask ( args , self . config ) [EOL] return test_task . run ( ) [EOL] [EOL] def assertTestFailed ( self , result ) : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] self . assertTrue ( result . status > [number] , [string] . format ( result . node . name ) ) [EOL] [EOL] def assertTestPassed ( self , result ) : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] [comment] [EOL] self . assertEqual ( result . status , [number] , [string] . format ( result . node . name ) ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_schema_tests ( self ) : [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] test_results = self . run_schema_validations ( ) [EOL] [comment] [EOL] self . assertEqual ( len ( test_results ) , [number] ) [EOL] [EOL] for result in test_results : [EOL] [comment] [EOL] if [string] in result . node . name : [EOL] self . assertTestFailed ( result ) [EOL] [comment] [EOL] else : [EOL] self . assertTestPassed ( result ) [EOL] [EOL] self . assertEqual ( sum ( x . status for x in test_results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_schema_test_selection ( self ) : [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] test_results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( test_results ) , [number] ) [comment] [EOL] for result in test_results : [EOL] self . assertTestPassed ( result ) [EOL] [EOL] test_results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( test_results ) , [number] ) [EOL] self . assertTestPassed ( test_results [ [number] ] ) [EOL] [EOL] test_results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( test_results ) , [number] ) [EOL] self . assertTestPassed ( test_results [ [number] ] ) [EOL] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_schema_test_exclude_failures ( self ) : [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] test_results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( test_results ) , [number] ) [EOL] for result in test_results : [EOL] self . assertTestPassed ( result ) [EOL] test_results = self . run_dbt ( [ [string] , [string] , [string] ] , expect_pass = False ) [EOL] self . assertEqual ( len ( test_results ) , [number] ) [EOL] for result in test_results : [EOL] self . assertTestFailed ( result ) [EOL] [EOL] [EOL] class TestMalformedSchemaTests ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_schema_validations ( self ) : [EOL] args = FakeArgs ( ) [EOL] [EOL] test_task = TestTask ( args , self . config ) [EOL] return test_task . run ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_malformed_schema_strict_will_break_run ( self ) : [EOL] with self . assertRaises ( CompilationException ) : [EOL] self . run_dbt ( strict = True ) [EOL] [comment] [EOL] with self . assertRaises ( CompilationException ) : [EOL] self . run_dbt ( strict = False ) [EOL] [EOL] [EOL] class TestMalformedMacroTests ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] def run_schema_validations ( self ) : [EOL] args = FakeArgs ( ) [EOL] test_task = TestTask ( args , self . config ) [EOL] return test_task . run ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_malformed_macro_reports_error ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( strict = True ) [EOL] expected_failure = [string] [EOL] [EOL] test_results = self . run_schema_validations ( ) [EOL] [EOL] self . assertEqual ( len ( test_results ) , [number] ) [EOL] [EOL] for result in test_results : [EOL] self . assertTrue ( result . error is not None or result . fail ) [EOL] [comment] [EOL] if result . error is not None : [EOL] self . assertIn ( [string] , result . error ) [EOL] [comment] [EOL] elif result . fail : [EOL] self . assertIn ( expected_failure , result . node . name ) [EOL] [EOL] [EOL] class TestHooksInTests ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] [comment] [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_hooks_dont_run_for_tests ( self ) : [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] for result in results : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] [comment] [EOL] self . assertEqual ( result . status , [number] , [string] . format ( result . node . name ) ) [EOL] [EOL] [EOL] class TestCustomSchemaTests ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , } , { [string] : [string] , [string] : [string] , } , ] } [EOL] [EOL] @ property def project_config ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_schema_validations ( self ) : [EOL] args = FakeArgs ( ) [EOL] [EOL] test_task = TestTask ( args , self . config ) [EOL] return test_task . run ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_schema_tests ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] test_results = self . run_schema_validations ( ) [EOL] self . assertEqual ( len ( test_results ) , [number] ) [EOL] [EOL] expected_failures = [ [string] , [string] ] [EOL] [EOL] for result in test_results : [EOL] if result . error is not None : [EOL] self . assertTrue ( result . node [ [string] ] in expected_failures ) [EOL] self . assertEqual ( sum ( x . status for x in test_results ) , [number] ) [EOL] [EOL] [EOL] class TestBQSchemaTests ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return os . path . normpath ( os . path . join ( [string] , path ) ) [EOL] [EOL] def run_schema_validations ( self ) : [EOL] args = FakeArgs ( ) [EOL] [EOL] test_task = TestTask ( args , self . config ) [EOL] return test_task . run ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_schema_tests_bigquery ( self ) : [EOL] self . use_default_project ( { [string] : [ self . dir ( [string] ) ] } ) [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] ] ) ) , [number] ) [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] test_results = self . run_schema_validations ( ) [EOL] self . assertEqual ( len ( test_results ) , [number] ) [EOL] [EOL] for result in test_results : [EOL] [comment] [EOL] if [string] in result . node . name : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] self . assertTrue ( result . status > [number] , [string] . format ( result . node . name ) ) [EOL] [EOL] [comment] [EOL] else : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] [comment] [EOL] self . assertEqual ( result . status , [number] , [string] . format ( result . node . name ) ) [EOL] [EOL] self . assertEqual ( sum ( x . status for x in test_results ) , [number] ) [EOL] [EOL] [EOL] class TestQuotedSchemaTestColumns ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_quote_required_column ( self ) : [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestVarsSchemaTests ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_argument_rendering ( self ) : [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL] [EOL] [EOL] class TestSchemaCaseInsensitive ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_schema_lowercase_sql ( self ) : [EOL] results = self . run_dbt ( strict = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] , strict = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_schema_uppercase_sql ( self ) : [EOL] results = self . run_dbt ( strict = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] , strict = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestSchemaYAMLExtension ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_yaml_extension ( self ) : [EOL] with self . assertRaises ( Exception ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 $typing.Any$ 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] import os [EOL] from datetime import datetime , timedelta [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] from dbt . exceptions import CompilationException [EOL] [EOL] [EOL] class TestSourceOverrides ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . _id = [number] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } , ] , } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : False , [string] : { [string] : True , } } , [string] : False , } , [string] : { [string] : { [string] : { [string] : False , } } } } [EOL] [EOL] def _set_updated_at_to ( self , delta ) : [EOL] insert_time = datetime . utcnow ( ) + delta [EOL] timestr = insert_time . strftime ( [string] ) [EOL] [comment] [EOL] insert_id = self . _id [EOL] self . _id += [number] [EOL] raw_sql = [string] [EOL] quoted_columns = [string] . join ( self . adapter . quote ( c ) if self . adapter_type != [string] else c for c in ( [string] , [string] , [string] , [string] , [string] , [string] ) ) [EOL] self . run_sql ( raw_sql , kwargs = { [string] : self . unique_schema ( ) , [string] : timestr , [string] : insert_id , [string] : self . adapter . quote ( [string] ) , [string] : quoted_columns , } ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_source_overrides ( self ) : [EOL] [comment] [EOL] _ , stdout = self . run_dbt_and_capture ( [ [string] ] , strict = False ) [EOL] self . assertRegex ( stdout , [string] ) [EOL] schema_path = os . path . join ( [string] , [string] ) [EOL] self . assertIn ( f' [string] { schema_path } [string] ' , stdout ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] seed_results = self . run_dbt ( [ [string] ] ) [EOL] assert len ( seed_results ) == [number] [EOL] [EOL] [comment] [EOL] test_results = self . run_dbt ( [ [string] ] ) [EOL] assert len ( test_results ) == [number] [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] assert len ( results ) == [number] [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] self . _set_updated_at_to ( timedelta ( days = - [number] ) ) [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] ] , expect_pass = False ) [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [comment] [EOL] [comment] [EOL] self . _set_updated_at_to ( timedelta ( days = - [number] ) ) [EOL] results = self . run_dbt ( [ [string] , [string] ] , expect_pass = False , ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . _set_updated_at_to ( timedelta ( hours = - [number] ) ) [EOL] results = self . run_dbt ( [ [string] , [string] ] , expect_pass = True ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . use_default_project ( { [string] : { [string] : { [string] : { [string] : True , } } } } ) [EOL] [comment] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] ] , expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestSourceDuplicateOverrides ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . _id = [number] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } , ] , } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : False , [string] : { [string] : True , } } , [string] : False , } , [string] : { [string] : { [string] : { [string] : False , } } } } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_source_duplicate_overrides ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] with self . assertRaises ( CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] schema1_path = os . path . join ( [string] , [string] ) [EOL] schema2_path = os . path . join ( [string] , [string] ) [EOL] self . assertIn ( schema1_path , str ( exc . exception ) ) [EOL] self . assertIn ( schema2_path , str ( exc . exception ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] [EOL] import json [EOL] [EOL] [EOL] class TestColumnComment ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : [string] , [string] : { [string] : True , [string] : True , } , } } } [EOL] [EOL] def run_has_comments ( self ) : [EOL] self . run_dbt ( ) [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] with open ( [string] ) as fp : [EOL] catalog_data = json . load ( fp ) [EOL] assert [string] in catalog_data [EOL] assert len ( catalog_data [ [string] ] ) == [number] [EOL] column_node = catalog_data [ [string] ] [ [string] ] [EOL] column_comment = column_node [ [string] ] [ [string] ] [ [string] ] [EOL] assert column_comment . startswith ( [string] ) [EOL] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_comments ( self ) : [EOL] self . run_has_comments ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_comments ( self ) : [EOL] self . run_has_comments ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_comments ( self ) : [EOL] self . run_has_comments ( ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] import shutil [EOL] import yaml [EOL] [EOL] [EOL] class TestInit ( DBTIntegrationTest ) : [EOL] def tearDown ( self ) : [EOL] project_name = self . get_project_name ( ) [EOL] [EOL] if os . path . exists ( project_name ) : [EOL] shutil . rmtree ( project_name ) [EOL] [EOL] super ( ) . tearDown ( ) [EOL] [EOL] def get_project_name ( self ) : [EOL] return [string] . format ( self . unique_schema ( ) ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_init_task ( self ) : [EOL] project_name = self . get_project_name ( ) [EOL] self . run_dbt ( [ [string] , project_name , [string] , [string] ] ) [EOL] [EOL] assert os . path . exists ( project_name ) [EOL] project_file = os . path . join ( project_name , [string] ) [EOL] assert os . path . exists ( project_file ) [EOL] with open ( project_file ) as fp : [EOL] project_data = yaml . safe_load ( fp . read ( ) ) [EOL] [EOL] assert [string] in project_data [EOL] assert project_data [ [string] ] == [number] [EOL] [EOL] git_dir = os . path . join ( project_name , [string] ) [EOL] assert not os . path . exists ( git_dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Union , Any , Tuple [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] import random [EOL] import shutil [EOL] import string [EOL] [EOL] import pytest [EOL] [EOL] from dbt . exceptions import CompilationException [EOL] [EOL] [EOL] class TestModifiedState ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : True , } } } [EOL] [EOL] def _symlink_test_folders ( self ) : [EOL] [comment] [EOL] [comment] [EOL] for entry in os . listdir ( self . test_original_source_path ) : [EOL] src = os . path . join ( self . test_original_source_path , entry ) [EOL] tst = os . path . join ( self . test_root_dir , entry ) [EOL] if entry in { [string] , [string] , [string] } : [EOL] shutil . copytree ( src , tst ) [EOL] elif os . path . isdir ( entry ) or entry . endswith ( [string] ) : [EOL] os . symlink ( src , tst ) [EOL] [EOL] def copy_state ( self ) : [EOL] assert not os . path . exists ( [string] ) [EOL] os . makedirs ( [string] ) [EOL] shutil . copyfile ( [string] , [string] ) [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . copy_state ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_changed_seed_contents_state ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , strict = False , expect_pass = False ) [EOL] assert len ( results ) == [number] [EOL] with open ( [string] ) as fp : [EOL] fp . readline ( ) [EOL] newline = fp . newlines [EOL] with open ( [string] , [string] ) as fp : [EOL] fp . write ( f' [string] { newline }' ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] == [string] [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] == [string] [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert set ( results ) == { [string] , [string] , [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] shutil . rmtree ( [string] ) [EOL] self . copy_state ( ) [EOL] [EOL] with open ( [string] , [string] ) as fp : [EOL] [comment] [EOL] target_size = [number] * [number] * [number] [EOL] line_size = [number] [EOL] [EOL] num_lines = target_size // line_size [EOL] [EOL] maxlines = num_lines + [number] [EOL] [EOL] for idx in range ( [number] , maxlines ) : [EOL] value = [string] . join ( random . choices ( string . ascii_letters , k = [number] ) ) [EOL] fp . write ( f'{ idx } [string] { value }{ newline }' ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , strict = False ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] == [string] [EOL] [EOL] with pytest . raises ( CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , strict = True ) [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] shutil . rmtree ( [string] ) [EOL] self . copy_state ( ) [EOL] [EOL] [comment] [EOL] with open ( [string] , [string] ) as fp : [EOL] fp . write ( f'{ random } [string] { newline }' ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , strict = False , expect_pass = False ) [EOL] assert len ( results ) == [number] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_changed_seed_config ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , strict = False , expect_pass = False ) [EOL] assert len ( results ) == [number] [EOL] [EOL] self . use_default_project ( { [string] : { [string] : { [string] : False } } } ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] == [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_unrendered_config_same ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , strict = False , expect_pass = False ) [EOL] assert len ( results ) == [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . use_default_project ( { [string] : { [string] : { [string] : [string] } } } ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] == [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_changed_model_contents ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] , strict = False ) [EOL] assert len ( results ) == [number] [EOL] [EOL] with open ( [string] ) as fp : [EOL] fp . readline ( ) [EOL] newline = fp . newlines [EOL] [EOL] with open ( [string] , [string] ) as fp : [EOL] fp . write ( [string] ) [EOL] fp . write ( newline ) [EOL] fp . write ( [string] ) [EOL] fp . write ( newline ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] . node . name == [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_new_macro ( self ) : [EOL] with open ( [string] ) as fp : [EOL] fp . readline ( ) [EOL] newline = fp . newlines [EOL] [EOL] new_macro = [string] + newline [EOL] [EOL] [comment] [EOL] with open ( [string] , [string] ) as fp : [EOL] fp . write ( new_macro ) [EOL] [EOL] results , stdout = self . run_dbt_and_capture ( [ [string] , [string] , [string] , [string] , [string] ] , strict = False ) [EOL] assert len ( results ) == [number] [EOL] assert [string] in stdout [EOL] [EOL] os . remove ( [string] ) [EOL] [comment] [EOL] with open ( [string] , [string] ) as fp : [EOL] fp . write ( new_macro ) [EOL] [EOL] results , stdout = self . run_dbt_and_capture ( [ [string] , [string] , [string] , [string] , [string] ] , strict = False ) [EOL] assert len ( results ) == [number] [EOL] assert [string] in stdout [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_changed_macro_contents ( self ) : [EOL] with open ( [string] ) as fp : [EOL] fp . readline ( ) [EOL] newline = fp . newlines [EOL] [EOL] [comment] [EOL] with open ( [string] , [string] ) as fp : [EOL] fp . write ( [string] ) [EOL] fp . write ( newline ) [EOL] fp . write ( [string] ) [EOL] fp . write ( newline ) [EOL] fp . write ( [string] ) [EOL] fp . write ( newline ) [EOL] [EOL] results , stdout = self . run_dbt_and_capture ( [ [string] , [string] , [string] , [string] , [string] ] , strict = False ) [EOL] assert len ( results ) == [number] [EOL] assert [string] in stdout [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_changed_report ( self ) : [EOL] with open ( [string] , [string] ) as fp : [EOL] fp . write ( [string] ) [EOL] [EOL] results , stdout = self . run_dbt_and_capture ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert results [ [number] ] . node . name == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import copy [EOL] import json [EOL] import os [EOL] import shutil [EOL] [EOL] import pytest [EOL] [EOL] [EOL] class TestDeferState ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def setUp ( self ) : [EOL] self . other_schema = None [EOL] super ( ) . setUp ( ) [EOL] self . _created_schemas . add ( self . other_schema ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : True , } } } [EOL] [EOL] def get_profile ( self , adapter_type ) : [EOL] if self . other_schema is None : [EOL] self . other_schema = self . unique_schema ( ) + [string] [EOL] if self . adapter_type == [string] : [EOL] self . other_schema = self . other_schema . upper ( ) [EOL] profile = super ( ) . get_profile ( adapter_type ) [EOL] default_name = profile [ [string] ] [ [string] ] [EOL] profile [ [string] ] [ [string] ] [ [string] ] = copy . deepcopy ( profile [ [string] ] [ [string] ] [ default_name ] ) [EOL] profile [ [string] ] [ [string] ] [ [string] ] [ [string] ] = self . other_schema [EOL] return profile [EOL] [EOL] def copy_state ( self ) : [EOL] assert not os . path . exists ( [string] ) [EOL] os . makedirs ( [string] ) [EOL] shutil . copyfile ( [string] , [string] ) [EOL] [EOL] def run_and_defer ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert not any ( r . node . deferred for r in results ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert not any ( r . node . deferred for r in results ) [EOL] [EOL] [comment] [EOL] self . copy_state ( ) [EOL] [EOL] [comment] [EOL] self . run_dbt ( [ [string] , [string] , [string] ] , expect_pass = False ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] assert self . other_schema not in results [ [number] ] . node . injected_sql [EOL] assert self . unique_schema ( ) in results [ [number] ] . node . injected_sql [EOL] [EOL] with open ( [string] ) as fp : [EOL] data = json . load ( fp ) [EOL] assert data [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] assert len ( results ) == [number] [EOL] [EOL] def run_switchdirs_defer ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] assert len ( results ) == [number] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] assert len ( results ) == [number] [EOL] [EOL] [comment] [EOL] self . copy_state ( ) [EOL] [EOL] self . use_default_project ( { [string] : [ [string] ] } ) [EOL] [comment] [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , expect_pass = False , ) [EOL] [comment] [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , expect_pass = True , ) [EOL] [EOL] self . use_default_project ( { [string] : [ [string] ] } ) [EOL] [comment] [EOL] [comment] [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , expect_pass = False , ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_state_changetarget ( self ) : [EOL] self . run_and_defer ( ) [EOL] [comment] [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] with pytest . raises ( SystemExit ) : [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] [EOL] with pytest . raises ( SystemExit ) : [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] with pytest . raises ( SystemExit ) : [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_stat_changedir ( self ) : [EOL] self . run_switchdirs_defer ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_state_changetarget ( self ) : [EOL] self . run_and_defer ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_state_changetarget ( self ) : [EOL] self . run_and_defer ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_state_changetarget ( self ) : [EOL] self . run_and_defer ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] from pytest import mark [EOL] [EOL] [EOL] [comment] [EOL] def postgres_error ( err , * args ) : [EOL] msg = str ( err ) [EOL] if [string] in msg : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] @ mark . flaky ( rerun_filter = postgres_error ) class TestPermissions ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_no_create_schema_permissions ( self ) : [EOL] [comment] [EOL] self . run_sql ( [string] . format ( self . unique_schema ( ) ) ) [EOL] with self . assertRaises ( RuntimeError ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] ] , expect_pass = False ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_create_schema_permissions ( self ) : [EOL] [comment] [EOL] self . run_sql ( [string] . format ( self . default_database ) ) [EOL] self . run_sql ( [string] . format ( self . unique_schema ( ) ) ) [EOL] self . run_sql ( [string] . format ( self . unique_schema ( ) ) ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] import dbt . exceptions [EOL] [EOL] class TestAdapterDDL ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_long_name_fails ( self ) : [EOL] self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_long_name_succeeds ( self ) : [EOL] self . run_dbt ( [ [string] ] , expect_pass = True ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import datetime [EOL] import json [EOL] import os [EOL] from datetime import datetime , timedelta [EOL] [EOL] import yaml [EOL] [EOL] from dbt . exceptions import CompilationException [EOL] from test . integration . base import DBTIntegrationTest , use_profile , AnyFloat , AnyStringWith [EOL] [EOL] [EOL] class BaseSourcesTest ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : True , [string] : True , [string] : True } , [string] : { [string] : True , } , } [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] os . environ [ [string] ] = [string] [EOL] [EOL] def tearDown ( self ) : [EOL] del os . environ [ [string] ] [EOL] super ( ) . tearDown ( ) [EOL] [EOL] def run_dbt_with_vars ( self , cmd , * args , ** kwargs ) : [EOL] vars_dict = { [string] : self . unique_schema ( ) , [string] : self . adapter . quote ( [string] ) , } [EOL] cmd . extend ( [ [string] , yaml . safe_dump ( vars_dict ) ] ) [EOL] return self . run_dbt ( cmd , * args , ** kwargs ) [EOL] [EOL] [EOL] class SuccessfulSourcesTest ( BaseSourcesTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . run_dbt_with_vars ( [ [string] ] , strict = False ) [EOL] self . maxDiff = None [EOL] self . _id = [number] [EOL] [comment] [EOL] self . last_inserted_time = [string] [EOL] [EOL] def _set_updated_at_to ( self , delta ) : [EOL] insert_time = datetime . utcnow ( ) + delta [EOL] timestr = insert_time . strftime ( [string] ) [EOL] [comment] [EOL] insert_id = self . _id [EOL] self . _id += [number] [EOL] raw_sql = [string] [EOL] quoted_columns = [string] . join ( self . adapter . quote ( c ) if self . adapter_type != [string] else c for c in ( [string] , [string] , [string] , [string] , [string] , [string] ) ) [EOL] self . run_sql ( raw_sql , kwargs = { [string] : self . unique_schema ( ) , [string] : timestr , [string] : insert_id , [string] : self . adapter . quote ( [string] ) , [string] : quoted_columns , } ) [EOL] self . last_inserted_time = insert_time . strftime ( [string] ) [EOL] [EOL] [EOL] class TestSources ( SuccessfulSourcesTest ) : [EOL] @ property def project_config ( self ) : [EOL] cfg = super ( ) . project_config [EOL] cfg . update ( { [string] : [ [string] ] , } ) [EOL] return cfg [EOL] [EOL] def _create_schemas ( self ) : [EOL] super ( ) . _create_schemas ( ) [EOL] self . _create_schema_named ( self . default_database , self . alternative_schema ( ) ) [EOL] [EOL] def alternative_schema ( self ) : [EOL] return self . unique_schema ( ) + [string] [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . run_sql ( [string] . format ( self . unique_schema ( ) ) ) [EOL] self . run_sql ( [string] . format ( self . alternative_schema ( ) , self . unique_schema ( ) ) ) [EOL] [EOL] def run_dbt_with_vars ( self , cmd , * args , ** kwargs ) : [EOL] vars_dict = { [string] : self . unique_schema ( ) , [string] : self . alternative_schema ( ) , [string] : self . adapter . quote ( [string] ) , } [EOL] cmd . extend ( [ [string] , yaml . safe_dump ( vars_dict ) ] ) [EOL] return self . run_dbt ( cmd , * args , ** kwargs ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_basic_source_def ( self ) : [EOL] results = self . run_dbt_with_vars ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] ] , [ [string] , [string] ] ) [EOL] results = self . run_dbt_with_vars ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_source_selector ( self ) : [EOL] [comment] [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_empty_source_def ( self ) : [EOL] [comment] [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_source_only_def ( self ) : [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_source_childrens_parents ( self ) : [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] , [ [string] , [string] ] , ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_run_operation_source ( self ) : [EOL] kwargs = [string] [EOL] self . run_dbt_with_vars ( [ [string] , [string] , [string] , kwargs ] ) [EOL] [EOL] [EOL] class TestSourceFreshness ( SuccessfulSourcesTest ) : [EOL] [EOL] def _assert_freshness_results ( self , path , state ) : [EOL] self . assertTrue ( os . path . exists ( path ) ) [EOL] with open ( path ) as fp : [EOL] data = json . load ( fp ) [EOL] [EOL] self . assertEqual ( set ( data ) , { [string] , [string] } ) [EOL] self . assertIn ( [string] , data [ [string] ] ) [EOL] self . assertIn ( [string] , data [ [string] ] ) [EOL] self . assertTrue ( isinstance ( data [ [string] ] [ [string] ] , float ) ) [EOL] self . assertBetween ( data [ [string] ] [ [string] ] , self . freshness_start_time ) [EOL] [EOL] last_inserted_time = self . last_inserted_time [EOL] [EOL] self . assertEqual ( len ( data [ [string] ] ) , [number] ) [EOL] [EOL] self . assertEqual ( data [ [string] ] , { [string] : { [string] : last_inserted_time , [string] : AnyStringWith ( ) , [string] : AnyFloat ( ) , [string] : state , [string] : { [string] : { [string] : [number] , [string] : [string] } , [string] : { [string] : [number] , [string] : [string] } , } , } } ) [EOL] [EOL] def _run_source_freshness ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . freshness_start_time = datetime . utcnow ( ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] , [string] ] , expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] . status , [string] ) [EOL] self . assertTrue ( results [ [number] ] . fail ) [EOL] self . assertIsNone ( results [ [number] ] . error ) [EOL] self . _assert_freshness_results ( [string] , [string] ) [EOL] [EOL] self . _set_updated_at_to ( timedelta ( hours = - [number] ) ) [EOL] self . freshness_start_time = datetime . utcnow ( ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] , [string] ] , ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] . status , [string] ) [EOL] self . assertFalse ( results [ [number] ] . fail ) [EOL] self . assertIsNone ( results [ [number] ] . error ) [EOL] self . _assert_freshness_results ( [string] , [string] ) [EOL] [EOL] self . _set_updated_at_to ( timedelta ( hours = - [number] ) ) [EOL] self . freshness_start_time = datetime . utcnow ( ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] , [string] , [string] ] , ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] . status , [string] ) [EOL] self . assertFalse ( results [ [number] ] . fail ) [EOL] self . assertIsNone ( results [ [number] ] . error ) [EOL] self . _assert_freshness_results ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_source_freshness ( self ) : [EOL] self . _run_source_freshness ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_source_freshness ( self ) : [EOL] self . _run_source_freshness ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_source_freshness ( self ) : [EOL] self . _run_source_freshness ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_source_freshness ( self ) : [EOL] self . _run_source_freshness ( ) [EOL] [EOL] [EOL] class TestSourceFreshnessErrors ( SuccessfulSourcesTest ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_error ( self ) : [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] ] , expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] . status , [string] ) [EOL] self . assertFalse ( results [ [number] ] . fail ) [EOL] self . assertIsNotNone ( results [ [number] ] . error ) [EOL] [EOL] [EOL] class TestSourceFreshnessFilter ( SuccessfulSourcesTest ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def assert_source_freshness_passed ( self , results ) : [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] . status , [string] ) [EOL] self . assertFalse ( results [ [number] ] . fail ) [EOL] self . assertIsNone ( results [ [number] ] . error ) [EOL] [EOL] def assert_source_freshness_failed ( self , results ) : [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] . status , [string] ) [EOL] self . assertTrue ( results [ [number] ] . fail ) [EOL] self . assertIsNone ( results [ [number] ] . error ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_all_records ( self ) : [EOL] [comment] [EOL] self . run_dbt_with_vars ( [ [string] , [string] ] , expect_pass = False ) [EOL] [comment] [EOL] [comment] [EOL] self . _set_updated_at_to ( timedelta ( hours = - [number] ) ) [EOL] self . run_dbt_with_vars ( [ [string] , [string] ] , expect_pass = False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _set_updated_at_to ( timedelta ( hours = - [number] ) ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] ] , expect_pass = True ) [EOL] [EOL] [EOL] class TestMalformedSources ( BaseSourcesTest ) : [EOL] [comment] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_malformed_schema_nonstrict_will_break_run ( self ) : [EOL] with self . assertRaises ( CompilationException ) : [EOL] self . run_dbt_with_vars ( [ [string] ] , strict = False ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_malformed_schema_strict_will_break_run ( self ) : [EOL] with self . assertRaises ( CompilationException ) : [EOL] self . run_dbt_with_vars ( [ [string] ] , strict = True ) [EOL] [EOL] [EOL] class TestRenderingInSourceTests ( BaseSourcesTest ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_render_in_source_tests ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] [comment] [EOL] self . run_dbt_with_vars ( [ [string] ] , expect_pass = False ) [EOL] [EOL] [EOL] class TestUnquotedSources ( SuccessfulSourcesTest ) : [EOL] @ property def project_config ( self ) : [EOL] cfg = super ( ) . project_config [EOL] cfg [ [string] ] = { [string] : False , [string] : False , [string] : False , } [EOL] return cfg [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_catalog ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] self . run_dbt_with_vars ( [ [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_catalog ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] self . run_dbt_with_vars ( [ [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import os [EOL] import shutil [EOL] [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] from dbt . exceptions import CompilationException [EOL] [EOL] [EOL] class TestConfigs ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] def unique_schema ( self ) : [EOL] return super ( ) . unique_schema ( ) . upper ( ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : { [string] : [string] , [string] : [ [string] ] , } } , } , [string] : { [string] : False , } , } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_config_layering ( self ) : [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] ] ) ) , [number] ) [EOL] [comment] [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] , [string] , [string] ] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] , [string] , [string] ] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] , [string] , [string] ] ) ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [comment] [EOL] models = self . get_models_in_schema ( ) [EOL] self . assertEqual ( models [ [string] ] , [string] ) [EOL] [EOL] [EOL] class TestTargetConfigs ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] def unique_schema ( self ) : [EOL] return super ( ) . unique_schema ( ) . upper ( ) [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . init_targets = [ d for d in os . listdir ( [string] ) if os . path . isdir ( d ) and d . startswith ( [string] ) ] [EOL] [EOL] def tearDown ( self ) : [EOL] super ( ) . tearDown ( ) [EOL] for d in self . new_dirs ( ) : [EOL] shutil . rmtree ( d ) [EOL] [EOL] def new_dirs ( self ) : [EOL] for d in os . listdir ( [string] ) : [EOL] if os . path . isdir ( d ) and d not in self . init_targets and d . startswith ( [string] ) : [EOL] yield d [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [string] , [string] : { [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_alternative_target_paths ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] dirs = list ( self . new_dirs ( ) ) [EOL] self . assertEqual ( len ( dirs ) , [number] ) [EOL] self . assertTrue ( os . path . exists ( os . path . join ( dirs [ [number] ] , [string] ) ) ) [EOL] [EOL] [EOL] class TestDisabledConfigs ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] def postgres_profile ( self ) : [EOL] return { [string] : { [string] : False } , [string] : { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : self . database_host , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , [string] : { [string] : [string] , [string] : [string] , [string] : self . database_host , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , } , [string] : [string] } } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : [string] , } , } , [string] : { [string] : { [string] : [string] , } } , [string] : { [string] : False , [string] : { [string] : { [string] : [string] , } , } , } , } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_disable_seed_partial_parse ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_conditional_model ( self ) : [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] , strict = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] , strict = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestUnusedModelConfigs ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : True , } } , [string] : { [string] : False , } , [string] : { [string] : { [string] : True , } } } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_warn_unused_configuration_paths ( self ) : [EOL] with self . assertRaises ( CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] self . run_dbt ( [ [string] ] , strict = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] class TestExternalReference ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . use_default_project ( ) [EOL] self . external_schema = self . unique_schema ( ) + [string] [EOL] self . run_sql ( [string] . format ( self . external_schema ) ) [EOL] self . run_sql ( [string] . format ( self . external_schema ) ) [EOL] self . run_sql ( [string] . format ( self . external_schema ) ) [EOL] [EOL] def tearDown ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . _drop_schemas ( ) [EOL] with self . get_connection ( ) : [EOL] self . _drop_schema_named ( self . default_database , self . external_schema ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__external_reference ( self ) : [EOL] self . assertEqual ( len ( self . run_dbt ( ) ) , [number] ) [EOL] [comment] [EOL] self . assertEqual ( len ( self . run_dbt ( ) ) , [number] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class TestExternalDependency ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def tearDown ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . _drop_schemas ( ) [EOL] with self . get_connection ( ) : [EOL] self . _drop_schema_named ( self . default_database , self . external_schema ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__external_reference ( self ) : [EOL] self . assertEqual ( len ( self . run_dbt ( ) ) , [number] ) [EOL] [EOL] [comment] [EOL] self . external_schema = self . unique_schema ( ) + [string] [EOL] self . run_sql ( [string] . format ( self . external_schema ) ) [EOL] self . run_sql ( [string] . format ( self . external_schema , self . unique_schema ( ) ) ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( len ( self . run_dbt ( ) ) , [number] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class BaseTestSimpleDependencyWithConfigs ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class TestSimpleDependencyWithConfigs ( BaseTestSimpleDependencyWithConfigs ) : [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } , ] } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : True } , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_dependency ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [EOL] class TestSimpleDependencyWithOverriddenConfigs ( BaseTestSimpleDependencyWithConfigs ) : [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } , ] } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : True } , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_dependency ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] import json [EOL] import shutil [EOL] import yaml [EOL] from unittest import mock [EOL] [EOL] import dbt . semver [EOL] import dbt . config [EOL] import dbt . exceptions [EOL] [EOL] [EOL] class BaseDependencyTest ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def base_schema ( self ) : [EOL] return self . unique_schema ( ) [EOL] [EOL] def configured_schema ( self ) : [EOL] return self . unique_schema ( ) + [string] [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . base_schema ( ) ) ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . configured_schema ( ) ) ) [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } ] } [EOL] [EOL] def run_dbt ( self , * args , ** kwargs ) : [EOL] strict = kwargs . pop ( [string] , False ) [EOL] kwargs [ [string] ] = strict [EOL] return super ( ) . run_dbt ( * args , ** kwargs ) [EOL] [EOL] [EOL] class TestSimpleDependency ( BaseDependencyTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def base_schema ( self ) : [EOL] return self . unique_schema ( ) [EOL] [EOL] def configured_schema ( self ) : [EOL] return self . unique_schema ( ) + [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_local_dependency ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( { r . node . schema for r in results } , { self . base_schema ( ) , self . configured_schema ( ) } ) [EOL] [EOL] base_schema_nodes = [ r . node for r in results if r . node . schema == self . base_schema ( ) ] [EOL] self . assertEqual ( len ( base_schema_nodes ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] , self . base_schema ( ) , self . base_schema ( ) ) [EOL] self . assertTablesEqual ( [string] , [string] , self . base_schema ( ) , self . base_schema ( ) ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_no_dependency_paths ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] local_path = os . path . join ( [string] , [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , f' [string] { local_path }' ] , ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] dep_path = os . path . join ( [string] , [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , f' [string] { dep_path }' ] , ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestMissingDependency ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_missing_dependency ( self ) : [EOL] [comment] [EOL] with self . assertRaises ( dbt . exceptions . Exception ) as exc : [EOL] self . run_dbt ( [ [string] ] , strict = False ) [EOL] message = str ( exc . exception ) [EOL] self . assertIn ( [string] , message ) [EOL] self . assertIn ( [string] , message ) [EOL] [EOL] [EOL] class TestSimpleDependencyWithSchema ( TestSimpleDependency ) : [EOL] def run_dbt ( self , cmd , * args , ** kwargs ) : [EOL] [comment] [EOL] vars_arg = yaml . safe_dump ( { [string] : self . base_schema ( ) , } ) [EOL] cmd . extend ( [ [string] , vars_arg ] ) [EOL] return super ( ) . run_dbt ( cmd , * args , ** kwargs ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : [string] , } , [string] : { [string] : [string] , } } [EOL] [EOL] def base_schema ( self ) : [EOL] return [string] . format ( self . unique_schema ( ) ) [EOL] [EOL] def configured_schema ( self ) : [EOL] return [string] . format ( self . unique_schema ( ) ) [EOL] [EOL] @ use_profile ( [string] ) @ mock . patch ( [string] ) def test_postgres_local_dependency_out_of_date ( self , mock_get ) : [EOL] mock_get . return_value = dbt . semver . VersionSpecifier . from_version_string ( [string] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [comment] [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] @ use_profile ( [string] ) @ mock . patch ( [string] ) def test_postgres_local_dependency_out_of_date_no_check ( self , mock_get ) : [EOL] mock_get . return_value = dbt . semver . VersionSpecifier . from_version_string ( [string] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( [ [string] , [string] ] ) [EOL] results = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestSimpleDependencyHooks ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] [comment] [EOL] return { [string] : [number] , [string] : [ [string] , [string] , ] } [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } , { [string] : [string] } ] } [EOL] [EOL] def base_schema ( self ) : [EOL] return self . unique_schema ( ) [EOL] [EOL] def configured_schema ( self ) : [EOL] return self . unique_schema ( ) + [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_hook_dependency ( self ) : [EOL] cli_vars = json . dumps ( { [string] : [string] . format ( self . unique_schema ( ) ) , [string] : [string] . format ( self . unique_schema ( ) ) } ) [EOL] self . run_dbt ( [ [string] , [string] , cli_vars ] ) [EOL] results = self . run_dbt ( [ [string] , [string] , cli_vars ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [EOL] class TestSimpleDependencyDuplicateName ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] } ] } [EOL] [EOL] def run_dbt ( self , * args , ** kwargs ) : [EOL] strict = kwargs . pop ( [string] , False ) [EOL] kwargs [ [string] ] = strict [EOL] return super ( ) . run_dbt ( * args , ** kwargs ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_local_dependency_same_name ( self ) : [EOL] with self . assertRaises ( dbt . exceptions . DependencyException ) : [EOL] self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_local_dependency_same_name_sneaky ( self ) : [EOL] os . makedirs ( [string] ) [EOL] shutil . copytree ( [string] , [string] ) [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) : [EOL] self . run_dbt ( [ [string] ] , expect_pass = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import tempfile [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] from dbt . exceptions import CompilationException [EOL] from dbt import deprecations [EOL] [EOL] [EOL] class TestSimpleDependency ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } ] } [EOL] [EOL] def run_deps ( self ) : [EOL] return self . run_dbt ( [ [string] ] ) [EOL] [EOL] def run_clean ( self ) : [EOL] return self . run_dbt ( [ [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_dependency ( self ) : [EOL] self . run_deps ( ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . run_deps ( ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] assert os . path . exists ( [string] ) [EOL] self . run_clean ( ) [EOL] assert not os . path . exists ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_dependency_with_models ( self ) : [EOL] self . run_deps ( ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] [EOL] assert os . path . exists ( [string] ) [EOL] self . run_clean ( ) [EOL] assert not os . path . exists ( [string] ) [EOL] [EOL] [EOL] class TestSimpleDependencyUnpinned ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : True , } ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_dependency ( self ) : [EOL] with self . assertRaises ( CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] assert [string] in str ( exc . exception ) [EOL] self . run_dbt ( [ [string] ] , strict = False ) [EOL] [EOL] [EOL] class TestSimpleDependencyWithDuplicates ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] [comment] [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , } ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_dependency_deps ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] [EOL] class TestRekeyedDependencyWithSubduplicates ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] [comment] [EOL] [comment] [EOL] return { [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , } ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_dependency_deps ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( os . listdir ( [string] ) ) , [number] ) [EOL] [EOL] [EOL] class TestSimpleDependencyBranch ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } , ] } [EOL] [EOL] def deps_run_assert_equality ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_simple_dependency ( self ) : [EOL] self . deps_run_assert_equality ( ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . deps_run_assert_equality ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_empty_models_not_compiled_in_dependencies ( self ) : [EOL] self . deps_run_assert_equality ( ) [EOL] [EOL] models = self . get_models_in_schema ( ) [EOL] [EOL] self . assertFalse ( [string] in models . keys ( ) ) [EOL] [EOL] [EOL] class TestSimpleDependencyNoProfile ( TestSimpleDependency ) : [EOL] def run_deps ( self ) : [EOL] with tempfile . TemporaryDirectory ( ) as tmpdir : [EOL] result = self . run_dbt ( [ [string] , [string] , tmpdir ] ) [EOL] return result [EOL] [EOL] def run_clean ( self ) : [EOL] with tempfile . TemporaryDirectory ( ) as tmpdir : [EOL] result = self . run_dbt ( [ [string] , [string] , tmpdir ] ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] import dbt . exceptions [EOL] [EOL] [EOL] class TestExitCodes ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_exit_code_run_succeed ( self ) : [EOL] results , success = self . run_dbt_and_check ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertTrue ( success ) [EOL] self . assertTableDoesExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_exit_code_run_fail ( self ) : [EOL] results , success = self . run_dbt_and_check ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertFalse ( success ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_schema_test_pass ( self ) : [EOL] results , success = self . run_dbt_and_check ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertTrue ( success ) [EOL] results , success = self . run_dbt_and_check ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertTrue ( success ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_schema_test_fail ( self ) : [EOL] results , success = self . run_dbt_and_check ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertTrue ( success ) [EOL] results , success = self . run_dbt_and_check ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertFalse ( success ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_compile ( self ) : [EOL] results , success = self . run_dbt_and_check ( [ [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertTrue ( success ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_snapshot_pass ( self ) : [EOL] self . run_dbt_and_check ( [ [string] , [string] , [string] ] ) [EOL] results , success = self . run_dbt_and_check ( [ [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertTableDoesExist ( [string] ) [EOL] self . assertTrue ( success ) [EOL] [EOL] [EOL] class TestExitCodesSnapshotFail ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_snapshot_fail ( self ) : [EOL] results , success = self . run_dbt_and_check ( [ [string] , [string] , [string] ] ) [EOL] self . assertTrue ( success ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] [EOL] results , success = self . run_dbt_and_check ( [ [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertFalse ( success ) [EOL] [EOL] class TestExitCodesDeps ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_deps ( self ) : [EOL] _ , success = self . run_dbt_and_check ( [ [string] ] ) [EOL] self . assertTrue ( success ) [EOL] [EOL] [EOL] class TestExitCodesDepsFail ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } , ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_deps ( self ) : [EOL] with self . assertRaises ( dbt . exceptions . InternalException ) : [EOL] [comment] [EOL] self . run_dbt_and_check ( [ [string] ] ) [EOL] [EOL] [EOL] class TestExitCodesSeed ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_seed ( self ) : [EOL] results , success = self . run_dbt_and_check ( [ [string] ] ) [EOL] self . assertEqual ( len ( results . results ) , [number] ) [EOL] self . assertTrue ( success ) [EOL] [EOL] [EOL] class TestExitCodesSeedFail ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_seed ( self ) : [EOL] _ , success = self . run_dbt_and_check ( [ [string] ] ) [EOL] self . assertFalse ( success ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] [EOL] [EOL] class TestInvalidDisabledModels ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_view_with_incremental_attributes ( self ) : [EOL] with self . assertRaises ( RuntimeError ) as exc : [EOL] self . run_dbt ( ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] [EOL] class TestDisabledModelReference ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_view_with_incremental_attributes ( self ) : [EOL] with self . assertRaises ( RuntimeError ) as exc : [EOL] self . run_dbt ( ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] [EOL] class TestMissingModelReference ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_view_with_incremental_attributes ( self ) : [EOL] with self . assertRaises ( RuntimeError ) as exc : [EOL] self . run_dbt ( ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] [EOL] class TestInvalidMacroCall ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return path . lstrip ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . dir ( [string] ) ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_call_invalid ( self ) : [EOL] with self . assertRaises ( Exception ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] macro_path = os . path . join ( [string] , [string] ) [EOL] model_path = os . path . join ( [string] , [string] ) [EOL] [EOL] self . assertIn ( f' [string] { macro_path } [string] ' , str ( exc . exception ) ) [EOL] self . assertIn ( f' [string] { model_path } [string] ' , str ( exc . exception ) ) [EOL] [EOL] [EOL] class TestInvalidDisabledSource ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : False , } } } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_source_disabled ( self ) : [EOL] with self . assertRaises ( RuntimeError ) as exc : [EOL] self . run_dbt ( ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] [EOL] class TestInvalidMissingSource ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_source_missing ( self ) : [EOL] with self . assertRaises ( RuntimeError ) as exc : [EOL] self . run_dbt ( ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestThreadCount ( DBTIntegrationTest ) : [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] } [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : [number] , } [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_threading_8x ( self ) : [EOL] results = self . run_dbt ( args = [ [string] , [string] , [string] ] ) [EOL] self . assertTrue ( len ( results ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] class TestBigqueryPrePostRunHooks ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . use_profile ( [string] ) [EOL] self . use_default_project ( ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . fields = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] profile = self . bigquery_profile ( ) [EOL] profile [ [string] ] [ [string] ] [ [string] ] [ [string] ] = [number] [EOL] return profile [EOL] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , ] , [string] : [ [string] , [string] , [string] , ] , [string] : { [string] : False , } , } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def get_ctx_vars ( self , state ) : [EOL] field_list = [string] . join ( self . fields ) [EOL] query = [string] . format ( field_list = field_list , schema = self . unique_schema ( ) , state = state ) [EOL] [EOL] vals = self . run_sql ( query , fetch = [string] ) [EOL] self . assertFalse ( len ( vals ) == [number] , [string] ) [EOL] self . assertFalse ( len ( vals ) > [number] , [string] ) [EOL] ctx = dict ( zip ( self . fields , vals [ [number] ] ) ) [EOL] [EOL] return ctx [EOL] [EOL] def check_hooks ( self , state ) : [EOL] ctx = self . get_ctx_vars ( state ) [EOL] [EOL] self . assertEqual ( ctx [ [string] ] , state ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] [EOL] self . assertTrue ( ctx [ [string] ] is not None and len ( ctx [ [string] ] ) > [number] , [string] ) [EOL] self . assertTrue ( ctx [ [string] ] is not None and len ( ctx [ [string] ] ) > [number] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_pre_and_post_run_hooks ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . check_hooks ( [string] ) [EOL] self . check_hooks ( [string] ) [EOL] [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_pre_and_post_seed_hooks ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . check_hooks ( [string] ) [EOL] self . check_hooks ( [string] ) [EOL] [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] from dbt . exceptions import CompilationException [EOL] [EOL] [EOL] MODEL_PRE_HOOK = [string] [EOL] [EOL] MODEL_POST_HOOK = [string] [EOL] [EOL] [EOL] class BaseTestPrePost ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . fields = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] def get_ctx_vars ( self , state , count ) : [EOL] field_list = [string] . join ( [ [string] . format ( f ) for f in self . fields ] ) [EOL] query = [string] . format ( field_list = field_list , schema = self . unique_schema ( ) , state = state ) [EOL] [EOL] vals = self . run_sql ( query , fetch = [string] ) [EOL] self . assertFalse ( len ( vals ) == [number] , [string] ) [EOL] self . assertFalse ( len ( vals ) < count , [string] ) [EOL] self . assertFalse ( len ( vals ) > count , [string] ) [EOL] return [ { k : v for k , v in zip ( self . fields , val ) } for val in vals ] [EOL] [EOL] def check_hooks ( self , state , count = [number] ) : [EOL] ctxs = self . get_ctx_vars ( state , count = count ) [EOL] for ctx in ctxs : [EOL] self . assertEqual ( ctx [ [string] ] , state ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . database_host ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] [EOL] self . assertTrue ( ctx [ [string] ] is not None and len ( ctx [ [string] ] ) > [number] , [string] ) [EOL] self . assertTrue ( ctx [ [string] ] is not None and len ( ctx [ [string] ] ) > [number] , [string] ) [EOL] [EOL] [EOL] class TestPrePostModelHooks ( BaseTestPrePost ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : [ MODEL_PRE_HOOK , { [string] : [string] , [string] : False } , ] , [string] : [ { [string] : [string] , [string] : False } , MODEL_POST_HOOK , ] , } } } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_pre_and_post_model_hooks ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . check_hooks ( [string] ) [EOL] self . check_hooks ( [string] ) [EOL] [EOL] [EOL] class TestHookRefs ( BaseTestPrePost ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : { [string] : [ [string] . strip ( ) ] , } } , } } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_pre_post_model_hooks_refed ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . check_hooks ( [string] , count = [number] ) [EOL] self . check_hooks ( [string] , count = [number] ) [EOL] [EOL] [EOL] class TestPrePostModelHooksOnSeeds ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { } , [string] : { [string] : [ [string] , [string] ] , [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_hooks_on_seeds ( self ) : [EOL] res = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( res ) , [number] , [string] ) [EOL] res = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( res ) , [number] , [string] ) [EOL] [EOL] [EOL] class TestPrePostModelHooksOnSeedsPlusPrefixed ( TestPrePostModelHooksOnSeeds ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { } , [string] : { [string] : [ [string] , [string] ] , [string] : False , } , } [EOL] [EOL] [EOL] class TestPrePostModelHooksOnSnapshots ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { } , [string] : { [string] : [ [string] , [string] ] } , [string] : { [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_hooks_on_snapshots ( self ) : [EOL] res = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( res ) , [number] , [string] ) [EOL] res = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( res ) , [number] , [string] ) [EOL] res = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( res ) , [number] , [string] ) [EOL] [EOL] [EOL] class TestPrePostModelHooksInConfig ( BaseTestPrePost ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_pre_and_post_model_hooks_model ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . check_hooks ( [string] ) [EOL] self . check_hooks ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_pre_and_post_model_hooks_model_and_project ( self ) : [EOL] self . use_default_project ( { [string] : [number] , [string] : { [string] : { [string] : [ MODEL_PRE_HOOK , { [string] : [string] , [string] : False } , ] , [string] : [ { [string] : [string] , [string] : False } , MODEL_POST_HOOK , ] , } } } ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . check_hooks ( [string] , count = [number] ) [EOL] self . check_hooks ( [string] , count = [number] ) [EOL] [EOL] [EOL] class TestPrePostModelHooksInConfigKwargs ( TestPrePostModelHooksInConfig ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class TestPrePostSnapshotHooksInConfigKwargs ( TestPrePostModelHooksOnSnapshots ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { } , [string] : { [string] : False , } , } [EOL] [EOL] [EOL] class TestDuplicateHooksInConfigs ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_run_duplicate_hook_defs ( self ) : [EOL] with self . assertRaises ( CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestPrePostRunHooks ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . fields = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : { [string] : False , } , } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def get_ctx_vars ( self , state ) : [EOL] field_list = [string] . join ( [ [string] . format ( f ) for f in self . fields ] ) [EOL] query = [string] . format ( field_list = field_list , schema = self . unique_schema ( ) , state = state ) [EOL] [EOL] vals = self . run_sql ( query , fetch = [string] ) [EOL] self . assertFalse ( len ( vals ) == [number] , [string] ) [EOL] self . assertFalse ( len ( vals ) > [number] , [string] ) [EOL] ctx = dict ( [ ( k , v ) for ( k , v ) in zip ( self . fields , vals [ [number] ] ) ] ) [EOL] [EOL] return ctx [EOL] [EOL] def assert_used_schemas ( self ) : [EOL] schemas_query = [string] . format ( self . unique_schema ( ) ) [EOL] results = self . run_sql ( schemas_query , fetch = [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] [ [number] ] , self . unique_schema ( ) ) [EOL] [EOL] db_schemas_query = [string] . format ( self . unique_schema ( ) ) [EOL] results = self . run_sql ( db_schemas_query , fetch = [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] [ [number] ] , self . default_database ) [EOL] self . assertEqual ( results [ [number] ] [ [number] ] , self . unique_schema ( ) ) [EOL] [EOL] def check_hooks ( self , state ) : [EOL] ctx = self . get_ctx_vars ( state ) [EOL] [EOL] self . assertEqual ( ctx [ [string] ] , state ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . database_host ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] [EOL] self . assertTrue ( ctx [ [string] ] is not None and len ( ctx [ [string] ] ) > [number] , [string] ) [EOL] self . assertTrue ( ctx [ [string] ] is not None and len ( ctx [ [string] ] ) > [number] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__pre_and_post_run_hooks ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . check_hooks ( [string] ) [EOL] self . check_hooks ( [string] ) [EOL] [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assert_used_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__pre_and_post_seed_hooks ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . check_hooks ( [string] ) [EOL] self . check_hooks ( [string] ) [EOL] [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assert_used_schemas ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] MODEL_PRE_HOOK = [string] [EOL] [EOL] [EOL] MODEL_POST_HOOK = [string] [EOL] [EOL] class TestBigqueryPrePostModelHooks ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] self . fields = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def profile_config ( self ) : [EOL] profile = self . bigquery_profile ( ) [EOL] profile [ [string] ] [ [string] ] [ [string] ] [ [string] ] = [number] [EOL] return profile [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : [ MODEL_PRE_HOOK ] , [string] : [ MODEL_POST_HOOK ] , } } } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def get_ctx_vars ( self , state ) : [EOL] field_list = [string] . join ( self . fields ) [EOL] query = [string] . format ( field_list = field_list , schema = self . unique_schema ( ) , state = state ) [EOL] [EOL] vals = self . run_sql ( query , fetch = [string] ) [EOL] self . assertFalse ( len ( vals ) == [number] , [string] ) [EOL] self . assertFalse ( len ( vals ) > [number] , [string] ) [EOL] ctx = dict ( zip ( self . fields , vals [ [number] ] ) ) [EOL] [EOL] return ctx [EOL] [EOL] def check_hooks ( self , state ) : [EOL] ctx = self . get_ctx_vars ( state ) [EOL] [EOL] self . assertEqual ( ctx [ [string] ] , state ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertEqual ( ctx [ [string] ] , self . unique_schema ( ) ) [EOL] self . assertEqual ( ctx [ [string] ] , [number] ) [EOL] self . assertEqual ( ctx [ [string] ] , [string] ) [EOL] self . assertTrue ( ctx [ [string] ] is not None and len ( ctx [ [string] ] ) > [number] , [string] ) [EOL] self . assertTrue ( ctx [ [string] ] is not None and len ( ctx [ [string] ] ) > [number] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_pre_and_post_model_hooks_bigquery ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] self . check_hooks ( [string] ) [EOL] self . check_hooks ( [string] ) [EOL] [EOL] [EOL] class TestBigqueryPrePostModelHooksOnSeeds ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { } , [string] : { [string] : [ [string] , ] , [string] : False , } , } [EOL] [EOL] @ use_profile ( [string] ) def test_hooks_on_seeds_bigquery ( self ) : [EOL] res = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( res ) , [number] , [string] ) [EOL] res = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( res ) , [number] , [string] ) [EOL] result = self . run_sql ( [string] , fetch = [string] ) [EOL] self . assertFalse ( len ( result ) == [number] , [string] ) [EOL] self . assertFalse ( len ( result ) > [number] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestVarcharWidening ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__varchar_widening ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__varchar_widening ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] ] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] class TestSeverity ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : False , } , } [EOL] [EOL] def run_dbt_with_vars ( self , cmd , strict_var , * args , ** kwargs ) : [EOL] cmd . extend ( [ [string] , [string] . format ( self . unique_schema ( ) , strict_var ) ] ) [EOL] return self . run_dbt ( cmd , * args , ** kwargs ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_severity_warnings ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] ] , [string] , strict = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertFalse ( results [ [number] ] . fail ) [EOL] self . assertTrue ( results [ [number] ] . warn ) [EOL] self . assertEqual ( results [ [number] ] . status , [number] ) [EOL] self . assertFalse ( results [ [number] ] . fail ) [EOL] self . assertTrue ( results [ [number] ] . warn ) [EOL] self . assertEqual ( results [ [number] ] . status , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_severity_rendered_errors ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] ] , [string] , strict = False , expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTrue ( results [ [number] ] . fail ) [EOL] self . assertFalse ( results [ [number] ] . warn ) [EOL] self . assertEqual ( results [ [number] ] . status , [number] ) [EOL] self . assertTrue ( results [ [number] ] . fail ) [EOL] self . assertFalse ( results [ [number] ] . warn ) [EOL] self . assertEqual ( results [ [number] ] . status , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_severity_warnings_strict ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] ] , [string] , expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTrue ( results [ [number] ] . fail ) [EOL] self . assertFalse ( results [ [number] ] . warn ) [EOL] self . assertEqual ( results [ [number] ] . status , [number] ) [EOL] self . assertTrue ( results [ [number] ] . fail ) [EOL] self . assertFalse ( results [ [number] ] . warn ) [EOL] self . assertEqual ( results [ [number] ] . status , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_data_severity_warnings ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] ] , [string] , strict = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertFalse ( results [ [number] ] . fail ) [EOL] self . assertTrue ( results [ [number] ] . warn ) [EOL] self . assertEqual ( results [ [number] ] . status , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_data_severity_rendered_errors ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] ] , [string] , strict = False , expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTrue ( results [ [number] ] . fail ) [EOL] self . assertFalse ( results [ [number] ] . warn ) [EOL] self . assertEqual ( results [ [number] ] . status , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_data_severity_warnings_strict ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] self . run_dbt_with_vars ( [ [string] ] , [string] , strict = False ) [EOL] results = self . run_dbt_with_vars ( [ [string] , [string] ] , [string] , expect_pass = False ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTrue ( results [ [number] ] . fail ) [EOL] self . assertFalse ( results [ [number] ] . warn ) [EOL] self . assertEqual ( results [ [number] ] . status , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] from dbt . exceptions import FailFastException [EOL] [EOL] [EOL] class TestFastFailingDuringRun ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [string] , [string] : { [string] : { [string] : [ { [string] : [string] , [string] : False } , { [string] : [string] , [string] : False } ] , } } } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def check_audit_table ( self , count = [number] ) : [EOL] query = [string] . format ( schema = self . unique_schema ( ) ) [EOL] [EOL] vals = self . run_sql ( query , fetch = [string] ) [EOL] self . assertFalse ( len ( vals ) == count , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_fail_fast_run ( self ) : [EOL] with self . assertRaises ( FailFastException ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . check_audit_table ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestStatements ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return path . lstrip ( [string] ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : False , } } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_statements ( self ) : [EOL] self . use_default_project ( { [string] : [ self . dir ( [string] ) ] } ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_statements ( self ) : [EOL] self . use_default_project ( { [string] : [ self . dir ( [string] ) ] } ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test_presto_statements ( self ) : [EOL] self . use_default_project ( { [string] : [ self . dir ( [string] ) ] } ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [EOL] class TestStatementsBigquery ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return path . lstrip ( [string] ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : False , } } [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_statements ( self ) : [EOL] self . use_default_project ( { [string] : [ self . dir ( [string] ) ] } ) [EOL] [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestRuntimeMaterialization ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : False , } } [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_dbt_full_refresh ( self ) : [EOL] return self . run_dbt ( [ [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_full_refresh ( self ) : [EOL] [comment] [EOL] results = self . run_dbt_full_refresh ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt_full_refresh ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt_full_refresh ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_delete__dbt_tmp_relation ( self ) : [EOL] [comment] [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTableDoesNotExist ( [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [EOL] class TestRuntimeMaterializationWithConfig ( TestRuntimeMaterialization ) : [EOL] @ property def project_config ( self ) : [EOL] result = super ( ) . project_config [EOL] result . update ( { [string] : { [string] : True } } ) [EOL] return result [EOL] [EOL] def run_dbt_full_refresh ( self ) : [EOL] return self . run_dbt ( [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestCLIVarOverride ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : [string] , } , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_overriden_vars_global ( self ) : [EOL] self . use_default_project ( ) [EOL] self . use_profile ( [string] ) [EOL] [EOL] [comment] [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] [EOL] class TestCLIVarOverridePorject ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : [string] , } , } , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_overriden_vars_project_level ( self ) : [EOL] [EOL] [comment] [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import yaml [EOL] [EOL] [EOL] class TestCLIVars ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_cli_vars_longform ( self ) : [EOL] self . use_profile ( [string] ) [EOL] self . use_default_project ( ) [EOL] [EOL] cli_vars = { [string] : [string] , [string] : [ [string] , [string] ] , [string] : { [string] : [string] } } [EOL] results = self . run_dbt ( [ [string] , [string] , yaml . dump ( cli_vars ) ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , yaml . dump ( cli_vars ) ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [EOL] class TestCLIVarsSimple ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_cli_vars_shorthand ( self ) : [EOL] self . use_profile ( [string] ) [EOL] self . use_default_project ( ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_cli_vars_longer ( self ) : [EOL] self . use_profile ( [string] ) [EOL] self . use_default_project ( ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Set [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] from dbt import deprecations [EOL] import dbt . exceptions [EOL] [EOL] [EOL] class BaseTestDeprecations ( DBTIntegrationTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] deprecations . reset_deprecations ( ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return path . lstrip ( [string] ) [EOL] [EOL] [EOL] class TestDeprecations ( BaseTestDeprecations ) : [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_deprecations_fail ( self ) : [EOL] self . run_dbt ( strict = True , expect_pass = False ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_deprecations ( self ) : [EOL] self . assertEqual ( deprecations . active_deprecations , set ( ) ) [EOL] self . run_dbt ( strict = False ) [EOL] expected = { [string] } [EOL] self . assertEqual ( expected , deprecations . active_deprecations ) [EOL] [EOL] [EOL] class TestMaterializationReturnDeprecation ( BaseTestDeprecations ) : [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . dir ( [string] ) ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_deprecations_fail ( self ) : [EOL] [comment] [EOL] self . run_dbt ( strict = True , expect_pass = False ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_deprecations ( self ) : [EOL] self . assertEqual ( deprecations . active_deprecations , set ( ) ) [EOL] self . run_dbt ( strict = False ) [EOL] expected = { [string] } [EOL] self . assertEqual ( expected , deprecations . active_deprecations ) [EOL] [EOL] [EOL] class TestModelsKeyMismatchDeprecation ( BaseTestDeprecations ) : [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_deprecations_fail ( self ) : [EOL] [comment] [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) as exc : [EOL] self . run_dbt ( strict = True ) [EOL] exc_str = [string] . join ( str ( exc . exception ) . split ( ) ) [comment] [EOL] self . assertIn ( [string] , exc_str ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_deprecations ( self ) : [EOL] self . assertEqual ( deprecations . active_deprecations , set ( ) ) [EOL] self . run_dbt ( strict = False ) [EOL] expected = { [string] } [EOL] self . assertEqual ( expected , deprecations . active_deprecations ) [EOL] [EOL] [EOL] class TestAdapterMacroDeprecation ( BaseTestDeprecations ) : [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . dir ( [string] ) ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_adapter_macro ( self ) : [EOL] self . assertEqual ( deprecations . active_deprecations , set ( ) ) [EOL] self . run_dbt ( strict = False ) [EOL] expected = { [string] } [EOL] self . assertEqual ( expected , deprecations . active_deprecations ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_adapter_macro_fail ( self ) : [EOL] self . assertEqual ( deprecations . active_deprecations , set ( ) ) [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) as exc : [EOL] self . run_dbt ( strict = True ) [EOL] exc_str = [string] . join ( str ( exc . exception ) . split ( ) ) [comment] [EOL] assert [string] in exc_str [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_adapter_macro ( self ) : [EOL] self . assertEqual ( deprecations . active_deprecations , set ( ) ) [EOL] [comment] [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) as exc : [EOL] self . run_dbt ( strict = False , expect_pass = False ) [EOL] exc_str = [string] . join ( str ( exc . exception ) . split ( ) ) [comment] [EOL] assert [string] in exc_str [comment] [EOL] [EOL] [EOL] class TestAdapterMacroDeprecationPackages ( BaseTestDeprecations ) : [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . dir ( [string] ) ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_adapter_macro_pkg ( self ) : [EOL] self . assertEqual ( deprecations . active_deprecations , set ( ) ) [EOL] self . run_dbt ( strict = False ) [EOL] expected = { [string] } [EOL] self . assertEqual ( expected , deprecations . active_deprecations ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_adapter_macro_pkg_fail ( self ) : [EOL] self . assertEqual ( deprecations . active_deprecations , set ( ) ) [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) as exc : [EOL] self . run_dbt ( strict = True ) [EOL] exc_str = [string] . join ( str ( exc . exception ) . split ( ) ) [comment] [EOL] assert [string] in exc_str [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_adapter_macro_pkg ( self ) : [EOL] self . assertEqual ( deprecations . active_deprecations , set ( ) ) [EOL] [comment] [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) as exc : [EOL] self . run_dbt ( strict = False , expect_pass = False ) [EOL] exc_str = [string] . join ( str ( exc . exception ) . split ( ) ) [comment] [EOL] assert [string] in exc_str [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] class TestAdapterDDL ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_sort_and_dist_keys_are_nops_on_postgres ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import json [EOL] [EOL] class TestPostgresTypes ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_nested_types ( self ) : [EOL] result = self . run_dbt ( [ [string] , [string] ] ) [EOL] self . assertTrue ( result . success ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] import dbt . exceptions [EOL] import pytest [EOL] [EOL] [EOL] class TestMacros ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } , ] } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : [string] , } , } , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_working_macros ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [EOL] class TestInvalidMacros ( DBTIntegrationTest ) : [EOL] [EOL] def setUp ( self ) : [EOL] DBTIntegrationTest . setUp ( self ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_invalid_macro ( self ) : [EOL] with pytest . raises ( RuntimeError ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] [EOL] class TestAdapterMacroNoDestination ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_invalid_macro ( self ) : [EOL] with pytest . raises ( dbt . exceptions . CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] [EOL] class TestMacroOverrideBuiltin ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_overrides ( self ) : [EOL] [comment] [EOL] self . run_dbt ( ) [EOL] self . run_dbt ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import unittest [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import hashlib [EOL] import os [EOL] [EOL] from unittest . mock import call , ANY , patch [EOL] [EOL] import dbt . exceptions [EOL] import dbt . version [EOL] import dbt . tracking [EOL] import dbt . utils [EOL] [EOL] [EOL] class TestEventTracking ( DBTIntegrationTest ) : [EOL] maxDiff = None [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : { [string] : True } } [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return path . lstrip ( [string] ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ patch ( [string] ) def run_event_test ( self , cmd , expected_calls , expected_contexts , track_fn , expect_pass = True , expect_raise = False ) : [EOL] track_fn . reset_mock ( ) [EOL] [EOL] project_id = hashlib . md5 ( self . config . project_name . encode ( [string] ) ) . hexdigest ( ) [EOL] version = str ( dbt . version . get_installed_version ( ) ) [EOL] [EOL] if expect_raise : [EOL] with self . assertRaises ( BaseException ) : [EOL] self . run_dbt ( cmd , expect_pass = expect_pass ) [EOL] else : [EOL] self . run_dbt ( cmd , expect_pass = expect_pass ) [EOL] [EOL] user_id = dbt . tracking . active_user . id [EOL] invocation_id = dbt . tracking . active_user . invocation_id [EOL] [EOL] self . assertTrue ( len ( user_id ) > [number] ) [EOL] self . assertTrue ( len ( invocation_id ) > [number] ) [EOL] [EOL] track_fn . assert_has_calls ( expected_calls ) [EOL] [EOL] ordered_contexts = [ ] [EOL] [EOL] for ( args , kwargs ) in track_fn . call_args_list : [EOL] ordered_contexts . append ( [ context . __dict__ for context in kwargs [ [string] ] ] ) [EOL] [EOL] populated_contexts = [ ] [EOL] [EOL] for context in expected_contexts : [EOL] if callable ( context ) : [EOL] populated_contexts . append ( context ( project_id , user_id , invocation_id , version ) ) [EOL] else : [EOL] populated_contexts . append ( context ) [EOL] [EOL] self . assertEqual ( ordered_contexts , populated_contexts ) [EOL] [EOL] def build_context ( self , command , progress , result_type = None , adapter_type = [string] ) : [EOL] [EOL] def populate ( project_id , user_id , invocation_id , version ) : [EOL] return [ { [string] : [string] , [string] : { [string] : project_id , [string] : user_id , [string] : invocation_id , [string] : version , [string] : command , [string] : progress , [string] : [string] , [string] : None , [string] : result_type , [string] : None , [string] : adapter_type } } , { [string] : [string] , [string] : ANY } , { [string] : [string] , [string] : ANY } ] [EOL] [EOL] return populate [EOL] [EOL] def run_context ( self , materialization , hashed_contents , model_id , index , total , status , error = None ) : [EOL] timing = [ ] [EOL] [EOL] if status != [string] : [EOL] timing = [ ANY , ANY ] [EOL] [EOL] def populate ( project_id , user_id , invocation_id , version ) : [EOL] return [ { [string] : [string] , [string] : { [string] : invocation_id , [string] : materialization , [string] : ANY , [string] : hashed_contents , [string] : model_id , [string] : index , [string] : total , [string] : status , [string] : error , [string] : False , [string] : timing , } , } ] [EOL] [EOL] return populate [EOL] [EOL] [EOL] class TestEventTrackingSuccess ( TestEventTracking ) : [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } , ] , } [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . dir ( [string] ) ] , [string] : [ self . dir ( [string] ) ] , [string] : { [string] : False , } } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_compile ( self ) : [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] , [string] , [string] ] , expected_calls , expected_contexts ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_deps ( self ) : [EOL] package_context = [ { [string] : [string] , [string] : { [string] : [string] , [string] : ANY , [string] : ANY , [string] : ANY , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] } } , { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } } ] [EOL] [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = ANY , property_ = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , package_context , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] ] , expected_calls , expected_contexts ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_seed ( self ) : [EOL] def seed_context ( project_id , user_id , invocation_id , version ) : [EOL] return [ { [string] : [string] , [string] : { [string] : invocation_id , [string] : [string] , [string] : ANY , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : None , [string] : False , [string] : [ ANY , ANY ] , } , } ] [EOL] [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = ANY , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , seed_context , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] ] , expected_calls , expected_contexts ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_models ( self ) : [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = ANY , context = ANY ) , call ( category = [string] , action = [string] , label = ANY , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] hashed = [string] [EOL] [comment] [EOL] [comment] [EOL] if os . name == [string] : [EOL] hashed = [string] [EOL] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , self . run_context ( hashed_contents = [string] , model_id = [string] , index = [number] , total = [number] , status = [string] , materialization = [string] ) , self . run_context ( hashed_contents = hashed , model_id = [string] , index = [number] , total = [number] , status = [string] , materialization = [string] ) , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] , [string] , [string] , [string] ] , expected_calls , expected_contexts ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_model_error ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = ANY , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , self . run_context ( hashed_contents = [string] , model_id = [string] , index = [number] , total = [number] , status = [string] , materialization = [string] ) , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] , [string] , [string] ] , expected_calls , expected_contexts , expect_pass = False ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_tests ( self ) : [EOL] [comment] [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] ] , expected_calls , expected_contexts , expect_pass = False ) [EOL] [EOL] [EOL] class TestEventTrackingCompilationError ( TestEventTracking ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . dir ( [string] ) ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_with_compilation_error ( self ) : [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] ] , expected_calls , expected_contexts , expect_pass = False , expect_raise = True ) [EOL] [EOL] [EOL] class TestEventTrackingUnableToConnect ( TestEventTracking ) : [EOL] [EOL] @ property def profile_config ( self ) : [EOL] return { [string] : { [string] : True } , [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } , [string] : { [string] : [string] , [string] : [number] , [string] : self . database_host , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . unique_schema ( ) } } , [string] : [string] } } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_unable_to_connect ( self ) : [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] , [string] , [string] , [string] , [string] ] , expected_calls , expected_contexts , expect_pass = False ) [EOL] [EOL] [EOL] class TestEventTrackingSnapshot ( TestEventTracking ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_snapshot ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = ANY , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] [comment] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , self . run_context ( hashed_contents = ANY , model_id = [string] , index = [number] , total = [number] , status = [string] , materialization = [string] ) , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] ] , expected_calls , expected_contexts ) [EOL] [EOL] [EOL] class TestEventTrackingCatalogGenerate ( TestEventTracking ) : [EOL] @ use_profile ( [string] ) def test__postgres_event_tracking_catalog_generate ( self ) : [EOL] [comment] [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] [EOL] expected_calls = [ call ( category = [string] , action = [string] , label = [string] , context = ANY ) , call ( category = [string] , action = [string] , label = [string] , context = ANY ) , ] [EOL] [EOL] expected_contexts = [ self . build_context ( [string] , [string] ) , self . build_context ( [string] , [string] , result_type = [string] ) ] [EOL] [EOL] self . run_event_test ( [ [string] , [string] ] , expected_calls , expected_contexts ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 $typing.List[typing.Any]$ 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestRefOverride ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : False , } , } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_ref_override ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [comment] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] [EOL] [EOL] class TestModelWarehouse ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( value ) : [EOL] return os . path . normpath ( value ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_override_ok ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] , ] ) [EOL] self . assertManyRelationsEqual ( [ [ [string] ] , [ [string] ] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_override_noexist ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] ] , expect_pass = False ) [EOL] [EOL] [EOL] class TestConfigWarehouse ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : os . getenv ( [string] , [string] ) , } , } , } [EOL] [EOL] @ staticmethod def dir ( value ) : [EOL] return os . path . normpath ( value ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_override_ok ( self ) : [EOL] self . run_dbt ( [ [string] , [string] , [string] , [string] , ] ) [EOL] self . assertManyRelationsEqual ( [ [ [string] ] , [ [string] ] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import yaml [EOL] [EOL] [EOL] class TestAlterColumnTypes ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] def run_and_alter_and_test ( self , alter_column_type_args ) : [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] ] ) ) , [number] ) [EOL] self . run_dbt ( [ [string] , [string] , [string] , alter_column_type_args ] ) [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] ] ) ) , [number] ) [EOL] [EOL] [EOL] class TestBigQueryAlterColumnTypes ( TestAlterColumnTypes ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_column_types ( self ) : [EOL] alter_column_type_args = yaml . safe_dump ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] self . run_and_alter_and_test ( alter_column_type_args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestColumnTypes ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] def run_and_test ( self ) : [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] ] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] ] ) ) , [number] ) [EOL] [EOL] [EOL] class TestPostgresColumnTypes ( TestColumnTypes ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_column_types ( self ) : [EOL] self . run_and_test ( ) [EOL] [EOL] [EOL] class TestRedshiftColumnTypes ( TestColumnTypes ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_column_types ( self ) : [EOL] self . run_and_test ( ) [EOL] [EOL] [EOL] class TestSnowflakeColumnTypes ( TestColumnTypes ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_column_types ( self ) : [EOL] self . run_and_test ( ) [EOL] [EOL] [EOL] class TestBigQueryColumnTypes ( TestColumnTypes ) : [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_column_types ( self ) : [EOL] self . run_and_test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import yaml [EOL] [EOL] [EOL] class TestBaseCaching ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_adapter_methods ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [comment] [EOL] self . run_dbt ( ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_redshift_adapter_methods ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [comment] [EOL] self . run_dbt ( ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_adapter_methods ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [comment] [EOL] self . run_dbt ( ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_adapter_methods ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [comment] [EOL] self . run_dbt ( ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [EOL] class TestRenameRelation ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] } [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_adapter_methods ( self ) : [EOL] self . run_dbt ( [ [string] ] ) [comment] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] rename_relation_args = yaml . safe_dump ( { [string] : [string] , [string] : [string] , } ) [EOL] self . run_dbt ( [ [string] , [string] , [string] , rename_relation_args ] ) [EOL] self . run_dbt ( ) [EOL] [EOL] [EOL] class TestGrantAccess ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] } [EOL] [EOL] @ use_profile ( [string] ) def test_bigquery_adapter_methods ( self ) : [EOL] from dbt . adapters . bigquery import GrantTarget [EOL] from google . cloud . bigquery import AccessEntry [EOL] [EOL] self . run_dbt ( [ [string] ] ) [comment] [EOL] self . run_sql_file ( [string] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] ae_role = [string] [EOL] ae_entity = [string] [EOL] ae_entity_type = [string] [EOL] ae_grant_target_dict = { [string] : self . default_database , [string] : self . unique_schema ( ) } [EOL] self . adapter . grant_access_to ( ae_entity , ae_entity_type , ae_role , ae_grant_target_dict ) [EOL] [EOL] conn = self . adapter . connections . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] grant_target = GrantTarget . from_dict ( ae_grant_target_dict ) [EOL] dataset = client . get_dataset ( self . adapter . connections . dataset_from_id ( grant_target . render ( ) ) ) [EOL] [EOL] expected_access_entry = AccessEntry ( ae_role , ae_entity_type , ae_entity ) [EOL] self . assertTrue ( expected_access_entry in dataset . access_entries ) [EOL] [EOL] unexpected_access_entry = AccessEntry ( ae_role , ae_entity_type , [string] ) [EOL] self . assertFalse ( unexpected_access_entry in dataset . access_entries ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0
from typing import Dict , Any , List , Set [EOL] import typing [EOL] import socket [EOL] import json [EOL] import os [EOL] import random [EOL] import shutil [EOL] import signal [EOL] import socket [EOL] import sys [EOL] import time [EOL] from base64 import standard_b64encode as b64 [EOL] from datetime import datetime [EOL] [EOL] import requests [EOL] from pytest import mark [EOL] [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import dbt . flags [EOL] from dbt . version import __version__ [EOL] from dbt . logger import log_manager [EOL] from dbt . main import handle_and_check [EOL] [EOL] [EOL] class ServerProcess ( dbt . flags . MP_CONTEXT . Process ) : [EOL] def __init__ ( self , port , profiles_dir , cli_vars = None ) : [EOL] self . port = port [EOL] handle_and_check_args = [ [string] , [string] , [string] , str ( self . port ) , [string] , profiles_dir ] [EOL] if cli_vars : [EOL] handle_and_check_args . extend ( [ [string] , cli_vars ] ) [EOL] super ( ) . __init__ ( target = handle_and_check , args = ( handle_and_check_args , ) , name = [string] ) [EOL] [EOL] def run ( self ) : [EOL] log_manager . reset_handlers ( ) [EOL] [comment] [EOL] log_manager . stderr_console ( ) [EOL] return super ( ) . run ( ) [EOL] [EOL] def can_connect ( self ) : [EOL] sock = socket . socket ( ) [EOL] try : [EOL] sock . connect ( ( [string] , self . port ) ) [EOL] except socket . error : [EOL] return False [EOL] sock . close ( ) [EOL] return True [EOL] [EOL] def _compare_result ( self , result ) : [EOL] return result [ [string] ] [ [string] ] == [string] [EOL] [EOL] def status_ok ( self ) : [EOL] result = query_url ( [string] . format ( self . port ) , { [string] : [string] , [string] : [number] , [string] : [string] } ) . json ( ) [EOL] return self . _compare_result ( result ) [EOL] [EOL] def is_up ( self ) : [EOL] if not self . can_connect ( ) : [EOL] return False [EOL] return self . status_ok ( ) [EOL] [EOL] def start ( self ) : [EOL] super ( ) . start ( ) [EOL] for _ in range ( [number] ) : [EOL] if self . is_up ( ) : [EOL] break [EOL] time . sleep ( [number] ) [EOL] if not self . can_connect ( ) : [EOL] raise Exception ( [string] ) [EOL] status_result = query_url ( [string] . format ( self . port ) , { [string] : [string] , [string] : [number] , [string] : [string] } ) . json ( ) [EOL] if not self . _compare_result ( status_result ) : [EOL] raise Exception ( [string] . format ( status_result ) ) [EOL] [EOL] [EOL] def query_url ( url , query ) : [EOL] headers = { [string] : [string] } [EOL] return requests . post ( url , headers = headers , data = json . dumps ( query ) ) [EOL] [EOL] [EOL] _select_from_ephemeral = [string] [EOL] [EOL] [EOL] def addr_in_use ( err , * args ) : [EOL] msg = str ( err ) [EOL] if [string] in msg : [EOL] return True [EOL] if [string] in msg : [EOL] return True [comment] [EOL] return False [EOL] [EOL] [EOL] @ mark . skipif ( os . name == [string] , reason = [string] ) class HasRPCServer ( DBTIntegrationTest ) : [EOL] ServerProcess = ServerProcess [EOL] should_seed = True [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] os . environ [ [string] ] = [string] [EOL] if self . should_seed : [EOL] self . run_dbt_with_vars ( [ [string] ] , strict = False ) [EOL] port = random . randint ( [number] , [number] ) [EOL] self . _server = self . ServerProcess ( cli_vars = [string] . format ( self . unique_schema ( ) ) , profiles_dir = self . test_root_dir , port = port ) [EOL] self . _server . start ( ) [EOL] self . background_queries = [ ] [EOL] [EOL] def tearDown ( self ) : [EOL] del os . environ [ [string] ] [EOL] self . _server . terminate ( ) [EOL] for query in self . background_queries : [EOL] query . terminate ( ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_dbt_with_vars ( self , cmd , * args , ** kwargs ) : [EOL] cmd . extend ( [ [string] , [string] . format ( self . unique_schema ( ) ) ] ) [EOL] return self . run_dbt ( cmd , * args , ** kwargs ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : True , [string] : True , [string] : True } , [string] : [ [string] ] , [string] : { [string] : False , } , } [EOL] [EOL] def build_query ( self , method , kwargs , sql = None , test_request_id = [number] , macros = None ) : [EOL] body_data = [string] [EOL] if sql is not None : [EOL] body_data += sql [EOL] [EOL] if macros is not None : [EOL] body_data += macros [EOL] [EOL] if sql is not None or macros is not None : [EOL] kwargs [ [string] ] = b64 ( body_data . encode ( [string] ) ) . decode ( [string] ) [EOL] [EOL] return { [string] : [string] , [string] : method , [string] : kwargs , [string] : test_request_id } [EOL] [EOL] @ property def url ( self ) : [EOL] return [string] . format ( self . _server . port ) [EOL] [EOL] def poll_for_result ( self , request_token , request_id = [number] , timeout = [number] , state = [string] , logs = None ) : [EOL] start = time . time ( ) [EOL] kwargs = { [string] : request_token , } [EOL] if logs is not None : [EOL] kwargs [ [string] ] = logs [EOL] [EOL] while True : [EOL] time . sleep ( [number] ) [EOL] response = self . query ( [string] , _test_request_id = request_id , ** kwargs ) [EOL] response_json = response . json ( ) [EOL] if [string] in response_json : [EOL] return response [EOL] result = self . assertIsResult ( response_json , request_id ) [EOL] self . assertIn ( [string] , result ) [EOL] if result [ [string] ] == state : [EOL] return response [EOL] if timeout is not None : [EOL] delta = ( time . time ( ) - start ) [EOL] self . assertGreater ( timeout , delta , [string] . format ( delta , state , result ) ) [EOL] [EOL] def async_query ( self , _method , _sql = None , _test_request_id = [number] , _poll_timeout = [number] , macros = None , ** kwargs ) : [EOL] response = self . query ( _method , _sql , _test_request_id , macros , ** kwargs ) . json ( ) [EOL] result = self . assertIsResult ( response , _test_request_id ) [EOL] self . assertIn ( [string] , result ) [EOL] return self . poll_for_result ( result [ [string] ] , request_id = _test_request_id , timeout = _poll_timeout , ) [EOL] [EOL] def query ( self , _method , _sql = None , _test_request_id = [number] , macros = None , ** kwargs ) : [EOL] built = self . build_query ( _method , kwargs , _sql , _test_request_id , macros ) [EOL] return query_url ( self . url , built ) [EOL] [EOL] def handle_result ( self , bg_query , pipe ) : [EOL] result_type , result = pipe . recv ( ) [EOL] bg_query . join ( ) [EOL] if result_type == [string] : [EOL] raise result [EOL] else : [EOL] return result [EOL] [EOL] def assertResultHasTimings ( self , result , * names ) : [EOL] self . assertIn ( [string] , result ) [EOL] timings = result [ [string] ] [EOL] self . assertEqual ( len ( timings ) , len ( names ) ) [EOL] for expected_name , timing in zip ( names , timings ) : [EOL] self . assertIn ( [string] , timing ) [EOL] self . assertEqual ( timing [ [string] ] , expected_name ) [EOL] self . assertIn ( [string] , timing ) [EOL] self . assertIn ( [string] , timing ) [EOL] datetime . strptime ( timing [ [string] ] , [string] ) [EOL] datetime . strptime ( timing [ [string] ] , [string] ) [EOL] [EOL] def assertIsResult ( self , data , id_ = [number] ) : [EOL] self . assertEqual ( data [ [string] ] , id_ ) [EOL] self . assertEqual ( data [ [string] ] , [string] ) [EOL] self . assertIn ( [string] , data ) [EOL] self . assertNotIn ( [string] , data ) [EOL] return data [ [string] ] [EOL] [EOL] def assertIsError ( self , data , id_ = [number] ) : [EOL] self . assertEqual ( data [ [string] ] , id_ ) [EOL] self . assertEqual ( data [ [string] ] , [string] ) [EOL] self . assertIn ( [string] , data ) [EOL] self . assertNotIn ( [string] , data ) [EOL] return data [ [string] ] [EOL] [EOL] def assertIsErrorWithCode ( self , data , code , id_ = [number] ) : [EOL] error = self . assertIsError ( data , id_ ) [EOL] self . assertIn ( [string] , error ) [EOL] self . assertIn ( [string] , error ) [EOL] self . assertEqual ( error [ [string] ] , code ) [EOL] return error [EOL] [EOL] def assertIsErrorWith ( self , data , code , message , error_data ) : [EOL] error = self . assertIsErrorWithCode ( data , code ) [EOL] if message is not None : [EOL] self . assertEqual ( error [ [string] ] , message ) [EOL] [EOL] if error_data is not None : [EOL] return self . assertHasErrorData ( error , error_data ) [EOL] else : [EOL] return error . get ( [string] ) [EOL] [EOL] def assertResultHasSql ( self , data , raw_sql , compiled_sql = None ) : [EOL] if compiled_sql is None : [EOL] compiled_sql = raw_sql [EOL] result = self . assertIsResult ( data ) [EOL] self . assertIn ( [string] , result ) [EOL] self . assertTrue ( len ( result [ [string] ] ) > [number] ) [EOL] self . assertIn ( [string] , result ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] result = result [ [string] ] [ [number] ] [EOL] self . assertIn ( [string] , result ) [EOL] self . assertIn ( [string] , result ) [EOL] self . assertEqual ( result [ [string] ] , raw_sql ) [EOL] self . assertEqual ( result [ [string] ] , compiled_sql ) [EOL] return result [EOL] [EOL] def assertSuccessfulCompilationResult ( self , data , raw_sql , compiled_sql = None ) : [EOL] result = self . assertResultHasSql ( data , raw_sql , compiled_sql ) [EOL] self . assertNotIn ( [string] , result ) [EOL] [comment] [EOL] [comment] [EOL] self . assertResultHasTimings ( result , [string] , [string] ) [EOL] [EOL] def assertSuccessfulRunResult ( self , data , raw_sql , compiled_sql = None , table = None ) : [EOL] result = self . assertResultHasSql ( data , raw_sql , compiled_sql ) [EOL] self . assertIn ( [string] , result ) [EOL] if table is not None : [EOL] self . assertEqual ( result [ [string] ] , table ) [EOL] self . assertResultHasTimings ( result , [string] , [string] ) [EOL] [EOL] def assertHasErrorData ( self , error , expected_error_data ) : [EOL] self . assertIn ( [string] , error ) [EOL] error_data = error [ [string] ] [EOL] for key , value in expected_error_data . items ( ) : [EOL] self . assertIn ( key , error_data ) [EOL] self . assertEqual ( error_data [ key ] , value ) [EOL] return error_data [EOL] [EOL] def assertRunning ( self , sleepers ) : [EOL] sleeper_ps_result = self . query ( [string] , completed = False , active = True ) . json ( ) [EOL] result = self . assertIsResult ( sleeper_ps_result ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , len ( sleepers ) ) [EOL] result_map = { rd [ [string] ] : rd for rd in result [ [string] ] } [EOL] for _ , request_id in sleepers : [EOL] found = result_map [ request_id ] [EOL] self . assertEqual ( found [ [string] ] , request_id ) [EOL] self . assertEqual ( found [ [string] ] , [string] ) [EOL] self . assertEqual ( found [ [string] ] , [string] ) [EOL] self . assertEqual ( found [ [string] ] , None ) [EOL] [EOL] def kill_and_assert ( self , request_token , request_id ) : [EOL] kill_response = self . query ( [string] , task_id = request_token ) . json ( ) [EOL] result = self . assertIsResult ( kill_response ) [EOL] self . assertEqual ( result [ [string] ] , [string] ) [EOL] [EOL] poll_id = [number] [EOL] [EOL] poll_response = self . poll_for_result ( request_token , request_id = poll_id , state = [string] , logs = True ) . json ( ) [EOL] [EOL] result = self . assertIsResult ( poll_response , id_ = poll_id ) [EOL] self . assertIn ( [string] , result ) [EOL] return result [EOL] [EOL] def get_sleep_query ( self , duration = [number] , request_id = [number] ) : [EOL] sleep_query = self . query ( [string] , [string] . format ( duration ) , name = [string] , _test_request_id = request_id ) . json ( ) [EOL] result = self . assertIsResult ( sleep_query , id_ = request_id ) [EOL] self . assertIn ( [string] , result ) [EOL] request_token = result [ [string] ] [EOL] return request_token , request_id [EOL] [EOL] def wait_for_state ( self , state , timestamp , timeout = [number] , raise_on_timeout = True ) : [EOL] started = time . time ( ) [EOL] time . sleep ( [number] ) [EOL] elapsed = time . time ( ) - started [EOL] [EOL] while elapsed < timeout : [EOL] status = self . assertIsResult ( self . query ( [string] ) . json ( ) ) [EOL] self . assertTrue ( status [ [string] ] >= timestamp ) [EOL] if status [ [string] ] != timestamp and status [ [string] ] == state : [EOL] return status [EOL] time . sleep ( [number] ) [EOL] elapsed = time . time ( ) - started [EOL] [EOL] status = self . assertIsResult ( self . query ( [string] ) . json ( ) ) [EOL] self . assertTrue ( status [ [string] ] >= timestamp ) [EOL] if raise_on_timeout : [EOL] self . assertEqual ( status [ [string] ] , state , f' [string] { timeout } [string] { elapsed } [string] ' ) [EOL] return status [EOL] [EOL] def run_command_with_id ( self , cmd , id_ ) : [EOL] self . assertIsResult ( self . async_query ( cmd , _test_request_id = id_ ) . json ( ) , id_ ) [EOL] [EOL] def make_many_requests ( self , num_requests ) : [EOL] stored = [ ] [EOL] for idx in range ( [number] , num_requests + [number] ) : [EOL] response = self . query ( [string] , [string] , name = [string] , _test_request_id = idx ) . json ( ) [EOL] result = self . assertIsResult ( response , id_ = idx ) [EOL] self . assertIn ( [string] , result ) [EOL] token = result [ [string] ] [EOL] self . poll_for_result ( token ) [EOL] stored . append ( token ) [EOL] return stored [EOL] [EOL] [EOL] @ mark . flaky ( rerun_filter = addr_in_use ) class TestRPCServerCompileRun ( HasRPCServer ) : [EOL] @ use_profile ( [string] ) def test_compile_sql_postgres ( self ) : [EOL] trivial = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulCompilationResult ( trivial , [string] ) [EOL] [EOL] ref = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulCompilationResult ( ref , [string] , compiled_sql = [string] . format ( self . default_database , self . unique_schema ( ) ) ) [EOL] [EOL] source = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulCompilationResult ( source , [string] , compiled_sql = [string] . format ( self . default_database , self . unique_schema ( ) ) ) [EOL] [EOL] macro = self . async_query ( [string] , [string] , name = [string] , macros = [string] ) . json ( ) [EOL] self . assertSuccessfulCompilationResult ( macro , [string] , compiled_sql = [string] ) [EOL] [EOL] macro_override = self . async_query ( [string] , [string] , name = [string] , macros = [string] ) . json ( ) [EOL] self . assertSuccessfulCompilationResult ( macro_override , [string] , compiled_sql = [string] ) [EOL] [EOL] macro_override_with_if_statement = self . async_query ( [string] , [string] , name = [string] , macros = [string] ) . json ( ) [EOL] self . assertSuccessfulCompilationResult ( macro_override_with_if_statement , [string] , compiled_sql = [string] ) [EOL] [EOL] ephemeral = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulCompilationResult ( ephemeral , [string] , compiled_sql = _select_from_ephemeral ) [EOL] [EOL] @ use_profile ( [string] ) def test_run_sql_postgres ( self ) : [EOL] [comment] [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] data = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulRunResult ( data , [string] , table = { [string] : [ [string] ] , [string] : [ [ [number] ] ] } ) [EOL] [EOL] ref = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulRunResult ( ref , [string] , compiled_sql = [string] . format ( self . default_database , self . unique_schema ( ) ) , table = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] ] , [string] : [ [ [string] , [number] , [string] , [string] , [string] , [string] ] ] , } ) [EOL] [EOL] source = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulRunResult ( source , [string] , compiled_sql = [string] . format ( self . default_database , self . unique_schema ( ) ) , table = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] ] , [string] : [ [ [string] , [number] , [string] , [string] , [string] , [string] ] ] , } ) [EOL] [EOL] macro = self . async_query ( [string] , [string] , name = [string] , macros = [string] ) . json ( ) [EOL] self . assertSuccessfulRunResult ( macro , raw_sql = [string] , compiled_sql = [string] , table = { [string] : [ [string] ] , [string] : [ [ [number] ] ] } ) [EOL] [EOL] macro_override = self . async_query ( [string] , [string] , name = [string] , macros = [string] ) . json ( ) [EOL] self . assertSuccessfulRunResult ( macro_override , raw_sql = [string] , compiled_sql = [string] , table = { [string] : [ [string] ] , [string] : [ [ [number] ] ] } ) [EOL] [EOL] macro_override_with_if_statement = self . async_query ( [string] , [string] , name = [string] , macros = [string] ) . json ( ) [EOL] self . assertSuccessfulRunResult ( macro_override_with_if_statement , [string] , compiled_sql = [string] , table = { [string] : [ [string] ] , [string] : [ [ [number] ] ] } ) [EOL] [EOL] macro_with_raw_statement = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulRunResult ( macro_with_raw_statement , [string] , compiled_sql = [string] , table = { [string] : [ [string] ] , [string] : [ [ [number] ] ] } ) [EOL] [EOL] macro_with_comment = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulRunResult ( macro_with_comment , [string] , compiled_sql = [string] , table = { [string] : [ [string] ] , [string] : [ [ [number] ] ] } ) [EOL] [EOL] ephemeral = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertSuccessfulRunResult ( ephemeral , raw_sql = [string] , compiled_sql = _select_from_ephemeral , table = { [string] : [ [string] ] , [string] : [ [ [number] ] ] } ) [EOL] [EOL] @ mark . flaky ( rerun_filter = None ) @ use_profile ( [string] ) def test_ps_kill_postgres ( self ) : [EOL] task_tags = { [string] : __version__ , [string] : True , } [EOL] done_query = self . async_query ( [string] , [string] , name = [string] , task_tags = task_tags ) . json ( ) [EOL] done_result = self . assertIsResult ( done_query ) [EOL] self . assertIn ( [string] , done_result ) [EOL] self . assertEqual ( done_result [ [string] ] , task_tags ) [EOL] [EOL] request_token , request_id = self . get_sleep_query ( ) [EOL] [EOL] empty_ps_result = self . query ( [string] , completed = False , active = False ) . json ( ) [EOL] result = self . assertIsResult ( empty_ps_result ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] [EOL] sleeper_ps_result = self . query ( [string] , completed = False , active = True ) . json ( ) [EOL] result = self . assertIsResult ( sleeper_ps_result ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] rowdict = result [ [string] ] [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , request_id ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertIsNone ( rowdict [ [number] ] [ [string] ] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , request_token ) [EOL] self . assertGreater ( rowdict [ [number] ] [ [string] ] , [number] ) [EOL] self . assertIsNone ( rowdict [ [number] ] [ [string] ] ) [EOL] [EOL] complete_ps_result = self . query ( [string] , completed = True , active = False ) . json ( ) [EOL] result = self . assertIsResult ( complete_ps_result ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] rowdict = result [ [string] ] [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertIsNone ( rowdict [ [number] ] [ [string] ] ) [EOL] self . assertGreater ( rowdict [ [number] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , task_tags ) [EOL] [EOL] all_ps_result = self . query ( [string] , completed = True , active = True ) . json ( ) [EOL] result = self . assertIsResult ( all_ps_result ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] rowdict = result [ [string] ] [EOL] rowdict . sort ( key = lambda r : r [ [string] ] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertIsNone ( rowdict [ [number] ] [ [string] ] ) [EOL] self . assertGreater ( rowdict [ [number] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , task_tags ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , request_id ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertIsNone ( rowdict [ [number] ] [ [string] ] ) [EOL] self . assertGreater ( rowdict [ [number] ] [ [string] ] , [number] ) [EOL] self . assertIsNone ( rowdict [ [number] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] gc_response = self . query ( [string] , task_ids = [ request_token ] ) . json ( ) [EOL] gc_result = self . assertIsResult ( gc_response ) [EOL] self . assertIn ( [string] , gc_result ) [EOL] self . assertEqual ( gc_result [ [string] ] , [ request_token ] ) [EOL] [EOL] self . kill_and_assert ( request_token , request_id ) [EOL] [EOL] all_ps_result = self . query ( [string] , completed = True , active = True ) . json ( ) [EOL] result = self . assertIsResult ( all_ps_result ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] rowdict = result [ [string] ] [EOL] rowdict . sort ( key = lambda r : r [ [string] ] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertIsNone ( rowdict [ [number] ] [ [string] ] ) [EOL] self . assertGreater ( rowdict [ [number] ] [ [string] ] , [number] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , task_tags ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , request_id ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( rowdict [ [number] ] [ [string] ] , [string] ) [EOL] self . assertIsNone ( rowdict [ [number] ] [ [string] ] ) [EOL] self . assertGreater ( rowdict [ [number] ] [ [string] ] , [number] ) [EOL] self . assertIsNone ( rowdict [ [number] ] [ [string] ] ) [EOL] [EOL] @ mark . flaky ( rerun_filter = lambda * a , ** kw : True ) @ use_profile ( [string] ) def test_ps_kill_longwait_postgres ( self ) : [EOL] request_token , request_id = self . get_sleep_query ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] result_data = self . kill_and_assert ( request_token , request_id ) [EOL] self . assertTrue ( len ( result_data [ [string] ] ) > [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_invalid_requests_postgres ( self ) : [EOL] [comment] [EOL] data = self . query ( [string] , [string] ) . json ( ) [EOL] self . assertIsErrorWith ( data , - [number] , [string] , None ) [EOL] [EOL] data = self . async_query ( [string] , [string] , name = [string] , task_tags = { [string] : True , [string] : [string] } ) . json ( ) [EOL] error_data = self . assertIsErrorWith ( data , [number] , [string] , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : { [string] : True , [string] : [string] } } ) [EOL] self . assertIn ( [string] , error_data ) [EOL] self . assertTrue ( len ( error_data [ [string] ] ) > [number] ) [EOL] [EOL] data = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] [comment] [EOL] [comment] [EOL] lineno = [string] [EOL] error_data = self . assertIsErrorWith ( data , [number] , [string] , { [string] : [string] , [string] : f' [string] { lineno } [string] ' , [string] : [string] , [string] : [string] , } ) [EOL] self . assertIn ( [string] , error_data ) [EOL] self . assertTrue ( len ( error_data [ [string] ] ) > [number] ) [EOL] [EOL] macro_no_override = self . async_query ( [string] , [string] , name = [string] , ) . json ( ) [EOL] error_data = self . assertIsErrorWith ( macro_no_override , [number] , [string] , { [string] : [string] , [string] : [string] , [string] : None } ) [EOL] self . assertIn ( [string] , error_data ) [EOL] self . assertTrue ( len ( error_data [ [string] ] ) > [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_timeout_postgres ( self ) : [EOL] data = self . async_query ( [string] , [string] , name = [string] , timeout = [number] ) . json ( ) [EOL] error = self . assertIsErrorWithCode ( data , [number] ) [EOL] self . assertEqual ( error [ [string] ] , [string] ) [EOL] self . assertIn ( [string] , error ) [EOL] error_data = error [ [string] ] [EOL] self . assertIn ( [string] , error_data ) [EOL] self . assertEqual ( error_data [ [string] ] , [number] ) [EOL] self . assertIn ( [string] , error_data ) [EOL] self . assertEqual ( error_data [ [string] ] , [string] ) [EOL] self . assertIn ( [string] , error_data ) [EOL] [comment] [EOL] [comment] [EOL] return [EOL] [EOL] [EOL] @ mark . flaky ( rerun_filter = addr_in_use ) class TestRPCServerProjects ( HasRPCServer ) : [EOL] def assertHasResults ( self , result , expected , * , missing = None , num_expected = None ) : [EOL] dct = self . assertIsResult ( result ) [EOL] self . assertIn ( [string] , dct ) [EOL] results = dct [ [string] ] [EOL] [EOL] if num_expected is None : [EOL] num_expected = len ( expected ) [EOL] actual = { r [ [string] ] [ [string] ] for r in results } [EOL] self . assertEqual ( len ( actual ) , num_expected ) [EOL] self . assertTrue ( expected . issubset ( actual ) ) [EOL] if missing : [EOL] for item in missing : [EOL] self . assertNotIn ( item , actual ) [EOL] [EOL] def correct_seed_result ( self , result ) : [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertHasResults ( result , { [string] , [string] , [string] , [string] } ) [EOL] [EOL] def assertHasTestResults ( self , results , expected , pass_results = None ) : [EOL] self . assertEqual ( len ( results ) , expected ) [EOL] [EOL] if pass_results is None : [EOL] pass_results = expected [EOL] [EOL] passes = [number] [EOL] for result in results : [EOL] [comment] [EOL] [comment] [EOL] self . assertIn ( [string] , result ) [EOL] if result [ [string] ] == [number] : [EOL] self . assertIsNone ( result [ [string] ] ) [EOL] passes += [number] [EOL] else : [EOL] self . assertTrue ( result [ [string] ] ) [EOL] self . assertEqual ( passes , pass_results ) [EOL] [EOL] @ use_profile ( [string] ) def test_seed_project_postgres ( self ) : [EOL] [comment] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] result = self . async_query ( [string] , show = True ) . json ( ) [EOL] self . correct_seed_result ( result ) [EOL] [EOL] result = self . async_query ( [string] , show = False ) . json ( ) [EOL] self . correct_seed_result ( result ) [EOL] [EOL] @ use_profile ( [string] ) def test_seed_project_cli_postgres ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] result = self . async_query ( [string] , cli = [string] ) . json ( ) [EOL] self . correct_seed_result ( result ) [EOL] result = self . async_query ( [string] , cli = [string] ) . json ( ) [EOL] self . correct_seed_result ( result ) [EOL] [EOL] @ use_profile ( [string] ) def test_compile_project_postgres ( self ) : [EOL] [EOL] result = self . async_query ( [string] ) . json ( ) [EOL] self . assertHasResults ( result , { [string] , [string] , [string] } , missing = [ [string] ] , num_expected = [number] , ) [EOL] [EOL] result = self . async_query ( [string] , models = [ [string] ] ) . json ( ) [EOL] self . assertHasResults ( result , { [string] , [string] } , missing = [ [string] , [string] ] , num_expected = [number] , ) [EOL] [EOL] @ use_profile ( [string] ) def test_compile_project_cli_postgres ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] result = self . async_query ( [string] , cli = [string] ) . json ( ) [EOL] self . assertHasResults ( result , { [string] , [string] , [string] } , missing = [ [string] ] , num_expected = [number] , ) [EOL] [EOL] result = self . async_query ( [string] , cli = [string] ) . json ( ) [EOL] self . assertHasResults ( result , { [string] , [string] } , missing = [ [string] , [string] ] , num_expected = [number] , ) [EOL] [EOL] @ use_profile ( [string] ) def test_run_project_postgres ( self ) : [EOL] result = self . async_query ( [string] ) . json ( ) [EOL] self . assertHasResults ( result , { [string] , [string] , [string] } ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_run_project_cli_postgres ( self ) : [EOL] result = self . async_query ( [string] , cli = [string] ) . json ( ) [EOL] self . assertHasResults ( result , { [string] , [string] , [string] } ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_test_project_postgres ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] data = self . async_query ( [string] ) . json ( ) [EOL] result = self . assertIsResult ( data ) [EOL] self . assertIn ( [string] , result ) [EOL] self . assertHasTestResults ( result [ [string] ] , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_test_project_cli_postgres ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] data = self . async_query ( [string] , cli = [string] ) . json ( ) [EOL] result = self . assertIsResult ( data ) [EOL] self . assertIn ( [string] , result ) [EOL] self . assertHasTestResults ( result [ [string] ] , [number] ) [EOL] [EOL] def assertManifestExists ( self , nodes_length , sources_length ) : [EOL] self . assertTrue ( os . path . exists ( [string] ) ) [EOL] with open ( [string] ) as fp : [EOL] manifest = json . load ( fp ) [EOL] self . assertIn ( [string] , manifest ) [EOL] self . assertEqual ( len ( manifest [ [string] ] ) , nodes_length ) [EOL] self . assertIn ( [string] , manifest ) [EOL] self . assertEqual ( len ( manifest [ [string] ] ) , sources_length ) [EOL] [EOL] def assertHasDocsGenerated ( self , result , expected ) : [EOL] dct = self . assertIsResult ( result ) [EOL] self . assertIn ( [string] , dct ) [EOL] self . assertTrue ( dct [ [string] ] ) [EOL] self . assertIn ( [string] , dct ) [EOL] nodes = dct [ [string] ] [EOL] self . assertEqual ( set ( nodes ) , expected [ [string] ] ) [EOL] self . assertIn ( [string] , dct ) [EOL] sources = dct [ [string] ] [EOL] self . assertEqual ( set ( sources ) , expected [ [string] ] ) [EOL] [EOL] def assertCatalogExists ( self ) : [EOL] self . assertTrue ( os . path . exists ( [string] ) ) [EOL] with open ( [string] ) as fp : [EOL] catalog = json . load ( fp ) [EOL] [EOL] def _correct_docs_generate_result ( self , result ) : [EOL] expected = { [string] : { [string] , [string] , [string] , [string] , [string] , [string] , [string] , } , [string] : { [string] , [string] , [string] , } , } [EOL] self . assertHasDocsGenerated ( result , expected ) [EOL] self . assertCatalogExists ( ) [EOL] self . assertManifestExists ( [number] , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_docs_generate_postgres ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] self . assertFalse ( os . path . exists ( [string] ) ) [EOL] if os . path . exists ( [string] ) : [EOL] os . remove ( [string] ) [EOL] result = self . async_query ( [string] ) . json ( ) [EOL] self . _correct_docs_generate_result ( result ) [EOL] [EOL] @ use_profile ( [string] ) def test_docs_generate_postgres_cli ( self ) : [EOL] self . run_dbt_with_vars ( [ [string] ] ) [EOL] self . assertFalse ( os . path . exists ( [string] ) ) [EOL] if os . path . exists ( [string] ) : [EOL] os . remove ( [string] ) [EOL] result = self . async_query ( [string] , cli = [string] ) . json ( ) [EOL] self . _correct_docs_generate_result ( result ) [EOL] [EOL] @ use_profile ( [string] ) def test_deps_postgres ( self ) : [EOL] self . async_query ( [string] ) . json ( ) [EOL] [EOL] @ mark . skip ( reason = [string] ) @ use_profile ( [string] ) def test_deps_postgres_cli ( self ) : [EOL] self . async_query ( [string] , cli = [string] ) . json ( ) [EOL] [EOL] [EOL] @ mark . flaky ( rerun_filter = addr_in_use ) class TestRPCTaskManagement ( HasRPCServer ) : [EOL] [EOL] @ mark . flaky ( rerun_filter = lambda * a , ** kw : True ) @ use_profile ( [string] ) def test_sighup_postgres ( self ) : [EOL] status = self . assertIsResult ( self . query ( [string] ) . json ( ) ) [EOL] self . assertEqual ( status [ [string] ] , [string] ) [EOL] self . assertIn ( [string] , status ) [EOL] logs = status [ [string] ] [EOL] self . assertTrue ( len ( logs ) > [number] ) [EOL] for key in ( [string] , [string] , [string] , [string] ) : [EOL] self . assertIn ( key , logs [ [number] ] ) [EOL] [EOL] self . assertIn ( [string] , status ) [EOL] [EOL] done_query = self . async_query ( [string] , [string] , name = [string] ) . json ( ) [EOL] self . assertIsResult ( done_query ) [EOL] sleepers = [ ] [EOL] [EOL] sleepers . append ( self . get_sleep_query ( duration = [number] , request_id = [number] ) ) [EOL] self . assertRunning ( sleepers ) [EOL] [EOL] self . run_command_with_id ( [string] , [number] ) [EOL] self . run_command_with_id ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] for _ in range ( [number] ) : [EOL] os . kill ( status [ [string] ] , signal . SIGHUP ) [EOL] [EOL] self . wait_for_state ( [string] , timestamp = status [ [string] ] ) [EOL] [EOL] [comment] [EOL] self . assertRunning ( sleepers ) [EOL] [EOL] self . run_command_with_id ( [string] , [number] ) [EOL] self . run_command_with_id ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] sleepers . append ( self . get_sleep_query ( duration = [number] , request_id = [number] ) ) [EOL] [EOL] [comment] [EOL] self . assertRunning ( sleepers ) [EOL] [EOL] [comment] [EOL] dead , alive = sleepers [EOL] self . kill_and_assert ( * dead ) [EOL] self . assertRunning ( [ alive ] ) [EOL] self . kill_and_assert ( * alive ) [EOL] [EOL] @ use_profile ( [string] ) def test_gc_by_time_postgres ( self ) : [EOL] [comment] [EOL] num_requests = [number] [EOL] self . make_many_requests ( num_requests ) [EOL] [EOL] resp = self . query ( [string] , completed = True , active = True ) . json ( ) [EOL] result = self . assertIsResult ( resp ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , num_requests ) [EOL] [comment] [EOL] resp = self . query ( [string] , before = datetime . utcnow ( ) . isoformat ( ) ) . json ( ) [EOL] result = self . assertIsResult ( resp ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , num_requests ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] [comment] [EOL] resp = self . query ( [string] , completed = True , active = True ) . json ( ) [EOL] result = self . assertIsResult ( resp ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_gc_by_id_postgres ( self ) : [EOL] [comment] [EOL] num_requests = [number] [EOL] stored = self . make_many_requests ( num_requests ) [EOL] [EOL] resp = self . query ( [string] , completed = True , active = True ) . json ( ) [EOL] result = self . assertIsResult ( resp ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , num_requests ) [EOL] [EOL] resp = self . query ( [string] , task_ids = stored [ : num_requests // [number] ] ) . json ( ) [EOL] result = self . assertIsResult ( resp ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , num_requests // [number] ) [EOL] self . assertEqual ( sorted ( result [ [string] ] ) , sorted ( stored [ : num_requests // [number] ] ) ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] [comment] [EOL] resp = self . query ( [string] , completed = True , active = True ) . json ( ) [EOL] result = self . assertIsResult ( resp ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , ( num_requests - num_requests // [number] ) ) [EOL] [EOL] resp = self . query ( [string] , task_ids = stored [ num_requests // [number] : ] ) . json ( ) [EOL] result = self . assertIsResult ( resp ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , num_requests // [number] ) [EOL] self . assertEqual ( sorted ( result [ [string] ] ) , sorted ( stored [ num_requests // [number] : ] ) ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] [comment] [EOL] resp = self . query ( [string] , completed = True , active = True ) . json ( ) [EOL] result = self . assertIsResult ( resp ) [EOL] self . assertEqual ( len ( result [ [string] ] ) , [number] ) [EOL] [EOL] [EOL] class CompletingServerProcess ( ServerProcess ) : [EOL] def _compare_result ( self , result ) : [EOL] return result [ [string] ] [ [string] ] in ( [string] , [string] ) [EOL] [EOL] [EOL] @ mark . flaky ( rerun_filter = addr_in_use ) class TestRPCServerDeps ( HasRPCServer ) : [EOL] ServerProcess = CompletingServerProcess [EOL] should_seed = False [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] if os . path . exists ( [string] ) : [EOL] shutil . rmtree ( [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] if os . path . exists ( [string] ) : [EOL] shutil . rmtree ( [string] ) [EOL] self . adapter . cleanup_connections ( ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] @ property def packages_config ( selF ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] } , ] } [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def _check_start_predeps ( self ) : [EOL] self . assertFalse ( os . path . exists ( [string] ) ) [EOL] status = self . assertIsResult ( self . query ( [string] ) . json ( ) ) [EOL] self . assertEqual ( status [ [string] ] , [string] ) [EOL] [EOL] self . assertIsError ( self . async_query ( [string] ) . json ( ) ) [EOL] if os . path . exists ( [string] ) : [EOL] self . assertEqual ( len ( os . listdir ( [string] ) ) , [number] ) [EOL] return status [EOL] [EOL] def _check_deps_ok ( self , status ) : [EOL] os . kill ( status [ [string] ] , signal . SIGHUP ) [EOL] [EOL] self . wait_for_state ( [string] , timestamp = status [ [string] ] ) [EOL] [EOL] self . assertTrue ( os . path . exists ( [string] ) ) [EOL] self . assertEqual ( len ( os . listdir ( [string] ) ) , [number] ) [EOL] self . assertIsResult ( self . async_query ( [string] ) . json ( ) ) [EOL] [EOL] @ use_profile ( [string] ) def test_deps_compilation_postgres ( self ) : [EOL] status = self . _check_start_predeps ( ) [EOL] [EOL] [comment] [EOL] self . assertIsResult ( self . async_query ( [string] , _poll_timeout = [number] ) . json ( ) ) [EOL] [EOL] self . _check_deps_ok ( status ) [EOL] [EOL] @ mark . skip ( reason = [string] ) @ use_profile ( [string] ) def test_deps_cli_compilation_postgres ( self ) : [EOL] status = self . _check_start_predeps ( ) [EOL] [EOL] [comment] [EOL] self . assertIsResult ( self . async_query ( [string] , cli = [string] , _poll_timeout = [number] ) . json ( ) ) [EOL] [EOL] self . _check_deps_ok ( status ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Union , Any , Dict , List [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import pickle [EOL] import os [EOL] [EOL] [EOL] class TestRpcExecuteReturnsResults ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] def do_test_pickle ( self , agate_table ) : [EOL] table = { [string] : list ( agate_table . column_names ) , [string] : [ list ( row ) for row in agate_table ] } [EOL] [EOL] pickle . dumps ( table ) [EOL] [EOL] def do_test_file ( self , filename ) : [EOL] file_path = os . path . join ( [string] , filename ) [EOL] with open ( file_path ) as fh : [EOL] query = fh . read ( ) [EOL] [EOL] with self . adapter . connection_named ( [string] ) : [EOL] status , table = self . adapter . execute ( query , auto_begin = False , fetch = True ) [EOL] self . assertTrue ( len ( table . columns ) > [number] , [string] ) [EOL] self . assertTrue ( len ( table . rows ) > [number] , [string] ) [EOL] [EOL] self . do_test_pickle ( table ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_fetch_and_serialize ( self ) : [EOL] self . do_test_file ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake_fetch_and_serialize ( self ) : [EOL] self . do_test_file ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__redshift_fetch_and_serialize ( self ) : [EOL] self . do_test_file ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[typing.List[typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestChangingRelationType ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return path . lstrip ( [string] ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] def swap_types_and_test ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__switch_materialization ( self ) : [EOL] self . swap_types_and_test ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__switch_materialization ( self ) : [EOL] self . swap_types_and_test ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__redshift__switch_materialization ( self ) : [EOL] self . swap_types_and_test ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery__switch_materialization ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test__presto__switch_materialization ( self ) : [EOL] [comment] [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( results [ [number] ] . node . config . materialized , [string] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestAliases ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_customer_alias_name ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] [EOL] class TestAliasesWithConfig ( TestAliases ) : [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_customer_alias_name ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import test [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , FakeArgs , use_profile [EOL] [EOL] from dbt . task . test import TestTask [EOL] import os [EOL] [EOL] [EOL] class TestDataTests ( DBTIntegrationTest ) : [EOL] [EOL] test_path = os . path . normpath ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . test_path ] } [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def run_data_validations ( self ) : [EOL] args = FakeArgs ( ) [EOL] args . data = True [EOL] [EOL] test_task = TestTask ( args , self . config ) [EOL] return test_task . run ( ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_data_tests ( self ) : [EOL] self . use_profile ( [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] test_results = self . run_data_validations ( ) [EOL] [EOL] for result in test_results : [EOL] [comment] [EOL] if [string] in result . node . name : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] self . assertTrue ( result . status > [number] ) [EOL] [EOL] [comment] [EOL] else : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] [comment] [EOL] self . assertEqual ( result . status , [number] ) [EOL] [EOL] [comment] [EOL] defined_tests = os . listdir ( self . test_path ) [EOL] self . assertNotEqual ( len ( test_results ) , [number] ) [EOL] self . assertEqual ( len ( test_results ) , len ( defined_tests ) ) [EOL] [EOL] @ use_profile ( [string] ) def test_snowflake_data_tests ( self ) : [EOL] self . use_profile ( [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] test_results = self . run_data_validations ( ) [EOL] [EOL] for result in test_results : [EOL] [comment] [EOL] if [string] in result . node . name : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] self . assertTrue ( result . status > [number] ) [EOL] [EOL] [comment] [EOL] else : [EOL] self . assertIsNone ( result . error ) [EOL] self . assertFalse ( result . skipped ) [EOL] [comment] [EOL] self . assertEqual ( result . status , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import os [EOL] [EOL] [EOL] class TestAnalyses ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def analysis_path ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . analysis_path ( ) ] } [EOL] [EOL] def assert_contents_equal ( self , path , expected ) : [EOL] with open ( path ) as fp : [EOL] self . assertEqual ( fp . read ( ) . strip ( ) , expected ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_analyses ( self ) : [EOL] compiled_analysis_path = os . path . normpath ( [string] ) [EOL] path_1 = os . path . join ( compiled_analysis_path , [string] ) [EOL] path_2 = os . path . join ( compiled_analysis_path , [string] ) [EOL] [EOL] self . run_dbt ( [ [string] ] ) [EOL] self . assertFalse ( os . path . exists ( compiled_analysis_path ) ) [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTrue ( os . path . exists ( path_1 ) ) [EOL] self . assertTrue ( os . path . exists ( path_2 ) ) [EOL] [EOL] expected_sql = [string] . format ( self . default_database , self . unique_schema ( ) ) [EOL] self . assert_contents_equal ( path_1 , expected_sql ) [EOL] self . assert_contents_equal ( path_2 , [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
import os [EOL] [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestLateBindingView ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return os . path . normpath ( path ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ self . dir ( [string] ) ] , [string] : { [string] : False , } } [EOL] [EOL] @ use_profile ( [string] ) def test__redshift_late_binding_view_query ( self ) : [EOL] self . assertEqual ( len ( self . run_dbt ( [ [string] ] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . run_dbt ( ) ) , [number] ) [EOL] [comment] [EOL] [comment] [EOL] drop = [string] . format ( self . unique_schema ( ) ) [EOL] self . run_sql ( drop ) [EOL] self . assertEqual ( len ( self . run_dbt ( ) ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestAliases ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : { [string] : [string] , } , [string] : { [string] : [string] , } , } } } [EOL] [EOL] @ use_profile ( [string] ) def test__alias_model_name_postgres ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__alias_model_name_bigquery ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__alias_model_name_snowflake ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] [EOL] class TestAliasErrors ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_alias_dupe_throws_exception ( self ) : [EOL] message = [string] [EOL] with self . assertRaisesRegex ( Exception , message ) : [EOL] self . run_dbt ( [ [string] ] ) [EOL] [EOL] [EOL] class TestSameAliasDifferentSchemas ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . unique_schema ( ) + [string] ) ) [EOL] self . _created_schemas . add ( self . _get_schema_fqn ( self . default_database , self . unique_schema ( ) + [string] ) ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres_same_alias_succeeds_in_different_schemas ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] res = self . run_dbt ( [ [string] ] ) [EOL] [EOL] [comment] [EOL] self . assertTrue ( len ( res ) > [number] ) [EOL] [EOL] [EOL] class TestSameAliasDifferentDatabases ( DBTIntegrationTest ) : [EOL] setup_alternate_db = True [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : [ [string] ] , [string] : { [string] : { [string] : [string] , [string] : { [string] : self . alternative_database , } , } , } } [EOL] [EOL] @ use_profile ( [string] ) def test__bigquery_same_alias_succeeds_in_different_schemas ( self ) : [EOL] results = self . run_dbt ( [ [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] res = self . run_dbt ( [ [string] ] ) [EOL] [EOL] [comment] [EOL] self . assertTrue ( len ( res ) > [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import yaml [EOL] [EOL] [EOL] class TestGraphSelection ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def selectors_config ( self ) : [EOL] return yaml . safe_load ( [string] ) [EOL] [EOL] def _verify_selected_users ( self , results ) : [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__same_model_intersection ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__same_model_intersection_selectors ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__tags_intersection ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__tags_intersection_selectors ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_triple_descending ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_triple_descending_schema ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_triple_descending_schema_selectors ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_triple_ascending ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_triple_ascending_schema_selectors ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] def _verify_selected_users_and_rollup ( self , results ) : [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_with_exclusion ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users_and_rollup ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_with_exclusion_selectors ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users_and_rollup ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_exclude_intersection ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_exclude_intersection_selectors ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_exclude_intersection_lack ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users_and_rollup ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_exclude_intersection_lack_selector ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users_and_rollup ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_exclude_triple_intersection ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . _verify_selected_users ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_concat ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_concat_intersection ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_concat_exclude ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_concat_exclude_concat ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__intersection_concat_exclude_intersection_concat ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] class TestGraphSelection ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] def assert_correct_schemas ( self ) : [EOL] with self . get_connection ( ) : [EOL] exists = self . adapter . check_schema_exists ( self . default_database , self . unique_schema ( ) ) [EOL] self . assertTrue ( exists ) [EOL] [EOL] schema = self . unique_schema ( ) + [string] [EOL] exists = self . adapter . check_schema_exists ( self . default_database , schema ) [EOL] self . assertFalse ( exists ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__specific_model ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__tags ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__tags_and_children ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__tags_and_children_limited ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__specific_model ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__specific_model_and_children ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__specific_model_and_children ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__specific_model_and_children_limited ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__specific_model_and_parents ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__specific_model_and_parents ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__specific_model_and_parents_limited ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__specific_model_with_exclusion ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__specific_model_with_exclusion ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] ) [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__locally_qualified_name ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assert_correct_schemas ( ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__childrens_parents ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] , ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert results [ [number] ] . node . name == [string] [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__more_childrens_parents ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] , ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert sorted ( [ r . node . name for r in results ] ) == [ [string] , [string] ] [EOL] [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__skip_intermediate ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] users = [ r for r in results if r . node . name == [string] ] [ [number] ] [EOL] dep = [ r for r in results if r . node . name == [string] ] [ [number] ] [EOL] user_last_end = users . timing [ [number] ] . completed_at [EOL] dep_first_start = dep . timing [ [number] ] . started_at [EOL] self . assertTrue ( user_last_end <= dep_first_start , [string] . format ( user_last_end , dep_first_start ) ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__concat ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__concat_exclude ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__concat_exclude_concat ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert results [ [number] ] . node . name == [string] [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__report_parents ( self ) : [EOL] self . run_sql_file ( [string] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert sorted ( results ) == [ [string] , [string] ] [EOL] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] assert len ( results ) == [number] [EOL] assert sorted ( results ) == [ [string] , [string] , [string] ] [EOL] [EOL] self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] assert len ( results ) == [number] [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL] self . assertNotIn ( [string] , created_models ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , List [EOL] import test [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , FakeArgs , use_profile [EOL] [EOL] from dbt . task . test import TestTask [EOL] [EOL] [EOL] class TestSchemaTestGraphSelection ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def packages_config ( self ) : [EOL] return { [string] : [ { [string] : [string] , [string] : [string] , } ] } [EOL] [EOL] def run_schema_and_assert ( self , include , exclude , expected_tests ) : [EOL] self . run_sql_file ( [string] ) [EOL] self . run_dbt ( [ [string] ] ) [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] args = FakeArgs ( ) [EOL] args . models = include [EOL] args . exclude = exclude [EOL] [EOL] test_task = TestTask ( args , self . config ) [EOL] test_results = test_task . run ( ) [EOL] [EOL] ran_tests = sorted ( [ test . node . name for test in test_results ] ) [EOL] expected_sorted = sorted ( expected_tests ) [EOL] [EOL] self . assertEqual ( ran_tests , expected_sorted ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_no_specifiers ( self ) : [EOL] self . run_schema_and_assert ( None , None , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_specify_model ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , None , [ [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_specify_tag ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , None , [ [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_specify_model_and_children ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , None , [ [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_specify_tag_and_children ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , None , [ [string] , [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_specify_model_and_parents ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , None , [ [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_specify_model_and_parents_with_exclude ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , [ [string] ] , [ [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_specify_exclude_only ( self ) : [EOL] self . run_schema_and_assert ( None , [ [string] ] , [ [string] , [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_specify_model_in_pkg ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , None , [ [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_with_glob ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , [ [string] ] , [ [string] , [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_dep_package_only ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , None , [ [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_model_in_dep_pkg ( self ) : [EOL] self . run_schema_and_assert ( [ [string] ] , None , [ [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__schema_tests_exclude_pkg ( self ) : [EOL] self . run_schema_and_assert ( None , [ [string] ] , [ [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $test.integration.base.FakeArgs$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] import yaml [EOL] [EOL] [EOL] class TestGraphSelection ( DBTIntegrationTest ) : [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [ [string] ] , } } } } [EOL] [EOL] @ property def selectors_config ( self ) : [EOL] return yaml . safe_load ( [string] ) [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] def _verify_select_tag ( self , results ) : [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] models_run = [ r . node . name for r in results ] [EOL] self . assertTrue ( [string] in models_run ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_select_tag ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag_selector_str ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_select_tag ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag_selector_dict ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_select_tag ( results ) [EOL] [EOL] def _verify_select_tag_and_children ( self , results ) : [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] models_run = [ r . node . name for r in results ] [EOL] self . assertTrue ( [string] in models_run ) [EOL] self . assertTrue ( [string] in models_run ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag_and_children ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_select_tag_and_children ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag_and_children_selector_str ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_select_tag_and_children ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag_and_children_selector_dict ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_select_tag_and_children ( results ) [EOL] [EOL] [comment] [EOL] def _verify_select_bi ( self , results ) : [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] models_run = [ r . node . name for r in results ] [EOL] self . assertTrue ( [string] in models_run ) [EOL] self . assertTrue ( [string] in models_run ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag_in_model_with_project_config ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_select_bi ( results ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag_in_model_with_project_config_selector ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . _verify_select_bi ( results ) [EOL] [EOL] [comment] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag_in_model_with_project_config_parents_children ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] models_run = set ( r . node . name for r in results ) [EOL] self . assertEqual ( { [string] , [string] , [string] , [string] } , models_run ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert sorted ( r . node . name for r in results ) == [ [string] , [string] ] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert results [ [number] ] . node . name == [string] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert results [ [number] ] . node . name == [string] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert sorted ( r . node . name for r in results ) == [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__select_tag_in_model_with_project_config_parents_children_selectors ( self ) : [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] models_run = set ( r . node . name for r in results ) [EOL] self . assertEqual ( { [string] , [string] , [string] , [string] } , models_run ) [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert sorted ( r . node . name for r in results ) == [ [string] , [string] ] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert results [ [number] ] . node . name == [string] [EOL] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert results [ [number] ] . node . name == [string] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] assert sorted ( r . node . name for r in results ) == [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] from dbt . exceptions import CompilationException [EOL] [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] [EOL] class TestSimpleReference ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] , [string] : { [string] : { [string] : [string] , } , } , } [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] [comment] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__simple_reference ( self ) : [EOL] [EOL] results = self . run_dbt ( ) [EOL] [comment] [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__simple_reference ( self ) : [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] self . run_sql_file ( [string] ) [EOL] [EOL] results = self . run_dbt ( ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] self . assertManyTablesEqual ( [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__simple_reference_with_models ( self ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertTrue ( [string] in created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__postgres__simple_reference_with_models_and_children ( self ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] [EOL] [comment] [EOL] self . assertFalse ( [string] in created_models ) [EOL] [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__simple_reference_with_models ( self ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertTablesEqual ( [string] , [string] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] self . assertTrue ( [string] in created_models ) [EOL] [EOL] @ use_profile ( [string] ) def test__snowflake__simple_reference_with_models_and_children ( self ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] results = self . run_dbt ( [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertManyTablesEqual ( [ [string] , [string] ] , [ [string] , [string] , [string] ] ) [EOL] [EOL] created_models = self . get_models_in_schema ( ) [EOL] [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] self . assertFalse ( [string] in created_models ) [EOL] [EOL] [comment] [EOL] self . assertFalse ( [string] in created_models ) [EOL] [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] [EOL] self . assertTrue ( [string] in created_models ) [EOL] self . assertEqual ( created_models [ [string] ] , [string] ) [EOL] [EOL] [EOL] class TestErrorReference ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_undefined_value ( self ) : [EOL] with self . assertRaises ( CompilationException ) as exc : [EOL] self . run_dbt ( [ [string] ] ) [EOL] path = os . path . join ( [string] , [string] ) [EOL] self . assertIn ( path , str ( exc . exception ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
[EOL] from typing import Pattern [EOL] import typing [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] import logging [EOL] import re [EOL] import sys [EOL] [EOL] class TestUseColors ( DBTIntegrationTest ) : [EOL] [EOL] @ property def project_config ( self ) : [EOL] return { [string] : [number] } [EOL] [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ property def models ( self ) : [EOL] return [string] [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_use_colors ( self ) : [EOL] [comment] [EOL] pattern = re . compile ( [string] ) [EOL] [EOL] results , stdout = self . run_dbt_and_capture ( args = [ [string] , [string] ] , expect_pass = False ) [EOL] [EOL] stdout_contains_formatting_characters = bool ( pattern . search ( stdout ) ) [EOL] self . assertTrue ( stdout_contains_formatting_characters ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0
from typing import Any [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] from test . integration . base import DBTIntegrationTest , use_profile [EOL] [EOL] import dbt . exceptions [EOL] [EOL] class TestGoodDocsBlocks ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return os . path . normpath ( path ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_valid_doc_ref ( self ) : [EOL] self . assertEqual ( len ( self . run_dbt ( ) ) , [number] ) [EOL] [EOL] self . assertTrue ( os . path . exists ( [string] ) ) [EOL] [EOL] with open ( [string] ) as fp : [EOL] manifest = json . load ( fp ) [EOL] [EOL] model_data = manifest [ [string] ] [ [string] ] [EOL] self . assertEqual ( model_data [ [string] ] , [string] ) [EOL] self . assertEqual ( { [string] : [string] , [string] : [string] , [string] : None , [string] : { } , [string] : None , [string] : [ ] , } , model_data [ [string] ] [ [string] ] ) [EOL] self . assertEqual ( { [string] : [string] , [string] : [string] , [string] : None , [string] : { } , [string] : None , [string] : [ ] , } , model_data [ [string] ] [ [string] ] ) [EOL] [EOL] self . assertEqual ( { [string] : [string] , [string] : [string] , [string] : None , [string] : { } , [string] : None , [string] : [ ] , } , model_data [ [string] ] [ [string] ] ) [EOL] self . assertEqual ( len ( model_data [ [string] ] ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_alternative_docs_path ( self ) : [EOL] self . use_default_project ( { [string] : [ self . dir ( [string] ) ] } ) [EOL] self . assertEqual ( len ( self . run_dbt ( ) ) , [number] ) [EOL] [EOL] self . assertTrue ( os . path . exists ( [string] ) ) [EOL] [EOL] with open ( [string] ) as fp : [EOL] manifest = json . load ( fp ) [EOL] [EOL] model_data = manifest [ [string] ] [ [string] ] [EOL] self . assertEqual ( model_data [ [string] ] , [string] ) [EOL] self . assertEqual ( { [string] : [string] , [string] : [string] , [string] : None , [string] : { } , [string] : None , [string] : [ ] , } , model_data [ [string] ] [ [string] ] ) [EOL] self . assertEqual ( { [string] : [string] , [string] : [string] , [string] : None , [string] : { } , [string] : None , [string] : [ ] , } , model_data [ [string] ] [ [string] ] ) [EOL] [EOL] self . assertEqual ( { [string] : [string] , [string] : [string] , [string] : None , [string] : { } , [string] : None , [string] : [ ] , } , model_data [ [string] ] [ [string] ] ) [EOL] self . assertEqual ( len ( model_data [ [string] ] ) , [number] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_alternative_docs_path_missing ( self ) : [EOL] self . use_default_project ( { [string] : [ self . dir ( [string] ) ] } ) [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) : [EOL] self . run_dbt ( ) [EOL] [EOL] [EOL] class TestMissingDocsBlocks ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return os . path . normpath ( path ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_missing_doc_ref ( self ) : [EOL] [comment] [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) : [EOL] self . run_dbt ( ) [EOL] [EOL] [EOL] class TestBadDocsBlocks ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return os . path . normpath ( path ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_invalid_doc_ref ( self ) : [EOL] [comment] [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) : [EOL] self . run_dbt ( expect_pass = False ) [EOL] [EOL] class TestDuplicateDocsBlock ( DBTIntegrationTest ) : [EOL] @ property def schema ( self ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def dir ( path ) : [EOL] return os . path . normpath ( path ) [EOL] [EOL] @ property def models ( self ) : [EOL] return self . dir ( [string] ) [EOL] [EOL] @ use_profile ( [string] ) def test_postgres_duplicate_doc_ref ( self ) : [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) : [EOL] self . run_dbt ( expect_pass = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import unittest [EOL] import typing [EOL] import agate [EOL] import unittest [EOL] from contextlib import contextmanager [EOL] from unittest import mock [EOL] [EOL] import dbt . flags as flags [EOL] [EOL] from dbt . adapters . snowflake import SnowflakeAdapter [EOL] from dbt . adapters . snowflake import Plugin as SnowflakePlugin [EOL] from dbt . adapters . snowflake . column import SnowflakeColumn [EOL] from dbt . adapters . base . query_headers import MacroQueryStringSetter [EOL] from dbt . clients import agate_helper [EOL] from dbt . logger import GLOBAL_LOGGER as logger [comment] [EOL] from dbt . parser . results import ParseResult [EOL] from snowflake import connector as snowflake_connector [EOL] [EOL] from . utils import config_from_parts_or_dicts , inject_adapter , mock_connection , TestAdapterConversions , load_internal_manifest_macros [EOL] [EOL] [EOL] class TestSnowflakeAdapter ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] flags . STRICT_MODE = False [EOL] [EOL] profile_cfg = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , } , [string] : [string] , } [EOL] [EOL] project_cfg = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : False , [string] : True , } , [string] : [string] , [string] : [number] , } [EOL] self . config = config_from_parts_or_dicts ( project_cfg , profile_cfg ) [EOL] self . assertEqual ( self . config . query_comment . comment , [string] ) [EOL] self . assertEqual ( self . config . query_comment . append , False ) [EOL] [EOL] self . handle = mock . MagicMock ( spec = snowflake_connector . SnowflakeConnection ) [EOL] self . cursor = self . handle . cursor . return_value [EOL] self . mock_execute = self . cursor . execute [EOL] self . patcher = mock . patch ( [string] ) [EOL] self . snowflake = self . patcher . start ( ) [EOL] [EOL] self . load_patch = mock . patch ( [string] ) [EOL] self . mock_parse_result = self . load_patch . start ( ) [EOL] self . mock_parse_result . return_value = ParseResult . rpc ( ) [EOL] [EOL] self . snowflake . return_value = self . handle [EOL] self . adapter = SnowflakeAdapter ( self . config ) [EOL] self . adapter . _macro_manifest_lazy = load_internal_manifest_macros ( self . config ) [EOL] self . adapter . connections . query_header = MacroQueryStringSetter ( self . config , self . adapter . _macro_manifest_lazy ) [EOL] [EOL] self . qh_patch = mock . patch . object ( self . adapter . connections . query_header , [string] ) [EOL] self . mock_query_header_add = self . qh_patch . start ( ) [EOL] self . mock_query_header_add . side_effect = lambda q : [string] . format ( q ) [EOL] [EOL] self . adapter . acquire_connection ( ) [EOL] inject_adapter ( self . adapter , SnowflakePlugin ) [EOL] [EOL] def tearDown ( self ) : [EOL] [comment] [EOL] self . adapter . cleanup_connections ( ) [EOL] self . qh_patch . stop ( ) [EOL] self . patcher . stop ( ) [EOL] self . load_patch . stop ( ) [EOL] [EOL] def test_quoting_on_drop_schema ( self ) : [EOL] relation = SnowflakeAdapter . Relation . create ( database = [string] , schema = [string] , quote_policy = self . adapter . config . quoting ) [EOL] self . adapter . drop_schema ( relation ) [EOL] [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] def test_quoting_on_drop ( self ) : [EOL] relation = self . adapter . Relation . create ( database = [string] , schema = [string] , identifier = [string] , type = [string] , quote_policy = self . adapter . config . quoting , ) [EOL] self . adapter . drop_relation ( relation ) [EOL] [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] def test_quoting_on_truncate ( self ) : [EOL] relation = self . adapter . Relation . create ( database = [string] , schema = [string] , identifier = [string] , type = [string] , quote_policy = self . adapter . config . quoting , ) [EOL] self . adapter . truncate_relation ( relation ) [EOL] [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] def test_quoting_on_rename ( self ) : [EOL] from_relation = self . adapter . Relation . create ( database = [string] , schema = [string] , identifier = [string] , type = [string] , quote_policy = self . adapter . config . quoting , ) [EOL] to_relation = self . adapter . Relation . create ( database = [string] , schema = [string] , identifier = [string] , type = [string] , quote_policy = self . adapter . config . quoting , ) [EOL] [EOL] self . adapter . rename_relation ( from_relation = from_relation , to_relation = to_relation ) [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] @ contextmanager def current_warehouse ( self , response ) : [EOL] [comment] [EOL] fetchall_return = self . cursor . fetchall . return_value [EOL] execute_side_effect = self . mock_execute . side_effect [EOL] [EOL] def execute_effect ( sql , * args , ** kwargs ) : [EOL] if sql == [string] : [EOL] self . cursor . description = [ [ [string] ] ] [EOL] self . cursor . fetchall . return_value = [ [ response ] ] [EOL] else : [EOL] self . cursor . description = None [EOL] self . cursor . fetchall . return_value = fetchall_return [EOL] return self . mock_execute . return_value [EOL] [EOL] self . mock_execute . side_effect = execute_effect [EOL] try : [EOL] yield [EOL] finally : [EOL] self . cursor . fetchall . return_value = fetchall_return [EOL] self . mock_execute . side_effect = execute_side_effect [EOL] [EOL] def _strip_transactions ( self ) : [EOL] result = [ ] [EOL] for call_args in self . mock_execute . call_args_list : [EOL] args , kwargs = tuple ( call_args ) [EOL] is_transactional = ( len ( kwargs ) == [number] and len ( args ) == [number] and args [ [number] ] is None and args [ [number] ] in { [string] , [string] } ) [EOL] if not is_transactional : [EOL] result . append ( call_args ) [EOL] return result [EOL] [EOL] def test_pre_post_hooks_warehouse ( self ) : [EOL] with self . current_warehouse ( [string] ) : [EOL] config = { [string] : [string] } [EOL] result = self . adapter . pre_model_hook ( config ) [EOL] self . assertIsNotNone ( result ) [EOL] calls = [ mock . call ( [string] , None ) , mock . call ( [string] , None ) ] [EOL] self . mock_execute . assert_has_calls ( calls ) [EOL] self . adapter . post_model_hook ( config , result ) [EOL] calls . append ( mock . call ( [string] , None ) ) [EOL] self . mock_execute . assert_has_calls ( calls ) [EOL] [EOL] def test_pre_post_hooks_no_warehouse ( self ) : [EOL] with self . current_warehouse ( [string] ) : [EOL] config = { } [EOL] result = self . adapter . pre_model_hook ( config ) [EOL] self . assertIsNone ( result ) [EOL] self . mock_execute . assert_not_called ( ) [EOL] self . adapter . post_model_hook ( config , result ) [EOL] self . mock_execute . assert_not_called ( ) [EOL] [EOL] def test_cancel_open_connections_empty ( self ) : [EOL] self . assertEqual ( len ( list ( self . adapter . cancel_open_connections ( ) ) ) , [number] ) [EOL] [EOL] def test_cancel_open_connections_master ( self ) : [EOL] key = self . adapter . connections . get_thread_identifier ( ) [EOL] self . adapter . connections . thread_connections [ key ] = mock_connection ( [string] ) [EOL] self . assertEqual ( len ( list ( self . adapter . cancel_open_connections ( ) ) ) , [number] ) [EOL] [EOL] def test_cancel_open_connections_single ( self ) : [EOL] master = mock_connection ( [string] ) [EOL] model = mock_connection ( [string] ) [EOL] model . handle . session_id = [number] [EOL] [EOL] key = self . adapter . connections . get_thread_identifier ( ) [EOL] self . adapter . connections . thread_connections . update ( { key : master , [number] : model , } ) [EOL] with mock . patch . object ( self . adapter . connections , [string] ) as add_query : [EOL] query_result = mock . MagicMock ( ) [EOL] add_query . return_value = ( None , query_result ) [EOL] [EOL] self . assertEqual ( len ( list ( self . adapter . cancel_open_connections ( ) ) ) , [number] ) [EOL] [EOL] add_query . assert_called_once_with ( [string] ) [EOL] [EOL] def test_client_session_keep_alive_false_by_default ( self ) : [EOL] conn = self . adapter . connections . set_connection_name ( name = [string] ) [EOL] [EOL] self . snowflake . assert_not_called ( ) [EOL] conn . handle [EOL] self . snowflake . assert_has_calls ( [ mock . call ( account = [string] , autocommit = False , client_session_keep_alive = False , database = [string] , role = None , schema = [string] , user = [string] , warehouse = [string] , private_key = None , application = [string] ) ] ) [EOL] [EOL] def test_client_session_keep_alive_true ( self ) : [EOL] self . config . credentials = self . config . credentials . replace ( client_session_keep_alive = True ) [EOL] self . adapter = SnowflakeAdapter ( self . config ) [EOL] conn = self . adapter . connections . set_connection_name ( name = [string] ) [EOL] [EOL] self . snowflake . assert_not_called ( ) [EOL] conn . handle [EOL] self . snowflake . assert_has_calls ( [ mock . call ( account = [string] , autocommit = False , client_session_keep_alive = True , database = [string] , role = None , schema = [string] , user = [string] , warehouse = [string] , private_key = None , application = [string] ) ] ) [EOL] [EOL] def test_user_pass_authentication ( self ) : [EOL] self . config . credentials = self . config . credentials . replace ( password = [string] , ) [EOL] self . adapter = SnowflakeAdapter ( self . config ) [EOL] conn = self . adapter . connections . set_connection_name ( name = [string] ) [EOL] [EOL] self . snowflake . assert_not_called ( ) [EOL] conn . handle [EOL] self . snowflake . assert_has_calls ( [ mock . call ( account = [string] , autocommit = False , client_session_keep_alive = False , database = [string] , password = [string] , role = None , schema = [string] , user = [string] , warehouse = [string] , private_key = None , application = [string] ) ] ) [EOL] [EOL] def test_authenticator_user_pass_authentication ( self ) : [EOL] self . config . credentials = self . config . credentials . replace ( password = [string] , authenticator = [string] , ) [EOL] self . adapter = SnowflakeAdapter ( self . config ) [EOL] conn = self . adapter . connections . set_connection_name ( name = [string] ) [EOL] [EOL] self . snowflake . assert_not_called ( ) [EOL] conn . handle [EOL] self . snowflake . assert_has_calls ( [ mock . call ( account = [string] , autocommit = False , client_session_keep_alive = False , database = [string] , password = [string] , role = None , schema = [string] , user = [string] , warehouse = [string] , authenticator = [string] , private_key = None , application = [string] , client_store_temporary_credential = True ) ] ) [EOL] [EOL] def test_authenticator_externalbrowser_authentication ( self ) : [EOL] self . config . credentials = self . config . credentials . replace ( authenticator = [string] ) [EOL] self . adapter = SnowflakeAdapter ( self . config ) [EOL] conn = self . adapter . connections . set_connection_name ( name = [string] ) [EOL] [EOL] self . snowflake . assert_not_called ( ) [EOL] conn . handle [EOL] self . snowflake . assert_has_calls ( [ mock . call ( account = [string] , autocommit = False , client_session_keep_alive = False , database = [string] , role = None , schema = [string] , user = [string] , warehouse = [string] , authenticator = [string] , private_key = None , application = [string] , client_store_temporary_credential = True ) ] ) [EOL] [EOL] def test_authenticator_oauth_authentication ( self ) : [EOL] self . config . credentials = self . config . credentials . replace ( authenticator = [string] , token = [string] , ) [EOL] self . adapter = SnowflakeAdapter ( self . config ) [EOL] conn = self . adapter . connections . set_connection_name ( name = [string] ) [EOL] [EOL] self . snowflake . assert_not_called ( ) [EOL] conn . handle [EOL] self . snowflake . assert_has_calls ( [ mock . call ( account = [string] , autocommit = False , client_session_keep_alive = False , database = [string] , role = None , schema = [string] , user = [string] , warehouse = [string] , authenticator = [string] , token = [string] , private_key = None , application = [string] , client_store_temporary_credential = True ) ] ) [EOL] [EOL] @ mock . patch ( [string] , return_value = [string] ) def test_authenticator_private_key_authentication ( self , mock_get_private_key ) : [EOL] self . config . credentials = self . config . credentials . replace ( private_key_path = [string] , private_key_passphrase = [string] , ) [EOL] [EOL] self . adapter = SnowflakeAdapter ( self . config ) [EOL] conn = self . adapter . connections . set_connection_name ( name = [string] ) [EOL] [EOL] self . snowflake . assert_not_called ( ) [EOL] conn . handle [EOL] self . snowflake . assert_has_calls ( [ mock . call ( account = [string] , autocommit = False , client_session_keep_alive = False , database = [string] , role = None , schema = [string] , user = [string] , warehouse = [string] , private_key = [string] , application = [string] ) ] ) [EOL] [EOL] @ mock . patch ( [string] , return_value = [string] ) def test_authenticator_private_key_authentication_no_passphrase ( self , mock_get_private_key ) : [EOL] self . config . credentials = self . config . credentials . replace ( private_key_path = [string] , private_key_passphrase = None , ) [EOL] [EOL] self . adapter = SnowflakeAdapter ( self . config ) [EOL] conn = self . adapter . connections . set_connection_name ( name = [string] ) [EOL] [EOL] self . snowflake . assert_not_called ( ) [EOL] conn . handle [EOL] self . snowflake . assert_has_calls ( [ mock . call ( account = [string] , autocommit = False , client_session_keep_alive = False , database = [string] , role = None , schema = [string] , user = [string] , warehouse = [string] , private_key = [string] , application = [string] ) ] ) [EOL] [EOL] [EOL] class TestSnowflakeAdapterConversions ( TestAdapterConversions ) : [EOL] def test_convert_text_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . Text ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert SnowflakeAdapter . convert_text_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_number_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . Number ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert SnowflakeAdapter . convert_number_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_boolean_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . Boolean ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert SnowflakeAdapter . convert_boolean_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_datetime_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , [ agate . DateTime , agate_helper . ISODateTime , agate . DateTime ] ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert SnowflakeAdapter . convert_datetime_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_date_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . Date ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert SnowflakeAdapter . convert_date_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_time_type ( self ) : [EOL] [comment] [EOL] agate . TimeDelta [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . TimeDelta ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert SnowflakeAdapter . convert_time_type ( agate_table , col_idx ) == expect [EOL] [EOL] [EOL] class TestSnowflakeColumn ( unittest . TestCase ) : [EOL] def test_text_from_description ( self ) : [EOL] col = SnowflakeColumn . from_description ( [string] , [string] ) [EOL] assert col . column == [string] [EOL] assert col . dtype == [string] [EOL] assert col . char_size is None [EOL] assert col . numeric_precision is None [EOL] assert col . numeric_scale is None [EOL] assert col . is_float ( ) is False [EOL] assert col . is_number ( ) is False [EOL] assert col . is_numeric ( ) is False [EOL] assert col . is_string ( ) is True [EOL] assert col . is_integer ( ) is False [EOL] assert col . string_size ( ) == [number] [EOL] [EOL] col = SnowflakeColumn . from_description ( [string] , [string] ) [EOL] assert col . column == [string] [EOL] assert col . dtype == [string] [EOL] assert col . char_size is None [EOL] assert col . numeric_precision is None [EOL] assert col . numeric_scale is None [EOL] assert col . is_float ( ) is False [EOL] assert col . is_number ( ) is False [EOL] assert col . is_numeric ( ) is False [EOL] assert col . is_string ( ) is True [EOL] assert col . is_integer ( ) is False [EOL] assert col . string_size ( ) == [number] [EOL] [EOL] def test_sized_varchar_from_description ( self ) : [EOL] col = SnowflakeColumn . from_description ( [string] , [string] ) [EOL] assert col . column == [string] [EOL] assert col . dtype == [string] [EOL] assert col . char_size == [number] [EOL] assert col . numeric_precision is None [EOL] assert col . numeric_scale is None [EOL] assert col . is_float ( ) is False [EOL] assert col . is_number ( ) is False [EOL] assert col . is_numeric ( ) is False [EOL] assert col . is_string ( ) is True [EOL] assert col . is_integer ( ) is False [EOL] assert col . string_size ( ) == [number] [EOL] [EOL] def test_sized_decimal_from_description ( self ) : [EOL] col = SnowflakeColumn . from_description ( [string] , [string] ) [EOL] assert col . column == [string] [EOL] assert col . dtype == [string] [EOL] assert col . char_size is None [EOL] assert col . numeric_precision == [number] [EOL] assert col . numeric_scale == [number] [EOL] assert col . is_float ( ) is False [EOL] assert col . is_number ( ) is True [EOL] assert col . is_numeric ( ) is True [EOL] assert col . is_string ( ) is False [EOL] assert col . is_integer ( ) is False [EOL] [EOL] def test_float_from_description ( self ) : [EOL] col = SnowflakeColumn . from_description ( [string] , [string] ) [EOL] assert col . column == [string] [EOL] assert col . dtype == [string] [EOL] assert col . char_size is None [EOL] assert col . numeric_precision is None [EOL] assert col . numeric_scale is None [EOL] assert col . is_float ( ) is True [EOL] assert col . is_number ( ) is True [EOL] assert col . is_numeric ( ) is False [EOL] assert col . is_string ( ) is False [EOL] assert col . is_integer ( ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Any$ 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[unittest.mock._Call]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import copy [EOL] import pytest [EOL] from unittest import mock [EOL] [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] [EOL] from dbt . contracts . files import FileHash [EOL] from dbt . contracts . graph . parsed import ( DependsOn , NodeConfig , ParsedModelNode , ParsedReport , ParsedSeedNode , ParsedSnapshotNode , ParsedDataTestNode , ParsedSchemaTestNode , ParsedSourceDefinition , TestConfig , TestMetadata , ColumnInfo , ) [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . graph . unparsed import ExposureType , ReportOwner [EOL] from dbt . contracts . state import PreviousState [EOL] from dbt . node_types import NodeType [EOL] from dbt . graph . selector_methods import ( MethodManager , QualifiedNameSelectorMethod , TagSelectorMethod , SourceSelectorMethod , PathSelectorMethod , PackageSelectorMethod , ConfigSelectorMethod , TestNameSelectorMethod , TestTypeSelectorMethod , StateSelectorMethod , ReportSelectorMethod , ) [EOL] import dbt . exceptions [EOL] import dbt . contracts . graph . parsed [EOL] from . utils import replace_config [EOL] [EOL] [EOL] def make_model ( pkg , name , sql , refs = None , sources = None , tags = None , path = None , alias = None , config_kwargs = None , fqn_extras = None ) : [EOL] if refs is None : [EOL] refs = [ ] [EOL] if sources is None : [EOL] sources = [ ] [EOL] if tags is None : [EOL] tags = [ ] [EOL] if path is None : [EOL] path = f'{ name } [string] ' [EOL] if alias is None : [EOL] alias = name [EOL] if config_kwargs is None : [EOL] config_kwargs = { } [EOL] [EOL] if fqn_extras is None : [EOL] fqn_extras = [ ] [EOL] [EOL] fqn = [ pkg ] + fqn_extras + [ name ] [EOL] [EOL] depends_on_nodes = [ ] [EOL] source_values = [ ] [EOL] ref_values = [ ] [EOL] for ref in refs : [EOL] ref_values . append ( [ ref . name ] ) [EOL] depends_on_nodes . append ( ref . unique_id ) [EOL] for src in sources : [EOL] source_values . append ( [ src . source_name , src . name ] ) [EOL] depends_on_nodes . append ( src . unique_id ) [EOL] [EOL] return ParsedModelNode ( raw_sql = sql , database = [string] , schema = [string] , alias = alias , name = name , fqn = fqn , unique_id = f' [string] { pkg } [string] { name }' , package_name = pkg , root_path = [string] , path = path , original_file_path = f' [string] { path }' , config = NodeConfig ( ** config_kwargs ) , tags = tags , refs = ref_values , sources = source_values , depends_on = DependsOn ( nodes = depends_on_nodes ) , resource_type = NodeType . Model , checksum = FileHash . from_contents ( [string] ) , ) [EOL] [EOL] [EOL] def make_seed ( pkg , name , path = None , loader = None , alias = None , tags = None , fqn_extras = None , checksum = None ) : [EOL] if alias is None : [EOL] alias = name [EOL] if tags is None : [EOL] tags = [ ] [EOL] if path is None : [EOL] path = f'{ name } [string] ' [EOL] [EOL] if fqn_extras is None : [EOL] fqn_extras = [ ] [EOL] [EOL] if checksum is None : [EOL] checksum = FileHash . from_contents ( [string] ) [EOL] [EOL] fqn = [ pkg ] + fqn_extras + [ name ] [EOL] return ParsedSeedNode ( raw_sql = [string] , database = [string] , schema = [string] , alias = alias , name = name , fqn = fqn , unique_id = f' [string] { pkg } [string] { name }' , package_name = pkg , root_path = [string] , path = path , original_file_path = f' [string] { path }' , tags = tags , resource_type = NodeType . Seed , checksum = FileHash . from_contents ( [string] ) , ) [EOL] [EOL] [EOL] def make_source ( pkg , source_name , table_name , path = None , loader = None , identifier = None , fqn_extras = None ) : [EOL] if path is None : [EOL] path = [string] [EOL] if loader is None : [EOL] loader = [string] [EOL] if identifier is None : [EOL] identifier = table_name [EOL] [EOL] if fqn_extras is None : [EOL] fqn_extras = [ ] [EOL] [EOL] fqn = [ pkg ] + fqn_extras + [ source_name , table_name ] [EOL] [EOL] return ParsedSourceDefinition ( fqn = fqn , database = [string] , schema = [string] , unique_id = f' [string] { pkg } [string] { source_name } [string] { table_name }' , package_name = pkg , root_path = [string] , path = path , original_file_path = path , name = table_name , source_name = source_name , loader = [string] , identifier = identifier , resource_type = NodeType . Source , loaded_at_field = [string] , tags = [ ] , source_description = [string] , ) [EOL] [EOL] [EOL] def make_unique_test ( pkg , test_model , column_name , path = None , refs = None , sources = None , tags = None ) : [EOL] return make_schema_test ( pkg , [string] , test_model , { } , column_name = column_name ) [EOL] [EOL] [EOL] def make_not_null_test ( pkg , test_model , column_name , path = None , refs = None , sources = None , tags = None ) : [EOL] return make_schema_test ( pkg , [string] , test_model , { } , column_name = column_name ) [EOL] [EOL] [EOL] def make_schema_test ( pkg , test_name , test_model , test_kwargs , path = None , refs = None , sources = None , tags = None , column_name = None ) : [EOL] kwargs = test_kwargs . copy ( ) [EOL] ref_values = [ ] [EOL] source_values = [ ] [EOL] [comment] [EOL] if isinstance ( test_model , ParsedSourceDefinition ) : [EOL] kwargs [ [string] ] = [string] + test_model . source_name + [string] + test_model . name + [string] [EOL] source_values . append ( [ test_model . source_name , test_model . name ] ) [EOL] else : [EOL] kwargs [ [string] ] = [string] + test_model . name + [string] [EOL] ref_values . append ( [ test_model . name ] ) [EOL] if column_name is not None : [EOL] kwargs [ [string] ] = column_name [EOL] [EOL] [comment] [EOL] args_name = test_model . search_name . replace ( [string] , [string] ) [EOL] if column_name is not None : [EOL] args_name += [string] + column_name [EOL] node_name = f'{ test_name } [string] { args_name }' [EOL] raw_sql = [string] + test_name + [string] [EOL] name_parts = test_name . split ( [string] ) [EOL] [EOL] if len ( name_parts ) == [number] : [EOL] namespace , test_name = name_parts [EOL] macro_depends = f' [string] { namespace } [string] { test_name }' [EOL] elif len ( name_parts ) == [number] : [EOL] namespace = None [EOL] macro_depends = f' [string] { test_name }' [EOL] else : [EOL] assert False , f' [string] { test_name }' [EOL] [EOL] if path is None : [EOL] path = [string] [EOL] if tags is None : [EOL] tags = [ [string] ] [EOL] [EOL] if refs is None : [EOL] refs = [ ] [EOL] if sources is None : [EOL] sources = [ ] [EOL] [EOL] depends_on_nodes = [ ] [EOL] for ref in refs : [EOL] ref_values . append ( [ ref . name ] ) [EOL] depends_on_nodes . append ( ref . unique_id ) [EOL] [EOL] for source in sources : [EOL] source_values . append ( [ source . source_name , source . name ] ) [EOL] depends_on_nodes . append ( source . unique_id ) [EOL] [EOL] return ParsedSchemaTestNode ( raw_sql = raw_sql , test_metadata = TestMetadata ( namespace = namespace , name = test_name , kwargs = kwargs , ) , database = [string] , schema = [string] , name = node_name , alias = node_name , fqn = [ [string] , [string] , node_name ] , unique_id = f' [string] { pkg } [string] { node_name }' , package_name = pkg , root_path = [string] , path = f' [string] { node_name } [string] ' , original_file_path = f' [string] { path }' , resource_type = NodeType . Test , tags = tags , refs = ref_values , sources = [ ] , depends_on = DependsOn ( macros = [ macro_depends ] , nodes = depends_on_nodes ) , column_name = column_name , checksum = FileHash . from_contents ( [string] ) , ) [EOL] [EOL] [EOL] def make_data_test ( pkg , name , sql , refs = None , sources = None , tags = None , path = None , config_kwargs = None ) : [EOL] [EOL] if refs is None : [EOL] refs = [ ] [EOL] if sources is None : [EOL] sources = [ ] [EOL] if tags is None : [EOL] tags = [ [string] ] [EOL] if path is None : [EOL] path = f'{ name } [string] ' [EOL] [EOL] if config_kwargs is None : [EOL] config_kwargs = { } [EOL] [EOL] fqn = [ [string] , [string] , name ] [EOL] [EOL] depends_on_nodes = [ ] [EOL] source_values = [ ] [EOL] ref_values = [ ] [EOL] for ref in refs : [EOL] ref_values . append ( [ ref . name ] ) [EOL] depends_on_nodes . append ( ref . unique_id ) [EOL] for src in sources : [EOL] source_values . append ( [ src . source_name , src . name ] ) [EOL] depends_on_nodes . append ( src . unique_id ) [EOL] [EOL] return ParsedDataTestNode ( raw_sql = sql , database = [string] , schema = [string] , name = name , alias = name , fqn = fqn , unique_id = f' [string] { pkg } [string] { name }' , package_name = pkg , root_path = [string] , path = path , original_file_path = f' [string] { path }' , config = TestConfig ( ** config_kwargs ) , tags = tags , refs = ref_values , sources = source_values , depends_on = DependsOn ( nodes = depends_on_nodes ) , resource_type = NodeType . Test , checksum = FileHash . from_contents ( [string] ) , ) [EOL] [EOL] [EOL] def make_report ( pkg , name , path = None , fqn_extras = None , owner = None ) : [EOL] if path is None : [EOL] path = [string] [EOL] [EOL] if fqn_extras is None : [EOL] fqn_extras = [ ] [EOL] [EOL] if owner is None : [EOL] owner = ReportOwner ( email = [string] ) [EOL] [EOL] fqn = [ pkg , [string] ] + fqn_extras + [ name ] [EOL] return ParsedReport ( name = name , type = ExposureType . Notebook , fqn = fqn , unique_id = f' [string] { pkg } [string] { name }' , package_name = pkg , path = path , root_path = [string] , original_file_path = path , owner = owner , ) [EOL] [EOL] [EOL] @ pytest . fixture def seed ( ) : [EOL] return make_seed ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def source ( ) : [EOL] return make_source ( [string] , [string] , [string] , identifier = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def ephemeral_model ( source ) : [EOL] return make_model ( [string] , [string] , [string] , config_kwargs = { [string] : [string] } , sources = [ source ] , ) [EOL] [EOL] [EOL] @ pytest . fixture def view_model ( ephemeral_model ) : [EOL] return make_model ( [string] , [string] , [string] , config_kwargs = { [string] : [string] } , refs = [ ephemeral_model ] , tags = [ [string] ] , ) [EOL] [EOL] [EOL] @ pytest . fixture def table_model ( ephemeral_model ) : [EOL] return make_model ( [string] , [string] , [string] , config_kwargs = { [string] : [string] } , refs = [ ephemeral_model ] , tags = [ [string] ] , path = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def ext_source ( ) : [EOL] return make_source ( [string] , [string] , [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def ext_source_2 ( ) : [EOL] return make_source ( [string] , [string] , [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def ext_source_other ( ) : [EOL] return make_source ( [string] , [string] , [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def ext_source_other_2 ( ) : [EOL] return make_source ( [string] , [string] , [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def ext_model ( ext_source ) : [EOL] return make_model ( [string] , [string] , [string] , sources = [ ext_source ] , ) [EOL] [EOL] [EOL] @ pytest . fixture def union_model ( seed , ext_source ) : [EOL] return make_model ( [string] , [string] , [string] , config_kwargs = { [string] : [string] } , refs = [ seed ] , sources = [ ext_source ] , fqn_extras = [ [string] ] , path = [string] , tags = [ [string] ] , ) [EOL] [EOL] [EOL] @ pytest . fixture def table_id_unique ( table_model ) : [EOL] return make_unique_test ( [string] , table_model , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def table_id_not_null ( table_model ) : [EOL] return make_not_null_test ( [string] , table_model , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def view_id_unique ( view_model ) : [EOL] return make_unique_test ( [string] , view_model , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def ext_source_id_unique ( ext_source ) : [EOL] return make_unique_test ( [string] , ext_source , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def view_test_nothing ( view_model ) : [EOL] return make_data_test ( [string] , [string] , [string] , refs = [ view_model ] ) [EOL] [EOL] [EOL] @ pytest . fixture def manifest ( seed , source , ephemeral_model , view_model , table_model , ext_source , ext_model , union_model , ext_source_2 , ext_source_other , ext_source_other_2 , table_id_unique , table_id_not_null , view_id_unique , ext_source_id_unique , view_test_nothing ) : [EOL] nodes = [ seed , ephemeral_model , view_model , table_model , union_model , ext_model , table_id_unique , table_id_not_null , view_id_unique , ext_source_id_unique , view_test_nothing ] [EOL] sources = [ source , ext_source , ext_source_2 , ext_source_other , ext_source_other_2 ] [EOL] manifest = Manifest ( nodes = { n . unique_id : n for n in nodes } , sources = { s . unique_id : s for s in sources } , macros = { } , docs = { } , files = { } , reports = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , ) [EOL] return manifest [EOL] [EOL] [EOL] def search_manifest_using_method ( manifest , method , selection ) : [EOL] selected = method . search ( set ( manifest . nodes ) | set ( manifest . sources ) | set ( manifest . reports ) , selection ) [EOL] results = { manifest . expect ( uid ) . search_name for uid in selected } [EOL] return results [EOL] [EOL] [EOL] def test_select_fqn ( manifest ) : [EOL] methods = MethodManager ( manifest , None ) [EOL] method = methods . get_method ( [string] , [ ] ) [EOL] assert isinstance ( method , QualifiedNameSelectorMethod ) [EOL] assert method . arguments == [ ] [EOL] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [comment] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] , [string] , [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] [EOL] [EOL] def test_select_tag ( manifest ) : [EOL] methods = MethodManager ( manifest , None ) [EOL] method = methods . get_method ( [string] , [ ] ) [EOL] assert isinstance ( method , TagSelectorMethod ) [EOL] assert method . arguments == [ ] [EOL] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_source ( manifest ) : [EOL] methods = MethodManager ( manifest , None ) [EOL] method = methods . get_method ( [string] , [ ] ) [EOL] assert isinstance ( method , SourceSelectorMethod ) [EOL] assert method . arguments == [ ] [EOL] [EOL] [comment] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] , [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . skip ( [string] ) def test_select_path ( manifest ) : [EOL] methods = MethodManager ( manifest , None ) [EOL] method = methods . get_method ( [string] , [ ] ) [EOL] assert isinstance ( method , PathSelectorMethod ) [EOL] assert method . arguments == [ ] [EOL] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_package ( manifest ) : [EOL] methods = MethodManager ( manifest , None ) [EOL] method = methods . get_method ( [string] , [ ] ) [EOL] assert isinstance ( method , PackageSelectorMethod ) [EOL] assert method . arguments == [ ] [EOL] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_config_materialized ( manifest ) : [EOL] methods = MethodManager ( manifest , None ) [EOL] method = methods . get_method ( [string] , [ [string] ] ) [EOL] assert isinstance ( method , ConfigSelectorMethod ) [EOL] assert method . arguments == [ [string] ] [EOL] [EOL] [comment] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] , [string] , [string] , [string] , [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] } [EOL] [EOL] [EOL] def test_select_test_name ( manifest ) : [EOL] methods = MethodManager ( manifest , None ) [EOL] method = methods . get_method ( [string] , [ ] ) [EOL] assert isinstance ( method , TestNameSelectorMethod ) [EOL] assert method . arguments == [ ] [EOL] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_test_type ( manifest ) : [EOL] methods = MethodManager ( manifest , None ) [EOL] method = methods . get_method ( [string] , [ ] ) [EOL] assert isinstance ( method , TestTypeSelectorMethod ) [EOL] assert method . arguments == [ ] [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] , [string] , [string] , [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] [EOL] [EOL] def test_select_report ( manifest ) : [EOL] report = make_report ( [string] , [string] ) [EOL] manifest . reports [ report . unique_id ] = report [EOL] methods = MethodManager ( manifest , None ) [EOL] method = methods . get_method ( [string] , [ ] ) [EOL] assert isinstance ( method , ReportSelectorMethod ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def previous_state ( manifest ) : [EOL] writable = copy . deepcopy ( manifest ) . writable_manifest ( ) [EOL] state = PreviousState ( Path ( [string] ) ) [EOL] state . manifest = writable [EOL] return state [EOL] [EOL] [EOL] def add_node ( manifest , node ) : [EOL] manifest . nodes [ node . unique_id ] = node [EOL] [EOL] [EOL] def change_node ( manifest , node , change = None ) : [EOL] if change is not None : [EOL] node = change ( node ) [EOL] manifest . nodes [ node . unique_id ] = node [EOL] [EOL] [EOL] def statemethod ( manifest , previous_state ) : [EOL] methods = MethodManager ( manifest , previous_state ) [EOL] method = methods . get_method ( [string] , [ ] ) [EOL] assert isinstance ( method , StateSelectorMethod ) [EOL] assert method . arguments == [ ] [EOL] return method [EOL] [EOL] [EOL] def test_select_state_no_change ( manifest , previous_state ) : [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_nothing ( manifest , previous_state ) : [EOL] previous_state . manifest = None [EOL] method = statemethod ( manifest , previous_state ) [EOL] with pytest . raises ( dbt . exceptions . RuntimeException ) as exc : [EOL] search_manifest_using_method ( manifest , method , [string] ) [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] with pytest . raises ( dbt . exceptions . RuntimeException ) as exc : [EOL] search_manifest_using_method ( manifest , method , [string] ) [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] [EOL] def test_select_state_added_model ( manifest , previous_state ) : [EOL] add_node ( manifest , make_model ( [string] , [string] , [string] ) ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] [EOL] [EOL] def test_select_state_changed_model_sql ( manifest , previous_state , view_model ) : [EOL] change_node ( manifest , view_model . replace ( raw_sql = [string] ) ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_changed_model_fqn ( manifest , previous_state , view_model ) : [EOL] change_node ( manifest , view_model . replace ( fqn = view_model . fqn [ : - [number] ] + [ [string] ] + view_model . fqn [ - [number] : ] ) ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_added_seed ( manifest , previous_state ) : [EOL] add_node ( manifest , make_seed ( [string] , [string] ) ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] [EOL] [EOL] def test_select_state_changed_seed_checksum_sha_to_sha ( manifest , previous_state , seed ) : [EOL] change_node ( manifest , seed . replace ( checksum = FileHash . from_contents ( [string] ) ) ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_checksum_path_to_path ( manifest , previous_state , seed ) : [EOL] change_node ( previous_state . manifest , seed . replace ( checksum = FileHash ( name = [string] , checksum = seed . original_file_path ) ) ) [EOL] change_node ( manifest , seed . replace ( checksum = FileHash ( name = [string] , checksum = seed . original_file_path ) ) ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] with mock . patch ( [string] ) as warn_or_error_patch : [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] warn_or_error_patch . assert_called_once ( ) [EOL] msg = warn_or_error_patch . call_args [ [number] ] [ [number] ] [EOL] assert msg . startswith ( [string] ) [EOL] with mock . patch ( [string] ) as warn_or_error_patch : [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] warn_or_error_patch . assert_not_called ( ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_checksum_sha_to_path ( manifest , previous_state , seed ) : [EOL] change_node ( manifest , seed . replace ( checksum = FileHash ( name = [string] , checksum = seed . original_file_path ) ) ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] with mock . patch ( [string] ) as warn_or_error_patch : [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] warn_or_error_patch . assert_called_once ( ) [EOL] msg = warn_or_error_patch . call_args [ [number] ] [ [number] ] [EOL] assert msg . startswith ( [string] ) [EOL] with mock . patch ( [string] ) as warn_or_error_patch : [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] warn_or_error_patch . assert_not_called ( ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_checksum_path_to_sha ( manifest , previous_state , seed ) : [EOL] change_node ( previous_state . manifest , seed . replace ( checksum = FileHash ( name = [string] , checksum = seed . original_file_path ) ) ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] with mock . patch ( [string] ) as warn_or_error_patch : [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] warn_or_error_patch . assert_not_called ( ) [EOL] with mock . patch ( [string] ) as warn_or_error_patch : [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] warn_or_error_patch . assert_not_called ( ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_fqn ( manifest , previous_state , seed ) : [EOL] change_node ( manifest , seed . replace ( fqn = seed . fqn [ : - [number] ] + [ [string] ] + seed . fqn [ - [number] : ] ) ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_relation_documented ( manifest , previous_state , seed ) : [EOL] seed_doc_relation = replace_config ( seed , persist_docs = { [string] : True } ) [EOL] change_node ( manifest , seed_doc_relation ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_relation_documented_nodocs ( manifest , previous_state , seed ) : [EOL] seed_doc_relation = replace_config ( seed , persist_docs = { [string] : True } ) [EOL] seed_doc_relation_documented = seed_doc_relation . replace ( description = [string] ) [EOL] change_node ( previous_state . manifest , seed_doc_relation ) [EOL] change_node ( manifest , seed_doc_relation_documented ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_relation_documented_withdocs ( manifest , previous_state , seed ) : [EOL] seed_doc_relation = replace_config ( seed , persist_docs = { [string] : True } ) [EOL] seed_doc_relation_documented = seed_doc_relation . replace ( description = [string] ) [EOL] change_node ( previous_state . manifest , seed_doc_relation_documented ) [EOL] change_node ( manifest , seed_doc_relation ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_columns_documented ( manifest , previous_state , seed ) : [EOL] [comment] [EOL] seed_doc_columns = replace_config ( seed , persist_docs = { [string] : True } ) [EOL] change_node ( manifest , seed_doc_columns ) [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_columns_documented_nodocs ( manifest , previous_state , seed ) : [EOL] seed_doc_columns = replace_config ( seed , persist_docs = { [string] : True } ) [EOL] seed_doc_columns_documented_columns = seed_doc_columns . replace ( columns = { [string] : ColumnInfo ( name = [string] , description = [string] ) } , ) [EOL] [EOL] change_node ( previous_state . manifest , seed_doc_columns ) [EOL] change_node ( manifest , seed_doc_columns_documented_columns ) [EOL] [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL] [EOL] [EOL] def test_select_state_changed_seed_columns_documented_withdocs ( manifest , previous_state , seed ) : [EOL] seed_doc_columns = replace_config ( seed , persist_docs = { [string] : True } ) [EOL] seed_doc_columns_documented_columns = seed_doc_columns . replace ( columns = { [string] : ColumnInfo ( name = [string] , description = [string] ) } , ) [EOL] [EOL] change_node ( manifest , seed_doc_columns ) [EOL] change_node ( previous_state . manifest , seed_doc_columns_documented_columns ) [EOL] [EOL] method = statemethod ( manifest , previous_state ) [EOL] assert search_manifest_using_method ( manifest , method , [string] ) == { [string] } [EOL] assert not search_manifest_using_method ( manifest , method , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from unittest import mock [EOL] [EOL] from dbt . adapters . base import BaseAdapter [EOL] from contextlib import contextmanager [EOL] [EOL] [EOL] def adapter_factory ( ) : [EOL] class MockAdapter ( BaseAdapter ) : [EOL] ConnectionManager = mock . MagicMock ( TYPE = [string] ) [EOL] responder = mock . MagicMock ( ) [EOL] [comment] [EOL] responder . quote . side_effect = lambda identifier : [string] . format ( identifier ) [EOL] responder . date_function . side_effect = lambda : [string] [EOL] responder . is_cancelable . side_effect = lambda : False [EOL] [EOL] @ contextmanager def exception_handler ( self , * args , ** kwargs ) : [EOL] self . responder . exception_handler ( * args , ** kwargs ) [EOL] yield [EOL] [EOL] def execute ( self , * args , ** kwargs ) : [EOL] return self . responder . execute ( * args , ** kwargs ) [EOL] [EOL] def drop_relation ( self , * args , ** kwargs ) : [EOL] return self . responder . drop_relation ( * args , ** kwargs ) [EOL] [EOL] def truncate_relation ( self , * args , ** kwargs ) : [EOL] return self . responder . truncate_relation ( * args , ** kwargs ) [EOL] [EOL] def rename_relation ( self , * args , ** kwargs ) : [EOL] return self . responder . rename_relation ( * args , ** kwargs ) [EOL] [EOL] def get_columns_in_relation ( self , * args , ** kwargs ) : [EOL] return self . responder . get_columns_in_relation ( * args , ** kwargs ) [EOL] [EOL] def expand_column_types ( self , * args , ** kwargs ) : [EOL] return self . responder . expand_column_types ( * args , ** kwargs ) [EOL] [EOL] def list_relations_without_caching ( self , * args , ** kwargs ) : [EOL] return self . responder . list_relations_without_caching ( * args , ** kwargs ) [EOL] [EOL] def create_schema ( self , * args , ** kwargs ) : [EOL] return self . responder . create_schema ( * args , ** kwargs ) [EOL] [EOL] def drop_schema ( self , * args , ** kwargs ) : [EOL] return self . responder . drop_schema ( * args , ** kwargs ) [EOL] [EOL] @ classmethod def quote ( cls , identifier ) : [EOL] return cls . responder . quote ( identifier ) [EOL] [EOL] def convert_text_type ( self , * args , ** kwargs ) : [EOL] return self . responder . convert_text_type ( * args , ** kwargs ) [EOL] [EOL] def convert_number_type ( self , * args , ** kwargs ) : [EOL] return self . responder . convert_number_type ( * args , ** kwargs ) [EOL] [EOL] def convert_boolean_type ( self , * args , ** kwargs ) : [EOL] return self . responder . convert_boolean_type ( * args , ** kwargs ) [EOL] [EOL] def convert_datetime_type ( self , * args , ** kwargs ) : [EOL] return self . responder . convert_datetime_type ( * args , ** kwargs ) [EOL] [EOL] def convert_date_type ( self , * args , ** kwargs ) : [EOL] return self . responder . convert_date_type ( * args , ** kwargs ) [EOL] [EOL] def convert_time_type ( self , * args , ** kwargs ) : [EOL] return self . responder . convert_time_type ( * args , ** kwargs ) [EOL] [EOL] def list_schemas ( self , * args , ** kwargs ) : [EOL] return self . responder . list_schemas ( * args , ** kwargs ) [EOL] [EOL] @ classmethod def date_function ( cls ) : [EOL] return cls . responder . date_function ( ) [EOL] [EOL] @ classmethod def is_cancelable ( cls ) : [EOL] return cls . responder . is_cancelable ( ) [EOL] [EOL] return MockAdapter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Dict , Tuple [EOL] import typing [EOL] from contextlib import contextmanager [EOL] import pytest [EOL] import unittest [EOL] import yaml [EOL] [EOL] from dbt . clients . jinja import get_rendered [EOL] from dbt . clients . jinja import get_template [EOL] from dbt . clients . jinja import extract_toplevel_blocks [EOL] from dbt . exceptions import CompilationException , JinjaRenderingException [EOL] [EOL] [EOL] @ contextmanager def returns ( value ) : [EOL] yield value [EOL] [EOL] [EOL] @ contextmanager def raises ( value ) : [EOL] with pytest . raises ( value ) as exc : [EOL] yield exc [EOL] [EOL] [EOL] def expected_id ( arg ) : [EOL] if isinstance ( arg , list ) : [EOL] return [string] . join ( arg ) [EOL] [EOL] [EOL] jinja_tests = [ ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , raises ( JinjaRenderingException ) , ) , ( [string] , returns ( [string] ) , raises ( JinjaRenderingException ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , raises ( JinjaRenderingException ) , ) , ( [string] , returns ( [string] ) , returns ( [number] ) , ) , ( [string] , returns ( [string] ) , returns ( [number] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , raises ( JinjaRenderingException ) , ) , ( [string] , returns ( [string] ) , returns ( [number] ) , ) , ( [string] , returns ( [string] ) , returns ( [number] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( True ) , ) , ( [string] , returns ( [string] ) , raises ( JinjaRenderingException ) , ) , ( [string] , returns ( [string] ) , returns ( True ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( True ) , ) , ( [string] , returns ( [string] ) , raises ( JinjaRenderingException ) , ) , ( [string] , returns ( [string] ) , returns ( True ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( True ) , ) , ( [string] , returns ( [string] ) , raises ( JinjaRenderingException ) , ) , ( [string] , returns ( [string] ) , returns ( True ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( True ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [number] ) , ) , ( [string] , returns ( [string] ) , returns ( [number] ) , ) , ( [string] , returns ( [string] ) , returns ( [number] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( None ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ( [string] , returns ( [string] ) , returns ( [string] ) , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , jinja_tests , ids = expected_id ) def test_jinja_rendering ( value , text_expectation , native_expectation ) : [EOL] foo_value = yaml . safe_load ( value ) [ [string] ] [EOL] ctx = { [string] : [string] , [string] : [number] , [string] : [string] } [EOL] with text_expectation as text_result : [EOL] assert text_result == get_rendered ( foo_value , ctx , native = False ) [EOL] [EOL] with native_expectation as native_result : [EOL] assert native_result == get_rendered ( foo_value , ctx , native = True ) [EOL] [EOL] [EOL] class TestJinja ( unittest . TestCase ) : [EOL] def test_do ( self ) : [EOL] s = [string] [EOL] [EOL] template = get_template ( s , { } ) [EOL] mod = template . make_module ( ) [EOL] self . assertEqual ( mod . my_dict , { [string] : [number] } ) [EOL] [EOL] def test_regular_render ( self ) : [EOL] s = [string] [EOL] value = get_rendered ( s , { } , native = False ) [EOL] assert value == [string] [EOL] s = [string] [EOL] value = get_rendered ( s , { } , native = False ) [EOL] assert value == [string] [EOL] [EOL] s = [string] [EOL] value = get_rendered ( s , { } , native = False ) [EOL] assert value == [string] [EOL] s = [string] [EOL] value = get_rendered ( s , { } , native = False ) [EOL] assert value == [string] [EOL] [EOL] def test_native_render ( self ) : [EOL] s = [string] [EOL] value = get_rendered ( s , { } , native = True ) [EOL] assert value == [string] [EOL] s = [string] [EOL] value = get_rendered ( s , { } , native = True ) [EOL] assert value == [number] [EOL] [EOL] s = [string] [EOL] value = get_rendered ( s , { } , native = True ) [EOL] assert value == [string] [EOL] s = [string] [EOL] value = get_rendered ( s , { } , native = True ) [EOL] assert value == [string] [EOL] [EOL] [EOL] class TestBlockLexer ( unittest . TestCase ) : [EOL] def test_basic ( self ) : [EOL] body = [string] [EOL] block_data = [string] + body + [string] [EOL] blocks = extract_toplevel_blocks ( block_data , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , body ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , block_data ) [EOL] [EOL] def test_multiple ( self ) : [EOL] body_one = [string] [EOL] body_two = ( [string] [string] ) [EOL] [EOL] block_data = ( [string] + body_one + [string] + [string] + body_two + [string] ) [EOL] blocks = extract_toplevel_blocks ( block_data , allowed_blocks = { [string] , [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] [EOL] def test_comments ( self ) : [EOL] body = [string] [EOL] comment = [string] [EOL] block_data = [string] + body + [string] [EOL] blocks = extract_toplevel_blocks ( comment + block_data , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , body ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , block_data ) [EOL] [EOL] def test_evil_comments ( self ) : [EOL] body = [string] [EOL] comment = [string] [EOL] block_data = [string] + body + [string] [EOL] blocks = extract_toplevel_blocks ( comment + block_data , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , body ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , block_data ) [EOL] [EOL] def test_nested_comments ( self ) : [EOL] body = [string] [EOL] block_data = [string] + body + [string] [EOL] comment = [string] [EOL] blocks = extract_toplevel_blocks ( comment + block_data , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , body ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , block_data ) [EOL] [EOL] def test_complex_file ( self ) : [EOL] blocks = extract_toplevel_blocks ( complex_snapshot_file , allowed_blocks = { [string] , [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , bar_block ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , bar_block [ [number] : - [number] ] . rstrip ( ) ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , x_block . strip ( ) ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , x_block [ len ( [string] ) : - len ( [string] ) ] ) [EOL] [EOL] def test_peaceful_macro_coexistence ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] , [string] } , collect_raw_data = True ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] [EOL] def test_macro_with_trailing_data ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] , [string] } , collect_raw_data = True ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] [EOL] def test_macro_with_crazy_args ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] [EOL] def test_materialization_parse ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , body ) [EOL] [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , body ) [EOL] [EOL] def test_nested_not_ok ( self ) : [EOL] [comment] [EOL] body = [string] [EOL] with self . assertRaises ( CompilationException ) : [EOL] extract_toplevel_blocks ( body , allowed_blocks = { [string] } ) [EOL] [EOL] def test_incomplete_block_failure ( self ) : [EOL] fullbody = [string] [EOL] for length in range ( len ( [string] ) , len ( fullbody ) - [number] ) : [EOL] body = fullbody [ : length ] [EOL] with self . assertRaises ( CompilationException ) : [EOL] extract_toplevel_blocks ( body , allowed_blocks = { [string] } ) [EOL] [EOL] def test_wrong_end_failure ( self ) : [EOL] body = [string] [EOL] with self . assertRaises ( CompilationException ) : [EOL] extract_toplevel_blocks ( body , allowed_blocks = { [string] , [string] } ) [EOL] [EOL] def test_comment_no_end_failure ( self ) : [EOL] body = [string] [EOL] with self . assertRaises ( CompilationException ) : [EOL] extract_toplevel_blocks ( body ) [EOL] [EOL] def test_comment_only ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] blocks = extract_toplevel_blocks ( body , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] [EOL] def test_comment_block_self_closing ( self ) : [EOL] [comment] [EOL] [comment] [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] [EOL] def test_embedded_self_closing_comment_block ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , body ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] [EOL] def test_set_statement ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] [EOL] def test_set_block ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] [EOL] def test_crazy_set_statement ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] [EOL] def test_do_statement ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] [EOL] def test_deceptive_do_statement ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] [EOL] def test_do_block ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] , [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] [EOL] def test_crazy_do_statement ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] , [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] [EOL] def test_awful_jinja ( self ) : [EOL] blocks = extract_toplevel_blocks ( if_you_do_this_you_are_awful , allowed_blocks = { [string] , [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( len ( [ b for b in blocks if b . block_type_name == [string] ] ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] . join ( [ [string] , [string] , [string] , [string] , [string] ] ) ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] [EOL] def test_quoted_endblock_within_block ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] [EOL] def test_docs_block ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] [EOL] def test_docs_block_expr ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] [EOL] def test_unclosed_model_quotes ( self ) : [EOL] [comment] [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body , allowed_blocks = { [string] } , collect_raw_data = False ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_type_name , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . contents , [string] ) [EOL] self . assertEqual ( blocks [ [number] ] . block_name , [string] ) [EOL] [EOL] def test_if ( self ) : [EOL] [comment] [EOL] body = [string] [EOL] with self . assertRaises ( CompilationException ) : [EOL] extract_toplevel_blocks ( body ) [EOL] [EOL] def test_if_innocuous ( self ) : [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , body ) [EOL] [EOL] def test_for ( self ) : [EOL] [comment] [EOL] body = [string] [EOL] with self . assertRaises ( CompilationException ) : [EOL] extract_toplevel_blocks ( body ) [EOL] [EOL] def test_for_innocuous ( self ) : [EOL] [comment] [EOL] body = [string] [EOL] blocks = extract_toplevel_blocks ( body ) [EOL] self . assertEqual ( len ( blocks ) , [number] ) [EOL] self . assertEqual ( blocks [ [number] ] . full_block , body ) [EOL] [EOL] def test_endif ( self ) : [EOL] body = [string] [EOL] with self . assertRaises ( CompilationException ) as err : [EOL] extract_toplevel_blocks ( body ) [EOL] self . assertIn ( [string] , str ( err . exception ) ) [EOL] [EOL] def test_if_endfor ( self ) : [EOL] body = [string] [EOL] with self . assertRaises ( CompilationException ) as err : [EOL] extract_toplevel_blocks ( body ) [EOL] self . assertIn ( [string] , str ( err . exception ) ) [EOL] [EOL] def test_if_endfor_newlines ( self ) : [EOL] body = [string] [EOL] with self . assertRaises ( CompilationException ) as err : [EOL] extract_toplevel_blocks ( body ) [EOL] self . assertIn ( [string] , str ( err . exception ) ) [EOL] [EOL] [EOL] bar_block = [string] [EOL] [EOL] x_block = [string] [EOL] [EOL] complex_snapshot_file = [string] + bar_block + x_block [EOL] [EOL] [EOL] if_you_do_this_you_are_awful = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] import decimal [EOL] [EOL] from dbt . adapters . base import Column [EOL] [EOL] class TestStringType ( unittest . TestCase ) : [EOL] [EOL] def test__character_type ( self ) : [EOL] col = Column ( [string] , [string] , char_size = [number] ) [EOL] [EOL] self . assertEqual ( col . data_type , [string] ) [EOL] [EOL] [EOL] class TestNumericType ( unittest . TestCase ) : [EOL] [EOL] def test__numeric_type ( self ) : [EOL] col = Column ( [string] , [string] , numeric_precision = decimal . Decimal ( [string] ) , numeric_scale = decimal . Decimal ( [string] ) ) [EOL] [EOL] self . assertEqual ( col . data_type , [string] ) [EOL] [EOL] def test__numeric_type_with_no_precision ( self ) : [EOL] [comment] [EOL] col = Column ( [string] , [string] , numeric_precision = None ) [EOL] [EOL] self . assertEqual ( col . data_type , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Union , Any , Dict [EOL] import typing [EOL] import re [EOL] from unittest import TestCase , mock [EOL] [EOL] from dbt . adapters . base . query_headers import MacroQueryStringSetter [EOL] [EOL] from test . unit . utils import config_from_parts_or_dicts [EOL] [EOL] [EOL] class TestQueryHeaders ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . profile_cfg = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] } , } , [string] : [string] } [EOL] self . project_cfg = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] self . query = [string] [EOL] [EOL] def test_comment_should_prepend_query_by_default ( self ) : [EOL] config = config_from_parts_or_dicts ( self . project_cfg , self . profile_cfg ) [EOL] query_header = MacroQueryStringSetter ( config , mock . MagicMock ( macros = { } ) ) [EOL] sql = query_header . add ( self . query ) [EOL] self . assertTrue ( re . match ( f' [string] { self . query } [string] ' , sql ) ) [EOL] [EOL] [EOL] def test_append_comment ( self ) : [EOL] self . project_cfg . update ( { [string] : { [string] : [string] , [string] : True } } ) [EOL] config = config_from_parts_or_dicts ( self . project_cfg , self . profile_cfg ) [EOL] query_header = MacroQueryStringSetter ( config , mock . MagicMock ( macros = { } ) ) [EOL] sql = query_header . add ( self . query ) [EOL] self . assertEqual ( sql , f'{ self . query [ : - [number] ] } [string] ' ) [EOL] [EOL] def test_disable_query_comment ( self ) : [EOL] self . project_cfg . update ( { [string] : [string] } ) [EOL] config = config_from_parts_or_dicts ( self . project_cfg , self . profile_cfg ) [EOL] query_header = MacroQueryStringSetter ( config , mock . MagicMock ( macros = { } ) ) [EOL] self . assertEqual ( query_header . add ( self . query ) , self . query ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import test [EOL] import typing [EOL] import os [EOL] import shutil [EOL] import tempfile [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import yaml [EOL] [EOL] from dbt import main [EOL] [EOL] [EOL] class FakeArgs : [EOL] def __init__ ( self , profiles_dir ) : [EOL] self . profiles_dir = profiles_dir [EOL] self . profile = [string] [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) @ mock . patch ( [string] ) class TestInitializeConfig ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . base_dir = tempfile . mkdtemp ( ) [EOL] self . profiles_path = os . path . join ( self . base_dir , [string] ) [EOL] self . args = FakeArgs ( self . base_dir ) [EOL] [EOL] def _base_config ( self ) : [EOL] return { [string] : { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , } , [string] : [string] , } } [EOL] [EOL] def set_up_empty_config ( self ) : [EOL] with open ( self . profiles_path , [string] ) as f : [EOL] f . write ( yaml . dump ( self . _base_config ( ) ) ) [EOL] [EOL] def set_up_config_options ( self , ** kwargs ) : [EOL] config = self . _base_config ( ) [EOL] config . update ( config = kwargs ) [EOL] with open ( self . profiles_path , [string] ) as f : [EOL] f . write ( yaml . dump ( config ) ) [EOL] [EOL] def tearDown ( self ) : [EOL] try : [EOL] shutil . rmtree ( self . base_dir ) [EOL] except : [EOL] pass [EOL] [EOL] def test__implicit_missing ( self , initialize_tracking , do_not_track , use_colors ) : [EOL] main . initialize_config_values ( self . args ) [EOL] [EOL] initialize_tracking . assert_called_once_with ( self . base_dir ) [EOL] do_not_track . assert_not_called ( ) [EOL] use_colors . assert_not_called ( ) [EOL] [EOL] def test__implicit_opt_in_colors ( self , initialize_tracking , do_not_track , use_colors ) : [EOL] self . set_up_empty_config ( ) [EOL] main . initialize_config_values ( self . args ) [EOL] [EOL] initialize_tracking . assert_called_once_with ( self . base_dir ) [EOL] do_not_track . assert_not_called ( ) [EOL] use_colors . assert_not_called ( ) [EOL] [EOL] def test__explicit_opt_out ( self , initialize_tracking , do_not_track , use_colors ) : [EOL] self . set_up_config_options ( send_anonymous_usage_stats = False ) [EOL] main . initialize_config_values ( self . args ) [EOL] [EOL] initialize_tracking . assert_not_called ( ) [EOL] do_not_track . assert_called_once_with ( ) [EOL] use_colors . assert_not_called ( ) [EOL] [EOL] def test__explicit_opt_in ( self , initialize_tracking , do_not_track , use_colors ) : [EOL] self . set_up_config_options ( send_anonymous_usage_stats = True ) [EOL] main . initialize_config_values ( self . args ) [EOL] [EOL] initialize_tracking . assert_called_once_with ( self . base_dir ) [EOL] do_not_track . assert_not_called ( ) [EOL] use_colors . assert_not_called ( ) [EOL] [EOL] def test__explicit_no_colors ( self , initialize_tracking , do_not_track , use_colors ) : [EOL] self . set_up_config_options ( use_colors = False ) [EOL] main . initialize_config_values ( self . args ) [EOL] [EOL] initialize_tracking . assert_called_once_with ( self . base_dir ) [EOL] do_not_track . assert_not_called ( ) [EOL] use_colors . assert_called_once_with ( False ) [EOL] [EOL] def test__explicit_yes_colors ( self , initialize_tracking , do_not_track , use_colors ) : [EOL] self . set_up_config_options ( use_colors = True ) [EOL] main . initialize_config_values ( self . args ) [EOL] [EOL] initialize_tracking . assert_called_once_with ( self . base_dir ) [EOL] do_not_track . assert_not_called ( ) [EOL] use_colors . assert_called_once_with ( True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.unit.test_main.FakeArgs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , Set [EOL] import unittest [EOL] import itertools [EOL] import builtins [EOL] import typing [EOL] import itertools [EOL] import unittest [EOL] import os [EOL] from typing import Set , Dict , Any [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] [EOL] [comment] [EOL] from dbt . adapters import postgres , redshift [EOL] from dbt . adapters import factory [EOL] from dbt . adapters . base import AdapterConfig [EOL] from dbt . clients . jinja import MacroStack [EOL] from dbt . contracts . graph . parsed import ( ParsedModelNode , NodeConfig , DependsOn , ParsedMacro ) [EOL] from dbt . config . project import VarProvider [EOL] from dbt . context import base , target , configured , providers , docs , manifest , macros [EOL] from dbt . contracts . files import FileHash [EOL] from dbt . node_types import NodeType [EOL] import dbt . exceptions [EOL] from . utils import profile_from_dict , config_from_parts_or_dicts , inject_adapter , clear_plugin [EOL] from . mock_adapter import adapter_factory [EOL] [EOL] [EOL] class TestVar ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . model = ParsedModelNode ( alias = [string] , name = [string] , database = [string] , schema = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , original_file_path = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = NodeConfig . from_dict ( { [string] : True , [string] : [string] , [string] : { } , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : [ ] , } ) , tags = [ ] , path = [string] , raw_sql = [string] , description = [string] , columns = { } , checksum = FileHash . from_contents ( [string] ) , ) [EOL] self . context = mock . MagicMock ( ) [EOL] self . provider = VarProvider ( { } ) [EOL] self . config = mock . MagicMock ( config_version = [number] , vars = self . provider , cli_vars = { } , project_name = [string] ) [EOL] [EOL] def test_var_default_something ( self ) : [EOL] self . config . cli_vars = { [string] : [string] } [EOL] var = providers . RuntimeVar ( self . context , self . config , self . model ) [EOL] self . assertEqual ( var ( [string] ) , [string] ) [EOL] self . assertEqual ( var ( [string] , [string] ) , [string] ) [EOL] [EOL] def test_var_default_none ( self ) : [EOL] self . config . cli_vars = { [string] : None } [EOL] var = providers . RuntimeVar ( self . context , self . config , self . model ) [EOL] self . assertEqual ( var ( [string] ) , None ) [EOL] self . assertEqual ( var ( [string] , [string] ) , None ) [EOL] [EOL] def test_var_not_defined ( self ) : [EOL] var = providers . RuntimeVar ( self . context , self . config , self . model ) [EOL] [EOL] self . assertEqual ( var ( [string] , [string] ) , [string] ) [EOL] with self . assertRaises ( dbt . exceptions . CompilationException ) : [EOL] var ( [string] ) [EOL] [EOL] def test_parser_var_default_something ( self ) : [EOL] self . config . cli_vars = { [string] : [string] } [EOL] var = providers . ParseVar ( self . context , self . config , self . model ) [EOL] self . assertEqual ( var ( [string] ) , [string] ) [EOL] self . assertEqual ( var ( [string] , [string] ) , [string] ) [EOL] [EOL] def test_parser_var_default_none ( self ) : [EOL] self . config . cli_vars = { [string] : None } [EOL] var = providers . ParseVar ( self . context , self . config , self . model ) [EOL] self . assertEqual ( var ( [string] ) , None ) [EOL] self . assertEqual ( var ( [string] , [string] ) , None ) [EOL] [EOL] def test_parser_var_not_defined ( self ) : [EOL] [comment] [EOL] [comment] [EOL] var = providers . ParseVar ( self . context , self . config , self . model ) [EOL] [EOL] self . assertEqual ( var ( [string] , [string] ) , [string] ) [EOL] self . assertEqual ( var ( [string] ) , None ) [EOL] [EOL] [EOL] class TestParseWrapper ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . mock_config = mock . MagicMock ( ) [EOL] adapter_class = adapter_factory ( ) [EOL] self . mock_adapter = adapter_class ( self . mock_config ) [EOL] self . namespace = mock . MagicMock ( ) [EOL] self . wrapper = providers . ParseDatabaseWrapper ( self . mock_adapter , self . namespace ) [EOL] self . responder = self . mock_adapter . responder [EOL] [EOL] def test_unwrapped_method ( self ) : [EOL] self . assertEqual ( self . wrapper . quote ( [string] ) , [string] ) [EOL] self . responder . quote . assert_called_once_with ( [string] ) [EOL] [EOL] def test_wrapped_method ( self ) : [EOL] found = self . wrapper . get_relation ( [string] , [string] , [string] ) [EOL] self . assertEqual ( found , None ) [EOL] self . responder . get_relation . assert_not_called ( ) [EOL] [EOL] [EOL] class TestRuntimeWrapper ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . mock_config = mock . MagicMock ( ) [EOL] self . mock_config . quoting = { [string] : True , [string] : True , [string] : True } [EOL] adapter_class = adapter_factory ( ) [EOL] self . mock_adapter = adapter_class ( self . mock_config ) [EOL] self . namespace = mock . MagicMock ( ) [EOL] self . wrapper = providers . RuntimeDatabaseWrapper ( self . mock_adapter , self . namespace ) [EOL] self . responder = self . mock_adapter . responder [EOL] [EOL] def test_unwrapped_method ( self ) : [EOL] [comment] [EOL] self . assertEqual ( self . wrapper . quote ( [string] ) , [string] ) [EOL] self . responder . quote . assert_called_once_with ( [string] ) [EOL] [EOL] def test_wrapped_method ( self ) : [EOL] rel = mock . MagicMock ( ) [EOL] rel . matches . return_value = True [EOL] self . responder . list_relations_without_caching . return_value = [ rel ] [EOL] [EOL] found = self . wrapper . get_relation ( [string] , [string] , [string] ) [EOL] [EOL] self . assertEqual ( found , rel ) [EOL] [EOL] self . responder . list_relations_without_caching . assert_called_once_with ( mock . ANY ) [EOL] [comment] [EOL] assert len ( self . responder . list_relations_without_caching . mock_calls ) == [number] [EOL] assert len ( self . responder . list_relations_without_caching . call_args [ [number] ] ) == [number] [EOL] arg = self . responder . list_relations_without_caching . call_args [ [number] ] [ [number] ] [EOL] assert arg . database == [string] [EOL] assert arg . schema == [string] [EOL] [EOL] [EOL] def assert_has_keys ( required_keys , maybe_keys , ctx ) : [EOL] keys = set ( ctx ) [EOL] for key in required_keys : [EOL] assert key in keys , f'{ key } [string] ' [EOL] keys . remove ( key ) [EOL] extras = keys . difference ( maybe_keys ) [EOL] assert not extras , f' [string] { extras }' [EOL] [EOL] [EOL] REQUIRED_BASE_KEYS = frozenset ( { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } ) [EOL] [EOL] REQUIRED_TARGET_KEYS = REQUIRED_BASE_KEYS | { [string] } [EOL] REQUIRED_DOCS_KEYS = REQUIRED_TARGET_KEYS | { [string] } | { [string] } [EOL] MACROS = frozenset ( { [string] , [string] , [string] , [string] } ) [EOL] REQUIRED_QUERY_HEADER_KEYS = REQUIRED_TARGET_KEYS | { [string] } | MACROS [EOL] REQUIRED_MACRO_KEYS = REQUIRED_QUERY_HEADER_KEYS | { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] REQUIRED_MODEL_KEYS = REQUIRED_MACRO_KEYS | { [string] } [EOL] MAYBE_KEYS = frozenset ( { [string] } ) [EOL] [EOL] [EOL] PROFILE_DATA = { [string] : [string] , [string] : { } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } , } [EOL] [EOL] PROJECT_DATA = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : os . getcwd ( ) , [string] : [number] , } [EOL] [EOL] [EOL] def model ( ) : [EOL] return ParsedModelNode ( alias = [string] , name = [string] , database = [string] , schema = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , original_file_path = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = NodeConfig . from_dict ( { [string] : True , [string] : [string] , [string] : { } , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : [ ] , } ) , tags = [ ] , path = [string] , raw_sql = [string] , description = [string] , columns = { } ) [EOL] [EOL] [EOL] def test_base_context ( ) : [EOL] ctx = base . generate_base_context ( { } ) [EOL] assert_has_keys ( REQUIRED_BASE_KEYS , MAYBE_KEYS , ctx ) [EOL] [EOL] [EOL] def test_target_context ( ) : [EOL] profile = profile_from_dict ( PROFILE_DATA , [string] ) [EOL] ctx = target . generate_target_context ( profile , { } ) [EOL] assert_has_keys ( REQUIRED_TARGET_KEYS , MAYBE_KEYS , ctx ) [EOL] [EOL] [EOL] def mock_macro ( name , package_name ) : [EOL] macro = mock . MagicMock ( __class__ = ParsedMacro , package_name = package_name , resource_type = [string] , unique_id = f' [string] { package_name } [string] { name }' , ) [EOL] [comment] [EOL] macro . name = name [EOL] return macro [EOL] [EOL] [EOL] def mock_manifest ( config ) : [EOL] manifest_macros = { } [EOL] for name in [ [string] , [string] ] : [EOL] macro = mock_macro ( name , config . project_name ) [EOL] manifest_macros [ macro . unique_id ] = macro [EOL] return mock . MagicMock ( macros = manifest_macros ) [EOL] [EOL] [EOL] def mock_model ( ) : [EOL] return mock . MagicMock ( __class__ = ParsedModelNode , alias = [string] , name = [string] , database = [string] , schema = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , original_file_path = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = NodeConfig . from_dict ( { [string] : True , [string] : [string] , [string] : { } , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : [ ] , } ) , tags = [ ] , path = [string] , raw_sql = [string] , description = [string] , columns = { } , ) [EOL] [EOL] [EOL] @ pytest . fixture def get_adapter ( ) : [EOL] with mock . patch . object ( providers , [string] ) as patch : [EOL] yield patch [EOL] [EOL] [EOL] @ pytest . fixture def get_include_paths ( ) : [EOL] with mock . patch . object ( factory , [string] ) as patch : [EOL] patch . return_value = [ ] [EOL] yield patch [EOL] [EOL] [EOL] @ pytest . fixture def config ( ) : [EOL] return config_from_parts_or_dicts ( PROJECT_DATA , PROFILE_DATA ) [EOL] [EOL] @ pytest . fixture def manifest_fx ( config ) : [EOL] return mock_manifest ( config ) [EOL] [EOL] [EOL] @ pytest . fixture def manifest_extended ( manifest_fx ) : [EOL] dbt_macro = mock_macro ( [string] , [string] ) [EOL] [comment] [EOL] rs_macro = mock_macro ( [string] , [string] ) [EOL] [comment] [EOL] package_default_macro = mock_macro ( [string] , [string] ) [EOL] package_rs_macro = mock_macro ( [string] , [string] ) [EOL] manifest_fx . macros [ dbt_macro . unique_id ] = dbt_macro [EOL] manifest_fx . macros [ rs_macro . unique_id ] = rs_macro [EOL] manifest_fx . macros [ package_default_macro . unique_id ] = package_default_macro [EOL] manifest_fx . macros [ package_rs_macro . unique_id ] = package_rs_macro [EOL] return manifest_fx [EOL] [EOL] [EOL] @ pytest . fixture def redshift_adapter ( config , get_adapter ) : [EOL] adapter = redshift . RedshiftAdapter ( config ) [EOL] inject_adapter ( adapter , redshift . Plugin ) [EOL] get_adapter . return_value = adapter [EOL] yield adapter [EOL] clear_plugin ( redshift . Plugin ) [EOL] [EOL] [EOL] @ pytest . fixture def postgres_adapter ( config , get_adapter ) : [EOL] adapter = postgres . PostgresAdapter ( config ) [EOL] inject_adapter ( adapter , postgres . Plugin ) [EOL] get_adapter . return_value = adapter [EOL] yield adapter [EOL] clear_plugin ( postgres . Plugin ) [EOL] [EOL] [EOL] def test_query_header_context ( config , manifest_fx ) : [EOL] ctx = manifest . generate_query_header_context ( config = config , manifest = manifest_fx , ) [EOL] assert_has_keys ( REQUIRED_QUERY_HEADER_KEYS , MAYBE_KEYS , ctx ) [EOL] [EOL] [EOL] def test_macro_parse_context ( config , manifest_fx , get_adapter , get_include_paths ) : [EOL] ctx = providers . generate_parser_macro ( macro = manifest_fx . macros [ [string] ] , config = config , manifest = manifest_fx , package_name = [string] , ) [EOL] assert_has_keys ( REQUIRED_MACRO_KEYS , MAYBE_KEYS , ctx ) [EOL] [EOL] [EOL] def test_macro_runtime_context ( config , manifest_fx , get_adapter , get_include_paths ) : [EOL] ctx = providers . generate_runtime_macro ( macro = manifest_fx . macros [ [string] ] , config = config , manifest = manifest_fx , package_name = [string] , ) [EOL] assert_has_keys ( REQUIRED_MACRO_KEYS , MAYBE_KEYS , ctx ) [EOL] [EOL] [EOL] def test_model_parse_context ( config , manifest_fx , get_adapter , get_include_paths ) : [EOL] ctx = providers . generate_parser_model ( model = mock_model ( ) , config = config , manifest = manifest_fx , context_config = mock . MagicMock ( ) , ) [EOL] assert_has_keys ( REQUIRED_MODEL_KEYS , MAYBE_KEYS , ctx ) [EOL] [EOL] [EOL] def test_model_runtime_context ( config , manifest_fx , get_adapter , get_include_paths ) : [EOL] ctx = providers . generate_runtime_model ( model = mock_model ( ) , config = config , manifest = manifest_fx , ) [EOL] assert_has_keys ( REQUIRED_MODEL_KEYS , MAYBE_KEYS , ctx ) [EOL] [EOL] [EOL] def test_docs_runtime_context ( config ) : [EOL] ctx = docs . generate_runtime_docs ( config , mock_model ( ) , [ ] , [string] ) [EOL] assert_has_keys ( REQUIRED_DOCS_KEYS , MAYBE_KEYS , ctx ) [EOL] [EOL] [EOL] def test_macro_namespace_duplicates ( config , manifest_fx ) : [EOL] mn = macros . MacroNamespaceBuilder ( [string] , [string] , MacroStack ( ) , [ [string] , [string] ] ) [EOL] mn . add_macros ( manifest_fx . macros . values ( ) , { } ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( dbt . exceptions . CompilationException ) : [EOL] mn . add_macro ( mock_macro ( [string] , [string] ) , { } ) [EOL] [EOL] [comment] [EOL] mn . add_macros ( mock_macro ( [string] , [string] ) , { } ) [EOL] [EOL] [EOL] def test_macro_namespace ( config , manifest_fx ) : [EOL] mn = macros . MacroNamespaceBuilder ( [string] , [string] , MacroStack ( ) , [ [string] , [string] ] ) [EOL] [EOL] dbt_macro = mock_macro ( [string] , [string] ) [EOL] [comment] [EOL] pg_macro = mock_macro ( [string] , [string] ) [EOL] [comment] [EOL] package_macro = mock_macro ( [string] , [string] ) [EOL] [EOL] all_macros = itertools . chain ( manifest_fx . macros . values ( ) , [ dbt_macro , pg_macro , package_macro ] ) [EOL] [EOL] namespace = mn . build_namespace ( all_macros , { } ) [EOL] dct = dict ( namespace ) [EOL] for result in [ dct , namespace ] : [EOL] assert [string] in result [EOL] assert [string] in result [EOL] assert [string] in result [EOL] assert [string] not in result [EOL] [comment] [EOL] assert len ( result ) == [number] [EOL] [comment] [EOL] assert set ( result ) == { [string] , [string] , [string] , [string] , [string] } [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert len ( result [ [string] ] ) == [number] [comment] [EOL] assert result [ [string] ] [ [string] ] . macro is pg_macro [EOL] assert result [ [string] ] [ [string] ] . macro is package_macro [EOL] assert result [ [string] ] . macro is package_macro [EOL] [EOL] [EOL] def test_resolve_specific ( config , manifest_extended , redshift_adapter , get_include_paths ) : [EOL] rs_macro = manifest_extended . macros [ [string] ] [EOL] package_rs_macro = manifest_extended . macros [ [string] ] [EOL] [EOL] ctx = providers . generate_runtime_model ( model = mock_model ( ) , config = config , manifest = manifest_extended , ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( dbt . exceptions . CompilationException ) : [EOL] ctx [ [string] ] . dispatch ( [string] ) . macro [EOL] [EOL] assert ctx [ [string] ] . dispatch ( [string] ) . macro is package_rs_macro [EOL] assert ctx [ [string] ] . dispatch ( [string] , packages = [ [string] ] ) . macro is rs_macro [EOL] assert ctx [ [string] ] . dispatch ( [string] , packages = [ [string] ] ) . macro is package_rs_macro [EOL] assert ctx [ [string] ] . dispatch ( [string] , packages = [ [string] , [string] ] ) . macro is package_rs_macro [EOL] assert ctx [ [string] ] . dispatch ( [string] , packages = [ [string] , [string] ] ) . macro is rs_macro [EOL] [EOL] [EOL] def test_resolve_default ( config , manifest_extended , postgres_adapter , get_include_paths ) : [EOL] dbt_macro = manifest_extended . macros [ [string] ] [EOL] package_macro = manifest_extended . macros [ [string] ] [EOL] [EOL] ctx = providers . generate_runtime_model ( model = mock_model ( ) , config = config , manifest = manifest_extended , ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( dbt . exceptions . CompilationException ) : [EOL] ctx [ [string] ] . dispatch ( [string] ) . macro [EOL] [EOL] assert ctx [ [string] ] . dispatch ( [string] ) . macro is package_macro [EOL] assert ctx [ [string] ] . dispatch ( [string] , packages = [ [string] ] ) . macro is dbt_macro [EOL] assert ctx [ [string] ] . dispatch ( [string] , packages = [ [string] ] ) . macro is package_macro [EOL] assert ctx [ [string] ] . dispatch ( [string] , packages = [ [string] , [string] ] ) . macro is package_macro [EOL] assert ctx [ [string] ] . dispatch ( [string] , packages = [ [string] , [string] ] ) . macro is dbt_macro [EOL] [EOL] [EOL] def test_resolve_errors ( config , manifest_extended , redshift_adapter , get_include_paths ) : [EOL] ctx = providers . generate_runtime_model ( model = mock_model ( ) , config = config , manifest = manifest_extended , ) [EOL] with pytest . raises ( dbt . exceptions . CompilationException ) as exc : [EOL] ctx [ [string] ] . dispatch ( [string] ) [EOL] assert [string] in str ( exc . value ) [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] with pytest . raises ( dbt . exceptions . CompilationException ) as exc : [EOL] ctx [ [string] ] . dispatch ( [string] ) [EOL] assert [string] in str ( exc . value ) [EOL] assert [string] in str ( exc . value ) [EOL] assert [string] in str ( exc . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import dbt [EOL] import typing [EOL] import os [EOL] import unittest [EOL] [EOL] from dbt . contracts . files import SourceFile , FileHash , FilePath [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . graph . parsed import ParsedDocumentation [EOL] from dbt . node_types import NodeType [EOL] from dbt . parser import docs [EOL] from dbt . parser . results import ParseResult [EOL] from dbt . parser . search import FileBlock [EOL] [EOL] from . utils import config_from_parts_or_dicts [EOL] [EOL] [EOL] SNOWPLOW_SESSIONS_DOCS = [string] [EOL] [EOL] SNOWPLOW_SESSIONS_SESSION_ID_DOCS = [string] [EOL] [EOL] SNOWPLOW_SESSIONS_BLOCK = [string] . format ( snowplow_sessions_docs = SNOWPLOW_SESSIONS_DOCS ) . strip ( ) [EOL] [EOL] [EOL] SNOWPLOW_SESSIONS_SESSION_ID_BLOCK = [string] . format ( snowplow_sessions_session_id_docs = SNOWPLOW_SESSIONS_SESSION_ID_DOCS ) . strip ( ) [EOL] [EOL] [EOL] TEST_DOCUMENTATION_FILE = [string] . format ( sessions_block = SNOWPLOW_SESSIONS_BLOCK , session_id_block = SNOWPLOW_SESSIONS_SESSION_ID_BLOCK , ) [EOL] [EOL] [EOL] MULTIPLE_RAW_BLOCKS = [string] [EOL] [EOL] [EOL] class DocumentationParserTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] if os . name == [string] : [EOL] self . root_path = [string] [EOL] self . subdir_path = [string] [EOL] self . testfile_path = [string] [EOL] else : [EOL] self . root_path = [string] [EOL] self . subdir_path = [string] [EOL] self . testfile_path = [string] [EOL] [EOL] profile_data = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } , [string] : [string] , } [EOL] root_project = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . root_path , [string] : [number] , } [EOL] [EOL] subdir_project = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : self . subdir_path , [string] : { } , [string] : [number] , } [EOL] self . root_project_config = config_from_parts_or_dicts ( project = root_project , profile = profile_data ) [EOL] self . subdir_project_config = config_from_parts_or_dicts ( project = subdir_project , profile = profile_data ) [EOL] [EOL] def _build_file ( self , contents , relative_path ) : [EOL] match = FilePath ( relative_path = relative_path , project_root = self . root_path , searched_path = self . subdir_path , ) [EOL] source_file = SourceFile ( path = match , checksum = FileHash . empty ( ) ) [EOL] source_file . contents = contents [EOL] return FileBlock ( file = source_file ) [EOL] [EOL] def test_load_file ( self ) : [EOL] parser = docs . DocumentationParser ( results = ParseResult . rpc ( ) , root_project = self . root_project_config , project = self . subdir_project_config , macro_manifest = Manifest . from_macros ( ) ) [EOL] [EOL] file_block = self . _build_file ( TEST_DOCUMENTATION_FILE , [string] ) [EOL] [EOL] parser . parse_file ( file_block ) [EOL] results = sorted ( parser . results . docs . values ( ) , key = lambda n : n . name ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] for result in results : [EOL] self . assertIsInstance ( result , ParsedDocumentation ) [EOL] self . assertEqual ( result . package_name , [string] ) [EOL] self . assertEqual ( result . original_file_path , self . testfile_path ) [EOL] self . assertEqual ( result . root_path , self . subdir_path ) [EOL] self . assertEqual ( result . resource_type , NodeType . Documentation ) [EOL] self . assertEqual ( result . path , [string] ) [EOL] [EOL] self . assertEqual ( results [ [number] ] . name , [string] ) [EOL] self . assertEqual ( results [ [number] ] . name , [string] ) [EOL] [EOL] def test_load_file_extras ( self ) : [EOL] TEST_DOCUMENTATION_FILE + [string] [EOL] [EOL] parser = docs . DocumentationParser ( results = ParseResult . rpc ( ) , root_project = self . root_project_config , project = self . subdir_project_config , macro_manifest = Manifest . from_macros ( ) ) [EOL] [EOL] file_block = self . _build_file ( TEST_DOCUMENTATION_FILE , [string] ) [EOL] [EOL] parser . parse_file ( file_block ) [EOL] results = sorted ( parser . results . docs . values ( ) , key = lambda n : n . name ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] for result in results : [EOL] self . assertIsInstance ( result , ParsedDocumentation ) [EOL] self . assertEqual ( results [ [number] ] . name , [string] ) [EOL] self . assertEqual ( results [ [number] ] . name , [string] ) [EOL] [EOL] def test_multiple_raw_blocks ( self ) : [EOL] parser = docs . DocumentationParser ( results = ParseResult . rpc ( ) , root_project = self . root_project_config , project = self . subdir_project_config , macro_manifest = Manifest . from_macros ( ) ) [EOL] [EOL] file_block = self . _build_file ( MULTIPLE_RAW_BLOCKS , [string] ) [EOL] [EOL] parser . parse_file ( file_block ) [EOL] results = sorted ( parser . results . docs . values ( ) , key = lambda n : n . name ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] for result in results : [EOL] self . assertIsInstance ( result , ParsedDocumentation ) [EOL] self . assertEqual ( result . package_name , [string] ) [EOL] self . assertEqual ( result . original_file_path , self . testfile_path ) [EOL] self . assertEqual ( result . root_path , self . subdir_path ) [EOL] self . assertEqual ( result . resource_type , NodeType . Documentation ) [EOL] self . assertEqual ( result . path , [string] ) [EOL] [EOL] self . assertEqual ( results [ [number] ] . name , [string] ) [EOL] self . assertEqual ( results [ [number] ] . block_contents , [string] ) [EOL] self . assertEqual ( results [ [number] ] . name , [string] ) [EOL] self . assertEqual ( results [ [number] ] . block_contents , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 $dbt.parser.search.FileBlock$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import MagicMock , patch [EOL] [EOL] import dbt . flags [EOL] import dbt . compilation [EOL] from dbt . adapters . postgres import Plugin [EOL] from dbt . contracts . files import FileHash [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . graph . parsed import NodeConfig , DependsOn , ParsedModelNode [EOL] from dbt . contracts . graph . compiled import CompiledModelNode , InjectedCTE [EOL] from dbt . node_types import NodeType [EOL] [EOL] from datetime import datetime [EOL] [EOL] from . utils import inject_adapter , clear_plugin , config_from_parts_or_dicts [EOL] [EOL] [EOL] class CompilerTest ( unittest . TestCase ) : [EOL] def assertEqualIgnoreWhitespace ( self , a , b ) : [EOL] self . assertEqual ( [string] . join ( a . split ( ) ) , [string] . join ( b . split ( ) ) ) [EOL] [EOL] def setUp ( self ) : [EOL] dbt . flags . STRICT_MODE = True [EOL] [EOL] self . maxDiff = None [EOL] [EOL] self . model_config = NodeConfig . from_dict ( { [string] : True , [string] : [string] , [string] : { } , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : [ ] , } ) [EOL] [EOL] project_cfg = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] profile_cfg = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] } } , [string] : [string] } [EOL] [EOL] self . config = config_from_parts_or_dicts ( project_cfg , profile_cfg ) [EOL] [EOL] self . _generate_runtime_model_patch = patch . object ( dbt . compilation , [string] ) [EOL] self . mock_generate_runtime_model = self . _generate_runtime_model_patch . start ( ) [EOL] [EOL] inject_adapter ( Plugin . adapter ( self . config ) , Plugin ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def mock_generate_runtime_model_context ( model , config , manifest ) : [EOL] def ref ( name ) : [EOL] result = f' [string] { name }' [EOL] unique_id = f' [string] { name }' [EOL] model . extra_ctes . append ( InjectedCTE ( id = unique_id , sql = None ) ) [EOL] return result [EOL] return { [string] : ref } [EOL] [EOL] self . mock_generate_runtime_model . side_effect = mock_generate_runtime_model_context [EOL] [EOL] def tearDown ( self ) : [EOL] self . _generate_runtime_model_patch . stop ( ) [EOL] clear_plugin ( Plugin ) [EOL] [EOL] def test__prepend_ctes__already_has_cte ( self ) : [EOL] ephemeral_config = self . model_config . replace ( materialized = [string] ) [EOL] [EOL] manifest = Manifest ( macros = { } , nodes = { [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , compiled = True , extra_ctes_injected = False , extra_ctes = [ InjectedCTE ( id = [string] , sql = [string] ) ] , injected_sql = [string] , compiled_sql = ( [string] [string] ) , checksum = FileHash . from_contents ( [string] ) , ) , [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = ephemeral_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , compiled = True , compiled_sql = [string] , extra_ctes_injected = False , extra_ctes = [ ] , injected_sql = [string] , checksum = FileHash . from_contents ( [string] ) , ) , } , sources = { } , docs = { } , generated_at = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , disabled = [ ] , files = { } , reports = { } , ) [EOL] [EOL] compiler = dbt . compilation . Compiler ( self . config ) [EOL] result , _ = compiler . _recursively_prepend_ctes ( manifest . nodes [ [string] ] , manifest , { } ) [EOL] [EOL] self . assertEqual ( result , manifest . nodes [ [string] ] ) [EOL] self . assertEqual ( result . extra_ctes_injected , True ) [EOL] self . assertEqualIgnoreWhitespace ( result . injected_sql , ( [string] [string] [string] [string] ) ) [EOL] [EOL] self . assertEqual ( manifest . nodes [ [string] ] . extra_ctes_injected , True ) [EOL] [EOL] def test__prepend_ctes__no_ctes ( self ) : [EOL] manifest = Manifest ( macros = { } , nodes = { [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = ( [string] [string] ) , compiled = True , extra_ctes_injected = False , extra_ctes = [ ] , injected_sql = [string] , compiled_sql = ( [string] [string] ) , checksum = FileHash . from_contents ( [string] ) , ) , [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , compiled = True , extra_ctes_injected = False , extra_ctes = [ ] , injected_sql = [string] , compiled_sql = ( [string] ) , checksum = FileHash . from_contents ( [string] ) , ) , } , sources = { } , docs = { } , generated_at = [string] , disabled = [ ] , files = { } , reports = { } , ) [EOL] [EOL] compiler = dbt . compilation . Compiler ( self . config ) [EOL] result , _ = compiler . _recursively_prepend_ctes ( manifest . nodes [ [string] ] , manifest , { } ) [EOL] [EOL] self . assertEqual ( result , manifest . nodes . get ( [string] ) ) [EOL] self . assertTrue ( result . extra_ctes_injected ) [EOL] self . assertEqualIgnoreWhitespace ( result . injected_sql , manifest . nodes . get ( [string] ) . compiled_sql ) [EOL] [EOL] compiler = dbt . compilation . Compiler ( self . config ) [EOL] result , _ = compiler . _recursively_prepend_ctes ( manifest . nodes . get ( [string] ) , manifest , { } ) [EOL] [EOL] self . assertEqual ( result , manifest . nodes . get ( [string] ) ) [EOL] self . assertTrue ( result . extra_ctes_injected ) [EOL] self . assertEqualIgnoreWhitespace ( result . injected_sql , manifest . nodes . get ( [string] ) . compiled_sql ) [EOL] [EOL] def test__prepend_ctes ( self ) : [EOL] ephemeral_config = self . model_config . replace ( materialized = [string] ) [EOL] [EOL] manifest = Manifest ( macros = { } , nodes = { [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , compiled = True , extra_ctes_injected = False , extra_ctes = [ InjectedCTE ( id = [string] , sql = [string] ) ] , injected_sql = [string] , compiled_sql = [string] , checksum = FileHash . from_contents ( [string] ) , ) , [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = ephemeral_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , compiled = True , extra_ctes_injected = False , extra_ctes = [ ] , injected_sql = [string] , compiled_sql = [string] , checksum = FileHash . from_contents ( [string] ) , ) , } , sources = { } , docs = { } , generated_at = [string] , disabled = [ ] , files = { } , reports = { } , ) [EOL] [EOL] compiler = dbt . compilation . Compiler ( self . config ) [EOL] result , _ = compiler . _recursively_prepend_ctes ( manifest . nodes [ [string] ] , manifest , { } ) [EOL] [EOL] self . assertEqual ( result , manifest . nodes . get ( [string] ) ) [EOL] [EOL] self . assertTrue ( result . extra_ctes_injected ) [EOL] self . assertEqualIgnoreWhitespace ( result . injected_sql , ( [string] [string] [string] [string] ) ) [EOL] [EOL] self . assertTrue ( manifest . nodes [ [string] ] . extra_ctes_injected ) [EOL] [EOL] def test__prepend_ctes__cte_not_compiled ( self ) : [EOL] ephemeral_config = self . model_config . replace ( materialized = [string] ) [EOL] parsed_ephemeral = ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = ephemeral_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , checksum = FileHash . from_contents ( [string] ) , ) [EOL] compiled_ephemeral = CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = ephemeral_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , compiled = True , compiled_sql = [string] , injected_sql = [string] , extra_ctes_injected = True , extra_ctes = [ ] , checksum = FileHash . from_contents ( [string] ) , ) [EOL] manifest = Manifest ( macros = { } , nodes = { [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , compiled = True , extra_ctes_injected = False , extra_ctes = [ InjectedCTE ( id = [string] , sql = [string] ) ] , injected_sql = [string] , compiled_sql = [string] , checksum = FileHash . from_contents ( [string] ) , ) , [string] : parsed_ephemeral , } , sources = { } , docs = { } , generated_at = [string] , disabled = [ ] , files = { } , reports = { } , ) [EOL] [EOL] compiler = dbt . compilation . Compiler ( self . config ) [EOL] with patch . object ( compiler , [string] ) as compile_node : [EOL] compile_node . return_value = compiled_ephemeral [EOL] [EOL] result , _ = compiler . _recursively_prepend_ctes ( manifest . nodes [ [string] ] , manifest , { } ) [EOL] compile_node . assert_called_once_with ( parsed_ephemeral , manifest , { } ) [EOL] [EOL] self . assertEqual ( result , manifest . nodes . get ( [string] ) ) [EOL] [EOL] self . assertTrue ( manifest . nodes [ [string] ] . compiled ) [EOL] self . assertTrue ( result . extra_ctes_injected ) [EOL] self . assertEqualIgnoreWhitespace ( result . injected_sql , ( [string] [string] [string] [string] ) ) [EOL] [EOL] self . assertTrue ( manifest . nodes [ [string] ] . extra_ctes_injected ) [EOL] [EOL] def test__prepend_ctes__multiple_levels ( self ) : [EOL] ephemeral_config = self . model_config . replace ( materialized = [string] ) [EOL] [EOL] manifest = Manifest ( macros = { } , nodes = { [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , compiled = True , extra_ctes_injected = False , extra_ctes = [ InjectedCTE ( id = [string] , sql = None ) ] , injected_sql = None , compiled_sql = [string] , checksum = FileHash . from_contents ( [string] ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = ephemeral_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , checksum = FileHash . from_contents ( [string] ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , root_path = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = ephemeral_config , tags = [ ] , path = [string] , original_file_path = [string] , raw_sql = [string] , checksum = FileHash . from_contents ( [string] ) , ) , } , sources = { } , docs = { } , generated_at = [string] , disabled = [ ] , files = { } , reports = { } , ) [EOL] [EOL] compiler = dbt . compilation . Compiler ( self . config ) [EOL] result , _ = compiler . _recursively_prepend_ctes ( manifest . nodes [ [string] ] , manifest , { } ) [EOL] [EOL] self . assertEqual ( result , manifest . nodes [ [string] ] ) [EOL] self . assertTrue ( result . extra_ctes_injected ) [EOL] self . assertEqualIgnoreWhitespace ( result . injected_sql , ( [string] [string] [string] [string] [string] [string] ) ) [EOL] [EOL] self . assertTrue ( manifest . nodes [ [string] ] . compiled ) [EOL] self . assertTrue ( manifest . nodes [ [string] ] . compiled ) [EOL] self . assertTrue ( manifest . nodes [ [string] ] . extra_ctes_injected ) [EOL] self . assertTrue ( manifest . nodes [ [string] ] . extra_ctes_injected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Dict , Tuple , Literal [EOL] import unittest [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] import unittest [EOL] from unittest . mock import MagicMock , patch [EOL] [EOL] from dbt . adapters . postgres import Plugin as PostgresPlugin [EOL] from dbt . adapters . factory import reset_adapters [EOL] import dbt . clients . system [EOL] import dbt . compilation [EOL] import dbt . exceptions [EOL] import dbt . flags [EOL] import dbt . parser [EOL] import dbt . config [EOL] import dbt . utils [EOL] import dbt . parser . manifest [EOL] from dbt . contracts . files import SourceFile , FileHash , FilePath [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . parser . results import ParseResult [EOL] from dbt . parser . base import BaseParser [EOL] from dbt . graph import NodeSelector , parse_difference [EOL] [EOL] try : [EOL] from queue import Empty [EOL] except ImportError : [EOL] from Queue import Empty [EOL] [EOL] from dbt . logger import GLOBAL_LOGGER as logger [comment] [EOL] [EOL] from . utils import config_from_parts_or_dicts , generate_name_macros , inject_plugin [EOL] [EOL] [EOL] class GraphTest ( unittest . TestCase ) : [EOL] [EOL] def tearDown ( self ) : [EOL] self . write_gpickle_patcher . stop ( ) [EOL] self . load_projects_patcher . stop ( ) [EOL] self . file_system_patcher . stop ( ) [EOL] self . get_adapter_patcher . stop ( ) [EOL] self . get_adapter_patcher_parser . stop ( ) [EOL] self . mock_filesystem_constructor . stop ( ) [EOL] self . mock_hook_constructor . stop ( ) [EOL] self . load_patch . stop ( ) [EOL] self . load_source_file_patcher . stop ( ) [EOL] reset_adapters ( ) [EOL] [EOL] def setUp ( self ) : [EOL] dbt . flags . STRICT_MODE = True [EOL] self . graph_result = None [EOL] [EOL] self . write_gpickle_patcher = patch ( [string] ) [EOL] self . load_projects_patcher = patch ( [string] ) [EOL] self . file_system_patcher = patch . object ( dbt . parser . search . FilesystemSearcher , [string] ) [EOL] self . hook_patcher = patch . object ( dbt . parser . hooks . HookParser , [string] ) [EOL] self . get_adapter_patcher = patch ( [string] ) [EOL] self . factory = self . get_adapter_patcher . start ( ) [EOL] [comment] [EOL] [EOL] self . get_adapter_patcher_parser = patch ( [string] ) [EOL] self . factory_cmn = self . get_adapter_patcher_parser . start ( ) [EOL] [EOL] [EOL] def mock_write_gpickle ( graph , outfile ) : [EOL] self . graph_result = graph [EOL] self . mock_write_gpickle = self . write_gpickle_patcher . start ( ) [EOL] self . mock_write_gpickle . side_effect = mock_write_gpickle [EOL] [EOL] self . profile = { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } , [string] : [string] } [EOL] [EOL] self . mock_load_projects = self . load_projects_patcher . start ( ) [EOL] def _load_projects ( config , paths ) : [EOL] yield config . project_name , config [EOL] self . mock_load_projects . side_effect = _load_projects [EOL] [EOL] self . mock_models = [ ] [EOL] [EOL] def _mock_parse_result ( config , all_projects ) : [EOL] return ParseResult ( vars_hash = FileHash . from_contents ( [string] ) , project_hashes = { name : FileHash . from_contents ( name ) for name in all_projects } , profile_hash = FileHash . from_contents ( [string] ) , ) [EOL] [EOL] self . load_patch = patch ( [string] ) [EOL] self . mock_parse_result = self . load_patch . start ( ) [EOL] self . mock_parse_result . side_effect = _mock_parse_result [EOL] [EOL] self . load_source_file_patcher = patch . object ( BaseParser , [string] ) [EOL] self . mock_source_file = self . load_source_file_patcher . start ( ) [EOL] self . mock_source_file . side_effect = lambda path : [ n for n in self . mock_models if n . path == path ] [ [number] ] [EOL] [EOL] self . macro_manifest = Manifest . from_macros ( macros = { n . unique_id : n for n in generate_name_macros ( [string] ) } ) [EOL] [EOL] def filesystem_iter ( iter_self ) : [EOL] if [string] not in iter_self . extension : [EOL] return [ ] [EOL] if [string] not in iter_self . relative_dirs : [EOL] return [ ] [EOL] return [ model . path for model in self . mock_models ] [EOL] [EOL] def create_filesystem_searcher ( cls , project , relative_dirs , extension ) : [EOL] result = MagicMock ( project = project , relative_dirs = relative_dirs , extension = extension ) [EOL] result . __iter__ . side_effect = lambda : iter ( filesystem_iter ( result ) ) [EOL] return result [EOL] [EOL] def create_hook_patcher ( cls , results , project , relative_dirs , extension ) : [EOL] result = MagicMock ( results = results , project = project , relative_dirs = relative_dirs , extension = extension ) [EOL] result . __iter__ . side_effect = lambda : iter ( [ ] ) [EOL] return result [EOL] [EOL] self . mock_filesystem_constructor = self . file_system_patcher . start ( ) [EOL] self . mock_filesystem_constructor . side_effect = create_filesystem_searcher [EOL] self . mock_hook_constructor = self . hook_patcher . start ( ) [EOL] self . mock_hook_constructor . side_effect = create_hook_patcher [EOL] inject_plugin ( PostgresPlugin ) [EOL] [EOL] def get_config ( self , extra_cfg = None ) : [EOL] if extra_cfg is None : [EOL] extra_cfg = { } [EOL] [EOL] cfg = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : os . path . abspath ( [string] ) , [string] : [number] , } [EOL] cfg . update ( extra_cfg ) [EOL] [EOL] return config_from_parts_or_dicts ( project = cfg , profile = self . profile ) [EOL] [EOL] def get_compiler ( self , project ) : [EOL] return dbt . compilation . Compiler ( project ) [EOL] [EOL] def use_models ( self , models ) : [EOL] for k , v in models . items ( ) : [EOL] path = FilePath ( searched_path = [string] , project_root = os . path . normcase ( os . getcwd ( ) ) , relative_path = [string] . format ( k ) , ) [EOL] source_file = SourceFile ( path = path , checksum = FileHash . empty ( ) ) [EOL] source_file . contents = v [EOL] self . mock_models . append ( source_file ) [EOL] [EOL] def load_manifest ( self , config ) : [EOL] loader = dbt . parser . manifest . ManifestLoader ( config , { config . project_name : config } ) [EOL] loader . load ( macro_manifest = self . macro_manifest ) [EOL] return loader . create_manifest ( ) [EOL] [EOL] def test__single_model ( self ) : [EOL] self . use_models ( { [string] : [string] , } ) [EOL] [EOL] config = self . get_config ( ) [EOL] manifest = self . load_manifest ( config ) [EOL] [EOL] compiler = self . get_compiler ( config ) [EOL] linker = compiler . compile ( manifest ) [EOL] [EOL] self . assertEqual ( list ( linker . nodes ( ) ) , [ [string] ] ) [EOL] [EOL] self . assertEqual ( list ( linker . edges ( ) ) , [ ] ) [EOL] [EOL] def test__two_models_simple_ref ( self ) : [EOL] self . use_models ( { [string] : [string] , [string] : [string] , } ) [EOL] [EOL] config = self . get_config ( ) [EOL] manifest = self . load_manifest ( config ) [EOL] compiler = self . get_compiler ( config ) [EOL] linker = compiler . compile ( manifest ) [EOL] [EOL] self . assertCountEqual ( linker . nodes ( ) , [ [string] , [string] , ] ) [EOL] [EOL] self . assertCountEqual ( linker . edges ( ) , [ ( [string] , [string] , ) ] ) [EOL] [EOL] def test__model_materializations ( self ) : [EOL] self . use_models ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] cfg = { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } } [EOL] [EOL] config = self . get_config ( cfg ) [EOL] manifest = self . load_manifest ( config ) [EOL] compiler = self . get_compiler ( config ) [EOL] linker = compiler . compile ( manifest ) [EOL] [EOL] expected_materialization = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] for model , expected in expected_materialization . items ( ) : [EOL] key = [string] . format ( model ) [EOL] actual = manifest . nodes [ key ] . config . materialized [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] def test__model_incremental ( self ) : [EOL] self . use_models ( { [string] : [string] } ) [EOL] [EOL] cfg = { [string] : { [string] : { [string] : { [string] : [string] , [string] : [string] } , } } } [EOL] [EOL] config = self . get_config ( cfg ) [EOL] manifest = self . load_manifest ( config ) [EOL] compiler = self . get_compiler ( config ) [EOL] linker = compiler . compile ( manifest ) [EOL] [EOL] node = [string] [EOL] [EOL] self . assertEqual ( list ( linker . nodes ( ) ) , [ node ] ) [EOL] self . assertEqual ( list ( linker . edges ( ) ) , [ ] ) [EOL] [EOL] self . assertEqual ( manifest . nodes [ node ] . config . materialized , [string] ) [EOL] [EOL] def test__dependency_list ( self ) : [EOL] self . use_models ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] config = self . get_config ( ) [EOL] manifest = self . load_manifest ( config ) [EOL] compiler = self . get_compiler ( config ) [EOL] graph = compiler . compile ( manifest ) [EOL] [EOL] models = ( [string] , [string] , [string] , [string] ) [EOL] model_ids = [ [string] . format ( m ) for m in models ] [EOL] [EOL] manifest = MagicMock ( nodes = { n : MagicMock ( unique_id = n , name = n . split ( [string] ) [ - [number] ] , package_name = [string] , fqn = [ [string] , n ] , empty = False , config = MagicMock ( enabled = True ) , ) for n in model_ids } ) [EOL] manifest . expect . side_effect = lambda n : MagicMock ( unique_id = n ) [EOL] selector = NodeSelector ( graph , manifest ) [EOL] queue = selector . get_graph_queue ( parse_difference ( None , None ) ) [EOL] [EOL] for model_id in model_ids : [EOL] self . assertFalse ( queue . empty ( ) ) [EOL] got = queue . get ( block = False ) [EOL] self . assertEqual ( got . unique_id , model_id ) [EOL] with self . assertRaises ( Empty ) : [EOL] queue . get ( block = False ) [EOL] queue . mark_done ( got . unique_id ) [EOL] self . assertTrue ( queue . empty ( ) ) [EOL] [EOL] def test__partial_parse ( self ) : [EOL] config = self . get_config ( ) [EOL] [EOL] loader = dbt . parser . manifest . ManifestLoader ( config , { config . project_name : config } ) [EOL] loader . load ( macro_manifest = self . macro_manifest ) [EOL] loader . create_manifest ( ) [EOL] results = loader . results [EOL] [EOL] self . assertTrue ( loader . matching_parse_results ( results ) ) [EOL] too_low = results . replace ( dbt_version = [string] ) [EOL] self . assertFalse ( loader . matching_parse_results ( too_low ) ) [EOL] too_high = results . replace ( dbt_version = [string] ) [EOL] self . assertFalse ( loader . matching_parse_results ( too_high ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $unittest.mock.MagicMock$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0
from typing import Dict , Any , List , Set [EOL] import typing [EOL] from unittest import TestCase [EOL] from dbt . adapters . cache import RelationsCache [EOL] from dbt . adapters . base . relation import BaseRelation [EOL] from multiprocessing . dummy import Pool as ThreadPool [EOL] import dbt . exceptions [EOL] [EOL] import random [EOL] import time [EOL] [EOL] [EOL] def make_relation ( database , schema , identifier ) : [EOL] return BaseRelation . create ( database = database , schema = schema , identifier = identifier ) [EOL] [EOL] def make_mock_relationship ( database , schema , identifier ) : [EOL] return BaseRelation . create ( database = database , schema = schema , identifier = identifier , type = [string] ) [EOL] [EOL] [EOL] class TestCache ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . cache = RelationsCache ( ) [EOL] [EOL] def assert_relations_state ( self , database , schema , identifiers ) : [EOL] relations = self . cache . get_relations ( database , schema ) [EOL] for identifier , expect in identifiers . items ( ) : [EOL] found = any ( ( r . identifier == identifier and r . schema == schema and r . database == database ) for r in relations ) [EOL] msg = [string] . format ( database , schema , identifier , [string] if found else [string] ) [EOL] self . assertEqual ( expect , found , msg ) [EOL] [EOL] def assert_relations_exist ( self , database , schema , * identifiers ) : [EOL] self . assert_relations_state ( database , schema , { k : True for k in identifiers } ) [EOL] [EOL] def assert_relations_do_not_exist ( self , database , schema , * identifiers ) : [EOL] self . assert_relations_state ( database , schema , { k : False for k in identifiers } ) [EOL] [EOL] [EOL] class TestEmpty ( TestCache ) : [EOL] def test_empty ( self ) : [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] [EOL] class TestDrop ( TestCache ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . cache . add ( make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] def test_missing_identifier_ignored ( self ) : [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] def test_missing_schema_ignored ( self ) : [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] def test_missing_db_ignored ( self ) : [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] def test_drop ( self ) : [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_relations_do_not_exist ( [string] , [string] , [string] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] [EOL] class TestAddLink ( TestCache ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . cache . add ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . cache . add ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . cache . add ( make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] def test_no_src ( self ) : [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assert_relations_do_not_exist ( [string] , [string] , [string] ) [EOL] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . assert_relations_exist ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def test_no_dst ( self ) : [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assert_relations_do_not_exist ( [string] , [string] , [string] ) [EOL] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . assert_relations_exist ( [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] class TestRename ( TestCache ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . cache . add ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assertEqual ( self . cache . schemas , { ( [string] , [string] ) } ) [EOL] [EOL] def test_no_source_error ( self ) : [EOL] [comment] [EOL] self . cache . rename ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def test_dest_exists_error ( self ) : [EOL] foo = make_relation ( [string] , [string] , [string] ) [EOL] bar = make_relation ( [string] , [string] , [string] ) [EOL] self . cache . add ( bar ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] , [string] ) [EOL] [EOL] with self . assertRaises ( dbt . exceptions . InternalException ) : [EOL] self . cache . rename ( foo , bar ) [EOL] [EOL] self . assert_relations_exist ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def test_dest_different_db ( self ) : [EOL] self . cache . rename ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assert_relations_do_not_exist ( [string] , [string] , [string] ) [EOL] [comment] [EOL] self . assertEqual ( self . cache . schemas , { ( [string] , [string] ) , ( [string] , [string] ) } ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] def test_rename_identifier ( self ) : [EOL] self . cache . rename ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assert_relations_do_not_exist ( [string] , [string] , [string] ) [EOL] self . assertEqual ( self . cache . schemas , { ( [string] , [string] ) } ) [EOL] [EOL] relation = self . cache . relations [ ( [string] , [string] , [string] ) ] [EOL] self . assertEqual ( relation . inner . schema , [string] ) [EOL] self . assertEqual ( relation . inner . identifier , [string] ) [EOL] self . assertEqual ( relation . schema , [string] ) [EOL] self . assertEqual ( relation . identifier , [string] ) [EOL] [EOL] def test_rename_db ( self ) : [EOL] self . cache . rename ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assert_relations_do_not_exist ( [string] , [string] , [string] ) [EOL] [comment] [EOL] self . assertEqual ( self . cache . schemas , { ( [string] , [string] ) , ( [string] , [string] ) } ) [EOL] [EOL] relation = self . cache . relations [ ( [string] , [string] , [string] ) ] [EOL] self . assertEqual ( relation . inner . database , [string] ) [EOL] self . assertEqual ( relation . inner . schema , [string] ) [EOL] self . assertEqual ( relation . inner . identifier , [string] ) [EOL] self . assertEqual ( relation . database , [string] ) [EOL] self . assertEqual ( relation . schema , [string] ) [EOL] self . assertEqual ( relation . identifier , [string] ) [EOL] [EOL] def test_rename_schema ( self ) : [EOL] self . cache . rename ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] self . assert_relations_do_not_exist ( [string] , [string] , [string] ) [EOL] [comment] [EOL] self . assertEqual ( self . cache . schemas , { ( [string] , [string] ) , ( [string] , [string] ) } ) [EOL] [EOL] relation = self . cache . relations [ ( [string] , [string] , [string] ) ] [EOL] self . assertEqual ( relation . inner . database , [string] ) [EOL] self . assertEqual ( relation . inner . schema , [string] ) [EOL] self . assertEqual ( relation . inner . identifier , [string] ) [EOL] self . assertEqual ( relation . database , [string] ) [EOL] self . assertEqual ( relation . schema , [string] ) [EOL] self . assertEqual ( relation . identifier , [string] ) [EOL] [EOL] [EOL] class TestGetRelations ( TestCache ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . relation = make_relation ( [string] , [string] , [string] ) [EOL] self . cache . add ( self . relation ) [EOL] [EOL] def test_get_by_name ( self ) : [EOL] relations = self . cache . get_relations ( [string] , [string] ) [EOL] self . assertEqual ( len ( relations ) , [number] ) [EOL] self . assertIs ( relations [ [number] ] , self . relation ) [EOL] [EOL] def test_get_by_uppercase_schema ( self ) : [EOL] relations = self . cache . get_relations ( [string] , [string] ) [EOL] self . assertEqual ( len ( relations ) , [number] ) [EOL] self . assertIs ( relations [ [number] ] , self . relation ) [EOL] [EOL] def test_get_by_uppercase_db ( self ) : [EOL] relations = self . cache . get_relations ( [string] , [string] ) [EOL] self . assertEqual ( len ( relations ) , [number] ) [EOL] self . assertIs ( relations [ [number] ] , self . relation ) [EOL] [EOL] def test_get_by_uppercase_schema_and_db ( self ) : [EOL] relations = self . cache . get_relations ( [string] , [string] ) [EOL] self . assertEqual ( len ( relations ) , [number] ) [EOL] self . assertIs ( relations [ [number] ] , self . relation ) [EOL] [EOL] def test_get_by_wrong_db ( self ) : [EOL] relations = self . cache . get_relations ( [string] , [string] ) [EOL] self . assertEqual ( len ( relations ) , [number] ) [EOL] [EOL] def test_get_by_wrong_schema ( self ) : [EOL] relations = self . cache . get_relations ( [string] , [string] ) [EOL] self . assertEqual ( len ( relations ) , [number] ) [EOL] [EOL] [EOL] class TestAdd ( TestCache ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . relation = make_relation ( [string] , [string] , [string] ) [EOL] self . cache . add ( self . relation ) [EOL] [EOL] def test_add ( self ) : [EOL] relations = self . cache . get_relations ( [string] , [string] ) [EOL] self . assertEqual ( len ( relations ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] self . assertIs ( relations [ [number] ] , self . relation ) [EOL] [EOL] def test_add_twice ( self ) : [EOL] [comment] [EOL] self . cache . add ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] self . assertEqual ( self . cache . schemas , { ( [string] , [string] ) } ) [EOL] self . assert_relations_exist ( [string] , [string] , [string] ) [EOL] [EOL] def add_uppercase_schema ( self ) : [EOL] self . cache . add ( make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] relations = self . cache . get_relations ( [string] , [string] ) [EOL] self . assertEqual ( len ( relations ) , [number] ) [EOL] self . assertEqual ( self . cache . schemas , { ( [string] , [string] ) } ) [EOL] self . assertIsNot ( self . cache . relations [ ( [string] , [string] , [string] ) ] . inner , None ) [EOL] self . assertIsNot ( self . cache . relations [ ( [string] , [string] , [string] ) ] . inner , None ) [EOL] [EOL] def add_different_db ( self ) : [EOL] self . cache . add ( make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( self . cache . schemas , { ( [string] , [string] ) , ( [string] , [string] ) } ) [EOL] self . assertIsNot ( self . cache . relations [ ( [string] , [string] , [string] ) ] . inner , None ) [EOL] self . assertIsNot ( self . cache . relations [ ( [string] , [string] , [string] ) ] . inner , None ) [EOL] [EOL] [EOL] class TestLikeDbt ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . cache = RelationsCache ( ) [EOL] self . _sleep = True [EOL] [EOL] [comment] [EOL] for ident in [string] : [EOL] self . cache . add ( make_relation ( [string] , [string] , ident ) ) [EOL] [comment] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [comment] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [comment] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [comment] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [comment] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [comment] [EOL] [EOL] def assert_has_relations ( self , expected ) : [EOL] current = set ( r . identifier for r in self . cache . get_relations ( [string] , [string] ) ) [EOL] self . assertEqual ( current , expected ) [EOL] [EOL] def test_drop_inner ( self ) : [EOL] self . assert_has_relations ( set ( [string] ) ) [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_has_relations ( { [string] , [string] } ) [EOL] [EOL] def test_rename_and_drop ( self ) : [EOL] self . assert_has_relations ( set ( [string] ) ) [EOL] [comment] [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_has_relations ( set ( [string] ) ) [EOL] [comment] [EOL] self . cache . add ( make_relation ( [string] , [string] , [string] , ) ) [EOL] self . assert_has_relations ( set ( [string] ) | { [string] } ) [EOL] [comment] [EOL] self . cache . rename ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_has_relations ( set ( [string] ) | { [string] , [string] } ) [EOL] [comment] [EOL] self . cache . rename ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_has_relations ( set ( [string] ) | { [string] } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assert_has_relations ( set ( [string] ) ) [EOL] relation = self . cache . relations [ ( [string] , [string] , [string] ) ] [EOL] self . assertEqual ( len ( relation . referenced_by ) , [number] ) [EOL] [EOL] def _rand_sleep ( self ) : [EOL] if not self . _sleep : [EOL] return [EOL] time . sleep ( random . random ( ) * [number] ) [EOL] [EOL] def _target ( self , ident ) : [EOL] self . _rand_sleep ( ) [EOL] self . cache . rename ( make_relation ( [string] , [string] , ident ) , make_relation ( [string] , [string] , ident + [string] ) ) [EOL] self . _rand_sleep ( ) [EOL] self . cache . add ( make_relation ( [string] , [string] , ident + [string] ) ) [EOL] self . _rand_sleep ( ) [EOL] self . cache . rename ( make_relation ( [string] , [string] , ident + [string] ) , make_relation ( [string] , [string] , ident ) ) [EOL] self . _rand_sleep ( ) [EOL] self . cache . drop ( make_relation ( [string] , [string] , ident + [string] ) ) [EOL] return ident , self . cache . get_relations ( [string] , [string] ) [EOL] [EOL] def test_threaded ( self ) : [EOL] [comment] [EOL] for ident in [string] : [EOL] obj = make_mock_relationship ( [string] , [string] , ident ) [EOL] self . cache . add ( make_relation ( [string] , [string] , ident ) ) [EOL] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] pool = ThreadPool ( [number] ) [EOL] results = list ( pool . imap_unordered ( self . _target , ( [string] , [string] , [string] , [string] ) ) ) [EOL] pool . close ( ) [EOL] pool . join ( ) [EOL] [comment] [EOL] [comment] [EOL] min_expect = { [string] : { [string] , [string] , [string] } , [string] : { [string] , [string] , [string] } , [string] : { [string] , [string] , [string] } , [string] : { [string] , [string] , [string] } , } [EOL] [EOL] for ident , relations in results : [EOL] seen = set ( r . identifier for r in relations ) [EOL] self . assertTrue ( min_expect [ ident ] . issubset ( seen ) ) [EOL] [EOL] self . assert_has_relations ( set ( [string] ) ) [EOL] [EOL] def test_threaded_repeated ( self ) : [EOL] for _ in range ( [number] ) : [EOL] self . setUp ( ) [EOL] self . _sleep = False [EOL] self . test_threaded ( ) [EOL] [EOL] [EOL] class TestComplexCache ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . cache = RelationsCache ( ) [EOL] inputs = [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ] [EOL] self . inputs = [ make_relation ( d , s , i ) for d , s , i in inputs ] [EOL] for relation in self . inputs : [EOL] self . cache . add ( relation ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [comment] [EOL] [comment] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] self . cache . add_link ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) , ) [EOL] [EOL] def test_get_relations ( self ) : [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] def test_drop_one ( self ) : [EOL] [comment] [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] def test_drop_many ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] def test_rename_root ( self ) : [EOL] self . cache . rename ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] retrieved = self . cache . relations [ ( [string] , [string] , [string] ) ] . inner [EOL] self . assertEqual ( retrieved . schema , [string] ) [EOL] self . assertEqual ( retrieved . identifier , [string] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] [comment] [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL] [EOL] def test_rename_branch ( self ) : [EOL] self . cache . rename ( make_relation ( [string] , [string] , [string] ) , make_relation ( [string] , [string] , [string] ) ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] [EOL] [comment] [EOL] self . cache . drop ( make_relation ( [string] , [string] , [string] ) ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . get_relations ( [string] , [string] ) ) , [number] ) [EOL] self . assertEqual ( len ( self . cache . relations ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set , Union , Optional , Dict , Tuple [EOL] import unittest [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] [EOL] import string [EOL] import dbt . exceptions [EOL] import dbt . graph . selector as graph_selector [EOL] import dbt . graph . cli as graph_cli [EOL] from dbt . node_types import NodeType [EOL] [EOL] import networkx as nx [EOL] [EOL] [EOL] def _get_graph ( ) : [EOL] integer_graph = nx . balanced_tree ( [number] , [number] , nx . DiGraph ( ) ) [EOL] [EOL] package_mapping = { i : [string] + ( [string] if i % [number] == [number] else [string] ) + [string] + letter for ( i , letter ) in enumerate ( string . ascii_lowercase ) } [EOL] [EOL] [comment] [EOL] return graph_selector . Graph ( nx . relabel_nodes ( integer_graph , package_mapping ) ) [EOL] [EOL] [EOL] def _get_manifest ( graph ) : [EOL] nodes = { } [EOL] for unique_id in graph : [EOL] fqn = unique_id . split ( [string] ) [EOL] node = mock . MagicMock ( unique_id = unique_id , fqn = fqn , package_name = fqn [ [number] ] , tags = [ ] , resource_type = NodeType . Model , empty = False , config = mock . MagicMock ( enabled = True ) , ) [EOL] nodes [ unique_id ] = node [EOL] [EOL] nodes [ [string] ] . tags = [ [string] ] [EOL] nodes [ [string] ] . tags = [ [string] , [string] ] [EOL] nodes [ [string] ] . tags = [ [string] , [string] ] [EOL] nodes [ [string] ] . tags = [ ] [EOL] nodes [ [string] ] . tags = [ [string] , [string] ] [EOL] nodes [ [string] ] . tags = [ [string] , [string] ] [EOL] nodes [ [string] ] . tags = [ [string] ] [EOL] return mock . MagicMock ( nodes = nodes ) [EOL] [EOL] [EOL] @ pytest . fixture def graph ( ) : [EOL] return graph_selector . Graph ( _get_graph ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture def manifest ( graph ) : [EOL] return _get_manifest ( graph ) [EOL] [EOL] [EOL] def id_macro ( arg ) : [EOL] if isinstance ( arg , str ) : [EOL] return arg [EOL] try : [EOL] return [string] . join ( arg ) [EOL] except TypeError : [EOL] return arg [EOL] [EOL] [EOL] run_specs = [ ( [ [string] ] , [ ] , { [string] } ) , ( [ [string] ] , [ ] , { [string] , [string] , [string] } ) , ( [ [string] ] , [ [string] ] , { [string] , [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ ] , { [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ ] , { [string] , [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ ] , { [string] , [string] } ) , ( [ [string] ] , [ [string] ] , { [string] , [string] , [string] , [string] , [string] , [string] } ) , ( [ [string] ] , [ ] , { [string] , [string] , [string] } ) , ( [ [string] ] , [ ] , { [string] , [string] , [string] } ) , ( [ [string] ] , [ [string] ] , { [string] , [string] , [string] , [string] } ) , ( [ [string] ] , [ ] , { [string] , [string] , [string] } ) , ( [ [string] ] , [ ] , { [string] , [string] } ) , ( [ [string] ] , [ ] , { [string] , [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ ] , { [string] , [string] , [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ [string] ] , { [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ [string] , [string] ] , { [string] , [string] } ) , ( [ [string] ] , [ ] , { [string] } ) , ( [ [string] ] , [ ] , { [string] } ) , ( [ [string] ] , [ ] , set ( ) ) , ( [ [string] ] , [ ] , { [string] , [string] } ) , ( [ [string] ] , [ ] , { [string] } ) , ( [ [string] ] , [ ] , { [string] } ) , ( [ [string] ] , [ [string] ] , { [string] } ) , ( [ [string] ] , [ [string] ] , { [string] } ) , ( [ [string] ] , [ [string] ] , set ( ) ) , ( [ [string] ] , [ [string] ] , { [string] } ) , ( [ [string] , [string] ] , [ ] , { [string] , [string] , [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ [string] ] , { [string] , [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ [string] ] , { [string] , [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ [string] , [string] ] , { [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ [string] ] , { [string] , [string] , [string] } ) , ( [ [string] , [string] ] , [ [string] , [string] ] , { [string] , [string] } ) ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , run_specs , ids = id_macro ) def test_run_specs ( include , exclude , expected ) : [EOL] graph = _get_graph ( ) [EOL] manifest = _get_manifest ( graph ) [EOL] selector = graph_selector . NodeSelector ( graph , manifest ) [EOL] spec = graph_cli . parse_difference ( include , exclude ) [EOL] selected = selector . select_nodes ( spec ) [EOL] [EOL] assert selected == expected [EOL] [EOL] [EOL] param_specs = [ ( [string] , False , None , False , None , [string] , [string] , False ) , ( [string] , True , None , False , None , [string] , [string] , False ) , ( [string] , True , [number] , False , None , [string] , [string] , False ) , ( [string] , False , None , True , None , [string] , [string] , False ) , ( [string] , False , None , True , [number] , [string] , [string] , False ) , ( [string] , True , None , True , None , [string] , [string] , False ) , ( [string] , True , [number] , True , [number] , [string] , [string] , False ) , ( [string] , False , None , False , None , [string] , [string] , True ) , ( [string] , False , None , False , None , [string] , [string] , False ) , ( [string] , True , None , False , None , [string] , [string] , False ) , ( [string] , True , [number] , False , None , [string] , [string] , False ) , ( [string] , False , None , True , None , [string] , [string] , False ) , ( [string] , False , None , True , [number] , [string] , [string] , False ) , ( [string] , True , None , True , None , [string] , [string] , False ) , ( [string] , True , [number] , True , [number] , [string] , [string] , False ) , ( [string] , False , None , False , None , [string] , [string] , True ) , ( [string] , False , None , False , None , [string] , [string] , False ) , ( [string] , True , None , False , None , [string] , [string] , False ) , ( [string] , True , [number] , False , None , [string] , [string] , False ) , ( [string] , False , None , True , None , [string] , [string] , False ) , ( [string] , False , None , True , [number] , [string] , [string] , False ) , ( [string] , True , None , True , None , [string] , [string] , False ) , ( [string] , True , [number] , True , [number] , [string] , [string] , False ) , ( [string] , False , None , False , None , [string] , [string] , True ) , ( [string] , False , None , False , None , [string] , [string] , False ) , ( [string] , True , None , False , None , [string] , [string] , False ) , ( [string] , True , [number] , False , None , [string] , [string] , False ) , ( [string] , False , None , True , None , [string] , [string] , False ) , ( [string] , False , None , True , [number] , [string] , [string] , False ) , ( [string] , True , None , True , None , [string] , [string] , False ) , ( [string] , True , [number] , True , [number] , [string] , [string] , False ) , ( [string] , False , None , False , None , [string] , [string] , True ) , ( [string] , False , None , False , None , [string] , [string] , False ) , ( [string] , False , None , True , None , [string] , [string] , False ) , ( [string] , False , None , True , [number] , [string] , [string] , False ) , ( [string] , False , None , True , [number] , [string] , [string] , False ) , ( [string] , False , None , False , None , [string] , [string] , True ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , param_specs , ids = id_macro ) def test_parse_specs ( spec , parents , parents_depth , children , children_depth , filter_type , filter_value , childrens_parents ) : [EOL] parsed = graph_selector . SelectionCriteria . from_single_spec ( spec ) [EOL] assert parsed . parents == parents [EOL] assert parsed . parents_depth == parents_depth [EOL] assert parsed . children == children [EOL] assert parsed . children_depth == children_depth [EOL] assert parsed . method == filter_type [EOL] assert parsed . value == filter_value [EOL] assert parsed . childrens_parents == childrens_parents [EOL] [EOL] [EOL] invalid_specs = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , invalid_specs , ids = lambda k : str ( k ) ) def test_invalid_specs ( invalid ) : [EOL] with pytest . raises ( dbt . exceptions . RuntimeException ) : [EOL] graph_selector . SelectionCriteria . from_single_spec ( invalid ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Tuple[typing.List[builtins.str],typing.List[typing.Any],typing.Set[typing.Any]],typing.Tuple[typing.List[builtins.str],typing.List[typing.Any],typing.Set[builtins.str]],typing.Tuple[typing.List[builtins.str],typing.List[builtins.str],typing.Set[typing.Any]],typing.Tuple[typing.List[builtins.str],typing.List[builtins.str],typing.Set[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Tuple[typing.List[builtins.str],typing.List[typing.Any],typing.Set[typing.Any]],typing.Tuple[typing.List[builtins.str],typing.List[typing.Any],typing.Set[builtins.str]],typing.Tuple[typing.List[builtins.str],typing.List[builtins.str],typing.Set[typing.Any]],typing.Tuple[typing.List[builtins.str],typing.List[builtins.str],typing.Set[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool,typing.Optional[builtins.int],builtins.bool,typing.Optional[builtins.int],builtins.str,builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool,typing.Optional[builtins.int],builtins.bool,typing.Optional[builtins.int],builtins.str,builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Optional , Dict , Tuple [EOL] import unittest [EOL] import typing [EOL] import agate [EOL] import decimal [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import dbt . flags as flags [EOL] from dbt . task . debug import DebugTask [EOL] [EOL] from dbt . adapters . base . query_headers import MacroQueryStringSetter [EOL] from dbt . adapters . postgres import PostgresAdapter [EOL] from dbt . adapters . postgres import Plugin as PostgresPlugin [EOL] from dbt . clients import agate_helper [EOL] from dbt . exceptions import ValidationException , DbtConfigError [EOL] from dbt . logger import GLOBAL_LOGGER as logger [comment] [EOL] from dbt . parser . results import ParseResult [EOL] from psycopg2 import extensions as psycopg2_extensions [EOL] from psycopg2 import DatabaseError [EOL] [EOL] from . utils import config_from_parts_or_dicts , inject_adapter , mock_connection , TestAdapterConversions , load_internal_manifest_macros , clear_plugin [EOL] [EOL] [EOL] class TestPostgresAdapter ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] flags . STRICT_MODE = True [EOL] project_cfg = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] profile_cfg = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] } } , [string] : [string] } [EOL] [EOL] self . config = config_from_parts_or_dicts ( project_cfg , profile_cfg ) [EOL] self . _adapter = None [EOL] [EOL] @ property def adapter ( self ) : [EOL] if self . _adapter is None : [EOL] self . _adapter = PostgresAdapter ( self . config ) [EOL] inject_adapter ( self . _adapter , PostgresPlugin ) [EOL] return self . _adapter [EOL] [EOL] @ mock . patch ( [string] ) def test_acquire_connection_validations ( self , psycopg2 ) : [EOL] try : [EOL] connection = self . adapter . acquire_connection ( [string] ) [EOL] except ValidationException as e : [EOL] self . fail ( [string] . format ( str ( e ) ) ) [EOL] except BaseException as e : [EOL] self . fail ( [string] . format ( str ( e ) ) ) [EOL] self . assertEqual ( connection . type , [string] ) [EOL] [EOL] psycopg2 . connect . assert_not_called ( ) [EOL] connection . handle [EOL] psycopg2 . connect . assert_called_once ( ) [EOL] [EOL] @ mock . patch ( [string] ) def test_acquire_connection ( self , psycopg2 ) : [EOL] connection = self . adapter . acquire_connection ( [string] ) [EOL] [EOL] psycopg2 . connect . assert_not_called ( ) [EOL] connection . handle [EOL] self . assertEqual ( connection . state , [string] ) [EOL] self . assertNotEqual ( connection . handle , None ) [EOL] psycopg2 . connect . assert_called_once ( ) [EOL] [EOL] def test_cancel_open_connections_empty ( self ) : [EOL] self . assertEqual ( len ( list ( self . adapter . cancel_open_connections ( ) ) ) , [number] ) [EOL] [EOL] def test_cancel_open_connections_master ( self ) : [EOL] key = self . adapter . connections . get_thread_identifier ( ) [EOL] self . adapter . connections . thread_connections [ key ] = mock_connection ( [string] ) [EOL] self . assertEqual ( len ( list ( self . adapter . cancel_open_connections ( ) ) ) , [number] ) [EOL] [EOL] def test_cancel_open_connections_single ( self ) : [EOL] master = mock_connection ( [string] ) [EOL] model = mock_connection ( [string] ) [EOL] key = self . adapter . connections . get_thread_identifier ( ) [EOL] model . handle . get_backend_pid . return_value = [number] [EOL] self . adapter . connections . thread_connections . update ( { key : master , [number] : model , } ) [EOL] with mock . patch . object ( self . adapter . connections , [string] ) as add_query : [EOL] query_result = mock . MagicMock ( ) [EOL] add_query . return_value = ( None , query_result ) [EOL] [EOL] self . assertEqual ( len ( list ( self . adapter . cancel_open_connections ( ) ) ) , [number] ) [EOL] [EOL] add_query . assert_called_once_with ( [string] ) [EOL] [EOL] master . handle . get_backend_pid . assert_not_called ( ) [EOL] [EOL] @ mock . patch ( [string] ) def test_default_keepalive ( self , psycopg2 ) : [EOL] connection = self . adapter . acquire_connection ( [string] ) [EOL] [EOL] psycopg2 . connect . assert_not_called ( ) [EOL] connection . handle [EOL] psycopg2 . connect . assert_called_once_with ( dbname = [string] , user = [string] , host = [string] , password = [string] , port = [number] , connect_timeout = [number] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_changed_keepalive ( self , psycopg2 ) : [EOL] self . config . credentials = self . config . credentials . replace ( keepalives_idle = [number] ) [EOL] connection = self . adapter . acquire_connection ( [string] ) [EOL] [EOL] psycopg2 . connect . assert_not_called ( ) [EOL] connection . handle [EOL] psycopg2 . connect . assert_called_once_with ( dbname = [string] , user = [string] , host = [string] , password = [string] , port = [number] , connect_timeout = [number] , keepalives_idle = [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) def test_role ( self , psycopg2 ) : [EOL] self . config . credentials = self . config . credentials . replace ( role = [string] ) [EOL] connection = self . adapter . acquire_connection ( [string] ) [EOL] [EOL] cursor = connection . handle . cursor ( ) [EOL] [EOL] cursor . execute . assert_called_once_with ( [string] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_search_path ( self , psycopg2 ) : [EOL] self . config . credentials = self . config . credentials . replace ( search_path = [string] ) [EOL] connection = self . adapter . acquire_connection ( [string] ) [EOL] [EOL] psycopg2 . connect . assert_not_called ( ) [EOL] connection . handle [EOL] psycopg2 . connect . assert_called_once_with ( dbname = [string] , user = [string] , host = [string] , password = [string] , port = [number] , connect_timeout = [number] , options = [string] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_sslmode ( self , psycopg2 ) : [EOL] self . config . credentials = self . config . credentials . replace ( sslmode = [string] ) [EOL] connection = self . adapter . acquire_connection ( [string] ) [EOL] [EOL] psycopg2 . connect . assert_not_called ( ) [EOL] connection . handle [EOL] psycopg2 . connect . assert_called_once_with ( dbname = [string] , user = [string] , host = [string] , password = [string] , port = [number] , connect_timeout = [number] , sslmode = [string] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_schema_with_space ( self , psycopg2 ) : [EOL] self . config . credentials = self . config . credentials . replace ( search_path = [string] ) [EOL] connection = self . adapter . acquire_connection ( [string] ) [EOL] [EOL] psycopg2 . connect . assert_not_called ( ) [EOL] connection . handle [EOL] psycopg2 . connect . assert_called_once_with ( dbname = [string] , user = [string] , host = [string] , password = [string] , port = [number] , connect_timeout = [number] , options = [string] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_set_zero_keepalive ( self , psycopg2 ) : [EOL] self . config . credentials = self . config . credentials . replace ( keepalives_idle = [number] ) [EOL] connection = self . adapter . acquire_connection ( [string] ) [EOL] [EOL] psycopg2 . connect . assert_not_called ( ) [EOL] connection . handle [EOL] psycopg2 . connect . assert_called_once_with ( dbname = [string] , user = [string] , host = [string] , password = [string] , port = [number] , connect_timeout = [number] ) [EOL] [EOL] @ mock . patch . object ( PostgresAdapter , [string] ) @ mock . patch . object ( PostgresAdapter , [string] ) def test_get_catalog_various_schemas ( self , mock_get_schemas , mock_execute ) : [EOL] column_names = [ [string] , [string] , [string] ] [EOL] rows = [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , None , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ] [EOL] mock_execute . return_value = agate . Table ( rows = rows , column_names = column_names ) [EOL] [EOL] mock_get_schemas . return_value . items . return_value = [ ( mock . MagicMock ( database = [string] ) , { [string] , [string] , [string] } ) ] [EOL] [EOL] mock_manifest = mock . MagicMock ( ) [EOL] mock_manifest . get_used_schemas . return_value = { ( [string] , [string] ) , ( [string] , [string] ) } [EOL] [EOL] catalog , exceptions = self . adapter . get_catalog ( mock_manifest ) [EOL] self . assertEqual ( set ( map ( tuple , catalog ) ) , { ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) } ) [EOL] self . assertEqual ( exceptions , [ ] ) [EOL] [EOL] [EOL] class TestConnectingPostgresAdapter ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] flags . STRICT_MODE = False [EOL] [EOL] self . target_dict = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] } [EOL] [EOL] profile_cfg = { [string] : { [string] : self . target_dict , } , [string] : [string] } [EOL] project_cfg = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : False , [string] : True , } , [string] : [number] , } [EOL] [EOL] self . config = config_from_parts_or_dicts ( project_cfg , profile_cfg ) [EOL] [EOL] self . handle = mock . MagicMock ( spec = psycopg2_extensions . connection ) [EOL] self . cursor = self . handle . cursor . return_value [EOL] self . mock_execute = self . cursor . execute [EOL] self . patcher = mock . patch ( [string] ) [EOL] self . psycopg2 = self . patcher . start ( ) [EOL] [EOL] self . load_patch = mock . patch ( [string] ) [EOL] self . mock_parse_result = self . load_patch . start ( ) [EOL] self . mock_parse_result . return_value = ParseResult . rpc ( ) [EOL] [EOL] self . psycopg2 . connect . return_value = self . handle [EOL] self . adapter = PostgresAdapter ( self . config ) [EOL] self . adapter . _macro_manifest_lazy = load_internal_manifest_macros ( self . config ) [EOL] self . adapter . connections . query_header = MacroQueryStringSetter ( self . config , self . adapter . _macro_manifest_lazy ) [EOL] [EOL] self . qh_patch = mock . patch . object ( self . adapter . connections . query_header , [string] ) [EOL] self . mock_query_header_add = self . qh_patch . start ( ) [EOL] self . mock_query_header_add . side_effect = lambda q : [string] . format ( q ) [EOL] self . adapter . acquire_connection ( ) [EOL] inject_adapter ( self . adapter , PostgresPlugin ) [EOL] [EOL] def tearDown ( self ) : [EOL] [comment] [EOL] self . adapter . cleanup_connections ( ) [EOL] self . qh_patch . stop ( ) [EOL] self . patcher . stop ( ) [EOL] self . load_patch . stop ( ) [EOL] clear_plugin ( PostgresPlugin ) [EOL] [EOL] def test_quoting_on_drop_schema ( self ) : [EOL] relation = self . adapter . Relation . create ( database = [string] , schema = [string] , quote_policy = self . adapter . config . quoting , ) [EOL] self . adapter . drop_schema ( relation ) [EOL] [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] def test_quoting_on_drop ( self ) : [EOL] relation = self . adapter . Relation . create ( database = [string] , schema = [string] , identifier = [string] , type = [string] , quote_policy = self . adapter . config . quoting , ) [EOL] self . adapter . drop_relation ( relation ) [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] def test_quoting_on_truncate ( self ) : [EOL] relation = self . adapter . Relation . create ( database = [string] , schema = [string] , identifier = [string] , type = [string] , quote_policy = self . adapter . config . quoting , ) [EOL] self . adapter . truncate_relation ( relation ) [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] def test_quoting_on_rename ( self ) : [EOL] from_relation = self . adapter . Relation . create ( database = [string] , schema = [string] , identifier = [string] , type = [string] , quote_policy = self . adapter . config . quoting , ) [EOL] to_relation = self . adapter . Relation . create ( database = [string] , schema = [string] , identifier = [string] , type = [string] , quote_policy = self . adapter . config . quoting , ) [EOL] [EOL] self . adapter . rename_relation ( from_relation = from_relation , to_relation = to_relation ) [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] def test_debug_connection_ok ( self ) : [EOL] DebugTask . validate_connection ( self . target_dict ) [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] def test_debug_connection_fail_nopass ( self ) : [EOL] del self . target_dict [ [string] ] [EOL] with self . assertRaises ( DbtConfigError ) : [EOL] DebugTask . validate_connection ( self . target_dict ) [EOL] [EOL] def test_connection_fail_select ( self ) : [EOL] self . mock_execute . side_effect = DatabaseError ( ) [EOL] with self . assertRaises ( DbtConfigError ) : [EOL] DebugTask . validate_connection ( self . target_dict ) [EOL] self . mock_execute . assert_has_calls ( [ mock . call ( [string] , None ) ] ) [EOL] [EOL] def test_dbname_verification_is_case_insensitive ( self ) : [EOL] [comment] [EOL] self . target_dict [ [string] ] = [string] [EOL] profile_cfg = { [string] : { [string] : self . target_dict , } , [string] : [string] } [EOL] project_cfg = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : False , [string] : True , } , [string] : [number] , } [EOL] self . config = config_from_parts_or_dicts ( project_cfg , profile_cfg ) [EOL] self . adapter . cleanup_connections ( ) [EOL] self . _adapter = PostgresAdapter ( self . config ) [EOL] self . adapter . verify_database ( [string] ) [EOL] [EOL] [EOL] class TestPostgresFilterCatalog ( unittest . TestCase ) : [EOL] def test__catalog_filter_table ( self ) : [EOL] manifest = mock . MagicMock ( ) [EOL] manifest . get_used_schemas . return_value = [ [ [string] , [string] ] , [ [string] , [string] ] ] [EOL] column_names = [ [string] , [string] , [string] , [string] ] [EOL] rows = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , ] [EOL] table = agate . Table ( rows , column_names , agate_helper . DEFAULT_TYPE_TESTER ) [EOL] [EOL] result = PostgresAdapter . _catalog_filter_table ( table , manifest ) [EOL] assert len ( result ) == [number] [EOL] for row in result . rows : [EOL] assert isinstance ( row [ [string] ] , str ) [EOL] assert isinstance ( row [ [string] ] , str ) [EOL] assert isinstance ( row [ [string] ] , str ) [EOL] assert isinstance ( row [ [string] ] , decimal . Decimal ) [EOL] [EOL] [EOL] class TestPostgresAdapterConversions ( TestAdapterConversions ) : [EOL] def test_convert_text_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . Text ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert PostgresAdapter . convert_text_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_number_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . Number ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert PostgresAdapter . convert_number_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_boolean_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . Boolean ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert PostgresAdapter . convert_boolean_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_datetime_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , [ agate . DateTime , agate_helper . ISODateTime , agate . DateTime ] ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert PostgresAdapter . convert_datetime_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_date_type ( self ) : [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . Date ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert PostgresAdapter . convert_date_type ( agate_table , col_idx ) == expect [EOL] [EOL] def test_convert_time_type ( self ) : [EOL] [comment] [EOL] agate . TimeDelta [EOL] rows = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] agate_table = self . _make_table_of ( rows , agate . TimeDelta ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] for col_idx , expect in enumerate ( expected ) : [EOL] assert PostgresAdapter . convert_time_type ( agate_table , col_idx ) == expect [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str],builtins.str]]$ 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str],builtins.str]]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],builtins.int,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from dbt . exceptions import raise_duplicate_macro_name , CompilationException [EOL] from . utils import MockMacro [EOL] [EOL] [EOL] def test_raise_duplicate_macros_different_package ( ) : [EOL] macro_1 = MockMacro ( package = [string] , name = [string] ) [EOL] macro_2 = MockMacro ( package = [string] , name = [string] ) [EOL] [EOL] with pytest . raises ( CompilationException ) as exc : [EOL] raise_duplicate_macro_name ( node_1 = macro_1 , node_2 = macro_2 , namespace = [string] , ) [EOL] assert [string] in str ( exc . value ) [EOL] assert [string] in str ( exc . value ) [EOL] assert [string] in str ( exc . value ) [EOL] assert [string] in str ( exc . value ) [EOL] [EOL] [EOL] def test_raise_duplicate_macros_same_package ( ) : [EOL] macro_1 = MockMacro ( package = [string] , name = [string] ) [EOL] macro_2 = MockMacro ( package = [string] , name = [string] ) [EOL] [EOL] with pytest . raises ( CompilationException ) as exc : [EOL] raise_duplicate_macro_name ( node_1 = macro_1 , node_2 = macro_2 , namespace = [string] , ) [EOL] assert [string] in str ( exc . value ) [EOL] assert [string] in str ( exc . value ) [EOL] assert [string] not in str ( exc . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Dict , Type [EOL] import test [EOL] import typing [EOL] import copy [EOL] import pickle [EOL] from datetime import timedelta [EOL] [EOL] from dbt . contracts . graph . unparsed import ( UnparsedNode , UnparsedRunHook , UnparsedMacro , Time , TimePeriod , FreshnessStatus , FreshnessThreshold , Quoting , UnparsedSourceDefinition , UnparsedSourceTableDefinition , UnparsedDocumentationFile , UnparsedColumn , UnparsedNodeUpdate , Docs , UnparsedReport , MaturityType , ReportOwner , ExposureType ) [EOL] from dbt . node_types import NodeType [EOL] from . utils import ContractTestCase [EOL] [EOL] [EOL] class TestUnparsedMacro ( ContractTestCase ) : [EOL] ContractType = UnparsedMacro [EOL] [EOL] def test_ok ( self ) : [EOL] macro_dict = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] macro = self . ContractType ( path = [string] , original_file_path = [string] , package_name = [string] , raw_sql = [string] , root_path = [string] , resource_type = NodeType . Macro , ) [EOL] self . assert_symmetric ( macro , macro_dict ) [EOL] pickle . loads ( pickle . dumps ( macro ) ) [EOL] [EOL] def test_invalid_missing_field ( self ) : [EOL] macro_dict = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] self . assert_fails_validation ( macro_dict ) [EOL] [EOL] def test_invalid_extra_field ( self ) : [EOL] macro_dict = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] self . assert_fails_validation ( macro_dict ) [EOL] [EOL] [EOL] class TestUnparsedNode ( ContractTestCase ) : [EOL] ContractType = UnparsedNode [EOL] [EOL] def test_ok ( self ) : [EOL] node_dict = { [string] : [string] , [string] : [string] , [string] : NodeType . Model , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] node = self . ContractType ( package_name = [string] , root_path = [string] , path = [string] , original_file_path = [string] , raw_sql = [string] , name = [string] , resource_type = NodeType . Model , ) [EOL] self . assert_symmetric ( node , node_dict ) [EOL] self . assertFalse ( node . empty ) [EOL] [EOL] self . assert_fails_validation ( node_dict , cls = UnparsedRunHook ) [EOL] self . assert_fails_validation ( node_dict , cls = UnparsedMacro ) [EOL] pickle . loads ( pickle . dumps ( node ) ) [EOL] [EOL] def test_empty ( self ) : [EOL] node_dict = { [string] : [string] , [string] : [string] , [string] : NodeType . Model , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] node = UnparsedNode ( package_name = [string] , root_path = [string] , path = [string] , original_file_path = [string] , raw_sql = [string] , name = [string] , resource_type = NodeType . Model , ) [EOL] self . assert_symmetric ( node , node_dict ) [EOL] self . assertTrue ( node . empty ) [EOL] [EOL] self . assert_fails_validation ( node_dict , cls = UnparsedRunHook ) [EOL] self . assert_fails_validation ( node_dict , cls = UnparsedMacro ) [EOL] [EOL] def test_bad_type ( self ) : [EOL] node_dict = { [string] : [string] , [string] : [string] , [string] : NodeType . Source , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] self . assert_fails_validation ( node_dict ) [EOL] [EOL] [EOL] class TestUnparsedRunHook ( ContractTestCase ) : [EOL] ContractType = UnparsedRunHook [EOL] [EOL] def test_ok ( self ) : [EOL] node_dict = { [string] : [string] , [string] : [string] , [string] : NodeType . Operation , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } [EOL] node = self . ContractType ( package_name = [string] , root_path = [string] , path = [string] , original_file_path = [string] , raw_sql = [string] , name = [string] , resource_type = NodeType . Operation , index = [number] , ) [EOL] self . assert_symmetric ( node , node_dict ) [EOL] self . assert_fails_validation ( node_dict , cls = UnparsedNode ) [EOL] pickle . loads ( pickle . dumps ( node ) ) [EOL] [EOL] def test_bad_type ( self ) : [EOL] node_dict = { [string] : [string] , [string] : [string] , [string] : NodeType . Model , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } [EOL] self . assert_fails_validation ( node_dict ) [EOL] [EOL] [EOL] class TestFreshnessThreshold ( ContractTestCase ) : [EOL] ContractType = FreshnessThreshold [EOL] [EOL] def test_empty ( self ) : [EOL] empty = self . ContractType ( None , None ) [EOL] self . assert_symmetric ( empty , { } ) [EOL] self . assertEqual ( empty . status ( float ( [string] ) ) , FreshnessStatus . Pass ) [EOL] self . assertEqual ( empty . status ( [number] ) , FreshnessStatus . Pass ) [EOL] [EOL] def test_both ( self ) : [EOL] threshold = self . ContractType ( warn_after = Time ( count = [number] , period = TimePeriod . hour ) , error_after = Time ( count = [number] , period = TimePeriod . day ) , ) [EOL] dct = { [string] : { [string] : [number] , [string] : [string] } , [string] : { [string] : [number] , [string] : [string] } } [EOL] self . assert_symmetric ( threshold , dct ) [EOL] [EOL] error_seconds = timedelta ( days = [number] ) . total_seconds ( ) [EOL] warn_seconds = timedelta ( days = [number] ) . total_seconds ( ) [EOL] pass_seconds = timedelta ( hours = [number] ) . total_seconds ( ) [EOL] self . assertEqual ( threshold . status ( error_seconds ) , FreshnessStatus . Error ) [EOL] self . assertEqual ( threshold . status ( warn_seconds ) , FreshnessStatus . Warn ) [EOL] self . assertEqual ( threshold . status ( pass_seconds ) , FreshnessStatus . Pass ) [EOL] pickle . loads ( pickle . dumps ( threshold ) ) [EOL] [EOL] def test_merged ( self ) : [EOL] t1 = self . ContractType ( warn_after = Time ( count = [number] , period = TimePeriod . hour ) , error_after = Time ( count = [number] , period = TimePeriod . day ) , ) [EOL] t2 = self . ContractType ( warn_after = Time ( count = [number] , period = TimePeriod . hour ) , ) [EOL] threshold = self . ContractType ( warn_after = Time ( count = [number] , period = TimePeriod . hour ) , error_after = Time ( count = [number] , period = TimePeriod . day ) , ) [EOL] self . assertEqual ( threshold , t1 . merged ( t2 ) ) [EOL] [EOL] error_seconds = timedelta ( days = [number] ) . total_seconds ( ) [EOL] warn_seconds = timedelta ( days = [number] ) . total_seconds ( ) [EOL] pass_seconds = timedelta ( hours = [number] ) . total_seconds ( ) [EOL] self . assertEqual ( threshold . status ( error_seconds ) , FreshnessStatus . Error ) [EOL] self . assertEqual ( threshold . status ( warn_seconds ) , FreshnessStatus . Warn ) [EOL] self . assertEqual ( threshold . status ( pass_seconds ) , FreshnessStatus . Pass ) [EOL] [EOL] [EOL] class TestQuoting ( ContractTestCase ) : [EOL] ContractType = Quoting [EOL] [EOL] def test_empty ( self ) : [EOL] empty = self . ContractType ( ) [EOL] self . assert_symmetric ( empty , { } ) [EOL] [EOL] def test_partial ( self ) : [EOL] a = self . ContractType ( None , True , False ) [EOL] b = self . ContractType ( True , False , None ) [EOL] self . assert_symmetric ( a , { [string] : True , [string] : False } ) [EOL] self . assert_symmetric ( b , { [string] : True , [string] : False } ) [EOL] [EOL] c = a . merged ( b ) [EOL] self . assertEqual ( c , self . ContractType ( True , False , False ) ) [EOL] self . assert_symmetric ( c , { [string] : True , [string] : False , [string] : False } ) [EOL] pickle . loads ( pickle . dumps ( c ) ) [EOL] [EOL] [EOL] class TestUnparsedSourceDefinition ( ContractTestCase ) : [EOL] ContractType = UnparsedSourceDefinition [EOL] [EOL] def test_defaults ( self ) : [EOL] minimum = self . ContractType ( name = [string] ) [EOL] from_dict = { [string] : [string] } [EOL] to_dict = { [string] : [string] , [string] : [string] , [string] : { } , [string] : { } , [string] : [ ] , [string] : [string] , [string] : { } , [string] : [ ] , } [EOL] self . assert_from_dict ( minimum , from_dict ) [EOL] self . assert_to_dict ( minimum , to_dict ) [EOL] [EOL] def test_contents ( self ) : [EOL] empty = self . ContractType ( name = [string] , description = [string] , quoting = Quoting ( database = False ) , loader = [string] , freshness = FreshnessThreshold ( ) , tables = [ ] , meta = { } , ) [EOL] dct = { [string] : [string] , [string] : [string] , [string] : { [string] : False } , [string] : [string] , [string] : { } , [string] : [ ] , [string] : { } , [string] : [ ] , } [EOL] self . assert_symmetric ( empty , dct ) [EOL] [EOL] def test_table_defaults ( self ) : [EOL] table_1 = UnparsedSourceTableDefinition ( name = [string] ) [EOL] table_2 = UnparsedSourceTableDefinition ( name = [string] , description = [string] , quoting = Quoting ( database = True ) , ) [EOL] source = self . ContractType ( name = [string] , tables = [ table_1 , table_2 ] ) [EOL] from_dict = { [string] : [string] , [string] : [ { [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : { [string] : True } , } , ] , } [EOL] to_dict = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { } , [string] : { } , [string] : { } , [string] : [ { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : [ ] , } , { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : [ ] , [string] : [ ] , [string] : { [string] : True } , [string] : { } , [string] : { } , [string] : [ ] , } , ] , [string] : [ ] , } [EOL] self . assert_from_dict ( source , from_dict ) [EOL] self . assert_symmetric ( source , to_dict ) [EOL] pickle . loads ( pickle . dumps ( source ) ) [EOL] [EOL] [EOL] class TestUnparsedDocumentationFile ( ContractTestCase ) : [EOL] ContractType = UnparsedDocumentationFile [EOL] [EOL] def test_ok ( self ) : [EOL] doc = self . ContractType ( package_name = [string] , root_path = [string] , path = [string] , original_file_path = [string] , file_contents = [string] , ) [EOL] doc_dict = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] self . assert_symmetric ( doc , doc_dict ) [EOL] self . assertEqual ( doc . resource_type , NodeType . Documentation ) [EOL] self . assert_fails_validation ( doc_dict , UnparsedNode ) [EOL] pickle . loads ( pickle . dumps ( doc ) ) [EOL] [EOL] def test_extra_field ( self ) : [EOL] self . assert_fails_validation ( { } ) [EOL] doc_dict = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] self . assert_fails_validation ( doc_dict ) [EOL] [EOL] [EOL] class TestUnparsedNodeUpdate ( ContractTestCase ) : [EOL] ContractType = UnparsedNodeUpdate [EOL] [EOL] def test_defaults ( self ) : [EOL] minimum = self . ContractType ( name = [string] , yaml_key = [string] , original_file_path = [string] , package_name = [string] , ) [EOL] from_dict = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] to_dict = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [string] , [string] : { [string] : True } , [string] : [ ] , [string] : { } , } [EOL] self . assert_from_dict ( minimum , from_dict ) [EOL] self . assert_to_dict ( minimum , to_dict ) [EOL] [EOL] def test_contents ( self ) : [EOL] update = self . ContractType ( name = [string] , yaml_key = [string] , original_file_path = [string] , package_name = [string] , description = [string] , tests = [ [string] ] , meta = { [string] : [ [string] , [string] ] } , columns = [ UnparsedColumn ( name = [string] , description = [string] , meta = { [string] : [string] } , ) , UnparsedColumn ( name = [string] , description = [string] , tests = [ [string] , { [string] : { [string] : [ [string] , [string] ] } } ] , meta = { } , tags = [ [string] , [string] ] , ) , ] , docs = Docs ( show = False ) , ) [EOL] dct = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : { [string] : [ [string] , [string] ] } , [string] : [ { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : [ ] , [string] : { [string] : [string] } , [string] : [ ] , } , { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : [ [string] , { [string] : { [string] : [ [string] , [string] ] } } ] , [string] : { } , [string] : [ [string] , [string] ] , } , ] , [string] : { [string] : False } , } [EOL] self . assert_symmetric ( update , dct ) [EOL] pickle . loads ( pickle . dumps ( update ) ) [EOL] [EOL] def test_bad_test_type ( self ) : [EOL] dct = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : { [string] : [ [string] , [string] ] } , [string] : [ { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : [ ] , [string] : { [string] : [string] } , } , { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : [ [number] , { [string] : { [string] : [ [string] , [string] ] } } ] , [string] : { } , [string] : [string] , [string] : [string] , } , ] , [string] : { [string] : True } , } [EOL] self . assert_fails_validation ( dct ) [EOL] [EOL] dct = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : { [string] : [ [string] , [string] ] } , [string] : [ { [string] : [string] , [string] : { [string] : True } , [string] : [ ] , [string] : { [string] : [string] } , } , { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : [ [string] , { [string] : { [string] : [ [string] , [string] ] } } ] , [string] : { } , [string] : [string] , [string] : [string] , } , ] , [string] : { [string] : True } , } [EOL] self . assert_fails_validation ( dct ) [EOL] [EOL] [comment] [EOL] dct = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : { [string] : [ [string] , [string] ] } , [string] : [ { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : [ ] , [string] : { [string] : [string] } , } , { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : [ [string] , { [string] : { [string] : [ [string] , [string] ] } } ] , [string] : { } , [string] : [string] , [string] : [string] , } , ] , [string] : { [string] : True } , } [EOL] self . assert_fails_validation ( dct ) [EOL] [EOL] [EOL] class TestUnparsedReport ( ContractTestCase ) : [EOL] ContractType = UnparsedReport [EOL] [EOL] def get_ok_dict ( self ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , ] } [EOL] [EOL] def test_ok ( self ) : [EOL] report = self . ContractType ( name = [string] , type = ExposureType . Dashboard , owner = ReportOwner ( email = [string] ) , maturity = MaturityType . Medium , url = [string] , description = [string] , depends_on = [ [string] , [string] ] , ) [EOL] dct = self . get_ok_dict ( ) [EOL] self . assert_symmetric ( report , dct ) [EOL] pickle . loads ( pickle . dumps ( report ) ) [EOL] [EOL] def test_ok_exposures ( self ) : [EOL] for exposure_allowed in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] tst = self . get_ok_dict ( ) [EOL] tst [ [string] ] = exposure_allowed [EOL] assert self . ContractType . from_dict ( tst ) . type == exposure_allowed [EOL] [EOL] def test_bad_exposure ( self ) : [EOL] [comment] [EOL] for exposure_not_allowed in ( None , [string] ) : [EOL] tst = self . get_ok_dict ( ) [EOL] tst [ [string] ] = exposure_not_allowed [EOL] self . assert_fails_validation ( tst ) [EOL] [EOL] def test_no_exposure ( self ) : [EOL] tst = self . get_ok_dict ( ) [EOL] del tst [ [string] ] [EOL] self . assert_fails_validation ( tst ) [EOL] [EOL] def test_ok_maturities ( self ) : [EOL] for maturity_allowed in ( None , [string] , [string] , [string] ) : [EOL] tst = self . get_ok_dict ( ) [EOL] tst [ [string] ] = maturity_allowed [EOL] assert self . ContractType . from_dict ( tst ) . maturity == maturity_allowed [EOL] [EOL] tst = self . get_ok_dict ( ) [EOL] del tst [ [string] ] [EOL] assert self . ContractType . from_dict ( tst ) . maturity is None [EOL] [EOL] def test_bad_maturity ( self ) : [EOL] tst = self . get_ok_dict ( ) [EOL] tst [ [string] ] = [string] [EOL] self . assert_fails_validation ( tst ) [EOL] [EOL] def test_bad_owner_missing_things ( self ) : [EOL] tst = self . get_ok_dict ( ) [EOL] del tst [ [string] ] [ [string] ] [EOL] self . assert_fails_validation ( tst ) [EOL] [EOL] del tst [ [string] ] [EOL] self . assert_fails_validation ( tst ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_graph_unparsed.TestUnparsedMacro]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_graph_unparsed.TestUnparsedNode]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_graph_unparsed.TestUnparsedRunHook]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_graph_unparsed.TestFreshnessThreshold]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_graph_unparsed.TestQuoting]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_graph_unparsed.TestUnparsedSourceDefinition]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Any],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Any],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_graph_unparsed.TestUnparsedDocumentationFile]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_graph_unparsed.TestUnparsedNodeUpdate]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]],builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,builtins.str],typing.List[typing.Any],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]],builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,builtins.str],typing.List[typing.Any],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]],builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,builtins.str],typing.List[typing.Any],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]],builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,builtins.str],typing.List[typing.Any],builtins.str]]]],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]],builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,builtins.str],typing.List[typing.Any],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]],builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,builtins.str],typing.List[typing.Any],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]],builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,builtins.str],typing.List[typing.Any],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.Dict[builtins.str,builtins.bool],typing.List[builtins.str],typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]],builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,builtins.str],typing.List[typing.Any],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_graph_unparsed.TestUnparsedReport]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from dbt . exceptions import RuntimeException [EOL] from dbt . graph . selector_spec import ( SelectionCriteria , SelectionIntersection , SelectionDifference , SelectionUnion , ) [EOL] from dbt . graph . selector_methods import MethodName [EOL] import os [EOL] [EOL] [EOL] def test_raw_parse_simple ( ) : [EOL] raw = [string] [EOL] result = SelectionCriteria . from_single_spec ( raw ) [EOL] assert result . raw == raw [EOL] assert result . method == MethodName . FQN [EOL] assert result . method_arguments == [ ] [EOL] assert result . value == raw [EOL] assert not result . childrens_parents [EOL] assert not result . children [EOL] assert not result . parents [EOL] assert result . parents_depth is None [EOL] assert result . children_depth is None [EOL] [EOL] [EOL] def test_raw_parse_simple_infer_path ( ) : [EOL] raw = os . path . join ( [string] , [string] ) [EOL] result = SelectionCriteria . from_single_spec ( raw ) [EOL] assert result . raw == raw [EOL] assert result . method == MethodName . Path [EOL] assert result . method_arguments == [ ] [EOL] assert result . value == raw [EOL] assert not result . childrens_parents [EOL] assert not result . children [EOL] assert not result . parents [EOL] assert result . parents_depth is None [EOL] assert result . children_depth is None [EOL] [EOL] [EOL] def test_raw_parse_simple_infer_path_modified ( ) : [EOL] raw = [string] + os . path . join ( [string] , [string] ) [EOL] result = SelectionCriteria . from_single_spec ( raw ) [EOL] assert result . raw == raw [EOL] assert result . method == MethodName . Path [EOL] assert result . method_arguments == [ ] [EOL] assert result . value == raw [ [number] : ] [EOL] assert result . childrens_parents [EOL] assert not result . children [EOL] assert not result . parents [EOL] assert result . parents_depth is None [EOL] assert result . children_depth is None [EOL] [EOL] [EOL] def test_raw_parse_simple_infer_fqn_parents ( ) : [EOL] raw = [string] [EOL] result = SelectionCriteria . from_single_spec ( raw ) [EOL] assert result . raw == raw [EOL] assert result . method == MethodName . FQN [EOL] assert result . method_arguments == [ ] [EOL] assert result . value == [string] [EOL] assert not result . childrens_parents [EOL] assert not result . children [EOL] assert result . parents [EOL] assert result . parents_depth is None [EOL] assert result . children_depth is None [EOL] [EOL] [EOL] def test_raw_parse_simple_infer_fqn_children ( ) : [EOL] raw = [string] [EOL] result = SelectionCriteria . from_single_spec ( raw ) [EOL] assert result . raw == raw [EOL] assert result . method == MethodName . FQN [EOL] assert result . method_arguments == [ ] [EOL] assert result . value == [string] [EOL] assert not result . childrens_parents [EOL] assert result . children [EOL] assert not result . parents [EOL] assert result . parents_depth is None [EOL] assert result . children_depth is None [EOL] [EOL] [EOL] def test_raw_parse_complex ( ) : [EOL] raw = [string] [EOL] result = SelectionCriteria . from_single_spec ( raw ) [EOL] assert result . raw == raw [EOL] assert result . method == MethodName . Config [EOL] assert result . method_arguments == [ [string] , [string] ] [EOL] assert result . value == [string] [EOL] assert not result . childrens_parents [EOL] assert result . children [EOL] assert result . parents [EOL] assert result . parents_depth == [number] [EOL] assert result . children_depth == [number] [EOL] [EOL] [EOL] def test_raw_parse_weird ( ) : [EOL] [comment] [EOL] [comment] [EOL] result = SelectionCriteria . from_single_spec ( [string] ) [EOL] assert result . raw == [string] [EOL] assert result . method == MethodName . FQN [EOL] assert result . method_arguments == [ ] [EOL] assert result . value == [string] [EOL] assert not result . childrens_parents [EOL] assert not result . children [EOL] assert not result . parents [EOL] assert result . parents_depth is None [EOL] assert result . children_depth is None [EOL] [EOL] [EOL] def test_raw_parse_invalid ( ) : [EOL] with pytest . raises ( RuntimeException ) : [EOL] SelectionCriteria . from_single_spec ( [string] ) [EOL] [EOL] with pytest . raises ( RuntimeException ) : [EOL] SelectionCriteria . from_single_spec ( [string] ) [EOL] [EOL] [EOL] def test_intersection ( ) : [EOL] fqn_a = SelectionCriteria . from_single_spec ( [string] ) [EOL] fqn_b = SelectionCriteria . from_single_spec ( [string] ) [EOL] intersection = SelectionIntersection ( components = [ fqn_a , fqn_b ] ) [EOL] assert list ( intersection ) == [ fqn_a , fqn_b ] [EOL] combined = intersection . combine_selections ( [ { [string] , [string] , [string] } , { [string] , [string] } ] ) [EOL] assert combined == { [string] } [EOL] [EOL] [EOL] def test_difference ( ) : [EOL] fqn_a = SelectionCriteria . from_single_spec ( [string] ) [EOL] fqn_b = SelectionCriteria . from_single_spec ( [string] ) [EOL] difference = SelectionDifference ( components = [ fqn_a , fqn_b ] ) [EOL] assert list ( difference ) == [ fqn_a , fqn_b ] [EOL] combined = difference . combine_selections ( [ { [string] , [string] , [string] } , { [string] , [string] } ] ) [EOL] assert combined == { [string] , [string] } [EOL] [EOL] fqn_c = SelectionCriteria . from_single_spec ( [string] ) [EOL] difference = SelectionDifference ( components = [ fqn_a , fqn_b , fqn_c ] ) [EOL] assert list ( difference ) == [ fqn_a , fqn_b , fqn_c ] [EOL] combined = difference . combine_selections ( [ { [string] , [string] , [string] } , { [string] , [string] } , { [string] } ] ) [EOL] assert combined == { [string] } [EOL] [EOL] [EOL] def test_union ( ) : [EOL] fqn_a = SelectionCriteria . from_single_spec ( [string] ) [EOL] fqn_b = SelectionCriteria . from_single_spec ( [string] ) [EOL] fqn_c = SelectionCriteria . from_single_spec ( [string] ) [EOL] difference = SelectionUnion ( components = [ fqn_a , fqn_b , fqn_c ] ) [EOL] combined = difference . combine_selections ( [ { [string] , [string] } , { [string] , [string] } , { [string] } ] ) [EOL] assert combined == { [string] , [string] , [string] , [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] from dataclasses import dataclass , field [EOL] from hologram import JsonSchemaMixin [EOL] from typing import List , Dict [EOL] import pytest [EOL] from dbt . contracts . graph . model_config import MergeBehavior , ShowBehavior , CompareBehavior [EOL] [EOL] [EOL] @ dataclass class ThingWithMergeBehavior ( JsonSchemaMixin ) : [EOL] default_behavior = ... [EOL] appended = field ( metadata = { [string] : MergeBehavior . Append } ) [EOL] updated = field ( metadata = { [string] : MergeBehavior . Update } ) [EOL] clobbered = field ( metadata = { [string] : MergeBehavior . Clobber } ) [EOL] [EOL] [EOL] [EOL] def test_merge_behavior_meta ( ) : [EOL] existing = { [string] : [string] } [EOL] initial_existing = existing . copy ( ) [EOL] assert set ( MergeBehavior ) == { MergeBehavior . Append , MergeBehavior . Update , MergeBehavior . Clobber } [EOL] for behavior in MergeBehavior : [EOL] assert behavior . meta ( ) == { [string] : behavior } [EOL] assert behavior . meta ( existing ) == { [string] : behavior , [string] : [string] } [EOL] assert existing == initial_existing [EOL] [EOL] [EOL] def test_merge_behavior_from_field ( ) : [EOL] fields = [ f [ [number] ] for f in ThingWithMergeBehavior . _get_fields ( ) ] [EOL] fields = { name : f for f , name in ThingWithMergeBehavior . _get_fields ( ) } [EOL] assert set ( fields ) == { [string] , [string] , [string] , [string] } [EOL] assert MergeBehavior . from_field ( fields [ [string] ] ) == MergeBehavior . Clobber [EOL] assert MergeBehavior . from_field ( fields [ [string] ] ) == MergeBehavior . Append [EOL] assert MergeBehavior . from_field ( fields [ [string] ] ) == MergeBehavior . Update [EOL] assert MergeBehavior . from_field ( fields [ [string] ] ) == MergeBehavior . Clobber [EOL] [EOL] [EOL] @ dataclass class ThingWithShowBehavior ( JsonSchemaMixin ) : [EOL] default_behavior = ... [EOL] hidden = field ( metadata = { [string] : ShowBehavior . Hide } ) [EOL] shown = field ( metadata = { [string] : ShowBehavior . Show } ) [EOL] [EOL] [EOL] def test_show_behavior_meta ( ) : [EOL] existing = { [string] : [string] } [EOL] initial_existing = existing . copy ( ) [EOL] assert set ( ShowBehavior ) == { ShowBehavior . Hide , ShowBehavior . Show } [EOL] for behavior in ShowBehavior : [EOL] assert behavior . meta ( ) == { [string] : behavior } [EOL] assert behavior . meta ( existing ) == { [string] : behavior , [string] : [string] } [EOL] assert existing == initial_existing [EOL] [EOL] [EOL] def test_show_behavior_from_field ( ) : [EOL] fields = [ f [ [number] ] for f in ThingWithShowBehavior . _get_fields ( ) ] [EOL] fields = { name : f for f , name in ThingWithShowBehavior . _get_fields ( ) } [EOL] assert set ( fields ) == { [string] , [string] , [string] } [EOL] assert ShowBehavior . from_field ( fields [ [string] ] ) == ShowBehavior . Show [EOL] assert ShowBehavior . from_field ( fields [ [string] ] ) == ShowBehavior . Hide [EOL] assert ShowBehavior . from_field ( fields [ [string] ] ) == ShowBehavior . Show [EOL] [EOL] [EOL] @ dataclass class ThingWithCompareBehavior ( JsonSchemaMixin ) : [EOL] default_behavior = ... [EOL] included = field ( metadata = { [string] : CompareBehavior . Include } ) [EOL] excluded = field ( metadata = { [string] : CompareBehavior . Exclude } ) [EOL] [EOL] [EOL] def test_compare_behavior_meta ( ) : [EOL] existing = { [string] : [string] } [EOL] initial_existing = existing . copy ( ) [EOL] assert set ( CompareBehavior ) == { CompareBehavior . Include , CompareBehavior . Exclude } [EOL] for behavior in CompareBehavior : [EOL] assert behavior . meta ( ) == { [string] : behavior } [EOL] assert behavior . meta ( existing ) == { [string] : behavior , [string] : [string] } [EOL] assert existing == initial_existing [EOL] [EOL] [EOL] def test_compare_behavior_from_field ( ) : [EOL] fields = [ f [ [number] ] for f in ThingWithCompareBehavior . _get_fields ( ) ] [EOL] fields = { name : f for f , name in ThingWithCompareBehavior . _get_fields ( ) } [EOL] assert set ( fields ) == { [string] , [string] , [string] } [EOL] assert CompareBehavior . from_field ( fields [ [string] ] ) == CompareBehavior . Include [EOL] assert CompareBehavior . from_field ( fields [ [string] ] ) == CompareBehavior . Include [EOL] assert CompareBehavior . from_field ( fields [ [string] ] ) == CompareBehavior . Exclude [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Optional , Dict [EOL] import typing [EOL] import unittest [EOL] [EOL] import dbt . exceptions [EOL] import dbt . utils [EOL] [EOL] [EOL] class TestDeepMerge ( unittest . TestCase ) : [EOL] [EOL] def test__simple_cases ( self ) : [EOL] cases = [ { [string] : [ { } , { [string] : [number] } ] , [string] : { [string] : [number] } , [string] : [string] } , { [string] : [ { } , { [string] : [number] } , { [string] : [number] } ] , [string] : { [string] : [number] , [string] : [number] } , [string] : [string] } , ] [EOL] [EOL] for case in cases : [EOL] actual = dbt . utils . deep_merge ( * case [ [string] ] ) [EOL] self . assertEqual ( case [ [string] ] , actual , [string] . format ( case [ [string] ] , actual , case [ [string] ] ) ) [EOL] [EOL] [EOL] class TestMerge ( unittest . TestCase ) : [EOL] [EOL] def test__simple_cases ( self ) : [EOL] cases = [ { [string] : [ { } , { [string] : [number] } ] , [string] : { [string] : [number] } , [string] : [string] } , { [string] : [ { } , { [string] : [number] } , { [string] : [number] } ] , [string] : { [string] : [number] , [string] : [number] } , [string] : [string] } , ] [EOL] [EOL] for case in cases : [EOL] actual = dbt . utils . deep_merge ( * case [ [string] ] ) [EOL] self . assertEqual ( case [ [string] ] , actual , [string] . format ( case [ [string] ] , actual , case [ [string] ] ) ) [EOL] [EOL] [EOL] class TestDeepMap ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . input_value = { [string] : { [string] : [string] , [string] : [ [number] , [number] , [string] , [string] ] , } , [string] : [ { [string] : [string] , [string] : None , } , { [string] : [number] , [string] : [number] , } , ] , } [EOL] [EOL] @ staticmethod def intify_all ( value , _ ) : [EOL] try : [EOL] return int ( value ) [EOL] except ( TypeError , ValueError ) : [EOL] return - [number] [EOL] [EOL] def test__simple_cases ( self ) : [EOL] expected = { [string] : { [string] : - [number] , [string] : [ [number] , [number] , [number] , - [number] ] , } , [string] : [ { [string] : [number] , [string] : - [number] , } , { [string] : [number] , [string] : [number] , } , ] , } [EOL] actual = dbt . utils . deep_map ( self . intify_all , self . input_value ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] actual = dbt . utils . deep_map ( self . intify_all , expected ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] @ staticmethod def special_keypath ( value , keypath ) : [EOL] [EOL] if tuple ( keypath ) == ( [string] , [string] , [number] ) : [EOL] return [string] [EOL] else : [EOL] return value [EOL] [EOL] def test__keypath ( self ) : [EOL] expected = { [string] : { [string] : [string] , [string] : [ [number] , [string] , [string] , [string] ] , } , [string] : [ { [string] : [string] , [string] : None , } , { [string] : [number] , [string] : [number] , } , ] , } [EOL] actual = dbt . utils . deep_map ( self . special_keypath , self . input_value ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] actual = dbt . utils . deep_map ( self . special_keypath , expected ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] def test__noop ( self ) : [EOL] actual = dbt . utils . deep_map ( lambda x , _ : x , self . input_value ) [EOL] self . assertEqual ( actual , self . input_value ) [EOL] [EOL] def test_trivial ( self ) : [EOL] cases = [ [ ] , { } , [number] , [string] , None , True ] [EOL] for case in cases : [EOL] result = dbt . utils . deep_map ( lambda x , _ : x , case ) [EOL] self . assertEqual ( result , case ) [EOL] [EOL] with self . assertRaises ( dbt . exceptions . DbtConfigError ) : [EOL] dbt . utils . deep_map ( lambda x , _ : x , { [string] : object ( ) } ) [EOL] [EOL] [EOL] class TestBytesFormatting ( unittest . TestCase ) : [EOL] [EOL] def test__simple_cases ( self ) : [EOL] self . assertEqual ( dbt . utils . format_bytes ( - [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ** [number] * [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ** [number] * [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ** [number] * [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ** [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ** [number] * [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ** [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_bytes ( [number] ** [number] * [number] ) , [string] ) [EOL] [EOL] [EOL] class TestRowsNumberFormatting ( unittest . TestCase ) : [EOL] [EOL] def test__simple_cases ( self ) : [EOL] self . assertEqual ( dbt . utils . format_rows_number ( - [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_rows_number ( [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_rows_number ( [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_rows_number ( [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_rows_number ( [number] ** [number] * [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_rows_number ( [number] ** [number] * [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_rows_number ( [number] ** [number] * [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_rows_number ( [number] ** [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_rows_number ( [number] ** [number] * [number] ) , [string] ) [EOL] self . assertEqual ( dbt . utils . format_rows_number ( [number] ** [number] * [number] ) , [string] ) [comment] [EOL] [EOL] [EOL] class TestMultiDict ( unittest . TestCase ) : [EOL] def test_one_member ( self ) : [EOL] dct = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] md = dbt . utils . MultiDict ( [ dct ] ) [EOL] assert len ( md ) == [number] [EOL] for key in [string] : [EOL] assert key in md [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] [EOL] def test_two_members_no_overlap ( self ) : [EOL] first = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] second = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] md = dbt . utils . MultiDict ( [ first , second ] ) [EOL] assert len ( md ) == [number] [EOL] for key in [string] : [EOL] assert key in md [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] [EOL] def test_two_members_overlap ( self ) : [EOL] first = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] second = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] md = dbt . utils . MultiDict ( [ first , second ] ) [EOL] assert len ( md ) == [number] [EOL] for key in [string] : [EOL] assert key in md [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL] assert md [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.int]]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.int]]],builtins.str]]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.int]]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.int]]],builtins.str]]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int]],typing.List[typing.Dict[builtins.str,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int]],typing.List[typing.Dict[builtins.str,builtins.int]]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int]],typing.List[typing.Dict[builtins.str,builtins.int]]]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int]],typing.List[typing.Dict[builtins.str,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[typing.Union[builtins.int,builtins.str]],builtins.str]],typing.List[typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[typing.Union[builtins.int,builtins.str]],builtins.str]],typing.List[typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[typing.Union[builtins.int,builtins.str]],builtins.str]],typing.List[typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[typing.Union[builtins.int,builtins.str]],builtins.str]],typing.List[typing.Union[typing.Dict[builtins.str,builtins.float],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.int,builtins.str]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any , Type , List , Union , Dict [EOL] import unittest [EOL] import test [EOL] import builtins [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import os [EOL] import yaml [EOL] [EOL] import dbt . flags [EOL] import dbt . parser [EOL] from dbt . exceptions import CompilationException [EOL] from dbt . parser import ( ModelParser , MacroParser , DataTestParser , SchemaParser , ParseResult , SnapshotParser , AnalysisParser ) [EOL] from dbt . parser . schemas import ( TestablePatchParser , SourceParser , AnalysisPatchParser , MacroPatchParser ) [EOL] from dbt . parser . search import FileBlock [EOL] from dbt . parser . schema_test_builders import YamlBlock [EOL] from dbt . parser . manifest import process_docs , process_sources , process_refs [EOL] [EOL] from dbt . node_types import NodeType [EOL] from dbt . contracts . files import SourceFile , FileHash , FilePath [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . contracts . graph . model_config import ( NodeConfig , TestConfig , TimestampSnapshotConfig , SnapshotStrategy , ) [EOL] from dbt . contracts . graph . parsed import ( ParsedModelNode , ParsedMacro , ParsedNodePatch , DependsOn , ColumnInfo , ParsedDataTestNode , ParsedSnapshotNode , ParsedAnalysisNode , UnpatchedSourceDefinition ) [EOL] from dbt . contracts . graph . unparsed import Docs [EOL] [EOL] from . utils import config_from_parts_or_dicts , normalize , generate_name_macros , MockNode , MockSource , MockDocumentation [EOL] [EOL] [EOL] def get_abs_os_path ( unix_path ) : [EOL] return normalize ( os . path . abspath ( unix_path ) ) [EOL] [EOL] [EOL] class BaseParserTest ( unittest . TestCase ) : [EOL] maxDiff = None [EOL] [EOL] def _generate_macros ( self ) : [EOL] name_sql = { } [EOL] for component in ( [string] , [string] , [string] ) : [EOL] if component == [string] : [EOL] source = [string] [EOL] else : [EOL] source = f' [string] { component }' [EOL] name = f' [string] { component } [string] ' [EOL] sql = f' [string] { name } [string] { source } [string] ' [EOL] name_sql [ name ] = sql [EOL] [EOL] for name , sql in name_sql . items ( ) : [EOL] pm = ParsedMacro ( name = name , resource_type = NodeType . Macro , unique_id = f' [string] { name }' , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , path = normalize ( [string] ) , macro_sql = sql , ) [EOL] yield pm [EOL] [EOL] def setUp ( self ) : [EOL] dbt . flags . STRICT_MODE = True [EOL] dbt . flags . WARN_ERROR = True [EOL] [EOL] self . maxDiff = None [EOL] [EOL] profile_data = { [string] : [string] , [string] : { } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } } [EOL] [EOL] root_project = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : normalize ( [string] ) , [string] : [number] , } [EOL] [EOL] self . root_project_config = config_from_parts_or_dicts ( project = root_project , profile = profile_data , cli_vars = [string] ) [EOL] [EOL] snowplow_project = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : get_abs_os_path ( [string] ) , [string] : [number] , } [EOL] [EOL] self . snowplow_project_config = config_from_parts_or_dicts ( project = snowplow_project , profile = profile_data ) [EOL] [EOL] self . all_projects = { [string] : self . root_project_config , [string] : self . snowplow_project_config } [EOL] [EOL] self . root_project_config . dependencies = self . all_projects [EOL] self . snowplow_project_config . dependencies = self . all_projects [EOL] self . patcher = mock . patch ( [string] ) [EOL] self . factory = self . patcher . start ( ) [EOL] [EOL] self . parser_patcher = mock . patch ( [string] ) [EOL] self . factory_parser = self . parser_patcher . start ( ) [EOL] [EOL] self . macro_manifest = Manifest . from_macros ( macros = { m . unique_id : m for m in generate_name_macros ( [string] ) } ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . parser_patcher . stop ( ) [EOL] self . patcher . stop ( ) [EOL] [EOL] def file_block_for ( self , data , filename , searched ) : [EOL] root_dir = get_abs_os_path ( [string] ) [EOL] filename = normalize ( filename ) [EOL] path = FilePath ( searched_path = searched , relative_path = filename , project_root = root_dir , ) [EOL] source_file = SourceFile ( path = path , checksum = FileHash . from_contents ( data ) , ) [EOL] source_file . contents = data [EOL] return FileBlock ( file = source_file ) [EOL] [EOL] def assert_has_results_length ( self , results , files = [number] , macros = [number] , nodes = [number] , sources = [number] , docs = [number] , patches = [number] , disabled = [number] ) : [EOL] self . assertEqual ( len ( results . files ) , files ) [EOL] self . assertEqual ( len ( results . macros ) , macros ) [EOL] self . assertEqual ( len ( results . nodes ) , nodes ) [EOL] self . assertEqual ( len ( results . sources ) , sources ) [EOL] self . assertEqual ( len ( results . docs ) , docs ) [EOL] self . assertEqual ( len ( results . patches ) , patches ) [EOL] self . assertEqual ( sum ( len ( v ) for v in results . disabled . values ( ) ) , disabled ) [EOL] [EOL] [EOL] SINGLE_TABLE_SOURCE = [string] [EOL] [EOL] SINGLE_TABLE_SOURCE_TESTS = [string] [EOL] [EOL] [EOL] SINGLE_TABLE_MODEL_TESTS = [string] [EOL] [EOL] [EOL] SINGLE_TABLE_SOURCE_PATCH = [string] [EOL] [EOL] [EOL] class SchemaParserTest ( BaseParserTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . parser = SchemaParser ( results = ParseResult . rpc ( ) , project = self . snowplow_project_config , root_project = self . root_project_config , macro_manifest = self . macro_manifest , ) [EOL] [EOL] def file_block_for ( self , data , filename ) : [EOL] return super ( ) . file_block_for ( data , filename , [string] ) [EOL] [EOL] def yaml_block_for ( self , test_yml , filename ) : [EOL] file_block = self . file_block_for ( data = test_yml , filename = filename ) [EOL] return YamlBlock . from_file_block ( src = file_block , data = yaml . safe_load ( test_yml ) , ) [EOL] [EOL] [EOL] class SchemaParserSourceTest ( SchemaParserTest ) : [EOL] def test__read_basic_source ( self ) : [EOL] block = self . yaml_block_for ( SINGLE_TABLE_SOURCE , [string] ) [EOL] analysis_blocks = AnalysisPatchParser ( self . parser , block , [string] ) . parse ( ) [EOL] model_blocks = TestablePatchParser ( self . parser , block , [string] ) . parse ( ) [EOL] source_blocks = SourceParser ( self . parser , block , [string] ) . parse ( ) [EOL] macro_blocks = MacroPatchParser ( self . parser , block , [string] ) . parse ( ) [EOL] self . assertEqual ( len ( analysis_blocks ) , [number] ) [EOL] self . assertEqual ( len ( model_blocks ) , [number] ) [EOL] self . assertEqual ( len ( source_blocks ) , [number] ) [EOL] self . assertEqual ( len ( macro_blocks ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . patches ) ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . nodes ) ) , [number] ) [EOL] results = list ( self . parser . results . sources . values ( ) ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] . source . name , [string] ) [EOL] self . assertEqual ( results [ [number] ] . table . name , [string] ) [EOL] self . assertEqual ( results [ [number] ] . table . description , [string] ) [EOL] self . assertEqual ( len ( results [ [number] ] . table . columns ) , [number] ) [EOL] [EOL] def test__parse_basic_source ( self ) : [EOL] block = self . file_block_for ( SINGLE_TABLE_SOURCE , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , sources = [number] ) [EOL] src = list ( self . parser . results . sources . values ( ) ) [ [number] ] [EOL] assert isinstance ( src , UnpatchedSourceDefinition ) [EOL] assert src . package_name == [string] [EOL] assert src . source . name == [string] [EOL] assert src . table . name == [string] [EOL] assert src . resource_type == NodeType . Source [EOL] assert src . fqn == [ [string] , [string] , [string] ] [EOL] [EOL] def test__read_basic_source_tests ( self ) : [EOL] block = self . yaml_block_for ( SINGLE_TABLE_SOURCE_TESTS , [string] ) [EOL] analysis_tests = AnalysisPatchParser ( self . parser , block , [string] ) . parse ( ) [EOL] model_tests = TestablePatchParser ( self . parser , block , [string] ) . parse ( ) [EOL] source_tests = SourceParser ( self . parser , block , [string] ) . parse ( ) [EOL] macro_tests = MacroPatchParser ( self . parser , block , [string] ) . parse ( ) [EOL] self . assertEqual ( len ( analysis_tests ) , [number] ) [EOL] self . assertEqual ( len ( model_tests ) , [number] ) [EOL] self . assertEqual ( len ( source_tests ) , [number] ) [EOL] self . assertEqual ( len ( macro_tests ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . nodes ) ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . patches ) ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . source_patches ) ) , [number] ) [EOL] results = list ( self . parser . results . sources . values ( ) ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] . source . name , [string] ) [EOL] self . assertEqual ( results [ [number] ] . table . name , [string] ) [EOL] self . assertEqual ( results [ [number] ] . table . description , [string] ) [EOL] self . assertEqual ( len ( results [ [number] ] . table . columns ) , [number] ) [EOL] [EOL] def test__parse_basic_source_tests ( self ) : [EOL] block = self . file_block_for ( SINGLE_TABLE_SOURCE_TESTS , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assertEqual ( len ( self . parser . results . nodes ) , [number] ) [EOL] self . assertEqual ( len ( self . parser . results . sources ) , [number] ) [EOL] self . assertEqual ( len ( self . parser . results . patches ) , [number] ) [EOL] src = list ( self . parser . results . sources . values ( ) ) [ [number] ] [EOL] self . assertEqual ( src . source . name , [string] ) [EOL] self . assertEqual ( src . source . schema , None ) [EOL] self . assertEqual ( src . table . name , [string] ) [EOL] self . assertEqual ( src . table . description , [string] ) [EOL] [EOL] tests = [ self . parser . parse_source_test ( src , test , col ) for test , col in src . get_tests ( ) ] [EOL] tests . sort ( key = lambda n : n . unique_id ) [EOL] [EOL] self . assertEqual ( tests [ [number] ] . config . severity , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . tags , [ [string] ] ) [EOL] self . assertEqual ( tests [ [number] ] . sources , [ [ [string] , [string] ] ] ) [EOL] self . assertEqual ( tests [ [number] ] . column_name , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . fqn , [ [string] , [string] , tests [ [number] ] . name ] ) [EOL] self . assertEqual ( tests [ [number] ] . config . severity , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . tags , [ [string] ] ) [EOL] self . assertEqual ( tests [ [number] ] . sources , [ [ [string] , [string] ] ] ) [EOL] self . assertEqual ( tests [ [number] ] . column_name , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . fqn , [ [string] , [string] , tests [ [number] ] . name ] ) [EOL] [EOL] path = get_abs_os_path ( [string] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( self . parser . results . files [ path ] . nodes , [ ] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( self . parser . results . files [ path ] . sources , [ [string] ] ) [EOL] self . assertEqual ( self . parser . results . files [ path ] . source_patches , [ ] ) [EOL] [EOL] def test__read_source_patch ( self ) : [EOL] block = self . yaml_block_for ( SINGLE_TABLE_SOURCE_PATCH , [string] ) [EOL] analysis_tests = AnalysisPatchParser ( self . parser , block , [string] ) . parse ( ) [EOL] model_tests = TestablePatchParser ( self . parser , block , [string] ) . parse ( ) [EOL] source_tests = SourceParser ( self . parser , block , [string] ) . parse ( ) [EOL] macro_tests = MacroPatchParser ( self . parser , block , [string] ) . parse ( ) [EOL] self . assertEqual ( len ( analysis_tests ) , [number] ) [EOL] self . assertEqual ( len ( model_tests ) , [number] ) [EOL] self . assertEqual ( len ( source_tests ) , [number] ) [EOL] self . assertEqual ( len ( macro_tests ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . nodes ) ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . patches ) ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . sources ) ) , [number] ) [EOL] results = list ( self . parser . results . source_patches . values ( ) ) [EOL] self . assertEqual ( len ( results ) , [number] ) [EOL] self . assertEqual ( results [ [number] ] . name , [string] ) [EOL] self . assertEqual ( results [ [number] ] . overrides , [string] ) [EOL] self . assertIsNone ( results [ [number] ] . description ) [EOL] self . assertEqual ( len ( results [ [number] ] . tables ) , [number] ) [EOL] table = results [ [number] ] . tables [ [number] ] [EOL] self . assertEqual ( table . name , [string] ) [EOL] self . assertIsNone ( table . description ) [EOL] self . assertEqual ( len ( table . columns ) , [number] ) [EOL] self . assertEqual ( len ( table . columns [ [number] ] . tests ) , [number] ) [EOL] [EOL] [EOL] class SchemaParserModelsTest ( SchemaParserTest ) : [EOL] def test__read_basic_model_tests ( self ) : [EOL] block = self . yaml_block_for ( SINGLE_TABLE_MODEL_TESTS , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assertEqual ( len ( list ( self . parser . results . patches ) ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . sources ) ) , [number] ) [EOL] self . assertEqual ( len ( list ( self . parser . results . nodes ) ) , [number] ) [EOL] [EOL] def test__parse_basic_model_tests ( self ) : [EOL] block = self . file_block_for ( SINGLE_TABLE_MODEL_TESTS , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , patches = [number] , nodes = [number] ) [EOL] [EOL] patch = list ( self . parser . results . patches . values ( ) ) [ [number] ] [EOL] self . assertEqual ( len ( patch . columns ) , [number] ) [EOL] self . assertEqual ( patch . name , [string] ) [EOL] self . assertEqual ( patch . description , [string] ) [EOL] expected_patch = ParsedNodePatch ( name = [string] , description = [string] , columns = { [string] : ColumnInfo ( name = [string] , description = [string] ) } , original_file_path = normalize ( [string] ) , meta = { } , yaml_key = [string] , package_name = [string] , docs = Docs ( show = True ) , ) [EOL] self . assertEqual ( patch , expected_patch ) [EOL] [EOL] tests = sorted ( self . parser . results . nodes . values ( ) , key = lambda n : n . unique_id ) [EOL] self . assertEqual ( tests [ [number] ] . config . severity , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . tags , [ [string] ] ) [EOL] self . assertEqual ( tests [ [number] ] . refs , [ [ [string] ] ] ) [EOL] self . assertEqual ( tests [ [number] ] . column_name , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . package_name , [string] ) [EOL] self . assertTrue ( tests [ [number] ] . name . startswith ( [string] ) ) [EOL] self . assertEqual ( tests [ [number] ] . fqn , [ [string] , [string] , tests [ [number] ] . name ] ) [EOL] self . assertEqual ( tests [ [number] ] . unique_id . split ( [string] ) , [ [string] , [string] , tests [ [number] ] . name ] ) [EOL] self . assertEqual ( tests [ [number] ] . test_metadata . name , [string] ) [EOL] self . assertIsNone ( tests [ [number] ] . test_metadata . namespace ) [EOL] self . assertEqual ( tests [ [number] ] . test_metadata . kwargs , { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] ] , } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( tests [ [number] ] . config . severity , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . tags , [ [string] ] ) [EOL] self . assertEqual ( tests [ [number] ] . refs , [ [ [string] ] ] ) [EOL] self . assertEqual ( tests [ [number] ] . column_name , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . column_name , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . fqn , [ [string] , [string] , tests [ [number] ] . name ] ) [EOL] self . assertTrue ( tests [ [number] ] . name . startswith ( [string] ) ) [EOL] self . assertEqual ( tests [ [number] ] . package_name , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . unique_id . split ( [string] ) , [ [string] , [string] , tests [ [number] ] . name ] ) [EOL] self . assertEqual ( tests [ [number] ] . test_metadata . name , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . test_metadata . namespace , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . test_metadata . kwargs , { [string] : [string] , [string] : [string] , [string] : [number] , } , ) [EOL] [EOL] self . assertEqual ( tests [ [number] ] . config . severity , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . tags , [ [string] ] ) [EOL] self . assertEqual ( tests [ [number] ] . refs , [ [ [string] ] ] ) [EOL] self . assertEqual ( tests [ [number] ] . column_name , [string] ) [EOL] self . assertEqual ( tests [ [number] ] . package_name , [string] ) [EOL] self . assertTrue ( tests [ [number] ] . name . startswith ( [string] ) ) [EOL] self . assertEqual ( tests [ [number] ] . fqn , [ [string] , [string] , tests [ [number] ] . name ] ) [EOL] self . assertEqual ( tests [ [number] ] . unique_id . split ( [string] ) , [ [string] , [string] , tests [ [number] ] . name ] ) [EOL] self . assertEqual ( tests [ [number] ] . test_metadata . name , [string] ) [EOL] self . assertIsNone ( tests [ [number] ] . test_metadata . namespace ) [EOL] self . assertEqual ( tests [ [number] ] . test_metadata . kwargs , { [string] : [string] , [string] : [string] , } , ) [EOL] [EOL] path = get_abs_os_path ( [string] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( sorted ( self . parser . results . files [ path ] . nodes ) , [ t . unique_id for t in tests ] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( self . parser . results . files [ path ] . patches , [ [string] ] ) [EOL] [EOL] [EOL] class ModelParserTest ( BaseParserTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . parser = ModelParser ( results = ParseResult . rpc ( ) , project = self . snowplow_project_config , root_project = self . root_project_config , macro_manifest = self . macro_manifest , ) [EOL] [EOL] def file_block_for ( self , data , filename ) : [EOL] return super ( ) . file_block_for ( data , filename , [string] ) [EOL] [EOL] def test_basic ( self ) : [EOL] raw_sql = [string] [EOL] block = self . file_block_for ( raw_sql , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , nodes = [number] ) [EOL] node = list ( self . parser . results . nodes . values ( ) ) [ [number] ] [EOL] expected = ParsedModelNode ( alias = [string] , name = [string] , database = [string] , schema = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] , [string] ] , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , config = NodeConfig ( materialized = [string] ) , path = normalize ( [string] ) , raw_sql = raw_sql , checksum = block . file . checksum , unrendered_config = { [string] : [string] } , ) [EOL] self . assertEqual ( node , expected ) [EOL] path = get_abs_os_path ( [string] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( self . parser . results . files [ path ] . nodes , [ [string] ] ) [EOL] [EOL] def test_parse_error ( self ) : [EOL] block = self . file_block_for ( [string] , [string] ) [EOL] with self . assertRaises ( CompilationException ) : [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , files = [number] ) [EOL] [EOL] [EOL] class SnapshotParserTest ( BaseParserTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . parser = SnapshotParser ( results = ParseResult . rpc ( ) , project = self . snowplow_project_config , root_project = self . root_project_config , macro_manifest = self . macro_manifest , ) [EOL] [EOL] def file_block_for ( self , data , filename ) : [EOL] return super ( ) . file_block_for ( data , filename , [string] ) [EOL] [EOL] def test_parse_error ( self ) : [EOL] block = self . file_block_for ( [string] , [string] ) [EOL] with self . assertRaises ( CompilationException ) : [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , files = [number] ) [EOL] [EOL] def test_single_block ( self ) : [EOL] raw_sql = [string] [EOL] full_file = [string] . format ( raw_sql ) [EOL] block = self . file_block_for ( full_file , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , nodes = [number] ) [EOL] node = list ( self . parser . results . nodes . values ( ) ) [ [number] ] [EOL] expected = ParsedSnapshotNode ( alias = [string] , name = [string] , database = [string] , schema = [string] , resource_type = NodeType . Snapshot , unique_id = [string] , fqn = [ [string] , [string] , [string] , [string] ] , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , config = TimestampSnapshotConfig ( strategy = SnapshotStrategy . Timestamp , updated_at = [string] , target_database = [string] , target_schema = [string] , unique_key = [string] , materialized = [string] , ) , path = normalize ( [string] ) , raw_sql = raw_sql , checksum = block . file . checksum , unrendered_config = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ) [EOL] self . assertEqual ( node , expected ) [EOL] path = get_abs_os_path ( [string] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( self . parser . results . files [ path ] . nodes , [ [string] ] ) [EOL] [EOL] def test_multi_block ( self ) : [EOL] raw_1 = [string] [EOL] raw_2 = [string] [EOL] full_file = [string] . format ( raw_1 , raw_2 ) [EOL] block = self . file_block_for ( full_file , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , nodes = [number] ) [EOL] nodes = sorted ( self . parser . results . nodes . values ( ) , key = lambda n : n . name ) [EOL] expect_foo = ParsedSnapshotNode ( alias = [string] , name = [string] , database = [string] , schema = [string] , resource_type = NodeType . Snapshot , unique_id = [string] , fqn = [ [string] , [string] , [string] , [string] ] , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , config = TimestampSnapshotConfig ( strategy = SnapshotStrategy . Timestamp , updated_at = [string] , target_database = [string] , target_schema = [string] , unique_key = [string] , materialized = [string] , ) , path = normalize ( [string] ) , raw_sql = raw_1 , checksum = block . file . checksum , unrendered_config = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ) [EOL] expect_bar = ParsedSnapshotNode ( alias = [string] , name = [string] , database = [string] , schema = [string] , resource_type = NodeType . Snapshot , unique_id = [string] , fqn = [ [string] , [string] , [string] , [string] ] , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , config = TimestampSnapshotConfig ( strategy = SnapshotStrategy . Timestamp , updated_at = [string] , target_database = [string] , target_schema = [string] , unique_key = [string] , materialized = [string] , ) , path = normalize ( [string] ) , raw_sql = raw_2 , checksum = block . file . checksum , unrendered_config = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ) [EOL] self . assertEqual ( nodes [ [number] ] , expect_bar ) [EOL] self . assertEqual ( nodes [ [number] ] , expect_foo ) [EOL] path = get_abs_os_path ( [string] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( sorted ( self . parser . results . files [ path ] . nodes ) , [ [string] , [string] ] ) [EOL] [EOL] [EOL] class MacroParserTest ( BaseParserTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . parser = MacroParser ( results = ParseResult . rpc ( ) , project = self . snowplow_project_config , ) [EOL] [EOL] def file_block_for ( self , data , filename ) : [EOL] return super ( ) . file_block_for ( data , filename , [string] ) [EOL] [EOL] def test_single_block ( self ) : [EOL] raw_sql = [string] [EOL] block = self . file_block_for ( raw_sql , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , macros = [number] ) [EOL] macro = list ( self . parser . results . macros . values ( ) ) [ [number] ] [EOL] expected = ParsedMacro ( name = [string] , resource_type = NodeType . Macro , unique_id = [string] , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , path = normalize ( [string] ) , macro_sql = raw_sql , ) [EOL] self . assertEqual ( macro , expected ) [EOL] path = get_abs_os_path ( [string] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( self . parser . results . files [ path ] . macros , [ [string] ] ) [EOL] [EOL] def test_multiple_blocks ( self ) : [EOL] raw_sql = [string] [EOL] block = self . file_block_for ( raw_sql , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , macros = [number] ) [EOL] macros = sorted ( self . parser . results . macros . values ( ) , key = lambda m : m . name ) [EOL] expected_bar = ParsedMacro ( name = [string] , resource_type = NodeType . Macro , unique_id = [string] , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , path = normalize ( [string] ) , macro_sql = [string] , ) [EOL] expected_foo = ParsedMacro ( name = [string] , resource_type = NodeType . Macro , unique_id = [string] , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , path = normalize ( [string] ) , macro_sql = [string] , ) [EOL] self . assertEqual ( macros , [ expected_bar , expected_foo ] ) [EOL] path = get_abs_os_path ( [string] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( sorted ( self . parser . results . files [ path ] . macros ) , [ [string] , [string] ] , ) [EOL] [EOL] [EOL] class DataTestParserTest ( BaseParserTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . parser = DataTestParser ( results = ParseResult . rpc ( ) , project = self . snowplow_project_config , root_project = self . root_project_config , macro_manifest = self . macro_manifest , ) [EOL] [EOL] def file_block_for ( self , data , filename ) : [EOL] return super ( ) . file_block_for ( data , filename , [string] ) [EOL] [EOL] def test_basic ( self ) : [EOL] raw_sql = [string] [EOL] block = self . file_block_for ( raw_sql , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , nodes = [number] ) [EOL] node = list ( self . parser . results . nodes . values ( ) ) [ [number] ] [EOL] expected = ParsedDataTestNode ( alias = [string] , name = [string] , database = [string] , schema = [string] , resource_type = NodeType . Test , unique_id = [string] , fqn = [ [string] , [string] , [string] ] , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , refs = [ [ [string] ] ] , config = TestConfig ( severity = [string] ) , tags = [ [string] ] , path = normalize ( [string] ) , raw_sql = raw_sql , checksum = block . file . checksum , unrendered_config = { } , ) [EOL] self . assertEqual ( node , expected ) [EOL] path = get_abs_os_path ( [string] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( self . parser . results . files [ path ] . nodes , [ [string] ] ) [EOL] [EOL] [EOL] class AnalysisParserTest ( BaseParserTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . parser = AnalysisParser ( results = ParseResult . rpc ( ) , project = self . snowplow_project_config , root_project = self . root_project_config , macro_manifest = self . macro_manifest , ) [EOL] [EOL] def file_block_for ( self , data , filename ) : [EOL] return super ( ) . file_block_for ( data , filename , [string] ) [EOL] [EOL] def test_basic ( self ) : [EOL] raw_sql = [string] [EOL] block = self . file_block_for ( raw_sql , [string] ) [EOL] self . parser . parse_file ( block ) [EOL] self . assert_has_results_length ( self . parser . results , nodes = [number] ) [EOL] node = list ( self . parser . results . nodes . values ( ) ) [ [number] ] [EOL] expected = ParsedAnalysisNode ( alias = [string] , name = [string] , database = [string] , schema = [string] , resource_type = NodeType . Analysis , unique_id = [string] , fqn = [ [string] , [string] , [string] , [string] ] , package_name = [string] , original_file_path = normalize ( [string] ) , root_path = get_abs_os_path ( [string] ) , depends_on = DependsOn ( ) , config = NodeConfig ( ) , path = normalize ( [string] ) , raw_sql = raw_sql , checksum = block . file . checksum , unrendered_config = { } , ) [EOL] self . assertEqual ( node , expected ) [EOL] path = get_abs_os_path ( [string] ) [EOL] self . assertIn ( path , self . parser . results . files ) [EOL] self . assertEqual ( self . parser . results . files [ path ] . nodes , [ [string] ] ) [EOL] [EOL] [EOL] class ProcessingTest ( BaseParserTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] x_depends_on = mock . MagicMock ( ) [EOL] y_depends_on = mock . MagicMock ( ) [EOL] self . x_node = MockNode ( package = [string] , name = [string] , config = mock . MagicMock ( enabled = True ) , refs = [ ] , sources = [ [ [string] , [string] ] ] , depends_on = x_depends_on , description = [string] , ) [EOL] self . y_node = MockNode ( package = [string] , name = [string] , config = mock . MagicMock ( enabled = True ) , refs = [ [ [string] ] ] , sources = [ ] , depends_on = y_depends_on , description = [string] , ) [EOL] self . src_node = MockSource ( package = [string] , source_name = [string] , name = [string] , config = mock . MagicMock ( enabled = True ) , ) [EOL] self . doc = MockDocumentation ( package = [string] , name = [string] , block_contents = [string] , ) [EOL] nodes = { self . x_node . unique_id : self . x_node , self . y_node . unique_id : self . y_node , } [EOL] sources = { self . src_node . unique_id : self . src_node , } [EOL] docs = { self . doc . unique_id : self . doc , } [EOL] self . manifest = Manifest ( nodes = nodes , sources = sources , macros = { } , docs = docs , disabled = [ ] , files = { } , reports = { } , generated_at = mock . MagicMock ( ) ) [EOL] [EOL] def test_process_docs ( self ) : [EOL] process_docs ( self . manifest , self . root_project_config ) [EOL] self . assertEqual ( self . x_node . description , [string] ) [EOL] self . assertEqual ( self . y_node . description , [string] ) [EOL] [EOL] def test_process_sources ( self ) : [EOL] process_sources ( self . manifest , [string] ) [EOL] self . x_node . depends_on . nodes . append . assert_called_once_with ( [string] ) [EOL] [EOL] def test_process_refs ( self ) : [EOL] process_refs ( self . manifest , [string] ) [EOL] self . y_node . depends_on . nodes . append . assert_called_once_with ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 $typing.dict$ 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 $typing.dict$ 0 $typing.dict$ 0 $typing.dict$ 0 0 0 0 0 0 $typing.dict$ 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Optional , Dict [EOL] import decimal [EOL] import unittest [EOL] import typing [EOL] from datetime import datetime [EOL] from decimal import Decimal [EOL] from unittest import mock [EOL] import unittest [EOL] [EOL] import dbt . flags [EOL] from dbt . task import generate [EOL] [EOL] [EOL] class GenerateTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] dbt . flags . STRICT_MODE = True [EOL] self . maxDiff = None [EOL] self . manifest = mock . MagicMock ( ) [EOL] self . patcher = mock . patch ( [string] ) [EOL] self . mock_get_unique_id_mapping = self . patcher . start ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . patcher . stop ( ) [EOL] [EOL] def map_uids ( self , effects ) : [EOL] results = { generate . CatalogKey ( db , sch , tbl ) : uid for db , sch , tbl , uid in effects } [EOL] self . mock_get_unique_id_mapping . return_value = results , { } [EOL] [EOL] def generate_catalog_dict ( self , columns ) : [EOL] nodes , sources = generate . Catalog ( columns ) . make_unique_id_map ( self . manifest ) [EOL] result = generate . CatalogResults ( nodes = nodes , sources = sources , generated_at = datetime . utcnow ( ) , errors = None , ) [EOL] return result . to_dict ( omit_none = False ) [ [string] ] [EOL] [EOL] def test__unflatten_empty ( self ) : [EOL] columns = { } [EOL] expected = { } [EOL] self . map_uids ( [ ] ) [EOL] [EOL] result = self . generate_catalog_dict ( columns ) [EOL] [EOL] self . mock_get_unique_id_mapping . assert_called_once_with ( self . manifest ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test__unflatten_one_column ( self ) : [EOL] columns = [ { [string] : None , [string] : Decimal ( [string] ) , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] [EOL] expected = { [string] : { [string] : { [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , [string] : None , [string] : [number] , [string] : [string] } , } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : False , } , } , [string] : [string] , } , } [EOL] self . map_uids ( [ ( [string] , [string] , [string] , [string] ) ] ) [EOL] [EOL] result = self . generate_catalog_dict ( columns ) [EOL] [EOL] self . mock_get_unique_id_mapping . assert_called_once_with ( self . manifest ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test__unflatten_multiple_schemas_dbs ( self ) : [EOL] columns = [ { [string] : None , [string] : Decimal ( [string] ) , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } , { [string] : None , [string] : Decimal ( [string] ) , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } , { [string] : None , [string] : Decimal ( [string] ) , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } , { [string] : None , [string] : Decimal ( [string] ) , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } , { [string] : None , [string] : Decimal ( [string] ) , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } , { [string] : None , [string] : Decimal ( [string] ) , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } , { [string] : None , [string] : Decimal ( [string] ) , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } , { [string] : None , [string] : Decimal ( [string] ) , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } , ] [EOL] expected = { [string] : { [string] : { [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , [string] : None , [string] : [number] , [string] : [string] } , [string] : { [string] : [string] , [string] : None , [string] : [number] , [string] : [string] , } } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : False , } , } , [string] : [string] , } , [string] : { [string] : { [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , [string] : None , [string] : [number] , [string] : [string] } , [string] : { [string] : [string] , [string] : None , [string] : [number] , [string] : [string] , } } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : False , } , } , [string] : [string] , } , [string] : { [string] : { [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , [string] : None , [string] : [number] , [string] : [string] } , [string] : { [string] : [string] , [string] : None , [string] : [number] , [string] : [string] , } } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : False , } , } , [string] : [string] , } , [string] : { [string] : { [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : { [string] : [string] , [string] : None , [string] : [number] , [string] : [string] } , [string] : { [string] : [string] , [string] : None , [string] : [number] , [string] : [string] , } } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : False , } , } , [string] : [string] , } } [EOL] self . map_uids ( [ ( [string] , [string] , [string] , [string] ) , ( [string] , [string] , [string] , [string] ) , ( [string] , [string] , [string] , [string] ) , ( [string] , [string] , [string] , [string] ) , ] ) [EOL] [EOL] result = self . generate_catalog_dict ( columns ) [EOL] [EOL] self . mock_get_unique_id_mapping . assert_called_once_with ( self . manifest ) [EOL] self . assertEqual ( result , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[None,decimal.Decimal,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]],typing.Dict[builtins.str,typing.Optional[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[None,decimal.Decimal,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]],typing.Dict[builtins.str,typing.Optional[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[None,decimal.Decimal,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]],typing.Dict[builtins.str,typing.Optional[builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[None,decimal.Decimal,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]],typing.Dict[builtins.str,typing.Optional[builtins.str]],builtins.str]]]$ 0 0
from typing import Any , List , Union , Dict , Type , Tuple [EOL] import test [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import copy [EOL] from collections import namedtuple [EOL] from itertools import product [EOL] from datetime import datetime [EOL] [EOL] import pytest [EOL] [EOL] import dbt . flags [EOL] from dbt import tracking [EOL] from dbt . contracts . files import FileHash [EOL] from dbt . contracts . graph . manifest import Manifest , ManifestMetadata [EOL] from dbt . contracts . graph . parsed import ( ParsedModelNode , DependsOn , NodeConfig , ParsedSeedNode , ParsedSourceDefinition , ) [EOL] from dbt . contracts . graph . compiled import CompiledModelNode [EOL] from dbt . node_types import NodeType [EOL] import freezegun [EOL] [EOL] from . utils import MockMacro , MockDocumentation , MockSource , MockNode , MockMaterialization , MockGenerateMacro [EOL] [EOL] [EOL] REQUIRED_PARSED_NODE_KEYS = frozenset ( { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } ) [EOL] [EOL] REQUIRED_COMPILED_NODE_KEYS = frozenset ( REQUIRED_PARSED_NODE_KEYS | { [string] , [string] , [string] , [string] , [string] , } ) [EOL] [EOL] [EOL] class ManifestTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] dbt . flags . STRICT_MODE = True [EOL] [EOL] self . maxDiff = None [EOL] [EOL] self . model_config = NodeConfig . from_dict ( { [string] : True , [string] : [string] , [string] : { } , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : [ ] , } ) [EOL] [EOL] self . nested_nodes = { [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ [ [string] ] ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ [ [string] ] ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ [ [string] ] ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ [ [string] ] ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] , [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , } [EOL] [EOL] self . sources = { [string] : ParsedSourceDefinition ( database = [string] , schema = [string] , resource_type = NodeType . Source , identifier = [string] , name = [string] , source_name = [string] , source_description = [string] , description = [string] , loader = [string] , unique_id = [string] , fqn = [ [string] , [string] , [string] ] , package_name = [string] , root_path = [string] , path = [string] , original_file_path = [string] , ) , } [EOL] for node in self . nested_nodes . values ( ) : [EOL] node . validate ( node . to_dict ( ) ) [EOL] for source in self . sources . values ( ) : [EOL] source . validate ( source . to_dict ( ) ) [EOL] [EOL] @ freezegun . freeze_time ( [string] ) def test__no_nodes ( self ) : [EOL] manifest = Manifest ( nodes = { } , sources = { } , macros = { } , docs = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } ) [EOL] self . assertEqual ( manifest . writable_manifest ( ) . to_dict ( ) , { [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : [string] , [string] : { } , [string] : { } , [string] : [ ] , } ) [EOL] [EOL] @ freezegun . freeze_time ( [string] ) def test__nested_nodes ( self ) : [EOL] nodes = copy . copy ( self . nested_nodes ) [EOL] manifest = Manifest ( nodes = nodes , sources = { } , macros = { } , docs = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } ) [EOL] serialized = manifest . writable_manifest ( ) . to_dict ( ) [EOL] self . assertEqual ( serialized [ [string] ] , [string] ) [EOL] self . assertEqual ( serialized [ [string] ] , { } ) [EOL] self . assertEqual ( serialized [ [string] ] , [ ] ) [EOL] parent_map = serialized [ [string] ] [EOL] child_map = serialized [ [string] ] [EOL] [comment] [EOL] self . assertEqual ( set ( parent_map ) , set ( nodes ) ) [EOL] self . assertEqual ( set ( child_map ) , set ( nodes ) ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ [string] ] ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ [string] ] ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( set ( parent_map [ [string] ] ) , set ( [ [string] , [string] ] ) ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ ] , ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ ] , ) [EOL] [EOL] self . assertEqual ( child_map [ [string] ] , [ [string] ] , ) [EOL] self . assertEqual ( child_map [ [string] ] , [ [string] ] , ) [EOL] self . assertEqual ( child_map [ [string] ] , [ [string] ] ) [EOL] self . assertEqual ( child_map [ [string] ] , [ ] ) [EOL] self . assertEqual ( set ( child_map [ [string] ] ) , set ( [ [string] , [string] ] ) ) [EOL] self . assertEqual ( child_map [ [string] ] , [ ] ) [EOL] [EOL] def test__build_flat_graph ( self ) : [EOL] nodes = copy . copy ( self . nested_nodes ) [EOL] sources = copy . copy ( self . sources ) [EOL] manifest = Manifest ( nodes = nodes , sources = sources , macros = { } , docs = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } ) [EOL] manifest . build_flat_graph ( ) [EOL] flat_graph = manifest . flat_graph [EOL] flat_nodes = flat_graph [ [string] ] [EOL] flat_sources = flat_graph [ [string] ] [EOL] self . assertEqual ( set ( flat_graph ) , set ( [ [string] , [string] ] ) ) [EOL] self . assertEqual ( set ( flat_nodes ) , set ( self . nested_nodes ) ) [EOL] self . assertEqual ( set ( flat_sources ) , set ( self . sources ) ) [EOL] for node in flat_nodes . values ( ) : [EOL] self . assertEqual ( frozenset ( node ) , REQUIRED_PARSED_NODE_KEYS ) [EOL] [EOL] @ mock . patch . object ( tracking , [string] ) def test_metadata ( self , mock_user ) : [EOL] mock_user . id = [string] [EOL] mock_user . do_not_track = True [EOL] self . assertEqual ( ManifestMetadata ( project_id = [string] , adapter_type = [string] , ) , ManifestMetadata ( project_id = [string] , user_id = [string] , send_anonymous_usage_stats = False , adapter_type = [string] , ) ) [EOL] [EOL] @ mock . patch . object ( tracking , [string] ) @ freezegun . freeze_time ( [string] ) def test_no_nodes_with_metadata ( self , mock_user ) : [EOL] mock_user . id = [string] [EOL] mock_user . do_not_track = True [EOL] metadata = ManifestMetadata ( project_id = [string] , adapter_type = [string] , ) [EOL] manifest = Manifest ( nodes = { } , sources = { } , macros = { } , docs = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , metadata = metadata , files = { } , reports = { } ) [EOL] [EOL] self . assertEqual ( manifest . writable_manifest ( ) . to_dict ( ) , { [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : [string] , [string] : { } , [string] : { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , } , [string] : [ ] , } ) [EOL] [EOL] def test_get_resource_fqns_empty ( self ) : [EOL] manifest = Manifest ( nodes = { } , sources = { } , macros = { } , docs = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } ) [EOL] self . assertEqual ( manifest . get_resource_fqns ( ) , { } ) [EOL] [EOL] def test_get_resource_fqns ( self ) : [EOL] nodes = copy . copy ( self . nested_nodes ) [EOL] nodes [ [string] ] = ParsedSeedNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Seed , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ [ [string] ] ] , sources = [ ] , depends_on = DependsOn ( ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , raw_sql = [string] , checksum = FileHash . empty ( ) , ) [EOL] manifest = Manifest ( nodes = nodes , sources = self . sources , macros = { } , docs = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } ) [EOL] expect = { [string] : frozenset ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) , [string] : frozenset ( [ ( [string] , [string] ) ] ) , [string] : frozenset ( [ ( [string] , [string] , [string] ) ] ) } [EOL] resource_fqns = manifest . get_resource_fqns ( ) [EOL] self . assertEqual ( resource_fqns , expect ) [EOL] [EOL] [EOL] class MixedManifestTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] dbt . flags . STRICT_MODE = True [EOL] [EOL] self . maxDiff = None [EOL] [EOL] self . model_config = NodeConfig . from_dict ( { [string] : True , [string] : [string] , [string] : { } , [string] : [ ] , [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : [ ] , } ) [EOL] [EOL] self . nested_nodes = { [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , raw_sql = [string] , meta = { } , compiled = True , compiled_sql = [string] , extra_ctes_injected = True , injected_sql = None , extra_ctes = [ ] , checksum = FileHash . empty ( ) , ) , [string] : CompiledModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ ] , sources = [ ] , depends_on = DependsOn ( ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , raw_sql = [string] , meta = { } , compiled = True , compiled_sql = [string] , extra_ctes_injected = True , injected_sql = [string] , extra_ctes = [ ] , checksum = FileHash . empty ( ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ [ [string] ] ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ [ [string] ] ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ [ [string] ] ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , [string] : ParsedModelNode ( name = [string] , database = [string] , schema = [string] , alias = [string] , resource_type = NodeType . Model , unique_id = [string] , fqn = [ [string] , [string] ] , package_name = [string] , refs = [ [ [string] ] ] , sources = [ ] , depends_on = DependsOn ( nodes = [ [string] , [string] ] ) , config = self . model_config , tags = [ ] , path = [string] , original_file_path = [string] , root_path = [string] , meta = { } , raw_sql = [string] , checksum = FileHash . empty ( ) , ) , } [EOL] [EOL] @ freezegun . freeze_time ( [string] ) def test__no_nodes ( self ) : [EOL] manifest = Manifest ( nodes = { } , sources = { } , macros = { } , docs = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } ) [EOL] self . assertEqual ( manifest . writable_manifest ( ) . to_dict ( ) , { [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : [string] , [string] : { } , [string] : { } , [string] : [ ] , } ) [EOL] [EOL] @ freezegun . freeze_time ( [string] ) def test__nested_nodes ( self ) : [EOL] nodes = copy . copy ( self . nested_nodes ) [EOL] manifest = Manifest ( nodes = nodes , sources = { } , macros = { } , docs = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } ) [EOL] serialized = manifest . writable_manifest ( ) . to_dict ( ) [EOL] self . assertEqual ( serialized [ [string] ] , [string] ) [EOL] self . assertEqual ( serialized [ [string] ] , [ ] ) [EOL] parent_map = serialized [ [string] ] [EOL] child_map = serialized [ [string] ] [EOL] [comment] [EOL] self . assertEqual ( set ( parent_map ) , set ( nodes ) ) [EOL] self . assertEqual ( set ( child_map ) , set ( nodes ) ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ [string] ] ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ [string] ] ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( set ( parent_map [ [string] ] ) , set ( [ [string] , [string] ] ) ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ ] , ) [EOL] self . assertEqual ( parent_map [ [string] ] , [ ] , ) [EOL] [EOL] self . assertEqual ( child_map [ [string] ] , [ [string] ] , ) [EOL] self . assertEqual ( child_map [ [string] ] , [ [string] ] , ) [EOL] self . assertEqual ( child_map [ [string] ] , [ [string] ] ) [EOL] self . assertEqual ( child_map [ [string] ] , [ ] ) [EOL] self . assertEqual ( set ( child_map [ [string] ] ) , set ( [ [string] , [string] ] ) ) [EOL] self . assertEqual ( child_map [ [string] ] , [ ] ) [EOL] [EOL] def test__build_flat_graph ( self ) : [EOL] nodes = copy . copy ( self . nested_nodes ) [EOL] manifest = Manifest ( nodes = nodes , sources = { } , macros = { } , docs = { } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } ) [EOL] manifest . build_flat_graph ( ) [EOL] flat_graph = manifest . flat_graph [EOL] flat_nodes = flat_graph [ [string] ] [EOL] self . assertEqual ( set ( flat_graph ) , set ( [ [string] , [string] ] ) ) [EOL] self . assertEqual ( set ( flat_nodes ) , set ( self . nested_nodes ) ) [EOL] compiled_count = [number] [EOL] for node in flat_nodes . values ( ) : [EOL] if node . get ( [string] ) : [EOL] self . assertEqual ( frozenset ( node ) , REQUIRED_COMPILED_NODE_KEYS ) [EOL] compiled_count += [number] [EOL] else : [EOL] self . assertEqual ( frozenset ( node ) , REQUIRED_PARSED_NODE_KEYS ) [EOL] self . assertEqual ( compiled_count , [number] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class TestManifestSearch ( unittest . TestCase ) : [EOL] _macros = [ ] [EOL] _models = [ ] [EOL] _docs = [ ] [EOL] @ property def macros ( self ) : [EOL] return self . _macros [EOL] [EOL] @ property def nodes ( self ) : [EOL] return self . _nodes [EOL] [EOL] @ property def docs ( self ) : [EOL] return self . _docs [EOL] [EOL] def setUp ( self ) : [EOL] self . manifest = Manifest ( nodes = { n . unique_id : n for n in self . nodes } , macros = { m . unique_id : m for m in self . macros } , docs = { d . unique_id : d for d in self . docs } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } , ) [EOL] [EOL] [EOL] def make_manifest ( nodes = [ ] , sources = [ ] , macros = [ ] , docs = [ ] ) : [EOL] return Manifest ( nodes = { n . unique_id : n for n in nodes } , macros = { m . unique_id : m for m in macros } , sources = { s . unique_id : s for s in sources } , docs = { d . unique_id : d for d in docs } , generated_at = datetime . utcnow ( ) , disabled = [ ] , files = { } , reports = { } , ) [EOL] [EOL] [EOL] FindMacroSpec = namedtuple ( [string] , [string] ) [EOL] [EOL] macro_parameter_sets = [ FindMacroSpec ( macros = [ ] , expected = { None : None , [string] : None , [string] : None , [string] : None } , ) , FindMacroSpec ( macros = [ MockMacro ( [string] ) ] , expected = { None : [string] , [string] : [string] , [string] : None , [string] : None } , ) , FindMacroSpec ( macros = [ MockMacro ( [string] ) ] , expected = { None : [string] , [string] : None , [string] : [string] , [string] : None } , ) , FindMacroSpec ( macros = [ MockMacro ( [string] ) ] , expected = { None : [string] , [string] : None , [string] : None , [string] : [string] } , ) , FindMacroSpec ( macros = [ MockMacro ( [string] ) , MockMacro ( [string] ) ] , expected = { None : [string] , [string] : [string] , [string] : [string] , [string] : None } , ) , FindMacroSpec ( macros = [ MockMacro ( [string] ) , MockMacro ( [string] ) ] , expected = { None : [string] , [string] : [string] , [string] : None , [string] : [string] } , ) , FindMacroSpec ( macros = [ MockMacro ( [string] ) , MockMacro ( [string] ) ] , expected = { None : [string] , [string] : None , [string] : [string] , [string] : [string] } , ) , FindMacroSpec ( macros = [ MockMacro ( [string] ) , MockMacro ( [string] ) , MockMacro ( [string] ) ] , expected = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , ) , ] [EOL] [EOL] [EOL] def id_macro ( arg ) : [EOL] if isinstance ( arg , list ) : [EOL] macro_names = [string] . join ( f'{ m . package_name }' for m in arg ) [EOL] return f' [string] { macro_names } [string] ' [EOL] if isinstance ( arg , dict ) : [EOL] arg_names = [string] . join ( f'{ k } [string] { v }' for k , v in arg . items ( ) ) [EOL] return f' [string] { arg_names } [string] ' [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , macro_parameter_sets , ids = id_macro ) def test_find_macro_by_name ( macros , expectations ) : [EOL] manifest = make_manifest ( macros = macros ) [EOL] for package , expected in expectations . items ( ) : [EOL] result = manifest . find_macro_by_name ( name = [string] , root_project_name = [string] , package = package ) [EOL] if expected is None : [EOL] assert result is expected [EOL] else : [EOL] assert result . package_name == expected [EOL] [EOL] [EOL] [comment] [EOL] generate_name_parameter_sets = [ FindMacroSpec ( macros = [ ] , expected = None , ) , FindMacroSpec ( macros = [ MockGenerateMacro ( [string] ) ] , expected = [string] , ) , FindMacroSpec ( macros = [ MockGenerateMacro ( [string] ) ] , expected = None , ) , FindMacroSpec ( macros = [ MockGenerateMacro ( [string] ) ] , expected = [string] , ) , FindMacroSpec ( macros = [ MockGenerateMacro ( [string] ) , MockGenerateMacro ( [string] ) ] , expected = [string] , ) , FindMacroSpec ( macros = [ MockGenerateMacro ( [string] ) , MockGenerateMacro ( [string] ) ] , expected = [string] , ) , FindMacroSpec ( macros = [ MockGenerateMacro ( [string] ) , MockGenerateMacro ( [string] ) ] , expected = [string] , ) , FindMacroSpec ( macros = [ MockGenerateMacro ( [string] ) , MockGenerateMacro ( [string] ) , MockGenerateMacro ( [string] ) ] , expected = [string] , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , generate_name_parameter_sets , ids = id_macro ) def test_find_generate_macro_by_name ( macros , expected ) : [EOL] manifest = make_manifest ( macros = macros ) [EOL] result = manifest . find_generate_macro_by_name ( component = [string] , root_project_name = [string] ) [EOL] if expected is None : [EOL] assert result is expected [EOL] else : [EOL] assert result . package_name == expected [EOL] [EOL] [EOL] FindMaterializationSpec = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] def _materialization_parameter_sets ( ) : [EOL] sets = [ FindMaterializationSpec ( macros = [ ] , adapter_type = [string] , expected = None ) , ] [EOL] [EOL] [comment] [EOL] sets . extend ( FindMaterializationSpec ( macros = [ MockMaterialization ( project , adapter_type = None ) ] , adapter_type = [string] , expected = ( project , [string] ) , ) for project in [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] sets . extend ( FindMaterializationSpec ( macros = [ MockMaterialization ( project , adapter_type = [string] ) ] , adapter_type = [string] , expected = None , ) for project in [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] sets . extend ( FindMaterializationSpec ( macros = [ MockMaterialization ( project , adapter_type = [string] ) ] , adapter_type = [string] , expected = ( project , [string] ) , ) for project in [ [string] , [string] , [string] ] ) [EOL] [EOL] sets . extend ( [ FindMaterializationSpec ( macros = [ MockMaterialization ( project , adapter_type = atype ) for ( project , atype ) in product ( [ [string] , [string] , [string] ] , [ [string] , None ] ) ] , adapter_type = [string] , expected = ( [string] , [string] ) ) , FindMaterializationSpec ( macros = [ MockMaterialization ( [string] , adapter_type = [string] ) , MockMaterialization ( [string] , adapter_type = [string] ) , MockMaterialization ( [string] , adapter_type = None ) ] , adapter_type = [string] , expected = ( [string] , [string] ) , ) , FindMaterializationSpec ( macros = [ MockMaterialization ( [string] , adapter_type = [string] ) , MockMaterialization ( [string] , adapter_type = [string] ) , MockMaterialization ( [string] , adapter_type = None ) ] , adapter_type = [string] , expected = ( [string] , [string] ) , ) , FindMaterializationSpec ( macros = [ MockMaterialization ( [string] , adapter_type = [string] ) , MockMaterialization ( [string] , adapter_type = [string] ) , MockMaterialization ( [string] , adapter_type = None ) ] , adapter_type = [string] , expected = ( [string] , [string] ) , ) , FindMaterializationSpec ( macros = [ MockMaterialization ( [string] , adapter_type = None ) , MockMaterialization ( [string] , adapter_type = [string] ) , MockMaterialization ( [string] , adapter_type = None ) , MockMaterialization ( [string] , adapter_type = [string] ) , ] , adapter_type = [string] , expected = ( [string] , [string] ) , ) , ] ) [EOL] [EOL] return sets [EOL] [EOL] [EOL] def id_mat ( arg ) : [EOL] if isinstance ( arg , list ) : [EOL] macro_names = [string] . join ( f'{ m . package_name } [string] { m . adapter_type }' for m in arg ) [EOL] return f' [string] { macro_names } [string] ' [EOL] elif isinstance ( arg , tuple ) : [EOL] return [string] . join ( arg ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _materialization_parameter_sets ( ) , ids = id_mat , ) def test_find_materialization_by_name ( macros , adapter_type , expected ) : [EOL] manifest = make_manifest ( macros = macros ) [EOL] result = manifest . find_materialization_macro_by_name ( project_name = [string] , materialization_name = [string] , adapter_type = adapter_type , ) [EOL] if expected is None : [EOL] assert result is expected [EOL] else : [EOL] expected_package , expected_adapter_type = expected [EOL] assert result . adapter_type == expected_adapter_type [EOL] assert result . package_name == expected_package [EOL] [EOL] [EOL] FindNodeSpec = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] def _refable_parameter_sets ( ) : [EOL] sets = [ FindNodeSpec ( nodes = [ ] , sources = [ ] , package = None , expected = None ) , FindNodeSpec ( nodes = [ ] , sources = [ ] , package = [string] , expected = None ) , ] [EOL] sets . extend ( FindNodeSpec ( nodes = [ MockNode ( project , [string] ) ] , sources = [ ] , package = None , expected = ( project , [string] ) , ) for project in [ [string] , [string] ] ) [EOL] [comment] [EOL] sets . extend ( [ FindNodeSpec ( nodes = [ MockNode ( [string] , [string] ) ] , sources = [ ] , package = [string] , expected = ( [string] , [string] ) , ) , FindNodeSpec ( nodes = [ MockNode ( [string] , [string] ) ] , sources = [ ] , package = [string] , expected = None , ) , FindNodeSpec ( nodes = [ ] , sources = [ MockSource ( [string] , [string] , [string] ) ] , package = None , expected = None ) , FindNodeSpec ( nodes = [ MockNode ( [string] , [string] ) ] , sources = [ MockSource ( [string] , [string] , [string] ) ] , package = None , expected = ( [string] , [string] ) , ) , FindNodeSpec ( nodes = [ MockNode ( [string] , [string] ) ] , sources = [ MockSource ( [string] , [string] , [string] ) ] , package = [string] , expected = ( [string] , [string] ) , ) , FindNodeSpec ( nodes = [ MockNode ( [string] , [string] ) ] , sources = [ MockSource ( [string] , [string] , [string] ) ] , package = [string] , expected = None , ) , ] ) [EOL] return sets [EOL] [EOL] [EOL] def id_nodes ( arg ) : [EOL] if isinstance ( arg , list ) : [EOL] node_names = [string] . join ( f'{ n . package_name } [string] { n . search_name }' for n in arg ) [EOL] return f' [string] { node_names } [string] ' [EOL] elif isinstance ( arg , tuple ) : [EOL] return [string] . join ( arg ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _refable_parameter_sets ( ) , ids = id_nodes , ) def test_resolve_ref ( nodes , sources , package , expected ) : [EOL] manifest = make_manifest ( nodes = nodes , sources = sources ) [EOL] result = manifest . resolve_ref ( target_model_name = [string] , target_model_package = package , current_project = [string] , node_package = [string] , ) [EOL] if expected is None : [EOL] assert result is expected [EOL] else : [EOL] assert result is not None [EOL] assert len ( expected ) == [number] [EOL] expected_package , expected_name = expected [EOL] assert result . name == expected_name [EOL] assert result . package_name == expected_package [EOL] [EOL] [EOL] def _source_parameter_sets ( ) : [EOL] sets = [ FindNodeSpec ( nodes = [ ] , sources = [ ] , package = [string] , expected = None ) , FindNodeSpec ( nodes = [ ] , sources = [ ] , package = [string] , expected = None ) , ] [EOL] sets . extend ( FindNodeSpec ( nodes = [ MockNode ( [string] , name ) ] , sources = [ ] , package = project , expected = None , ) for project in ( [string] , [string] ) for name in ( [string] , [string] ) ) [EOL] [comment] [EOL] sets . extend ( FindNodeSpec ( nodes = [ MockNode ( [string] , [string] ) , MockNode ( [string] , [string] ) ] , sources = [ MockSource ( [string] , [string] , [string] ) ] , package = project , expected = ( [string] , [string] , [string] ) , ) for project in ( [string] , [string] ) ) [EOL] sets . extend ( FindNodeSpec ( nodes = [ ] , sources = [ MockSource ( [string] , [string] , [string] ) ] , package = project , expected = None , ) for project in ( [string] , [string] ) ) [EOL] sets . extend ( FindNodeSpec ( nodes = [ ] , sources = [ MockSource ( [string] , [string] , [string] ) ] , package = project , expected = None , ) for project in ( [string] , [string] ) ) [EOL] sets . append ( FindNodeSpec ( nodes = [ ] , sources = [ MockSource ( [string] , [string] , [string] ) ] , package = [string] , expected = ( [string] , [string] , [string] ) , ) ) [EOL] sets . extend ( FindNodeSpec ( nodes = [ ] , sources = [ MockSource ( [string] , [string] , [string] ) ] , package = project , expected = ( [string] , [string] , [string] ) , ) for project in ( [string] , [string] ) ) [EOL] [EOL] return sets [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _source_parameter_sets ( ) , ids = id_nodes , ) def test_resolve_source ( nodes , sources , package , expected ) : [EOL] manifest = make_manifest ( nodes = nodes , sources = sources ) [EOL] result = manifest . resolve_source ( target_source_name = [string] , target_table_name = [string] , current_project = package , node_package = [string] , ) [EOL] if expected is None : [EOL] assert result is expected [EOL] else : [EOL] assert result is not None [EOL] assert len ( expected ) == [number] [EOL] expected_package , expected_source_name , expected_name = expected [EOL] assert result . source_name == expected_source_name [EOL] assert result . name == expected_name [EOL] assert result . package_name == expected_package [EOL] [EOL] [EOL] FindDocSpec = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] def _docs_parameter_sets ( ) : [EOL] sets = [ ] [EOL] sets . extend ( FindDocSpec ( docs = [ ] , package = project , expected = None ) for project in ( [string] , None ) ) [EOL] sets . extend ( FindDocSpec ( docs = [ MockDocumentation ( [string] , [string] ) ] , package = project , expected = ( [string] , [string] ) ) for project in ( [string] , None ) ) [EOL] sets . extend ( [ FindDocSpec ( docs = [ MockDocumentation ( [string] , [string] ) ] , package = [string] , expected = None ) , FindDocSpec ( docs = [ MockDocumentation ( [string] , [string] ) ] , package = None , expected = ( [string] , [string] ) ) , ] ) [EOL] return sets [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , _docs_parameter_sets ( ) , ids = id_nodes , ) def test_resolve_doc ( docs , package , expected ) : [EOL] manifest = make_manifest ( docs = docs ) [EOL] result = manifest . resolve_doc ( name = [string] , package = package , current_project = [string] , node_package = [string] ) [EOL] if expected is None : [EOL] assert result is expected [EOL] else : [EOL] assert result is not None [EOL] assert len ( expected ) == [number] [EOL] expected_package , expected_name = expected [EOL] assert result . name == expected_name [EOL] assert result . package_name == expected_package [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] import itertools [EOL] [EOL] from dbt . exceptions import VersionsNotCompatibleException [EOL] from dbt . semver import VersionSpecifier , UnboundedVersionSpecifier , VersionRange , reduce_versions , versions_compatible , resolve_to_specific_version [EOL] [EOL] [EOL] def create_range ( start_version_string , end_version_string ) : [EOL] start = UnboundedVersionSpecifier ( ) [EOL] end = UnboundedVersionSpecifier ( ) [EOL] [EOL] if start_version_string is not None : [EOL] start = VersionSpecifier . from_version_string ( start_version_string ) [EOL] [EOL] if end_version_string is not None : [EOL] end = VersionSpecifier . from_version_string ( end_version_string ) [EOL] [EOL] return VersionRange ( start = start , end = end ) [EOL] [EOL] [EOL] class TestSemver ( unittest . TestCase ) : [EOL] [EOL] def assertVersionSetResult ( self , inputs , output_range ) : [EOL] expected = create_range ( * output_range ) [EOL] [EOL] for permutation in itertools . permutations ( inputs ) : [EOL] self . assertEqual ( reduce_versions ( * permutation ) , expected ) [EOL] [EOL] def assertInvalidVersionSet ( self , inputs ) : [EOL] for permutation in itertools . permutations ( inputs ) : [EOL] with self . assertRaises ( VersionsNotCompatibleException ) : [EOL] reduce_versions ( * permutation ) [EOL] [EOL] def test__versions_compatible ( self ) : [EOL] self . assertTrue ( versions_compatible ( [string] , [string] ) ) [EOL] self . assertFalse ( versions_compatible ( [string] , [string] ) ) [EOL] self . assertTrue ( versions_compatible ( [string] , [string] ) ) [EOL] [EOL] def test__reduce_versions ( self ) : [EOL] self . assertVersionSetResult ( [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] ] , [ [string] , None ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] ] , [ None , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] , [string] , [string] ] , [ [string] , None ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] , [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] , [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] , [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] , [string] , [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertVersionSetResult ( [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] self . assertInvalidVersionSet ( [ [string] , [string] ] ) [EOL] self . assertInvalidVersionSet ( [ [string] , [string] ] ) [EOL] self . assertInvalidVersionSet ( [ [string] , [string] ] ) [EOL] self . assertInvalidVersionSet ( [ [string] , [string] ] ) [EOL] self . assertInvalidVersionSet ( [ [string] , [string] ] ) [EOL] self . assertInvalidVersionSet ( [ [string] , [string] ] ) [EOL] self . assertInvalidVersionSet ( [ [string] , [string] ] ) [EOL] [EOL] def test__resolve_to_specific_version ( self ) : [EOL] self . assertEqual ( resolve_to_specific_version ( create_range ( [string] , None ) , [ [string] , [string] ] ) , [string] ) [EOL] [EOL] self . assertEqual ( resolve_to_specific_version ( create_range ( [string] , None ) , [ [string] , [string] ] ) , [string] ) [EOL] [EOL] self . assertEqual ( resolve_to_specific_version ( create_range ( [string] , None ) , [ [string] , [string] ] ) , None ) [EOL] [EOL] self . assertEqual ( resolve_to_specific_version ( create_range ( [string] , [string] ) , [ [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] self . assertEqual ( resolve_to_specific_version ( create_range ( None , [string] ) , [ [string] , [string] , [string] ] ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import builtins [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import patch , MagicMock [EOL] [EOL] import dbt . main [EOL] import dbt . version [EOL] [EOL] [EOL] class VersionTest ( unittest . TestCase ) : [EOL] [EOL] @ patch ( [string] , [string] ) @ patch ( [string] , autospec = True ) @ patch ( [string] ) def test_versions_equal ( self , mock_get , mock_get_dbt_plugins_info ) : [EOL] mock_get . return_value . json . return_value = { [string] : { [string] : [string] } } [EOL] mock_get_dbt_plugins_info . return_value = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] latest_version = dbt . version . get_latest_version ( ) [EOL] installed_version = dbt . version . get_installed_version ( ) [EOL] version_information = dbt . version . get_version_information ( ) [EOL] [EOL] expected_version_information = [string] [string] [string] [string] [string] [string] [string] [string] [EOL] [EOL] self . assertEqual ( latest_version , installed_version ) [EOL] self . assertEqual ( latest_version , installed_version ) [EOL] self . assertMultiLineEqual ( version_information , expected_version_information ) [EOL] [EOL] @ patch ( [string] , [string] ) @ patch ( [string] , autospec = True ) @ patch ( [string] ) def test_installed_version_greater ( self , mock_get , mock_get_dbt_plugins_info ) : [EOL] mock_get . return_value . json . return_value = { [string] : { [string] : [string] } } [EOL] mock_get_dbt_plugins_info . return_value = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] latest_version = dbt . version . get_latest_version ( ) [EOL] installed_version = dbt . version . get_installed_version ( ) [EOL] version_information = dbt . version . get_version_information ( ) [EOL] [EOL] expected_version_information = [string] [string] [string] [string] [string] [string] [string] [string] [EOL] [EOL] assert installed_version > latest_version [EOL] self . assertMultiLineEqual ( version_information , expected_version_information ) [EOL] [EOL] @ patch ( [string] , [string] ) @ patch ( [string] , autospec = True ) @ patch ( [string] ) def test_installed_version_lower ( self , mock_get , mock_get_dbt_plugins_info ) : [EOL] mock_get . return_value . json . return_value = { [string] : { [string] : [string] } } [EOL] mock_get_dbt_plugins_info . return_value = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] latest_version = dbt . version . get_latest_version ( ) [EOL] installed_version = dbt . version . get_installed_version ( ) [EOL] version_information = dbt . version . get_version_information ( ) [EOL] [EOL] expected_version_information = [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [EOL] [EOL] assert installed_version < latest_version [EOL] self . assertMultiLineEqual ( version_information , expected_version_information ) [EOL] [EOL] [comment] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_dbt_version_flag ( self , mock_get , stderr ) : [EOL] mock_get . return_value . json . return_value = { [string] : { [string] : [string] } } [EOL] [EOL] with self . assertRaises ( SystemExit ) as exc : [EOL] dbt . main . handle_and_check ( [ [string] ] ) [EOL] self . assertEqual ( exc . exception . code , [number] ) [EOL] [EOL] @ patch ( [string] , autospec = True ) @ patch ( [string] , autospec = True ) def test_get_adapter_plugin_names ( self , mock_find_spec , mock_glob ) : [EOL] mock_submodule = unittest . mock . MagicMock ( ) [EOL] mock_find_spec . return_value = mock_submodule [EOL] mock_submodule . submodule_search_locations = [ [string] ] [EOL] [EOL] def glob_side_effect ( path ) : [EOL] return [ path . replace ( [string] , [string] ) , path . replace ( [string] , [string] ) , ] [EOL] mock_glob . side_effect = glob_side_effect [EOL] self . assertEqual ( list ( dbt . version . _get_adapter_plugin_names ( ) ) , [ [string] , [string] ] , ) [EOL] [EOL] mock_find_spec . assert_called_once_with ( [string] ) [EOL] [EOL] @ patch ( [string] , autospec = True ) @ patch ( [string] , autospec = True ) def test_get_adapter_plugin_names ( self , mock_find_spec , mock_glob ) : [EOL] mock_submodule = unittest . mock . MagicMock ( ) [EOL] mock_find_spec . return_value = mock_submodule [EOL] mock_submodule . submodule_search_locations = [ [string] , [string] ] [EOL] [EOL] def glob_side_effect ( path ) : [EOL] assert [string] in path or [string] in path [EOL] if [string] in path : [EOL] return [ path . replace ( [string] , [string] ) ] [EOL] elif [string] in path : [EOL] return [ path . replace ( [string] , [string] ) ] [EOL] mock_glob . side_effect = glob_side_effect [EOL] self . assertEqual ( list ( dbt . version . _get_adapter_plugin_names ( ) ) , [ [string] , [string] ] , ) [EOL] [EOL] mock_find_spec . assert_called_once_with ( [string] ) [EOL] [EOL] @ patch ( [string] , autospec = True ) @ patch ( [string] , autospec = True ) def test_get_dbt_plugins_info_with_version_info ( self , mock_mod , mock_get_plugin_names ) : [EOL] mock_get_plugin_names . return_value = [ [string] , [string] ] [EOL] mod_version = unittest . mock . Mock ( ) [EOL] mock_mod . return_value = mod_version [EOL] mod_version . version = [string] [EOL] self . assertEqual ( list ( dbt . version . _get_dbt_plugins_info ( ) ) , [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] mock_get_plugin_names . assert_called_once_with ( ) [EOL] mock_mod . assert_has_calls ( [ unittest . mock . call ( [string] ) , unittest . mock . call ( [string] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , List , Union , Dict , Tuple [EOL] import unittest [EOL] import test [EOL] import typing [EOL] from copy import deepcopy [EOL] from contextlib import contextmanager [EOL] import json [EOL] import os [EOL] import shutil [EOL] import tempfile [EOL] import unittest [EOL] [EOL] from unittest import mock [EOL] import yaml [EOL] [EOL] import dbt . config [EOL] import dbt . exceptions [EOL] from dbt . adapters . factory import load_plugin [EOL] from dbt . adapters . postgres import PostgresCredentials [EOL] from dbt . adapters . redshift import RedshiftCredentials [EOL] from dbt . context . base import generate_base_context [EOL] from dbt . contracts . connection import QueryComment , DEFAULT_QUERY_COMMENT [EOL] from dbt . contracts . project import PackageConfig , LocalPackage , GitPackage [EOL] from dbt . node_types import NodeType [EOL] from dbt . semver import VersionSpecifier [EOL] from dbt . task . run_operation import RunOperationTask [EOL] [EOL] from . utils import normalize , config_from_parts_or_dicts [EOL] [EOL] INITIAL_ROOT = os . getcwd ( ) [EOL] [EOL] [EOL] @ contextmanager def temp_cd ( path ) : [EOL] current_path = os . getcwd ( ) [EOL] os . chdir ( path ) [EOL] try : [EOL] yield [EOL] finally : [EOL] os . chdir ( current_path ) [EOL] [EOL] @ contextmanager def raises_nothing ( ) : [EOL] yield [EOL] [EOL] [EOL] def empty_profile_renderer ( ) : [EOL] return dbt . config . renderer . ProfileRenderer ( generate_base_context ( { } ) ) [EOL] [EOL] [EOL] def empty_project_renderer ( ) : [EOL] return dbt . config . renderer . DbtProjectYamlRenderer ( generate_base_context ( { } ) ) [EOL] [EOL] [EOL] model_config = { [string] : { [string] : True , [string] : { [string] : { [string] : [string] , [string] : True , [string] : [string] } } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : { [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [string] } } } } } [EOL] [EOL] model_fqns = frozenset ( ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) ) [EOL] [EOL] [EOL] class Args : [EOL] def __init__ ( self , profiles_dir = None , threads = None , profile = None , cli_vars = None , version_check = None , project_dir = None ) : [EOL] self . profile = profile [EOL] if threads is not None : [EOL] self . threads = threads [EOL] if profiles_dir is not None : [EOL] self . profiles_dir = profiles_dir [EOL] if cli_vars is not None : [EOL] self . vars = cli_vars [EOL] if version_check is not None : [EOL] self . version_check = version_check [EOL] if project_dir is not None : [EOL] self . project_dir = project_dir [EOL] [EOL] [EOL] class BaseConfigTest ( unittest . TestCase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] self . default_project_data = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] self . default_profile_data = { [string] : { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } } , [string] : [string] , } , [string] : { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } , [string] : [string] , } , [string] : { } } [EOL] self . args = Args ( profiles_dir = self . profiles_dir , cli_vars = [string] , version_check = True , project_dir = self . project_dir ) [EOL] self . env_override = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] def assertRaisesOrReturns ( self , exc ) : [EOL] if exc is None : [EOL] return raises_nothing ( ) [EOL] else : [EOL] return self . assertRaises ( exc ) [EOL] [EOL] [EOL] class BaseFileTest ( BaseConfigTest ) : [EOL] def setUp ( self ) : [EOL] self . project_dir = normalize ( tempfile . mkdtemp ( ) ) [EOL] self . profiles_dir = normalize ( tempfile . mkdtemp ( ) ) [EOL] super ( ) . setUp ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] try : [EOL] shutil . rmtree ( self . project_dir ) [EOL] except EnvironmentError : [EOL] pass [EOL] try : [EOL] shutil . rmtree ( self . profiles_dir ) [EOL] except EnvironmentError : [EOL] pass [EOL] [EOL] def project_path ( self , name ) : [EOL] return os . path . join ( self . project_dir , name ) [EOL] [EOL] def profile_path ( self , name ) : [EOL] return os . path . join ( self . profiles_dir , name ) [EOL] [EOL] def write_project ( self , project_data = None ) : [EOL] if project_data is None : [EOL] project_data = self . project_data [EOL] with open ( self . project_path ( [string] ) , [string] ) as fp : [EOL] yaml . dump ( project_data , fp ) [EOL] [EOL] def write_packages ( self , package_data ) : [EOL] with open ( self . project_path ( [string] ) , [string] ) as fp : [EOL] yaml . dump ( package_data , fp ) [EOL] [EOL] def write_profile ( self , profile_data = None ) : [EOL] if profile_data is None : [EOL] profile_data = self . profile_data [EOL] with open ( self . profile_path ( [string] ) , [string] ) as fp : [EOL] yaml . dump ( profile_data , fp ) [EOL] [EOL] def write_empty_profile ( self ) : [EOL] with open ( self . profile_path ( [string] ) , [string] ) as fp : [EOL] yaml . dump ( [string] , fp ) [EOL] [EOL] [EOL] class TestProfile ( BaseConfigTest ) : [EOL] def setUp ( self ) : [EOL] self . profiles_dir = [string] [EOL] self . project_dir = [string] [EOL] super ( ) . setUp ( ) [EOL] [EOL] def from_raw_profiles ( self ) : [EOL] renderer = empty_profile_renderer ( ) [EOL] return dbt . config . Profile . from_raw_profiles ( self . default_profile_data , [string] , renderer ) [EOL] [EOL] def test_from_raw_profiles ( self ) : [EOL] profile = self . from_raw_profiles ( ) [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertEqual ( profile . threads , [number] ) [EOL] self . assertTrue ( profile . config . send_anonymous_usage_stats ) [EOL] self . assertIsNone ( profile . config . use_colors ) [EOL] self . assertTrue ( isinstance ( profile . credentials , PostgresCredentials ) ) [EOL] self . assertEqual ( profile . credentials . type , [string] ) [EOL] self . assertEqual ( profile . credentials . host , [string] ) [EOL] self . assertEqual ( profile . credentials . port , [number] ) [EOL] self . assertEqual ( profile . credentials . user , [string] ) [EOL] self . assertEqual ( profile . credentials . password , [string] ) [EOL] self . assertEqual ( profile . credentials . schema , [string] ) [EOL] self . assertEqual ( profile . credentials . database , [string] ) [EOL] [EOL] def test_config_override ( self ) : [EOL] self . default_profile_data [ [string] ] = { [string] : False , [string] : False , } [EOL] profile = self . from_raw_profiles ( ) [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertFalse ( profile . config . send_anonymous_usage_stats ) [EOL] self . assertFalse ( profile . config . use_colors ) [EOL] [EOL] def test_partial_config_override ( self ) : [EOL] self . default_profile_data [ [string] ] = { [string] : False , [string] : [number] } [EOL] profile = self . from_raw_profiles ( ) [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertFalse ( profile . config . send_anonymous_usage_stats ) [EOL] self . assertIsNone ( profile . config . use_colors ) [EOL] self . assertEqual ( profile . config . printer_width , [number] ) [EOL] [EOL] def test_missing_type ( self ) : [EOL] del self . default_profile_data [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] with self . assertRaises ( dbt . exceptions . DbtProfileError ) as exc : [EOL] self . from_raw_profiles ( ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_bad_type ( self ) : [EOL] self . default_profile_data [ [string] ] [ [string] ] [ [string] ] [ [string] ] = [string] [EOL] with self . assertRaises ( dbt . exceptions . DbtProfileError ) as exc : [EOL] self . from_raw_profiles ( ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_invalid_credentials ( self ) : [EOL] del self . default_profile_data [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] with self . assertRaises ( dbt . exceptions . DbtProfileError ) as exc : [EOL] self . from_raw_profiles ( ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_missing_target ( self ) : [EOL] profile = self . default_profile_data [ [string] ] [EOL] del profile [ [string] ] [EOL] profile [ [string] ] [ [string] ] = profile [ [string] ] [ [string] ] [EOL] profile = self . from_raw_profiles ( ) [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertEqual ( profile . credentials . type , [string] ) [EOL] [EOL] def test_profile_invalid_project ( self ) : [EOL] renderer = empty_profile_renderer ( ) [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) as exc : [EOL] dbt . config . Profile . from_raw_profiles ( self . default_profile_data , [string] , renderer ) [EOL] [EOL] self . assertEqual ( exc . exception . result_type , [string] ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_profile_invalid_target ( self ) : [EOL] renderer = empty_profile_renderer ( ) [EOL] with self . assertRaises ( dbt . exceptions . DbtProfileError ) as exc : [EOL] dbt . config . Profile . from_raw_profiles ( self . default_profile_data , [string] , renderer , target_override = [string] ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_no_outputs ( self ) : [EOL] renderer = empty_profile_renderer ( ) [EOL] [EOL] with self . assertRaises ( dbt . exceptions . DbtProfileError ) as exc : [EOL] dbt . config . Profile . from_raw_profiles ( { [string] : { [string] : [string] } } , [string] , renderer ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_neq ( self ) : [EOL] profile = self . from_raw_profiles ( ) [EOL] self . assertNotEqual ( profile , object ( ) ) [EOL] [EOL] def test_eq ( self ) : [EOL] renderer = empty_profile_renderer ( ) [EOL] profile = dbt . config . Profile . from_raw_profiles ( deepcopy ( self . default_profile_data ) , [string] , renderer ) [EOL] [EOL] other = dbt . config . Profile . from_raw_profiles ( deepcopy ( self . default_profile_data ) , [string] , renderer ) [EOL] self . assertEqual ( profile , other ) [EOL] [EOL] def test_invalid_env_vars ( self ) : [EOL] self . env_override [ [string] ] = [string] [EOL] renderer = empty_profile_renderer ( ) [EOL] with mock . patch . dict ( os . environ , self . env_override ) : [EOL] with self . assertRaises ( dbt . exceptions . DbtProfileError ) as exc : [EOL] dbt . config . Profile . from_raw_profile_info ( self . default_profile_data [ [string] ] , [string] , renderer , target_override = [string] ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] [EOL] class TestProfileFile ( BaseFileTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . write_profile ( self . default_profile_data ) [EOL] [EOL] def from_raw_profile_info ( self , raw_profile = None , profile_name = [string] , ** kwargs ) : [EOL] if raw_profile is None : [EOL] raw_profile = self . default_profile_data [ [string] ] [EOL] renderer = empty_profile_renderer ( ) [EOL] kw = { [string] : raw_profile , [string] : profile_name , [string] : renderer , } [EOL] kw . update ( kwargs ) [EOL] return dbt . config . Profile . from_raw_profile_info ( ** kw ) [EOL] [EOL] def from_args ( self , project_profile_name = [string] , ** kwargs ) : [EOL] kw = { [string] : self . args , [string] : project_profile_name , [string] : empty_profile_renderer ( ) } [EOL] kw . update ( kwargs ) [EOL] return dbt . config . Profile . render_from_args ( ** kw ) [EOL] [EOL] def test_profile_simple ( self ) : [EOL] profile = self . from_args ( ) [EOL] from_raw = self . from_raw_profile_info ( ) [EOL] [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertEqual ( profile . threads , [number] ) [EOL] self . assertTrue ( profile . config . send_anonymous_usage_stats ) [EOL] self . assertIsNone ( profile . config . use_colors ) [EOL] self . assertTrue ( isinstance ( profile . credentials , PostgresCredentials ) ) [EOL] self . assertEqual ( profile . credentials . type , [string] ) [EOL] self . assertEqual ( profile . credentials . host , [string] ) [EOL] self . assertEqual ( profile . credentials . port , [number] ) [EOL] self . assertEqual ( profile . credentials . user , [string] ) [EOL] self . assertEqual ( profile . credentials . password , [string] ) [EOL] self . assertEqual ( profile . credentials . schema , [string] ) [EOL] self . assertEqual ( profile . credentials . database , [string] ) [EOL] self . assertEqual ( profile , from_raw ) [EOL] [EOL] def test_profile_override ( self ) : [EOL] self . args . profile = [string] [EOL] self . args . threads = [number] [EOL] profile = self . from_args ( ) [EOL] from_raw = self . from_raw_profile_info ( self . default_profile_data [ [string] ] , [string] , threads_override = [number] , ) [EOL] [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertEqual ( profile . threads , [number] ) [EOL] self . assertTrue ( profile . config . send_anonymous_usage_stats ) [EOL] self . assertIsNone ( profile . config . use_colors ) [EOL] self . assertTrue ( isinstance ( profile . credentials , PostgresCredentials ) ) [EOL] self . assertEqual ( profile . credentials . type , [string] ) [EOL] self . assertEqual ( profile . credentials . host , [string] ) [EOL] self . assertEqual ( profile . credentials . port , [number] ) [EOL] self . assertEqual ( profile . credentials . user , [string] ) [EOL] self . assertEqual ( profile . credentials . password , [string] ) [EOL] self . assertEqual ( profile . credentials . schema , [string] ) [EOL] self . assertEqual ( profile . credentials . database , [string] ) [EOL] self . assertEqual ( profile , from_raw ) [EOL] [EOL] def test_target_override ( self ) : [EOL] self . args . target = [string] [EOL] profile = self . from_args ( ) [EOL] from_raw = self . from_raw_profile_info ( target_override = [string] ) [EOL] [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertEqual ( profile . threads , [number] ) [EOL] self . assertTrue ( profile . config . send_anonymous_usage_stats ) [EOL] self . assertIsNone ( profile . config . use_colors ) [EOL] self . assertTrue ( isinstance ( profile . credentials , RedshiftCredentials ) ) [EOL] self . assertEqual ( profile . credentials . type , [string] ) [EOL] self . assertEqual ( profile . credentials . host , [string] ) [EOL] self . assertEqual ( profile . credentials . port , [number] ) [EOL] self . assertEqual ( profile . credentials . user , [string] ) [EOL] self . assertEqual ( profile . credentials . password , [string] ) [EOL] self . assertEqual ( profile . credentials . schema , [string] ) [EOL] self . assertEqual ( profile . credentials . database , [string] ) [EOL] self . assertEqual ( profile , from_raw ) [EOL] [EOL] def test_env_vars ( self ) : [EOL] self . args . target = [string] [EOL] with mock . patch . dict ( os . environ , self . env_override ) : [EOL] profile = self . from_args ( ) [EOL] from_raw = self . from_raw_profile_info ( target_override = [string] ) [EOL] [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertEqual ( profile . threads , [number] ) [EOL] self . assertTrue ( profile . config . send_anonymous_usage_stats ) [EOL] self . assertIsNone ( profile . config . use_colors ) [EOL] self . assertEqual ( profile . credentials . type , [string] ) [EOL] self . assertEqual ( profile . credentials . host , [string] ) [EOL] self . assertEqual ( profile . credentials . port , [number] ) [EOL] self . assertEqual ( profile . credentials . user , [string] ) [EOL] self . assertEqual ( profile . credentials . password , [string] ) [EOL] self . assertEqual ( profile , from_raw ) [EOL] [EOL] def test_env_vars_env_target ( self ) : [EOL] self . default_profile_data [ [string] ] [ [string] ] = [string] [EOL] self . write_profile ( self . default_profile_data ) [EOL] self . env_override [ [string] ] = [string] [EOL] with mock . patch . dict ( os . environ , self . env_override ) : [EOL] profile = self . from_args ( ) [EOL] from_raw = self . from_raw_profile_info ( target_override = [string] ) [EOL] [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertEqual ( profile . threads , [number] ) [EOL] self . assertTrue ( profile . config . send_anonymous_usage_stats ) [EOL] self . assertIsNone ( profile . config . use_colors ) [EOL] self . assertEqual ( profile . credentials . type , [string] ) [EOL] self . assertEqual ( profile . credentials . host , [string] ) [EOL] self . assertEqual ( profile . credentials . port , [number] ) [EOL] self . assertEqual ( profile . credentials . user , [string] ) [EOL] self . assertEqual ( profile . credentials . password , [string] ) [EOL] self . assertEqual ( profile , from_raw ) [EOL] [EOL] def test_invalid_env_vars ( self ) : [EOL] self . env_override [ [string] ] = [string] [EOL] self . args . target = [string] [EOL] with mock . patch . dict ( os . environ , self . env_override ) : [EOL] with self . assertRaises ( dbt . exceptions . DbtProfileError ) as exc : [EOL] self . from_args ( ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_cli_and_env_vars ( self ) : [EOL] self . args . target = [string] [EOL] self . args . vars = [string] [EOL] renderer = dbt . config . renderer . ProfileRenderer ( generate_base_context ( { [string] : [string] } ) ) [EOL] with mock . patch . dict ( os . environ , self . env_override ) : [EOL] profile = self . from_args ( renderer = renderer ) [EOL] from_raw = self . from_raw_profile_info ( target_override = [string] , renderer = renderer , ) [EOL] [EOL] self . assertEqual ( profile . profile_name , [string] ) [EOL] self . assertEqual ( profile . target_name , [string] ) [EOL] self . assertEqual ( profile . threads , [number] ) [EOL] self . assertTrue ( profile . config . send_anonymous_usage_stats ) [EOL] self . assertIsNone ( profile . config . use_colors ) [EOL] self . assertEqual ( profile . credentials . type , [string] ) [EOL] self . assertEqual ( profile . credentials . host , [string] ) [EOL] self . assertEqual ( profile . credentials . port , [number] ) [EOL] self . assertEqual ( profile . credentials . user , [string] ) [EOL] self . assertEqual ( profile . credentials . password , [string] ) [EOL] self . assertEqual ( profile , from_raw ) [EOL] [EOL] def test_no_profile ( self ) : [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) as exc : [EOL] self . from_args ( project_profile_name = None ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_empty_profile ( self ) : [EOL] self . write_empty_profile ( ) [EOL] with self . assertRaises ( dbt . exceptions . DbtProfileError ) as exc : [EOL] self . from_args ( ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_profile_with_empty_profile_data ( self ) : [EOL] renderer = empty_profile_renderer ( ) [EOL] with self . assertRaises ( dbt . exceptions . DbtProfileError ) as exc : [EOL] dbt . config . Profile . from_raw_profiles ( self . default_profile_data , [string] , renderer ) [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] [EOL] def project_from_config_norender ( cfg , packages = None , path = [string] , verify_version = False ) : [EOL] if packages is None : [EOL] packages = { } [EOL] partial = dbt . config . project . PartialProject . from_dicts ( path , project_dict = cfg , packages_dict = packages , selectors_dict = { } , verify_version = verify_version , ) [EOL] [comment] [EOL] rendered = dbt . config . project . RenderComponents ( project_dict = partial . project_dict , packages_dict = partial . packages_dict , selectors_dict = partial . selectors_dict , ) [EOL] return partial . create_project ( rendered ) [EOL] [EOL] [EOL] def project_from_config_rendered ( cfg , packages = None , path = [string] , verify_version = False ) : [EOL] if packages is None : [EOL] packages = { } [EOL] partial = dbt . config . project . PartialProject . from_dicts ( path , project_dict = cfg , packages_dict = packages , selectors_dict = { } , verify_version = verify_version , ) [EOL] return partial . render ( empty_project_renderer ( ) ) [EOL] [EOL] [EOL] class TestProject ( BaseConfigTest ) : [EOL] def setUp ( self ) : [EOL] self . profiles_dir = [string] [EOL] self . project_dir = [string] [EOL] super ( ) . setUp ( ) [EOL] self . default_project_data [ [string] ] = self . project_dir [EOL] [EOL] def test_defaults ( self ) : [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project . project_name , [string] ) [EOL] self . assertEqual ( project . version , [string] ) [EOL] self . assertEqual ( project . profile_name , [string] ) [EOL] self . assertEqual ( project . project_root , [string] ) [EOL] self . assertEqual ( project . source_paths , [ [string] ] ) [EOL] self . assertEqual ( project . macro_paths , [ [string] ] ) [EOL] self . assertEqual ( project . data_paths , [ [string] ] ) [EOL] self . assertEqual ( project . test_paths , [ [string] ] ) [EOL] self . assertEqual ( project . analysis_paths , [ ] ) [EOL] self . assertEqual ( project . docs_paths , [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( project . asset_paths , [ ] ) [EOL] self . assertEqual ( project . target_path , [string] ) [EOL] self . assertEqual ( project . clean_targets , [ [string] ] ) [EOL] self . assertEqual ( project . log_path , [string] ) [EOL] self . assertEqual ( project . modules_path , [string] ) [EOL] self . assertEqual ( project . quoting , { } ) [EOL] self . assertEqual ( project . models , { } ) [EOL] self . assertEqual ( project . on_run_start , [ ] ) [EOL] self . assertEqual ( project . on_run_end , [ ] ) [EOL] self . assertEqual ( project . seeds , { } ) [EOL] self . assertEqual ( project . dbt_version , [ VersionSpecifier . from_version_string ( [string] ) ] ) [EOL] self . assertEqual ( project . packages , PackageConfig ( packages = [ ] ) ) [EOL] [comment] [EOL] [comment] [EOL] str ( project ) [EOL] [EOL] def test_eq ( self ) : [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] other = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project , other ) [EOL] [EOL] def test_neq ( self ) : [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] self . assertNotEqual ( project , object ( ) ) [EOL] [EOL] def test_implicit_overrides ( self ) : [EOL] self . default_project_data . update ( { [string] : [ [string] ] , [string] : [string] , } ) [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project . docs_paths , [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( project . clean_targets , [ [string] ] ) [EOL] [EOL] def test_hashed_name ( self ) : [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project . hashed_name ( ) , [string] ) [EOL] [EOL] def test_all_overrides ( self ) : [EOL] self . default_project_data . update ( { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [string] , [string] : [ [string] ] , [string] : [string] , [string] : [string] , [string] : { [string] : False } , [string] : { [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : { [string] : False , [string] : { [string] : True , } } , [string] : { [string] : [string] , } , } , [string] : { [string] : { [string] : [string] , } , } , } , [string] : [ [string] , ] , [string] : [ [string] , ] , [string] : { [string] : { [string] : True , [string] : [string] , [string] : [string] , } , } , [string] : [string] , } ) [EOL] packages = { [string] : [ { [string] : [string] , } , { [string] : [string] , [string] : [string] } , ] , } [EOL] project = project_from_config_norender ( self . default_project_data , packages = packages ) [EOL] self . assertEqual ( project . project_name , [string] ) [EOL] self . assertEqual ( project . version , [string] ) [EOL] self . assertEqual ( project . profile_name , [string] ) [EOL] self . assertEqual ( project . project_root , [string] ) [EOL] self . assertEqual ( project . source_paths , [ [string] ] ) [EOL] self . assertEqual ( project . macro_paths , [ [string] ] ) [EOL] self . assertEqual ( project . data_paths , [ [string] ] ) [EOL] self . assertEqual ( project . test_paths , [ [string] ] ) [EOL] self . assertEqual ( project . analysis_paths , [ [string] ] ) [EOL] self . assertEqual ( project . docs_paths , [ [string] ] ) [EOL] self . assertEqual ( project . asset_paths , [ [string] ] ) [EOL] self . assertEqual ( project . target_path , [string] ) [EOL] self . assertEqual ( project . clean_targets , [ [string] ] ) [EOL] self . assertEqual ( project . log_path , [string] ) [EOL] self . assertEqual ( project . modules_path , [string] ) [EOL] self . assertEqual ( project . quoting , { [string] : False } ) [EOL] self . assertEqual ( project . models , { [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : { [string] : False , [string] : { [string] : True , } } , [string] : { [string] : [string] , } , } , [string] : { [string] : { [string] : [string] , } , } , } ) [EOL] self . assertEqual ( project . on_run_start , [ [string] ] ) [EOL] self . assertEqual ( project . on_run_end , [ [string] ] ) [EOL] self . assertEqual ( project . seeds , { [string] : { [string] : True , [string] : [string] , [string] : [string] , } , } ) [EOL] self . assertEqual ( project . dbt_version , [ VersionSpecifier . from_version_string ( [string] ) ] ) [EOL] self . assertEqual ( project . packages , PackageConfig ( packages = [ LocalPackage ( local = [string] ) , GitPackage ( git = [string] , revision = [string] ) ] ) ) [EOL] str ( project ) [EOL] json . dumps ( project . to_project_config ( ) ) [EOL] [EOL] def test_string_run_hooks ( self ) : [EOL] self . default_project_data . update ( { [string] : [string] , [string] : [string] , } ) [EOL] project = project_from_config_rendered ( self . default_project_data ) [EOL] self . assertEqual ( project . on_run_start , [ [string] ] ) [EOL] self . assertEqual ( project . on_run_end , [ [string] ] ) [EOL] [EOL] def test_invalid_project_name ( self ) : [EOL] self . default_project_data [ [string] ] = [string] [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) as exc : [EOL] project_from_config_norender ( self . default_project_data ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_no_project ( self ) : [EOL] renderer = empty_project_renderer ( ) [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) as exc : [EOL] dbt . config . Project . from_project_root ( self . project_dir , renderer ) [EOL] [EOL] self . assertIn ( [string] , str ( exc . exception ) ) [EOL] [EOL] def test_invalid_version ( self ) : [EOL] self . default_project_data [ [string] ] = [string] [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) : [EOL] project_from_config_norender ( self . default_project_data ) [EOL] [EOL] def test_unsupported_version ( self ) : [EOL] self . default_project_data [ [string] ] = [string] [EOL] [comment] [EOL] project_from_config_norender ( self . default_project_data ) [EOL] [EOL] def test_none_values ( self ) : [EOL] self . default_project_data . update ( { [string] : None , [string] : None , [string] : None , [string] : None , } ) [EOL] project = project_from_config_rendered ( self . default_project_data ) [EOL] self . assertEqual ( project . models , { } ) [EOL] self . assertEqual ( project . on_run_start , [ ] ) [EOL] self . assertEqual ( project . on_run_end , [ ] ) [EOL] self . assertEqual ( project . seeds , { } ) [EOL] [EOL] def test_nested_none_values ( self ) : [EOL] self . default_project_data . update ( { [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None , [string] : None , [string] : None } , } ) [EOL] project = project_from_config_rendered ( self . default_project_data ) [EOL] self . assertEqual ( project . models , { [string] : { } , [string] : [ ] , [string] : [ ] } ) [EOL] self . assertEqual ( project . seeds , { [string] : { } , [string] : [ ] , [string] : [ ] , [string] : { } } ) [EOL] [EOL] def test_cycle ( self ) : [EOL] models = { } [EOL] models [ [string] ] = models [EOL] self . default_project_data . update ( { [string] : models , } ) [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) as exc : [EOL] project_from_config_rendered ( self . default_project_data ) [EOL] [EOL] assert [string] in str ( exc . exception ) [EOL] [EOL] def test_query_comment_disabled ( self ) : [EOL] self . default_project_data . update ( { [string] : None , } ) [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project . query_comment . comment , [string] ) [EOL] self . assertEqual ( project . query_comment . append , False ) [EOL] [EOL] self . default_project_data . update ( { [string] : [string] , } ) [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project . query_comment . comment , [string] ) [EOL] self . assertEqual ( project . query_comment . append , False ) [EOL] [EOL] def test_default_query_comment ( self ) : [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project . query_comment , QueryComment ( ) ) [EOL] [EOL] def test_default_query_comment_append ( self ) : [EOL] self . default_project_data . update ( { [string] : { [string] : True } , } ) [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project . query_comment . comment , DEFAULT_QUERY_COMMENT ) [EOL] self . assertEqual ( project . query_comment . append , True ) [EOL] [EOL] def test_custom_query_comment_append ( self ) : [EOL] self . default_project_data . update ( { [string] : { [string] : [string] , [string] : True } , } ) [EOL] project = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project . query_comment . comment , [string] ) [EOL] self . assertEqual ( project . query_comment . append , True ) [EOL] [EOL] [EOL] class TestProjectFile ( BaseFileTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . write_project ( self . default_project_data ) [EOL] [comment] [EOL] self . default_project_data [ [string] ] = self . project_dir [EOL] [EOL] def test_from_project_root ( self ) : [EOL] renderer = empty_project_renderer ( ) [EOL] project = dbt . config . Project . from_project_root ( self . project_dir , renderer ) [EOL] from_config = project_from_config_norender ( self . default_project_data ) [EOL] self . assertEqual ( project , from_config ) [EOL] self . assertEqual ( project . version , [string] ) [EOL] self . assertEqual ( project . project_name , [string] ) [EOL] [EOL] def test_with_invalid_package ( self ) : [EOL] renderer = empty_project_renderer ( ) [EOL] self . write_packages ( { [string] : [ [string] ] } ) [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) : [EOL] dbt . config . Project . from_project_root ( self . project_dir , renderer ) [EOL] [EOL] [EOL] class TestRunOperationTask ( BaseFileTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . write_project ( self . default_project_data ) [EOL] self . write_profile ( self . default_profile_data ) [EOL] [EOL] def tearDown ( self ) : [EOL] super ( ) . tearDown ( ) [EOL] [comment] [EOL] [comment] [EOL] os . chdir ( INITIAL_ROOT ) [EOL] [EOL] def test_run_operation_task ( self ) : [EOL] self . assertEqual ( os . getcwd ( ) , INITIAL_ROOT ) [EOL] self . assertNotEqual ( INITIAL_ROOT , self . project_dir ) [EOL] new_task = RunOperationTask . from_args ( self . args ) [EOL] self . assertEqual ( os . path . realpath ( os . getcwd ( ) ) , os . path . realpath ( self . project_dir ) ) [EOL] [EOL] def test_run_operation_task_with_bad_path ( self ) : [EOL] self . args . project_dir = [string] [EOL] with self . assertRaises ( dbt . exceptions . RuntimeException ) : [EOL] new_task = RunOperationTask . from_args ( self . args ) [EOL] [EOL] [EOL] class TestVariableProjectFile ( BaseFileTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . default_project_data [ [string] ] = [string] [EOL] self . default_project_data [ [string] ] = [string] [EOL] self . default_project_data [ [string] ] = [string] [EOL] self . write_project ( self . default_project_data ) [EOL] [comment] [EOL] self . default_project_data [ [string] ] = self . project_dir [EOL] [EOL] def test_cli_and_env_vars ( self ) : [EOL] renderer = dbt . config . renderer . DbtProjectYamlRenderer ( generate_base_context ( { [string] : [string] } ) ) [EOL] with mock . patch . dict ( os . environ , self . env_override ) : [EOL] project = dbt . config . Project . from_project_root ( self . project_dir , renderer , ) [EOL] [EOL] self . assertEqual ( project . version , [string] ) [EOL] self . assertEqual ( project . project_name , [string] ) [EOL] self . assertEqual ( project . profile_name , [string] ) [EOL] [EOL] [EOL] class TestRuntimeConfig ( BaseConfigTest ) : [EOL] def setUp ( self ) : [EOL] self . profiles_dir = [string] [EOL] self . project_dir = [string] [EOL] super ( ) . setUp ( ) [EOL] self . default_project_data [ [string] ] = self . project_dir [EOL] [EOL] def get_project ( self ) : [EOL] return project_from_config_norender ( self . default_project_data , verify_version = self . args . version_check ) [EOL] [EOL] def get_profile ( self ) : [EOL] renderer = empty_profile_renderer ( ) [EOL] return dbt . config . Profile . from_raw_profiles ( self . default_profile_data , self . default_project_data [ [string] ] , renderer ) [EOL] [EOL] def from_parts ( self , exc = None ) : [EOL] with self . assertRaisesOrReturns ( exc ) as err : [EOL] project = self . get_project ( ) [EOL] profile = self . get_profile ( ) [EOL] [EOL] result = dbt . config . RuntimeConfig . from_parts ( project , profile , self . args ) [EOL] [EOL] if exc is None : [EOL] return result [EOL] else : [EOL] return err [EOL] [EOL] def test_from_parts ( self ) : [EOL] project = self . get_project ( ) [EOL] profile = self . get_profile ( ) [EOL] config = dbt . config . RuntimeConfig . from_parts ( project , profile , self . args ) [EOL] [EOL] self . assertEqual ( config . cli_vars , { } ) [EOL] self . assertEqual ( config . to_profile_info ( ) , profile . to_profile_info ( ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] expected_project = project . to_project_config ( ) [EOL] self . assertEqual ( expected_project [ [string] ] , { } ) [EOL] [EOL] expected_project [ [string] ] = { [string] : True , [string] : True , [string] : True , } [EOL] self . assertEqual ( config . to_project_config ( ) , expected_project ) [EOL] [EOL] def test_str ( self ) : [EOL] project = self . get_project ( ) [EOL] profile = self . get_profile ( ) [EOL] config = dbt . config . RuntimeConfig . from_parts ( project , profile , { } ) [EOL] [EOL] [comment] [EOL] str ( config ) [EOL] [EOL] def test_validate_fails ( self ) : [EOL] project = self . get_project ( ) [EOL] profile = self . get_profile ( ) [EOL] [comment] [EOL] profile . config . use_colors = [number] [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) : [EOL] dbt . config . RuntimeConfig . from_parts ( project , profile , { } ) [EOL] [EOL] def test_supported_version ( self ) : [EOL] self . default_project_data [ [string] ] = [string] [EOL] conf = self . from_parts ( ) [EOL] self . assertEqual ( set ( x . to_version_string ( ) for x in conf . dbt_version ) , { [string] } ) [EOL] [EOL] def test_unsupported_version ( self ) : [EOL] self . default_project_data [ [string] ] = [string] [EOL] raised = self . from_parts ( dbt . exceptions . DbtProjectError ) [EOL] self . assertIn ( [string] , str ( raised . exception ) ) [EOL] [EOL] def test_unsupported_version_no_check ( self ) : [EOL] self . default_project_data [ [string] ] = [string] [EOL] self . args . version_check = False [EOL] conf = self . from_parts ( ) [EOL] self . assertEqual ( set ( x . to_version_string ( ) for x in conf . dbt_version ) , { [string] } ) [EOL] [EOL] def test_supported_version_range ( self ) : [EOL] self . default_project_data [ [string] ] = [ [string] , [string] ] [EOL] conf = self . from_parts ( ) [EOL] self . assertEqual ( set ( x . to_version_string ( ) for x in conf . dbt_version ) , { [string] , [string] } ) [EOL] [EOL] def test_unsupported_version_range ( self ) : [EOL] self . default_project_data [ [string] ] = [ [string] , [string] ] [EOL] raised = self . from_parts ( dbt . exceptions . DbtProjectError ) [EOL] self . assertIn ( [string] , str ( raised . exception ) ) [EOL] [EOL] def test_unsupported_version_range_bad_config ( self ) : [EOL] self . default_project_data [ [string] ] = [ [string] , [string] ] [EOL] self . default_project_data [ [string] ] = True [EOL] raised = self . from_parts ( dbt . exceptions . DbtProjectError ) [EOL] self . assertIn ( [string] , str ( raised . exception ) ) [EOL] [EOL] def test_unsupported_version_range_no_check ( self ) : [EOL] self . default_project_data [ [string] ] = [ [string] , [string] ] [EOL] self . args . version_check = False [EOL] conf = self . from_parts ( ) [EOL] self . assertEqual ( set ( x . to_version_string ( ) for x in conf . dbt_version ) , { [string] , [string] } ) [EOL] [EOL] def test_impossible_version_range ( self ) : [EOL] self . default_project_data [ [string] ] = [ [string] , [string] ] [EOL] raised = self . from_parts ( dbt . exceptions . DbtProjectError ) [EOL] self . assertIn ( [string] , str ( raised . exception ) ) [EOL] [EOL] def test_unsupported_version_extra_config ( self ) : [EOL] self . default_project_data [ [string] ] = True [EOL] raised = self . from_parts ( dbt . exceptions . DbtProjectError ) [EOL] self . assertIn ( [string] , str ( raised . exception ) ) [EOL] [EOL] def test_archive_not_allowed ( self ) : [EOL] self . default_project_data [ [string] ] = [ { [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , ] , } ] [EOL] with self . assertRaises ( dbt . exceptions . DbtProjectError ) : [EOL] self . get_project ( ) [EOL] [EOL] def test__no_unused_resource_config_paths ( self ) : [EOL] self . default_project_data . update ( { [string] : model_config , [string] : { } , } ) [EOL] project = self . from_parts ( ) [EOL] [EOL] resource_fqns = { [string] : model_fqns } [EOL] unused = project . get_unused_resource_config_paths ( resource_fqns , [ ] ) [EOL] self . assertEqual ( len ( unused ) , [number] ) [EOL] [EOL] def test__unused_resource_config_paths ( self ) : [EOL] self . default_project_data . update ( { [string] : model_config [ [string] ] , [string] : { } , } ) [EOL] project = self . from_parts ( ) [EOL] [EOL] resource_fqns = { [string] : model_fqns } [EOL] unused = project . get_unused_resource_config_paths ( resource_fqns , [ ] ) [EOL] self . assertEqual ( len ( unused ) , [number] ) [EOL] [EOL] def test__get_unused_resource_config_paths_empty ( self ) : [EOL] project = self . from_parts ( ) [EOL] unused = project . get_unused_resource_config_paths ( { [string] : frozenset ( ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) ) } , [ ] ) [EOL] self . assertEqual ( len ( unused ) , [number] ) [EOL] [EOL] def test__warn_for_unused_resource_config_paths_empty ( self ) : [EOL] project = self . from_parts ( ) [EOL] dbt . flags . WARN_ERROR = True [EOL] try : [EOL] project . warn_for_unused_resource_config_paths ( { [string] : frozenset ( ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) ) } , [ ] ) [EOL] finally : [EOL] dbt . flags . WARN_ERROR = False [EOL] [EOL] [EOL] class TestRuntimeConfigWithConfigs ( BaseConfigTest ) : [EOL] def setUp ( self ) : [EOL] self . profiles_dir = [string] [EOL] self . project_dir = [string] [EOL] super ( ) . setUp ( ) [EOL] self . default_project_data [ [string] ] = self . project_dir [EOL] self . default_project_data [ [string] ] = { [string] : True , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , } } , [string] : { [string] : [string] , } } } [EOL] self . used = { [string] : frozenset ( ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) ) } [EOL] [EOL] def get_project ( self ) : [EOL] return project_from_config_norender ( self . default_project_data , verify_version = True ) [EOL] [EOL] def get_profile ( self ) : [EOL] renderer = empty_profile_renderer ( ) [EOL] return dbt . config . Profile . from_raw_profiles ( self . default_profile_data , self . default_project_data [ [string] ] , renderer ) [EOL] [EOL] def from_parts ( self , exc = None ) : [EOL] with self . assertRaisesOrReturns ( exc ) as err : [EOL] project = self . get_project ( ) [EOL] profile = self . get_profile ( ) [EOL] [EOL] result = dbt . config . RuntimeConfig . from_parts ( project , profile , self . args ) [EOL] [EOL] if exc is None : [EOL] return result [EOL] else : [EOL] return err [EOL] [EOL] def test__get_unused_resource_config_paths ( self ) : [EOL] project = self . from_parts ( ) [EOL] unused = project . get_unused_resource_config_paths ( self . used , [ ] ) [EOL] self . assertEqual ( len ( unused ) , [number] ) [EOL] self . assertEqual ( unused [ [number] ] , ( [string] , [string] , [string] ) ) [EOL] [EOL] @ mock . patch . object ( dbt . config . runtime , [string] ) def test__warn_for_unused_resource_config_paths ( self , warn_or_error ) : [EOL] project = self . from_parts ( ) [EOL] project . warn_for_unused_resource_config_paths ( self . used , [ ] ) [EOL] warn_or_error . assert_called_once ( ) [EOL] [EOL] def test__warn_for_unused_resource_config_paths_disabled ( self ) : [EOL] project = self . from_parts ( ) [EOL] unused = project . get_unused_resource_config_paths ( self . used , frozenset ( [ ( [string] , [string] ) ] ) ) [EOL] [EOL] self . assertEqual ( len ( unused ) , [number] ) [EOL] [EOL] [EOL] class TestRuntimeConfigFiles ( BaseFileTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . write_profile ( self . default_profile_data ) [EOL] self . write_project ( self . default_project_data ) [EOL] [comment] [EOL] self . default_project_data [ [string] ] = self . project_dir [EOL] [EOL] def test_from_args ( self ) : [EOL] with temp_cd ( self . project_dir ) : [EOL] config = dbt . config . RuntimeConfig . from_args ( self . args ) [EOL] self . assertEqual ( config . version , [string] ) [EOL] self . assertEqual ( config . profile_name , [string] ) [EOL] [comment] [EOL] self . assertTrue ( os . path . samefile ( config . project_root , self . project_dir ) ) [EOL] self . assertEqual ( config . source_paths , [ [string] ] ) [EOL] self . assertEqual ( config . macro_paths , [ [string] ] ) [EOL] self . assertEqual ( config . data_paths , [ [string] ] ) [EOL] self . assertEqual ( config . test_paths , [ [string] ] ) [EOL] self . assertEqual ( config . analysis_paths , [ ] ) [EOL] self . assertEqual ( config . docs_paths , [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( config . asset_paths , [ ] ) [EOL] self . assertEqual ( config . target_path , [string] ) [EOL] self . assertEqual ( config . clean_targets , [ [string] ] ) [EOL] self . assertEqual ( config . log_path , [string] ) [EOL] self . assertEqual ( config . modules_path , [string] ) [EOL] self . assertEqual ( config . quoting , { [string] : True , [string] : True , [string] : True } ) [EOL] self . assertEqual ( config . models , { } ) [EOL] self . assertEqual ( config . on_run_start , [ ] ) [EOL] self . assertEqual ( config . on_run_end , [ ] ) [EOL] self . assertEqual ( config . seeds , { } ) [EOL] self . assertEqual ( config . packages , PackageConfig ( packages = [ ] ) ) [EOL] self . assertEqual ( config . project_name , [string] ) [EOL] [EOL] [EOL] class TestVariableRuntimeConfigFiles ( BaseFileTest ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . default_project_data . update ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , ] , [string] : { [string] : { [string] : [string] , } , [string] : { [string] : [string] , } } , [string] : { [string] : { [string] : [string] , } , [string] : { [string] : [string] , } } , } ) [EOL] self . write_project ( self . default_project_data ) [EOL] self . write_profile ( self . default_profile_data ) [EOL] [comment] [EOL] self . default_project_data [ [string] ] = self . project_dir [EOL] [EOL] def test_cli_and_env_vars ( self ) : [EOL] self . args . target = [string] [EOL] self . args . vars = [string] [EOL] with mock . patch . dict ( os . environ , self . env_override ) , temp_cd ( self . project_dir ) : [EOL] config = dbt . config . RuntimeConfig . from_args ( self . args ) [EOL] [EOL] self . assertEqual ( config . version , [string] ) [EOL] self . assertEqual ( config . project_name , [string] ) [EOL] self . assertEqual ( config . profile_name , [string] ) [EOL] self . assertEqual ( config . credentials . host , [string] ) [EOL] self . assertEqual ( config . credentials . user , [string] ) [EOL] [comment] [EOL] self . assertEqual ( config . on_run_end , [ [string] ] ) [EOL] self . assertEqual ( config . models [ [string] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( config . models [ [string] ] [ [string] ] , [string] ) [comment] [EOL] self . assertEqual ( config . seeds [ [string] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( config . seeds [ [string] ] [ [string] ] , [string] ) [comment] [EOL] [EOL] [EOL] class TestVarLookups ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . initial_src_vars = { [string] : [number] , [string] : [string] , [string] : { [string] : [string] , [string] : True , } , [string] : { [string] : [number] , } , } [EOL] self . src_vars = deepcopy ( self . initial_src_vars ) [EOL] self . dst = { [string] : deepcopy ( self . initial_src_vars ) } [EOL] [EOL] self . projects = [ [string] , [string] , [string] ] [EOL] load_plugin ( [string] ) [EOL] self . local_var_search = mock . MagicMock ( fqn = [ [string] , [string] ] , resource_type = NodeType . Model , package_name = [string] ) [EOL] self . other_var_search = mock . MagicMock ( fqn = [ [string] , [string] ] , resource_type = NodeType . Model , package_name = [string] ) [EOL] self . third_var_search = mock . MagicMock ( fqn = [ [string] , [string] ] , resource_type = NodeType . Model , package_name = [string] ) [EOL] [EOL] def test_lookups ( self ) : [EOL] vars_provider = dbt . config . project . VarProvider ( self . initial_src_vars ) [EOL] [EOL] expected = [ ( self . local_var_search , [string] , [number] ) , ( self . other_var_search , [string] , [number] ) , ( self . third_var_search , [string] , [number] ) , ( self . local_var_search , [string] , [string] ) , ( self . other_var_search , [string] , [string] ) , ( self . third_var_search , [string] , [string] ) , ( self . local_var_search , [string] , True ) , ( self . other_var_search , [string] , None ) , ( self . third_var_search , [string] , None ) , ] [EOL] for node , key , expected_value in expected : [EOL] value = vars_provider . vars_for ( node , [string] ) . get ( key ) [EOL] assert value == expected_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.unit.test_config.Args$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[unittest.mock.MagicMock,builtins.str,typing.Union[None,builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[unittest.mock.MagicMock,builtins.str,typing.Union[None,builtins.int,builtins.str]]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
import unittest [EOL] [EOL] class ImportTest ( unittest . TestCase ) : [EOL] [EOL] def test_import_dbt_main ( self ) : [EOL] [docstring] [EOL] import dbt . main [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import unittest [EOL] import typing [EOL] import os [EOL] import tempfile [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] from dbt import compilation [EOL] try : [EOL] from queue import Empty [EOL] except ImportError : [EOL] from Queue import Empty [EOL] [EOL] from dbt . graph . selector import NodeSelector [EOL] from dbt . graph . cli import parse_difference [EOL] [EOL] [EOL] def _mock_manifest ( nodes ) : [EOL] config = mock . MagicMock ( enabled = True ) [EOL] manifest = mock . MagicMock ( nodes = { n : mock . MagicMock ( unique_id = n , package_name = [string] , name = n , empty = False , config = config , fqn = [ [string] , n ] , ) for n in nodes } ) [EOL] manifest . expect . side_effect = lambda n : mock . MagicMock ( unique_id = n ) [EOL] return manifest [EOL] [EOL] [EOL] class LinkerTest ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . linker = compilation . Linker ( ) [EOL] [EOL] def test_linker_add_node ( self ) : [EOL] expected_nodes = [ [string] , [string] , [string] ] [EOL] for node in expected_nodes : [EOL] self . linker . add_node ( node ) [EOL] [EOL] actual_nodes = self . linker . nodes ( ) [EOL] for node in expected_nodes : [EOL] self . assertIn ( node , actual_nodes ) [EOL] [EOL] self . assertEqual ( len ( actual_nodes ) , len ( expected_nodes ) ) [EOL] [EOL] def test_linker_write_graph ( self ) : [EOL] expected_nodes = [ [string] , [string] , [string] ] [EOL] for node in expected_nodes : [EOL] self . linker . add_node ( node ) [EOL] [EOL] manifest = _mock_manifest ( [string] ) [EOL] ( fd , fname ) = tempfile . mkstemp ( ) [EOL] os . close ( fd ) [EOL] try : [EOL] self . linker . write_graph ( fname , manifest ) [EOL] assert os . path . exists ( fname ) [EOL] finally : [EOL] os . unlink ( fname ) [EOL] [EOL] def assert_would_join ( self , queue ) : [EOL] [docstring] [EOL] self . assertEqual ( queue . inner . unfinished_tasks , [number] ) [EOL] [EOL] def _get_graph_queue ( self , manifest , include = None , exclude = None ) : [EOL] graph = compilation . Graph ( self . linker . graph ) [EOL] selector = NodeSelector ( graph , manifest ) [EOL] spec = parse_difference ( include , exclude ) [EOL] return selector . get_graph_queue ( spec ) [EOL] [EOL] def test_linker_add_dependency ( self ) : [EOL] actual_deps = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] for ( l , r ) in actual_deps : [EOL] self . linker . dependency ( l , r ) [EOL] [EOL] queue = self . _get_graph_queue ( _mock_manifest ( [string] ) ) [EOL] [EOL] got = queue . get ( block = False ) [EOL] self . assertEqual ( got . unique_id , [string] ) [EOL] with self . assertRaises ( Empty ) : [EOL] queue . get ( block = False ) [EOL] self . assertFalse ( queue . empty ( ) ) [EOL] queue . mark_done ( [string] ) [EOL] self . assertFalse ( queue . empty ( ) ) [EOL] [EOL] got = queue . get ( block = False ) [EOL] self . assertEqual ( got . unique_id , [string] ) [EOL] with self . assertRaises ( Empty ) : [EOL] queue . get ( block = False ) [EOL] self . assertFalse ( queue . empty ( ) ) [EOL] queue . mark_done ( [string] ) [EOL] self . assertFalse ( queue . empty ( ) ) [EOL] [EOL] got = queue . get ( block = False ) [EOL] self . assertEqual ( got . unique_id , [string] ) [EOL] with self . assertRaises ( Empty ) : [EOL] queue . get ( block = False ) [EOL] self . assertTrue ( queue . empty ( ) ) [EOL] queue . mark_done ( [string] ) [EOL] self . assert_would_join ( queue ) [EOL] self . assertTrue ( queue . empty ( ) ) [EOL] [EOL] def test_linker_add_disjoint_dependencies ( self ) : [EOL] actual_deps = [ ( [string] , [string] ) ] [EOL] additional_node = [string] [EOL] [EOL] for ( l , r ) in actual_deps : [EOL] self . linker . dependency ( l , r ) [EOL] self . linker . add_node ( additional_node ) [EOL] [EOL] queue = self . _get_graph_queue ( _mock_manifest ( [string] ) ) [EOL] [comment] [EOL] first = queue . get ( block = False ) [EOL] self . assertEqual ( first . unique_id , [string] ) [EOL] self . assertFalse ( queue . empty ( ) ) [EOL] queue . mark_done ( [string] ) [EOL] self . assertFalse ( queue . empty ( ) ) [EOL] [EOL] second = queue . get ( block = False ) [EOL] self . assertIn ( second . unique_id , { [string] , [string] } ) [EOL] self . assertFalse ( queue . empty ( ) ) [EOL] queue . mark_done ( second . unique_id ) [EOL] self . assertFalse ( queue . empty ( ) ) [EOL] [EOL] third = queue . get ( block = False ) [EOL] self . assertIn ( third . unique_id , { [string] , [string] } ) [EOL] with self . assertRaises ( Empty ) : [EOL] queue . get ( block = False ) [EOL] self . assertNotEqual ( second . unique_id , third . unique_id ) [EOL] self . assertTrue ( queue . empty ( ) ) [EOL] queue . mark_done ( third . unique_id ) [EOL] self . assert_would_join ( queue ) [EOL] self . assertTrue ( queue . empty ( ) ) [EOL] [EOL] def test_linker_dependencies_limited_to_some_nodes ( self ) : [EOL] actual_deps = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] for ( l , r ) in actual_deps : [EOL] self . linker . dependency ( l , r ) [EOL] [EOL] queue = self . _get_graph_queue ( _mock_manifest ( [string] ) , [ [string] ] ) [EOL] got = queue . get ( block = False ) [EOL] self . assertEqual ( got . unique_id , [string] ) [EOL] self . assertTrue ( queue . empty ( ) ) [EOL] queue . mark_done ( [string] ) [EOL] self . assert_would_join ( queue ) [EOL] [EOL] queue_2 = queue = self . _get_graph_queue ( _mock_manifest ( [string] ) , [ [string] , [string] ] ) [EOL] got = queue_2 . get ( block = False ) [EOL] self . assertEqual ( got . unique_id , [string] ) [EOL] self . assertFalse ( queue_2 . empty ( ) ) [EOL] with self . assertRaises ( Empty ) : [EOL] queue_2 . get ( block = False ) [EOL] queue_2 . mark_done ( [string] ) [EOL] self . assertFalse ( queue_2 . empty ( ) ) [EOL] [EOL] got = queue_2 . get ( block = False ) [EOL] self . assertEqual ( got . unique_id , [string] ) [EOL] self . assertTrue ( queue_2 . empty ( ) ) [EOL] with self . assertRaises ( Empty ) : [EOL] queue_2 . get ( block = False ) [EOL] self . assertTrue ( queue_2 . empty ( ) ) [EOL] queue_2 . mark_done ( [string] ) [EOL] self . assert_would_join ( queue_2 ) [EOL] [EOL] def test__find_cycles__cycles ( self ) : [EOL] actual_deps = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] for ( l , r ) in actual_deps : [EOL] self . linker . dependency ( l , r ) [EOL] [EOL] self . assertIsNotNone ( self . linker . find_cycles ( ) ) [EOL] [EOL] def test__find_cycles__no_cycles ( self ) : [EOL] actual_deps = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] [EOL] for ( l , r ) in actual_deps : [EOL] self . linker . dependency ( l , r ) [EOL] [EOL] self . assertIsNone ( self . linker . find_cycles ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] from pathlib import Path [EOL] import unittest [EOL] from unittest import mock [EOL] from dbt . adapters . factory import AdapterContainer [EOL] from dbt . adapters . base . plugin import AdapterPlugin [EOL] from dbt . include . global_project import ( PACKAGE_PATH as GLOBAL_PROJECT_PATH , PROJECT_NAME as GLOBAL_PROJECT_NAME , ) [EOL] [EOL] [EOL] class TestGetPackageNames ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] with mock . patch ( [string] ) as get_name : [EOL] get_name . return_value = [string] [EOL] self . root_plugin = AdapterPlugin ( adapter = mock . MagicMock ( ) , credentials = mock . MagicMock ( ) , include_path = [string] , dependencies = [ [string] , [string] ] , ) [EOL] get_name . return_value = [string] [EOL] self . childa = AdapterPlugin ( adapter = mock . MagicMock ( ) , credentials = mock . MagicMock ( ) , include_path = [string] , ) [EOL] get_name . return_value = [string] [EOL] self . childb = AdapterPlugin ( adapter = mock . MagicMock ( ) , credentials = mock . MagicMock ( ) , include_path = [string] , dependencies = [ [string] ] ) [EOL] get_name . return_value = [string] [EOL] self . childc = AdapterPlugin ( adapter = mock . MagicMock ( ) , credentials = mock . MagicMock ( ) , include_path = [string] , ) [EOL] [EOL] self . _mock_modules = { [string] : self . root_plugin , [string] : self . childa , [string] : self . childb , [string] : self . childc , } [EOL] [EOL] self . factory = AdapterContainer ( ) [EOL] [EOL] self . load_patch = mock . patch . object ( AdapterContainer , [string] ) [EOL] self . mock_load = self . load_patch . start ( ) [EOL] [EOL] [EOL] def mock_load_plugin ( name ) : [EOL] try : [EOL] plugin = self . _mock_modules [ name ] [EOL] except KeyError : [EOL] raise RuntimeError ( f' [string] { name } [string] ' ) [EOL] self . factory . plugins [ name ] = plugin [EOL] self . factory . packages [ plugin . project_name ] = Path ( plugin . include_path ) [EOL] for dep in plugin . dependencies : [EOL] self . factory . load_plugin ( dep ) [EOL] [EOL] self . mock_load . side_effect = mock_load_plugin [EOL] [EOL] def tearDown ( self ) : [EOL] self . load_patch . stop ( ) [EOL] [EOL] def test_no_packages ( self ) : [EOL] assert self . factory . get_adapter_package_names ( None ) == [ GLOBAL_PROJECT_NAME ] [EOL] [EOL] def test_one_package ( self ) : [EOL] self . factory . load_plugin ( [string] ) [EOL] assert self . factory . get_adapter_package_names ( [string] ) == [ [string] , GLOBAL_PROJECT_NAME ] [EOL] [EOL] def test_simple_child_packages ( self ) : [EOL] self . factory . load_plugin ( [string] ) [EOL] assert self . factory . get_adapter_package_names ( [string] ) == [ [string] , [string] , GLOBAL_PROJECT_NAME ] [EOL] [EOL] def test_layered_child_packages ( self ) : [EOL] self . factory . load_plugin ( [string] ) [EOL] assert self . factory . get_adapter_package_names ( [string] ) == [ [string] , [string] , [string] , [string] , GLOBAL_PROJECT_NAME ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import os [EOL] import shutil [EOL] import stat [EOL] import unittest [EOL] from tempfile import mkdtemp , NamedTemporaryFile [EOL] [EOL] from dbt . exceptions import ExecutableError , WorkingDirectoryError [EOL] import dbt . clients . system [EOL] [EOL] [EOL] class SystemClient ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . tmp_dir = mkdtemp ( ) [EOL] self . profiles_path = [string] . format ( self . tmp_dir ) [EOL] [EOL] def set_up_profile ( self ) : [EOL] with open ( self . profiles_path , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] def get_profile_text ( self ) : [EOL] with open ( self . profiles_path , [string] ) as f : [EOL] return f . read ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] try : [EOL] shutil . rmtree ( self . tmp_dir ) [EOL] except : [EOL] pass [EOL] [EOL] def test__make_file_when_exists ( self ) : [EOL] self . set_up_profile ( ) [EOL] written = dbt . clients . system . make_file ( self . profiles_path , contents = [string] ) [EOL] [EOL] self . assertFalse ( written ) [EOL] self . assertEqual ( self . get_profile_text ( ) , [string] ) [EOL] [EOL] def test__make_file_when_not_exists ( self ) : [EOL] written = dbt . clients . system . make_file ( self . profiles_path , contents = [string] ) [EOL] [EOL] self . assertTrue ( written ) [EOL] self . assertEqual ( self . get_profile_text ( ) , [string] ) [EOL] [EOL] def test__make_file_with_overwrite ( self ) : [EOL] self . set_up_profile ( ) [EOL] written = dbt . clients . system . make_file ( self . profiles_path , contents = [string] , overwrite = True ) [EOL] [EOL] self . assertTrue ( written ) [EOL] self . assertEqual ( self . get_profile_text ( ) , [string] ) [EOL] [EOL] [EOL] class TestRunCmd ( unittest . TestCase ) : [EOL] [docstring] [EOL] not_a_file = [string] [EOL] def setUp ( self ) : [EOL] self . tempdir = mkdtemp ( ) [EOL] self . run_dir = os . path . join ( self . tempdir , [string] ) [EOL] self . does_not_exist = os . path . join ( self . tempdir , [string] ) [EOL] self . empty_file = os . path . join ( self . tempdir , [string] ) [EOL] if os . name == [string] : [EOL] self . exists_cmd = [ [string] , [string] , [string] , [string] ] [EOL] else : [EOL] self . exists_cmd = [ [string] , [string] ] [EOL] [EOL] [EOL] os . mkdir ( self . run_dir ) [EOL] with open ( self . empty_file , [string] ) as fp : [EOL] pass [comment] [EOL] [EOL] def tearDown ( self ) : [EOL] shutil . rmtree ( self . tempdir ) [EOL] [EOL] def test__executable_does_not_exist ( self ) : [EOL] with self . assertRaises ( ExecutableError ) as exc : [EOL] dbt . clients . system . run_cmd ( self . run_dir , [ self . does_not_exist ] ) [EOL] [EOL] msg = str ( exc . exception ) . lower ( ) [EOL] [EOL] self . assertIn ( [string] , msg ) [EOL] self . assertIn ( [string] , msg ) [EOL] self . assertIn ( self . does_not_exist . lower ( ) , msg ) [EOL] [EOL] def test__not_exe ( self ) : [EOL] with self . assertRaises ( ExecutableError ) as exc : [EOL] dbt . clients . system . run_cmd ( self . run_dir , [ self . empty_file ] ) [EOL] [EOL] msg = str ( exc . exception ) . lower ( ) [EOL] if os . name == [string] : [EOL] [comment] [EOL] self . assertIn ( [string] , msg ) [EOL] else : [EOL] [comment] [EOL] self . assertIn ( [string] , msg ) [EOL] self . assertIn ( self . empty_file . lower ( ) , msg ) [EOL] [EOL] def test__cwd_does_not_exist ( self ) : [EOL] with self . assertRaises ( WorkingDirectoryError ) as exc : [EOL] dbt . clients . system . run_cmd ( self . does_not_exist , self . exists_cmd ) [EOL] msg = str ( exc . exception ) . lower ( ) [EOL] self . assertIn ( [string] , msg ) [EOL] self . assertIn ( self . does_not_exist . lower ( ) , msg ) [EOL] [EOL] def test__cwd_not_directory ( self ) : [EOL] with self . assertRaises ( WorkingDirectoryError ) as exc : [EOL] dbt . clients . system . run_cmd ( self . empty_file , self . exists_cmd ) [EOL] [EOL] msg = str ( exc . exception ) . lower ( ) [EOL] self . assertIn ( [string] , msg ) [EOL] self . assertIn ( self . empty_file . lower ( ) , msg ) [EOL] [EOL] def test__cwd_no_permissions ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if os . name == [string] : [EOL] return [EOL] [EOL] [comment] [EOL] os . chmod ( self . run_dir , stat . S_IRUSR ) [EOL] [EOL] with self . assertRaises ( WorkingDirectoryError ) as exc : [EOL] dbt . clients . system . run_cmd ( self . run_dir , self . exists_cmd ) [EOL] [EOL] msg = str ( exc . exception ) . lower ( ) [EOL] self . assertIn ( [string] , msg ) [EOL] self . assertIn ( self . run_dir . lower ( ) , msg ) [EOL] [EOL] def test__ok ( self ) : [EOL] out , err = dbt . clients . system . run_cmd ( self . run_dir , self . exists_cmd ) [EOL] self . assertEqual ( out . strip ( ) , [string] ) [EOL] self . assertEqual ( err . strip ( ) , [string] ) [EOL] [EOL] [EOL] class TestFindMatching ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . base_dir = mkdtemp ( ) [EOL] self . tempdir = mkdtemp ( dir = self . base_dir ) [EOL] [EOL] def test_find_matching_lowercase_file_pattern ( self ) : [EOL] with NamedTemporaryFile ( prefix = [string] , suffix = [string] , dir = self . tempdir ) as named_file : [EOL] file_path = os . path . dirname ( named_file . name ) [EOL] relative_path = os . path . basename ( file_path ) [EOL] out = dbt . clients . system . find_matching ( self . base_dir , [ relative_path ] , [string] ) [EOL] expected_output = [ { [string] : relative_path , [string] : named_file . name , [string] : os . path . basename ( named_file . name ) } ] [EOL] self . assertEqual ( out , expected_output ) [EOL] [EOL] def test_find_matching_uppercase_file_pattern ( self ) : [EOL] with NamedTemporaryFile ( prefix = [string] , suffix = [string] , dir = self . tempdir ) as named_file : [EOL] file_path = os . path . dirname ( named_file . name ) [EOL] relative_path = os . path . basename ( file_path ) [EOL] out = dbt . clients . system . find_matching ( self . base_dir , [ relative_path ] , [string] ) [EOL] expected_output = [ { [string] : relative_path , [string] : named_file . name , [string] : os . path . basename ( named_file . name ) } ] [EOL] self . assertEqual ( out , expected_output ) [EOL] [EOL] def test_find_matching_file_pattern_not_found ( self ) : [EOL] with NamedTemporaryFile ( prefix = [string] , suffix = [string] , dir = self . tempdir ) : [EOL] out = dbt . clients . system . find_matching ( self . tempdir , [ [string] ] , [string] ) [EOL] self . assertEqual ( out , [ ] ) [EOL] [EOL] def tearDown ( self ) : [EOL] try : [EOL] shutil . rmtree ( self . base_dir ) [EOL] except : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import dbt . tracking [EOL] import datetime [EOL] import shutil [EOL] import tempfile [EOL] import unittest [EOL] [EOL] [EOL] class TestTracking ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] dbt . tracking . active_user = None [EOL] self . tempdir = tempfile . mkdtemp ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] dbt . tracking . active_user = None [EOL] shutil . rmtree ( self . tempdir ) [EOL] [EOL] def test_tracking_initial ( self ) : [EOL] assert dbt . tracking . active_user is None [EOL] dbt . tracking . initialize_tracking ( self . tempdir ) [EOL] assert isinstance ( dbt . tracking . active_user , dbt . tracking . User ) [EOL] [EOL] invocation_id = dbt . tracking . active_user . invocation_id [EOL] run_started_at = dbt . tracking . active_user . run_started_at [EOL] [EOL] assert dbt . tracking . active_user . do_not_track is False [EOL] assert isinstance ( dbt . tracking . active_user . id , str ) [EOL] assert isinstance ( invocation_id , str ) [EOL] assert isinstance ( run_started_at , datetime . datetime ) [EOL] [EOL] dbt . tracking . disable_tracking ( ) [EOL] assert isinstance ( dbt . tracking . active_user , dbt . tracking . User ) [EOL] [EOL] assert dbt . tracking . active_user . do_not_track is True [EOL] assert dbt . tracking . active_user . id is None [EOL] assert dbt . tracking . active_user . invocation_id == invocation_id [EOL] assert dbt . tracking . active_user . run_started_at == run_started_at [EOL] [EOL] [comment] [EOL] dbt . tracking . do_not_track ( ) [EOL] assert isinstance ( dbt . tracking . active_user , dbt . tracking . User ) [EOL] [EOL] assert dbt . tracking . active_user . do_not_track is True [EOL] assert dbt . tracking . active_user . id is None [EOL] assert isinstance ( dbt . tracking . active_user . invocation_id , str ) [EOL] assert isinstance ( dbt . tracking . active_user . run_started_at , datetime . datetime ) [EOL] assert dbt . tracking . active_user . invocation_id != invocation_id [EOL] [comment] [EOL] assert dbt . tracking . active_user . run_started_at is not run_started_at [EOL] [EOL] def test_tracking_never_ok ( self ) : [EOL] assert dbt . tracking . active_user is None [EOL] [EOL] [comment] [EOL] dbt . tracking . do_not_track ( ) [EOL] assert isinstance ( dbt . tracking . active_user , dbt . tracking . User ) [EOL] [EOL] assert dbt . tracking . active_user . do_not_track is True [EOL] assert dbt . tracking . active_user . id is None [EOL] assert isinstance ( dbt . tracking . active_user . invocation_id , str ) [EOL] assert isinstance ( dbt . tracking . active_user . run_started_at , datetime . datetime ) [EOL] [EOL] def test_disable_never_enabled ( self ) : [EOL] assert dbt . tracking . active_user is None [EOL] [EOL] [comment] [EOL] dbt . tracking . disable_tracking ( ) [EOL] assert isinstance ( dbt . tracking . active_user , dbt . tracking . User ) [EOL] [EOL] assert dbt . tracking . active_user . do_not_track is True [EOL] assert dbt . tracking . active_user . id is None [EOL] assert isinstance ( dbt . tracking . active_user . invocation_id , str ) [EOL] assert isinstance ( dbt . tracking . active_user . run_started_at , datetime . datetime ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import test [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import dbt . deps [EOL] import dbt . exceptions [EOL] from dbt . deps . git import GitUnpinnedPackage [EOL] from dbt . deps . local import LocalUnpinnedPackage [EOL] from dbt . deps . registry import RegistryUnpinnedPackage [EOL] from dbt . deps . resolver import resolve_packages [EOL] from dbt . contracts . project import ( LocalPackage , GitPackage , RegistryPackage , ) [EOL] [EOL] from dbt . contracts . project import PackageConfig [EOL] from dbt . semver import VersionSpecifier [EOL] [EOL] from hologram import ValidationError [EOL] [EOL] [EOL] class TestLocalPackage ( unittest . TestCase ) : [EOL] def test_init ( self ) : [EOL] a_contract = LocalPackage . from_dict ( { [string] : [string] } ) [EOL] self . assertEqual ( a_contract . local , [string] ) [EOL] a = LocalUnpinnedPackage . from_contract ( a_contract ) [EOL] self . assertEqual ( a . local , [string] ) [EOL] a_pinned = a . resolved ( ) [EOL] self . assertEqual ( a_pinned . local , [string] ) [EOL] self . assertEqual ( str ( a_pinned ) , [string] ) [EOL] [EOL] [EOL] class TestGitPackage ( unittest . TestCase ) : [EOL] def test_init ( self ) : [EOL] a_contract = GitPackage . from_dict ( { [string] : [string] , [string] : [string] } ) [EOL] self . assertEqual ( a_contract . git , [string] ) [EOL] self . assertEqual ( a_contract . revision , [string] ) [EOL] self . assertIs ( a_contract . warn_unpinned , None ) [EOL] [EOL] a = GitUnpinnedPackage . from_contract ( a_contract ) [EOL] self . assertEqual ( a . git , [string] ) [EOL] self . assertEqual ( a . revisions , [ [string] ] ) [EOL] self . assertIs ( a . warn_unpinned , True ) [EOL] [EOL] a_pinned = a . resolved ( ) [EOL] self . assertEqual ( a_pinned . name , [string] ) [EOL] self . assertEqual ( a_pinned . get_version ( ) , [string] ) [EOL] self . assertEqual ( a_pinned . source_type ( ) , [string] ) [EOL] self . assertIs ( a_pinned . warn_unpinned , True ) [EOL] [EOL] def test_invalid ( self ) : [EOL] with self . assertRaises ( ValidationError ) : [EOL] GitPackage . from_dict ( { [string] : [string] , [string] : [string] } ) [EOL] [EOL] def test_resolve_ok ( self ) : [EOL] a_contract = GitPackage . from_dict ( { [string] : [string] , [string] : [string] } ) [EOL] b_contract = GitPackage . from_dict ( { [string] : [string] , [string] : [string] , [string] : False } ) [EOL] a = GitUnpinnedPackage . from_contract ( a_contract ) [EOL] b = GitUnpinnedPackage . from_contract ( b_contract ) [EOL] self . assertTrue ( a . warn_unpinned ) [EOL] self . assertFalse ( b . warn_unpinned ) [EOL] c = a . incorporate ( b ) [EOL] [EOL] c_pinned = c . resolved ( ) [EOL] self . assertEqual ( c_pinned . name , [string] ) [EOL] self . assertEqual ( c_pinned . get_version ( ) , [string] ) [EOL] self . assertEqual ( c_pinned . source_type ( ) , [string] ) [EOL] self . assertFalse ( c_pinned . warn_unpinned ) [EOL] [EOL] def test_resolve_fail ( self ) : [EOL] a_contract = GitPackage . from_dict ( { [string] : [string] , [string] : [string] } ) [EOL] b_contract = GitPackage . from_dict ( { [string] : [string] , [string] : [string] } ) [EOL] a = GitUnpinnedPackage . from_contract ( a_contract ) [EOL] b = GitUnpinnedPackage . from_contract ( b_contract ) [EOL] c = a . incorporate ( b ) [EOL] self . assertEqual ( c . git , [string] ) [EOL] self . assertEqual ( c . revisions , [ [string] , [string] ] ) [EOL] [EOL] with self . assertRaises ( dbt . exceptions . DependencyException ) : [EOL] c . resolved ( ) [EOL] [EOL] def test_default_revision ( self ) : [EOL] a_contract = GitPackage . from_dict ( { [string] : [string] } ) [EOL] self . assertEqual ( a_contract . revision , None ) [EOL] self . assertIs ( a_contract . warn_unpinned , None ) [EOL] [EOL] a = GitUnpinnedPackage . from_contract ( a_contract ) [EOL] self . assertEqual ( a . git , [string] ) [EOL] self . assertEqual ( a . revisions , [ ] ) [EOL] self . assertIs ( a . warn_unpinned , True ) [EOL] [EOL] a_pinned = a . resolved ( ) [EOL] self . assertEqual ( a_pinned . name , [string] ) [EOL] self . assertEqual ( a_pinned . get_version ( ) , [string] ) [EOL] self . assertEqual ( a_pinned . source_type ( ) , [string] ) [EOL] self . assertIs ( a_pinned . warn_unpinned , True ) [EOL] [EOL] [EOL] class TestHubPackage ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . patcher = mock . patch ( [string] ) [EOL] self . registry = self . patcher . start ( ) [EOL] self . index_cached = self . registry . index_cached [EOL] self . get_available_versions = self . registry . get_available_versions [EOL] self . package_version = self . registry . package_version [EOL] [EOL] self . index_cached . return_value = [ [string] , ] [EOL] self . get_available_versions . return_value = [ [string] , [string] ] [EOL] self . package_version . return_value = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : { [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : [ [string] , [string] ] , } [EOL] [EOL] def tearDown ( self ) : [EOL] self . patcher . stop ( ) [EOL] [EOL] def test_init ( self ) : [EOL] a_contract = RegistryPackage ( package = [string] , version = [string] , ) [EOL] self . assertEqual ( a_contract . package , [string] ) [EOL] self . assertEqual ( a_contract . version , [string] ) [EOL] [EOL] a = RegistryUnpinnedPackage . from_contract ( a_contract ) [EOL] self . assertEqual ( a . package , [string] ) [EOL] self . assertEqual ( a . versions , [ VersionSpecifier ( build = None , major = [string] , matcher = [string] , minor = [string] , patch = [string] , prerelease = None ) ] ) [EOL] [EOL] a_pinned = a . resolved ( ) [EOL] self . assertEqual ( a_contract . package , [string] ) [EOL] self . assertEqual ( a_contract . version , [string] ) [EOL] self . assertEqual ( a_pinned . source_type ( ) , [string] ) [EOL] [EOL] def test_invalid ( self ) : [EOL] with self . assertRaises ( ValidationError ) : [EOL] RegistryPackage . from_dict ( { [string] : [string] , [string] : [string] } ) [EOL] [EOL] def test_resolve_ok ( self ) : [EOL] a_contract = RegistryPackage ( package = [string] , version = [string] ) [EOL] b_contract = RegistryPackage ( package = [string] , version = [string] ) [EOL] a = RegistryUnpinnedPackage . from_contract ( a_contract ) [EOL] b = RegistryUnpinnedPackage . from_contract ( b_contract ) [EOL] c = a . incorporate ( b ) [EOL] [EOL] self . assertEqual ( c . package , [string] ) [EOL] self . assertEqual ( c . versions , [ VersionSpecifier ( build = None , major = [string] , matcher = [string] , minor = [string] , patch = [string] , prerelease = None , ) , VersionSpecifier ( build = None , major = [string] , matcher = [string] , minor = [string] , patch = [string] , prerelease = None , ) , ] ) [EOL] [EOL] c_pinned = c . resolved ( ) [EOL] self . assertEqual ( c_pinned . package , [string] ) [EOL] self . assertEqual ( c_pinned . version , [string] ) [EOL] self . assertEqual ( c_pinned . source_type ( ) , [string] ) [EOL] [EOL] def test_resolve_missing_package ( self ) : [EOL] a = RegistryUnpinnedPackage . from_contract ( RegistryPackage ( package = [string] , version = [string] ) ) [EOL] with self . assertRaises ( dbt . exceptions . DependencyException ) as exc : [EOL] a . resolved ( ) [EOL] [EOL] msg = [string] [EOL] self . assertEqual ( msg , str ( exc . exception ) ) [EOL] [EOL] def test_resolve_missing_version ( self ) : [EOL] a = RegistryUnpinnedPackage . from_contract ( RegistryPackage ( package = [string] , version = [string] ) ) [EOL] [EOL] with self . assertRaises ( dbt . exceptions . DependencyException ) as exc : [EOL] a . resolved ( ) [EOL] msg = ( [string] [string] [string] ) [EOL] self . assertEqual ( msg , str ( exc . exception ) ) [EOL] [EOL] def test_resolve_conflict ( self ) : [EOL] a_contract = RegistryPackage ( package = [string] , version = [string] ) [EOL] b_contract = RegistryPackage ( package = [string] , version = [string] ) [EOL] a = RegistryUnpinnedPackage . from_contract ( a_contract ) [EOL] b = RegistryUnpinnedPackage . from_contract ( b_contract ) [EOL] c = a . incorporate ( b ) [EOL] [EOL] with self . assertRaises ( dbt . exceptions . DependencyException ) as exc : [EOL] c . resolved ( ) [EOL] msg = ( [string] [string] ) [EOL] self . assertEqual ( msg , str ( exc . exception ) ) [EOL] [EOL] def test_resolve_ranges ( self ) : [EOL] a_contract = RegistryPackage ( package = [string] , version = [string] ) [EOL] b_contract = RegistryPackage ( package = [string] , version = [string] ) [EOL] a = RegistryUnpinnedPackage . from_contract ( a_contract ) [EOL] b = RegistryUnpinnedPackage . from_contract ( b_contract ) [EOL] c = a . incorporate ( b ) [EOL] [EOL] self . assertEqual ( c . package , [string] ) [EOL] self . assertEqual ( c . versions , [ VersionSpecifier ( build = None , major = [string] , matcher = [string] , minor = [string] , patch = [string] , prerelease = None , ) , VersionSpecifier ( build = None , major = [string] , matcher = [string] , minor = [string] , patch = [string] , prerelease = None , ) , ] ) [EOL] [EOL] c_pinned = c . resolved ( ) [EOL] self . assertEqual ( c_pinned . package , [string] ) [EOL] self . assertEqual ( c_pinned . version , [string] ) [EOL] self . assertEqual ( c_pinned . source_type ( ) , [string] ) [EOL] [EOL] [EOL] class MockRegistry : [EOL] def __init__ ( self , packages ) : [EOL] self . packages = packages [EOL] [EOL] def index_cached ( self , registry_base_url = None ) : [EOL] return sorted ( self . packages ) [EOL] [EOL] def get_available_versions ( self , name ) : [EOL] try : [EOL] pkg = self . packages [ name ] [EOL] except KeyError : [EOL] return [ ] [EOL] return list ( pkg ) [EOL] [EOL] def package_version ( self , name , version ) : [EOL] try : [EOL] return self . packages [ name ] [ version ] [EOL] except KeyError : [EOL] return None [EOL] [EOL] [EOL] class TestPackageSpec ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . patcher = mock . patch ( [string] ) [EOL] self . registry = self . patcher . start ( ) [EOL] self . mock_registry = MockRegistry ( packages = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : { [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : [ [string] , [string] ] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : { [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : [ [string] , [string] ] , } } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } ] , [string] : { [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : [ [string] , [string] ] , } , } } ) [EOL] [EOL] self . registry . index_cached . side_effect = self . mock_registry . index_cached [EOL] self . registry . get_available_versions . side_effect = self . mock_registry . get_available_versions [EOL] self . registry . package_version . side_effect = self . mock_registry . package_version [EOL] [EOL] def tearDown ( self ) : [EOL] self . patcher . stop ( ) [EOL] [EOL] def test_dependency_resolution ( self ) : [EOL] package_config = PackageConfig . from_dict ( { [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , } ) [EOL] resolved = resolve_packages ( package_config . packages , mock . MagicMock ( project_name = [string] ) ) [EOL] self . assertEqual ( len ( resolved ) , [number] ) [EOL] self . assertEqual ( resolved [ [number] ] . name , [string] ) [EOL] self . assertEqual ( resolved [ [number] ] . version , [string] ) [EOL] self . assertEqual ( resolved [ [number] ] . name , [string] ) [EOL] self . assertEqual ( resolved [ [number] ] . version , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.unit.test_deps.MockRegistry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.unit.test_deps.MockRegistry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.unit.test_deps.MockRegistry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.unit.test_deps.MockRegistry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import dbt [EOL] import builtins [EOL] import typing [EOL] from dbt . graph import ( cli , SelectionUnion , SelectionIntersection , SelectionDifference , SelectionCriteria , ) [EOL] from dbt . graph . selector_methods import MethodName [EOL] import textwrap [EOL] import yaml [EOL] [EOL] from dbt . contracts . selection import SelectorFile [EOL] [EOL] [EOL] def parse_file ( txt ) : [EOL] txt = textwrap . dedent ( txt ) [EOL] dct = yaml . safe_load ( txt ) [EOL] sf = SelectorFile . from_dict ( dct ) [EOL] return sf [EOL] [EOL] [EOL] class Union : [EOL] def __init__ ( self , * args ) : [EOL] self . components = args [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . components } [string] ' [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . components !r} [string] ' [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , SelectionUnion ) : [EOL] return False [EOL] [EOL] return all ( mine == theirs for mine , theirs in zip ( self . components , other . components ) ) [EOL] [EOL] [EOL] class Intersection : [EOL] def __init__ ( self , * args ) : [EOL] self . components = args [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . components } [string] ' [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . components !r} [string] ' [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , SelectionIntersection ) : [EOL] return False [EOL] [EOL] return all ( mine == theirs for mine , theirs in zip ( self . components , other . components ) ) [EOL] [EOL] [EOL] class Difference : [EOL] def __init__ ( self , * args ) : [EOL] self . components = args [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . components } [string] ' [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . components !r} [string] ' [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , SelectionDifference ) : [EOL] return False [EOL] [EOL] return all ( mine == theirs for mine , theirs in zip ( self . components , other . components ) ) [EOL] [EOL] [EOL] class Criteria : [EOL] def __init__ ( self , method , value , ** kwargs ) : [EOL] self . method = method [EOL] self . value = value [EOL] self . kwargs = kwargs [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . method } [string] { self . value } [string] { self . kwargs } [string] ' [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . method !r} [string] { self . value !r} [string] { self . kwargs !r} [string] ' [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , SelectionCriteria ) : [EOL] return False [EOL] return ( self . method == other . method and self . value == other . value and all ( getattr ( other , k ) == v for k , v in self . kwargs . items ( ) ) ) [EOL] [EOL] [EOL] def test_parse_simple ( ) : [EOL] sf = parse_file ( [string] ) [EOL] [EOL] assert len ( sf . selectors ) == [number] [EOL] parsed = cli . parse_from_selectors_definition ( sf ) [EOL] assert len ( parsed ) == [number] [EOL] assert [string] in parsed [EOL] assert Criteria ( method = MethodName . Tag , method_arguments = [ ] , value = [string] , children = False , parents = False , childrens_parents = False , children_depth = None , parents_depth = None , ) == parsed [ [string] ] [EOL] [EOL] [EOL] def test_parse_simple_childrens_parents ( ) : [EOL] sf = parse_file ( [string] ) [EOL] [EOL] assert len ( sf . selectors ) == [number] [EOL] parsed = cli . parse_from_selectors_definition ( sf ) [EOL] assert len ( parsed ) == [number] [EOL] assert [string] in parsed [EOL] assert Criteria ( method = MethodName . Tag , method_arguments = [ ] , value = [string] , children = False , parents = False , childrens_parents = True , children_depth = None , parents_depth = None , ) == parsed [ [string] ] [EOL] [EOL] [EOL] def test_parse_simple_arguments_with_modifiers ( ) : [EOL] sf = parse_file ( [string] ) [EOL] [EOL] assert len ( sf . selectors ) == [number] [EOL] parsed = cli . parse_from_selectors_definition ( sf ) [EOL] assert len ( parsed ) == [number] [EOL] assert [string] in parsed [EOL] assert Criteria ( method = MethodName . Config , method_arguments = [ [string] ] , value = [string] , children = True , parents = True , childrens_parents = False , children_depth = [number] , parents_depth = None , ) == parsed [ [string] ] [EOL] [EOL] [EOL] def test_parse_union ( ) : [EOL] sf = parse_file ( [string] ) [EOL] assert len ( sf . selectors ) == [number] [EOL] parsed = cli . parse_from_selectors_definition ( sf ) [EOL] assert [string] in parsed [EOL] assert Union ( Criteria ( method = MethodName . Config , value = [string] , method_arguments = [ [string] ] ) , Criteria ( method = MethodName . Tag , value = [string] , method_arguments = [ ] ) ) == parsed [ [string] ] [EOL] [EOL] [EOL] def test_parse_intersection ( ) : [EOL] sf = parse_file ( [string] ) [EOL] assert len ( sf . selectors ) == [number] [EOL] parsed = cli . parse_from_selectors_definition ( sf ) [EOL] [EOL] assert [string] in parsed [EOL] assert Intersection ( Criteria ( method = MethodName . Config , value = [string] , method_arguments = [ [string] ] ) , Criteria ( method = MethodName . Tag , value = [string] , method_arguments = [ ] ) , ) == parsed [ [string] ] [EOL] [EOL] [EOL] def test_parse_union_excluding ( ) : [EOL] sf = parse_file ( [string] ) [EOL] assert len ( sf . selectors ) == [number] [EOL] parsed = cli . parse_from_selectors_definition ( sf ) [EOL] assert [string] in parsed [EOL] assert Difference ( Union ( Criteria ( method = MethodName . Config , value = [string] , method_arguments = [ [string] ] ) , Criteria ( method = MethodName . Tag , value = [string] , method_arguments = [ ] ) ) , Criteria ( method = MethodName . Tag , value = [string] , method_arguments = [ ] ) , ) == parsed [ [string] ] [EOL] [EOL] [EOL] def test_parse_yaml_complex ( ) : [EOL] sf = parse_file ( [string] ) [EOL] [EOL] assert len ( sf . selectors ) == [number] [EOL] parsed = cli . parse_from_selectors_definition ( sf ) [EOL] assert [string] in parsed [EOL] assert [string] in parsed [EOL] assert Union ( Criteria ( method = MethodName . Tag , value = [string] ) , Criteria ( method = MethodName . Tag , value = [string] ) , ) == parsed [ [string] ] [EOL] [EOL] assert Union ( Intersection ( Criteria ( method = MethodName . Tag , value = [string] ) , Criteria ( method = MethodName . Tag , value = [string] ) , Union ( Criteria ( method = MethodName . Package , value = [string] ) , Criteria ( method = MethodName . Config , value = [string] , method_arguments = [ [string] ] ) , ) , ) , Union ( Criteria ( method = MethodName . Path , value = [string] ) , Criteria ( method = MethodName . FQN , value = [string] ) , ) , Difference ( Intersection ( Criteria ( method = MethodName . ResourceType , value = [string] ) , Criteria ( method = MethodName . Package , value = [string] ) , ) , Union ( Criteria ( method = MethodName . FQN , value = [string] ) , Intersection ( Criteria ( method = MethodName . Tag , value = [string] ) , Criteria ( method = MethodName . Config , value = [string] , method_arguments = [ [string] ] ) , ) , ) , ) , ) == parsed [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.contracts.selection.SelectorFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict [EOL] import unittest [EOL] import test [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] from . utils import config_from_parts_or_dicts , normalize [EOL] [EOL] from dbt . contracts . files import SourceFile , FileHash , FilePath [EOL] from dbt . parser import ParseResult [EOL] from dbt . parser . search import FileBlock [EOL] from dbt . parser import manifest [EOL] [EOL] [EOL] class MatchingHash ( FileHash ) : [EOL] def __init__ ( self ) : [EOL] return super ( ) . __init__ ( [string] , [string] ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return True [EOL] [EOL] [EOL] class MismatchedHash ( FileHash ) : [EOL] def __init__ ( self ) : [EOL] return super ( ) . __init__ ( [string] , [string] ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return False [EOL] [EOL] [EOL] class TestLoader ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] profile_data = { [string] : [string] , [string] : { } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } } [EOL] [EOL] root_project = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : normalize ( [string] ) , [string] : [number] , } [EOL] [EOL] self . root_project_config = config_from_parts_or_dicts ( project = root_project , profile = profile_data , cli_vars = [string] ) [EOL] self . parser = mock . MagicMock ( ) [EOL] self . patched_result_builder = mock . patch ( [string] ) [EOL] self . mock_result_builder = self . patched_result_builder . start ( ) [EOL] self . patched_result_builder . return_value = self . _new_results ( ) [EOL] self . loader = manifest . ManifestLoader ( self . root_project_config , { [string] : self . root_project_config } ) [EOL] [EOL] def _new_results ( self ) : [EOL] return ParseResult ( MatchingHash ( ) , MatchingHash ( ) , { } ) [EOL] [EOL] def _mismatched_file ( self , searched , name ) : [EOL] return self . _new_file ( searched , name , False ) [EOL] [EOL] def _matching_file ( self , searched , name ) : [EOL] return self . _new_file ( searched , name , True ) [EOL] [EOL] def _new_file ( self , searched , name , match ) : [EOL] if match : [EOL] checksum = MatchingHash ( ) [EOL] else : [EOL] checksum = MismatchedHash ( ) [EOL] path = FilePath ( searched_path = normalize ( searched ) , relative_path = normalize ( name ) , project_root = normalize ( self . root_project_config . project_root ) , ) [EOL] return SourceFile ( path = path , checksum = checksum ) [EOL] [EOL] def test_model_no_cache ( self ) : [EOL] source_file = self . _matching_file ( [string] , [string] ) [EOL] self . parser . load_file . return_value = source_file [EOL] [EOL] old_results = None [EOL] [EOL] self . loader . parse_with_cache ( source_file . path , self . parser , old_results ) [EOL] [comment] [EOL] [comment] [EOL] self . parser . parse_file . assert_called_once_with ( FileBlock ( file = source_file ) ) [EOL] [EOL] def test_model_cache_hit ( self ) : [EOL] source_file = self . _matching_file ( [string] , [string] ) [EOL] self . parser . load_file . return_value = source_file [EOL] [EOL] source_file_dupe = self . _matching_file ( [string] , [string] ) [EOL] source_file_dupe . nodes . append ( [string] ) [EOL] [EOL] old_results = self . _new_results ( ) [EOL] old_results . files [ source_file_dupe . path . search_key ] = source_file_dupe [EOL] old_results . nodes = { [string] : mock . MagicMock ( ) } [EOL] [EOL] self . loader . parse_with_cache ( source_file . path , self . parser , old_results ) [EOL] [comment] [EOL] self . parser . parse_file . assert_not_called ( ) [EOL] [EOL] def test_model_cache_mismatch_checksum ( self ) : [EOL] source_file = self . _mismatched_file ( [string] , [string] ) [EOL] self . parser . load_file . return_value = source_file [EOL] [EOL] source_file_dupe = self . _mismatched_file ( [string] , [string] ) [EOL] source_file_dupe . nodes . append ( [string] ) [EOL] [EOL] old_results = self . _new_results ( ) [EOL] old_results . files [ source_file_dupe . path . search_key ] = source_file_dupe [EOL] old_results . nodes = { [string] : mock . MagicMock ( ) } [EOL] [EOL] self . loader . parse_with_cache ( source_file . path , self . parser , old_results ) [EOL] [comment] [EOL] [comment] [EOL] self . parser . parse_file . assert_called_once_with ( FileBlock ( file = source_file ) ) [EOL] [EOL] def test_model_cache_missing_file ( self ) : [EOL] source_file = self . _matching_file ( [string] , [string] ) [EOL] self . parser . load_file . return_value = source_file [EOL] [EOL] source_file_different = self . _matching_file ( [string] , [string] ) [EOL] source_file_different . nodes . append ( [string] ) [EOL] [EOL] old_results = self . _new_results ( ) [EOL] old_results . files [ source_file_different . path . search_key ] = source_file_different [EOL] old_results . nodes = { [string] : mock . MagicMock ( ) } [EOL] [EOL] self . loader . parse_with_cache ( source_file . path , self . parser , old_results ) [EOL] [comment] [EOL] [comment] [EOL] self . parser . parse_file . assert_called_once_with ( FileBlock ( file = source_file ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $test.unit.test_parse_manifest.MismatchedHash$ 0 0 0 0 0 0 0 0 $test.unit.test_parse_manifest.MismatchedHash$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $test.unit.test_parse_manifest.MismatchedHash$ 0 $test.unit.test_parse_manifest.MismatchedHash$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Type , Any , Union , Dict [EOL] import test [EOL] import typing [EOL] from . utils import ContractTestCase [EOL] [EOL] from hologram import ValidationError [EOL] [EOL] from dbt . contracts . project import Project [EOL] [EOL] [EOL] class TestProject ( ContractTestCase ) : [EOL] ContractType = Project [EOL] [EOL] def test_minimal ( self ) : [EOL] dct = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] project = self . ContractType ( name = [string] , version = [string] , profile = [string] , project_root = [string] , config_version = [number] , ) [EOL] self . assert_from_dict ( project , dct ) [EOL] [EOL] def test_invalid_name ( self ) : [EOL] dct = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] with self . assertRaises ( ValidationError ) : [EOL] self . ContractType . from_dict ( dct ) [EOL] [EOL] def test_unsupported_version ( self ) : [EOL] dct = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] with self . assertRaises ( ValidationError ) : [EOL] self . ContractType . from_dict ( dct ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[test.unit.test_contracts_project.TestProject]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0
from typing import Any [EOL] import test [EOL] import typing [EOL] import pytest [EOL] [EOL] from . util import ( get_querier , ProjectDefinition , ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_run_sql_nohang ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] with querier_ctx as querier : [EOL] querier . async_wait_for_result ( querier . run_sql ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_snowflake_rpc_run_sql_keepalive_nohang ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , target = [string] , ) [EOL] with querier_ctx as querier : [EOL] querier . async_wait_for_result ( querier . run_sql ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import test [EOL] import builtins [EOL] import typing [EOL] import concurrent [EOL] from concurrent . futures import ThreadPoolExecutor , as_completed [EOL] import pytest [EOL] [EOL] from . util import ( get_querier , ProjectDefinition , ) [EOL] [EOL] [EOL] def _compile_poll_for_result ( querier , id ) : [EOL] sql = f' [string] { id } [string] ' [EOL] resp = querier . compile_sql ( request_id = id , sql = sql , name = f' [string] { id }' ) [EOL] compile_sql_result = querier . async_wait_for_result ( resp ) [EOL] assert compile_sql_result [ [string] ] [ [number] ] [ [string] ] == sql [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_compile_sql_concurrency ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] values = { } [EOL] with ThreadPoolExecutor ( max_workers = [number] ) as tpe : [EOL] for id in range ( [number] ) : [EOL] fut = tpe . submit ( _compile_poll_for_result , querier , id ) [EOL] values [ fut ] = id [EOL] for fut in as_completed ( values ) : [EOL] fut . result ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import test [EOL] import typing [EOL] import pytest [EOL] [EOL] from . util import ( get_querier , ProjectDefinition , ) [EOL] [EOL] macros_data = [string] [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_run_operation ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } , macros = { [string] : macros_data , } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] poll_result = querier . async_wait_for_result ( querier . run_operation ( macro = [string] , args = { } ) ) [EOL] [EOL] assert [string] in poll_result [EOL] assert poll_result [ [string] ] is True [EOL] [EOL] poll_result = querier . async_wait_for_result ( querier . run_operation ( macro = [string] , args = { [string] : [number] } ) ) [EOL] [EOL] assert [string] in poll_result [EOL] assert poll_result [ [string] ] is True [EOL] [EOL] poll_result = querier . async_wait_for_result ( querier . run_operation ( macro = [string] , args = { } ) , state = [string] , ) [EOL] assert [string] in poll_result [EOL] assert poll_result [ [string] ] == [string] [EOL] [EOL] poll_result = querier . async_wait_for_result ( querier . run_operation ( macro = [string] , args = { } ) ) [EOL] assert [string] in poll_result [EOL] assert poll_result [ [string] ] is True [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_run_operation_cli ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } , macros = { [string] : macros_data , } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] poll_result = querier . async_wait_for_result ( querier . cli_args ( cli = [string] ) ) [EOL] [EOL] assert [string] in poll_result [EOL] assert poll_result [ [string] ] is True [EOL] [EOL] bar_cmd = [string] [EOL] poll_result = querier . async_wait_for_result ( querier . cli_args ( cli = bar_cmd ) ) [EOL] [EOL] assert [string] in poll_result [EOL] assert poll_result [ [string] ] is True [EOL] [EOL] poll_result = querier . async_wait_for_result ( querier . cli_args ( cli = [string] ) , state = [string] , ) [EOL] assert [string] in poll_result [EOL] assert poll_result [ [string] ] == [string] [EOL] [EOL] poll_result = querier . async_wait_for_result ( querier . cli_args ( cli = [string] ) ) [EOL] assert [string] in poll_result [EOL] assert poll_result [ [string] ] is True [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import test [EOL] import typing [EOL] import os [EOL] import pytest [EOL] import yaml [EOL] from . util import ( assert_has_threads , get_querier , get_write_manifest , ProjectDefinition , ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_test_threads ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] schema_yaml = { [string] : [number] , [string] : [ { [string] : [string] , [string] : [ { [string] : [string] , [string] : [ [string] , [string] ] , } , ] , } ] , } [EOL] project = ProjectDefinition ( models = { [string] : [string] , [string] : yaml . safe_dump ( schema_yaml ) } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] with querier_ctx as querier : [EOL] [comment] [EOL] querier . async_wait_for_result ( querier . run ( ) ) [EOL] [EOL] results = querier . async_wait_for_result ( querier . test ( threads = [number] ) ) [EOL] assert_has_threads ( results , [number] ) [EOL] [EOL] results = querier . async_wait_for_result ( querier . cli_args ( [string] ) ) [EOL] assert_has_threads ( results , [number] ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_test_state ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] schema_yaml = { [string] : [number] , [string] : [ { [string] : [string] , [string] : [ { [string] : [string] , [string] : [ [string] , [string] ] , } , ] , } ] , } [EOL] project = ProjectDefinition ( models = { [string] : [string] , [string] : yaml . safe_dump ( schema_yaml ) } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] with querier_ctx as querier : [EOL] state_dir = os . path . join ( project_root , [string] ) [EOL] os . makedirs ( state_dir ) [EOL] [EOL] results = querier . async_wait_for_result ( querier . run ( ) ) [EOL] results = querier . async_wait_for_result ( querier . test ( ) ) [EOL] assert len ( results [ [string] ] ) == [number] [EOL] [EOL] get_write_manifest ( querier , os . path . join ( state_dir , [string] ) ) [EOL] [EOL] project . models [ [string] ] = [string] [EOL] project . write_models ( project_root , remove = True ) [EOL] querier . sighup ( ) [EOL] assert querier . wait_for_status ( [string] ) is True [EOL] [EOL] results = querier . async_wait_for_result ( querier . test ( state = [string] , models = [ [string] ] ) ) [EOL] assert len ( results [ [string] ] ) == [number] [EOL] [EOL] get_write_manifest ( querier , os . path . join ( state_dir , [string] ) ) [EOL] [EOL] results = querier . async_wait_for_result ( querier . test ( state = [string] , models = [ [string] ] ) , ) [EOL] assert len ( results [ [string] ] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import test [EOL] import typing [EOL] import pytest [EOL] [EOL] from . util import ( get_querier , ProjectDefinition , ) [EOL] [EOL] [EOL] def deps_with_packages ( packages , bad_packages , project_dir , profiles_dir , schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] , } , packages = { [string] : packages } , ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_dir , profiles_dir = profiles_dir , schema = schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] [comment] [EOL] querier . async_wait_for_result ( querier . run_sql ( [string] ) ) [EOL] [EOL] [comment] [EOL] querier . is_result ( querier . status ( ) ) [EOL] [EOL] [comment] [EOL] querier . async_wait_for_result ( querier . deps ( ) ) [EOL] [EOL] [comment] [EOL] tok1 = querier . is_async_result ( querier . run ( ) ) [EOL] tok2 = querier . is_async_result ( querier . run_sql ( [string] ) ) [EOL] [EOL] querier . is_result ( querier . async_wait ( tok2 ) ) [EOL] querier . is_result ( querier . async_wait ( tok1 ) ) [EOL] [EOL] [comment] [EOL] project . packages [ [string] ] = bad_packages [EOL] project . write_packages ( project_dir , remove = True ) [EOL] [EOL] [comment] [EOL] tok1 = querier . is_async_result ( querier . run ( ) ) [EOL] tok2 = querier . is_async_result ( querier . run_sql ( [string] ) ) [EOL] [EOL] querier . is_result ( querier . async_wait ( tok2 ) ) [EOL] querier . is_result ( querier . async_wait ( tok1 ) ) [EOL] [EOL] [comment] [EOL] querier . async_wait_for_error ( querier . deps ( ) ) [EOL] [comment] [EOL] result = querier . is_result ( querier . ps ( active = True , completed = False ) ) [EOL] assert result [ [string] ] == [ ] [EOL] [EOL] [comment] [EOL] project . packages [ [string] ] = packages [EOL] project . write_packages ( project_dir , remove = True ) [EOL] [comment] [EOL] querier . is_error ( querier . run ( ) ) [EOL] [EOL] [comment] [EOL] querier . async_wait_for_result ( querier . deps ( ) ) [EOL] querier . is_result ( querier . status ( ) ) [EOL] [EOL] tok1 = querier . is_async_result ( querier . run ( ) ) [EOL] tok2 = querier . is_async_result ( querier . run_sql ( [string] ) ) [EOL] [EOL] querier . is_result ( querier . async_wait ( tok2 ) ) [EOL] querier . is_result ( querier . async_wait ( tok1 ) ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_deps_packages ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] packages = [ { [string] : [string] , [string] : [string] , } ] [EOL] bad_packages = [ { [string] : [string] , [string] : [string] , } ] [EOL] deps_with_packages ( packages , bad_packages , project_root , profiles_root , unique_schema ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_deps_git ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] packages = [ { [string] : [string] , [string] : [string] } ] [EOL] [comment] [EOL] bad_packages = [ { [string] : [string] , [string] : [string] } ] [EOL] deps_with_packages ( packages , bad_packages , project_root , profiles_root , unique_schema ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import test [EOL] import typing [EOL] import datetime [EOL] import pytest [EOL] from datetime import datetime , timedelta [EOL] from . util import ( get_querier , ProjectDefinition , ) [EOL] [EOL] source_freshness_schema_yml = [string] [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_source_freshness ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] start_time = datetime . utcnow ( ) [EOL] warn_me = start_time - timedelta ( hours = [number] ) [EOL] error_me = start_time - timedelta ( days = [number] ) [EOL] [comment] [EOL] project = ProjectDefinition ( project_data = { [string] : { [string] : { [string] : False } } } , seeds = { [string] : [string] . format ( error_me . strftime ( [string] ) ) , [string] : [string] . format ( error_me . strftime ( [string] ) ) } , models = { [string] : source_freshness_schema_yml . format ( schema = unique_schema ) , } , ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] seeds = querier . async_wait_for_result ( querier . seed ( ) ) [EOL] assert len ( seeds [ [string] ] ) == [number] [EOL] [comment] [EOL] error_results = querier . async_wait_for_result ( querier . snapshot_freshness ( ) , state = [string] ) [EOL] assert len ( error_results [ [string] ] ) == [number] [EOL] for result in error_results [ [string] ] : [EOL] assert result [ [string] ] == [string] [EOL] error_results = querier . async_wait_for_result ( querier . cli_args ( [string] ) , state = [string] ) [EOL] assert len ( error_results [ [string] ] ) == [number] [EOL] for result in error_results [ [string] ] : [EOL] assert result [ [string] ] == [string] [EOL] [EOL] project . seeds [ [string] ] += [string] . format ( warn_me . strftime ( [string] ) ) [EOL] project . write_seeds ( project_root , remove = True ) [EOL] querier . async_wait_for_result ( querier . seed ( ) ) [EOL] [comment] [EOL] warn_results = querier . async_wait_for_result ( querier . snapshot_freshness ( select = [string] ) ) [EOL] assert len ( warn_results [ [string] ] ) == [number] [EOL] assert warn_results [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] warn_results = querier . async_wait_for_result ( querier . cli_args ( [string] ) ) [EOL] assert len ( warn_results [ [string] ] ) == [number] [EOL] assert warn_results [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] project . seeds [ [string] ] += [string] . format ( start_time . strftime ( [string] ) ) [EOL] project . write_seeds ( project_root , remove = True ) [EOL] querier . async_wait_for_result ( querier . seed ( ) ) [EOL] [comment] [EOL] pass_results = querier . async_wait_for_result ( querier . snapshot_freshness ( select = [ [string] ] ) ) [EOL] assert len ( pass_results [ [string] ] ) == [number] [EOL] assert pass_results [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] pass_results = querier . async_wait_for_result ( querier . cli_args ( [string] ) ) [EOL] assert len ( pass_results [ [string] ] ) == [number] [EOL] assert pass_results [ [string] ] [ [number] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Iterator [EOL] import test [EOL] import builtins [EOL] import typing [EOL] import pytest [EOL] import time [EOL] from . util import ( get_querier , ProjectDefinition , ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_basics ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] querier . async_wait_for_result ( querier . run_sql ( [string] ) ) [EOL] [EOL] querier . async_wait_for_result ( querier . run ( ) ) [EOL] [EOL] querier . async_wait_for_result ( querier . run_sql ( [string] ) ) [EOL] [EOL] querier . async_wait_for_error ( querier . run_sql ( [string] ) ) [EOL] [EOL] [EOL] bad_schema_yml = [string] [EOL] [EOL] fixed_schema_yml = [string] [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_status_error ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] , [string] : bad_schema_yml , } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , criteria = [string] , ) [EOL] with querier_ctx as querier : [EOL] [EOL] [comment] [EOL] result = querier . is_result ( querier . status ( ) ) [EOL] assert [string] in result [EOL] assert [string] in result [ [string] ] [EOL] assert [string] in result [ [string] ] [ [string] ] [EOL] assert [string] in result [EOL] assert result [ [string] ] == [string] [EOL] assert [string] in result [EOL] logs = result [ [string] ] [EOL] assert len ( logs ) > [number] [EOL] for key in ( [string] , [string] , [string] , [string] ) : [EOL] assert key in logs [ [number] ] [EOL] assert [string] in result [EOL] assert querier . server . pid == result [ [string] ] [EOL] [EOL] error = querier . is_error ( querier . compile_sql ( [string] ) ) [EOL] assert [string] in error [EOL] assert error [ [string] ] == [number] [EOL] assert [string] in error [EOL] assert error [ [string] ] == [string] [EOL] assert [string] in error [EOL] assert [string] in error [ [string] ] [EOL] assert [string] in error [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] querier . async_wait_for_error ( querier . deps ( ) ) [EOL] [EOL] [comment] [EOL] result = querier . is_result ( querier . status ( ) ) [EOL] assert [string] in result [EOL] assert [string] in result [ [string] ] [EOL] assert [string] in result [ [string] ] [ [string] ] [EOL] [EOL] error = querier . is_error ( querier . compile_sql ( [string] ) ) [EOL] assert [string] in error [EOL] assert error [ [string] ] == [number] [EOL] [EOL] project . models [ [string] ] = fixed_schema_yml [EOL] project . write_models ( project_root , remove = True ) [EOL] [EOL] [comment] [EOL] querier . async_wait_for_result ( querier . deps ( ) ) [EOL] [EOL] result = querier . is_result ( querier . status ( ) ) [EOL] assert result . get ( [string] ) is None [EOL] assert [string] in result [EOL] assert result [ [string] ] == [string] [EOL] [EOL] querier . is_result ( querier . compile_sql ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_gc_change_interval ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] [EOL] for _ in range ( [number] ) : [EOL] querier . async_wait_for_result ( querier . run ( ) ) [EOL] [EOL] result = querier . is_result ( querier . ps ( True , True ) ) [EOL] assert len ( result [ [string] ] ) == [number] [EOL] [EOL] result = querier . is_result ( querier . gc ( settings = dict ( maxsize = [number] , reapsize = [number] , auto_reap_age = [number] ) ) ) [EOL] [EOL] for k in ( [string] , [string] , [string] ) : [EOL] assert k in result [EOL] assert len ( result [ k ] ) == [number] [EOL] [EOL] time . sleep ( [number] ) [EOL] [EOL] result = querier . is_result ( querier . ps ( True , True ) ) [EOL] assert len ( result [ [string] ] ) == [number] [EOL] [EOL] result = querier . is_result ( querier . gc ( settings = dict ( maxsize = [number] , reapsize = [number] , auto_reap_age = [number] ) ) ) [EOL] for k in ( [string] , [string] , [string] ) : [EOL] assert k in result [EOL] assert len ( result [ k ] ) == [number] [EOL] [EOL] time . sleep ( [number] ) [EOL] [EOL] for _ in range ( [number] ) : [EOL] querier . async_wait_for_result ( querier . run ( ) ) [EOL] [EOL] time . sleep ( [number] ) [EOL] result = querier . is_result ( querier . ps ( True , True ) ) [EOL] assert len ( result [ [string] ] ) <= [number] [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_ps_poll_output_match ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] [EOL] poll_result = querier . async_wait_for_result ( querier . run ( ) ) [EOL] [EOL] result = querier . is_result ( querier . ps ( active = True , completed = True ) ) [EOL] assert [string] in result [EOL] rows = result [ [string] ] [EOL] assert len ( rows ) == [number] [EOL] ps_result = rows [ [number] ] [EOL] [EOL] for key in ( [string] , [string] , [string] , [string] ) : [EOL] assert ps_result [ key ] == poll_result [ key ] [EOL] [EOL] [EOL] sleeper_sql = [string] [EOL] [EOL] logger_sql = [string] [EOL] [EOL] [EOL] def find_log_ordering ( logs , * messages ) : [EOL] log_iter = iter ( logs ) [EOL] found = [number] [EOL] [EOL] while found < len ( messages ) : [EOL] try : [EOL] log = next ( log_iter ) [EOL] except StopIteration : [EOL] return False [EOL] if messages [ found ] in log [ [string] ] : [EOL] found += [number] [EOL] return True [EOL] [EOL] [EOL] def poll_logs ( querier , token ) : [EOL] has_log = querier . is_result ( querier . poll ( token ) ) [EOL] assert [string] in has_log [EOL] return has_log [ [string] ] [EOL] [EOL] [EOL] def wait_for_log_ordering ( querier , token , attempts , * messages ) : [EOL] for _ in range ( attempts ) : [EOL] time . sleep ( [number] ) [EOL] logs = poll_logs ( querier , token ) [EOL] if find_log_ordering ( logs , * messages ) : [EOL] return len ( logs ) [EOL] [EOL] msg = [string] . format ( messages , [ log [ [string] ] for log in logs ] , ) [EOL] assert False , msg [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_get_status ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } , ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] [comment] [EOL] token = querier . is_async_result ( querier . run_sql ( sleeper_sql ) ) [EOL] [EOL] no_log = querier . is_result ( querier . poll ( token , logs = False ) ) [EOL] assert [string] in no_log [EOL] assert len ( no_log [ [string] ] ) == [number] [EOL] [EOL] num_logs = wait_for_log_ordering ( querier , token , [number] ) [EOL] [EOL] trunc_log = querier . is_result ( querier . poll ( token , logs_start = num_logs ) ) [EOL] assert [string] in trunc_log [EOL] assert len ( trunc_log [ [string] ] ) == [number] [EOL] [EOL] querier . kill ( token ) [EOL] [EOL] [comment] [EOL] token = querier . is_async_result ( querier . run_sql ( logger_sql ) ) [EOL] result = querier . is_result ( querier . async_wait ( token ) ) [EOL] assert [string] in result [EOL] num_logs = len ( result [ [string] ] ) [EOL] assert num_logs > [number] [EOL] [EOL] result = querier . is_result ( querier . poll ( token , logs_start = num_logs ) ) [EOL] assert [string] in result [EOL] assert len ( result [ [string] ] ) == [number] [EOL] [EOL] result = querier . is_result ( querier . poll ( token , logs = False ) ) [EOL] assert [string] in result [EOL] assert len ( result [ [string] ] ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_missing_tag_sighup ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] , } , ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] with querier_ctx as querier : [EOL] [comment] [EOL] assert querier . wait_for_status ( [string] ) is True [EOL] [EOL] [comment] [EOL] project . models [ [string] ] = [string] [EOL] project . write_models ( project_root , remove = True ) [EOL] [EOL] querier . sighup ( ) [EOL] [EOL] assert querier . wait_for_status ( [string] ) is True [EOL] result = querier . is_result ( querier . status ( ) ) [EOL] assert [string] in result [EOL] assert [string] in result [ [string] ] [EOL] assert [string] in result [ [string] ] [ [string] ] [EOL] [EOL] project . models [ [string] ] = [string] [EOL] project . write_models ( project_root , remove = True ) [EOL] [EOL] querier . sighup ( ) [EOL] [EOL] assert querier . wait_for_status ( [string] ) is True [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_get_manifest ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] , } , ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] [EOL] with querier_ctx as querier : [EOL] results = querier . async_wait_for_result ( querier . cli_args ( [string] ) ) [EOL] assert len ( results [ [string] ] ) == [number] [EOL] assert results [ [string] ] [ [number] ] [ [string] ] [ [string] ] == [string] [EOL] result = querier . async_wait_for_result ( querier . get_manifest ( ) ) [EOL] assert [string] in result [EOL] manifest = result [ [string] ] [EOL] assert manifest [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] assert [string] in result [EOL] manifest = result [ [string] ] [EOL] assert manifest [ [string] ] [ [string] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import test [EOL] import typing [EOL] import os [EOL] import pytest [EOL] from . util import ( assert_has_threads , get_querier , get_write_manifest , ProjectDefinition , ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_compile_threads ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] with querier_ctx as querier : [EOL] results = querier . async_wait_for_result ( querier . compile ( threads = [number] ) ) [EOL] assert_has_threads ( results , [number] ) [EOL] [EOL] results = querier . async_wait_for_result ( querier . cli_args ( [string] ) ) [EOL] assert_has_threads ( results , [number] ) [EOL] [EOL] [EOL] @ pytest . mark . supported ( [string] ) def test_rpc_compile_state ( project_root , profiles_root , dbt_profile , unique_schema ) : [EOL] project = ProjectDefinition ( models = { [string] : [string] } ) [EOL] querier_ctx = get_querier ( project_def = project , project_dir = project_root , profiles_dir = profiles_root , schema = unique_schema , test_kwargs = { } , ) [EOL] with querier_ctx as querier : [EOL] state_dir = os . path . join ( project_root , [string] ) [EOL] os . makedirs ( state_dir ) [EOL] [EOL] results = querier . async_wait_for_result ( querier . compile ( ) ) [EOL] assert len ( results [ [string] ] ) == [number] [EOL] [EOL] get_write_manifest ( querier , os . path . join ( state_dir , [string] ) ) [EOL] [EOL] project . models [ [string] ] = [string] [EOL] project . write_models ( project_root , remove = True ) [EOL] [EOL] querier . sighup ( ) [EOL] assert querier . wait_for_status ( [string] ) is True [EOL] [EOL] results = querier . async_wait_for_result ( querier . compile ( state = [string] , models = [ [string] ] ) ) [EOL] assert len ( results [ [string] ] ) == [number] [EOL] [EOL] get_write_manifest ( querier , os . path . join ( state_dir , [string] ) ) [EOL] [EOL] results = querier . async_wait_for_result ( querier . compile ( state = [string] , models = [ [string] ] ) , ) [EOL] assert len ( results [ [string] ] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Set [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import pytest [EOL] import random [EOL] import time [EOL] from typing import Dict , Any , Set [EOL] [EOL] import yaml [EOL] [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] parser . addoption ( [string] , default = [string] , help = [string] , ) [EOL] [EOL] [EOL] def _get_item_profiles ( item ) : [EOL] supported = set ( ) [EOL] for mark in item . iter_markers ( name = [string] ) : [EOL] supported . update ( mark . args ) [EOL] return supported [EOL] [EOL] [EOL] def pytest_collection_modifyitems ( config , items ) : [EOL] selected_profile = config . getoption ( [string] ) [EOL] [EOL] to_remove = [ ] [EOL] [EOL] for item in items : [EOL] item_profiles = _get_item_profiles ( item ) [EOL] if selected_profile not in item_profiles and [string] not in item_profiles : [EOL] to_remove . append ( item ) [EOL] [EOL] for item in to_remove : [EOL] items . remove ( item ) [EOL] [EOL] [EOL] def pytest_configure ( config ) : [EOL] [comment] [EOL] [comment] [EOL] helptxt = [string] [EOL] config . addinivalue_line ( [string] , f' [string] { helptxt }' ) [EOL] [EOL] [EOL] @ pytest . fixture def unique_schema ( ) : [EOL] return [string] . format ( int ( time . time ( ) ) , random . randint ( [number] , [number] ) ) [EOL] [EOL] [EOL] @ pytest . fixture def profiles_root ( tmpdir ) : [EOL] return tmpdir . mkdir ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def project_root ( tmpdir ) : [EOL] return tmpdir . mkdir ( [string] ) [EOL] [EOL] [EOL] def postgres_profile_data ( unique_schema ) : [EOL] return { [string] : { [string] : False } , [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : unique_schema , } , [string] : { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : unique_schema + [string] , } } , [string] : [string] } } [EOL] [EOL] [EOL] def snowflake_profile_data ( unique_schema ) : [EOL] return { [string] : { [string] : False } , [string] : { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : unique_schema , [string] : os . getenv ( [string] ) , } , [string] : { [string] : [string] , [string] : [number] , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : unique_schema , [string] : os . getenv ( [string] ) , [string] : True , } , } , [string] : [string] , } , } [EOL] [EOL] [EOL] @ pytest . fixture def dbt_profile_data ( unique_schema , pytestconfig ) : [EOL] profile_name = pytestconfig . getoption ( [string] ) [EOL] if profile_name == [string] : [EOL] return postgres_profile_data ( unique_schema ) [EOL] elif profile_name == [string] : [EOL] return snowflake_profile_data ( unique_schema ) [EOL] else : [EOL] print ( f' [string] { profile_name } [string] ' ) [EOL] return { } [EOL] [EOL] [EOL] @ pytest . fixture def dbt_profile ( profiles_root , dbt_profile_data ) : [EOL] path = os . path . join ( profiles_root , [string] ) [EOL] with open ( path , [string] ) as fp : [EOL] fp . write ( yaml . safe_dump ( dbt_profile_data ) ) [EOL] return dbt_profile_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import scripts [EOL] import schema [EOL] from dataclasses import dataclass [EOL] from typing import Dict , Any [EOL] import json [EOL] [EOL] from hologram import JsonSchemaMixin [EOL] from dbt . contracts . graph . manifest import WritableManifest [EOL] from dbt . contracts . results import ( CatalogResults , ExecutionResult , FreshnessExecutionResult ) [EOL] [EOL] [EOL] @ dataclass class Schemas ( JsonSchemaMixin ) : [EOL] manifest = ... [EOL] catalog = ... [EOL] run_results = ... [EOL] freshness_results = ... [EOL] [EOL] [EOL] def main ( ) : [EOL] schemas = Schemas ( manifest = WritableManifest . json_schema ( ) , catalog = CatalogResults . json_schema ( ) , run_results = ExecutionResult . json_schema ( ) , freshness_results = FreshnessExecutionResult . json_schema ( ) , ) [EOL] print ( json . dumps ( schemas . to_dict ( ) ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import token [EOL] import requests [EOL] import werkzeug [EOL] import typing [EOL] import scripts [EOL] import argparse [EOL] import argparse [EOL] import json [EOL] import secrets [EOL] import textwrap [EOL] from base64 import b64encode [EOL] [EOL] import requests [EOL] from werkzeug import redirect [EOL] from werkzeug . middleware . dispatcher import DispatcherMiddleware [EOL] from werkzeug . wrappers import Request , Response [EOL] from werkzeug . serving import run_simple [EOL] from urllib . parse import urlencode [EOL] [EOL] [EOL] def _make_rfp_claim_value ( ) : [EOL] [comment] [EOL] [comment] [EOL] return secrets . token_urlsafe ( [number] ) [EOL] [EOL] [EOL] def _make_response ( client_id , client_secret , refresh_token ) : [EOL] return Response ( textwrap . dedent ( f''' [string] { refresh_token } [string] { client_id } [string] { client_secret } [string] ''' ) ) [EOL] [EOL] [EOL] class TokenManager : [EOL] def __init__ ( self , account_name , client_id , client_secret ) : [EOL] self . account_name = account_name [EOL] self . client_id = client_id [EOL] self . client_secret = client_secret [EOL] self . token = None [EOL] self . rfp_claim = _make_rfp_claim_value ( ) [EOL] self . port = [number] [EOL] [EOL] @ property def account_url ( self ) : [EOL] return f' [string] { self . account_name } [string] ' [EOL] [EOL] @ property def auth_url ( self ) : [EOL] return f'{ self . account_url } [string] ' [EOL] [EOL] @ property def token_url ( self ) : [EOL] return f'{ self . account_url } [string] ' [EOL] [EOL] @ property def redirect_uri ( self ) : [EOL] return f' [string] { self . port }' [EOL] [EOL] @ property def headers ( self ) : [EOL] auth = f'{ self . client_id } [string] { self . client_secret }' . encode ( [string] ) [EOL] encoded_auth = b64encode ( auth ) . decode ( [string] ) [EOL] return { [string] : f' [string] { encoded_auth }' , [string] : [string] } [EOL] [EOL] def _code_to_token ( self , code ) : [EOL] data = { [string] : [string] , [string] : code , [string] : self . redirect_uri , } [EOL] [comment] [EOL] resp = requests . post ( url = self . token_url , headers = self . headers , data = data , ) [EOL] try : [EOL] refresh_token = resp . json ( ) [ [string] ] [EOL] except KeyError : [EOL] print ( resp . json ( ) ) [EOL] raise [EOL] return refresh_token [EOL] [EOL] @ Request . application def auth ( self , request ) : [EOL] code = request . args . get ( [string] ) [EOL] if code : [EOL] [comment] [EOL] state_received = request . args . get ( [string] ) [EOL] if state_received != self . rfp_claim : [EOL] return Response ( [string] , status = [number] ) [EOL] refresh_token = self . _code_to_token ( code ) [EOL] return _make_response ( self . client_id , self . client_secret , refresh_token , ) [EOL] else : [EOL] return redirect ( [string] ) [EOL] [EOL] @ Request . application def login ( self , request ) : [EOL] [comment] [EOL] query = { [string] : [string] , [string] : self . client_id , [string] : self . redirect_uri , [string] : self . rfp_claim , } [EOL] query = urlencode ( query ) [EOL] return redirect ( f'{ self . auth_url } [string] { query }' ) [EOL] [EOL] [EOL] def parse_args ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] [EOL] return parser . parse_args ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] args = parse_args ( ) [EOL] data = json . loads ( args . json_blob ) [EOL] client_id = data [ [string] ] [EOL] client_secret = data [ [string] ] [EOL] token_manager = TokenManager ( account_name = args . account_name , client_id = client_id , client_secret = client_secret , ) [EOL] app = DispatcherMiddleware ( token_manager . auth , { [string] : token_manager . login , } ) [EOL] [EOL] run_simple ( [string] , token_manager . port , app ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Any , Iterable , List [EOL] import contexts [EOL] import inspect [EOL] import typing [EOL] import scripts [EOL] [number][comment] [EOL] [EOL] import inspect [EOL] import json [EOL] from dataclasses import dataclass [EOL] from typing import List , Optional , Iterable , Union , Dict , Any [EOL] from hologram import JsonSchemaMixin [EOL] [EOL] [EOL] from dbt . context . base import BaseContext [EOL] from dbt . context . target import TargetContext [EOL] from dbt . context . providers import ModelContext , MacroContext [EOL] [EOL] [EOL] CONTEXTS_MAP = { [string] : BaseContext , [string] : TargetContext , [string] : ModelContext , [string] : MacroContext , } [EOL] [EOL] [EOL] @ dataclass class ContextValue ( JsonSchemaMixin ) : [EOL] name = ... [EOL] value = ... [comment] [EOL] doc = ... [EOL] [EOL] [EOL] @ dataclass class MethodArgument ( JsonSchemaMixin ) : [EOL] name = ... [EOL] value = ... [comment] [EOL] [EOL] [EOL] @ dataclass class ContextMethod ( JsonSchemaMixin ) : [EOL] name = ... [EOL] args = ... [EOL] result = ... [comment] [EOL] doc = ... [EOL] [EOL] [EOL] @ dataclass class Unknown ( JsonSchemaMixin ) : [EOL] name = ... [EOL] value = ... [EOL] doc = ... [EOL] [EOL] [EOL] ContextMember = Union [ ContextValue , ContextMethod , Unknown ] [EOL] [EOL] [EOL] def _get_args ( func ) : [EOL] found_first = False [EOL] for argname , arg in func . parameters . items ( ) : [EOL] if found_first is False and argname in { [string] , [string] } : [EOL] continue [EOL] if found_first is False : [EOL] found_first = True [EOL] [EOL] yield MethodArgument ( name = argname , value = inspect . formatannotation ( arg . annotation ) , ) [EOL] [EOL] [EOL] def collect ( cls ) : [EOL] values = [ ] [EOL] for name , v in cls . _context_members_ . items ( ) : [EOL] attrname = cls . _context_attrs_ [ name ] [EOL] attrdef = getattr ( cls , attrname ) [EOL] doc = getattr ( attrdef , [string] ) [EOL] if inspect . isfunction ( attrdef ) : [EOL] sig = inspect . signature ( attrdef ) [EOL] result = inspect . formatannotation ( sig . return_annotation ) [EOL] sig_good_part = ContextMethod ( name = name , args = list ( _get_args ( sig ) ) , result = result , doc = doc , ) [EOL] elif isinstance ( attrdef , property ) : [EOL] sig = inspect . signature ( attrdef . fget ) [EOL] sig_txt = inspect . formatannotation ( sig . return_annotation ) [EOL] sig_good_part = ContextValue ( name = name , value = sig_txt , doc = doc ) [EOL] else : [EOL] sig_good_part = Unknown ( name = name , value = repr ( attrdef ) , doc = doc ) [EOL] values . append ( sig_good_part ) [EOL] [EOL] return values [EOL] [EOL] [EOL] @ dataclass class ContextCatalog ( JsonSchemaMixin ) : [EOL] base = ... [EOL] target = ... [EOL] model = ... [EOL] macro = ... [EOL] schema = ... [EOL] [EOL] [EOL] def main ( ) : [EOL] catalog = ContextCatalog ( base = collect ( BaseContext ) , target = collect ( TargetContext ) , model = collect ( ModelContext ) , macro = collect ( MacroContext ) , schema = ContextCatalog . json_schema ( ) , ) [EOL] print ( json . dumps ( catalog . to_dict ( ) ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[MethodArgument]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[MethodArgument]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ContextMember]$ 0 0 0 $typing.List[ContextMember]$ 0 0 0 $typing.List[ContextMember]$ 0 0 0 $typing.List[ContextMember]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Pattern , Set , Union , Optional , Dict , Tuple , Literal , Iterator [EOL] import typing_extensions [EOL] import dbt [EOL] import builtins [EOL] import venv [EOL] import typing [EOL] import scripts [EOL] import pathlib [EOL] import argparse [EOL] import subprocess [EOL] import zipfile [EOL] import json [EOL] import os [EOL] import re [EOL] import shutil [EOL] import subprocess [EOL] import sys [EOL] import tempfile [EOL] import textwrap [EOL] import time [EOL] import venv [comment] [EOL] import zipfile [EOL] [EOL] from typing import Dict [EOL] [EOL] from argparse import ArgumentParser [EOL] from dataclasses import dataclass [EOL] from pathlib import Path [EOL] from urllib . request import urlopen [EOL] [EOL] from typing import Optional , Iterator , Tuple , List , Iterable [EOL] [EOL] [EOL] HOMEBREW_PYTHON = ( [number] , [number] ) [EOL] [EOL] [EOL] [comment] [EOL] VERSION_PATTERN = re . compile ( [string] [string] ) [EOL] [EOL] [EOL] class Version : [EOL] def __init__ ( self , raw ) : [EOL] self . raw = raw [EOL] match = VERSION_PATTERN . match ( self . raw ) [EOL] assert match is not None , f' [string] { self . raw }' [EOL] groups = match . groupdict ( ) [EOL] [EOL] self . major = int ( groups [ [string] ] ) [EOL] self . minor = int ( groups [ [string] ] ) [EOL] self . patch = int ( groups [ [string] ] ) [EOL] self . prerelease = None [EOL] self . num = None [EOL] [EOL] if groups [ [string] ] is not None : [EOL] self . prerelease = groups [ [string] ] [EOL] self . num = int ( groups [ [string] ] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . raw [EOL] [EOL] def homebrew_class_name ( self ) : [EOL] name = f' [string] { self . major }{ self . minor }{ self . patch }' [EOL] if self . prerelease is not None and self . num is not None : [EOL] name = f'{ name }{ self . prerelease . title ( ) }{ self . num }' [EOL] return name [EOL] [EOL] def homebrew_filename ( self ) : [EOL] version_str = f'{ self . major } [string] { self . minor } [string] { self . patch }' [EOL] if self . prerelease is not None and self . num is not None : [EOL] version_str = f'{ version_str } [string] { self . prerelease }{ self . num }' [EOL] return f' [string] { version_str } [string] ' [EOL] [EOL] [EOL] @ dataclass class Arguments : [EOL] version = ... [EOL] part = ... [EOL] path = ... [EOL] homebrew_path = ... [EOL] homebrew_set_default = ... [EOL] set_version = ... [EOL] build_pypi = ... [EOL] upload_pypi = ... [EOL] test_upload = ... [EOL] build_homebrew = ... [EOL] build_docker = ... [EOL] upload_docker = ... [EOL] write_requirements = ... [EOL] write_dockerfile = ... [EOL] [EOL] @ classmethod def parse ( cls ) : [EOL] parser = ArgumentParser ( prog = [string] ) [EOL] parser . add_argument ( [string] , type = Version , help = [string] , ) [EOL] parser . add_argument ( [string] , type = str , help = [string] , ) [EOL] parser . add_argument ( [string] , type = Path , help = [string] , default = Path . cwd ( ) , ) [EOL] parser . add_argument ( [string] , type = Path , help = [string] , default = ( Path . cwd ( ) / [string] ) , ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] , ) [EOL] [EOL] uploading = parser . add_mutually_exclusive_group ( ) [EOL] [EOL] uploading . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] [EOL] uploading . add_argument ( [string] , dest = [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] parsed = parser . parse_args ( ) [EOL] [EOL] upload_pypi = parsed . build_pypi [EOL] if parsed . force_upload_pypi : [EOL] upload_pypi = True [EOL] elif parsed . no_upload_pypi : [EOL] upload_pypi = False [EOL] [EOL] return cls ( version = parsed . version , part = parsed . part , path = parsed . path , homebrew_path = parsed . homebrew_path , homebrew_set_default = parsed . homebrew_set_default , set_version = parsed . set_version , build_pypi = parsed . build_pypi , upload_pypi = upload_pypi , test_upload = parsed . test_upload , build_homebrew = parsed . build_homebrew , build_docker = parsed . build_docker , upload_docker = parsed . upload_docker , write_requirements = parsed . write_requirements , write_dockerfile = parsed . write_dockerfile , ) [EOL] [EOL] [EOL] def collect_output ( cmd , cwd = None , stderr = subprocess . PIPE ) : [EOL] try : [EOL] result = subprocess . run ( cmd , cwd = cwd , check = True , stdout = subprocess . PIPE , stderr = stderr ) [EOL] except subprocess . CalledProcessError as exc : [EOL] print ( f' [string] { exc . cmd } [string] ' ) [EOL] if exc . output : [EOL] print ( exc . output . decode ( [string] ) ) [EOL] if exc . stderr : [EOL] print ( exc . stderr . decode ( [string] ) , file = sys . stderr ) [EOL] raise [EOL] return result . stdout . decode ( [string] ) [EOL] [EOL] [EOL] def run_command ( cmd , cwd = None ) : [EOL] result = collect_output ( cmd , stderr = subprocess . STDOUT , cwd = cwd ) [EOL] print ( result ) [EOL] [EOL] [EOL] def set_version ( path , version , part ) : [EOL] [comment] [EOL] cmd = [ [string] , [string] , [string] , [string] , str ( version ) , part ] [EOL] print ( f' [string] { version }' ) [EOL] run_command ( cmd , cwd = path ) [EOL] print ( f' [string] { version }' ) [EOL] [EOL] [EOL] class PypiBuilder : [EOL] _SUBPACKAGES = ( [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , dbt_path ) : [EOL] self . dbt_path = dbt_path [EOL] [EOL] @ staticmethod def _dist_for ( path , make = False ) : [EOL] dist_path = path / [string] [EOL] if dist_path . exists ( ) : [EOL] shutil . rmtree ( dist_path ) [EOL] if make : [EOL] os . makedirs ( dist_path ) [EOL] build_path = path / [string] [EOL] if build_path . exists ( ) : [EOL] shutil . rmtree ( build_path ) [EOL] return dist_path [EOL] [EOL] @ staticmethod def _build_pypi_package ( path ) : [EOL] print ( f' [string] { path }' ) [EOL] cmd = [ [string] , [string] , [string] , [string] ] [EOL] run_command ( cmd , cwd = path ) [EOL] print ( f' [string] { path }' ) [EOL] [EOL] @ staticmethod def _all_packages_in ( path ) : [EOL] path = path / [string] [EOL] for pattern in ( [string] , [string] ) : [EOL] yield from path . glob ( pattern ) [EOL] [EOL] def _build_subpackage ( self , name ) : [EOL] subpath = self . dbt_path / name [EOL] self . _dist_for ( subpath ) [EOL] self . _build_pypi_package ( subpath ) [EOL] return self . _all_packages_in ( subpath ) [EOL] [EOL] def build ( self ) : [EOL] print ( [string] ) [EOL] dist_path = self . _dist_for ( self . dbt_path ) [EOL] sub_pkgs = [ ] [EOL] for path in self . _SUBPACKAGES : [EOL] sub_pkgs . extend ( self . _build_subpackage ( path ) ) [EOL] [EOL] [comment] [EOL] self . _build_pypi_package ( self . dbt_path ) [EOL] [comment] [EOL] for package in sub_pkgs : [EOL] shutil . copy ( str ( package ) , dist_path ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] def upload ( self , * , test = True ) : [EOL] cmd = [ [string] , [string] ] [EOL] cmd . extend ( str ( p ) for p in self . _all_packages_in ( self . dbt_path ) ) [EOL] run_command ( cmd ) [EOL] cmd = [ [string] , [string] ] [EOL] if test : [EOL] cmd . extend ( [ [string] , [string] ] ) [EOL] cmd . extend ( str ( p ) for p in self . _all_packages_in ( self . dbt_path ) ) [EOL] print ( [string] . format ( [string] . join ( cmd ) ) ) [EOL] run_command ( cmd ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] class PipInstaller ( venv . EnvBuilder ) : [EOL] def __init__ ( self , packages ) : [EOL] super ( ) . __init__ ( with_pip = True ) [EOL] self . packages = packages [EOL] [EOL] def post_setup ( self , context ) : [EOL] [comment] [EOL] [comment] [EOL] tmp = tempfile . mkdtemp ( ) [EOL] cmd = [ context . env_exe , [string] , [string] , [string] , [string] ] [EOL] cmd . extend ( self . packages ) [EOL] print ( f' [string] { self . packages }' ) [EOL] try : [EOL] run_command ( cmd , cwd = tmp ) [EOL] finally : [EOL] os . rmdir ( tmp ) [EOL] print ( f' [string] { self . packages }' ) [EOL] [EOL] def create ( self , venv_path ) : [EOL] os . makedirs ( venv_path . parent , exist_ok = True ) [EOL] if venv_path . exists ( ) : [EOL] shutil . rmtree ( venv_path ) [EOL] return super ( ) . create ( venv_path ) [EOL] [EOL] [EOL] def _require_wheels ( dbt_path ) : [EOL] dist_path = dbt_path / [string] [EOL] wheels = list ( dist_path . glob ( [string] ) ) [EOL] if not wheels : [EOL] raise ValueError ( f' [string] { dist_path } [string] ' ) [EOL] return wheels [EOL] [EOL] [EOL] class DistFolderEnv ( PipInstaller ) : [EOL] def __init__ ( self , dbt_path ) : [EOL] self . wheels = _require_wheels ( dbt_path ) [EOL] super ( ) . __init__ ( packages = self . wheels ) [EOL] [EOL] [EOL] class HomebrewVirtualenv ( PipInstaller ) : [EOL] def __init__ ( self , dbt_version ) : [EOL] super ( ) . __init__ ( [ f' [string] { dbt_version }' ] ) [EOL] [EOL] [EOL] @ dataclass class HomebrewDependency : [EOL] name = ... [EOL] url = ... [EOL] sha256 = ... [EOL] version = ... [EOL] [EOL] def render ( self , indent = [number] ) : [EOL] result = textwrap . dedent ( f''' [string] { self . name } [string] { self . name } [string] { self . version } [string] { self . url } [string] { self . sha256 } [string] ''' ) [EOL] return textwrap . indent ( result , [string] * indent ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . render ( indent = [number] ) [EOL] [EOL] [EOL] @ dataclass class HomebrewTemplate : [EOL] url_data = ... [EOL] hash_data = ... [EOL] dependencies = ... [EOL] [EOL] [EOL] def _make_venv_at ( root , name , builder ) : [EOL] venv_path = root / name [EOL] os . makedirs ( root , exist_ok = True ) [EOL] if venv_path . exists ( ) : [EOL] shutil . rmtree ( venv_path ) [EOL] [EOL] builder . create ( venv_path ) [EOL] return venv_path [EOL] [EOL] [EOL] class HomebrewBuilder : [EOL] def __init__ ( self , dbt_path , version , homebrew_path , set_default , ) : [EOL] self . dbt_path = dbt_path [EOL] self . version = version [EOL] self . homebrew_path = homebrew_path [EOL] self . set_default = set_default [EOL] self . _template = None [EOL] [EOL] def make_venv ( self ) : [EOL] env = HomebrewVirtualenv ( self . version ) [EOL] max_attempts = [number] [EOL] for attempt in range ( [number] , max_attempts + [number] ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] env . create ( self . homebrew_venv_path ) [EOL] return [EOL] except subprocess . CalledProcessError : [EOL] if attempt == max_attempts : [EOL] raise [EOL] else : [EOL] print ( f' [string] ' f' [string] { attempt } [string] { max_attempts } [string] ' ) [EOL] time . sleep ( [number] ) [EOL] [EOL] return env [EOL] [EOL] @ property def versioned_formula_path ( self ) : [EOL] return ( self . homebrew_path / [string] / self . version . homebrew_filename ( ) ) [EOL] [EOL] @ property def default_formula_path ( self ) : [EOL] return ( self . homebrew_path / [string] ) [EOL] [EOL] @ property def homebrew_venv_path ( self ) : [EOL] return self . dbt_path / [string] / [string] [EOL] [EOL] @ staticmethod def _dbt_homebrew_formula_fmt ( ) : [EOL] return textwrap . dedent ( [string] ) [EOL] [EOL] @ staticmethod def _dbt_homebrew_trailer ( ) : [EOL] dedented = textwrap . dedent ( [string] ) [EOL] return textwrap . indent ( dedented , [string] ) [EOL] [EOL] def get_formula_data ( self , versioned = True ) : [EOL] fmt = self . _dbt_homebrew_formula_fmt ( ) [EOL] trailer = self . _dbt_homebrew_trailer ( ) [EOL] if versioned : [EOL] formula_name = self . version . homebrew_class_name ( ) [EOL] else : [EOL] formula_name = [string] [EOL] [EOL] dependencies_str = [string] . join ( d . render ( ) for d in self . template . dependencies ) [EOL] [EOL] return fmt . format ( formula_name = formula_name , version = self . version , url_data = self . template . url_data , hash_data = self . template . hash_data , dependencies = dependencies_str , trailer = trailer , ) [EOL] [EOL] @ property def template ( self ) : [EOL] if self . _template is None : [EOL] self . make_venv ( ) [EOL] print ( [string] ) [EOL] [EOL] dependencies = [ ] [EOL] dbt_package = None [EOL] for pkg in self . _get_packages ( ) : [EOL] if pkg . name == [string] : [EOL] if pkg . version != str ( self . version ) : [EOL] raise ValueError ( f' [string] { pkg . version } [string] ' f' [string] { self . version }' ) [EOL] dbt_package = pkg [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] if pkg . name . startswith ( [string] ) : [EOL] if pkg . version != str ( self . version ) : [EOL] raise ValueError ( f' [string] { pkg . name } [string] { pkg . version } [string] ' f' [string] { pkg . name } [string] { self . version }' ) [EOL] dependencies . append ( pkg ) [EOL] if dbt_package is None : [EOL] raise RuntimeError ( [string] ) [EOL] template = HomebrewTemplate ( url_data = dbt_package . url , hash_data = dbt_package . sha256 , dependencies = dependencies , ) [EOL] self . _template = template [EOL] else : [EOL] template = self . _template [EOL] return template [EOL] [EOL] def _get_pypi_info ( self , pkg , version ) : [EOL] fp = urlopen ( f' [string] { pkg } [string] { version } [string] ' ) [EOL] try : [EOL] data = json . load ( fp ) [EOL] finally : [EOL] fp . close ( ) [EOL] assert [string] in data [EOL] for pkginfo in data [ [string] ] : [EOL] assert [string] in pkginfo [EOL] if pkginfo [ [string] ] == [string] : [EOL] assert [string] in pkginfo [EOL] assert [string] in pkginfo [EOL] assert [string] in pkginfo [ [string] ] [EOL] url = pkginfo [ [string] ] [EOL] sha256 = pkginfo [ [string] ] [ [string] ] [EOL] return url , sha256 [EOL] raise ValueError ( f' [string] { pkg } [string] { version }' ) [EOL] [EOL] def _get_packages ( self ) : [EOL] pip = self . homebrew_venv_path / [string] [EOL] cmd = [ pip , [string] , [string] ] [EOL] raw = collect_output ( cmd ) . split ( [string] ) [EOL] for line in raw : [EOL] if not line : [EOL] continue [EOL] parts = line . split ( [string] ) [EOL] if len ( parts ) != [number] : [EOL] raise ValueError ( f' [string] { line }' ) [EOL] name , version = parts [EOL] url , sha256 = self . _get_pypi_info ( name , version ) [EOL] dep = HomebrewDependency ( name = name , url = url , sha256 = sha256 , version = version ) [EOL] yield dep [EOL] [EOL] def _remove_dbt_resource ( self , lines ) : [EOL] [comment] [EOL] line_iter = iter ( lines ) [EOL] [comment] [EOL] for line in line_iter : [EOL] [comment] [EOL] if line . strip ( ) == [string] : [EOL] for skip in line_iter : [EOL] if skip . strip ( ) == [string] : [EOL] [comment] [EOL] next ( line_iter ) [EOL] break [EOL] else : [EOL] yield line [EOL] [EOL] def create_versioned_formula_file ( self ) : [EOL] formula_contents = self . get_formula_data ( versioned = True ) [EOL] if self . versioned_formula_path . exists ( ) : [EOL] print ( [string] ) [EOL] self . versioned_formula_path . write_text ( formula_contents ) [EOL] [EOL] def commit_versioned_formula ( self ) : [EOL] [comment] [EOL] run_command ( [ [string] , [string] , self . versioned_formula_path ] , cwd = self . homebrew_path ) [EOL] run_command ( [ [string] , [string] , [string] , f' [string] { self . version }' ] , cwd = self . homebrew_path ) [EOL] [EOL] def commit_default_formula ( self ) : [EOL] run_command ( [ [string] , [string] , self . default_formula_path ] , cwd = self . homebrew_path ) [EOL] run_command ( [ [string] , [string] , [string] , f' [string] { self . version }' ] , cwd = self . homebrew_path ) [EOL] [EOL] @ staticmethod def run_tests ( formula_path , audit = True ) : [EOL] path = os . path . normpath ( formula_path ) [EOL] run_command ( [ [string] , [string] , [string] , path ] ) [EOL] versions = [ l . strip ( ) for l in collect_output ( [ [string] , [string] ] ) . split ( [string] ) if l . strip ( ) . startswith ( [string] ) or l . strip ( ) == [string] ] [EOL] if versions : [EOL] run_command ( [ [string] , [string] ] + versions ) [EOL] run_command ( [ [string] , [string] , path ] ) [EOL] run_command ( [ [string] , [string] , path ] ) [EOL] if audit : [EOL] run_command ( [ [string] , [string] , [string] , path ] ) [EOL] [EOL] def create_default_package ( self ) : [EOL] os . remove ( self . default_formula_path ) [EOL] formula_contents = self . get_formula_data ( versioned = False ) [EOL] self . default_formula_path . write_text ( formula_contents ) [EOL] [EOL] def build ( self ) : [EOL] self . create_versioned_formula_file ( ) [EOL] [comment] [EOL] self . commit_versioned_formula ( ) [EOL] [EOL] if self . set_default : [EOL] self . create_default_package ( ) [EOL] [comment] [EOL] self . commit_default_formula ( ) [EOL] [EOL] [EOL] class WheelInfo : [EOL] def __init__ ( self , path ) : [EOL] self . path = path [EOL] [EOL] @ staticmethod def _extract_distinfo_path ( wfile ) : [EOL] zpath = zipfile . Path ( root = wfile ) [EOL] for path in zpath . iterdir ( ) : [EOL] if path . name . endswith ( [string] ) : [EOL] return path [EOL] raise ValueError ( [string] ) [EOL] [EOL] def get_metadata ( self ) : [EOL] with zipfile . ZipFile ( self . path ) as wf : [EOL] distinfo = self . _extract_distinfo_path ( wf ) [EOL] metadata = distinfo / [string] [EOL] metadata_dict = { } [EOL] for line in metadata . read_text ( ) . split ( [string] ) : [EOL] parts = line . split ( [string] , [number] ) [EOL] if len ( parts ) == [number] : [EOL] metadata_dict [ parts [ [number] ] ] = parts [ [number] ] [EOL] return metadata_dict [EOL] [EOL] def package_name ( self ) : [EOL] metadata = self . get_metadata ( ) [EOL] if [string] not in metadata : [EOL] raise ValueError ( [string] ) [EOL] return metadata [ [string] ] [EOL] [EOL] [EOL] class DockerBuilder : [EOL] [docstring] [EOL] def __init__ ( self , dbt_path , version ) : [EOL] self . dbt_path = dbt_path [EOL] self . version = version [EOL] [EOL] @ property def docker_path ( self ) : [EOL] return self . dbt_path / [string] [EOL] [EOL] @ property def dockerfile_name ( self ) : [EOL] return f' [string] { self . version }' [EOL] [EOL] @ property def dockerfile_path ( self ) : [EOL] return self . docker_path / self . dockerfile_name [EOL] [EOL] @ property def requirements_path ( self ) : [EOL] return self . docker_path / [string] [EOL] [EOL] @ property def requirements_file_name ( self ) : [EOL] return f' [string] { self . version } [string] ' [EOL] [EOL] @ property def dockerfile_venv_path ( self ) : [EOL] return self . dbt_path / [string] / [string] [EOL] [EOL] @ property def requirements_txt_path ( self ) : [EOL] return self . requirements_path / self . requirements_file_name [EOL] [EOL] def make_venv ( self ) : [EOL] env = DistFolderEnv ( self . dbt_path ) [EOL] [EOL] env . create ( self . dockerfile_venv_path ) [EOL] return env [EOL] [EOL] def get_frozen ( self ) : [EOL] env = self . make_venv ( ) [EOL] pip_path = self . dockerfile_venv_path / [string] [EOL] cmd = [ pip_path , [string] ] [EOL] wheel_names = { WheelInfo ( wheel_path ) . package_name ( ) for wheel_path in env . wheels } [EOL] [comment] [EOL] return [string] . join ( [ dep for dep in collect_output ( cmd ) . split ( [string] ) if dep . split ( [string] ) [ [number] ] not in wheel_names ] ) [EOL] [EOL] def write_lockfile ( self ) : [EOL] freeze = self . get_frozen ( ) [EOL] path = self . requirements_txt_path [EOL] if path . exists ( ) : [EOL] raise ValueError ( f' [string] { path } [string] ' ) [EOL] os . makedirs ( path . parent , exist_ok = True ) [EOL] path . write_text ( freeze ) [EOL] [EOL] def get_dockerfile_contents ( self ) : [EOL] dist_path = ( self . dbt_path / [string] ) . relative_to ( Path . cwd ( ) ) [EOL] wheel_paths = [string] . join ( os . path . join ( [string] , [string] , p . name ) for p in _require_wheels ( self . dbt_path ) ) [EOL] [EOL] requirements_path = self . requirements_txt_path . relative_to ( Path . cwd ( ) ) [EOL] [EOL] return textwrap . dedent ( f''' [string] { requirements_path } [string] { self . requirements_file_name } [string] { dist_path } [string] { self . requirements_file_name } [string] { wheel_paths } [string] ''' ) [EOL] [EOL] def write_dockerfile ( self ) : [EOL] dockerfile = self . get_dockerfile_contents ( ) [EOL] path = self . dockerfile_path [EOL] if path . exists ( ) : [EOL] raise ValueError ( f' [string] { path } [string] ' ) [EOL] os . makedirs ( path . parent , exist_ok = True ) [EOL] path . write_text ( dockerfile ) [EOL] [EOL] @ property def image_tag ( self ) : [EOL] return f' [string] { self . version }' [EOL] [EOL] @ property def remote_tag ( self ) : [EOL] return f' [string] { self . image_tag }' [EOL] [EOL] def create_docker_image ( self ) : [EOL] run_command ( [ [string] , [string] , [string] , self . dockerfile_path , [string] , self . image_tag , self . dbt_path , ] , cwd = self . dbt_path ) [EOL] [EOL] def set_remote_tag ( self ) : [EOL] [comment] [EOL] run_command ( [ [string] , [string] , self . image_tag , self . remote_tag ] , cwd = self . dbt_path , ) [EOL] [EOL] def commit_docker_folder ( self ) : [EOL] [comment] [EOL] run_command ( [ [string] , [string] , [string] ] , cwd = self . dbt_path ) [EOL] commit_msg = f' [string] { self . image_tag } [string] ' [EOL] run_command ( [ [string] , [string] , [string] , commit_msg ] , cwd = self . dbt_path ) [EOL] [EOL] def build ( self , write_requirements = True , write_dockerfile = True ) : [EOL] if write_requirements : [EOL] self . write_lockfile ( ) [EOL] if write_dockerfile : [EOL] self . write_dockerfile ( ) [EOL] self . commit_docker_folder ( ) [EOL] self . create_docker_image ( ) [EOL] self . set_remote_tag ( ) [EOL] [EOL] def push ( self ) : [EOL] run_command ( [ [string] , [string] , self . remote_tag ] ) [EOL] [EOL] [EOL] def sanity_check ( ) : [EOL] if sys . version_info [ : len ( HOMEBREW_PYTHON ) ] != HOMEBREW_PYTHON : [EOL] python_version_str = [string] . join ( str ( i ) for i in HOMEBREW_PYTHON ) [EOL] print ( f' [string] { python_version_str }' ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [comment] [EOL] try : [EOL] import wheel [comment] [EOL] except ImportError : [EOL] print ( [string] [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def upgrade_to ( args ) : [EOL] if args . set_version : [EOL] set_version ( args . path , args . version , args . part ) [EOL] [EOL] builder = PypiBuilder ( args . path ) [EOL] if args . build_pypi : [EOL] builder . build ( ) [EOL] [EOL] if args . upload_pypi : [EOL] if args . test_upload : [EOL] builder . upload ( ) [EOL] input ( f' [string] { args . version } [string] ' [string] ) [EOL] builder . upload ( test = False ) [EOL] [EOL] if args . build_homebrew : [EOL] if args . upload_pypi : [EOL] print ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] HomebrewBuilder ( dbt_path = args . path , version = args . version , homebrew_path = args . homebrew_path , set_default = args . homebrew_set_default , ) . build ( ) [EOL] [EOL] if args . build_docker : [EOL] builder = DockerBuilder ( dbt_path = args . path , version = args . version , ) [EOL] builder . build ( write_requirements = args . write_requirements , write_dockerfile = args . write_dockerfile , ) [EOL] if args . upload_docker : [EOL] builder . push ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] sanity_check ( ) [EOL] args = Arguments . parse ( ) [EOL] upgrade_to ( args ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Version$ 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[HomebrewDependency]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.List[typing.Union[pathlib.Path,builtins.str]]$ 0 0 $pathlib.Path$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[pathlib.Path,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] PACKAGE_PATH = os . path . dirname ( __file__ ) [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Optional [EOL] import builtins [EOL] import typing [EOL] import multiprocessing [EOL] from multiprocessing import Lock [EOL] from contextlib import contextmanager [EOL] from typing import NewType [EOL] [EOL] from dbt . adapters . postgres import PostgresConnectionManager [EOL] from dbt . adapters . postgres import PostgresCredentials [EOL] from dbt . logger import GLOBAL_LOGGER as logger [comment] [EOL] import dbt . exceptions [EOL] import dbt . flags [EOL] [EOL] import boto3 [EOL] [EOL] from hologram import FieldEncoder , JsonSchemaMixin [EOL] from hologram . helpers import StrEnum [EOL] [EOL] from dataclasses import dataclass , field [EOL] from typing import Optional , List [EOL] [EOL] drop_lock = dbt . flags . MP_CONTEXT . Lock ( ) [EOL] [EOL] [EOL] IAMDuration = NewType ( [string] , int ) [EOL] [EOL] [EOL] class IAMDurationEncoder ( FieldEncoder ) : [EOL] @ property def json_schema ( self ) : [EOL] return { [string] : [string] , [string] : [number] , [string] : [number] } [EOL] [EOL] [EOL] JsonSchemaMixin . register_field_encoders ( { IAMDuration : IAMDurationEncoder ( ) } ) [EOL] [EOL] [EOL] class RedshiftConnectionMethod ( StrEnum ) : [EOL] DATABASE = [string] [EOL] IAM = [string] [EOL] [EOL] [EOL] @ dataclass class RedshiftCredentials ( PostgresCredentials ) : [EOL] method = RedshiftConnectionMethod . DATABASE [EOL] password = None [EOL] cluster_id = field ( default = None , metadata = { [string] : [string] } , ) [EOL] iam_profile = None [EOL] iam_duration_seconds = [number] [EOL] search_path = None [EOL] keepalives_idle = [number] [EOL] autocreate = False [EOL] db_groups = field ( default_factory = list ) [EOL] [EOL] @ property def type ( self ) : [EOL] return [string] [EOL] [EOL] def _connection_keys ( self ) : [EOL] keys = super ( ) . _connection_keys ( ) [EOL] return keys + ( [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] class RedshiftConnectionManager ( PostgresConnectionManager ) : [EOL] TYPE = [string] [EOL] [EOL] @ contextmanager def fresh_transaction ( self , name = None ) : [EOL] [docstring] [EOL] with drop_lock : [EOL] connection = self . get_thread_connection ( ) [EOL] [EOL] if connection . transaction_open : [EOL] self . commit ( ) [EOL] [EOL] self . begin ( ) [EOL] yield [EOL] [EOL] self . commit ( ) [EOL] self . begin ( ) [EOL] [EOL] @ classmethod def fetch_cluster_credentials ( cls , db_user , db_name , cluster_id , iam_profile , duration_s , autocreate , db_groups ) : [EOL] [docstring] [EOL] [EOL] if iam_profile is None : [EOL] boto_client = boto3 . client ( [string] ) [EOL] else : [EOL] logger . debug ( [string] + f" [string] { iam_profile }" ) [EOL] boto_session = boto3 . Session ( profile_name = iam_profile ) [EOL] boto_client = boto_session . client ( [string] ) [EOL] [EOL] try : [EOL] return boto_client . get_cluster_credentials ( DbUser = db_user , DbName = db_name , ClusterIdentifier = cluster_id , DurationSeconds = duration_s , AutoCreate = autocreate , DbGroups = db_groups , ) [EOL] [EOL] except boto_client . exceptions . ClientError as e : [EOL] raise dbt . exceptions . FailedToConnectException ( [string] . format ( e ) ) [EOL] [EOL] @ classmethod def get_tmp_iam_cluster_credentials ( cls , credentials ) : [EOL] cluster_id = credentials . cluster_id [EOL] [EOL] [comment] [EOL] [comment] [EOL] iam_duration_s = credentials . iam_duration_seconds [EOL] [EOL] if not cluster_id : [EOL] raise dbt . exceptions . FailedToConnectException ( [string] [string] ) [EOL] [EOL] cluster_creds = cls . fetch_cluster_credentials ( credentials . user , credentials . database , credentials . cluster_id , credentials . iam_profile , iam_duration_s , credentials . autocreate , credentials . db_groups , ) [EOL] [EOL] [comment] [EOL] return credentials . replace ( user = cluster_creds . get ( [string] ) , password = cluster_creds . get ( [string] ) ) [EOL] [EOL] @ classmethod def get_credentials ( cls , credentials ) : [EOL] method = credentials . method [EOL] [EOL] [comment] [EOL] if method == [string] or method is None : [EOL] logger . debug ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] if credentials . password is None : [EOL] raise dbt . exceptions . FailedToConnectException ( [string] ) [EOL] return credentials [EOL] [EOL] elif method == [string] : [EOL] logger . debug ( [string] ) [EOL] return cls . get_tmp_iam_cluster_credentials ( credentials ) [EOL] [EOL] else : [EOL] raise dbt . exceptions . FailedToConnectException ( [string] . format ( method ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from dbt . adapters . redshift . connections import RedshiftConnectionManager [comment] [EOL] from dbt . adapters . redshift . connections import RedshiftCredentials [EOL] from dbt . adapters . redshift . relation import RedshiftColumn [comment] [EOL] from dbt . adapters . redshift . relation import RedshiftRelation [comment] [EOL] from dbt . adapters . redshift . impl import RedshiftAdapter [EOL] [EOL] [EOL] from dbt . adapters . base import AdapterPlugin [EOL] from dbt . include import redshift [EOL] [EOL] Plugin = AdapterPlugin ( adapter = RedshiftAdapter , credentials = RedshiftCredentials , include_path = redshift . PACKAGE_PATH , dependencies = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
version = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Type , Any , List , Optional [EOL] import plugins [EOL] import builtins [EOL] import typing [EOL] from dataclasses import dataclass [EOL] from typing import Optional [EOL] from dbt . adapters . base . impl import AdapterConfig [EOL] from dbt . adapters . postgres import PostgresAdapter [EOL] from dbt . adapters . redshift import RedshiftConnectionManager [EOL] from dbt . adapters . redshift import RedshiftColumn [EOL] from dbt . adapters . redshift import RedshiftRelation [EOL] from dbt . logger import GLOBAL_LOGGER as logger [comment] [EOL] [EOL] [EOL] @ dataclass class RedshiftConfig ( AdapterConfig ) : [EOL] sort_type = None [EOL] dist = None [EOL] sort = None [EOL] bind = None [EOL] [EOL] [EOL] class RedshiftAdapter ( PostgresAdapter ) : [EOL] Relation = RedshiftRelation [EOL] ConnectionManager = RedshiftConnectionManager [EOL] Column = RedshiftColumn [EOL] [EOL] AdapterSpecificConfigs = RedshiftConfig [EOL] [EOL] @ classmethod def date_function ( cls ) : [EOL] return [string] [EOL] [EOL] def drop_relation ( self , relation ) : [EOL] [docstring] [EOL] with self . connections . fresh_transaction ( ) : [EOL] return super ( ) . drop_relation ( relation ) [EOL] [EOL] @ classmethod def convert_text_type ( cls , agate_table , col_idx ) : [EOL] column = agate_table . columns [ col_idx ] [EOL] [comment] [EOL] [comment] [EOL] lens = [ len ( d . encode ( [string] ) ) for d in column . values_without_nulls ( ) ] [EOL] max_len = max ( lens ) if lens else [number] [EOL] return [string] . format ( max_len ) [EOL] [EOL] @ classmethod def convert_time_type ( cls , agate_table , col_idx ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[plugins.redshift.dbt.adapters.redshift.impl.RedshiftAdapter]$ 0 0 0 $typing.Type[plugins.redshift.dbt.adapters.redshift.impl.RedshiftAdapter]$ 0 0 0 $typing.Type[plugins.redshift.dbt.adapters.redshift.impl.RedshiftAdapter]$ 0 0 0 0 $typing.Type[plugins.redshift.dbt.adapters.redshift.impl.RedshiftConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dbt . adapters . base import Column [EOL] from dataclasses import dataclass [EOL] from dbt . adapters . postgres . relation import PostgresRelation [EOL] [EOL] [EOL] @ dataclass ( frozen = True , eq = False , repr = False ) class RedshiftRelation ( PostgresRelation ) : [EOL] [comment] [EOL] [comment] [EOL] def relation_max_name_length ( self ) : [EOL] return [number] [EOL] [EOL] [EOL] class RedshiftColumn ( Column ) : [EOL] pass [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import os [EOL] import sys [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] from setuptools import setup [EOL] try : [EOL] from setuptools import find_namespace_packages [EOL] except ImportError : [EOL] [comment] [EOL] print ( [string] ) [EOL] print ( [string] [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] package_name = [string] [EOL] package_version = [string] [EOL] description = [string] [EOL] [EOL] this_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] with open ( os . path . join ( this_directory , [string] ) ) as f : [EOL] long_description = f . read ( ) [EOL] [EOL] setup ( name = package_name , version = package_version , description = description , long_description = long_description , long_description_content_type = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_namespace_packages ( include = [ [string] , [string] ] ) , package_data = { [string] : [ [string] , [string] , [string] , [string] , ] } , install_requires = [ [string] . format ( package_version ) , [string] , [string] , [string] , [string] , [string] , [string] , ] , zip_safe = False , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , python_requires = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] PACKAGE_PATH = os . path . dirname ( __file__ ) [EOL]	0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set , Union , Dict , Optional , Type [EOL] import builtins [EOL] import dbt [EOL] import typing [EOL] import google [EOL] import plugins [EOL] import agate [EOL] from dataclasses import dataclass [EOL] from typing import Dict , List , Optional , Any , Set , Union [EOL] from hologram import JsonSchemaMixin , ValidationError [EOL] [EOL] import dbt . deprecations [EOL] import dbt . exceptions [EOL] import dbt . flags as flags [EOL] import dbt . clients . gcloud [EOL] import dbt . clients . agate_helper [EOL] [EOL] from dbt import ui [EOL] from dbt . adapters . base import ( BaseAdapter , available , RelationType , SchemaSearchMap , AdapterConfig ) [EOL] from dbt . adapters . bigquery . relation import BigQueryRelation [EOL] from dbt . adapters . bigquery import BigQueryColumn [EOL] from dbt . adapters . bigquery import BigQueryConnectionManager [EOL] from dbt . contracts . connection import Connection [EOL] from dbt . contracts . graph . manifest import Manifest [EOL] from dbt . logger import GLOBAL_LOGGER as logger , print_timestamped_line [EOL] from dbt . utils import filter_null_values [EOL] [EOL] import google . auth [EOL] import google . api_core [EOL] import google . oauth2 [EOL] import google . cloud . exceptions [EOL] import google . cloud . bigquery [EOL] [EOL] from google . cloud . bigquery import AccessEntry , SchemaField [EOL] [EOL] import time [EOL] import agate [EOL] import json [EOL] [EOL] [comment] [EOL] WRITE_APPEND = google . cloud . bigquery . job . WriteDisposition . WRITE_APPEND [EOL] WRITE_TRUNCATE = google . cloud . bigquery . job . WriteDisposition . WRITE_TRUNCATE [EOL] [EOL] [EOL] def sql_escape ( string ) : [EOL] if not isinstance ( string , str ) : [EOL] dbt . exceptions . raise_compiler_exception ( f' [string] { string }' ) [EOL] [EOL] return json . dumps ( string ) [ [number] : - [number] ] [EOL] [EOL] [EOL] @ dataclass class PartitionConfig ( JsonSchemaMixin ) : [EOL] field = ... [EOL] data_type = [string] [EOL] range = None [EOL] [EOL] def render ( self , alias = None ) : [EOL] column = self . field [EOL] if alias : [EOL] column = f'{ alias } [string] { self . field }' [EOL] [EOL] if self . data_type in ( [string] , [string] ) : [EOL] return f' [string] { column } [string] ' [EOL] else : [EOL] return column [EOL] [EOL] @ classmethod def parse ( cls , raw_partition_by ) : [EOL] if raw_partition_by is None : [EOL] return None [EOL] try : [EOL] return cls . from_dict ( raw_partition_by ) [EOL] except ValidationError as exc : [EOL] msg = dbt . exceptions . validator_error_message ( exc ) [EOL] dbt . exceptions . raise_compiler_error ( f' [string] { msg }' ) [EOL] except TypeError : [EOL] dbt . exceptions . raise_compiler_error ( f' [string] ' f' [string] { raw_partition_by } [string] ' f' [string] ' ) [EOL] [EOL] [EOL] @ dataclass class GrantTarget ( JsonSchemaMixin ) : [EOL] dataset = ... [EOL] project = ... [EOL] [EOL] def render ( self ) : [EOL] return f'{ self . project } [string] { self . dataset }' [EOL] [EOL] [EOL] def _stub_relation ( * args , ** kwargs ) : [EOL] return BigQueryRelation . create ( database = [string] , schema = [string] , identifier = [string] , quote_policy = { } , type = BigQueryRelation . Table ) [EOL] [EOL] [EOL] @ dataclass class BigqueryConfig ( AdapterConfig ) : [EOL] cluster_by = None [EOL] partition_by = None [EOL] kms_key_name = None [EOL] labels = None [EOL] partitions = None [EOL] grant_access_to = None [EOL] hours_to_expiration = None [EOL] [EOL] [EOL] class BigQueryAdapter ( BaseAdapter ) : [EOL] [EOL] RELATION_TYPES = { [string] : RelationType . Table , [string] : RelationType . View , [string] : RelationType . External } [EOL] [EOL] Relation = BigQueryRelation [EOL] Column = BigQueryColumn [EOL] ConnectionManager = BigQueryConnectionManager [EOL] [EOL] AdapterSpecificConfigs = BigqueryConfig [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ classmethod def date_function ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def is_cancelable ( cls ) : [EOL] return False [EOL] [EOL] def drop_relation ( self , relation ) : [EOL] is_cached = self . _schema_is_cached ( relation . database , relation . schema ) [EOL] if is_cached : [EOL] self . cache_dropped ( relation ) [EOL] [EOL] conn = self . connections . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] dataset = self . connections . dataset ( relation . database , relation . schema , conn ) [EOL] relation_object = dataset . table ( relation . identifier ) [EOL] client . delete_table ( relation_object ) [EOL] [EOL] def truncate_relation ( self , relation ) : [EOL] raise dbt . exceptions . NotImplementedException ( [string] ) [EOL] [EOL] def rename_relation ( self , from_relation , to_relation ) : [EOL] [EOL] conn = self . connections . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] from_table_ref = self . connections . table_ref ( from_relation . database , from_relation . schema , from_relation . identifier , conn ) [EOL] from_table = client . get_table ( from_table_ref ) [EOL] if from_table . table_type == [string] or from_relation . type == RelationType . View or to_relation . type == RelationType . View : [EOL] raise dbt . exceptions . RuntimeException ( [string] ) [EOL] [EOL] to_table_ref = self . connections . table_ref ( to_relation . database , to_relation . schema , to_relation . identifier , conn ) [EOL] [EOL] self . cache_renamed ( from_relation , to_relation ) [EOL] client . copy_table ( from_table_ref , to_table_ref ) [EOL] client . delete_table ( from_table_ref ) [EOL] [EOL] @ available def list_schemas ( self , database ) : [EOL] [comment] [EOL] [comment] [EOL] database = database . strip ( [string] ) [EOL] conn = self . connections . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] def query_schemas ( ) : [EOL] [comment] [EOL] all_datasets = client . list_datasets ( project = database , max_results = [number] ) [EOL] return [ ds . dataset_id for ds in all_datasets ] [EOL] [EOL] return self . connections . _retry_and_handle ( msg = [string] , conn = conn , fn = query_schemas ) [EOL] [EOL] @ available . parse ( lambda * a , ** k : False ) def check_schema_exists ( self , database , schema ) : [EOL] conn = self . connections . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] bigquery_dataset = self . connections . dataset ( database , schema , conn ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] next ( iter ( client . list_tables ( bigquery_dataset , max_results = [number] ) ) ) [EOL] except StopIteration : [EOL] pass [EOL] except google . api_core . exceptions . NotFound : [EOL] [comment] [EOL] return False [EOL] return True [EOL] [EOL] def get_columns_in_relation ( self , relation ) : [EOL] try : [EOL] table = self . connections . get_bq_table ( database = relation . database , schema = relation . schema , identifier = relation . identifier ) [EOL] return self . _get_dbt_columns_from_bq_table ( table ) [EOL] [EOL] except ( ValueError , google . cloud . exceptions . NotFound ) as e : [EOL] logger . debug ( [string] . format ( e ) ) [EOL] return [ ] [EOL] [EOL] def expand_column_types ( self , goal , current ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def expand_target_column_types ( self , from_relation , to_relation ) : [EOL] [comment] [EOL] pass [EOL] [EOL] @ available . parse_list def list_relations_without_caching ( self , schema_relation ) : [EOL] connection = self . connections . get_thread_connection ( ) [EOL] client = connection . handle [EOL] [EOL] bigquery_dataset = self . connections . dataset ( schema_relation . database , schema_relation . schema , connection ) [EOL] [EOL] all_tables = client . list_tables ( bigquery_dataset , max_results = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] return [ self . _bq_table_to_relation ( table ) for table in all_tables ] [EOL] except google . api_core . exceptions . NotFound : [EOL] return [ ] [EOL] [EOL] def get_relation ( self , database , schema , identifier ) : [EOL] if self . _schema_is_cached ( database , schema ) : [EOL] [comment] [EOL] [comment] [EOL] return super ( ) . get_relation ( database = database , schema = schema , identifier = identifier ) [EOL] [EOL] try : [EOL] table = self . connections . get_bq_table ( database , schema , identifier ) [EOL] except google . api_core . exceptions . NotFound : [EOL] table = None [EOL] return self . _bq_table_to_relation ( table ) [EOL] [EOL] def create_schema ( self , relation ) : [EOL] database = relation . database [EOL] schema = relation . schema [EOL] logger . debug ( [string] , database , schema ) [EOL] self . connections . create_dataset ( database , schema ) [EOL] [EOL] def drop_schema ( self , relation ) : [EOL] database = relation . database [EOL] schema = relation . schema [EOL] logger . debug ( [string] , database , schema ) [EOL] self . connections . drop_dataset ( database , schema ) [EOL] self . cache . drop_schema ( database , schema ) [EOL] [EOL] @ classmethod def quote ( cls , identifier ) : [EOL] return [string] . format ( identifier ) [EOL] [EOL] @ classmethod def convert_text_type ( cls , agate_table , col_idx ) : [EOL] return [string] [EOL] [EOL] @ classmethod def convert_number_type ( cls , agate_table , col_idx ) : [EOL] decimals = agate_table . aggregate ( agate . MaxPrecision ( col_idx ) ) [EOL] return [string] if decimals else [string] [EOL] [EOL] @ classmethod def convert_boolean_type ( cls , agate_table , col_idx ) : [EOL] return [string] [EOL] [EOL] @ classmethod def convert_datetime_type ( cls , agate_table , col_idx ) : [EOL] return [string] [EOL] [EOL] @ classmethod def convert_date_type ( cls , agate_table , col_idx ) : [EOL] return [string] [EOL] [EOL] @ classmethod def convert_time_type ( cls , agate_table , col_idx ) : [EOL] return [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def _make_match_kwargs ( self , database , schema , identifier ) : [EOL] return filter_null_values ( { [string] : database , [string] : identifier , [string] : schema , } ) [EOL] [EOL] def _get_dbt_columns_from_bq_table ( self , table ) : [EOL] [docstring] [EOL] [EOL] columns = [ ] [EOL] for col in table . schema : [EOL] [comment] [EOL] dtype = self . Column . translate_type ( col . field_type ) [EOL] column = self . Column ( col . name , dtype , col . fields , col . mode ) [EOL] columns . append ( column ) [EOL] [EOL] return columns [EOL] [EOL] def _agate_to_schema ( self , agate_table , column_override ) : [EOL] [docstring] [EOL] bq_schema = [ ] [EOL] for idx , col_name in enumerate ( agate_table . column_names ) : [EOL] inferred_type = self . convert_agate_type ( agate_table , idx ) [EOL] type_ = column_override . get ( col_name , inferred_type ) [EOL] bq_schema . append ( SchemaField ( col_name , type_ ) ) [EOL] return bq_schema [EOL] [EOL] def _materialize_as_view ( self , model ) : [EOL] model_database = model . get ( [string] ) [EOL] model_schema = model . get ( [string] ) [EOL] model_alias = model . get ( [string] ) [EOL] model_sql = model . get ( [string] ) [EOL] [EOL] logger . debug ( [string] . format ( model_alias , model_sql ) ) [EOL] self . connections . create_view ( database = model_database , schema = model_schema , table_name = model_alias , sql = model_sql ) [EOL] return [string] [EOL] [EOL] def _materialize_as_table ( self , model , model_sql , decorator = None , ) : [EOL] model_database = model . get ( [string] ) [EOL] model_schema = model . get ( [string] ) [EOL] model_alias = model . get ( [string] ) [EOL] [EOL] if decorator is None : [EOL] table_name = model_alias [EOL] else : [EOL] table_name = [string] . format ( model_alias , decorator ) [EOL] [EOL] logger . debug ( [string] . format ( table_name , model_sql ) ) [EOL] self . connections . create_table ( database = model_database , schema = model_schema , table_name = table_name , sql = model_sql ) [EOL] [EOL] return [string] [EOL] [EOL] @ available . parse ( lambda * a , ** k : [string] ) def copy_table ( self , source , destination , materialization ) : [EOL] if materialization == [string] : [EOL] write_disposition = WRITE_APPEND [EOL] elif materialization == [string] : [EOL] write_disposition = WRITE_TRUNCATE [EOL] else : [EOL] dbt . exceptions . raise_compiler_error ( [string] f" [string] " f'{ materialization }' ) [EOL] [EOL] self . connections . copy_bq_table ( source , destination , write_disposition ) [EOL] [EOL] return [string] . format ( materialization ) [EOL] [EOL] @ classmethod def poll_until_job_completes ( cls , job , timeout ) : [EOL] retry_count = timeout [EOL] [EOL] while retry_count > [number] and job . state != [string] : [EOL] retry_count -= [number] [EOL] time . sleep ( [number] ) [EOL] job . reload ( ) [EOL] [EOL] if job . state != [string] : [EOL] raise dbt . exceptions . RuntimeException ( [string] ) [EOL] [EOL] elif job . error_result : [EOL] message = [string] . join ( error [ [string] ] . strip ( ) for error in job . errors ) [EOL] raise dbt . exceptions . RuntimeException ( message ) [EOL] [EOL] def _bq_table_to_relation ( self , bq_table ) : [EOL] if bq_table is None : [EOL] return None [EOL] [EOL] return self . Relation . create ( database = bq_table . project , schema = bq_table . dataset_id , identifier = bq_table . table_id , quote_policy = { [string] : True , [string] : True } , type = self . RELATION_TYPES . get ( bq_table . table_type , RelationType . External ) , ) [EOL] [EOL] @ classmethod def warning_on_hooks ( hook_type ) : [EOL] msg = [string] [EOL] print_timestamped_line ( msg . format ( hook_type ) , ui . COLOR_FG_YELLOW ) [EOL] [EOL] @ available def add_query ( self , sql , auto_begin = True , bindings = None , abridge_sql_log = False ) : [EOL] if self . nice_connection_name ( ) in [ [string] , [string] ] : [EOL] self . warning_on_hooks ( self . nice_connection_name ( ) ) [EOL] else : [EOL] raise dbt . exceptions . NotImplementedException ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ available . parse_none def make_date_partitioned_table ( self , relation ) : [EOL] return self . connections . create_date_partitioned_table ( database = relation . database , schema = relation . schema , table_name = relation . identifier ) [EOL] [EOL] @ available . parse ( lambda * a , ** k : [string] ) def execute_model ( self , model , materialization , sql_override = None , decorator = None ) : [EOL] [EOL] if sql_override is None : [EOL] sql_override = model . get ( [string] ) [EOL] [EOL] if flags . STRICT_MODE : [EOL] connection = self . connections . get_thread_connection ( ) [EOL] if not isinstance ( connection , Connection ) : [EOL] dbt . exceptions . raise_compiler_error ( f' [string] { connection } [string] ' ) [EOL] model_uid = model . get ( [string] ) [EOL] if connection . name != model_uid : [EOL] raise dbt . exceptions . InternalException ( f' [string] { connection . name } [string] ' f' [string] { model_uid } [string] ' ) [EOL] [EOL] if materialization == [string] : [EOL] res = self . _materialize_as_view ( model ) [EOL] elif materialization == [string] : [EOL] res = self . _materialize_as_table ( model , sql_override , decorator ) [EOL] else : [EOL] msg = [string] . format ( materialization ) [EOL] raise dbt . exceptions . RuntimeException ( msg , model ) [EOL] [EOL] return res [EOL] [EOL] def _partitions_match ( self , table , conf_partition ) : [EOL] [docstring] [EOL] is_partitioned = ( table . range_partitioning or table . time_partitioning ) [EOL] [EOL] if not is_partitioned and not conf_partition : [EOL] return True [EOL] elif conf_partition and table . time_partitioning is not None : [EOL] table_field = table . time_partitioning . field [EOL] return table_field == conf_partition . field [EOL] elif conf_partition and table . range_partitioning is not None : [EOL] dest_part = table . range_partitioning [EOL] conf_part = conf_partition . range or { } [EOL] [EOL] return dest_part . field == conf_partition . field \ [EOL] and dest_part . range_ . start == conf_part . get ( [string] ) \ [EOL] and dest_part . range_ . end == conf_part . get ( [string] ) \ [EOL] and dest_part . range_ . interval == conf_part . get ( [string] ) [EOL] else : [EOL] return False [EOL] [EOL] def _clusters_match ( self , table , conf_cluster ) : [EOL] [docstring] [EOL] if isinstance ( conf_cluster , str ) : [EOL] conf_cluster = [ conf_cluster ] [EOL] [EOL] return table . clustering_fields == conf_cluster [EOL] [EOL] @ available . parse ( lambda * a , ** k : True ) def is_replaceable ( self , relation , conf_partition , conf_cluster ) : [EOL] [docstring] [EOL] if not relation : [EOL] return True [EOL] [EOL] try : [EOL] table = self . connections . get_bq_table ( database = relation . database , schema = relation . schema , identifier = relation . identifier ) [EOL] except google . cloud . exceptions . NotFound : [EOL] return True [EOL] [EOL] return all ( ( self . _partitions_match ( table , conf_partition ) , self . _clusters_match ( table , conf_cluster ) ) ) [EOL] [EOL] @ available def parse_partition_by ( self , raw_partition_by ) : [EOL] [docstring] [EOL] return PartitionConfig . parse ( raw_partition_by ) [EOL] [EOL] def get_table_ref_from_relation ( self , conn , relation ) : [EOL] return self . connections . table_ref ( relation . database , relation . schema , relation . identifier , conn ) [EOL] [EOL] def _update_column_dict ( self , bq_column_dict , dbt_columns , parent = [string] ) : [EOL] [docstring] [EOL] if parent : [EOL] dotted_column_name = [string] . format ( parent , bq_column_dict [ [string] ] ) [EOL] else : [EOL] dotted_column_name = bq_column_dict [ [string] ] [EOL] [EOL] if dotted_column_name in dbt_columns : [EOL] column_config = dbt_columns [ dotted_column_name ] [EOL] bq_column_dict [ [string] ] = column_config . get ( [string] ) [EOL] if column_config . get ( [string] ) : [EOL] bq_column_dict [ [string] ] = { [string] : column_config . get ( [string] ) } [EOL] [EOL] new_fields = [ ] [EOL] for child_col_dict in bq_column_dict . get ( [string] , list ( ) ) : [EOL] new_child_column_dict = self . _update_column_dict ( child_col_dict , dbt_columns , parent = dotted_column_name ) [EOL] new_fields . append ( new_child_column_dict ) [EOL] [EOL] bq_column_dict [ [string] ] = new_fields [EOL] [EOL] return bq_column_dict [EOL] [EOL] @ available . parse_none def update_columns ( self , relation , columns ) : [EOL] if len ( columns ) == [number] : [EOL] return [EOL] [EOL] conn = self . connections . get_thread_connection ( ) [EOL] table_ref = self . get_table_ref_from_relation ( conn , relation ) [EOL] table = conn . handle . get_table ( table_ref ) [EOL] [EOL] new_schema = [ ] [EOL] for bq_column in table . schema : [EOL] bq_column_dict = bq_column . to_api_repr ( ) [EOL] new_bq_column_dict = self . _update_column_dict ( bq_column_dict , columns ) [EOL] new_schema . append ( SchemaField . from_api_repr ( new_bq_column_dict ) ) [EOL] [EOL] new_table = google . cloud . bigquery . Table ( table_ref , schema = new_schema ) [EOL] conn . handle . update_table ( new_table , [ [string] ] ) [EOL] [EOL] @ available . parse_none def update_table_description ( self , database , schema , identifier , description ) : [EOL] conn = self . connections . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] table_ref = self . connections . table_ref ( database , schema , identifier , conn ) [EOL] table = client . get_table ( table_ref ) [EOL] table . description = description [EOL] client . update_table ( table , [ [string] ] ) [EOL] [EOL] @ available . parse_none def alter_table_add_columns ( self , relation , columns ) : [EOL] [EOL] logger . debug ( [string] . format ( columns , relation ) ) [EOL] [EOL] conn = self . connections . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] table_ref = self . connections . table_ref ( relation . database , relation . schema , relation . identifier , conn ) [EOL] table = client . get_table ( table_ref ) [EOL] [EOL] new_columns = [ col . column_to_bq_schema ( ) for col in columns ] [EOL] new_schema = table . schema + new_columns [EOL] [EOL] new_table = google . cloud . bigquery . Table ( table_ref , schema = new_schema ) [EOL] client . update_table ( new_table , [ [string] ] ) [EOL] [EOL] @ available . parse_none def load_dataframe ( self , database , schema , table_name , agate_table , column_override ) : [EOL] bq_schema = self . _agate_to_schema ( agate_table , column_override ) [EOL] conn = self . connections . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] table = self . connections . table_ref ( database , schema , table_name , conn ) [EOL] [EOL] load_config = google . cloud . bigquery . LoadJobConfig ( ) [EOL] load_config . skip_leading_rows = [number] [EOL] load_config . schema = bq_schema [EOL] [EOL] with open ( agate_table . original_abspath , [string] ) as f : [EOL] job = client . load_table_from_file ( f , table , rewind = True , job_config = load_config ) [EOL] [EOL] timeout = self . connections . get_timeout ( conn ) [EOL] with self . connections . exception_handler ( [string] ) : [EOL] self . poll_until_job_completes ( job , timeout ) [EOL] [EOL] @ classmethod def _catalog_filter_table ( cls , table , manifest ) : [EOL] table = table . rename ( column_names = { col . name : col . name . replace ( [string] , [string] ) for col in table . columns } ) [EOL] return super ( ) . _catalog_filter_table ( table , manifest ) [EOL] [EOL] def _get_catalog_schemas ( self , manifest ) : [EOL] candidates = super ( ) . _get_catalog_schemas ( manifest ) [EOL] db_schemas = { } [EOL] result = SchemaSearchMap ( ) [EOL] [EOL] for candidate , schemas in candidates . items ( ) : [EOL] database = candidate . database [EOL] if database not in db_schemas : [EOL] db_schemas [ database ] = set ( self . list_schemas ( database ) ) [EOL] if candidate . schema in db_schemas [ database ] : [EOL] result [ candidate ] = schemas [EOL] else : [EOL] logger . debug ( [string] . format ( database , candidate . schema ) ) [EOL] return result [EOL] [EOL] @ available . parse ( lambda * a , ** k : { } ) def get_table_options ( self , config , node , temporary ) : [EOL] opts = { } [EOL] if temporary : [EOL] expiration = [string] [EOL] opts [ [string] ] = expiration [EOL] [EOL] if ( config . get ( [string] ) is not None ) and ( not temporary ) : [EOL] expiration = ( [string] [string] ) . format ( config . get ( [string] ) ) [EOL] opts [ [string] ] = expiration [EOL] [EOL] if config . persist_relation_docs ( ) and [string] in node : [EOL] description = sql_escape ( node [ [string] ] ) [EOL] opts [ [string] ] = [string] . format ( description ) [EOL] [EOL] if config . get ( [string] ) is not None : [EOL] opts [ [string] ] = [string] . format ( config . get ( [string] ) ) [EOL] [EOL] if config . get ( [string] ) : [EOL] labels = config . get ( [string] , { } ) [EOL] opts [ [string] ] = list ( labels . items ( ) ) [EOL] [EOL] return opts [EOL] [EOL] @ available . parse_none def grant_access_to ( self , entity , entity_type , role , grant_target_dict ) : [EOL] [docstring] [EOL] conn = self . connections . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] grant_target = GrantTarget . from_dict ( grant_target_dict ) [EOL] dataset = client . get_dataset ( self . connections . dataset_from_id ( grant_target . render ( ) ) ) [EOL] [EOL] if entity_type == [string] : [EOL] entity = self . connections . table_ref ( entity . database , entity . schema , entity . identifier , conn ) . to_api_repr ( ) [EOL] [EOL] access_entry = AccessEntry ( role , entity_type , entity ) [EOL] access_entries = dataset . access_entries [EOL] [EOL] if access_entry in access_entries : [EOL] logger . debug ( f" [string] { access_entry } [string] " f" [string] " ) [EOL] return [EOL] [EOL] access_entries . append ( AccessEntry ( role , entity_type , entity ) ) [EOL] dataset . access_entries = access_entries [EOL] client . update_dataset ( dataset , [ [string] ] ) [EOL] [EOL] def get_rows_different_sql ( self , relation_a , relation_b , column_names = None , except_operator = [string] ) : [EOL] return super ( ) . get_rows_different_sql ( relation_a = relation_a , relation_b = relation_b , column_names = column_names , except_operator = except_operator , ) [EOL] [EOL] def timestamp_add_sql ( self , add_to , number = [number] , interval = [string] ) : [EOL] return f' [string] { add_to } [string] { number } [string] { interval } [string] ' [EOL] [EOL] def string_add_sql ( self , add_to , value , location = [string] , ) : [EOL] if location == [string] : [EOL] return f" [string] { add_to } [string] { value } [string] " [EOL] elif location == [string] : [EOL] return f" [string] { value } [string] { add_to } [string] " [EOL] else : [EOL] raise dbt . exceptions . RuntimeException ( f' [string] { location } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.bool$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $dbt.adapters.bigquery.relation.BigQueryRelation$ 0 $dbt.adapters.bigquery.relation.BigQueryRelation$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dbt.adapters.bigquery.relation.BigQueryRelation$ 0 $dbt.adapters.bigquery.relation.BigQueryRelation$ 0 $dbt.adapters.bigquery.relation.BigQueryRelation$ 0 $dbt.adapters.bigquery.relation.BigQueryRelation$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , Any , Optional [EOL] import builtins [EOL] import typing [EOL] from dataclasses import dataclass [EOL] from typing import Optional [EOL] [EOL] from dbt . adapters . base . relation import ( BaseRelation , ComponentName , InformationSchema ) [EOL] from dbt . utils import filter_null_values [EOL] from typing import TypeVar [EOL] [EOL] [EOL] Self = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True , eq = False , repr = False ) class BigQueryRelation ( BaseRelation ) : [EOL] quote_character = [string] [EOL] [EOL] def matches ( self , database = None , schema = None , identifier = None , ) : [EOL] search = filter_null_values ( { ComponentName . Database : database , ComponentName . Schema : schema , ComponentName . Identifier : identifier } ) [EOL] [EOL] if not search : [EOL] [comment] [EOL] pass [EOL] [EOL] for k , v in search . items ( ) : [EOL] if not self . _is_exactish_match ( k , v ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] @ property def project ( self ) : [EOL] return self . database [EOL] [EOL] @ property def dataset ( self ) : [EOL] return self . schema [EOL] [EOL] def information_schema ( self , identifier = None ) : [EOL] return BigQueryInformationSchema . from_relation ( self , identifier ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True , eq = False , repr = False ) class BigQueryInformationSchema ( InformationSchema ) : [EOL] quote_character = [string] [EOL] [EOL] @ classmethod def get_include_policy ( cls , relation , information_schema_view ) : [EOL] schema = True [EOL] if information_schema_view in ( [string] , [string] , None ) : [EOL] schema = False [EOL] [EOL] identifier = True [EOL] if information_schema_view == [string] : [EOL] identifier = False [EOL] [EOL] return relation . include_policy . replace ( schema = schema , identifier = identifier , ) [EOL] [EOL] def replace ( self , ** kwargs ) : [EOL] if [string] in kwargs : [EOL] view = kwargs [ [string] ] [EOL] [comment] [EOL] [comment] [EOL] if [string] not in kwargs : [EOL] kwargs [ [string] ] = self . get_include_policy ( self , view ) [EOL] return super ( ) . replace ( ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'BigQueryInformationSchema'$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Optional , Type , Tuple [EOL] import plugins [EOL] import builtins [EOL] import typing [EOL] import requests [EOL] from contextlib import contextmanager [EOL] from dataclasses import dataclass [EOL] from requests . exceptions import ConnectionError [EOL] from typing import Optional , Any , Dict [EOL] [EOL] import google . auth [EOL] import google . auth . exceptions [EOL] import google . cloud . bigquery [EOL] import google . cloud . exceptions [EOL] from google . api_core import retry , client_info [EOL] from google . auth import impersonated_credentials [EOL] from google . oauth2 import service_account [EOL] [EOL] from dbt . utils import format_bytes , format_rows_number [EOL] from dbt . clients import agate_helper , gcloud [EOL] from dbt . contracts . connection import ConnectionState [EOL] from dbt . exceptions import ( FailedToConnectException , RuntimeException , DatabaseException ) [EOL] from dbt . adapters . base import BaseConnectionManager , Credentials [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] from dbt . version import __version__ as dbt_version [EOL] [EOL] from hologram . helpers import StrEnum [EOL] [EOL] [EOL] BQ_QUERY_JOB_SPLIT = [string] [EOL] [EOL] WRITE_TRUNCATE = google . cloud . bigquery . job . WriteDisposition . WRITE_TRUNCATE [EOL] [EOL] REOPENABLE_ERRORS = ( ConnectionResetError , ConnectionError , ) [EOL] [EOL] RETRYABLE_ERRORS = ( google . cloud . exceptions . ServerError , google . cloud . exceptions . BadRequest , ConnectionResetError , ConnectionError , ) [EOL] [EOL] [EOL] class Priority ( StrEnum ) : [EOL] Interactive = [string] [EOL] Batch = [string] [EOL] [EOL] [EOL] class BigQueryConnectionMethod ( StrEnum ) : [EOL] OAUTH = [string] [EOL] SERVICE_ACCOUNT = [string] [EOL] SERVICE_ACCOUNT_JSON = [string] [EOL] [EOL] [EOL] @ dataclass class BigQueryCredentials ( Credentials ) : [EOL] method = ... [EOL] keyfile = None [EOL] keyfile_json = None [EOL] timeout_seconds = [number] [EOL] location = None [EOL] priority = None [EOL] retries = [number] [EOL] maximum_bytes_billed = None [EOL] impersonate_service_account = None [EOL] _ALIASES = { [string] : [string] , [string] : [string] , } [EOL] [EOL] @ property def type ( self ) : [EOL] return [string] [EOL] [EOL] def _connection_keys ( self ) : [EOL] return ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] class BigQueryConnectionManager ( BaseConnectionManager ) : [EOL] TYPE = [string] [EOL] [EOL] SCOPE = ( [string] , [string] , [string] ) [EOL] [EOL] QUERY_TIMEOUT = [number] [EOL] RETRIES = [number] [EOL] DEFAULT_INITIAL_DELAY = [number] [comment] [EOL] DEFAULT_MAXIMUM_DELAY = [number] [comment] [EOL] [EOL] @ classmethod def handle_error ( cls , error , message ) : [EOL] error_msg = [string] . join ( [ item [ [string] ] for item in error . errors ] ) [EOL] raise DatabaseException ( error_msg ) [EOL] [EOL] def clear_transaction ( self ) : [EOL] pass [EOL] [EOL] @ contextmanager def exception_handler ( self , sql ) : [EOL] try : [EOL] yield [EOL] [EOL] except google . cloud . exceptions . BadRequest as e : [EOL] message = [string] [EOL] self . handle_error ( e , message ) [EOL] [EOL] except google . cloud . exceptions . Forbidden as e : [EOL] message = [string] [EOL] self . handle_error ( e , message ) [EOL] [EOL] except google . auth . exceptions . RefreshError : [EOL] message = [string] [string] [string] [string] [string] [EOL] raise RuntimeException ( message ) [EOL] [EOL] except Exception as e : [EOL] logger . debug ( [string] . format ( sql ) ) [EOL] logger . debug ( e ) [EOL] if isinstance ( e , RuntimeException ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] raise [EOL] exc_message = str ( e ) [EOL] [comment] [EOL] [comment] [EOL] if BQ_QUERY_JOB_SPLIT in exc_message : [EOL] exc_message = exc_message . split ( BQ_QUERY_JOB_SPLIT ) [ [number] ] . strip ( ) [EOL] raise RuntimeException ( exc_message ) [EOL] [EOL] def cancel_open ( self ) : [EOL] pass [EOL] [EOL] @ classmethod def close ( cls , connection ) : [EOL] connection . state = ConnectionState . CLOSED [EOL] [EOL] return connection [EOL] [EOL] def begin ( self ) : [EOL] pass [EOL] [EOL] def commit ( self ) : [EOL] pass [EOL] [EOL] @ classmethod def get_bigquery_credentials ( cls , profile_credentials ) : [EOL] method = profile_credentials . method [EOL] creds = service_account . Credentials [EOL] [EOL] if method == BigQueryConnectionMethod . OAUTH : [EOL] credentials , project_id = google . auth . default ( scopes = cls . SCOPE ) [EOL] return credentials [EOL] [EOL] elif method == BigQueryConnectionMethod . SERVICE_ACCOUNT : [EOL] keyfile = profile_credentials . keyfile [EOL] return creds . from_service_account_file ( keyfile , scopes = cls . SCOPE ) [EOL] [EOL] elif method == BigQueryConnectionMethod . SERVICE_ACCOUNT_JSON : [EOL] details = profile_credentials . keyfile_json [EOL] return creds . from_service_account_info ( details , scopes = cls . SCOPE ) [EOL] [EOL] error = ( [string] . format ( method ) ) [EOL] raise FailedToConnectException ( error ) [EOL] [EOL] @ classmethod def get_impersonated_bigquery_credentials ( cls , profile_credentials ) : [EOL] source_credentials = cls . get_bigquery_credentials ( profile_credentials ) [EOL] return impersonated_credentials . Credentials ( source_credentials = source_credentials , target_principal = profile_credentials . impersonate_service_account , target_scopes = list ( cls . SCOPE ) , lifetime = profile_credentials . timeout_seconds , ) [EOL] [EOL] @ classmethod def get_bigquery_client ( cls , profile_credentials ) : [EOL] if profile_credentials . impersonate_service_account : [EOL] creds = cls . get_impersonated_bigquery_credentials ( profile_credentials ) [EOL] else : [EOL] creds = cls . get_bigquery_credentials ( profile_credentials ) [EOL] database = profile_credentials . database [EOL] location = getattr ( profile_credentials , [string] , None ) [EOL] [EOL] info = client_info . ClientInfo ( user_agent = f' [string] { dbt_version }' ) [EOL] return google . cloud . bigquery . Client ( database , creds , location = location , client_info = info , ) [EOL] [EOL] @ classmethod def open ( cls , connection ) : [EOL] if connection . state == [string] : [EOL] logger . debug ( [string] ) [EOL] return connection [EOL] [EOL] try : [EOL] handle = cls . get_bigquery_client ( connection . credentials ) [EOL] [EOL] except google . auth . exceptions . DefaultCredentialsError : [EOL] logger . info ( [string] ) [EOL] gcloud . setup_default_credentials ( ) [EOL] [EOL] handle = cls . get_bigquery_client ( connection . credentials ) [EOL] [EOL] except Exception as e : [EOL] raise [EOL] logger . debug ( [string] [string] . format ( e ) ) [EOL] [EOL] connection . handle = None [EOL] connection . state = [string] [EOL] [EOL] raise FailedToConnectException ( str ( e ) ) [EOL] [EOL] connection . handle = handle [EOL] connection . state = [string] [EOL] return connection [EOL] [EOL] @ classmethod def get_timeout ( cls , conn ) : [EOL] credentials = conn . credentials [EOL] return credentials . timeout_seconds [EOL] [EOL] @ classmethod def get_retries ( cls , conn ) : [EOL] credentials = conn . credentials [EOL] if credentials . retries is not None : [EOL] return credentials . retries [EOL] else : [EOL] return [number] [EOL] [EOL] @ classmethod def get_table_from_response ( cls , resp ) : [EOL] column_names = [ field . name for field in resp . schema ] [EOL] return agate_helper . table_from_data_flat ( resp , column_names ) [EOL] [EOL] def raw_execute ( self , sql , fetch = False ) : [EOL] conn = self . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] logger . debug ( [string] , conn . name , sql ) [EOL] [EOL] job_params = { [string] : False } [EOL] [EOL] priority = conn . credentials . priority [EOL] if priority == Priority . Batch : [EOL] job_params [ [string] ] = google . cloud . bigquery . QueryPriority . BATCH [EOL] else : [EOL] job_params [ [string] ] = google . cloud . bigquery . QueryPriority . INTERACTIVE [EOL] [EOL] maximum_bytes_billed = conn . credentials . maximum_bytes_billed [EOL] if maximum_bytes_billed is not None and maximum_bytes_billed != [number] : [EOL] job_params [ [string] ] = maximum_bytes_billed [EOL] [EOL] def fn ( ) : [EOL] return self . _query_and_results ( client , sql , conn , job_params ) [EOL] [EOL] query_job , iterator = self . _retry_and_handle ( msg = sql , conn = conn , fn = fn ) [EOL] [EOL] return query_job , iterator [EOL] [EOL] def execute ( self , sql , auto_begin = False , fetch = None ) : [EOL] sql = self . _add_query_comment ( sql ) [EOL] [comment] [EOL] query_job , iterator = self . raw_execute ( sql , fetch = fetch ) [EOL] [EOL] if fetch : [EOL] res = self . get_table_from_response ( iterator ) [EOL] else : [EOL] res = agate_helper . empty_table ( ) [EOL] [EOL] if query_job . statement_type == [string] : [EOL] status = [string] [EOL] [EOL] elif query_job . statement_type == [string] : [EOL] conn = self . get_thread_connection ( ) [EOL] client = conn . handle [EOL] table = client . get_table ( query_job . destination ) [EOL] processed = format_bytes ( query_job . total_bytes_processed ) [EOL] status = [string] . format ( format_rows_number ( table . num_rows ) , format_bytes ( query_job . total_bytes_processed ) , ) [EOL] [EOL] elif query_job . statement_type == [string] : [EOL] processed = format_bytes ( query_job . total_bytes_processed ) [EOL] status = f' [string] { processed } [string] ' [EOL] [EOL] elif query_job . statement_type in [ [string] , [string] , [string] ] : [EOL] status = [string] . format ( query_job . statement_type , format_rows_number ( query_job . num_dml_affected_rows ) , format_bytes ( query_job . total_bytes_processed ) , ) [EOL] [EOL] else : [EOL] status = [string] [EOL] [EOL] return status , res [EOL] [EOL] def create_bigquery_table ( self , database , schema , table_name , callback , sql ) : [EOL] [docstring] [EOL] conn = self . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] view_ref = self . table_ref ( database , schema , table_name , conn ) [EOL] view = google . cloud . bigquery . Table ( view_ref ) [EOL] callback ( view ) [EOL] [EOL] def fn ( ) : [EOL] return client . create_table ( view ) [EOL] self . _retry_and_handle ( msg = sql , conn = conn , fn = fn ) [EOL] [EOL] def create_view ( self , database , schema , table_name , sql ) : [EOL] def callback ( table ) : [EOL] table . view_query = sql [EOL] table . view_use_legacy_sql = False [EOL] [EOL] self . create_bigquery_table ( database , schema , table_name , callback , sql ) [EOL] [EOL] def create_table ( self , database , schema , table_name , sql ) : [EOL] conn = self . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] table_ref = self . table_ref ( database , schema , table_name , conn ) [EOL] job_params = { [string] : table_ref , [string] : WRITE_TRUNCATE } [EOL] [EOL] timeout = self . get_timeout ( conn ) [EOL] [EOL] def fn ( ) : [EOL] return self . _query_and_results ( client , sql , conn , job_params , timeout = timeout ) [EOL] self . _retry_and_handle ( msg = sql , conn = conn , fn = fn ) [EOL] [EOL] def create_date_partitioned_table ( self , database , schema , table_name ) : [EOL] def callback ( table ) : [EOL] table . partitioning_type = [string] [EOL] [EOL] self . create_bigquery_table ( database , schema , table_name , callback , [string] ) [EOL] [EOL] def copy_bq_table ( self , source , destination , write_disposition ) : [EOL] conn = self . get_thread_connection ( ) [EOL] client = conn . handle [EOL] [EOL] source_ref = self . table_ref ( source . database , source . schema , source . table , conn ) [EOL] destination_ref = self . table_ref ( destination . database , destination . schema , destination . table , conn ) [EOL] [EOL] logger . debug ( [string] , source_ref . path , destination_ref . path , write_disposition ) [EOL] [EOL] def copy_and_results ( ) : [EOL] job_config = google . cloud . bigquery . CopyJobConfig ( write_disposition = write_disposition ) [EOL] copy_job = client . copy_table ( source_ref , destination_ref , job_config = job_config ) [EOL] iterator = copy_job . result ( timeout = self . get_timeout ( conn ) ) [EOL] return copy_job , iterator [EOL] [EOL] self . _retry_and_handle ( msg = [string] . format ( source_ref . path , destination_ref . path ) , conn = conn , fn = copy_and_results ) [EOL] [EOL] @ staticmethod def dataset ( database , schema , conn ) : [EOL] dataset_ref = conn . handle . dataset ( schema , database ) [EOL] return google . cloud . bigquery . Dataset ( dataset_ref ) [EOL] [EOL] @ staticmethod def dataset_from_id ( dataset_id ) : [EOL] return google . cloud . bigquery . Dataset . from_string ( dataset_id ) [EOL] [EOL] def table_ref ( self , database , schema , table_name , conn ) : [EOL] dataset = self . dataset ( database , schema , conn ) [EOL] return dataset . table ( table_name ) [EOL] [EOL] def get_bq_table ( self , database , schema , identifier ) : [EOL] [docstring] [EOL] conn = self . get_thread_connection ( ) [EOL] table_ref = self . table_ref ( database , schema , identifier , conn ) [EOL] return conn . handle . get_table ( table_ref ) [EOL] [EOL] def drop_dataset ( self , database , schema ) : [EOL] conn = self . get_thread_connection ( ) [EOL] dataset = self . dataset ( database , schema , conn ) [EOL] client = conn . handle [EOL] [EOL] def fn ( ) : [EOL] return client . delete_dataset ( dataset , delete_contents = True , not_found_ok = True ) [EOL] [EOL] self . _retry_and_handle ( msg = [string] , conn = conn , fn = fn ) [EOL] [EOL] def create_dataset ( self , database , schema ) : [EOL] conn = self . get_thread_connection ( ) [EOL] client = conn . handle [EOL] dataset = self . dataset ( database , schema , conn ) [EOL] [EOL] def fn ( ) : [EOL] return client . create_dataset ( dataset , exists_ok = True ) [EOL] self . _retry_and_handle ( msg = [string] , conn = conn , fn = fn ) [EOL] [EOL] def _query_and_results ( self , client , sql , conn , job_params , timeout = None ) : [EOL] [docstring] [EOL] [comment] [EOL] job_config = google . cloud . bigquery . QueryJobConfig ( ** job_params ) [EOL] query_job = client . query ( sql , job_config = job_config ) [EOL] iterator = query_job . result ( timeout = timeout ) [EOL] [EOL] return query_job , iterator [EOL] [EOL] def _retry_and_handle ( self , msg , conn , fn ) : [EOL] [docstring] [EOL] def reopen_conn_on_error ( error ) : [EOL] if isinstance ( error , REOPENABLE_ERRORS ) : [EOL] logger . warning ( [string] , error ) [EOL] self . close ( conn ) [EOL] self . open ( conn ) [EOL] return [EOL] [EOL] with self . exception_handler ( msg ) : [EOL] return retry . retry_target ( target = fn , predicate = _ErrorCounter ( self . get_retries ( conn ) ) . count_error , sleep_generator = self . _retry_generator ( ) , deadline = None , on_error = reopen_conn_on_error ) [EOL] [EOL] def _retry_generator ( self ) : [EOL] [docstring] [EOL] return retry . exponential_sleep_generator ( initial = self . DEFAULT_INITIAL_DELAY , maximum = self . DEFAULT_MAXIMUM_DELAY ) [EOL] [EOL] [EOL] class _ErrorCounter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , retries ) : [EOL] self . retries = retries [EOL] self . error_count = [number] [EOL] [EOL] def count_error ( self , error ) : [EOL] if self . retries == [number] : [EOL] return False [comment] [EOL] self . error_count += [number] [EOL] if _is_retryable ( error ) and self . error_count <= self . retries : [EOL] logger . debug ( [string] , self . error_count , self . retries , repr ( error ) ) [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def _is_retryable ( error ) : [EOL] [docstring] [EOL] if isinstance ( error , RETRYABLE_ERRORS ) : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BigQueryConnectionMethod$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
version = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] from dbt . adapters . bigquery . connections import BigQueryConnectionManager [comment] [EOL] from dbt . adapters . bigquery . connections import BigQueryCredentials [EOL] from dbt . adapters . bigquery . relation import BigQueryRelation [comment] [EOL] from dbt . adapters . bigquery . column import BigQueryColumn [comment] [EOL] from dbt . adapters . bigquery . impl import BigQueryAdapter , GrantTarget [comment] [EOL] [EOL] from dbt . adapters . base import AdapterPlugin [EOL] from dbt . include import bigquery [EOL] [EOL] Plugin = AdapterPlugin ( adapter = BigQueryAdapter , credentials = BigQueryCredentials , include_path = bigquery . PACKAGE_PATH ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] PACKAGE_PATH = os . path . dirname ( __file__ ) [EOL]	0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
version = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Dict , Any , Type , Optional [EOL] import plugins [EOL] import builtins [EOL] import typing [EOL] from contextlib import contextmanager [EOL] [EOL] import psycopg2 [EOL] [EOL] import dbt . exceptions [EOL] from dbt . adapters . base import Credentials [EOL] from dbt . adapters . sql import SQLConnectionManager [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] [EOL] from dbt . helper_types import Port [EOL] from dataclasses import dataclass [EOL] from typing import Optional [EOL] [EOL] [EOL] @ dataclass class PostgresCredentials ( Credentials ) : [EOL] host = ... [EOL] user = ... [EOL] role = ... [EOL] port = ... [EOL] password = ... [comment] [EOL] search_path = None [EOL] keepalives_idle = [number] [comment] [EOL] sslmode = None [EOL] [EOL] _ALIASES = { [string] : [string] , [string] : [string] } [EOL] [EOL] @ property def type ( self ) : [EOL] return [string] [EOL] [EOL] def _connection_keys ( self ) : [EOL] return ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] class PostgresConnectionManager ( SQLConnectionManager ) : [EOL] TYPE = [string] [EOL] [EOL] @ contextmanager def exception_handler ( self , sql ) : [EOL] try : [EOL] yield [EOL] [EOL] except psycopg2 . DatabaseError as e : [EOL] logger . debug ( [string] . format ( str ( e ) ) ) [EOL] [EOL] try : [EOL] self . rollback_if_open ( ) [EOL] except psycopg2 . Error : [EOL] logger . debug ( [string] ) [EOL] pass [EOL] [EOL] raise dbt . exceptions . DatabaseException ( str ( e ) . strip ( ) ) from e [EOL] [EOL] except Exception as e : [EOL] logger . debug ( [string] , sql ) [EOL] logger . debug ( [string] ) [EOL] self . rollback_if_open ( ) [EOL] if isinstance ( e , dbt . exceptions . RuntimeException ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] raise [EOL] [EOL] raise dbt . exceptions . RuntimeException ( e ) from e [EOL] [EOL] @ classmethod def open ( cls , connection ) : [EOL] if connection . state == [string] : [EOL] logger . debug ( [string] ) [EOL] return connection [EOL] [EOL] credentials = cls . get_credentials ( connection . credentials ) [EOL] kwargs = { } [EOL] [comment] [EOL] [comment] [EOL] if credentials . keepalives_idle : [EOL] kwargs [ [string] ] = credentials . keepalives_idle [EOL] [EOL] [comment] [EOL] [comment] [EOL] search_path = credentials . search_path [EOL] if search_path is not None and search_path != [string] : [EOL] [comment] [EOL] kwargs [ [string] ] = [string] . format ( search_path . replace ( [string] , [string] ) ) [EOL] [EOL] if credentials . sslmode : [EOL] kwargs [ [string] ] = credentials . sslmode [EOL] [EOL] try : [EOL] handle = psycopg2 . connect ( dbname = credentials . database , user = credentials . user , host = credentials . host , password = credentials . password , port = credentials . port , connect_timeout = [number] , ** kwargs ) [EOL] [EOL] if credentials . role : [EOL] handle . cursor ( ) . execute ( [string] . format ( credentials . role ) ) [EOL] [EOL] connection . handle = handle [EOL] connection . state = [string] [EOL] except psycopg2 . Error as e : [EOL] logger . debug ( [string] [string] . format ( e ) ) [EOL] [EOL] connection . handle = None [EOL] connection . state = [string] [EOL] [EOL] raise dbt . exceptions . FailedToConnectException ( str ( e ) ) [EOL] [EOL] return connection [EOL] [EOL] def cancel ( self , connection ) : [EOL] connection_name = connection . name [EOL] try : [EOL] pid = connection . handle . get_backend_pid ( ) [EOL] except psycopg2 . InterfaceError as exc : [EOL] [comment] [EOL] if [string] in str ( exc ) : [EOL] logger . debug ( f' [string] { connection_name } [string] ' ) [EOL] return [EOL] [comment] [EOL] raise [EOL] [EOL] sql = [string] . format ( pid ) [EOL] [EOL] logger . debug ( [string] . format ( connection_name , pid ) ) [EOL] [EOL] _ , cursor = self . add_query ( sql ) [EOL] res = cursor . fetchone ( ) [EOL] [EOL] logger . debug ( [string] . format ( connection_name , res ) ) [EOL] [EOL] @ classmethod def get_credentials ( cls , credentials ) : [EOL] return credentials [EOL] [EOL] @ classmethod def get_status ( cls , cursor ) : [EOL] return cursor . statusmessage [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $dbt.helper_types.Port$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , Set , Optional [EOL] import plugins [EOL] import builtins [EOL] import typing [EOL] from dataclasses import dataclass [EOL] from typing import Optional , Set [EOL] from dbt . adapters . base . meta import available [EOL] from dbt . adapters . base . impl import AdapterConfig [EOL] from dbt . adapters . sql import SQLAdapter [EOL] from dbt . adapters . postgres import PostgresConnectionManager [EOL] from dbt . adapters . postgres import PostgresColumn [EOL] from dbt . adapters . postgres import PostgresRelation [EOL] import dbt . exceptions [EOL] [EOL] [EOL] [comment] [EOL] GET_RELATIONS_MACRO_NAME = [string] [EOL] [EOL] [EOL] @ dataclass class PostgresConfig ( AdapterConfig ) : [EOL] unlogged = None [EOL] [EOL] [EOL] class PostgresAdapter ( SQLAdapter ) : [EOL] Relation = PostgresRelation [EOL] ConnectionManager = PostgresConnectionManager [EOL] Column = PostgresColumn [EOL] [EOL] AdapterSpecificConfigs = PostgresConfig [EOL] [EOL] @ classmethod def date_function ( cls ) : [EOL] return [string] [EOL] [EOL] @ available def verify_database ( self , database ) : [EOL] if database . startswith ( [string] ) : [EOL] database = database . strip ( [string] ) [EOL] expected = self . config . credentials . database [EOL] if database . lower ( ) != expected . lower ( ) : [EOL] raise dbt . exceptions . NotImplementedException ( [string] . format ( self . type ( ) , database , expected ) ) [EOL] [comment] [EOL] return [string] [EOL] [EOL] def _link_cached_database_relations ( self , schemas ) : [EOL] [docstring] [EOL] database = self . config . credentials . database [EOL] table = self . execute_macro ( GET_RELATIONS_MACRO_NAME ) [EOL] [EOL] for ( dep_schema , dep_name , refed_schema , refed_name ) in table : [EOL] dependent = self . Relation . create ( database = database , schema = dep_schema , identifier = dep_name ) [EOL] referenced = self . Relation . create ( database = database , schema = refed_schema , identifier = refed_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if refed_schema . lower ( ) in schemas : [EOL] self . cache . add_link ( referenced , dependent ) [EOL] [EOL] def _get_catalog_schemas ( self , manifest ) : [EOL] [comment] [EOL] schemas = super ( ) . _get_catalog_schemas ( manifest ) [EOL] try : [EOL] return schemas . flatten ( ) [EOL] except dbt . exceptions . RuntimeException as exc : [EOL] dbt . exceptions . raise_compiler_error ( [string] . format ( self . type ( ) , exc . msg ) ) [EOL] [EOL] def _link_cached_relations ( self , manifest ) : [EOL] schemas = set ( ) [EOL] relations_schemas = self . _get_cache_schemas ( manifest ) [EOL] for relation in relations_schemas : [EOL] self . verify_database ( relation . database ) [EOL] schemas . add ( relation . schema . lower ( ) ) [EOL] [EOL] self . _link_cached_database_relations ( schemas ) [EOL] [EOL] def _relations_cache_for_schemas ( self , manifest ) : [EOL] super ( ) . _relations_cache_for_schemas ( manifest ) [EOL] self . _link_cached_relations ( manifest ) [EOL] [EOL] def timestamp_add_sql ( self , add_to , number = [number] , interval = [string] ) : [EOL] return f"{ add_to } [string] { number } [string] { interval } [string] " [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[plugins.postgres.dbt.adapters.postgres.impl.PostgresAdapter]$ 0 0 0 $typing.Type[plugins.postgres.dbt.adapters.postgres.impl.PostgresAdapter]$ 0 0 0 $typing.Type[plugins.postgres.dbt.adapters.postgres.impl.PostgresAdapter]$ 0 0 0 0 $typing.Type[plugins.postgres.dbt.adapters.postgres.impl.PostgresConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0
from dbt . adapters . base import Column [EOL] from dataclasses import dataclass [EOL] from dbt . adapters . base . relation import BaseRelation [EOL] from dbt . exceptions import RuntimeException [EOL] [EOL] [EOL] @ dataclass ( frozen = True , eq = False , repr = False ) class PostgresRelation ( BaseRelation ) : [EOL] def __post_init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if ( self . identifier is not None and self . type is not None and len ( self . identifier ) > self . relation_max_name_length ( ) ) : [EOL] raise RuntimeException ( f" [string] { self . identifier } [string] " f" [string] { self . relation_max_name_length ( ) } [string] " ) [EOL] [EOL] def relation_max_name_length ( self ) : [EOL] return [number] [EOL] [EOL] [EOL] class PostgresColumn ( Column ) : [EOL] @ property def data_type ( self ) : [EOL] [comment] [EOL] if self . dtype . lower ( ) == [string] : [EOL] return self . dtype [EOL] return super ( ) . data_type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Optional , Dict , Tuple [EOL] import builtins [EOL] import io [EOL] import requests [EOL] import typing [EOL] import datetime [EOL] import pytz [EOL] import base64 [EOL] import datetime [EOL] import pytz [EOL] import re [EOL] from contextlib import contextmanager [EOL] from dataclasses import dataclass [EOL] from io import StringIO [EOL] from typing import Optional [EOL] [EOL] from cryptography . hazmat . backends import default_backend [EOL] from cryptography . hazmat . primitives import serialization [EOL] import requests [EOL] import snowflake . connector [EOL] import snowflake . connector . errors [EOL] [EOL] from dbt . exceptions import ( InternalException , RuntimeException , FailedToConnectException , DatabaseException , warn_or_error ) [EOL] from dbt . adapters . base import Credentials [EOL] from dbt . adapters . sql import SQLConnectionManager [EOL] from dbt . logger import GLOBAL_LOGGER as logger [EOL] [EOL] [EOL] _TOKEN_REQUEST_URL = [string] [EOL] [EOL] [EOL] @ dataclass class SnowflakeCredentials ( Credentials ) : [EOL] account = ... [EOL] user = ... [EOL] warehouse = ... [EOL] role = ... [EOL] password = ... [EOL] authenticator = ... [EOL] private_key_path = ... [EOL] private_key_passphrase = ... [EOL] token = ... [EOL] oauth_client_id = ... [EOL] oauth_client_secret = ... [EOL] query_tag = ... [EOL] client_session_keep_alive = False [EOL] [EOL] def __post_init__ ( self ) : [EOL] if ( self . authenticator != [string] and ( self . oauth_client_secret or self . oauth_client_id or self . token ) ) : [EOL] [comment] [EOL] warn_or_error ( [string] [string] ) [EOL] [EOL] @ property def type ( self ) : [EOL] return [string] [EOL] [EOL] def _connection_keys ( self ) : [EOL] return ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def auth_args ( self ) : [EOL] [comment] [EOL] [comment] [EOL] result = { } [EOL] if self . password : [EOL] result [ [string] ] = self . password [EOL] if self . authenticator : [EOL] result [ [string] ] = self . authenticator [EOL] if self . authenticator == [string] : [EOL] token = self . token [EOL] [comment] [EOL] [comment] [EOL] if self . oauth_client_id and self . oauth_client_secret : [EOL] token = self . _get_access_token ( ) [EOL] elif self . oauth_client_id : [EOL] warn_or_error ( [string] [string] ) [EOL] elif self . oauth_client_secret : [EOL] warn_or_error ( [string] [string] ) [EOL] [EOL] result [ [string] ] = token [EOL] [comment] [EOL] result [ [string] ] = True [EOL] result [ [string] ] = self . _get_private_key ( ) [EOL] return result [EOL] [EOL] def _get_access_token ( self ) : [EOL] if self . authenticator != [string] : [EOL] raise InternalException ( [string] ) [EOL] missing = any ( x is None for x in ( self . oauth_client_id , self . oauth_client_secret , self . token ) ) [EOL] if missing : [EOL] raise InternalException ( [string] [string] ) [EOL] [comment] [EOL] token_url = _TOKEN_REQUEST_URL . format ( self . account ) [EOL] [comment] [EOL] [comment] [EOL] redirect_uri = [string] [EOL] data = { [string] : [string] , [string] : self . token , [string] : redirect_uri } [EOL] [EOL] auth = base64 . b64encode ( f'{ self . oauth_client_id } [string] { self . oauth_client_secret }' . encode ( [string] ) ) . decode ( [string] ) [EOL] headers = { [string] : f' [string] { auth }' , [string] : [string] } [EOL] result = requests . post ( token_url , headers = headers , data = data ) [EOL] result_json = result . json ( ) [EOL] if [string] not in result_json : [EOL] raise DatabaseException ( f' [string] { result_json }' ) [EOL] return result_json [ [string] ] [EOL] [EOL] def _get_private_key ( self ) : [EOL] [docstring] [EOL] if not self . private_key_path : [EOL] return None [EOL] [EOL] if self . private_key_passphrase : [EOL] encoded_passphrase = self . private_key_passphrase . encode ( ) [EOL] else : [EOL] encoded_passphrase = None [EOL] [EOL] with open ( self . private_key_path , [string] ) as key : [EOL] p_key = serialization . load_pem_private_key ( key . read ( ) , password = encoded_passphrase , backend = default_backend ( ) ) [EOL] [EOL] return p_key . private_bytes ( encoding = serialization . Encoding . DER , format = serialization . PrivateFormat . PKCS8 , encryption_algorithm = serialization . NoEncryption ( ) ) [EOL] [EOL] [EOL] class SnowflakeConnectionManager ( SQLConnectionManager ) : [EOL] TYPE = [string] [EOL] [EOL] @ contextmanager def exception_handler ( self , sql ) : [EOL] try : [EOL] yield [EOL] except snowflake . connector . errors . ProgrammingError as e : [EOL] msg = str ( e ) [EOL] [EOL] logger . debug ( [string] . format ( e . sfqid ) ) [EOL] logger . debug ( [string] . format ( msg ) ) [EOL] [EOL] if [string] in msg : [EOL] logger . debug ( [string] ) [EOL] elif [string] in msg : [EOL] raise FailedToConnectException ( ( [string] [string] [string] [string] ) . format ( msg ) ) [EOL] else : [EOL] raise DatabaseException ( msg ) [EOL] except Exception as e : [EOL] if isinstance ( e , snowflake . connector . errors . Error ) : [EOL] logger . debug ( [string] . format ( e . sfqid ) ) [EOL] [EOL] logger . debug ( [string] , sql ) [EOL] logger . debug ( [string] ) [EOL] self . rollback_if_open ( ) [EOL] if isinstance ( e , RuntimeException ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] raise [EOL] raise RuntimeException ( str ( e ) ) from e [EOL] [EOL] @ classmethod def open ( cls , connection ) : [EOL] if connection . state == [string] : [EOL] logger . debug ( [string] ) [EOL] return connection [EOL] [EOL] try : [EOL] creds = connection . credentials [EOL] [EOL] handle = snowflake . connector . connect ( account = creds . account , user = creds . user , database = creds . database , schema = creds . schema , warehouse = creds . warehouse , role = creds . role , autocommit = False , client_session_keep_alive = creds . client_session_keep_alive , application = [string] , ** creds . auth_args ( ) ) [EOL] [EOL] if creds . query_tag : [EOL] handle . cursor ( ) . execute ( ( [string] ) . format ( creds . query_tag ) ) [EOL] [EOL] connection . handle = handle [EOL] connection . state = [string] [EOL] except snowflake . connector . errors . Error as e : [EOL] logger . debug ( [string] [string] . format ( e ) ) [EOL] [EOL] connection . handle = None [EOL] connection . state = [string] [EOL] [EOL] raise FailedToConnectException ( str ( e ) ) [EOL] [EOL] def cancel ( self , connection ) : [EOL] handle = connection . handle [EOL] sid = handle . session_id [EOL] [EOL] connection_name = connection . name [EOL] [EOL] sql = [string] . format ( sid ) [EOL] [EOL] logger . debug ( [string] . format ( connection_name , sid ) ) [EOL] [EOL] _ , cursor = self . add_query ( sql ) [EOL] res = cursor . fetchone ( ) [EOL] [EOL] logger . debug ( [string] . format ( connection_name , res ) ) [EOL] [EOL] @ classmethod def get_status ( cls , cursor ) : [EOL] state = cursor . sqlstate [EOL] [EOL] if state is None : [EOL] state = [string] [EOL] [EOL] return [string] . format ( state , cursor . rowcount ) [EOL] [EOL] @ classmethod def _split_queries ( cls , sql ) : [EOL] [docstring] [EOL] [EOL] sql_s = str ( sql ) [EOL] sql_buf = StringIO ( sql_s ) [EOL] split_query = snowflake . connector . util_text . split_statements ( sql_buf ) [EOL] return [ part [ [number] ] for part in split_query ] [EOL] [EOL] @ classmethod def process_results ( cls , column_names , rows ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] fixed = [ ] [EOL] for row in rows : [EOL] fixed_row = [ ] [EOL] for col in row : [EOL] if isinstance ( col , datetime . datetime ) and col . tzinfo : [EOL] offset = col . utcoffset ( ) [EOL] offset_seconds = offset . total_seconds ( ) [EOL] new_timezone = pytz . FixedOffset ( offset_seconds // [number] ) [EOL] col = col . astimezone ( tz = new_timezone ) [EOL] fixed_row . append ( col ) [EOL] [EOL] fixed . append ( fixed_row ) [EOL] [EOL] return super ( ) . process_results ( column_names , fixed ) [EOL] [EOL] def add_query ( self , sql , auto_begin = True , bindings = None , abridge_sql_log = False ) : [EOL] [EOL] connection = None [EOL] cursor = None [EOL] [EOL] if bindings : [EOL] [comment] [EOL] [comment] [EOL] bindings = tuple ( bindings ) [EOL] [EOL] queries = self . _split_queries ( sql ) [EOL] [EOL] for individual_query in queries : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] without_comments = re . sub ( re . compile ( [string] , re . MULTILINE ) , [string] , individual_query ) . strip ( ) [EOL] [EOL] if without_comments == [string] : [EOL] continue [EOL] [EOL] connection , cursor = super ( ) . add_query ( individual_query , auto_begin , bindings = bindings , abridge_sql_log = abridge_sql_log ) [EOL] [EOL] if cursor is None : [EOL] conn = self . get_thread_connection ( ) [EOL] if conn is None or conn . name is None : [EOL] conn_name = [string] [EOL] else : [EOL] conn_name = conn . name [EOL] [EOL] raise RuntimeException ( [string] [string] [string] [string] . format ( conn_name , sql ) ) [EOL] [EOL] return connection , cursor [EOL] [EOL] @ classmethod def _rollback_handle ( cls , connection ) : [EOL] [docstring] [EOL] try : [EOL] connection . handle . rollback ( ) [EOL] except snowflake . connector . errors . ProgrammingError as e : [EOL] msg = str ( e ) [EOL] if [string] not in msg : [EOL] raise [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $io.StringIO$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 $typing.Optional[datetime.timedelta]$ 0 $datetime.datetime$ 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[datetime.timedelta]$ 0 0 0 0 0 $typing.Union[datetime.tzinfo,pytz._UTCclass]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 $typing.Union[datetime.tzinfo,pytz._UTCclass]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $datetime.datetime$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
version = [string] [EOL]	$builtins.str$ 0 0 0
import builtins [EOL] from dataclasses import dataclass [EOL] [EOL] from dbt . adapters . base . column import Column [EOL] from dbt . exceptions import RuntimeException [EOL] [EOL] [EOL] @ dataclass class SnowflakeColumn ( Column ) : [EOL] def is_integer ( self ) : [EOL] [comment] [EOL] return False [EOL] [EOL] def is_numeric ( self ) : [EOL] return self . dtype . lower ( ) in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def is_float ( self ) : [EOL] return self . dtype . lower ( ) in [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] def string_size ( self ) : [EOL] if not self . is_string ( ) : [EOL] raise RuntimeException ( [string] ) [EOL] [EOL] if self . dtype == [string] or self . char_size is None : [EOL] return [number] [EOL] else : [EOL] return int ( self . char_size ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from dataclasses import dataclass [EOL] from dbt . adapters . base . relation import BaseRelation , Policy [EOL] [EOL] [EOL] @ dataclass class SnowflakeQuotePolicy ( Policy ) : [EOL] database = False [EOL] schema = False [EOL] identifier = False [EOL] [EOL] [EOL] @ dataclass ( frozen = True , eq = False , repr = False ) class SnowflakeRelation ( BaseRelation ) : [EOL] quote_policy = SnowflakeQuotePolicy ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SnowflakeQuotePolicy$ 0 0 0 0 0
import os [EOL] PACKAGE_PATH = os . path . dirname ( __file__ ) [EOL]	0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0